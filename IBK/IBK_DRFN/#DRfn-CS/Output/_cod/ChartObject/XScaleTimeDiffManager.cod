; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30145.0 

	TITLE	D:\git\src\IBK\IBK_DRFN\#DRfn-CS\_Obj\ChartObject\XScaleTimeDiffManager.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

CONST	SEGMENT
?_Fake_alloc@std@@3U_Fake_allocator@1@B	ORG $+1		; std::_Fake_alloc
CONST	ENDS
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	??1exception@std@@UAE@XZ			; std::exception::~exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?_Throw_tree_length_error@std@@YAXXZ		; std::_Throw_tree_length_error
PUBLIC	?_Xlen_string@std@@YAXXZ			; std::_Xlen_string
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	??0CXScaleTimeDiffManager@@QAE@XZ		; CXScaleTimeDiffManager::CXScaleTimeDiffManager
PUBLIC	??0CXScaleTimeDiffManager@@QAE@PAVCXScaleManagerImp@@@Z ; CXScaleTimeDiffManager::CXScaleTimeDiffManager
PUBLIC	??1CXScaleTimeDiffManager@@UAE@XZ		; CXScaleTimeDiffManager::~CXScaleTimeDiffManager
PUBLIC	?SetXScaleManagerImp@CXScaleTimeDiffManager@@QAEXPAVCXScaleManagerImp@@@Z ; CXScaleTimeDiffManager::SetXScaleManagerImp
PUBLIC	??R?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0@Z ; std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator()
PUBLIC	?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@2@QAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Insert_node
PUBLIC	??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE@XZ ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::~map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >
PUBLIC	?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@PAX@std@@@2@QAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,tm> > >::_Insert_node
PUBLIC	??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@@2@@std@@QAE@XZ ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,tm,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,tm> > >::~map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,tm,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,tm> > >
PUBLIC	?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@PAX@std@@@2@QAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,__int64> > >::_Insert_node
PUBLIC	?InitRQDiffTime@CXScaleTimeDiffManager@@QAEXXZ	; CXScaleTimeDiffManager::InitRQDiffTime
PUBLIC	?InitRQMarketTime@CXScaleTimeDiffManager@@QAEXXZ ; CXScaleTimeDiffManager::InitRQMarketTime
PUBLIC	?SetRQDiffTime@CXScaleTimeDiffManager@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H_J@Z ; CXScaleTimeDiffManager::SetRQDiffTime
PUBLIC	?SetRQMarketTime@CXScaleTimeDiffManager@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HHW4MARKETDAYTYPE@CPacketType@@@Z ; CXScaleTimeDiffManager::SetRQMarketTime
PUBLIC	?SetScreenDiffTime@CXScaleTimeDiffManager@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z ; CXScaleTimeDiffManager::SetScreenDiffTime
PUBLIC	?SetCurrentRQ@CXScaleTimeDiffManager@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ; CXScaleTimeDiffManager::SetCurrentRQ
PUBLIC	?GetRQScreenTime@CXScaleTimeDiffManager@@QAE_JV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAUtm@@@Z ; CXScaleTimeDiffManager::GetRQScreenTime
PUBLIC	?GetRQScreenDateTime@CXScaleTimeDiffManager@@QAE_JV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@_J@Z ; CXScaleTimeDiffManager::GetRQScreenDateTime
PUBLIC	?CalcCurrentDateTimToPacketTime@CXScaleTimeDiffManager@@QAEPAUtm@@V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ; CXScaleTimeDiffManager::CalcCurrentDateTimToPacketTime
PUBLIC	??_GCXScaleTimeDiffManager@@UAEPAXI@Z		; CXScaleTimeDiffManager::`scalar deleting destructor'
PUBLIC	??1?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@QAE@XZ ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int>::~pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int>
PUBLIC	??1?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@QAE@XZ ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,tm>::~pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,tm>
PUBLIC	??1?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@QAE@XZ ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,__int64>::~pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,__int64>
PUBLIC	??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,__int64> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,__int64>,void *> > >
PUBLIC	??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> > >
PUBLIC	??$_Find_lower_bound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_JU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@PAX@std@@@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,__int64,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,__int64> >,0> >::_Find_lower_bound<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,tm> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,tm>,void *> > >
PUBLIC	??$_Find_lower_bound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Find_lower_bound<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$_Emplace@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@PAX@std@@_N@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,tm,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,tm> >,0> >::_Emplace<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,tm> >
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??$?MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> > >
PUBLIC	??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,tm>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,tm>,void *> > >
PUBLIC	??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,__int64>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,__int64>,void *> > >
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_C@_0BB@GCADKGJO@map?1set?5too?5long@		; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	??_7CXScaleTimeDiffManager@@6B@			; CXScaleTimeDiffManager::`vftable'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4CXScaleTimeDiffManager@@6B@		; CXScaleTimeDiffManager::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCXScaleTimeDiffManager@@@8		; CXScaleTimeDiffManager `RTTI Type Descriptor'
PUBLIC	??_R3CXScaleTimeDiffManager@@8			; CXScaleTimeDiffManager::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CXScaleTimeDiffManager@@8			; CXScaleTimeDiffManager::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CXScaleTimeDiffManager@@8		; CXScaleTimeDiffManager::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	__imp___invalid_parameter_noinfo_noreturn:PROC
EXTRN	__imp___mktime64:PROC
EXTRN	__imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ:PROC
EXTRN	__imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z:PROC
EXTRN	__imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ:PROC
EXTRN	__imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z:PROC
EXTRN	__imp_?Compare@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEHPBD@Z:PROC
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	??_ECXScaleTimeDiffManager@@UAEPAXI@Z:PROC	; CXScaleTimeDiffManager::`vector deleting destructor'
EXTRN	?CalcCurrentDateTimToPacketTime@CDataConversion@@SAPAUtm@@H@Z:PROC ; CDataConversion::CalcCurrentDateTimToPacketTime
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__alldiv:PROC
EXTRN	__allmul:PROC
EXTRN	__aulldvrm:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___security_cookie:DWORD
;	COMDAT ??_R1A@?0A@EA@CXScaleTimeDiffManager@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CXScaleTimeDiffManager@@8 DD FLAT:??_R0?AVCXScaleTimeDiffManager@@@8 ; CXScaleTimeDiffManager::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CXScaleTimeDiffManager@@8
rdata$r	ENDS
;	COMDAT ??_R2CXScaleTimeDiffManager@@8
rdata$r	SEGMENT
??_R2CXScaleTimeDiffManager@@8 DD FLAT:??_R1A@?0A@EA@CXScaleTimeDiffManager@@8 ; CXScaleTimeDiffManager::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CXScaleTimeDiffManager@@8
rdata$r	SEGMENT
??_R3CXScaleTimeDiffManager@@8 DD 00H			; CXScaleTimeDiffManager::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CXScaleTimeDiffManager@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCXScaleTimeDiffManager@@@8
data$rs	SEGMENT
??_R0?AVCXScaleTimeDiffManager@@@8 DD FLAT:??_7type_info@@6B@ ; CXScaleTimeDiffManager `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCXScaleTimeDiffManager@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CXScaleTimeDiffManager@@6B@
rdata$r	SEGMENT
??_R4CXScaleTimeDiffManager@@6B@ DD 00H			; CXScaleTimeDiffManager::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCXScaleTimeDiffManager@@@8
	DD	FLAT:??_R3CXScaleTimeDiffManager@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_7CXScaleTimeDiffManager@@6B@
CONST	SEGMENT
??_7CXScaleTimeDiffManager@@6B@ DD FLAT:??_R4CXScaleTimeDiffManager@@6B@ ; CXScaleTimeDiffManager::`vftable'
	DD	FLAT:??_ECXScaleTimeDiffManager@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GCADKGJO@map?1set?5too?5long@
CONST	SEGMENT
??_C@_0BB@GCADKGJO@map?1set?5too?5long@ DB 'map/set too long', 00H ; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$?0U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@PAX@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?0U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@PAX@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@1@@Z$1
__ehfuncinfo$??$?0U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@PAX@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?0U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@PAX@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@PAX@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@PAX@std@@@1@@Z$0
__ehfuncinfo$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@PAX@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@PAX@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$?0U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@PAX@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?0U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@PAX@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@1@@Z$1
__ehfuncinfo$??$?0U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@PAX@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?0U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@PAX@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@PAX@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@PAX@std@@@1@@Z$0
__ehfuncinfo$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@PAX@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@PAX@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$?0U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?0U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@@Z$1
__ehfuncinfo$??$?0U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?0U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@1@@Z$0
__ehfuncinfo$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Emplace@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_JU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@PAX@std@@_N@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Emplace@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_JU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@PAX@std@@_N@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@1@@Z$2
__ehfuncinfo$??$_Emplace@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_JU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@PAX@std@@_N@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Emplace@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_JU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@PAX@std@@_N@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Emplace@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@PAX@std@@_N@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Emplace@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@PAX@std@@_N@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@1@@Z$2
__ehfuncinfo$??$_Emplace@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@PAX@std@@_N@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Emplace@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@PAX@std@@_N@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Emplace@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@_N@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Emplace@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@_N@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@@Z$2
__ehfuncinfo$??$_Emplace@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@_N@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Emplace@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@_N@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$emplace@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_JU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$emplace@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_JU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@1@@Z$2
__ehfuncinfo$??$emplace@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_JU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$emplace@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_JU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$emplace@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$emplace@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@@Z$2
__ehfuncinfo$??$emplace@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$emplace@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$insert@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@$0A@@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_JU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$insert@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@$0A@@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_JU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@1@@Z$2
__ehfuncinfo$??$insert@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@$0A@@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_JU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$insert@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@$0A@@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_JU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$insert@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@$0A@@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$insert@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@$0A@@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@@Z$2
__ehfuncinfo$??$insert@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@$0A@@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$insert@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@$0A@@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?CalcCurrentDateTimToPacketTime@CXScaleTimeDiffManager@@QAEPAUtm@@V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CalcCurrentDateTimToPacketTime@CXScaleTimeDiffManager@@QAEPAUtm@@V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?CalcCurrentDateTimToPacketTime@CXScaleTimeDiffManager@@QAEPAUtm@@V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z$1
__ehfuncinfo$?CalcCurrentDateTimToPacketTime@CXScaleTimeDiffManager@@QAEPAUtm@@V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?CalcCurrentDateTimToPacketTime@CXScaleTimeDiffManager@@QAEPAUtm@@V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?GetRQScreenDateTime@CXScaleTimeDiffManager@@QAE_JV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@_J@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetRQScreenDateTime@CXScaleTimeDiffManager@@QAE_JV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@_J@Z$0
__ehfuncinfo$?GetRQScreenDateTime@CXScaleTimeDiffManager@@QAE_JV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@_J@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetRQScreenDateTime@CXScaleTimeDiffManager@@QAE_JV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@_J@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?GetRQScreenTime@CXScaleTimeDiffManager@@QAE_JV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAUtm@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetRQScreenTime@CXScaleTimeDiffManager@@QAE_JV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAUtm@@@Z$0
__ehfuncinfo$?GetRQScreenTime@CXScaleTimeDiffManager@@QAE_JV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAUtm@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetRQScreenTime@CXScaleTimeDiffManager@@QAE_JV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAUtm@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?SetCurrentRQ@CXScaleTimeDiffManager@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SetCurrentRQ@CXScaleTimeDiffManager@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?SetCurrentRQ@CXScaleTimeDiffManager@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?SetCurrentRQ@CXScaleTimeDiffManager@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z$5
__ehfuncinfo$?SetCurrentRQ@CXScaleTimeDiffManager@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?SetCurrentRQ@CXScaleTimeDiffManager@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?SetScreenDiffTime@CXScaleTimeDiffManager@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SetScreenDiffTime@CXScaleTimeDiffManager@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z$0
__ehfuncinfo$?SetScreenDiffTime@CXScaleTimeDiffManager@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SetScreenDiffTime@CXScaleTimeDiffManager@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?SetRQMarketTime@CXScaleTimeDiffManager@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HHW4MARKETDAYTYPE@CPacketType@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SetRQMarketTime@CXScaleTimeDiffManager@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HHW4MARKETDAYTYPE@CPacketType@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?SetRQMarketTime@CXScaleTimeDiffManager@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HHW4MARKETDAYTYPE@CPacketType@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?SetRQMarketTime@CXScaleTimeDiffManager@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HHW4MARKETDAYTYPE@CPacketType@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?SetRQMarketTime@CXScaleTimeDiffManager@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HHW4MARKETDAYTYPE@CPacketType@@@Z$10
__ehfuncinfo$?SetRQMarketTime@CXScaleTimeDiffManager@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HHW4MARKETDAYTYPE@CPacketType@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?SetRQMarketTime@CXScaleTimeDiffManager@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HHW4MARKETDAYTYPE@CPacketType@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0242H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?SetRQDiffTime@CXScaleTimeDiffManager@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H_J@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?SetRQDiffTime@CXScaleTimeDiffManager@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H_J@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?SetRQDiffTime@CXScaleTimeDiffManager@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H_J@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SetRQDiffTime@CXScaleTimeDiffManager@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H_J@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?SetRQDiffTime@CXScaleTimeDiffManager@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H_J@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?SetRQDiffTime@CXScaleTimeDiffManager@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H_J@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?SetRQDiffTime@CXScaleTimeDiffManager@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H_J@Z$11
	DD	01H
	DD	FLAT:__unwindfunclet$?SetRQDiffTime@CXScaleTimeDiffManager@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H_J@Z$3
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CXScaleTimeDiffManager@@QAE@PAVCXScaleManagerImp@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CXScaleTimeDiffManager@@QAE@PAVCXScaleManagerImp@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CXScaleTimeDiffManager@@QAE@PAVCXScaleManagerImp@@@Z$1
__ehfuncinfo$??0CXScaleTimeDiffManager@@QAE@PAVCXScaleManagerImp@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0CXScaleTimeDiffManager@@QAE@PAVCXScaleManagerImp@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CXScaleTimeDiffManager@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CXScaleTimeDiffManager@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CXScaleTimeDiffManager@@QAE@XZ$1
__ehfuncinfo$??0CXScaleTimeDiffManager@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0CXScaleTimeDiffManager@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,__int64>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,__int64>,void *> > >, COMDAT
; _this$ = ecx

; 970  :         if (_Ptr) {

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	85 c0		 test	 eax, eax
  00005	74 0b		 je	 SHORT $LN8@Alloc_cons

; 255  :         ::operator delete(_Ptr, _Bytes);

  00007	6a 30		 push	 48			; 00000030H
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000f	83 c4 08	 add	 esp, 8
$LN8@Alloc_cons:

; 971  :             _Al.deallocate(_Ptr, 1);
; 972  :         }
; 973  :     }

  00012	c3		 ret	 0
??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,__int64>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,__int64>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,tm>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,tm>,void *> > >, COMDAT
; _this$ = ecx

; 970  :         if (_Ptr) {

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	85 c0		 test	 eax, eax
  00005	74 0b		 je	 SHORT $LN8@Alloc_cons

; 255  :         ::operator delete(_Ptr, _Bytes);

  00007	6a 4c		 push	 76			; 0000004cH
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000f	83 c4 08	 add	 esp, 8
$LN8@Alloc_cons:

; 971  :             _Al.deallocate(_Ptr, 1);
; 972  :         }
; 973  :     }

  00012	c3		 ret	 0
??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,tm>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,tm>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> > >, COMDAT
; _this$ = ecx

; 970  :         if (_Ptr) {

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	85 c0		 test	 eax, eax
  00005	74 0b		 je	 SHORT $LN8@Alloc_cons

; 255  :         ::operator delete(_Ptr, _Bytes);

  00007	6a 2c		 push	 44			; 0000002cH
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000f	83 c4 08	 add	 esp, 8
$LN8@Alloc_cons:

; 971  :             _Al.deallocate(_Ptr, 1);
; 972  :         }
; 973  :     }

  00012	c3		 ret	 0
??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??$?MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z PROC ; std::operator<<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 4808 :     const basic_string<_Elem, _Traits, _Alloc>& _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2272 :         const value_type* _Result = _Bx._Buf;

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	8b c8		 mov	 ecx, eax

; 2286 :         return _BUF_SIZE <= _Myres;

  00008	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 2273 :         if (_Large_string_engaged()) {

  0000c	72 02		 jb	 SHORT $LN6@operator

; 2274 :             _Result = _Unfancy(_Bx._Ptr);

  0000e	8b 08		 mov	 ecx, DWORD PTR [eax]
$LN6@operator:
  00010	53		 push	 ebx
  00011	56		 push	 esi

; 2272 :         const value_type* _Result = _Bx._Buf;

  00012	8b 75 08	 mov	 esi, DWORD PTR __Left$[ebp]
  00015	8b d6		 mov	 edx, esi
  00017	57		 push	 edi

; 2286 :         return _BUF_SIZE <= _Myres;

  00018	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 2273 :         if (_Large_string_engaged()) {

  0001c	72 02		 jb	 SHORT $LN11@operator

; 2274 :             _Result = _Unfancy(_Bx._Ptr);

  0001e	8b 16		 mov	 edx, DWORD PTR [esi]
$LN11@operator:

; 4380 :         return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

  00020	8b 5e 10	 mov	 ebx, DWORD PTR [esi+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 66   :     return _Right < _Left ? _Right : _Left;

  00023	8b f3		 mov	 esi, ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4380 :         return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

  00025	8b 78 10	 mov	 edi, DWORD PTR [eax+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 66   :     return _Right < _Left ? _Right : _Left;

  00028	3b fb		 cmp	 edi, ebx
  0002a	0f 42 f7	 cmovb	 esi, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 384  :         return _CSTD memcmp(_First1, _First2, _Count);

  0002d	83 ee 04	 sub	 esi, 4
  00030	72 11		 jb	 SHORT $LN26@operator
$LL27@operator:
  00032	8b 02		 mov	 eax, DWORD PTR [edx]
  00034	3b 01		 cmp	 eax, DWORD PTR [ecx]
  00036	75 10		 jne	 SHORT $LN25@operator
  00038	83 c2 04	 add	 edx, 4
  0003b	83 c1 04	 add	 ecx, 4
  0003e	83 ee 04	 sub	 esi, 4
  00041	73 ef		 jae	 SHORT $LL27@operator
$LN26@operator:
  00043	83 fe fc	 cmp	 esi, -4			; fffffffcH
  00046	74 34		 je	 SHORT $LN24@operator
$LN25@operator:
  00048	8a 02		 mov	 al, BYTE PTR [edx]
  0004a	3a 01		 cmp	 al, BYTE PTR [ecx]
  0004c	75 27		 jne	 SHORT $LN28@operator
  0004e	83 fe fd	 cmp	 esi, -3			; fffffffdH
  00051	74 29		 je	 SHORT $LN24@operator
  00053	8a 42 01	 mov	 al, BYTE PTR [edx+1]
  00056	3a 41 01	 cmp	 al, BYTE PTR [ecx+1]
  00059	75 1a		 jne	 SHORT $LN28@operator
  0005b	83 fe fe	 cmp	 esi, -2			; fffffffeH
  0005e	74 1c		 je	 SHORT $LN24@operator
  00060	8a 42 02	 mov	 al, BYTE PTR [edx+2]
  00063	3a 41 02	 cmp	 al, BYTE PTR [ecx+2]
  00066	75 0d		 jne	 SHORT $LN28@operator
  00068	83 fe ff	 cmp	 esi, -1
  0006b	74 0f		 je	 SHORT $LN24@operator
  0006d	8a 42 03	 mov	 al, BYTE PTR [edx+3]
  00070	3a 41 03	 cmp	 al, BYTE PTR [ecx+3]
  00073	74 07		 je	 SHORT $LN24@operator
$LN28@operator:
  00075	1b c0		 sbb	 eax, eax
  00077	83 c8 01	 or	 eax, 1
  0007a	eb 02		 jmp	 SHORT $LN29@operator
$LN24@operator:
  0007c	33 c0		 xor	 eax, eax
$LN29@operator:

; 580  :     if (_Ans != 0) {

  0007e	85 c0		 test	 eax, eax
  00080	75 13		 jne	 SHORT $LN18@operator

; 581  :         return _Ans;
; 582  :     }
; 583  : 
; 584  :     if (_Left_size < _Right_size) {

  00082	3b fb		 cmp	 edi, ebx
  00084	76 0b		 jbe	 SHORT $LN30@operator

; 4809 :     return _Left.compare(_Right) < 0;

  00086	5f		 pop	 edi

; 585  :         return -1;

  00087	83 c8 ff	 or	 eax, -1

; 4809 :     return _Left.compare(_Right) < 0;

  0008a	5e		 pop	 esi
  0008b	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0008e	5b		 pop	 ebx

; 4810 : }

  0008f	5d		 pop	 ebp
  00090	c3		 ret	 0
$LN30@operator:

; 588  :     if (_Left_size > _Right_size) {

  00091	1b c0		 sbb	 eax, eax
  00093	f7 d8		 neg	 eax
$LN18@operator:

; 4809 :     return _Left.compare(_Right) < 0;

  00095	5f		 pop	 edi
  00096	5e		 pop	 esi
  00097	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0009a	5b		 pop	 ebx

; 4810 : }

  0009b	5d		 pop	 ebp
  0009c	c3		 ret	 0
??$?MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ENDP ; std::operator<<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 127  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 128  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 129  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00006	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]

; 130  :     if (_Block_size <= _Bytes) {

  00009	3b c8		 cmp	 ecx, eax
  0000b	0f 86 00 00 00
	00		 jbe	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length

; 79   :         return ::operator new(_Bytes);

  00011	51		 push	 ecx
  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 131  :         _Throw_bad_array_new_length(); // add overflow
; 132  :     }
; 133  : 
; 134  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00017	8b c8		 mov	 ecx, eax

; 79   :         return ::operator new(_Bytes);

  00019	83 c4 04	 add	 esp, 4

; 135  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0001c	85 c9		 test	 ecx, ecx
  0001e	74 0b		 je	 SHORT $LN7@Allocate_m

; 136  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  00020	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00023	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 137  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00026	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 138  : 
; 139  : #ifdef _DEBUG
; 140  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 141  : #endif // _DEBUG
; 142  :     return _Ptr;
; 143  : }

  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
$LN7@Allocate_m:

; 135  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0002b	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ??$_Emplace@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@PAX@std@@_N@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@1@@Z
_TEXT	SEGMENT
__Myhead$1$ = -44					; size = 4
$T3 = -40						; size = 8
tv1025 = -36						; size = 4
tv1023 = -32						; size = 4
__Loc$1$ = -28						; size = 4
_this$1$ = -24						; size = 4
$T1$sroa$480$1$ = -20					; size = 4
__Trynode$1$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_<_Vals_0>$ = 12					; size = 4
??$_Emplace@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@PAX@std@@_N@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,tm,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,tm> >,0> >::_Emplace<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,tm> >, COMDAT
; _this$ = ecx

; 999  :     pair<_Nodeptr, bool> _Emplace(_Valtys&&... _Vals) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Emplace@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@PAX@std@@_N@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 20	 sub	 esp, 32			; 00000020H
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	50		 push	 eax
  0001e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00027	8b d1		 mov	 edx, ecx
  00029	89 55 e8	 mov	 DWORD PTR _this$1$[ebp], edx

; 1597 :         _Tree_find_result<_Nodeptr> _Result{{_Scary->_Myhead->_Parent, _Tree_child::_Right}, _Scary->_Myhead};

  0002c	8b 02		 mov	 eax, DWORD PTR [edx]
  0002e	33 f6		 xor	 esi, esi
  00030	8b c8		 mov	 ecx, eax
  00032	89 45 d4	 mov	 DWORD PTR __Myhead$1$[ebp], eax
  00035	89 4d ec	 mov	 DWORD PTR $T1$sroa$480$1$[ebp], ecx
  00038	8b 78 04	 mov	 edi, DWORD PTR [eax+4]
  0003b	89 7d e4	 mov	 DWORD PTR __Loc$1$[ebp], edi

; 1598 :         _Nodeptr _Trynode = _Result._Location._Parent;
; 1599 :         while (!_Trynode->_Isnil) {

  0003e	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  00042	0f 85 da 00 00
	00		 jne	 $LN7@Emplace
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2286 :         return _BUF_SIZE <= _Myres;

  00048	8b 55 0c	 mov	 edx, DWORD PTR _<_Vals_0>$[ebp]

; 4380 :         return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

  0004b	89 7d f0	 mov	 DWORD PTR __Trynode$1$[ebp], edi

; 2286 :         return _BUF_SIZE <= _Myres;

  0004e	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00051	89 45 e0	 mov	 DWORD PTR tv1023[ebp], eax
$LL6@Emplace:

; 2273 :         if (_Large_string_engaged()) {

  00054	83 7d e0 10	 cmp	 DWORD PTR tv1023[ebp], 16 ; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1600 :             _Result._Location._Parent = _Trynode;

  00058	89 7d e4	 mov	 DWORD PTR __Loc$1$[ebp], edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2273 :         if (_Large_string_engaged()) {

  0005b	72 05		 jb	 SHORT $LN18@Emplace

; 2274 :             _Result = _Unfancy(_Bx._Ptr);

  0005d	8b 45 0c	 mov	 eax, DWORD PTR _<_Vals_0>$[ebp]
  00060	8b 10		 mov	 edx, DWORD PTR [eax]
$LN18@Emplace:

; 2273 :         if (_Large_string_engaged()) {

  00062	83 7f 24 10	 cmp	 DWORD PTR [edi+36], 16	; 00000010H
  00066	8d 47 10	 lea	 eax, DWORD PTR [edi+16]
  00069	72 03		 jb	 SHORT $LN23@Emplace

; 2274 :             _Result = _Unfancy(_Bx._Ptr);

  0006b	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
$LN23@Emplace:

; 4380 :         return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

  0006e	8b 4f 20	 mov	 ecx, DWORD PTR [edi+32]

; 578  :     const int _Ans = _Traits::compare(_Left, _Right, (_STD min)(_Left_size, _Right_size));

  00071	8b f1		 mov	 esi, ecx
  00073	8b 7d 0c	 mov	 edi, DWORD PTR _<_Vals_0>$[ebp]

; 4380 :         return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

  00076	89 4d dc	 mov	 DWORD PTR tv1025[ebp], ecx

; 578  :     const int _Ans = _Traits::compare(_Left, _Right, (_STD min)(_Left_size, _Right_size));

  00079	39 4f 10	 cmp	 DWORD PTR [edi+16], ecx
  0007c	8b cf		 mov	 ecx, edi

; 384  :         return _CSTD memcmp(_First1, _First2, _Count);

  0007e	8b 7d f0	 mov	 edi, DWORD PTR __Trynode$1$[ebp]

; 578  :     const int _Ans = _Traits::compare(_Left, _Right, (_STD min)(_Left_size, _Right_size));

  00081	0f 42 71 10	 cmovb	 esi, DWORD PTR [ecx+16]

; 384  :         return _CSTD memcmp(_First1, _First2, _Count);

  00085	83 ee 04	 sub	 esi, 4
  00088	72 17		 jb	 SHORT $LN158@Emplace
  0008a	66 0f 1f 44 00
	00		 npad	 6
$LL159@Emplace:
  00090	8b 08		 mov	 ecx, DWORD PTR [eax]
  00092	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  00094	75 10		 jne	 SHORT $LN157@Emplace
  00096	83 c0 04	 add	 eax, 4
  00099	83 c2 04	 add	 edx, 4
  0009c	83 ee 04	 sub	 esi, 4
  0009f	73 ef		 jae	 SHORT $LL159@Emplace
$LN158@Emplace:
  000a1	83 fe fc	 cmp	 esi, -4			; fffffffcH
  000a4	74 34		 je	 SHORT $LN156@Emplace
$LN157@Emplace:
  000a6	8a 08		 mov	 cl, BYTE PTR [eax]
  000a8	3a 0a		 cmp	 cl, BYTE PTR [edx]
  000aa	75 27		 jne	 SHORT $LN160@Emplace
  000ac	83 fe fd	 cmp	 esi, -3			; fffffffdH
  000af	74 29		 je	 SHORT $LN156@Emplace
  000b1	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  000b4	3a 4a 01	 cmp	 cl, BYTE PTR [edx+1]
  000b7	75 1a		 jne	 SHORT $LN160@Emplace
  000b9	83 fe fe	 cmp	 esi, -2			; fffffffeH
  000bc	74 1c		 je	 SHORT $LN156@Emplace
  000be	8a 48 02	 mov	 cl, BYTE PTR [eax+2]
  000c1	3a 4a 02	 cmp	 cl, BYTE PTR [edx+2]
  000c4	75 0d		 jne	 SHORT $LN160@Emplace
  000c6	83 fe ff	 cmp	 esi, -1
  000c9	74 0f		 je	 SHORT $LN156@Emplace
  000cb	8a 40 03	 mov	 al, BYTE PTR [eax+3]
  000ce	3a 42 03	 cmp	 al, BYTE PTR [edx+3]
  000d1	74 07		 je	 SHORT $LN156@Emplace
$LN160@Emplace:
  000d3	1b c0		 sbb	 eax, eax
  000d5	83 c8 01	 or	 eax, 1
  000d8	eb 02		 jmp	 SHORT $LN161@Emplace
$LN156@Emplace:
  000da	33 c0		 xor	 eax, eax
$LN161@Emplace:

; 580  :     if (_Ans != 0) {

  000dc	8b 55 0c	 mov	 edx, DWORD PTR _<_Vals_0>$[ebp]
  000df	85 c0		 test	 eax, eax
  000e1	75 13		 jne	 SHORT $LN30@Emplace

; 581  :         return _Ans;
; 582  :     }
; 583  : 
; 584  :     if (_Left_size < _Right_size) {

  000e3	8b 45 dc	 mov	 eax, DWORD PTR tv1025[ebp]
  000e6	8b 4a 10	 mov	 ecx, DWORD PTR [edx+16]
  000e9	3b c8		 cmp	 ecx, eax
  000eb	76 05		 jbe	 SHORT $LN165@Emplace

; 585  :         return -1;

  000ed	83 c8 ff	 or	 eax, -1
  000f0	eb 04		 jmp	 SHORT $LN30@Emplace
$LN165@Emplace:

; 586  :     }
; 587  : 
; 588  :     if (_Left_size > _Right_size) {

  000f2	1b c0		 sbb	 eax, eax
  000f4	f7 d8		 neg	 eax
$LN30@Emplace:

; 4809 :     return _Left.compare(_Right) < 0;

  000f6	c1 e8 1f	 shr	 eax, 31			; 0000001fH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1601 :             if (_DEBUG_LT_PRED(_Getcomp(), _Traits::_Kfn(_Trynode->_Myval), _Keyval)) {

  000f9	84 c0		 test	 al, al
  000fb	74 08		 je	 SHORT $LN8@Emplace

; 1602 :                 _Result._Location._Child = _Tree_child::_Right;
; 1603 :                 _Trynode                 = _Trynode->_Right;

  000fd	8b 7f 08	 mov	 edi, DWORD PTR [edi+8]

; 1604 :             } else {

  00100	8b 4d ec	 mov	 ecx, DWORD PTR $T1$sroa$480$1$[ebp]
  00103	eb 07		 jmp	 SHORT $LN166@Emplace
$LN8@Emplace:

; 1605 :                 _Result._Location._Child = _Tree_child::_Left;
; 1606 :                 _Result._Bound           = _Trynode;

  00105	8b cf		 mov	 ecx, edi

; 1607 :                 _Trynode                 = _Trynode->_Left;

  00107	8b 3f		 mov	 edi, DWORD PTR [edi]
  00109	89 4d ec	 mov	 DWORD PTR $T1$sroa$480$1$[ebp], ecx
$LN166@Emplace:

; 1598 :         _Nodeptr _Trynode = _Result._Location._Parent;
; 1599 :         while (!_Trynode->_Isnil) {

  0010c	0f b6 f0	 movzx	 esi, al
  0010f	83 f6 01	 xor	 esi, 1
  00112	89 7d f0	 mov	 DWORD PTR __Trynode$1$[ebp], edi
  00115	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  00119	0f 84 35 ff ff
	ff		 je	 $LL6@Emplace
  0011f	8b 55 e8	 mov	 edx, DWORD PTR _this$1$[ebp]
$LN7@Emplace:

; 1591 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  00122	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00126	8b 7d 0c	 mov	 edi, DWORD PTR _<_Vals_0>$[ebp]
  00129	75 2f		 jne	 SHORT $LN2@Emplace
  0012b	8d 41 10	 lea	 eax, DWORD PTR [ecx+16]
  0012e	8b ca		 mov	 ecx, edx
  00130	50		 push	 eax
  00131	57		 push	 edi
  00132	e8 00 00 00 00	 call	 ??R?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0@Z ; std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator()
  00137	84 c0		 test	 al, al
  00139	75 1f		 jne	 SHORT $LN2@Emplace
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 186  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  0013b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0013e	8b 4d ec	 mov	 ecx, DWORD PTR $T1$sroa$480$1$[ebp]
  00141	89 08		 mov	 DWORD PTR [eax], ecx
  00143	c6 40 04 00	 mov	 BYTE PTR [eax+4], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1032 :     }

  00147	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0014a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00151	59		 pop	 ecx
  00152	5f		 pop	 edi
  00153	5e		 pop	 esi
  00154	8b e5		 mov	 esp, ebp
  00156	5d		 pop	 ebp
  00157	c2 08 00	 ret	 8
$LN2@Emplace:

; 1615 :         if (max_size() == _Get_scary()->_Mysize) {

  0015a	8b 45 e8	 mov	 eax, DWORD PTR _this$1$[ebp]
  0015d	81 78 04 d7 50
	5e 03		 cmp	 DWORD PTR [eax+4], 56512727 ; 035e50d7H
  00164	0f 84 a6 00 00
	00		 je	 $LN168@Emplace
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 958  :     _CONSTEXPR20_DYNALLOC explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

  0016a	89 45 d8	 mov	 DWORD PTR $T3[ebp], eax

; 79   :         return ::operator new(_Bytes);

  0016d	6a 4c		 push	 76			; 0000004cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 783  :     explicit _Tree_temp_node_alloc(_Alnode& _Al_) : _Alloc_construct_ptr<_Alnode>(_Al_) {

  0016f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 965  :         _Ptr = nullptr; // if allocate throws, prevents double-free

  00176	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR $T3[ebp+4], 0

; 79   :         return ::operator new(_Bytes);

  0017d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 235  :         return _Traits::_Allocate(_Bytes);

  00182	8b c8		 mov	 ecx, eax

; 79   :         return ::operator new(_Bytes);

  00184	83 c4 04	 add	 esp, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2313 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00187	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 2322 :     size_type _Mysize = 0; // current length of string

  0018e	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0

; 2323 :     size_type _Myres  = 0; // current storage reserved for string

  00195	c7 41 24 00 00
	00 00		 mov	 DWORD PTR [ecx+36], 0

; 2835 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  0019c	0f 10 07	 movups	 xmm0, XMMWORD PTR [edi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1031 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  0019f	51		 push	 ecx
  001a0	56		 push	 esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2835 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  001a1	0f 11 41 10	 movups	 XMMWORD PTR [ecx+16], xmm0
  001a5	f3 0f 7e 47 10	 movq	 xmm0, QWORD PTR [edi+16]
  001aa	66 0f d6 41 20	 movq	 QWORD PTR [ecx+32], xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1031 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  001af	ff 75 e4	 push	 DWORD PTR __Loc$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4562 :         _My_data._Mysize = 0;

  001b2	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0

; 4563 : 
; 4564 : #ifdef __cpp_lib_constexpr_string
; 4565 :         if (_STD is_constant_evaluated()) {
; 4566 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4567 :             auto& _Al              = _Getal();
; 4568 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4569 :             _My_data._Bx._Ptr      = _New_ptr;
; 4570 : 
; 4571 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4572 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4573 :         } else
; 4574 : #endif // __cpp_lib_constexpr_string
; 4575 :         {
; 4576 :             _My_data._Myres = _BUF_SIZE - 1;

  001b9	c7 47 14 0f 00
	00 00		 mov	 DWORD PTR [edi+20], 15	; 0000000fH

; 4577 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4578 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  001c0	c6 07 00	 mov	 BYTE PTR [edi], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 242  :         : first(_STD forward<_Other1>(_Right.first)), second(_STD forward<_Other2>(_Right.second)) {}

  001c3	0f 10 47 18	 movups	 xmm0, XMMWORD PTR [edi+24]
  001c7	0f 11 41 28	 movups	 XMMWORD PTR [ecx+40], xmm0
  001cb	0f 10 47 28	 movups	 xmm0, XMMWORD PTR [edi+40]
  001cf	0f 11 41 38	 movups	 XMMWORD PTR [ecx+56], xmm0
  001d3	8b 47 38	 mov	 eax, DWORD PTR [edi+56]
  001d6	89 41 48	 mov	 DWORD PTR [ecx+72], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 806  :         _Construct_in_place(this->_Ptr->_Left, _Myhead);

  001d9	8b 45 d4	 mov	 eax, DWORD PTR __Myhead$1$[ebp]
  001dc	89 01		 mov	 DWORD PTR [ecx], eax

; 807  :         _Construct_in_place(this->_Ptr->_Parent, _Myhead);

  001de	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 808  :         _Construct_in_place(this->_Ptr->_Right, _Myhead);

  001e1	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 809  :         this->_Ptr->_Color = _Red;

  001e4	66 c7 41 0c 00
	00		 mov	 WORD PTR [ecx+12], 0

; 1031 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  001ea	8b 4d e8	 mov	 ecx, DWORD PTR _this$1$[ebp]
  001ed	e8 00 00 00 00	 call	 ?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@PAX@std@@@2@QAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,tm> > >::_Insert_node
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 186  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  001f2	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  001f5	89 01		 mov	 DWORD PTR [ecx], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1031 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  001f7	8b c1		 mov	 eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 186  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  001f9	c6 41 04 01	 mov	 BYTE PTR [ecx+4], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1032 :     }

  001fd	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00200	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00207	59		 pop	 ecx
  00208	5f		 pop	 edi
  00209	5e		 pop	 esi
  0020a	8b e5		 mov	 esp, ebp
  0020c	5d		 pop	 ebp
  0020d	c2 08 00	 ret	 8
$LN168@Emplace:

; 1616 :             _Throw_tree_length_error();

  00210	e8 00 00 00 00	 call	 ?_Throw_tree_length_error@std@@YAXXZ ; std::_Throw_tree_length_error
$LN164@Emplace:
  00215	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Emplace@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@PAX@std@@_N@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@1@@Z$2:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T3[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,tm>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,tm>,void *> > >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$_Emplace@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@PAX@std@@_N@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@1@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a d4	 mov	 ecx, DWORD PTR [edx-44]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Emplace@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@PAX@std@@_N@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@1@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Emplace@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@PAX@std@@_N@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,tm,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,tm> >,0> >::_Emplace<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,tm> >
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ??$_Find_lower_bound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
tv409 = -8						; size = 4
tv405 = -4						; size = 4
tv410 = 8						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
??$_Find_lower_bound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Find_lower_bound<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 1595 :     _Tree_find_result<_Nodeptr> _Find_lower_bound(const _Keyty& _Keyval) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1596 :         const auto _Scary = _Get_scary();
; 1597 :         _Tree_find_result<_Nodeptr> _Result{{_Scary->_Myhead->_Parent, _Tree_child::_Right}, _Scary->_Myhead};

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	83 ec 08	 sub	 esp, 8
  00008	53		 push	 ebx
  00009	8b 5d 08	 mov	 ebx, DWORD PTR ___$ReturnUdt$[ebp]
  0000c	57		 push	 edi
  0000d	8b 78 04	 mov	 edi, DWORD PTR [eax+4]
  00010	89 3b		 mov	 DWORD PTR [ebx], edi
  00012	c7 43 04 00 00
	00 00		 mov	 DWORD PTR [ebx+4], 0

; 1598 :         _Nodeptr _Trynode = _Result._Location._Parent;
; 1599 :         while (!_Trynode->_Isnil) {

  00019	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  0001d	89 43 08	 mov	 DWORD PTR [ebx+8], eax
  00020	0f 85 ab 00 00
	00		 jne	 $LN42@Find_lower
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2286 :         return _BUF_SIZE <= _Myres;

  00026	8b 45 0c	 mov	 eax, DWORD PTR __Keyval$[ebp]
  00029	56		 push	 esi
  0002a	8b 70 14	 mov	 esi, DWORD PTR [eax+20]

; 4380 :         return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

  0002d	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]

; 2286 :         return _BUF_SIZE <= _Myres;

  00030	89 75 f8	 mov	 DWORD PTR tv409[ebp], esi

; 4380 :         return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

  00033	89 4d 08	 mov	 DWORD PTR tv410[ebp], ecx
$LL2@Find_lower:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1600 :             _Result._Location._Parent = _Trynode;

  00036	89 3b		 mov	 DWORD PTR [ebx], edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2272 :         const value_type* _Result = _Bx._Buf;

  00038	8b d0		 mov	 edx, eax

; 2286 :         return _BUF_SIZE <= _Myres;

  0003a	83 fe 10	 cmp	 esi, 16			; 00000010H

; 2273 :         if (_Large_string_engaged()) {

  0003d	72 02		 jb	 SHORT $LN14@Find_lower

; 2274 :             _Result = _Unfancy(_Bx._Ptr);

  0003f	8b 10		 mov	 edx, DWORD PTR [eax]
$LN14@Find_lower:

; 2286 :         return _BUF_SIZE <= _Myres;

  00041	83 7f 24 10	 cmp	 DWORD PTR [edi+36], 16	; 00000010H

; 2272 :         const value_type* _Result = _Bx._Buf;

  00045	8d 47 10	 lea	 eax, DWORD PTR [edi+16]

; 2273 :         if (_Large_string_engaged()) {

  00048	72 03		 jb	 SHORT $LN19@Find_lower

; 2274 :             _Result = _Unfancy(_Bx._Ptr);

  0004a	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
$LN19@Find_lower:

; 4380 :         return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

  0004d	8b 4f 20	 mov	 ecx, DWORD PTR [edi+32]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 66   :     return _Right < _Left ? _Right : _Left;

  00050	8b f1		 mov	 esi, ecx
  00052	39 4d 08	 cmp	 DWORD PTR tv410[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4380 :         return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

  00055	89 4d fc	 mov	 DWORD PTR tv405[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 66   :     return _Right < _Left ? _Right : _Left;

  00058	0f 42 75 08	 cmovb	 esi, DWORD PTR tv410[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 384  :         return _CSTD memcmp(_First1, _First2, _Count);

  0005c	83 ee 04	 sub	 esi, 4
  0005f	72 11		 jb	 SHORT $LN38@Find_lower
$LL39@Find_lower:
  00061	8b 08		 mov	 ecx, DWORD PTR [eax]
  00063	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  00065	75 10		 jne	 SHORT $LN37@Find_lower
  00067	83 c0 04	 add	 eax, 4
  0006a	83 c2 04	 add	 edx, 4
  0006d	83 ee 04	 sub	 esi, 4
  00070	73 ef		 jae	 SHORT $LL39@Find_lower
$LN38@Find_lower:
  00072	83 fe fc	 cmp	 esi, -4			; fffffffcH
  00075	74 34		 je	 SHORT $LN36@Find_lower
$LN37@Find_lower:
  00077	8a 08		 mov	 cl, BYTE PTR [eax]
  00079	3a 0a		 cmp	 cl, BYTE PTR [edx]
  0007b	75 27		 jne	 SHORT $LN40@Find_lower
  0007d	83 fe fd	 cmp	 esi, -3			; fffffffdH
  00080	74 29		 je	 SHORT $LN36@Find_lower
  00082	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  00085	3a 4a 01	 cmp	 cl, BYTE PTR [edx+1]
  00088	75 1a		 jne	 SHORT $LN40@Find_lower
  0008a	83 fe fe	 cmp	 esi, -2			; fffffffeH
  0008d	74 1c		 je	 SHORT $LN36@Find_lower
  0008f	8a 48 02	 mov	 cl, BYTE PTR [eax+2]
  00092	3a 4a 02	 cmp	 cl, BYTE PTR [edx+2]
  00095	75 0d		 jne	 SHORT $LN40@Find_lower
  00097	83 fe ff	 cmp	 esi, -1
  0009a	74 0f		 je	 SHORT $LN36@Find_lower
  0009c	8a 40 03	 mov	 al, BYTE PTR [eax+3]
  0009f	3a 42 03	 cmp	 al, BYTE PTR [edx+3]
  000a2	74 07		 je	 SHORT $LN36@Find_lower
$LN40@Find_lower:
  000a4	1b c0		 sbb	 eax, eax
  000a6	83 c8 01	 or	 eax, 1
  000a9	eb 02		 jmp	 SHORT $LN41@Find_lower
$LN36@Find_lower:
  000ab	33 c0		 xor	 eax, eax
$LN41@Find_lower:

; 580  :     if (_Ans != 0) {

  000ad	85 c0		 test	 eax, eax
  000af	74 2a		 je	 SHORT $LN24@Find_lower
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1601 :             if (_DEBUG_LT_PRED(_Getcomp(), _Traits::_Kfn(_Trynode->_Myval), _Keyval)) {

  000b1	78 30		 js	 SHORT $LN35@Find_lower
$LN4@Find_lower:

; 1605 :                 _Result._Location._Child = _Tree_child::_Left;
; 1606 :                 _Result._Bound           = _Trynode;

  000b3	89 7b 08	 mov	 DWORD PTR [ebx+8], edi

; 1607 :                 _Trynode                 = _Trynode->_Left;

  000b6	b8 01 00 00 00	 mov	 eax, 1
  000bb	8b 3f		 mov	 edi, DWORD PTR [edi]
$LN5@Find_lower:

; 1598 :         _Nodeptr _Trynode = _Result._Location._Parent;
; 1599 :         while (!_Trynode->_Isnil) {

  000bd	8b 75 f8	 mov	 esi, DWORD PTR tv409[ebp]
  000c0	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  000c3	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  000c7	8b 45 0c	 mov	 eax, DWORD PTR __Keyval$[ebp]
  000ca	0f 84 66 ff ff
	ff		 je	 $LL2@Find_lower

; 1608 :             }
; 1609 :         }
; 1610 : 
; 1611 :         return _Result;

  000d0	5e		 pop	 esi
$LN42@Find_lower:
  000d1	5f		 pop	 edi

; 1612 :     }

  000d2	8b c3		 mov	 eax, ebx
  000d4	5b		 pop	 ebx
  000d5	8b e5		 mov	 esp, ebp
  000d7	5d		 pop	 ebp
  000d8	c2 08 00	 ret	 8
$LN24@Find_lower:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 584  :     if (_Left_size < _Right_size) {

  000db	8b 45 08	 mov	 eax, DWORD PTR tv410[ebp]
  000de	39 45 fc	 cmp	 DWORD PTR tv405[ebp], eax
  000e1	73 d0		 jae	 SHORT $LN4@Find_lower
$LN35@Find_lower:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1603 :                 _Trynode                 = _Trynode->_Right;

  000e3	8b 7f 08	 mov	 edi, DWORD PTR [edi+8]
  000e6	33 c0		 xor	 eax, eax

; 1604 :             } else {

  000e8	eb d3		 jmp	 SHORT $LN5@Find_lower
??$_Find_lower_bound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Find_lower_bound<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@PAX@1@@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
__Al$ = 8						; size = 4
__Rootnode$ = 12					; size = 4
??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@PAX@1@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,tm> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,tm>,void *> > >, COMDAT
; _this$ = ecx

; 742  :     void _Erase_tree(_Alnode& _Al, _Nodeptr _Rootnode) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	57		 push	 edi

; 743  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

  00005	8b 7d 0c	 mov	 edi, DWORD PTR __Rootnode$[ebp]
  00008	8b c1		 mov	 eax, ecx
  0000a	89 45 fc	 mov	 DWORD PTR _this$1$[ebp], eax
  0000d	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  00011	75 74		 jne	 SHORT $LN73@Erase_tree
  00013	53		 push	 ebx
  00014	8b 5d 08	 mov	 ebx, DWORD PTR __Al$[ebp]
  00017	56		 push	 esi
$LL2@Erase_tree:

; 744  :             _Erase_tree(_Al, _Rootnode->_Right);

  00018	ff 77 08	 push	 DWORD PTR [edi+8]
  0001b	8b c8		 mov	 ecx, eax
  0001d	53		 push	 ebx
  0001e	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,tm> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,tm>,void *> > >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 602  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  00023	8b f7		 mov	 esi, edi

; 603  :     _Val         = static_cast<_Other&&>(_New_val);

  00025	8b 3f		 mov	 edi, DWORD PTR [edi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2286 :         return _BUF_SIZE <= _Myres;

  00027	8b 4e 24	 mov	 ecx, DWORD PTR [esi+36]
  0002a	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 4584 :         if (_Mypair._Myval2._Large_string_engaged()) {

  0002d	72 28		 jb	 SHORT $LN29@Erase_tree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0002f	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4588 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00032	41		 inc	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00033	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00039	72 12		 jb	 SHORT $LN39@Erase_tree

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0003b	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0003e	83 c1 23	 add	 ecx, 35			; 00000023H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00041	2b c2		 sub	 eax, edx

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00043	83 c0 fc	 add	 eax, -4			; fffffffcH
  00046	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00049	77 34		 ja	 SHORT $LN36@Erase_tree

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0004b	8b c2		 mov	 eax, edx
$LN39@Erase_tree:

; 255  :         ::operator delete(_Ptr, _Bytes);

  0004d	51		 push	 ecx
  0004e	50		 push	 eax
  0004f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00054	83 c4 08	 add	 esp, 8
$LN29@Erase_tree:
  00057	6a 4c		 push	 76			; 0000004cH
  00059	56		 push	 esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4599 :             _Mypair._Myval2._Mysize = 0;

  0005a	c7 46 20 00 00
	00 00		 mov	 DWORD PTR [esi+32], 0

; 4600 :             _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00061	c7 46 24 0f 00
	00 00		 mov	 DWORD PTR [esi+36], 15	; 0000000fH

; 4601 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4602 :             _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00068	c6 46 10 00	 mov	 BYTE PTR [esi+16], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 255  :         ::operator delete(_Ptr, _Bytes);

  0006c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00071	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 743  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

  00074	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  00078	75 0b		 jne	 SHORT $LN75@Erase_tree
  0007a	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]
  0007d	eb 99		 jmp	 SHORT $LL2@Erase_tree
$LN36@Erase_tree:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0007f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN75@Erase_tree:
  00085	5e		 pop	 esi
  00086	5b		 pop	 ebx
$LN73@Erase_tree:
  00087	5f		 pop	 edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 747  :     }

  00088	8b e5		 mov	 esp, ebp
  0008a	5d		 pop	 ebp
  0008b	c2 08 00	 ret	 8
$LN76@Erase_tree:
??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@PAX@1@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,tm> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,tm>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ??$_Find_lower_bound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_JU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@PAX@std@@@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
tv409 = -8						; size = 4
tv405 = -4						; size = 4
tv410 = 8						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
??$_Find_lower_bound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_JU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@PAX@std@@@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,__int64,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,__int64> >,0> >::_Find_lower_bound<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 1595 :     _Tree_find_result<_Nodeptr> _Find_lower_bound(const _Keyty& _Keyval) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1596 :         const auto _Scary = _Get_scary();
; 1597 :         _Tree_find_result<_Nodeptr> _Result{{_Scary->_Myhead->_Parent, _Tree_child::_Right}, _Scary->_Myhead};

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	83 ec 08	 sub	 esp, 8
  00008	53		 push	 ebx
  00009	8b 5d 08	 mov	 ebx, DWORD PTR ___$ReturnUdt$[ebp]
  0000c	57		 push	 edi
  0000d	8b 78 04	 mov	 edi, DWORD PTR [eax+4]
  00010	89 3b		 mov	 DWORD PTR [ebx], edi
  00012	c7 43 04 00 00
	00 00		 mov	 DWORD PTR [ebx+4], 0

; 1598 :         _Nodeptr _Trynode = _Result._Location._Parent;
; 1599 :         while (!_Trynode->_Isnil) {

  00019	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  0001d	89 43 08	 mov	 DWORD PTR [ebx+8], eax
  00020	0f 85 ab 00 00
	00		 jne	 $LN42@Find_lower
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2286 :         return _BUF_SIZE <= _Myres;

  00026	8b 45 0c	 mov	 eax, DWORD PTR __Keyval$[ebp]
  00029	56		 push	 esi
  0002a	8b 70 14	 mov	 esi, DWORD PTR [eax+20]

; 4380 :         return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

  0002d	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]

; 2286 :         return _BUF_SIZE <= _Myres;

  00030	89 75 f8	 mov	 DWORD PTR tv409[ebp], esi

; 4380 :         return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

  00033	89 4d 08	 mov	 DWORD PTR tv410[ebp], ecx
$LL2@Find_lower:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1600 :             _Result._Location._Parent = _Trynode;

  00036	89 3b		 mov	 DWORD PTR [ebx], edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2272 :         const value_type* _Result = _Bx._Buf;

  00038	8b d0		 mov	 edx, eax

; 2286 :         return _BUF_SIZE <= _Myres;

  0003a	83 fe 10	 cmp	 esi, 16			; 00000010H

; 2273 :         if (_Large_string_engaged()) {

  0003d	72 02		 jb	 SHORT $LN14@Find_lower

; 2274 :             _Result = _Unfancy(_Bx._Ptr);

  0003f	8b 10		 mov	 edx, DWORD PTR [eax]
$LN14@Find_lower:

; 2286 :         return _BUF_SIZE <= _Myres;

  00041	83 7f 24 10	 cmp	 DWORD PTR [edi+36], 16	; 00000010H

; 2272 :         const value_type* _Result = _Bx._Buf;

  00045	8d 47 10	 lea	 eax, DWORD PTR [edi+16]

; 2273 :         if (_Large_string_engaged()) {

  00048	72 03		 jb	 SHORT $LN19@Find_lower

; 2274 :             _Result = _Unfancy(_Bx._Ptr);

  0004a	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
$LN19@Find_lower:

; 4380 :         return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

  0004d	8b 4f 20	 mov	 ecx, DWORD PTR [edi+32]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 66   :     return _Right < _Left ? _Right : _Left;

  00050	8b f1		 mov	 esi, ecx
  00052	39 4d 08	 cmp	 DWORD PTR tv410[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4380 :         return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

  00055	89 4d fc	 mov	 DWORD PTR tv405[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 66   :     return _Right < _Left ? _Right : _Left;

  00058	0f 42 75 08	 cmovb	 esi, DWORD PTR tv410[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 384  :         return _CSTD memcmp(_First1, _First2, _Count);

  0005c	83 ee 04	 sub	 esi, 4
  0005f	72 11		 jb	 SHORT $LN38@Find_lower
$LL39@Find_lower:
  00061	8b 08		 mov	 ecx, DWORD PTR [eax]
  00063	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  00065	75 10		 jne	 SHORT $LN37@Find_lower
  00067	83 c0 04	 add	 eax, 4
  0006a	83 c2 04	 add	 edx, 4
  0006d	83 ee 04	 sub	 esi, 4
  00070	73 ef		 jae	 SHORT $LL39@Find_lower
$LN38@Find_lower:
  00072	83 fe fc	 cmp	 esi, -4			; fffffffcH
  00075	74 34		 je	 SHORT $LN36@Find_lower
$LN37@Find_lower:
  00077	8a 08		 mov	 cl, BYTE PTR [eax]
  00079	3a 0a		 cmp	 cl, BYTE PTR [edx]
  0007b	75 27		 jne	 SHORT $LN40@Find_lower
  0007d	83 fe fd	 cmp	 esi, -3			; fffffffdH
  00080	74 29		 je	 SHORT $LN36@Find_lower
  00082	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  00085	3a 4a 01	 cmp	 cl, BYTE PTR [edx+1]
  00088	75 1a		 jne	 SHORT $LN40@Find_lower
  0008a	83 fe fe	 cmp	 esi, -2			; fffffffeH
  0008d	74 1c		 je	 SHORT $LN36@Find_lower
  0008f	8a 48 02	 mov	 cl, BYTE PTR [eax+2]
  00092	3a 4a 02	 cmp	 cl, BYTE PTR [edx+2]
  00095	75 0d		 jne	 SHORT $LN40@Find_lower
  00097	83 fe ff	 cmp	 esi, -1
  0009a	74 0f		 je	 SHORT $LN36@Find_lower
  0009c	8a 40 03	 mov	 al, BYTE PTR [eax+3]
  0009f	3a 42 03	 cmp	 al, BYTE PTR [edx+3]
  000a2	74 07		 je	 SHORT $LN36@Find_lower
$LN40@Find_lower:
  000a4	1b c0		 sbb	 eax, eax
  000a6	83 c8 01	 or	 eax, 1
  000a9	eb 02		 jmp	 SHORT $LN41@Find_lower
$LN36@Find_lower:
  000ab	33 c0		 xor	 eax, eax
$LN41@Find_lower:

; 580  :     if (_Ans != 0) {

  000ad	85 c0		 test	 eax, eax
  000af	74 2a		 je	 SHORT $LN24@Find_lower
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1601 :             if (_DEBUG_LT_PRED(_Getcomp(), _Traits::_Kfn(_Trynode->_Myval), _Keyval)) {

  000b1	78 30		 js	 SHORT $LN35@Find_lower
$LN4@Find_lower:

; 1605 :                 _Result._Location._Child = _Tree_child::_Left;
; 1606 :                 _Result._Bound           = _Trynode;

  000b3	89 7b 08	 mov	 DWORD PTR [ebx+8], edi

; 1607 :                 _Trynode                 = _Trynode->_Left;

  000b6	b8 01 00 00 00	 mov	 eax, 1
  000bb	8b 3f		 mov	 edi, DWORD PTR [edi]
$LN5@Find_lower:

; 1598 :         _Nodeptr _Trynode = _Result._Location._Parent;
; 1599 :         while (!_Trynode->_Isnil) {

  000bd	8b 75 f8	 mov	 esi, DWORD PTR tv409[ebp]
  000c0	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  000c3	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  000c7	8b 45 0c	 mov	 eax, DWORD PTR __Keyval$[ebp]
  000ca	0f 84 66 ff ff
	ff		 je	 $LL2@Find_lower

; 1608 :             }
; 1609 :         }
; 1610 : 
; 1611 :         return _Result;

  000d0	5e		 pop	 esi
$LN42@Find_lower:
  000d1	5f		 pop	 edi

; 1612 :     }

  000d2	8b c3		 mov	 eax, ebx
  000d4	5b		 pop	 ebx
  000d5	8b e5		 mov	 esp, ebp
  000d7	5d		 pop	 ebp
  000d8	c2 08 00	 ret	 8
$LN24@Find_lower:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 584  :     if (_Left_size < _Right_size) {

  000db	8b 45 08	 mov	 eax, DWORD PTR tv410[ebp]
  000de	39 45 fc	 cmp	 DWORD PTR tv405[ebp], eax
  000e1	73 d0		 jae	 SHORT $LN4@Find_lower
$LN35@Find_lower:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1603 :                 _Trynode                 = _Trynode->_Right;

  000e3	8b 7f 08	 mov	 edi, DWORD PTR [edi+8]
  000e6	33 c0		 xor	 eax, eax

; 1604 :             } else {

  000e8	eb d3		 jmp	 SHORT $LN5@Find_lower
??$_Find_lower_bound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_JU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@PAX@std@@@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,__int64,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,__int64> >,0> >::_Find_lower_bound<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
__Al$ = 8						; size = 4
__Rootnode$ = 12					; size = 4
??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> > >, COMDAT
; _this$ = ecx

; 742  :     void _Erase_tree(_Alnode& _Al, _Nodeptr _Rootnode) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	57		 push	 edi

; 743  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

  00005	8b 7d 0c	 mov	 edi, DWORD PTR __Rootnode$[ebp]
  00008	8b c1		 mov	 eax, ecx
  0000a	89 45 fc	 mov	 DWORD PTR _this$1$[ebp], eax
  0000d	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  00011	75 74		 jne	 SHORT $LN73@Erase_tree
  00013	53		 push	 ebx
  00014	8b 5d 08	 mov	 ebx, DWORD PTR __Al$[ebp]
  00017	56		 push	 esi
$LL2@Erase_tree:

; 744  :             _Erase_tree(_Al, _Rootnode->_Right);

  00018	ff 77 08	 push	 DWORD PTR [edi+8]
  0001b	8b c8		 mov	 ecx, eax
  0001d	53		 push	 ebx
  0001e	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> > >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 602  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  00023	8b f7		 mov	 esi, edi

; 603  :     _Val         = static_cast<_Other&&>(_New_val);

  00025	8b 3f		 mov	 edi, DWORD PTR [edi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2286 :         return _BUF_SIZE <= _Myres;

  00027	8b 4e 24	 mov	 ecx, DWORD PTR [esi+36]
  0002a	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 4584 :         if (_Mypair._Myval2._Large_string_engaged()) {

  0002d	72 28		 jb	 SHORT $LN29@Erase_tree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0002f	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4588 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00032	41		 inc	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00033	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00039	72 12		 jb	 SHORT $LN39@Erase_tree

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0003b	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0003e	83 c1 23	 add	 ecx, 35			; 00000023H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00041	2b c2		 sub	 eax, edx

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00043	83 c0 fc	 add	 eax, -4			; fffffffcH
  00046	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00049	77 34		 ja	 SHORT $LN36@Erase_tree

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0004b	8b c2		 mov	 eax, edx
$LN39@Erase_tree:

; 255  :         ::operator delete(_Ptr, _Bytes);

  0004d	51		 push	 ecx
  0004e	50		 push	 eax
  0004f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00054	83 c4 08	 add	 esp, 8
$LN29@Erase_tree:
  00057	6a 2c		 push	 44			; 0000002cH
  00059	56		 push	 esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4599 :             _Mypair._Myval2._Mysize = 0;

  0005a	c7 46 20 00 00
	00 00		 mov	 DWORD PTR [esi+32], 0

; 4600 :             _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00061	c7 46 24 0f 00
	00 00		 mov	 DWORD PTR [esi+36], 15	; 0000000fH

; 4601 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4602 :             _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00068	c6 46 10 00	 mov	 BYTE PTR [esi+16], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 255  :         ::operator delete(_Ptr, _Bytes);

  0006c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00071	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 743  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

  00074	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  00078	75 0b		 jne	 SHORT $LN75@Erase_tree
  0007a	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]
  0007d	eb 99		 jmp	 SHORT $LL2@Erase_tree
$LN36@Erase_tree:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0007f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN75@Erase_tree:
  00085	5e		 pop	 esi
  00086	5b		 pop	 ebx
$LN73@Erase_tree:
  00087	5f		 pop	 edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 747  :     }

  00088	8b e5		 mov	 esp, ebp
  0008a	5d		 pop	 ebp
  0008b	c2 08 00	 ret	 8
$LN76@Erase_tree:
??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@PAX@1@@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
__Al$ = 8						; size = 4
__Rootnode$ = 12					; size = 4
??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@PAX@1@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,__int64> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,__int64>,void *> > >, COMDAT
; _this$ = ecx

; 742  :     void _Erase_tree(_Alnode& _Al, _Nodeptr _Rootnode) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	57		 push	 edi

; 743  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

  00005	8b 7d 0c	 mov	 edi, DWORD PTR __Rootnode$[ebp]
  00008	8b c1		 mov	 eax, ecx
  0000a	89 45 fc	 mov	 DWORD PTR _this$1$[ebp], eax
  0000d	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  00011	75 74		 jne	 SHORT $LN73@Erase_tree
  00013	53		 push	 ebx
  00014	8b 5d 08	 mov	 ebx, DWORD PTR __Al$[ebp]
  00017	56		 push	 esi
$LL2@Erase_tree:

; 744  :             _Erase_tree(_Al, _Rootnode->_Right);

  00018	ff 77 08	 push	 DWORD PTR [edi+8]
  0001b	8b c8		 mov	 ecx, eax
  0001d	53		 push	 ebx
  0001e	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,__int64> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,__int64>,void *> > >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 602  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  00023	8b f7		 mov	 esi, edi

; 603  :     _Val         = static_cast<_Other&&>(_New_val);

  00025	8b 3f		 mov	 edi, DWORD PTR [edi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2286 :         return _BUF_SIZE <= _Myres;

  00027	8b 4e 24	 mov	 ecx, DWORD PTR [esi+36]
  0002a	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 4584 :         if (_Mypair._Myval2._Large_string_engaged()) {

  0002d	72 28		 jb	 SHORT $LN29@Erase_tree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0002f	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4588 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00032	41		 inc	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00033	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00039	72 12		 jb	 SHORT $LN39@Erase_tree

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0003b	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0003e	83 c1 23	 add	 ecx, 35			; 00000023H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00041	2b c2		 sub	 eax, edx

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00043	83 c0 fc	 add	 eax, -4			; fffffffcH
  00046	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00049	77 34		 ja	 SHORT $LN36@Erase_tree

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0004b	8b c2		 mov	 eax, edx
$LN39@Erase_tree:

; 255  :         ::operator delete(_Ptr, _Bytes);

  0004d	51		 push	 ecx
  0004e	50		 push	 eax
  0004f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00054	83 c4 08	 add	 esp, 8
$LN29@Erase_tree:
  00057	6a 30		 push	 48			; 00000030H
  00059	56		 push	 esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4599 :             _Mypair._Myval2._Mysize = 0;

  0005a	c7 46 20 00 00
	00 00		 mov	 DWORD PTR [esi+32], 0

; 4600 :             _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00061	c7 46 24 0f 00
	00 00		 mov	 DWORD PTR [esi+36], 15	; 0000000fH

; 4601 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4602 :             _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00068	c6 46 10 00	 mov	 BYTE PTR [esi+16], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 255  :         ::operator delete(_Ptr, _Bytes);

  0006c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00071	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 743  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

  00074	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  00078	75 0b		 jne	 SHORT $LN75@Erase_tree
  0007a	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]
  0007d	eb 99		 jmp	 SHORT $LL2@Erase_tree
$LN36@Erase_tree:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0007f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN75@Erase_tree:
  00085	5e		 pop	 esi
  00086	5b		 pop	 ebx
$LN73@Erase_tree:
  00087	5f		 pop	 edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 747  :     }

  00088	8b e5		 mov	 esp, ebp
  0008a	5d		 pop	 ebp
  0008b	c2 08 00	 ret	 8
$LN76@Erase_tree:
??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@PAX@1@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,__int64> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,__int64>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@QAE@XZ
_TEXT	SEGMENT
??1?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@QAE@XZ PROC ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,__int64>::~pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,__int64>, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2286 :         return _BUF_SIZE <= _Myres;

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00006	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 4584 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00009	72 27		 jb	 SHORT $LN15@pair
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000b	8b 06		 mov	 eax, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4588 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0000d	41		 inc	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0000e	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00014	72 12		 jb	 SHORT $LN25@pair

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00016	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00019	83 c1 23	 add	 ecx, 35			; 00000023H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001c	2b c2		 sub	 eax, edx

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0001e	83 c0 fc	 add	 eax, -4			; fffffffcH
  00021	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00024	77 1f		 ja	 SHORT $LN22@pair

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00026	8b c2		 mov	 eax, edx
$LN25@pair:

; 255  :         ::operator delete(_Ptr, _Bytes);

  00028	51		 push	 ecx
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	83 c4 08	 add	 esp, 8
$LN15@pair:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4599 :             _Mypair._Myval2._Mysize = 0;

  00032	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 4600 :             _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00039	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 4601 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4602 :             _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00040	c6 06 00	 mov	 BYTE PTR [esi], 0
  00043	5e		 pop	 esi
  00044	c3		 ret	 0
$LN22@pair:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00045	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN31@pair:
  0004b	cc		 int	 3
??1?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@QAE@XZ ENDP ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,__int64>::~pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,__int64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@QAE@XZ PROC ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,tm>::~pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,tm>, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2286 :         return _BUF_SIZE <= _Myres;

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00006	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 4584 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00009	72 27		 jb	 SHORT $LN15@pair
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000b	8b 06		 mov	 eax, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4588 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0000d	41		 inc	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0000e	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00014	72 12		 jb	 SHORT $LN25@pair

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00016	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00019	83 c1 23	 add	 ecx, 35			; 00000023H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001c	2b c2		 sub	 eax, edx

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0001e	83 c0 fc	 add	 eax, -4			; fffffffcH
  00021	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00024	77 1f		 ja	 SHORT $LN22@pair

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00026	8b c2		 mov	 eax, edx
$LN25@pair:

; 255  :         ::operator delete(_Ptr, _Bytes);

  00028	51		 push	 ecx
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	83 c4 08	 add	 esp, 8
$LN15@pair:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4599 :             _Mypair._Myval2._Mysize = 0;

  00032	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 4600 :             _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00039	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 4601 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4602 :             _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00040	c6 06 00	 mov	 BYTE PTR [esi], 0
  00043	5e		 pop	 esi
  00044	c3		 ret	 0
$LN22@pair:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00045	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN31@pair:
  0004b	cc		 int	 3
??1?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@QAE@XZ ENDP ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,tm>::~pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,tm>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@QAE@XZ
_TEXT	SEGMENT
??1?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@QAE@XZ PROC ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int>::~pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int>, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2286 :         return _BUF_SIZE <= _Myres;

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00006	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 4584 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00009	72 27		 jb	 SHORT $LN15@pair
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000b	8b 06		 mov	 eax, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4588 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0000d	41		 inc	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0000e	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00014	72 12		 jb	 SHORT $LN25@pair

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00016	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00019	83 c1 23	 add	 ecx, 35			; 00000023H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001c	2b c2		 sub	 eax, edx

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0001e	83 c0 fc	 add	 eax, -4			; fffffffcH
  00021	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00024	77 1f		 ja	 SHORT $LN22@pair

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00026	8b c2		 mov	 eax, edx
$LN25@pair:

; 255  :         ::operator delete(_Ptr, _Bytes);

  00028	51		 push	 ecx
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	83 c4 08	 add	 esp, 8
$LN15@pair:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4599 :             _Mypair._Myval2._Mysize = 0;

  00032	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 4600 :             _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00039	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 4601 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4602 :             _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00040	c6 06 00	 mov	 BYTE PTR [esi], 0
  00043	5e		 pop	 esi
  00044	c3		 ret	 0
$LN22@pair:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00045	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN31@pair:
  0004b	cc		 int	 3
??1?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@QAE@XZ ENDP ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int>::~pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??_GCXScaleTimeDiffManager@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCXScaleTimeDiffManager@@UAEPAXI@Z PROC		; CXScaleTimeDiffManager::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp

; 39   : {

  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b f9		 mov	 edi, ecx

; 41   : }

  00007	8d 4f 20	 lea	 ecx, DWORD PTR [edi+32]
  0000a	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7CXScaleTimeDiffManager@@6B@
  00010	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 752  :         _Erase_tree(_Al, _Myhead->_Parent);

  00016	8b 47 18	 mov	 eax, DWORD PTR [edi+24]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp

; 41   : }

  00019	8d 77 18	 lea	 esi, DWORD PTR [edi+24]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 752  :         _Erase_tree(_Al, _Myhead->_Parent);

  0001c	8b ce		 mov	 ecx, esi
  0001e	ff 70 04	 push	 DWORD PTR [eax+4]
  00021	56		 push	 esi
  00022	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,__int64> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,__int64>,void *> > >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 255  :         ::operator delete(_Ptr, _Bytes);

  00027	6a 30		 push	 48			; 00000030H
  00029	ff 36		 push	 DWORD PTR [esi]
  0002b	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 752  :         _Erase_tree(_Al, _Myhead->_Parent);

  00030	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp

; 41   : }

  00033	8d 77 10	 lea	 esi, DWORD PTR [edi+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 255  :         ::operator delete(_Ptr, _Bytes);

  00036	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 752  :         _Erase_tree(_Al, _Myhead->_Parent);

  00039	8b ce		 mov	 ecx, esi
  0003b	ff 70 04	 push	 DWORD PTR [eax+4]
  0003e	56		 push	 esi
  0003f	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,tm> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,tm>,void *> > >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 255  :         ::operator delete(_Ptr, _Bytes);

  00044	6a 4c		 push	 76			; 0000004cH
  00046	ff 36		 push	 DWORD PTR [esi]
  00048	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 752  :         _Erase_tree(_Al, _Myhead->_Parent);

  0004d	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp

; 41   : }

  00050	8d 77 08	 lea	 esi, DWORD PTR [edi+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 255  :         ::operator delete(_Ptr, _Bytes);

  00053	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 752  :         _Erase_tree(_Al, _Myhead->_Parent);

  00056	8b ce		 mov	 ecx, esi
  00058	ff 70 04	 push	 DWORD PTR [eax+4]
  0005b	56		 push	 esi
  0005c	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> > >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 255  :         ::operator delete(_Ptr, _Bytes);

  00061	6a 2c		 push	 44			; 0000002cH
  00063	ff 36		 push	 DWORD PTR [esi]
  00065	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0006a	83 c4 08	 add	 esp, 8
  0006d	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00071	74 0b		 je	 SHORT $LN99@scalar
  00073	6a 28		 push	 40			; 00000028H
  00075	57		 push	 edi
  00076	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0007b	83 c4 08	 add	 esp, 8
$LN99@scalar:
  0007e	8b c7		 mov	 eax, edi
  00080	5f		 pop	 edi
  00081	5e		 pop	 esi
  00082	5d		 pop	 ebp
  00083	c2 04 00	 ret	 4
??_GCXScaleTimeDiffManager@@UAEPAXI@Z ENDP		; CXScaleTimeDiffManager::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp
;	COMDAT ?CalcCurrentDateTimToPacketTime@CXScaleTimeDiffManager@@QAEPAUtm@@V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
_TEXT	SEGMENT
__Loc$2 = -52						; size = 12
_stringRQ$ = -40					; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_strRQ$ = 8						; size = 4
?CalcCurrentDateTimToPacketTime@CXScaleTimeDiffManager@@QAEPAUtm@@V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z PROC ; CXScaleTimeDiffManager::CalcCurrentDateTimToPacketTime, COMDAT
; _this$ = ecx

; 177  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?CalcCurrentDateTimToPacketTime@CXScaleTimeDiffManager@@QAEPAUtm@@V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 28	 sub	 esp, 40			; 00000028H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b f9		 mov	 edi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 404  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  0002d	8b 45 08	 mov	 eax, DWORD PTR _strRQ$[ebp]
  00030	8b d0		 mov	 edx, eax

; 2313 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00032	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _stringRQ$[ebp], 0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp

; 177  : {

  00039	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4562 :         _My_data._Mysize = 0;

  00040	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _stringRQ$[ebp+16], 0

; 4563 : 
; 4564 : #ifdef __cpp_lib_constexpr_string
; 4565 :         if (_STD is_constant_evaluated()) {
; 4566 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4567 :             auto& _Al              = _Getal();
; 4568 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4569 :             _My_data._Bx._Ptr      = _New_ptr;
; 4570 : 
; 4571 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4572 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4573 :         } else
; 4574 : #endif // __cpp_lib_constexpr_string
; 4575 :         {
; 4576 :             _My_data._Myres = _BUF_SIZE - 1;

  00047	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR _stringRQ$[ebp+20], 15 ; 0000000fH

; 404  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  0004e	8d 72 01	 lea	 esi, DWORD PTR [edx+1]

; 4578 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00051	c6 45 d8 00	 mov	 BYTE PTR _stringRQ$[ebp], 0
$LL113@CalcCurren:

; 404  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00055	8a 0a		 mov	 cl, BYTE PTR [edx]
  00057	42		 inc	 edx
  00058	84 c9		 test	 cl, cl
  0005a	75 f9		 jne	 SHORT $LL113@CalcCurren
  0005c	2b d6		 sub	 edx, esi

; 3230 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0005e	8d 4d d8	 lea	 ecx, DWORD PTR _stringRQ$[ebp]
  00061	52		 push	 edx
  00062	50		 push	 eax
  00063	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1353 :         const _Tree_find_result<_Nodeptr> _Loc = _Find_lower_bound(_Keyval);

  00068	8d 45 d8	 lea	 eax, DWORD PTR _stringRQ$[ebp]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp

; 178  : 	string stringRQ((LPSTR)(LPCSTR)strRQ);

  0006b	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1353 :         const _Tree_find_result<_Nodeptr> _Loc = _Find_lower_bound(_Keyval);

  0006f	50		 push	 eax
  00070	8d 45 cc	 lea	 eax, DWORD PTR __Loc$2[ebp]
  00073	50		 push	 eax
  00074	8d 4f 08	 lea	 ecx, DWORD PTR [edi+8]
  00077	e8 00 00 00 00	 call	 ??$_Find_lower_bound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Find_lower_bound<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >

; 1591 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  0007c	8b 75 d4	 mov	 esi, DWORD PTR __Loc$2[ebp+8]
  0007f	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  00083	75 1e		 jne	 SHORT $LN112@CalcCurren
  00085	8d 46 10	 lea	 eax, DWORD PTR [esi+16]
  00088	50		 push	 eax
  00089	8d 45 d8	 lea	 eax, DWORD PTR _stringRQ$[ebp]
  0008c	50		 push	 eax
  0008d	8d 4f 08	 lea	 ecx, DWORD PTR [edi+8]
  00090	e8 00 00 00 00	 call	 ??R?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0@Z ; std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator()
  00095	84 c0		 test	 al, al
  00097	75 0a		 jne	 SHORT $LN112@CalcCurren

; 38   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  00099	3b 77 08	 cmp	 esi, DWORD PTR [edi+8]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp

; 180  : 	if(it == m_mtdRQ.end())

  0009c	74 05		 je	 SHORT $LN112@CalcCurren

; 185  : 	return CDataConversion::CalcCurrentDateTimToPacketTime(it->second);

  0009e	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  000a1	eb 02		 jmp	 SHORT $LN6@CalcCurren
$LN112@CalcCurren:

; 181  : 	{
; 182  : 		return CDataConversion::CalcCurrentDateTimToPacketTime(0);

  000a3	33 c0		 xor	 eax, eax
$LN6@CalcCurren:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2286 :         return _BUF_SIZE <= _Myres;

  000a5	50		 push	 eax
  000a6	e8 00 00 00 00	 call	 ?CalcCurrentDateTimToPacketTime@CDataConversion@@SAPAUtm@@H@Z ; CDataConversion::CalcCurrentDateTimToPacketTime
  000ab	8b 55 ec	 mov	 edx, DWORD PTR _stringRQ$[ebp+20]
  000ae	83 c4 04	 add	 esp, 4
  000b1	8b f0		 mov	 esi, eax
  000b3	83 fa 10	 cmp	 edx, 16			; 00000010H

; 4584 :         if (_Mypair._Myval2._Large_string_engaged()) {

  000b6	72 2e		 jb	 SHORT $LN96@CalcCurren
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000b8	8b 4d d8	 mov	 ecx, DWORD PTR _stringRQ$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4588 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  000bb	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000bc	8b c1		 mov	 eax, ecx

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  000be	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  000c4	72 16		 jb	 SHORT $LN106@CalcCurren

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000c6	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  000c9	83 c2 23	 add	 edx, 35			; 00000023H
  000cc	2b c1		 sub	 eax, ecx

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000ce	83 c0 fc	 add	 eax, -4			; fffffffcH
  000d1	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  000d4	76 06		 jbe	 SHORT $LN106@CalcCurren
  000d6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN106@CalcCurren:

; 255  :         ::operator delete(_Ptr, _Bytes);

  000dc	52		 push	 edx
  000dd	51		 push	 ecx
  000de	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  000e3	83 c4 08	 add	 esp, 8
$LN96@CalcCurren:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp

; 185  : 	return CDataConversion::CalcCurrentDateTimToPacketTime(it->second);

  000e6	8d 4d 08	 lea	 ecx, DWORD PTR _strRQ$[ebp]
  000e9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  000ef	8b c6		 mov	 eax, esi

; 186  : }

  000f1	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000f4	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000fb	59		 pop	 ecx
  000fc	5f		 pop	 edi
  000fd	5e		 pop	 esi
  000fe	5b		 pop	 ebx
  000ff	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00102	33 cd		 xor	 ecx, ebp
  00104	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00109	8b e5		 mov	 esp, ebp
  0010b	5d		 pop	 ebp
  0010c	c2 04 00	 ret	 4
$LN115@CalcCurren:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CalcCurrentDateTimToPacketTime@CXScaleTimeDiffManager@@QAEPAUtm@@V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z$0:
  00000	8d 4d 08	 lea	 ecx, DWORD PTR _strRQ$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?CalcCurrentDateTimToPacketTime@CXScaleTimeDiffManager@@QAEPAUtm@@V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z$1:
  00009	8d 4d d8	 lea	 ecx, DWORD PTR _stringRQ$[ebp]
  0000c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
  00015	cc		 int	 3
__ehhandler$?CalcCurrentDateTimToPacketTime@CXScaleTimeDiffManager@@QAEPAUtm@@V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z:
  00016	90		 npad	 1
  00017	90		 npad	 1
  00018	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001f	8b 4a c8	 mov	 ecx, DWORD PTR [edx-56]
  00022	33 c8		 xor	 ecx, eax
  00024	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00029	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0002c	33 c8		 xor	 ecx, eax
  0002e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00033	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?CalcCurrentDateTimToPacketTime@CXScaleTimeDiffManager@@QAEPAUtm@@V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
  00038	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?CalcCurrentDateTimToPacketTime@CXScaleTimeDiffManager@@QAEPAUtm@@V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ENDP ; CXScaleTimeDiffManager::CalcCurrentDateTimToPacketTime
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp
;	COMDAT ?GetRQScreenDateTime@CXScaleTimeDiffManager@@QAE_JV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@_J@Z
_TEXT	SEGMENT
_spanTime$1$ = -56					; size = 4
__Loc$2 = -52						; size = 12
__Loc$3 = -52						; size = 12
_nMarketStartTime$ = -48				; size = 8
_stringRQ$ = -40					; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_strRQ$ = 8						; size = 4
_timeRQ$ = 12						; size = 8
?GetRQScreenDateTime@CXScaleTimeDiffManager@@QAE_JV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@_J@Z PROC ; CXScaleTimeDiffManager::GetRQScreenDateTime, COMDAT
; _this$ = ecx

; 152  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?GetRQScreenDateTime@CXScaleTimeDiffManager@@QAE_JV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@_J@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b f9		 mov	 edi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 404  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  0002d	8b 45 08	 mov	 eax, DWORD PTR _strRQ$[ebp]
  00030	8b d0		 mov	 edx, eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp

; 152  : {

  00032	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2313 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00039	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _stringRQ$[ebp], 0

; 4562 :         _My_data._Mysize = 0;

  00040	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _stringRQ$[ebp+16], 0

; 4563 : 
; 4564 : #ifdef __cpp_lib_constexpr_string
; 4565 :         if (_STD is_constant_evaluated()) {
; 4566 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4567 :             auto& _Al              = _Getal();
; 4568 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4569 :             _My_data._Bx._Ptr      = _New_ptr;
; 4570 : 
; 4571 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4572 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4573 :         } else
; 4574 : #endif // __cpp_lib_constexpr_string
; 4575 :         {
; 4576 :             _My_data._Myres = _BUF_SIZE - 1;

  00047	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR _stringRQ$[ebp+20], 15 ; 0000000fH

; 404  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  0004e	8d 72 01	 lea	 esi, DWORD PTR [edx+1]
$LL148@GetRQScree:
  00051	8a 0a		 mov	 cl, BYTE PTR [edx]
  00053	42		 inc	 edx
  00054	84 c9		 test	 cl, cl
  00056	75 f9		 jne	 SHORT $LL148@GetRQScree
  00058	2b d6		 sub	 edx, esi

; 3230 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0005a	8d 4d d8	 lea	 ecx, DWORD PTR _stringRQ$[ebp]
  0005d	52		 push	 edx
  0005e	50		 push	 eax
  0005f	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1353 :         const _Tree_find_result<_Nodeptr> _Loc = _Find_lower_bound(_Keyval);

  00064	8d 45 d8	 lea	 eax, DWORD PTR _stringRQ$[ebp]
  00067	50		 push	 eax
  00068	8d 45 cc	 lea	 eax, DWORD PTR __Loc$3[ebp]
  0006b	50		 push	 eax
  0006c	8d 4f 08	 lea	 ecx, DWORD PTR [edi+8]
  0006f	e8 00 00 00 00	 call	 ??$_Find_lower_bound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Find_lower_bound<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >

; 1591 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  00074	8b 75 d4	 mov	 esi, DWORD PTR __Loc$3[ebp+8]
  00077	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  0007b	0f 85 8c 00 00
	00		 jne	 $LN147@GetRQScree
  00081	8d 46 10	 lea	 eax, DWORD PTR [esi+16]
  00084	50		 push	 eax
  00085	8d 45 d8	 lea	 eax, DWORD PTR _stringRQ$[ebp]
  00088	50		 push	 eax
  00089	8d 4f 08	 lea	 ecx, DWORD PTR [edi+8]
  0008c	e8 00 00 00 00	 call	 ??R?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0@Z ; std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator()
  00091	84 c0		 test	 al, al
  00093	75 78		 jne	 SHORT $LN147@GetRQScree

; 38   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  00095	3b 77 08	 cmp	 esi, DWORD PTR [edi+8]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp

; 157  : 	if(it == m_mtdRQ.end())

  00098	74 73		 je	 SHORT $LN147@GetRQScree

; 160  : 	int	spanTime = it->second;

  0009a	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1353 :         const _Tree_find_result<_Nodeptr> _Loc = _Find_lower_bound(_Keyval);

  0009d	8d 4f 18	 lea	 ecx, DWORD PTR [edi+24]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp

; 160  : 	int	spanTime = it->second;

  000a0	89 45 c8	 mov	 DWORD PTR _spanTime$1$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1353 :         const _Tree_find_result<_Nodeptr> _Loc = _Find_lower_bound(_Keyval);

  000a3	8d 45 d8	 lea	 eax, DWORD PTR _stringRQ$[ebp]
  000a6	50		 push	 eax
  000a7	8d 45 cc	 lea	 eax, DWORD PTR __Loc$2[ebp]
  000aa	50		 push	 eax
  000ab	e8 00 00 00 00	 call	 ??$_Find_lower_bound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_JU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@PAX@std@@@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,__int64,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,__int64> >,0> >::_Find_lower_bound<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >

; 1591 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  000b0	8b 75 d4	 mov	 esi, DWORD PTR __Loc$2[ebp+8]
  000b3	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  000b7	75 29		 jne	 SHORT $LN88@GetRQScree
  000b9	8d 46 10	 lea	 eax, DWORD PTR [esi+16]
  000bc	50		 push	 eax
  000bd	8d 45 d8	 lea	 eax, DWORD PTR _stringRQ$[ebp]
  000c0	50		 push	 eax
  000c1	8d 4f 18	 lea	 ecx, DWORD PTR [edi+24]
  000c4	e8 00 00 00 00	 call	 ??R?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0@Z ; std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator()
  000c9	84 c0		 test	 al, al
  000cb	75 15		 jne	 SHORT $LN88@GetRQScree
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp

; 163  : 	time_t nMarketStartTime = 0;

  000cd	0f 57 c0	 xorps	 xmm0, xmm0
  000d0	66 0f 13 45 d0	 movlpd	 QWORD PTR _nMarketStartTime$[ebp], xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 38   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  000d5	3b 77 18	 cmp	 esi, DWORD PTR [edi+24]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp

; 165  : 	if(itm != m_mRQMarketTime.end())

  000d8	74 10		 je	 SHORT $LN149@GetRQScree

; 166  : 	{
; 167  : 		nMarketStartTime = itm->second;

  000da	8b 4e 28	 mov	 ecx, DWORD PTR [esi+40]
  000dd	8b 5e 2c	 mov	 ebx, DWORD PTR [esi+44]
  000e0	eb 0e		 jmp	 SHORT $LN3@GetRQScree
$LN88@GetRQScree:
  000e2	0f 57 c0	 xorps	 xmm0, xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1358 :         return _Get_scary()->_Myhead;

  000e5	66 0f 13 45 d0	 movlpd	 QWORD PTR _nMarketStartTime$[ebp], xmm0
$LN149@GetRQScree:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp

; 170  : 	return timeRQ + (3600 * (m_tmScreenTimeDiff - spanTime) ) + nMarketStartTime;

  000ea	8b 4d d0	 mov	 ecx, DWORD PTR _nMarketStartTime$[ebp]
  000ed	8b 5d d4	 mov	 ebx, DWORD PTR _nMarketStartTime$[ebp+4]
$LN3@GetRQScree:
  000f0	8b 47 24	 mov	 eax, DWORD PTR [edi+36]
  000f3	2b 45 c8	 sub	 eax, DWORD PTR _spanTime$1$[ebp]
  000f6	69 c0 10 0e 00
	00		 imul	 eax, eax, 3600
  000fc	99		 cdq
  000fd	8b f0		 mov	 esi, eax
  000ff	8b fa		 mov	 edi, edx
  00101	03 f1		 add	 esi, ecx
  00103	13 fb		 adc	 edi, ebx
  00105	03 75 0c	 add	 esi, DWORD PTR _timeRQ$[ebp]
  00108	13 7d 10	 adc	 edi, DWORD PTR _timeRQ$[ebp+4]
  0010b	eb 06		 jmp	 SHORT $LN7@GetRQScree
$LN147@GetRQScree:
  0010d	8b 75 0c	 mov	 esi, DWORD PTR _timeRQ$[ebp]
  00110	8b 7d 10	 mov	 edi, DWORD PTR _timeRQ$[ebp+4]
$LN7@GetRQScree:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2286 :         return _BUF_SIZE <= _Myres;

  00113	8b 55 ec	 mov	 edx, DWORD PTR _stringRQ$[ebp+20]
  00116	83 fa 10	 cmp	 edx, 16			; 00000010H

; 4584 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00119	72 2e		 jb	 SHORT $LN130@GetRQScree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0011b	8b 4d d8	 mov	 ecx, DWORD PTR _stringRQ$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4588 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0011e	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0011f	8b c1		 mov	 eax, ecx

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00121	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00127	72 16		 jb	 SHORT $LN140@GetRQScree

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00129	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  0012c	83 c2 23	 add	 edx, 35			; 00000023H
  0012f	2b c1		 sub	 eax, ecx

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00131	83 c0 fc	 add	 eax, -4			; fffffffcH
  00134	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00137	76 06		 jbe	 SHORT $LN140@GetRQScree
  00139	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN140@GetRQScree:

; 255  :         ::operator delete(_Ptr, _Bytes);

  0013f	52		 push	 edx
  00140	51		 push	 ecx
  00141	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00146	83 c4 08	 add	 esp, 8
$LN130@GetRQScree:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp

; 170  : 	return timeRQ + (3600 * (m_tmScreenTimeDiff - spanTime) ) + nMarketStartTime;

  00149	8d 4d 08	 lea	 ecx, DWORD PTR _strRQ$[ebp]
  0014c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00152	8b c6		 mov	 eax, esi
  00154	8b d7		 mov	 edx, edi

; 171  : 
; 172  : }

  00156	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00159	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00160	59		 pop	 ecx
  00161	5f		 pop	 edi
  00162	5e		 pop	 esi
  00163	5b		 pop	 ebx
  00164	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00167	33 cd		 xor	 ecx, ebp
  00169	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0016e	8b e5		 mov	 esp, ebp
  00170	5d		 pop	 ebp
  00171	c2 0c 00	 ret	 12			; 0000000cH
$LN151@GetRQScree:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetRQScreenDateTime@CXScaleTimeDiffManager@@QAE_JV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@_J@Z$0:
  00000	8d 4d 08	 lea	 ecx, DWORD PTR _strRQ$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
  0000d	cc		 int	 3
__ehhandler$?GetRQScreenDateTime@CXScaleTimeDiffManager@@QAE_JV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@_J@Z:
  0000e	90		 npad	 1
  0000f	90		 npad	 1
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a c4	 mov	 ecx, DWORD PTR [edx-60]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00024	33 c8		 xor	 ecx, eax
  00026	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?GetRQScreenDateTime@CXScaleTimeDiffManager@@QAE_JV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@_J@Z
  00030	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?GetRQScreenDateTime@CXScaleTimeDiffManager@@QAE_JV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@_J@Z ENDP ; CXScaleTimeDiffManager::GetRQScreenDateTime
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\time.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp
;	COMDAT ?GetRQScreenTime@CXScaleTimeDiffManager@@QAE_JV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAUtm@@@Z
_TEXT	SEGMENT
__Loc$2 = -52						; size = 12
_stringRQ$ = -40					; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_strRQ$ = 8						; size = 4
_timeRQ$ = 12						; size = 4
?GetRQScreenTime@CXScaleTimeDiffManager@@QAE_JV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAUtm@@@Z PROC ; CXScaleTimeDiffManager::GetRQScreenTime, COMDAT
; _this$ = ecx

; 128  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?GetRQScreenTime@CXScaleTimeDiffManager@@QAE_JV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAUtm@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 28	 sub	 esp, 40			; 00000028H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b f9		 mov	 edi, ecx
  0002d	8b 75 0c	 mov	 esi, DWORD PTR _timeRQ$[ebp]

; 129  : 	if( !m_strScreenRQ.Compare(strRQ) )		return mktime(timeRQ);		//    RQ  return

  00030	ff 75 08	 push	 DWORD PTR _strRQ$[ebp]
  00033	8d 4f 20	 lea	 ecx, DWORD PTR [edi+32]
  00036	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Compare@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEHPBD@Z
  00043	85 c0		 test	 eax, eax
  00045	75 13		 jne	 SHORT $LN2@GetRQScree
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\time.h

; 515  :             return _mktime64(_Tm);

  00047	56		 push	 esi
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___mktime64
  0004e	83 c4 04	 add	 esp, 4
  00051	8b f0		 mov	 esi, eax
  00053	8b fa		 mov	 edi, edx
  00055	e9 c1 00 00 00	 jmp	 $LN168@GetRQScree
$LN2@GetRQScree:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 404  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  0005a	8b 45 08	 mov	 eax, DWORD PTR _strRQ$[ebp]
  0005d	8b d0		 mov	 edx, eax

; 2313 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  0005f	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _stringRQ$[ebp], 0

; 4562 :         _My_data._Mysize = 0;

  00066	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _stringRQ$[ebp+16], 0

; 4563 : 
; 4564 : #ifdef __cpp_lib_constexpr_string
; 4565 :         if (_STD is_constant_evaluated()) {
; 4566 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4567 :             auto& _Al              = _Getal();
; 4568 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4569 :             _My_data._Bx._Ptr      = _New_ptr;
; 4570 : 
; 4571 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4572 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4573 :         } else
; 4574 : #endif // __cpp_lib_constexpr_string
; 4575 :         {
; 4576 :             _My_data._Myres = _BUF_SIZE - 1;

  0006d	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR _stringRQ$[ebp+20], 15 ; 0000000fH

; 404  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00074	8d 5a 01	 lea	 ebx, DWORD PTR [edx+1]
$LL187@GetRQScree:
  00077	8a 0a		 mov	 cl, BYTE PTR [edx]
  00079	42		 inc	 edx
  0007a	84 c9		 test	 cl, cl
  0007c	75 f9		 jne	 SHORT $LL187@GetRQScree
  0007e	2b d3		 sub	 edx, ebx

; 3230 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00080	8d 4d d8	 lea	 ecx, DWORD PTR _stringRQ$[ebp]
  00083	52		 push	 edx
  00084	50		 push	 eax
  00085	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1353 :         const _Tree_find_result<_Nodeptr> _Loc = _Find_lower_bound(_Keyval);

  0008a	8d 4d d8	 lea	 ecx, DWORD PTR _stringRQ$[ebp]
  0008d	51		 push	 ecx
  0008e	8d 4d cc	 lea	 ecx, DWORD PTR __Loc$2[ebp]
  00091	51		 push	 ecx
  00092	8d 4f 08	 lea	 ecx, DWORD PTR [edi+8]
  00095	e8 00 00 00 00	 call	 ??$_Find_lower_bound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Find_lower_bound<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >

; 1591 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  0009a	8b 5d d4	 mov	 ebx, DWORD PTR __Loc$2[ebp+8]
  0009d	80 7b 0d 00	 cmp	 BYTE PTR [ebx+13], 0
  000a1	75 34		 jne	 SHORT $LN186@GetRQScree
  000a3	8d 43 10	 lea	 eax, DWORD PTR [ebx+16]
  000a6	50		 push	 eax
  000a7	8d 45 d8	 lea	 eax, DWORD PTR _stringRQ$[ebp]
  000aa	50		 push	 eax
  000ab	8d 4f 08	 lea	 ecx, DWORD PTR [edi+8]
  000ae	e8 00 00 00 00	 call	 ??R?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0@Z ; std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator()
  000b3	84 c0		 test	 al, al
  000b5	75 20		 jne	 SHORT $LN186@GetRQScree

; 38   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  000b7	3b 5f 08	 cmp	 ebx, DWORD PTR [edi+8]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp

; 135  : 	if(it == m_mtdRQ.end())

  000ba	74 1b		 je	 SHORT $LN186@GetRQScree

; 136  : 		return mktime(timeRQ);
; 137  : 
; 138  : 	int	spanTime = it->second;

  000bc	8b 4b 28	 mov	 ecx, DWORD PTR [ebx+40]

; 139  : 	if( spanTime == 0 && m_tmScreenTimeDiff == 0 )

  000bf	85 c9		 test	 ecx, ecx
  000c1	75 05		 jne	 SHORT $LN185@GetRQScree
  000c3	39 4f 24	 cmp	 DWORD PTR [edi+36], ecx
  000c6	74 0f		 je	 SHORT $LN186@GetRQScree
$LN185@GetRQScree:

; 140  : 		return mktime(timeRQ);
; 141  : 	if( spanTime == m_tmScreenTimeDiff )		//      RQ  Return

  000c8	8b 47 24	 mov	 eax, DWORD PTR [edi+36]
  000cb	56		 push	 esi
  000cc	3b c8		 cmp	 ecx, eax
  000ce	74 08		 je	 SHORT $LN190@GetRQScree

; 142  : 		return mktime(timeRQ);
; 143  : 
; 144  : 	timeRQ->tm_hour += (m_tmScreenTimeDiff - spanTime);

  000d0	2b c1		 sub	 eax, ecx
  000d2	01 46 08	 add	 DWORD PTR [esi+8], eax

; 145  : 	return mktime(timeRQ);

  000d5	eb 01		 jmp	 SHORT $LN190@GetRQScree
$LN186@GetRQScree:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2286 :         return _BUF_SIZE <= _Myres;

  000d7	56		 push	 esi
$LN190@GetRQScree:
  000d8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___mktime64
  000de	8b fa		 mov	 edi, edx
  000e0	83 c4 04	 add	 esp, 4
  000e3	8b 55 ec	 mov	 edx, DWORD PTR _stringRQ$[ebp+20]
  000e6	8b f0		 mov	 esi, eax
  000e8	83 fa 10	 cmp	 edx, 16			; 00000010H

; 4584 :         if (_Mypair._Myval2._Large_string_engaged()) {

  000eb	72 2e		 jb	 SHORT $LN168@GetRQScree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000ed	8b 4d d8	 mov	 ecx, DWORD PTR _stringRQ$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4588 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  000f0	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000f1	8b c1		 mov	 eax, ecx

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  000f3	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  000f9	72 16		 jb	 SHORT $LN178@GetRQScree

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000fb	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  000fe	83 c2 23	 add	 edx, 35			; 00000023H
  00101	2b c1		 sub	 eax, ecx

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00103	83 c0 fc	 add	 eax, -4			; fffffffcH
  00106	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00109	76 06		 jbe	 SHORT $LN178@GetRQScree
  0010b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN178@GetRQScree:

; 255  :         ::operator delete(_Ptr, _Bytes);

  00111	52		 push	 edx
  00112	51		 push	 ecx
  00113	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00118	83 c4 08	 add	 esp, 8
$LN168@GetRQScree:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp

; 145  : 	return mktime(timeRQ);

  0011b	8d 4d 08	 lea	 ecx, DWORD PTR _strRQ$[ebp]
  0011e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00124	8b c6		 mov	 eax, esi
  00126	8b d7		 mov	 edx, edi

; 146  : }

  00128	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0012b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00132	59		 pop	 ecx
  00133	5f		 pop	 edi
  00134	5e		 pop	 esi
  00135	5b		 pop	 ebx
  00136	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00139	33 cd		 xor	 ecx, ebp
  0013b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00140	8b e5		 mov	 esp, ebp
  00142	5d		 pop	 ebp
  00143	c2 08 00	 ret	 8
$LN189@GetRQScree:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetRQScreenTime@CXScaleTimeDiffManager@@QAE_JV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAUtm@@@Z$0:
  00000	8d 4d 08	 lea	 ecx, DWORD PTR _strRQ$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
  0000d	cc		 int	 3
__ehhandler$?GetRQScreenTime@CXScaleTimeDiffManager@@QAE_JV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAUtm@@@Z:
  0000e	90		 npad	 1
  0000f	90		 npad	 1
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a c8	 mov	 ecx, DWORD PTR [edx-56]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00024	33 c8		 xor	 ecx, eax
  00026	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?GetRQScreenTime@CXScaleTimeDiffManager@@QAE_JV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAUtm@@@Z
  00030	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?GetRQScreenTime@CXScaleTimeDiffManager@@QAE_JV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAUtm@@@Z ENDP ; CXScaleTimeDiffManager::GetRQScreenTime
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp
;	COMDAT ?SetCurrentRQ@CXScaleTimeDiffManager@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
_TEXT	SEGMENT
__Loc$2 = -56						; size = 12
$T3 = -44						; size = 4
_stringRQ$ = -40					; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_strRQ$ = 8						; size = 4
?SetCurrentRQ@CXScaleTimeDiffManager@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z PROC ; CXScaleTimeDiffManager::SetCurrentRQ, COMDAT
; _this$ = ecx

; 120  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?SetCurrentRQ@CXScaleTimeDiffManager@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b d9		 mov	 ebx, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 404  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  0002d	8b 45 08	 mov	 eax, DWORD PTR _strRQ$[ebp]
  00030	8b d0		 mov	 edx, eax

; 2313 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00032	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _stringRQ$[ebp], 0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp

; 120  : {

  00039	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4562 :         _My_data._Mysize = 0;

  00040	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _stringRQ$[ebp+16], 0

; 4563 : 
; 4564 : #ifdef __cpp_lib_constexpr_string
; 4565 :         if (_STD is_constant_evaluated()) {
; 4566 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4567 :             auto& _Al              = _Getal();
; 4568 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4569 :             _My_data._Bx._Ptr      = _New_ptr;
; 4570 : 
; 4571 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4572 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4573 :         } else
; 4574 : #endif // __cpp_lib_constexpr_string
; 4575 :         {
; 4576 :             _My_data._Myres = _BUF_SIZE - 1;

  00047	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR _stringRQ$[ebp+20], 15 ; 0000000fH

; 404  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  0004e	8d 72 01	 lea	 esi, DWORD PTR [edx+1]

; 4578 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00051	c6 45 d8 00	 mov	 BYTE PTR _stringRQ$[ebp], 0
$LL91@SetCurrent:

; 404  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00055	8a 0a		 mov	 cl, BYTE PTR [edx]
  00057	42		 inc	 edx
  00058	84 c9		 test	 cl, cl
  0005a	75 f9		 jne	 SHORT $LL91@SetCurrent
  0005c	2b d6		 sub	 edx, esi

; 3230 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0005e	8d 4d d8	 lea	 ecx, DWORD PTR _stringRQ$[ebp]
  00061	52		 push	 edx
  00062	50		 push	 eax
  00063	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1353 :         const _Tree_find_result<_Nodeptr> _Loc = _Find_lower_bound(_Keyval);

  00068	8d 45 d8	 lea	 eax, DWORD PTR _stringRQ$[ebp]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp

; 121  : 	string stringRQ((LPSTR)(LPCSTR)strRQ);

  0006b	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1353 :         const _Tree_find_result<_Nodeptr> _Loc = _Find_lower_bound(_Keyval);

  0006f	50		 push	 eax
  00070	8d 45 c8	 lea	 eax, DWORD PTR __Loc$2[ebp]
  00073	50		 push	 eax
  00074	8d 4b 08	 lea	 ecx, DWORD PTR [ebx+8]
  00077	e8 00 00 00 00	 call	 ??$_Find_lower_bound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Find_lower_bound<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >

; 1591 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  0007c	8b 75 d0	 mov	 esi, DWORD PTR __Loc$2[ebp+8]
  0007f	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  00083	75 14		 jne	 SHORT $LN29@SetCurrent
  00085	8d 46 10	 lea	 eax, DWORD PTR [esi+16]
  00088	50		 push	 eax
  00089	8d 45 d8	 lea	 eax, DWORD PTR _stringRQ$[ebp]
  0008c	50		 push	 eax
  0008d	8d 4b 08	 lea	 ecx, DWORD PTR [ebx+8]
  00090	e8 00 00 00 00	 call	 ??R?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0@Z ; std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator()
  00095	84 c0		 test	 al, al
  00097	74 03		 je	 SHORT $LN28@SetCurrent
$LN29@SetCurrent:

; 1358 :         return _Get_scary()->_Myhead;

  00099	8b 73 08	 mov	 esi, DWORD PTR [ebx+8]
$LN28@SetCurrent:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp

; 123  : 	SetScreenDiffTime( strRQ, (it != m_mtdRQ.end()) ? it->second : 0 );

  0009c	3b 73 08	 cmp	 esi, DWORD PTR [ebx+8]
  0009f	74 05		 je	 SHORT $LN3@SetCurrent
  000a1	8b 76 28	 mov	 esi, DWORD PTR [esi+40]
  000a4	eb 02		 jmp	 SHORT $LN4@SetCurrent
$LN3@SetCurrent:
  000a6	33 f6		 xor	 esi, esi
$LN4@SetCurrent:
  000a8	8d 45 08	 lea	 eax, DWORD PTR _strRQ$[ebp]
  000ab	50		 push	 eax
  000ac	8d 4d d4	 lea	 ecx, DWORD PTR $T3[ebp]
  000af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z

; 114  : 	m_strScreenRQ = strRQ;

  000b5	8d 45 d4	 lea	 eax, DWORD PTR $T3[ebp]
  000b8	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  000bc	50		 push	 eax
  000bd	8d 4b 20	 lea	 ecx, DWORD PTR [ebx+32]
  000c0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z

; 115  : 	m_tmScreenTimeDiff = tmDiffTime;
; 116  : }

  000c6	8d 4d d4	 lea	 ecx, DWORD PTR $T3[ebp]
  000c9	89 73 24	 mov	 DWORD PTR [ebx+36], esi
  000cc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2286 :         return _BUF_SIZE <= _Myres;

  000d2	8b 55 ec	 mov	 edx, DWORD PTR _stringRQ$[ebp+20]
  000d5	83 fa 10	 cmp	 edx, 16			; 00000010H

; 4584 :         if (_Mypair._Myval2._Large_string_engaged()) {

  000d8	72 2e		 jb	 SHORT $LN74@SetCurrent
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000da	8b 4d d8	 mov	 ecx, DWORD PTR _stringRQ$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4588 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  000dd	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000de	8b c1		 mov	 eax, ecx

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  000e0	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  000e6	72 16		 jb	 SHORT $LN84@SetCurrent

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000e8	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  000eb	83 c2 23	 add	 edx, 35			; 00000023H
  000ee	2b c1		 sub	 eax, ecx

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000f0	83 c0 fc	 add	 eax, -4			; fffffffcH
  000f3	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  000f6	76 06		 jbe	 SHORT $LN84@SetCurrent
  000f8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN84@SetCurrent:

; 255  :         ::operator delete(_Ptr, _Bytes);

  000fe	52		 push	 edx
  000ff	51		 push	 ecx
  00100	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00105	83 c4 08	 add	 esp, 8
$LN74@SetCurrent:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp

; 124  : }

  00108	8d 4d 08	 lea	 ecx, DWORD PTR _strRQ$[ebp]
  0010b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00111	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00114	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0011b	59		 pop	 ecx
  0011c	5f		 pop	 edi
  0011d	5e		 pop	 esi
  0011e	5b		 pop	 ebx
  0011f	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00122	33 cd		 xor	 ecx, ebp
  00124	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00129	8b e5		 mov	 esp, ebp
  0012b	5d		 pop	 ebp
  0012c	c2 04 00	 ret	 4
$LN93@SetCurrent:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SetCurrentRQ@CXScaleTimeDiffManager@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z$0:
  00000	8d 4d 08	 lea	 ecx, DWORD PTR _strRQ$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?SetCurrentRQ@CXScaleTimeDiffManager@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z$1:
  00009	8d 4d d8	 lea	 ecx, DWORD PTR _stringRQ$[ebp]
  0000c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SetCurrentRQ@CXScaleTimeDiffManager@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z$5:
  00011	8d 4d d4	 lea	 ecx, DWORD PTR $T3[ebp]
  00014	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0001a	cc		 int	 3
  0001b	cc		 int	 3
  0001c	cc		 int	 3
  0001d	cc		 int	 3
  0001e	cc		 int	 3
__ehhandler$?SetCurrentRQ@CXScaleTimeDiffManager@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z:
  0001f	90		 npad	 1
  00020	90		 npad	 1
  00021	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00025	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00028	8b 4a c4	 mov	 ecx, DWORD PTR [edx-60]
  0002b	33 c8		 xor	 ecx, eax
  0002d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00032	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00035	33 c8		 xor	 ecx, eax
  00037	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?SetCurrentRQ@CXScaleTimeDiffManager@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
  00041	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?SetCurrentRQ@CXScaleTimeDiffManager@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ENDP ; CXScaleTimeDiffManager::SetCurrentRQ
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp
;	COMDAT ?SetScreenDiffTime@CXScaleTimeDiffManager@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_strRQ$ = 8						; size = 4
_tmDiffTime$ = 12					; size = 4
?SetScreenDiffTime@CXScaleTimeDiffManager@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z PROC ; CXScaleTimeDiffManager::SetScreenDiffTime, COMDAT
; _this$ = ecx

; 113  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?SetScreenDiffTime@CXScaleTimeDiffManager@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx

; 114  : 	m_strScreenRQ = strRQ;

  00025	8d 45 08	 lea	 eax, DWORD PTR _strRQ$[ebp]
  00028	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0002f	50		 push	 eax
  00030	8d 4e 20	 lea	 ecx, DWORD PTR [esi+32]
  00033	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z

; 115  : 	m_tmScreenTimeDiff = tmDiffTime;

  00039	8b 45 0c	 mov	 eax, DWORD PTR _tmDiffTime$[ebp]

; 116  : }

  0003c	8d 4d 08	 lea	 ecx, DWORD PTR _strRQ$[ebp]
  0003f	89 46 24	 mov	 DWORD PTR [esi+36], eax
  00042	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00048	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00052	59		 pop	 ecx
  00053	5e		 pop	 esi
  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SetScreenDiffTime@CXScaleTimeDiffManager@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z$0:
  00000	8d 4d 08	 lea	 ecx, DWORD PTR _strRQ$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
  0000d	cc		 int	 3
__ehhandler$?SetScreenDiffTime@CXScaleTimeDiffManager@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z:
  0000e	90		 npad	 1
  0000f	90		 npad	 1
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?SetScreenDiffTime@CXScaleTimeDiffManager@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z
  00026	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?SetScreenDiffTime@CXScaleTimeDiffManager@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z ENDP ; CXScaleTimeDiffManager::SetScreenDiffTime
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp
;	COMDAT ?SetRQMarketTime@CXScaleTimeDiffManager@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HHW4MARKETDAYTYPE@CPacketType@@@Z
_TEXT	SEGMENT
$T2 = -124						; size = 16
__Loc$3 = -108						; size = 12
$T4 = -96						; size = 12
$T5 = -92						; size = 8
__Result$2$ = -88					; size = 4
_this$GSCopy$1$ = -84					; size = 4
_timeResult$1$ = -80					; size = 4
_timeResult$2$ = -76					; size = 4
$T6 = -72						; size = 32
_stringRQ$ = -40					; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_strRQ$ = 8						; size = 4
_nMarketStartTime$ = 12					; size = 4
_nMarketEndTime$ = 16					; size = 4
_nMarketDayType$ = 20					; size = 4
?SetRQMarketTime@CXScaleTimeDiffManager@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HHW4MARKETDAYTYPE@CPacketType@@@Z PROC ; CXScaleTimeDiffManager::SetRQMarketTime, COMDAT
; _this$ = ecx

; 89   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?SetRQMarketTime@CXScaleTimeDiffManager@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HHW4MARKETDAYTYPE@CPacketType@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 70	 sub	 esp, 112		; 00000070H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	56		 push	 esi
  0001f	57		 push	 edi
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	89 4d ac	 mov	 DWORD PTR _this$GSCopy$1$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h

; 519  : 		return( GetData()->nDataLength );

  0002d	8b 45 08	 mov	 eax, DWORD PTR _strRQ$[ebp]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp

; 89   : {

  00030	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h

; 533  : 		return( GetLength() == 0 );

  00037	83 78 f4 00	 cmp	 DWORD PTR [eax-12], 0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp

; 90   : 	if( strRQ.IsEmpty() )

  0003b	0f 84 55 02 00
	00		 je	 $LN237@SetRQMarke
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 404  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00041	8b c8		 mov	 ecx, eax

; 2313 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00043	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _stringRQ$[ebp], 0

; 4562 :         _My_data._Mysize = 0;

  0004a	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _stringRQ$[ebp+16], 0

; 4563 : 
; 4564 : #ifdef __cpp_lib_constexpr_string
; 4565 :         if (_STD is_constant_evaluated()) {
; 4566 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4567 :             auto& _Al              = _Getal();
; 4568 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4569 :             _My_data._Bx._Ptr      = _New_ptr;
; 4570 : 
; 4571 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4572 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4573 :         } else
; 4574 : #endif // __cpp_lib_constexpr_string
; 4575 :         {
; 4576 :             _My_data._Myres = _BUF_SIZE - 1;

  00051	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR _stringRQ$[ebp+20], 15 ; 0000000fH

; 4577 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4578 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00058	c6 45 d8 00	 mov	 BYTE PTR _stringRQ$[ebp], 0

; 404  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  0005c	8d 71 01	 lea	 esi, DWORD PTR [ecx+1]
  0005f	90		 npad	 1
$LL254@SetRQMarke:
  00060	8a 11		 mov	 dl, BYTE PTR [ecx]
  00062	41		 inc	 ecx
  00063	84 d2		 test	 dl, dl
  00065	75 f9		 jne	 SHORT $LL254@SetRQMarke
  00067	2b ce		 sub	 ecx, esi

; 3230 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00069	51		 push	 ecx
  0006a	50		 push	 eax
  0006b	8d 4d d8	 lea	 ecx, DWORD PTR _stringRQ$[ebp]
  0006e	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp

; 103  : 	timeResult += ( 60 * (nMarketStartTime%10000/100) );

  00073	8b 7d 0c	 mov	 edi, DWORD PTR _nMarketStartTime$[ebp]
  00076	b8 ad 8b db 68	 mov	 eax, 1759218605		; 68db8badH
  0007b	f7 ef		 imul	 edi
  0007d	8b cf		 mov	 ecx, edi
  0007f	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00083	c1 fa 0c	 sar	 edx, 12			; 0000000cH
  00086	8b f2		 mov	 esi, edx
  00088	c1 ee 1f	 shr	 esi, 31			; 0000001fH
  0008b	03 f2		 add	 esi, edx
  0008d	69 c6 10 27 00
	00		 imul	 eax, esi, 10000
  00093	2b c8		 sub	 ecx, eax
  00095	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  0009a	f7 e9		 imul	 ecx
  0009c	c1 fa 05	 sar	 edx, 5
  0009f	8b ca		 mov	 ecx, edx
  000a1	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  000a4	03 ca		 add	 ecx, edx
  000a6	8b c1		 mov	 eax, ecx
  000a8	c1 e0 04	 shl	 eax, 4
  000ab	2b c1		 sub	 eax, ecx
  000ad	c1 e0 02	 shl	 eax, 2
  000b0	99		 cdq
  000b1	89 45 b4	 mov	 DWORD PTR _timeResult$2$[ebp], eax

; 104  : 	timeResult += nMarketStartTime%100;

  000b4	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  000b9	89 55 b0	 mov	 DWORD PTR _timeResult$1$[ebp], edx
  000bc	f7 ef		 imul	 edi
  000be	c1 fa 05	 sar	 edx, 5
  000c1	8b ca		 mov	 ecx, edx
  000c3	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  000c6	03 ca		 add	 ecx, edx
  000c8	6b c9 64	 imul	 ecx, ecx, 100
  000cb	2b f9		 sub	 edi, ecx
  000cd	8b 4d b4	 mov	 ecx, DWORD PTR _timeResult$2$[ebp]
  000d0	8b c7		 mov	 eax, edi
  000d2	8b 7d b0	 mov	 edi, DWORD PTR _timeResult$1$[ebp]
  000d5	99		 cdq
  000d6	03 c8		 add	 ecx, eax
  000d8	13 fa		 adc	 edi, edx
  000da	69 c6 10 0e 00
	00		 imul	 eax, esi, 3600
  000e0	99		 cdq
  000e1	03 c8		 add	 ecx, eax
  000e3	89 4d b4	 mov	 DWORD PTR _timeResult$2$[ebp], ecx
  000e6	13 fa		 adc	 edi, edx

; 105  : 
; 106  : 	if( nMarketDayType == CPacketType::WITH_NEXT_DAY) timeResult -= ( 3600 * 24 );

  000e8	83 7d 14 01	 cmp	 DWORD PTR _nMarketDayType$[ebp], 1
  000ec	89 7d b0	 mov	 DWORD PTR _timeResult$1$[ebp], edi
  000ef	75 0f		 jne	 SHORT $LN3@SetRQMarke
  000f1	81 c1 80 ae fe
	ff		 add	 ecx, -86400		; fffeae80H
  000f7	89 4d b4	 mov	 DWORD PTR _timeResult$2$[ebp], ecx
  000fa	83 d7 ff	 adc	 edi, -1
  000fd	89 7d b0	 mov	 DWORD PTR _timeResult$1$[ebp], edi
$LN3@SetRQMarke:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2273 :         if (_Large_string_engaged()) {

  00100	83 7d ec 10	 cmp	 DWORD PTR _stringRQ$[ebp+20], 16 ; 00000010H
  00104	8d 4d d8	 lea	 ecx, DWORD PTR _stringRQ$[ebp]

; 2899 :         if (_Stay_small) { // stay small, don't allocate

  00107	8b 45 e8	 mov	 eax, DWORD PTR _stringRQ$[ebp+16]

; 2273 :         if (_Large_string_engaged()) {

  0010a	0f 43 4d d8	 cmovae	 ecx, DWORD PTR _stringRQ$[ebp]
  0010e	89 4d a8	 mov	 DWORD PTR __Result$2$[ebp], ecx

; 2899 :         if (_Stay_small) { // stay small, don't allocate

  00111	83 f8 10	 cmp	 eax, 16			; 00000010H
  00114	73 11		 jae	 SHORT $LN47@SetRQMarke

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00116	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]

; 2902 :             _My_data._Myres  = _BUF_SIZE - 1;

  00119	be 0f 00 00 00	 mov	 esi, 15			; 0000000fH

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0011e	0f 11 45 b8	 movups	 XMMWORD PTR $T6[ebp], xmm0

; 2903 :             return;

  00122	8b 7d b8	 mov	 edi, DWORD PTR $T6[ebp]
  00125	eb 38		 jmp	 SHORT $LN257@SetRQMarke
$LN47@SetRQMarke:

; 2904 :         }
; 2905 : 
; 2906 :         auto& _Al                     = _Getal();
; 2907 :         const size_type _New_capacity = (_STD min)(_Right_size | _ALLOC_MASK, max_size());

  00127	8b f0		 mov	 esi, eax

; 2908 :         const pointer _New_array      = _Al.allocate(_New_capacity + 1); // throws

  00129	8d 4d b8	 lea	 ecx, DWORD PTR $T6[ebp]
  0012c	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00131	83 ce 0f	 or	 esi, 15			; 0000000fH
  00134	3b f0		 cmp	 esi, eax
  00136	0f 47 f0	 cmova	 esi, eax
  00139	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  0013c	50		 push	 eax
  0013d	e8 00 00 00 00	 call	 ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate

; 2909 :         _Construct_in_place(_My_data._Bx._Ptr, _New_array);
; 2910 : 
; 2911 : #ifdef __cpp_lib_constexpr_string
; 2912 :         if (_STD is_constant_evaluated()) { // Begin the lifetimes of the objects before copying to avoid UB
; 2913 :             _Traits::assign(_Unfancy(_New_array), _New_capacity + 1, _Elem());
; 2914 :         }
; 2915 : #endif // __cpp_lib_constexpr_string
; 2916 :         _Traits::copy(_Unfancy(_New_array), _Right_ptr, _Right_size + 1);

  00142	8b 4d e8	 mov	 ecx, DWORD PTR _stringRQ$[ebp+16]
  00145	8b f8		 mov	 edi, eax
  00147	41		 inc	 ecx
  00148	89 7d b8	 mov	 DWORD PTR $T6[ebp], edi

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0014b	51		 push	 ecx
  0014c	ff 75 a8	 push	 DWORD PTR __Result$2$[ebp]
  0014f	57		 push	 edi
  00150	e8 00 00 00 00	 call	 _memcpy

; 2917 :         _My_data._Mysize = _Right_size;

  00155	8b 45 e8	 mov	 eax, DWORD PTR _stringRQ$[ebp+16]

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00158	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2918 :         _My_data._Myres  = _New_capacity;

  0015b	0f 10 45 b8	 movups	 xmm0, XMMWORD PTR $T6[ebp]
$LN257@SetRQMarke:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 186  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  0015f	89 45 c8	 mov	 DWORD PTR $T6[ebp+16], eax
  00162	8b 45 b4	 mov	 eax, DWORD PTR _timeResult$2$[ebp]
  00165	89 45 d0	 mov	 DWORD PTR $T6[ebp+24], eax
  00168	8b 45 b0	 mov	 eax, DWORD PTR _timeResult$1$[ebp]
  0016b	0f 11 45 84	 movups	 XMMWORD PTR $T2[ebp], xmm0
  0016f	89 75 cc	 mov	 DWORD PTR $T6[ebp+20], esi
  00172	89 45 d4	 mov	 DWORD PTR $T6[ebp+28], eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp

; 108  : 	m_mRQMarketTime.insert(PAIR_RQ_TIME_MARKET(stringRQ, timeResult));

  00175	8b 45 ac	 mov	 eax, DWORD PTR _this$GSCopy$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1006 :             _Loc                = _Find_lower_bound(_Keyval);

  00178	8d 4d b8	 lea	 ecx, DWORD PTR $T6[ebp]
  0017b	51		 push	 ecx
  0017c	8d 4d a0	 lea	 ecx, DWORD PTR $T4[ebp]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp

; 108  : 	m_mRQMarketTime.insert(PAIR_RQ_TIME_MARKET(stringRQ, timeResult));

  0017f	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1006 :             _Loc                = _Find_lower_bound(_Keyval);

  00183	51		 push	 ecx
  00184	8d 48 18	 lea	 ecx, DWORD PTR [eax+24]
  00187	e8 00 00 00 00	 call	 ??$_Find_lower_bound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_JU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@PAX@std@@@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,__int64,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,__int64> >,0> >::_Find_lower_bound<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
  0018c	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  00190	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00193	66 0f d6 45 94	 movq	 QWORD PTR __Loc$3[ebp], xmm0

; 1591 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  00198	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0019c	75 4b		 jne	 SHORT $LN70@SetRQMarke
  0019e	8b 4d ac	 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  001a1	83 c0 10	 add	 eax, 16			; 00000010H
  001a4	50		 push	 eax
  001a5	8d 45 b8	 lea	 eax, DWORD PTR $T6[ebp]
  001a8	50		 push	 eax
  001a9	8d 49 18	 lea	 ecx, DWORD PTR [ecx+24]
  001ac	e8 00 00 00 00	 call	 ??R?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0@Z ; std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator()
  001b1	84 c0		 test	 al, al
  001b3	75 34		 jne	 SHORT $LN70@SetRQMarke
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2286 :         return _BUF_SIZE <= _Myres;

  001b5	83 fe 10	 cmp	 esi, 16			; 00000010H

; 4584 :         if (_Mypair._Myval2._Large_string_engaged()) {

  001b8	0f 82 a0 00 00
	00		 jb	 $LN209@SetRQMarke

; 4588 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  001be	46		 inc	 esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  001bf	8b c7		 mov	 eax, edi

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  001c1	81 fe 00 10 00
	00		 cmp	 esi, 4096		; 00001000H
  001c7	72 14		 jb	 SHORT $LN219@SetRQMarke

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  001c9	8b 7f fc	 mov	 edi, DWORD PTR [edi-4]
  001cc	83 c6 23	 add	 esi, 35			; 00000023H
  001cf	2b c7		 sub	 eax, edi

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  001d1	83 c0 fc	 add	 eax, -4			; fffffffcH
  001d4	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  001d7	0f 87 a9 00 00
	00		 ja	 $LN244@SetRQMarke
$LN219@SetRQMarke:

; 255  :         ::operator delete(_Ptr, _Bytes);

  001dd	56		 push	 esi
  001de	57		 push	 edi
  001df	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  001e4	83 c4 08	 add	 esp, 8
  001e7	eb 75		 jmp	 SHORT $LN209@SetRQMarke
$LN70@SetRQMarke:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1615 :         if (max_size() == _Get_scary()->_Mysize) {

  001e9	8b 7d ac	 mov	 edi, DWORD PTR _this$GSCopy$1$[ebp]
  001ec	83 c7 18	 add	 edi, 24			; 00000018H
  001ef	81 7f 04 55 55
	55 05		 cmp	 DWORD PTR [edi+4], 89478485 ; 05555555H
  001f6	0f 84 c0 00 00
	00		 je	 $LN259@SetRQMarke

; 1012 :             _Inserted = _Tree_temp_node<_Alnode>(_Getal(), _Scary->_Myhead, _STD forward<_Valtys>(_Vals)...)._Release();

  001fc	8b 37		 mov	 esi, DWORD PTR [edi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 958  :     _CONSTEXPR20_DYNALLOC explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

  001fe	89 7d a4	 mov	 DWORD PTR $T5[ebp], edi

; 79   :         return ::operator new(_Bytes);

  00201	6a 30		 push	 48			; 00000030H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 783  :     explicit _Tree_temp_node_alloc(_Alnode& _Al_) : _Alloc_construct_ptr<_Alnode>(_Al_) {

  00203	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 965  :         _Ptr = nullptr; // if allocate throws, prevents double-free

  00207	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR $T5[ebp+4], 0

; 79   :         return ::operator new(_Bytes);

  0020e	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2835 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  00213	0f 10 45 84	 movups	 xmm0, XMMWORD PTR $T2[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 242  :         : first(_STD forward<_Other1>(_Right.first)), second(_STD forward<_Other2>(_Right.second)) {}

  00217	8b 4d b4	 mov	 ecx, DWORD PTR _timeResult$2$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 79   :         return ::operator new(_Bytes);

  0021a	83 c4 04	 add	 esp, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2322 :     size_type _Mysize = 0; // current length of string

  0021d	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], 0

; 2323 :     size_type _Myres  = 0; // current storage reserved for string

  00224	c7 40 24 00 00
	00 00		 mov	 DWORD PTR [eax+36], 0

; 2835 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  0022b	0f 11 40 10	 movups	 XMMWORD PTR [eax+16], xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1031 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  0022f	50		 push	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2835 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  00230	f3 0f 7e 45 c8	 movq	 xmm0, QWORD PTR $T6[ebp+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1031 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  00235	ff 75 98	 push	 DWORD PTR __Loc$3[ebp+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2835 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  00238	66 0f d6 40 20	 movq	 QWORD PTR [eax+32], xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1031 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  0023d	ff 75 94	 push	 DWORD PTR __Loc$3[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 242  :         : first(_STD forward<_Other1>(_Right.first)), second(_STD forward<_Other2>(_Right.second)) {}

  00240	89 48 28	 mov	 DWORD PTR [eax+40], ecx
  00243	8b 4d b0	 mov	 ecx, DWORD PTR _timeResult$1$[ebp]
  00246	89 48 2c	 mov	 DWORD PTR [eax+44], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1031 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  00249	8b cf		 mov	 ecx, edi

; 806  :         _Construct_in_place(this->_Ptr->_Left, _Myhead);

  0024b	89 30		 mov	 DWORD PTR [eax], esi

; 807  :         _Construct_in_place(this->_Ptr->_Parent, _Myhead);

  0024d	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 808  :         _Construct_in_place(this->_Ptr->_Right, _Myhead);

  00250	89 70 08	 mov	 DWORD PTR [eax+8], esi

; 809  :         this->_Ptr->_Color = _Red;

  00253	66 c7 40 0c 00
	00		 mov	 WORD PTR [eax+12], 0

; 1031 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  00259	e8 00 00 00 00	 call	 ?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@PAX@std@@@2@QAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,__int64> > >::_Insert_node
$LN209@SetRQMarke:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2286 :         return _BUF_SIZE <= _Myres;

  0025e	8b 45 ec	 mov	 eax, DWORD PTR _stringRQ$[ebp+20]
  00261	83 f8 10	 cmp	 eax, 16			; 00000010H

; 4584 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00264	72 30		 jb	 SHORT $LN237@SetRQMarke
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00266	8b 4d d8	 mov	 ecx, DWORD PTR _stringRQ$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4588 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00269	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0026c	8b c1		 mov	 eax, ecx

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0026e	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00274	72 16		 jb	 SHORT $LN247@SetRQMarke

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00276	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00279	83 c2 23	 add	 edx, 35			; 00000023H
  0027c	2b c1		 sub	 eax, ecx

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0027e	83 c0 fc	 add	 eax, -4			; fffffffcH
  00281	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00284	76 06		 jbe	 SHORT $LN247@SetRQMarke
$LN244@SetRQMarke:
  00286	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN247@SetRQMarke:

; 255  :         ::operator delete(_Ptr, _Bytes);

  0028c	52		 push	 edx
  0028d	51		 push	 ecx
  0028e	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00293	83 c4 08	 add	 esp, 8
$LN237@SetRQMarke:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp

; 109  : }

  00296	8d 4d 08	 lea	 ecx, DWORD PTR _strRQ$[ebp]
  00299	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0029f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  002a2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  002a9	59		 pop	 ecx
  002aa	5f		 pop	 edi
  002ab	5e		 pop	 esi
  002ac	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002af	33 cd		 xor	 ecx, ebp
  002b1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002b6	8b e5		 mov	 esp, ebp
  002b8	5d		 pop	 ebp
  002b9	c2 10 00	 ret	 16			; 00000010H
$LN259@SetRQMarke:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1616 :             _Throw_tree_length_error();

  002bc	e8 00 00 00 00	 call	 ?_Throw_tree_length_error@std@@YAXXZ ; std::_Throw_tree_length_error
$LN256@SetRQMarke:
  002c1	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SetRQMarketTime@CXScaleTimeDiffManager@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HHW4MARKETDAYTYPE@CPacketType@@@Z$0:
  00000	8d 4d 08	 lea	 ecx, DWORD PTR _strRQ$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?SetRQMarketTime@CXScaleTimeDiffManager@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HHW4MARKETDAYTYPE@CPacketType@@@Z$1:
  00009	8d 4d d8	 lea	 ecx, DWORD PTR _stringRQ$[ebp]
  0000c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SetRQMarketTime@CXScaleTimeDiffManager@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HHW4MARKETDAYTYPE@CPacketType@@@Z$2:
  00011	8d 4d b8	 lea	 ecx, DWORD PTR $T6[ebp]
  00014	e9 00 00 00 00	 jmp	 ??1?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@QAE@XZ
__unwindfunclet$?SetRQMarketTime@CXScaleTimeDiffManager@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HHW4MARKETDAYTYPE@CPacketType@@@Z$10:
  00019	8d 4d a4	 lea	 ecx, DWORD PTR $T5[ebp]
  0001c	e9 00 00 00 00	 jmp	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,__int64>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,__int64>,void *> > >
  00021	cc		 int	 3
  00022	cc		 int	 3
  00023	cc		 int	 3
  00024	cc		 int	 3
  00025	cc		 int	 3
__ehhandler$?SetRQMarketTime@CXScaleTimeDiffManager@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HHW4MARKETDAYTYPE@CPacketType@@@Z:
  00026	90		 npad	 1
  00027	90		 npad	 1
  00028	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0002c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0002f	8b 4a 84	 mov	 ecx, DWORD PTR [edx-124]
  00032	33 c8		 xor	 ecx, eax
  00034	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00039	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0003c	33 c8		 xor	 ecx, eax
  0003e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00043	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?SetRQMarketTime@CXScaleTimeDiffManager@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HHW4MARKETDAYTYPE@CPacketType@@@Z
  00048	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?SetRQMarketTime@CXScaleTimeDiffManager@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HHW4MARKETDAYTYPE@CPacketType@@@Z ENDP ; CXScaleTimeDiffManager::SetRQMarketTime
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp
;	COMDAT ?SetRQDiffTime@CXScaleTimeDiffManager@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H_J@Z
_TEXT	SEGMENT
$T2 = -188						; size = 16
__Loc$3 = -172						; size = 12
tv1680 = -168						; size = 8
__Result$2$ = -164					; size = 4
tv1384 = -164						; size = 4
tv1266 = -164						; size = 4
tv1374 = -160						; size = 4
tv1271 = -160						; size = 4
tv1383 = -156						; size = 4
tv1349 = -156						; size = 4
$T4 = -152						; size = 12
tv1689 = -148						; size = 8
tv1538 = -148						; size = 8
tv1529 = -148						; size = 8
__Result$5 = -148					; size = 8
tv827 = -148						; size = 8
$T6 = -148						; size = 8
__Result$2$ = -144					; size = 4
tv1297 = -144						; size = 4
tv1270 = -144						; size = 4
_this$GSCopy$1$ = -140					; size = 4
$T7 = -136						; size = 60
_currTime$8 = -76					; size = 36
$T9 = -68						; size = 28
_stringRQ$ = -40					; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_strRQ$ = 8						; size = 4
_tmDiffTime$ = 12					; size = 4
_nCurrTime$ = 16					; size = 8
?SetRQDiffTime@CXScaleTimeDiffManager@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H_J@Z PROC ; CXScaleTimeDiffManager::SetRQDiffTime, COMDAT
; _this$ = ecx

; 63   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?SetRQDiffTime@CXScaleTimeDiffManager@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H_J@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec b0 00 00
	00		 sub	 esp, 176		; 000000b0H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 8d 74 ff ff
	ff		 mov	 DWORD PTR _this$GSCopy$1$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h

; 519  : 		return( GetData()->nDataLength );

  00034	8b 45 08	 mov	 eax, DWORD PTR _strRQ$[ebp]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp

; 63   : {

  00037	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h

; 533  : 		return( GetLength() == 0 );

  0003e	83 78 f4 00	 cmp	 DWORD PTR [eax-12], 0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp

; 64   : 	if( strRQ.IsEmpty() )

  00042	0f 84 68 04 00
	00		 je	 $LN308@SetRQDiffT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 404  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00048	8b c8		 mov	 ecx, eax

; 2313 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  0004a	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _stringRQ$[ebp], 0

; 4562 :         _My_data._Mysize = 0;

  00051	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _stringRQ$[ebp+16], 0

; 4576 :             _My_data._Myres = _BUF_SIZE - 1;

  00058	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR _stringRQ$[ebp+20], 15 ; 0000000fH

; 4577 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4578 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  0005f	c6 45 d8 00	 mov	 BYTE PTR _stringRQ$[ebp], 0

; 404  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00063	8d 71 01	 lea	 esi, DWORD PTR [ecx+1]
$LL325@SetRQDiffT:
  00066	8a 11		 mov	 dl, BYTE PTR [ecx]
  00068	41		 inc	 ecx
  00069	84 d2		 test	 dl, dl
  0006b	75 f9		 jne	 SHORT $LL325@SetRQDiffT
  0006d	2b ce		 sub	 ecx, esi

; 3230 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0006f	51		 push	 ecx
  00070	50		 push	 eax
  00071	8d 4d d8	 lea	 ecx, DWORD PTR _stringRQ$[ebp]
  00074	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 2273 :         if (_Large_string_engaged()) {

  00079	83 7d ec 10	 cmp	 DWORD PTR _stringRQ$[ebp+20], 16 ; 00000010H
  0007d	8d 4d d8	 lea	 ecx, DWORD PTR _stringRQ$[ebp]

; 2899 :         if (_Stay_small) { // stay small, don't allocate

  00080	8b 45 e8	 mov	 eax, DWORD PTR _stringRQ$[ebp+16]
  00083	ba ff ff ff 7f	 mov	 edx, 2147483647		; 7fffffffH

; 2273 :         if (_Large_string_engaged()) {

  00088	0f 43 4d d8	 cmovae	 ecx, DWORD PTR _stringRQ$[ebp]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp

; 67   : 	string stringRQ((LPSTR)(LPCTSTR)strRQ);

  0008c	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2273 :         if (_Large_string_engaged()) {

  00090	89 8d 5c ff ff
	ff		 mov	 DWORD PTR __Result$2$[ebp], ecx

; 2899 :         if (_Stay_small) { // stay small, don't allocate

  00096	83 f8 10	 cmp	 eax, 16			; 00000010H
  00099	73 11		 jae	 SHORT $LN48@SetRQDiffT

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0009b	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]

; 2902 :             _My_data._Myres  = _BUF_SIZE - 1;

  0009e	bf 0f 00 00 00	 mov	 edi, 15			; 0000000fH

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000a3	0f 11 45 bc	 movups	 XMMWORD PTR $T9[ebp], xmm0

; 2903 :             return;

  000a7	8b 75 bc	 mov	 esi, DWORD PTR $T9[ebp]
  000aa	eb 36		 jmp	 SHORT $LN330@SetRQDiffT
$LN48@SetRQDiffT:

; 2904 :         }
; 2905 : 
; 2906 :         auto& _Al                     = _Getal();
; 2907 :         const size_type _New_capacity = (_STD min)(_Right_size | _ALLOC_MASK, max_size());

  000ac	8b f8		 mov	 edi, eax

; 2908 :         const pointer _New_array      = _Al.allocate(_New_capacity + 1); // throws

  000ae	8d 4d bc	 lea	 ecx, DWORD PTR $T9[ebp]
  000b1	83 cf 0f	 or	 edi, 15			; 0000000fH
  000b4	3b fa		 cmp	 edi, edx
  000b6	0f 47 fa	 cmova	 edi, edx
  000b9	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  000bc	50		 push	 eax
  000bd	e8 00 00 00 00	 call	 ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate
  000c2	8b f0		 mov	 esi, eax

; 2909 :         _Construct_in_place(_My_data._Bx._Ptr, _New_array);
; 2910 : 
; 2911 : #ifdef __cpp_lib_constexpr_string
; 2912 :         if (_STD is_constant_evaluated()) { // Begin the lifetimes of the objects before copying to avoid UB
; 2913 :             _Traits::assign(_Unfancy(_New_array), _New_capacity + 1, _Elem());
; 2914 :         }
; 2915 : #endif // __cpp_lib_constexpr_string
; 2916 :         _Traits::copy(_Unfancy(_New_array), _Right_ptr, _Right_size + 1);

  000c4	8b 45 e8	 mov	 eax, DWORD PTR _stringRQ$[ebp+16]
  000c7	40		 inc	 eax
  000c8	89 75 bc	 mov	 DWORD PTR $T9[ebp], esi

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000cb	50		 push	 eax
  000cc	ff b5 5c ff ff
	ff		 push	 DWORD PTR __Result$2$[ebp]
  000d2	56		 push	 esi
  000d3	e8 00 00 00 00	 call	 _memcpy

; 2917 :         _My_data._Mysize = _Right_size;

  000d8	8b 45 e8	 mov	 eax, DWORD PTR _stringRQ$[ebp+16]

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000db	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2918 :         _My_data._Myres  = _New_capacity;

  000de	0f 10 45 bc	 movups	 xmm0, XMMWORD PTR $T9[ebp]
$LN330@SetRQDiffT:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 186  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  000e2	89 45 cc	 mov	 DWORD PTR $T9[ebp+16], eax
  000e5	8b 45 0c	 mov	 eax, DWORD PTR _tmDiffTime$[ebp]
  000e8	0f 11 85 44 ff
	ff ff		 movups	 XMMWORD PTR $T2[ebp], xmm0
  000ef	89 7d d0	 mov	 DWORD PTR $T9[ebp+20], edi
  000f2	89 45 d4	 mov	 DWORD PTR $T9[ebp+24], eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp

; 69   : 	m_mtdRQ.insert(PAIR_RQ_TIME_DIFF(stringRQ, tmDiffTime));

  000f5	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _this$GSCopy$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1006 :             _Loc                = _Find_lower_bound(_Keyval);

  000fb	8d 4d bc	 lea	 ecx, DWORD PTR $T9[ebp]
  000fe	51		 push	 ecx
  000ff	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp

; 69   : 	m_mtdRQ.insert(PAIR_RQ_TIME_DIFF(stringRQ, tmDiffTime));

  00105	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1006 :             _Loc                = _Find_lower_bound(_Keyval);

  00109	51		 push	 ecx
  0010a	8d 48 08	 lea	 ecx, DWORD PTR [eax+8]
  0010d	e8 00 00 00 00	 call	 ??$_Find_lower_bound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Find_lower_bound<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
  00112	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  00116	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00119	66 0f d6 85 54
	ff ff ff	 movq	 QWORD PTR __Loc$3[ebp], xmm0

; 1591 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  00121	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00125	75 1e		 jne	 SHORT $LN71@SetRQDiffT
  00127	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  0012d	83 c0 10	 add	 eax, 16			; 00000010H
  00130	50		 push	 eax
  00131	8d 45 bc	 lea	 eax, DWORD PTR $T9[ebp]
  00134	50		 push	 eax
  00135	8d 49 08	 lea	 ecx, DWORD PTR [ecx+8]
  00138	e8 00 00 00 00	 call	 ??R?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0@Z ; std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator()
  0013d	84 c0		 test	 al, al
  0013f	0f 84 94 00 00
	00		 je	 $LN183@SetRQDiffT
$LN71@SetRQDiffT:

; 1615 :         if (max_size() == _Get_scary()->_Mysize) {

  00145	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _this$GSCopy$1$[ebp]
  0014b	83 c0 08	 add	 eax, 8
  0014e	81 78 04 5d 74
	d1 05		 cmp	 DWORD PTR [eax+4], 97612893 ; 05d1745dH
  00155	0f 84 7c 03 00
	00		 je	 $LN333@SetRQDiffT

; 1012 :             _Inserted = _Tree_temp_node<_Alnode>(_Getal(), _Scary->_Myhead, _STD forward<_Valtys>(_Vals)...)._Release();

  0015b	8b 30		 mov	 esi, DWORD PTR [eax]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 958  :     _CONSTEXPR20_DYNALLOC explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

  0015d	89 85 6c ff ff
	ff		 mov	 DWORD PTR $T6[ebp], eax

; 79   :         return ::operator new(_Bytes);

  00163	6a 2c		 push	 44			; 0000002cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 783  :     explicit _Tree_temp_node_alloc(_Alnode& _Al_) : _Alloc_construct_ptr<_Alnode>(_Al_) {

  00165	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 965  :         _Ptr = nullptr; // if allocate throws, prevents double-free

  00169	c7 85 70 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T6[ebp+4], 0

; 79   :         return ::operator new(_Bytes);

  00173	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2835 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  00178	0f 10 85 44 ff
	ff ff		 movups	 xmm0, XMMWORD PTR $T2[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 242  :         : first(_STD forward<_Other1>(_Right.first)), second(_STD forward<_Other2>(_Right.second)) {}

  0017f	8b 4d 0c	 mov	 ecx, DWORD PTR _tmDiffTime$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 79   :         return ::operator new(_Bytes);

  00182	83 c4 04	 add	 esp, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4576 :             _My_data._Myres = _BUF_SIZE - 1;

  00185	bf 0f 00 00 00	 mov	 edi, 15			; 0000000fH

; 4577 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4578 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  0018a	c6 45 bc 00	 mov	 BYTE PTR $T9[ebp], 0

; 2322 :     size_type _Mysize = 0; // current length of string

  0018e	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], 0

; 2323 :     size_type _Myres  = 0; // current storage reserved for string

  00195	c7 40 24 00 00
	00 00		 mov	 DWORD PTR [eax+36], 0

; 2835 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  0019c	0f 11 40 10	 movups	 XMMWORD PTR [eax+16], xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1031 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  001a0	50		 push	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2835 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  001a1	f3 0f 7e 45 cc	 movq	 xmm0, QWORD PTR $T9[ebp+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1031 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  001a6	ff b5 58 ff ff
	ff		 push	 DWORD PTR __Loc$3[ebp+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2835 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  001ac	66 0f d6 40 20	 movq	 QWORD PTR [eax+32], xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1031 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  001b1	ff b5 54 ff ff
	ff		 push	 DWORD PTR __Loc$3[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 242  :         : first(_STD forward<_Other1>(_Right.first)), second(_STD forward<_Other2>(_Right.second)) {}

  001b7	89 48 28	 mov	 DWORD PTR [eax+40], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1031 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  001ba	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]

; 806  :         _Construct_in_place(this->_Ptr->_Left, _Myhead);

  001c0	89 30		 mov	 DWORD PTR [eax], esi

; 807  :         _Construct_in_place(this->_Ptr->_Parent, _Myhead);

  001c2	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 808  :         _Construct_in_place(this->_Ptr->_Right, _Myhead);

  001c5	89 70 08	 mov	 DWORD PTR [eax+8], esi

; 1031 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  001c8	8d 49 08	 lea	 ecx, DWORD PTR [ecx+8]

; 809  :         this->_Ptr->_Color = _Red;

  001cb	66 c7 40 0c 00
	00		 mov	 WORD PTR [eax+12], 0

; 1031 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  001d1	e8 00 00 00 00	 call	 ?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@2@QAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Insert_node
  001d6	8b 75 bc	 mov	 esi, DWORD PTR $T9[ebp]
$LN183@SetRQDiffT:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp

; 69   : 	m_mtdRQ.insert(PAIR_RQ_TIME_DIFF(stringRQ, tmDiffTime));

  001d9	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4584 :         if (_Mypair._Myval2._Large_string_engaged()) {

  001dd	83 ff 10	 cmp	 edi, 16			; 00000010H
  001e0	72 29		 jb	 SHORT $LN210@SetRQDiffT

; 4588 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  001e2	47		 inc	 edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  001e3	8b c6		 mov	 eax, esi

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  001e5	81 ff 00 10 00
	00		 cmp	 edi, 4096		; 00001000H
  001eb	72 14		 jb	 SHORT $LN220@SetRQDiffT

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  001ed	8b 76 fc	 mov	 esi, DWORD PTR [esi-4]
  001f0	83 c7 23	 add	 edi, 35			; 00000023H
  001f3	2b c6		 sub	 eax, esi

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  001f5	83 c0 fc	 add	 eax, -4			; fffffffcH
  001f8	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  001fb	0f 87 9f 02 00
	00		 ja	 $LN315@SetRQDiffT
$LN220@SetRQDiffT:

; 255  :         ::operator delete(_Ptr, _Bytes);

  00201	57		 push	 edi
  00202	56		 push	 esi
  00203	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00208	83 c4 08	 add	 esp, 8
$LN210@SetRQDiffT:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp

; 71   : 	if( nCurrTime > 0 )

  0020b	8b 45 14	 mov	 eax, DWORD PTR _nCurrTime$[ebp+4]
  0020e	85 c0		 test	 eax, eax
  00210	0f 8c 62 02 00
	00		 jl	 $LN280@SetRQDiffT
  00216	8b 7d 10	 mov	 edi, DWORD PTR _nCurrTime$[ebp]
  00219	7f 08		 jg	 SHORT $LN326@SetRQDiffT
  0021b	85 ff		 test	 edi, edi
  0021d	0f 84 55 02 00
	00		 je	 $LN280@SetRQDiffT
$LN326@SetRQDiffT:

; 72   : 	{
; 73   : 		tm currTime;
; 74   : 		memset(&currTime, 0, sizeof(tm));
; 75   : 		currTime.tm_isdst = -1;		//[A00000554]alzioyes:20110530  .
; 76   : 		currTime.tm_year =  (nCurrTime / 10000000000) - 1900;

  00223	53		 push	 ebx
  00224	6a 02		 push	 2
  00226	68 00 e4 0b 54	 push	 1410065408		; 540be400H
  0022b	0f 57 c0	 xorps	 xmm0, xmm0
  0022e	50		 push	 eax
  0022f	57		 push	 edi
  00230	66 0f 13 45 b4	 movlpd	 QWORD PTR _currTime$8[ebp], xmm0
  00235	66 0f 13 45 cc	 movlpd	 QWORD PTR _currTime$8[ebp+24], xmm0
  0023a	e8 00 00 00 00	 call	 __aulldvrm
  0023f	8b f3		 mov	 esi, ebx
  00241	5b		 pop	 ebx
  00242	90		 npad	 1

; 77   : 		currTime.tm_mon =	(nCurrTime % 10000000000) / 100000000 - 1;

  00243	6a 00		 push	 0
  00245	68 00 e1 f5 05	 push	 100000000		; 05f5e100H
  0024a	56		 push	 esi
  0024b	05 94 f8 ff ff	 add	 eax, -1900		; fffff894H
  00250	89 95 70 ff ff
	ff		 mov	 DWORD PTR tv827[ebp+4], edx
  00256	51		 push	 ecx
  00257	89 45 c8	 mov	 DWORD PTR _currTime$8[ebp+20], eax
  0025a	e8 00 00 00 00	 call	 __alldiv
  0025f	48		 dec	 eax

; 78   : 		currTime.tm_mday =	(nCurrTime % 100000000) / 1000000;
; 79   : 		currTime.tm_hour =	(nCurrTime % 1000000) / 10000;

  00260	b9 db 34 b6 d7	 mov	 ecx, -675924773		; d7b634dbH
  00265	89 45 c4	 mov	 DWORD PTR _currTime$8[ebp+16], eax
  00268	8b c7		 mov	 eax, edi
  0026a	f7 e1		 mul	 ecx
  0026c	6a 00		 push	 0
  0026e	8b f2		 mov	 esi, edx
  00270	89 85 6c ff ff
	ff		 mov	 DWORD PTR tv1689[ebp], eax
  00276	8b c7		 mov	 eax, edi
  00278	ba 82 de 1b 43	 mov	 edx, 1125899906		; 431bde82H
  0027d	f7 e2		 mul	 edx
  0027f	68 40 42 0f 00	 push	 1000000			; 000f4240H
  00284	8b f8		 mov	 edi, eax
  00286	89 95 64 ff ff
	ff		 mov	 DWORD PTR tv1349[ebp], edx
  0028c	8b 45 14	 mov	 eax, DWORD PTR _nCurrTime$[ebp+4]
  0028f	f7 e1		 mul	 ecx
  00291	8b c8		 mov	 ecx, eax
  00293	89 95 5c ff ff
	ff		 mov	 DWORD PTR tv1266[ebp], edx
  00299	8b 45 14	 mov	 eax, DWORD PTR _nCurrTime$[ebp+4]
  0029c	ba 82 de 1b 43	 mov	 edx, 1125899906		; 431bde82H
  002a1	f7 e2		 mul	 edx
  002a3	03 ce		 add	 ecx, esi
  002a5	89 95 70 ff ff
	ff		 mov	 DWORD PTR tv1270[ebp], edx
  002ab	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR tv1266[ebp]
  002b1	83 d2 00	 adc	 edx, 0
  002b4	89 85 60 ff ff
	ff		 mov	 DWORD PTR tv1271[ebp], eax
  002ba	8b f0		 mov	 esi, eax
  002bc	03 f9		 add	 edi, ecx
  002be	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR tv1349[ebp]
  002c4	83 d1 00	 adc	 ecx, 0
  002c7	89 bd 58 ff ff
	ff		 mov	 DWORD PTR tv1680[ebp], edi
  002cd	33 c0		 xor	 eax, eax
  002cf	03 d1		 add	 edx, ecx
  002d1	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR tv1270[ebp]
  002d7	13 c0		 adc	 eax, eax
  002d9	03 f2		 add	 esi, edx
  002db	13 c8		 adc	 ecx, eax
  002dd	0f ac ce 12	 shrd	 esi, ecx, 18
  002e1	c1 e9 12	 shr	 ecx, 18			; 00000012H
  002e4	51		 push	 ecx
  002e5	56		 push	 esi
  002e6	e8 00 00 00 00	 call	 __allmul
  002eb	8b 7d 10	 mov	 edi, DWORD PTR _nCurrTime$[ebp]
  002ee	8b cf		 mov	 ecx, edi
  002f0	2b c8		 sub	 ecx, eax
  002f2	8b 45 14	 mov	 eax, DWORD PTR _nCurrTime$[ebp+4]
  002f5	6a 00		 push	 0
  002f7	68 10 27 00 00	 push	 10000			; 00002710H
  002fc	1b c2		 sbb	 eax, edx
  002fe	50		 push	 eax
  002ff	51		 push	 ecx
  00300	e8 00 00 00 00	 call	 __alldiv
  00305	89 45 bc	 mov	 DWORD PTR _currTime$8[ebp+8], eax

; 81   : 		currTime.tm_mday =	(nCurrTime % 100);

  00308	b9 15 ae 47 e1	 mov	 ecx, -515396075		; e147ae15H
  0030d	8b c7		 mov	 eax, edi
  0030f	f7 e1		 mul	 ecx
  00311	89 85 6c ff ff
	ff		 mov	 DWORD PTR tv1538[ebp], eax
  00317	8b f2		 mov	 esi, edx
  00319	8b c7		 mov	 eax, edi
  0031b	ba 7a 14 ae 47	 mov	 edx, 1202590842		; 47ae147aH
  00320	f7 e2		 mul	 edx
  00322	8b f8		 mov	 edi, eax
  00324	89 95 60 ff ff
	ff		 mov	 DWORD PTR tv1374[ebp], edx
  0032a	8b 45 14	 mov	 eax, DWORD PTR _nCurrTime$[ebp+4]
  0032d	f7 e1		 mul	 ecx
  0032f	8b c8		 mov	 ecx, eax
  00331	89 95 70 ff ff
	ff		 mov	 DWORD PTR tv1297[ebp], edx
  00337	8b 45 14	 mov	 eax, DWORD PTR _nCurrTime$[ebp+4]
  0033a	ba 7a 14 ae 47	 mov	 edx, 1202590842		; 47ae147aH
  0033f	f7 e2		 mul	 edx
  00341	03 ce		 add	 ecx, esi
  00343	8b 75 14	 mov	 esi, DWORD PTR _nCurrTime$[ebp+4]
  00346	89 95 5c ff ff
	ff		 mov	 DWORD PTR tv1384[ebp], edx
  0034c	8b 95 70 ff ff
	ff		 mov	 edx, DWORD PTR tv1297[ebp]
  00352	83 d2 00	 adc	 edx, 0
  00355	89 85 64 ff ff
	ff		 mov	 DWORD PTR tv1383[ebp], eax
  0035b	03 f9		 add	 edi, ecx
  0035d	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR tv1374[ebp]
  00363	89 bd 6c ff ff
	ff		 mov	 DWORD PTR tv1529[ebp], edi
  00369	8b 7d 10	 mov	 edi, DWORD PTR _nCurrTime$[ebp]
  0036c	83 d1 00	 adc	 ecx, 0
  0036f	33 c0		 xor	 eax, eax
  00371	03 d1		 add	 edx, ecx
  00373	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR tv1383[ebp]
  00379	13 c0		 adc	 eax, eax
  0037b	03 ca		 add	 ecx, edx
  0037d	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR tv1384[ebp]
  00383	13 d0		 adc	 edx, eax
  00385	8b c7		 mov	 eax, edi
  00387	2b c1		 sub	 eax, ecx
  00389	1b f2		 sbb	 esi, edx
  0038b	0f ac f0 01	 shrd	 eax, esi, 1
  0038f	d1 ee		 shr	 esi, 1
  00391	03 c1		 add	 eax, ecx
  00393	13 f2		 adc	 esi, edx
  00395	0f ac f0 06	 shrd	 eax, esi, 6
  00399	6b c0 64	 imul	 eax, eax, 100
  0039c	2b f8		 sub	 edi, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2273 :         if (_Large_string_engaged()) {

  0039e	83 7d ec 10	 cmp	 DWORD PTR _stringRQ$[ebp+20], 16 ; 00000010H
  003a2	8d 45 d8	 lea	 eax, DWORD PTR _stringRQ$[ebp]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp

; 81   : 		currTime.tm_mday =	(nCurrTime % 100);

  003a5	89 7d c0	 mov	 DWORD PTR _currTime$8[ebp+12], edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2273 :         if (_Large_string_engaged()) {

  003a8	0f 43 45 d8	 cmovae	 eax, DWORD PTR _stringRQ$[ebp]

; 2899 :         if (_Stay_small) { // stay small, don't allocate

  003ac	8b 7d e8	 mov	 edi, DWORD PTR _stringRQ$[ebp+16]

; 2273 :         if (_Large_string_engaged()) {

  003af	89 85 70 ff ff
	ff		 mov	 DWORD PTR __Result$2$[ebp], eax

; 2899 :         if (_Stay_small) { // stay small, don't allocate

  003b5	83 ff 10	 cmp	 edi, 16			; 00000010H
  003b8	73 13		 jae	 SHORT $LN240@SetRQDiffT

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  003ba	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]

; 2902 :             _My_data._Myres  = _BUF_SIZE - 1;

  003bd	c7 45 8c 0f 00
	00 00		 mov	 DWORD PTR $T7[ebp+20], 15 ; 0000000fH

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  003c4	0f 11 85 78 ff
	ff ff		 movups	 XMMWORD PTR $T7[ebp], xmm0

; 2903 :             return;

  003cb	eb 3e		 jmp	 SHORT $LN331@SetRQDiffT
$LN240@SetRQDiffT:

; 2904 :         }
; 2905 : 
; 2906 :         auto& _Al                     = _Getal();
; 2907 :         const size_type _New_capacity = (_STD min)(_Right_size | _ALLOC_MASK, max_size());

  003cd	8b f7		 mov	 esi, edi

; 2908 :         const pointer _New_array      = _Al.allocate(_New_capacity + 1); // throws

  003cf	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR $T7[ebp]
  003d5	83 ce 0f	 or	 esi, 15			; 0000000fH
  003d8	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  003dd	81 fe ff ff ff
	7f		 cmp	 esi, 2147483647		; 7fffffffH
  003e3	0f 47 f0	 cmova	 esi, eax
  003e6	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  003e9	50		 push	 eax
  003ea	e8 00 00 00 00	 call	 ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate

; 2909 :         _Construct_in_place(_My_data._Bx._Ptr, _New_array);
; 2910 : 
; 2911 : #ifdef __cpp_lib_constexpr_string
; 2912 :         if (_STD is_constant_evaluated()) { // Begin the lifetimes of the objects before copying to avoid UB
; 2913 :             _Traits::assign(_Unfancy(_New_array), _New_capacity + 1, _Elem());
; 2914 :         }
; 2915 : #endif // __cpp_lib_constexpr_string
; 2916 :         _Traits::copy(_Unfancy(_New_array), _Right_ptr, _Right_size + 1);

  003ef	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
  003f2	89 85 78 ff ff
	ff		 mov	 DWORD PTR $T7[ebp], eax

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  003f8	51		 push	 ecx
  003f9	ff b5 70 ff ff
	ff		 push	 DWORD PTR __Result$2$[ebp]
  003ff	50		 push	 eax
  00400	e8 00 00 00 00	 call	 _memcpy
  00405	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2918 :         _My_data._Myres  = _New_capacity;

  00408	89 75 8c	 mov	 DWORD PTR $T7[ebp+20], esi
$LN331@SetRQDiffT:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 186  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  0040b	0f 10 45 b4	 movups	 xmm0, XMMWORD PTR _currTime$8[ebp]
  0040f	89 7d 88	 mov	 DWORD PTR $T7[ebp+16], edi
  00412	c7 45 b0 ff ff
	ff ff		 mov	 DWORD PTR $T7[ebp+56], -1
  00419	0f 11 45 90	 movups	 XMMWORD PTR $T7[ebp+24], xmm0
  0041d	0f 10 45 c4	 movups	 xmm0, XMMWORD PTR _currTime$8[ebp+16]
  00421	0f 11 45 a0	 movups	 XMMWORD PTR $T7[ebp+40], xmm0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp

; 83   : 		m_mRQCurrTime.insert(PAIR_RQ_CURR_TIME(stringRQ, currTime));

  00425	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1037 :         const auto _Result = _Emplace(_STD forward<_Valtys>(_Vals)...);

  0042b	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR $T7[ebp]
  00431	50		 push	 eax
  00432	8d 85 6c ff ff
	ff		 lea	 eax, DWORD PTR __Result$5[ebp]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp

; 83   : 		m_mRQCurrTime.insert(PAIR_RQ_CURR_TIME(stringRQ, currTime));

  00438	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1037 :         const auto _Result = _Emplace(_STD forward<_Valtys>(_Vals)...);

  0043c	50		 push	 eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp

; 83   : 		m_mRQCurrTime.insert(PAIR_RQ_CURR_TIME(stringRQ, currTime));

  0043d	8d 49 10	 lea	 ecx, DWORD PTR [ecx+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1037 :         const auto _Result = _Emplace(_STD forward<_Valtys>(_Vals)...);

  00440	e8 00 00 00 00	 call	 ??$_Emplace@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@PAX@std@@_N@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,tm,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,tm> >,0> >::_Emplace<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,tm> >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2286 :         return _BUF_SIZE <= _Myres;

  00445	8b 55 8c	 mov	 edx, DWORD PTR $T7[ebp+20]
  00448	83 fa 10	 cmp	 edx, 16			; 00000010H

; 4584 :         if (_Mypair._Myval2._Large_string_engaged()) {

  0044b	72 2b		 jb	 SHORT $LN280@SetRQDiffT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0044d	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR $T7[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4588 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00453	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00454	8b c1		 mov	 eax, ecx

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00456	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  0045c	72 10		 jb	 SHORT $LN290@SetRQDiffT

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0045e	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00461	83 c2 23	 add	 edx, 35			; 00000023H
  00464	2b c1		 sub	 eax, ecx

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00466	83 c0 fc	 add	 eax, -4			; fffffffcH
  00469	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0046c	77 32		 ja	 SHORT $LN315@SetRQDiffT
$LN290@SetRQDiffT:

; 255  :         ::operator delete(_Ptr, _Bytes);

  0046e	52		 push	 edx
  0046f	51		 push	 ecx
  00470	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00475	83 c4 08	 add	 esp, 8
$LN280@SetRQDiffT:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2286 :         return _BUF_SIZE <= _Myres;

  00478	8b 45 ec	 mov	 eax, DWORD PTR _stringRQ$[ebp+20]
  0047b	83 f8 10	 cmp	 eax, 16			; 00000010H

; 4584 :         if (_Mypair._Myval2._Large_string_engaged()) {

  0047e	72 30		 jb	 SHORT $LN308@SetRQDiffT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00480	8b 4d d8	 mov	 ecx, DWORD PTR _stringRQ$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4588 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00483	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00486	8b c1		 mov	 eax, ecx

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00488	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  0048e	72 16		 jb	 SHORT $LN318@SetRQDiffT

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00490	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00493	83 c2 23	 add	 edx, 35			; 00000023H
  00496	2b c1		 sub	 eax, ecx

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00498	83 c0 fc	 add	 eax, -4			; fffffffcH
  0049b	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0049e	76 06		 jbe	 SHORT $LN318@SetRQDiffT
$LN315@SetRQDiffT:
  004a0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN318@SetRQDiffT:

; 255  :         ::operator delete(_Ptr, _Bytes);

  004a6	52		 push	 edx
  004a7	51		 push	 ecx
  004a8	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  004ad	83 c4 08	 add	 esp, 8
$LN308@SetRQDiffT:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp

; 85   : }

  004b0	8d 4d 08	 lea	 ecx, DWORD PTR _strRQ$[ebp]
  004b3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  004b9	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  004bc	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  004c3	59		 pop	 ecx
  004c4	5f		 pop	 edi
  004c5	5e		 pop	 esi
  004c6	5b		 pop	 ebx
  004c7	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004ca	33 cd		 xor	 ecx, ebp
  004cc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004d1	8b e5		 mov	 esp, ebp
  004d3	5d		 pop	 ebp
  004d4	c2 10 00	 ret	 16			; 00000010H
$LN333@SetRQDiffT:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1616 :             _Throw_tree_length_error();

  004d7	e8 00 00 00 00	 call	 ?_Throw_tree_length_error@std@@YAXXZ ; std::_Throw_tree_length_error
$LN329@SetRQDiffT:
  004dc	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SetRQDiffTime@CXScaleTimeDiffManager@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H_J@Z$0:
  00000	8d 4d 08	 lea	 ecx, DWORD PTR _strRQ$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?SetRQDiffTime@CXScaleTimeDiffManager@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H_J@Z$1:
  00009	8d 4d d8	 lea	 ecx, DWORD PTR _stringRQ$[ebp]
  0000c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SetRQDiffTime@CXScaleTimeDiffManager@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H_J@Z$2:
  00011	8d 4d bc	 lea	 ecx, DWORD PTR $T9[ebp]
  00014	e9 00 00 00 00	 jmp	 ??1?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@QAE@XZ
__unwindfunclet$?SetRQDiffTime@CXScaleTimeDiffManager@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H_J@Z$11:
  00019	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  0001f	e9 00 00 00 00	 jmp	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> > >
__unwindfunclet$?SetRQDiffTime@CXScaleTimeDiffManager@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H_J@Z$3:
  00024	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR $T7[ebp]
  0002a	e9 00 00 00 00	 jmp	 ??1?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@QAE@XZ
  0002f	cc		 int	 3
  00030	cc		 int	 3
  00031	cc		 int	 3
  00032	cc		 int	 3
  00033	cc		 int	 3
__ehhandler$?SetRQDiffTime@CXScaleTimeDiffManager@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H_J@Z:
  00034	90		 npad	 1
  00035	90		 npad	 1
  00036	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0003a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0003d	8b 8a 40 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-192]
  00043	33 c8		 xor	 ecx, eax
  00045	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004a	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0004d	33 c8		 xor	 ecx, eax
  0004f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00054	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?SetRQDiffTime@CXScaleTimeDiffManager@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H_J@Z
  00059	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?SetRQDiffTime@CXScaleTimeDiffManager@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H_J@Z ENDP ; CXScaleTimeDiffManager::SetRQDiffTime
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp
;	COMDAT ?InitRQMarketTime@CXScaleTimeDiffManager@@QAEXXZ
_TEXT	SEGMENT
?InitRQMarketTime@CXScaleTimeDiffManager@@QAEXXZ PROC	; CXScaleTimeDiffManager::InitRQMarketTime, COMDAT
; _this$ = ecx

; 57   : {

  00000	56		 push	 esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1342 :         auto _Head = _Scary->_Myhead;

  00001	8b 71 18	 mov	 esi, DWORD PTR [ecx+24]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp

; 57   : {

  00004	57		 push	 edi

; 58   : 	m_mRQMarketTime.clear();

  00005	8d 79 18	 lea	 edi, DWORD PTR [ecx+24]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1343 :         _Scary->_Erase_tree(_Getal(), _Head->_Parent);

  00008	8b cf		 mov	 ecx, edi
  0000a	ff 76 04	 push	 DWORD PTR [esi+4]
  0000d	57		 push	 edi
  0000e	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,__int64> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,__int64>,void *> > >

; 1344 :         _Head->_Parent  = _Head;

  00013	89 76 04	 mov	 DWORD PTR [esi+4], esi

; 1345 :         _Head->_Left    = _Head;

  00016	89 36		 mov	 DWORD PTR [esi], esi

; 1346 :         _Head->_Right   = _Head;

  00018	89 76 08	 mov	 DWORD PTR [esi+8], esi

; 1347 :         _Scary->_Mysize = 0;

  0001b	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0
  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp

; 59   : }

  00024	c3		 ret	 0
?InitRQMarketTime@CXScaleTimeDiffManager@@QAEXXZ ENDP	; CXScaleTimeDiffManager::InitRQMarketTime
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp
;	COMDAT ?InitRQDiffTime@CXScaleTimeDiffManager@@QAEXXZ
_TEXT	SEGMENT
?InitRQDiffTime@CXScaleTimeDiffManager@@QAEXXZ PROC	; CXScaleTimeDiffManager::InitRQDiffTime, COMDAT
; _this$ = ecx

; 51   : {

  00000	56		 push	 esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1342 :         auto _Head = _Scary->_Myhead;

  00001	8b 71 08	 mov	 esi, DWORD PTR [ecx+8]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp

; 51   : {

  00004	57		 push	 edi

; 52   : 	m_mtdRQ.clear();

  00005	8d 79 08	 lea	 edi, DWORD PTR [ecx+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1343 :         _Scary->_Erase_tree(_Getal(), _Head->_Parent);

  00008	8b cf		 mov	 ecx, edi
  0000a	ff 76 04	 push	 DWORD PTR [esi+4]
  0000d	57		 push	 edi
  0000e	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> > >

; 1344 :         _Head->_Parent  = _Head;

  00013	89 76 04	 mov	 DWORD PTR [esi+4], esi

; 1345 :         _Head->_Left    = _Head;

  00016	89 36		 mov	 DWORD PTR [esi], esi

; 1346 :         _Head->_Right   = _Head;

  00018	89 76 08	 mov	 DWORD PTR [esi+8], esi

; 1347 :         _Scary->_Mysize = 0;

  0001b	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0
  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp

; 53   : }

  00024	c3		 ret	 0
?InitRQDiffTime@CXScaleTimeDiffManager@@QAEXXZ ENDP	; CXScaleTimeDiffManager::InitRQDiffTime
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@PAX@std@@@2@QAU32@@Z
_TEXT	SEGMENT
__Head$1$ = -8						; size = 4
_this$1$ = -4						; size = 4
__Loc$ = 8						; size = 8
__Newnode$ = 16						; size = 4
?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@PAX@std@@@2@QAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,__int64> > >::_Insert_node, COMDAT
; _this$ = ecx

; 644  :     _Nodeptr _Insert_node(const _Tree_id<_Nodeptr> _Loc, const _Nodeptr _Newnode) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 645  :         ++_Mysize;
; 646  :         const auto _Head  = _Myhead;
; 647  :         _Newnode->_Parent = _Loc._Parent;

  00006	8b 55 08	 mov	 edx, DWORD PTR __Loc$[ebp]
  00009	8b c1		 mov	 eax, ecx
  0000b	89 45 fc	 mov	 DWORD PTR _this$1$[ebp], eax
  0000e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00010	ff 40 04	 inc	 DWORD PTR [eax+4]
  00013	8b 45 10	 mov	 eax, DWORD PTR __Newnode$[ebp]
  00016	89 4d f8	 mov	 DWORD PTR __Head$1$[ebp], ecx
  00019	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 648  :         if (_Loc._Parent == _Head) { // first node in tree, just set head values

  0001c	3b d1		 cmp	 edx, ecx
  0001e	75 12		 jne	 SHORT $LN5@Insert_nod

; 649  :             _Head->_Left     = _Newnode;

  00020	89 01		 mov	 DWORD PTR [ecx], eax

; 650  :             _Head->_Parent   = _Newnode;

  00022	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 651  :             _Head->_Right    = _Newnode;

  00025	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 652  :             _Newnode->_Color = _Black; // the root is black

  00028	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 711  :     }

  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c2 0c 00	 ret	 12			; 0000000cH
$LN5@Insert_nod:

; 653  :             return _Newnode;
; 654  :         }
; 655  : 
; 656  :         _STL_INTERNAL_CHECK(_Loc._Child != _Tree_child::_Unused);
; 657  :         if (_Loc._Child == _Tree_child::_Right) { // add to right of _Loc._Parent

  00032	83 7d 0c 00	 cmp	 DWORD PTR __Loc$[ebp+4], 0
  00036	75 0d		 jne	 SHORT $LN6@Insert_nod

; 658  :             _STL_INTERNAL_CHECK(_Loc._Parent->_Right->_Isnil);
; 659  :             _Loc._Parent->_Right = _Newnode;

  00038	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 660  :             if (_Loc._Parent == _Head->_Right) { // remember rightmost node

  0003b	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  0003e	75 0d		 jne	 SHORT $LN9@Insert_nod

; 661  :                 _Head->_Right = _Newnode;

  00040	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 662  :             }
; 663  :         } else { // add to left of _Loc._Parent

  00043	eb 08		 jmp	 SHORT $LN9@Insert_nod
$LN6@Insert_nod:

; 664  :             _STL_INTERNAL_CHECK(_Loc._Parent->_Left->_Isnil);
; 665  :             _Loc._Parent->_Left = _Newnode;

  00045	89 02		 mov	 DWORD PTR [edx], eax

; 666  :             if (_Loc._Parent == _Head->_Left) { // remember leftmost node

  00047	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00049	75 02		 jne	 SHORT $LN9@Insert_nod

; 667  :                 _Head->_Left = _Newnode;

  0004b	89 01		 mov	 DWORD PTR [ecx], eax
$LN9@Insert_nod:

; 668  :             }
; 669  :         }
; 670  : 
; 671  :         for (_Nodeptr _Pnode = _Newnode; _Pnode->_Parent->_Color == _Red;) {

  0004d	8b d0		 mov	 edx, eax
  0004f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00052	80 78 0c 00	 cmp	 BYTE PTR [eax+12], 0
  00056	0f 85 99 01 00
	00		 jne	 $LN3@Insert_nod
  0005c	53		 push	 ebx
  0005d	56		 push	 esi
  0005e	57		 push	 edi
  0005f	90		 npad	 1
$LL2@Insert_nod:

; 672  :             if (_Pnode->_Parent == _Pnode->_Parent->_Parent->_Left) { // fixup red-red in left subtree

  00060	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00063	8d 7a 04	 lea	 edi, DWORD PTR [edx+4]
  00066	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00069	8d 59 04	 lea	 ebx, DWORD PTR [ecx+4]
  0006c	8b 06		 mov	 eax, DWORD PTR [esi]
  0006e	3b c8		 cmp	 ecx, eax
  00070	0f 85 ba 00 00
	00		 jne	 $LN10@Insert_nod

; 673  :                 const auto _Parent_sibling = _Pnode->_Parent->_Parent->_Right;

  00076	8b 46 08	 mov	 eax, DWORD PTR [esi+8]

; 674  :                 if (_Parent_sibling->_Color == _Red) { // parent's sibling has two red children, blacken both

  00079	80 78 0c 00	 cmp	 BYTE PTR [eax+12], 0
  0007d	0f 84 b3 00 00
	00		 je	 $LN53@Insert_nod

; 675  :                     _Pnode->_Parent->_Color          = _Black;
; 676  :                     _Parent_sibling->_Color          = _Black;
; 677  :                     _Pnode->_Parent->_Parent->_Color = _Red;
; 678  :                     _Pnode                           = _Pnode->_Parent->_Parent;
; 679  :                 } else { // parent's sibling has red and black children
; 680  :                     if (_Pnode == _Pnode->_Parent->_Right) { // rotate right child to left

  00083	8b 71 08	 mov	 esi, DWORD PTR [ecx+8]
  00086	3b d6		 cmp	 edx, esi
  00088	75 47		 jne	 SHORT $LN51@Insert_nod

; 460  :         _Wherenode->_Right = _Pnode->_Left;

  0008a	8b 06		 mov	 eax, DWORD PTR [esi]

; 681  :                         _Pnode = _Pnode->_Parent;

  0008c	8b d1		 mov	 edx, ecx

; 460  :         _Wherenode->_Right = _Pnode->_Left;

  0008e	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 461  : 
; 462  :         if (!_Pnode->_Left->_Isnil) {

  00091	8b 06		 mov	 eax, DWORD PTR [esi]
  00093	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00097	75 03		 jne	 SHORT $LN20@Insert_nod

; 463  :             _Pnode->_Left->_Parent = _Wherenode;

  00099	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN20@Insert_nod:

; 464  :         }
; 465  : 
; 466  :         _Pnode->_Parent = _Wherenode->_Parent;

  0009c	8b 03		 mov	 eax, DWORD PTR [ebx]
  0009e	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 467  : 
; 468  :         if (_Wherenode == _Myhead->_Parent) {

  000a1	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]
  000a4	8b 00		 mov	 eax, DWORD PTR [eax]
  000a6	3b 50 04	 cmp	 edx, DWORD PTR [eax+4]
  000a9	75 0b		 jne	 SHORT $LN21@Insert_nod

; 469  :             _Myhead->_Parent = _Pnode;

  000ab	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 477  :         _Wherenode->_Parent = _Pnode;

  000ae	8b fb		 mov	 edi, ebx
  000b0	89 16		 mov	 DWORD PTR [esi], edx
  000b2	89 33		 mov	 DWORD PTR [ebx], esi
  000b4	eb 1d		 jmp	 SHORT $LN49@Insert_nod
$LN21@Insert_nod:

; 470  :         } else if (_Wherenode == _Wherenode->_Parent->_Left) {

  000b6	8b 03		 mov	 eax, DWORD PTR [ebx]
  000b8	3b 10		 cmp	 edx, DWORD PTR [eax]
  000ba	75 0a		 jne	 SHORT $LN23@Insert_nod

; 471  :             _Wherenode->_Parent->_Left = _Pnode;

  000bc	89 30		 mov	 DWORD PTR [eax], esi

; 477  :         _Wherenode->_Parent = _Pnode;

  000be	8b fb		 mov	 edi, ebx
  000c0	89 16		 mov	 DWORD PTR [esi], edx
  000c2	89 33		 mov	 DWORD PTR [ebx], esi
  000c4	eb 0d		 jmp	 SHORT $LN49@Insert_nod
$LN23@Insert_nod:

; 473  :             _Wherenode->_Parent->_Right = _Pnode;

  000c6	89 70 08	 mov	 DWORD PTR [eax+8], esi

; 477  :         _Wherenode->_Parent = _Pnode;

  000c9	8b fb		 mov	 edi, ebx
  000cb	89 16		 mov	 DWORD PTR [esi], edx
  000cd	89 33		 mov	 DWORD PTR [ebx], esi
  000cf	eb 02		 jmp	 SHORT $LN49@Insert_nod
$LN51@Insert_nod:
  000d1	8b f1		 mov	 esi, ecx
$LN49@Insert_nod:

; 682  :                         _Lrotate(_Pnode);
; 683  :                     }
; 684  : 
; 685  :                     _Pnode->_Parent->_Color          = _Black; // propagate red up

  000d3	c6 46 0c 01	 mov	 BYTE PTR [esi+12], 1

; 686  :                     _Pnode->_Parent->_Parent->_Color = _Red;

  000d7	8b 07		 mov	 eax, DWORD PTR [edi]
  000d9	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000dc	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 687  :                     _Rrotate(_Pnode->_Parent->_Parent);

  000e0	8b 07		 mov	 eax, DWORD PTR [edi]
  000e2	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 481  :         _Nodeptr _Pnode   = _Wherenode->_Left;

  000e5	8b 31		 mov	 esi, DWORD PTR [ecx]

; 482  :         _Wherenode->_Left = _Pnode->_Right;

  000e7	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000ea	89 01		 mov	 DWORD PTR [ecx], eax

; 483  : 
; 484  :         if (!_Pnode->_Right->_Isnil) {

  000ec	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000ef	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  000f3	75 03		 jne	 SHORT $LN27@Insert_nod

; 485  :             _Pnode->_Right->_Parent = _Wherenode;

  000f5	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN27@Insert_nod:

; 486  :         }
; 487  : 
; 488  :         _Pnode->_Parent = _Wherenode->_Parent;

  000f8	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  000fb	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 489  : 
; 490  :         if (_Wherenode == _Myhead->_Parent) {

  000fe	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]
  00101	8b 00		 mov	 eax, DWORD PTR [eax]
  00103	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00106	75 0b		 jne	 SHORT $LN28@Insert_nod

; 491  :             _Myhead->_Parent = _Pnode;

  00108	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 496  :         }
; 497  : 
; 498  :         _Pnode->_Right      = _Wherenode;

  0010b	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 688  :                 }
; 689  :             } else { // fixup red-red in right subtree

  0010e	e9 cc 00 00 00	 jmp	 $LN52@Insert_nod
$LN28@Insert_nod:

; 492  :         } else if (_Wherenode == _Wherenode->_Parent->_Right) {

  00113	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00116	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00119	75 0b		 jne	 SHORT $LN30@Insert_nod

; 493  :             _Wherenode->_Parent->_Right = _Pnode;

  0011b	89 70 08	 mov	 DWORD PTR [eax+8], esi

; 496  :         }
; 497  : 
; 498  :         _Pnode->_Right      = _Wherenode;

  0011e	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 688  :                 }
; 689  :             } else { // fixup red-red in right subtree

  00121	e9 b9 00 00 00	 jmp	 $LN52@Insert_nod
$LN30@Insert_nod:

; 495  :             _Wherenode->_Parent->_Left = _Pnode;

  00126	89 30		 mov	 DWORD PTR [eax], esi

; 496  :         }
; 497  : 
; 498  :         _Pnode->_Right      = _Wherenode;

  00128	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 688  :                 }
; 689  :             } else { // fixup red-red in right subtree

  0012b	e9 af 00 00 00	 jmp	 $LN52@Insert_nod
$LN10@Insert_nod:

; 690  :                 const auto _Parent_sibling = _Pnode->_Parent->_Parent->_Left;
; 691  :                 if (_Parent_sibling->_Color == _Red) { // parent's sibling has two red children, blacken both

  00130	80 78 0c 00	 cmp	 BYTE PTR [eax+12], 0
  00134	75 1b		 jne	 SHORT $LN15@Insert_nod
$LN53@Insert_nod:

; 668  :             }
; 669  :         }
; 670  : 
; 671  :         for (_Nodeptr _Pnode = _Newnode; _Pnode->_Parent->_Color == _Red;) {

  00136	c6 41 0c 01	 mov	 BYTE PTR [ecx+12], 1
  0013a	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1
  0013e	8b 07		 mov	 eax, DWORD PTR [edi]
  00140	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00143	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0
  00147	8b 07		 mov	 eax, DWORD PTR [edi]
  00149	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0014c	e9 91 00 00 00	 jmp	 $LN46@Insert_nod
$LN15@Insert_nod:

; 692  :                     _Pnode->_Parent->_Color          = _Black;
; 693  :                     _Parent_sibling->_Color          = _Black;
; 694  :                     _Pnode->_Parent->_Parent->_Color = _Red;
; 695  :                     _Pnode                           = _Pnode->_Parent->_Parent;
; 696  :                 } else { // parent's sibling has red and black children
; 697  :                     if (_Pnode == _Pnode->_Parent->_Left) { // rotate left child to right

  00151	8b 01		 mov	 eax, DWORD PTR [ecx]
  00153	3b d0		 cmp	 edx, eax
  00155	75 3e		 jne	 SHORT $LN39@Insert_nod

; 698  :                         _Pnode = _Pnode->_Parent;

  00157	8b d1		 mov	 edx, ecx

; 481  :         _Nodeptr _Pnode   = _Wherenode->_Left;

  00159	8b c8		 mov	 ecx, eax

; 482  :         _Wherenode->_Left = _Pnode->_Right;

  0015b	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0015e	89 02		 mov	 DWORD PTR [edx], eax

; 483  : 
; 484  :         if (!_Pnode->_Right->_Isnil) {

  00160	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00163	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00167	75 03		 jne	 SHORT $LN34@Insert_nod

; 485  :             _Pnode->_Right->_Parent = _Wherenode;

  00169	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN34@Insert_nod:

; 486  :         }
; 487  : 
; 488  :         _Pnode->_Parent = _Wherenode->_Parent;

  0016c	8b 03		 mov	 eax, DWORD PTR [ebx]
  0016e	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 489  : 
; 490  :         if (_Wherenode == _Myhead->_Parent) {

  00171	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]
  00174	8b 00		 mov	 eax, DWORD PTR [eax]
  00176	3b 50 04	 cmp	 edx, DWORD PTR [eax+4]
  00179	75 05		 jne	 SHORT $LN35@Insert_nod

; 491  :             _Myhead->_Parent = _Pnode;

  0017b	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0017e	eb 0e		 jmp	 SHORT $LN38@Insert_nod
$LN35@Insert_nod:

; 492  :         } else if (_Wherenode == _Wherenode->_Parent->_Right) {

  00180	8b 03		 mov	 eax, DWORD PTR [ebx]
  00182	3b 50 08	 cmp	 edx, DWORD PTR [eax+8]
  00185	75 05		 jne	 SHORT $LN37@Insert_nod

; 493  :             _Wherenode->_Parent->_Right = _Pnode;

  00187	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 494  :         } else {

  0018a	eb 02		 jmp	 SHORT $LN38@Insert_nod
$LN37@Insert_nod:

; 495  :             _Wherenode->_Parent->_Left = _Pnode;

  0018c	89 08		 mov	 DWORD PTR [eax], ecx
$LN38@Insert_nod:

; 496  :         }
; 497  : 
; 498  :         _Pnode->_Right      = _Wherenode;

  0018e	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 499  :         _Wherenode->_Parent = _Pnode;

  00191	8b fb		 mov	 edi, ebx
  00193	89 0b		 mov	 DWORD PTR [ebx], ecx
$LN39@Insert_nod:

; 699  :                         _Rrotate(_Pnode);
; 700  :                     }
; 701  : 
; 702  :                     _Pnode->_Parent->_Color          = _Black; // propagate red up

  00195	c6 41 0c 01	 mov	 BYTE PTR [ecx+12], 1

; 703  :                     _Pnode->_Parent->_Parent->_Color = _Red;

  00199	8b 07		 mov	 eax, DWORD PTR [edi]
  0019b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0019e	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 704  :                     _Lrotate(_Pnode->_Parent->_Parent);

  001a2	8b 07		 mov	 eax, DWORD PTR [edi]
  001a4	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 459  :         _Nodeptr _Pnode    = _Wherenode->_Right;

  001a7	8b 71 08	 mov	 esi, DWORD PTR [ecx+8]

; 460  :         _Wherenode->_Right = _Pnode->_Left;

  001aa	8b 06		 mov	 eax, DWORD PTR [esi]
  001ac	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 461  : 
; 462  :         if (!_Pnode->_Left->_Isnil) {

  001af	8b 06		 mov	 eax, DWORD PTR [esi]
  001b1	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  001b5	75 03		 jne	 SHORT $LN41@Insert_nod

; 463  :             _Pnode->_Left->_Parent = _Wherenode;

  001b7	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN41@Insert_nod:

; 464  :         }
; 465  : 
; 466  :         _Pnode->_Parent = _Wherenode->_Parent;

  001ba	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  001bd	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 467  : 
; 468  :         if (_Wherenode == _Myhead->_Parent) {

  001c0	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]
  001c3	8b 00		 mov	 eax, DWORD PTR [eax]
  001c5	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  001c8	75 05		 jne	 SHORT $LN42@Insert_nod

; 469  :             _Myhead->_Parent = _Pnode;

  001ca	89 70 04	 mov	 DWORD PTR [eax+4], esi
  001cd	eb 0e		 jmp	 SHORT $LN45@Insert_nod
$LN42@Insert_nod:

; 470  :         } else if (_Wherenode == _Wherenode->_Parent->_Left) {

  001cf	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  001d2	3b 08		 cmp	 ecx, DWORD PTR [eax]
  001d4	75 04		 jne	 SHORT $LN44@Insert_nod

; 471  :             _Wherenode->_Parent->_Left = _Pnode;

  001d6	89 30		 mov	 DWORD PTR [eax], esi

; 472  :         } else {

  001d8	eb 03		 jmp	 SHORT $LN45@Insert_nod
$LN44@Insert_nod:

; 473  :             _Wherenode->_Parent->_Right = _Pnode;

  001da	89 70 08	 mov	 DWORD PTR [eax+8], esi
$LN45@Insert_nod:

; 474  :         }
; 475  : 
; 476  :         _Pnode->_Left       = _Wherenode;

  001dd	89 0e		 mov	 DWORD PTR [esi], ecx
$LN52@Insert_nod:

; 668  :             }
; 669  :         }
; 670  : 
; 671  :         for (_Nodeptr _Pnode = _Newnode; _Pnode->_Parent->_Color == _Red;) {

  001df	89 71 04	 mov	 DWORD PTR [ecx+4], esi
$LN46@Insert_nod:
  001e2	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  001e5	80 78 0c 00	 cmp	 BYTE PTR [eax+12], 0
  001e9	0f 84 71 fe ff
	ff		 je	 $LL2@Insert_nod
  001ef	8b 4d f8	 mov	 ecx, DWORD PTR __Head$1$[ebp]
  001f2	5f		 pop	 edi
  001f3	5e		 pop	 esi
  001f4	5b		 pop	 ebx
$LN3@Insert_nod:

; 705  :                 }
; 706  :             }
; 707  :         }
; 708  : 
; 709  :         _Head->_Parent->_Color = _Black; // root is always black

  001f5	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  001f8	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 710  :         return _Newnode;

  001fc	8b 45 10	 mov	 eax, DWORD PTR __Newnode$[ebp]

; 711  :     }

  001ff	8b e5		 mov	 esp, ebp
  00201	5d		 pop	 ebp
  00202	c2 0c 00	 ret	 12			; 0000000cH
?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@PAX@std@@@2@QAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,__int64> > >::_Insert_node
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@@2@@std@@QAE@XZ PROC ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,tm,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,tm> > >::~map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,tm,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,tm> > >, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 752  :         _Erase_tree(_Al, _Myhead->_Parent);

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	ff 70 04	 push	 DWORD PTR [eax+4]
  00008	56		 push	 esi
  00009	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,tm> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,tm>,void *> > >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 255  :         ::operator delete(_Ptr, _Bytes);

  0000e	6a 4c		 push	 76			; 0000004cH
  00010	ff 36		 push	 DWORD PTR [esi]
  00012	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00017	83 c4 08	 add	 esp, 8
  0001a	5e		 pop	 esi
  0001b	c3		 ret	 0
??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@@2@@std@@QAE@XZ ENDP ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,tm,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,tm> > >::~map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,tm,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,tm> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@PAX@std@@@2@QAU32@@Z
_TEXT	SEGMENT
__Head$1$ = -8						; size = 4
_this$1$ = -4						; size = 4
__Loc$ = 8						; size = 8
__Newnode$ = 16						; size = 4
?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@PAX@std@@@2@QAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,tm> > >::_Insert_node, COMDAT
; _this$ = ecx

; 644  :     _Nodeptr _Insert_node(const _Tree_id<_Nodeptr> _Loc, const _Nodeptr _Newnode) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 645  :         ++_Mysize;
; 646  :         const auto _Head  = _Myhead;
; 647  :         _Newnode->_Parent = _Loc._Parent;

  00006	8b 55 08	 mov	 edx, DWORD PTR __Loc$[ebp]
  00009	8b c1		 mov	 eax, ecx
  0000b	89 45 fc	 mov	 DWORD PTR _this$1$[ebp], eax
  0000e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00010	ff 40 04	 inc	 DWORD PTR [eax+4]
  00013	8b 45 10	 mov	 eax, DWORD PTR __Newnode$[ebp]
  00016	89 4d f8	 mov	 DWORD PTR __Head$1$[ebp], ecx
  00019	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 648  :         if (_Loc._Parent == _Head) { // first node in tree, just set head values

  0001c	3b d1		 cmp	 edx, ecx
  0001e	75 12		 jne	 SHORT $LN5@Insert_nod

; 649  :             _Head->_Left     = _Newnode;

  00020	89 01		 mov	 DWORD PTR [ecx], eax

; 650  :             _Head->_Parent   = _Newnode;

  00022	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 651  :             _Head->_Right    = _Newnode;

  00025	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 652  :             _Newnode->_Color = _Black; // the root is black

  00028	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 711  :     }

  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c2 0c 00	 ret	 12			; 0000000cH
$LN5@Insert_nod:

; 653  :             return _Newnode;
; 654  :         }
; 655  : 
; 656  :         _STL_INTERNAL_CHECK(_Loc._Child != _Tree_child::_Unused);
; 657  :         if (_Loc._Child == _Tree_child::_Right) { // add to right of _Loc._Parent

  00032	83 7d 0c 00	 cmp	 DWORD PTR __Loc$[ebp+4], 0
  00036	75 0d		 jne	 SHORT $LN6@Insert_nod

; 658  :             _STL_INTERNAL_CHECK(_Loc._Parent->_Right->_Isnil);
; 659  :             _Loc._Parent->_Right = _Newnode;

  00038	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 660  :             if (_Loc._Parent == _Head->_Right) { // remember rightmost node

  0003b	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  0003e	75 0d		 jne	 SHORT $LN9@Insert_nod

; 661  :                 _Head->_Right = _Newnode;

  00040	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 662  :             }
; 663  :         } else { // add to left of _Loc._Parent

  00043	eb 08		 jmp	 SHORT $LN9@Insert_nod
$LN6@Insert_nod:

; 664  :             _STL_INTERNAL_CHECK(_Loc._Parent->_Left->_Isnil);
; 665  :             _Loc._Parent->_Left = _Newnode;

  00045	89 02		 mov	 DWORD PTR [edx], eax

; 666  :             if (_Loc._Parent == _Head->_Left) { // remember leftmost node

  00047	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00049	75 02		 jne	 SHORT $LN9@Insert_nod

; 667  :                 _Head->_Left = _Newnode;

  0004b	89 01		 mov	 DWORD PTR [ecx], eax
$LN9@Insert_nod:

; 668  :             }
; 669  :         }
; 670  : 
; 671  :         for (_Nodeptr _Pnode = _Newnode; _Pnode->_Parent->_Color == _Red;) {

  0004d	8b d0		 mov	 edx, eax
  0004f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00052	80 78 0c 00	 cmp	 BYTE PTR [eax+12], 0
  00056	0f 85 99 01 00
	00		 jne	 $LN3@Insert_nod
  0005c	53		 push	 ebx
  0005d	56		 push	 esi
  0005e	57		 push	 edi
  0005f	90		 npad	 1
$LL2@Insert_nod:

; 672  :             if (_Pnode->_Parent == _Pnode->_Parent->_Parent->_Left) { // fixup red-red in left subtree

  00060	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00063	8d 7a 04	 lea	 edi, DWORD PTR [edx+4]
  00066	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00069	8d 59 04	 lea	 ebx, DWORD PTR [ecx+4]
  0006c	8b 06		 mov	 eax, DWORD PTR [esi]
  0006e	3b c8		 cmp	 ecx, eax
  00070	0f 85 ba 00 00
	00		 jne	 $LN10@Insert_nod

; 673  :                 const auto _Parent_sibling = _Pnode->_Parent->_Parent->_Right;

  00076	8b 46 08	 mov	 eax, DWORD PTR [esi+8]

; 674  :                 if (_Parent_sibling->_Color == _Red) { // parent's sibling has two red children, blacken both

  00079	80 78 0c 00	 cmp	 BYTE PTR [eax+12], 0
  0007d	0f 84 b3 00 00
	00		 je	 $LN53@Insert_nod

; 675  :                     _Pnode->_Parent->_Color          = _Black;
; 676  :                     _Parent_sibling->_Color          = _Black;
; 677  :                     _Pnode->_Parent->_Parent->_Color = _Red;
; 678  :                     _Pnode                           = _Pnode->_Parent->_Parent;
; 679  :                 } else { // parent's sibling has red and black children
; 680  :                     if (_Pnode == _Pnode->_Parent->_Right) { // rotate right child to left

  00083	8b 71 08	 mov	 esi, DWORD PTR [ecx+8]
  00086	3b d6		 cmp	 edx, esi
  00088	75 47		 jne	 SHORT $LN51@Insert_nod

; 460  :         _Wherenode->_Right = _Pnode->_Left;

  0008a	8b 06		 mov	 eax, DWORD PTR [esi]

; 681  :                         _Pnode = _Pnode->_Parent;

  0008c	8b d1		 mov	 edx, ecx

; 460  :         _Wherenode->_Right = _Pnode->_Left;

  0008e	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 461  : 
; 462  :         if (!_Pnode->_Left->_Isnil) {

  00091	8b 06		 mov	 eax, DWORD PTR [esi]
  00093	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00097	75 03		 jne	 SHORT $LN20@Insert_nod

; 463  :             _Pnode->_Left->_Parent = _Wherenode;

  00099	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN20@Insert_nod:

; 464  :         }
; 465  : 
; 466  :         _Pnode->_Parent = _Wherenode->_Parent;

  0009c	8b 03		 mov	 eax, DWORD PTR [ebx]
  0009e	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 467  : 
; 468  :         if (_Wherenode == _Myhead->_Parent) {

  000a1	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]
  000a4	8b 00		 mov	 eax, DWORD PTR [eax]
  000a6	3b 50 04	 cmp	 edx, DWORD PTR [eax+4]
  000a9	75 0b		 jne	 SHORT $LN21@Insert_nod

; 469  :             _Myhead->_Parent = _Pnode;

  000ab	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 477  :         _Wherenode->_Parent = _Pnode;

  000ae	8b fb		 mov	 edi, ebx
  000b0	89 16		 mov	 DWORD PTR [esi], edx
  000b2	89 33		 mov	 DWORD PTR [ebx], esi
  000b4	eb 1d		 jmp	 SHORT $LN49@Insert_nod
$LN21@Insert_nod:

; 470  :         } else if (_Wherenode == _Wherenode->_Parent->_Left) {

  000b6	8b 03		 mov	 eax, DWORD PTR [ebx]
  000b8	3b 10		 cmp	 edx, DWORD PTR [eax]
  000ba	75 0a		 jne	 SHORT $LN23@Insert_nod

; 471  :             _Wherenode->_Parent->_Left = _Pnode;

  000bc	89 30		 mov	 DWORD PTR [eax], esi

; 477  :         _Wherenode->_Parent = _Pnode;

  000be	8b fb		 mov	 edi, ebx
  000c0	89 16		 mov	 DWORD PTR [esi], edx
  000c2	89 33		 mov	 DWORD PTR [ebx], esi
  000c4	eb 0d		 jmp	 SHORT $LN49@Insert_nod
$LN23@Insert_nod:

; 473  :             _Wherenode->_Parent->_Right = _Pnode;

  000c6	89 70 08	 mov	 DWORD PTR [eax+8], esi

; 477  :         _Wherenode->_Parent = _Pnode;

  000c9	8b fb		 mov	 edi, ebx
  000cb	89 16		 mov	 DWORD PTR [esi], edx
  000cd	89 33		 mov	 DWORD PTR [ebx], esi
  000cf	eb 02		 jmp	 SHORT $LN49@Insert_nod
$LN51@Insert_nod:
  000d1	8b f1		 mov	 esi, ecx
$LN49@Insert_nod:

; 682  :                         _Lrotate(_Pnode);
; 683  :                     }
; 684  : 
; 685  :                     _Pnode->_Parent->_Color          = _Black; // propagate red up

  000d3	c6 46 0c 01	 mov	 BYTE PTR [esi+12], 1

; 686  :                     _Pnode->_Parent->_Parent->_Color = _Red;

  000d7	8b 07		 mov	 eax, DWORD PTR [edi]
  000d9	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000dc	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 687  :                     _Rrotate(_Pnode->_Parent->_Parent);

  000e0	8b 07		 mov	 eax, DWORD PTR [edi]
  000e2	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 481  :         _Nodeptr _Pnode   = _Wherenode->_Left;

  000e5	8b 31		 mov	 esi, DWORD PTR [ecx]

; 482  :         _Wherenode->_Left = _Pnode->_Right;

  000e7	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000ea	89 01		 mov	 DWORD PTR [ecx], eax

; 483  : 
; 484  :         if (!_Pnode->_Right->_Isnil) {

  000ec	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000ef	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  000f3	75 03		 jne	 SHORT $LN27@Insert_nod

; 485  :             _Pnode->_Right->_Parent = _Wherenode;

  000f5	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN27@Insert_nod:

; 486  :         }
; 487  : 
; 488  :         _Pnode->_Parent = _Wherenode->_Parent;

  000f8	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  000fb	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 489  : 
; 490  :         if (_Wherenode == _Myhead->_Parent) {

  000fe	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]
  00101	8b 00		 mov	 eax, DWORD PTR [eax]
  00103	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00106	75 0b		 jne	 SHORT $LN28@Insert_nod

; 491  :             _Myhead->_Parent = _Pnode;

  00108	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 496  :         }
; 497  : 
; 498  :         _Pnode->_Right      = _Wherenode;

  0010b	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 688  :                 }
; 689  :             } else { // fixup red-red in right subtree

  0010e	e9 cc 00 00 00	 jmp	 $LN52@Insert_nod
$LN28@Insert_nod:

; 492  :         } else if (_Wherenode == _Wherenode->_Parent->_Right) {

  00113	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00116	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00119	75 0b		 jne	 SHORT $LN30@Insert_nod

; 493  :             _Wherenode->_Parent->_Right = _Pnode;

  0011b	89 70 08	 mov	 DWORD PTR [eax+8], esi

; 496  :         }
; 497  : 
; 498  :         _Pnode->_Right      = _Wherenode;

  0011e	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 688  :                 }
; 689  :             } else { // fixup red-red in right subtree

  00121	e9 b9 00 00 00	 jmp	 $LN52@Insert_nod
$LN30@Insert_nod:

; 495  :             _Wherenode->_Parent->_Left = _Pnode;

  00126	89 30		 mov	 DWORD PTR [eax], esi

; 496  :         }
; 497  : 
; 498  :         _Pnode->_Right      = _Wherenode;

  00128	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 688  :                 }
; 689  :             } else { // fixup red-red in right subtree

  0012b	e9 af 00 00 00	 jmp	 $LN52@Insert_nod
$LN10@Insert_nod:

; 690  :                 const auto _Parent_sibling = _Pnode->_Parent->_Parent->_Left;
; 691  :                 if (_Parent_sibling->_Color == _Red) { // parent's sibling has two red children, blacken both

  00130	80 78 0c 00	 cmp	 BYTE PTR [eax+12], 0
  00134	75 1b		 jne	 SHORT $LN15@Insert_nod
$LN53@Insert_nod:

; 668  :             }
; 669  :         }
; 670  : 
; 671  :         for (_Nodeptr _Pnode = _Newnode; _Pnode->_Parent->_Color == _Red;) {

  00136	c6 41 0c 01	 mov	 BYTE PTR [ecx+12], 1
  0013a	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1
  0013e	8b 07		 mov	 eax, DWORD PTR [edi]
  00140	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00143	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0
  00147	8b 07		 mov	 eax, DWORD PTR [edi]
  00149	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0014c	e9 91 00 00 00	 jmp	 $LN46@Insert_nod
$LN15@Insert_nod:

; 692  :                     _Pnode->_Parent->_Color          = _Black;
; 693  :                     _Parent_sibling->_Color          = _Black;
; 694  :                     _Pnode->_Parent->_Parent->_Color = _Red;
; 695  :                     _Pnode                           = _Pnode->_Parent->_Parent;
; 696  :                 } else { // parent's sibling has red and black children
; 697  :                     if (_Pnode == _Pnode->_Parent->_Left) { // rotate left child to right

  00151	8b 01		 mov	 eax, DWORD PTR [ecx]
  00153	3b d0		 cmp	 edx, eax
  00155	75 3e		 jne	 SHORT $LN39@Insert_nod

; 698  :                         _Pnode = _Pnode->_Parent;

  00157	8b d1		 mov	 edx, ecx

; 481  :         _Nodeptr _Pnode   = _Wherenode->_Left;

  00159	8b c8		 mov	 ecx, eax

; 482  :         _Wherenode->_Left = _Pnode->_Right;

  0015b	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0015e	89 02		 mov	 DWORD PTR [edx], eax

; 483  : 
; 484  :         if (!_Pnode->_Right->_Isnil) {

  00160	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00163	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00167	75 03		 jne	 SHORT $LN34@Insert_nod

; 485  :             _Pnode->_Right->_Parent = _Wherenode;

  00169	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN34@Insert_nod:

; 486  :         }
; 487  : 
; 488  :         _Pnode->_Parent = _Wherenode->_Parent;

  0016c	8b 03		 mov	 eax, DWORD PTR [ebx]
  0016e	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 489  : 
; 490  :         if (_Wherenode == _Myhead->_Parent) {

  00171	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]
  00174	8b 00		 mov	 eax, DWORD PTR [eax]
  00176	3b 50 04	 cmp	 edx, DWORD PTR [eax+4]
  00179	75 05		 jne	 SHORT $LN35@Insert_nod

; 491  :             _Myhead->_Parent = _Pnode;

  0017b	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0017e	eb 0e		 jmp	 SHORT $LN38@Insert_nod
$LN35@Insert_nod:

; 492  :         } else if (_Wherenode == _Wherenode->_Parent->_Right) {

  00180	8b 03		 mov	 eax, DWORD PTR [ebx]
  00182	3b 50 08	 cmp	 edx, DWORD PTR [eax+8]
  00185	75 05		 jne	 SHORT $LN37@Insert_nod

; 493  :             _Wherenode->_Parent->_Right = _Pnode;

  00187	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 494  :         } else {

  0018a	eb 02		 jmp	 SHORT $LN38@Insert_nod
$LN37@Insert_nod:

; 495  :             _Wherenode->_Parent->_Left = _Pnode;

  0018c	89 08		 mov	 DWORD PTR [eax], ecx
$LN38@Insert_nod:

; 496  :         }
; 497  : 
; 498  :         _Pnode->_Right      = _Wherenode;

  0018e	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 499  :         _Wherenode->_Parent = _Pnode;

  00191	8b fb		 mov	 edi, ebx
  00193	89 0b		 mov	 DWORD PTR [ebx], ecx
$LN39@Insert_nod:

; 699  :                         _Rrotate(_Pnode);
; 700  :                     }
; 701  : 
; 702  :                     _Pnode->_Parent->_Color          = _Black; // propagate red up

  00195	c6 41 0c 01	 mov	 BYTE PTR [ecx+12], 1

; 703  :                     _Pnode->_Parent->_Parent->_Color = _Red;

  00199	8b 07		 mov	 eax, DWORD PTR [edi]
  0019b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0019e	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 704  :                     _Lrotate(_Pnode->_Parent->_Parent);

  001a2	8b 07		 mov	 eax, DWORD PTR [edi]
  001a4	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 459  :         _Nodeptr _Pnode    = _Wherenode->_Right;

  001a7	8b 71 08	 mov	 esi, DWORD PTR [ecx+8]

; 460  :         _Wherenode->_Right = _Pnode->_Left;

  001aa	8b 06		 mov	 eax, DWORD PTR [esi]
  001ac	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 461  : 
; 462  :         if (!_Pnode->_Left->_Isnil) {

  001af	8b 06		 mov	 eax, DWORD PTR [esi]
  001b1	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  001b5	75 03		 jne	 SHORT $LN41@Insert_nod

; 463  :             _Pnode->_Left->_Parent = _Wherenode;

  001b7	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN41@Insert_nod:

; 464  :         }
; 465  : 
; 466  :         _Pnode->_Parent = _Wherenode->_Parent;

  001ba	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  001bd	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 467  : 
; 468  :         if (_Wherenode == _Myhead->_Parent) {

  001c0	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]
  001c3	8b 00		 mov	 eax, DWORD PTR [eax]
  001c5	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  001c8	75 05		 jne	 SHORT $LN42@Insert_nod

; 469  :             _Myhead->_Parent = _Pnode;

  001ca	89 70 04	 mov	 DWORD PTR [eax+4], esi
  001cd	eb 0e		 jmp	 SHORT $LN45@Insert_nod
$LN42@Insert_nod:

; 470  :         } else if (_Wherenode == _Wherenode->_Parent->_Left) {

  001cf	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  001d2	3b 08		 cmp	 ecx, DWORD PTR [eax]
  001d4	75 04		 jne	 SHORT $LN44@Insert_nod

; 471  :             _Wherenode->_Parent->_Left = _Pnode;

  001d6	89 30		 mov	 DWORD PTR [eax], esi

; 472  :         } else {

  001d8	eb 03		 jmp	 SHORT $LN45@Insert_nod
$LN44@Insert_nod:

; 473  :             _Wherenode->_Parent->_Right = _Pnode;

  001da	89 70 08	 mov	 DWORD PTR [eax+8], esi
$LN45@Insert_nod:

; 474  :         }
; 475  : 
; 476  :         _Pnode->_Left       = _Wherenode;

  001dd	89 0e		 mov	 DWORD PTR [esi], ecx
$LN52@Insert_nod:

; 668  :             }
; 669  :         }
; 670  : 
; 671  :         for (_Nodeptr _Pnode = _Newnode; _Pnode->_Parent->_Color == _Red;) {

  001df	89 71 04	 mov	 DWORD PTR [ecx+4], esi
$LN46@Insert_nod:
  001e2	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  001e5	80 78 0c 00	 cmp	 BYTE PTR [eax+12], 0
  001e9	0f 84 71 fe ff
	ff		 je	 $LL2@Insert_nod
  001ef	8b 4d f8	 mov	 ecx, DWORD PTR __Head$1$[ebp]
  001f2	5f		 pop	 edi
  001f3	5e		 pop	 esi
  001f4	5b		 pop	 ebx
$LN3@Insert_nod:

; 705  :                 }
; 706  :             }
; 707  :         }
; 708  : 
; 709  :         _Head->_Parent->_Color = _Black; // root is always black

  001f5	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  001f8	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 710  :         return _Newnode;

  001fc	8b 45 10	 mov	 eax, DWORD PTR __Newnode$[ebp]

; 711  :     }

  001ff	8b e5		 mov	 esp, ebp
  00201	5d		 pop	 ebp
  00202	c2 0c 00	 ret	 12			; 0000000cH
?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@PAX@std@@@2@QAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,tm> > >::_Insert_node
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE@XZ PROC ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::~map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 752  :         _Erase_tree(_Al, _Myhead->_Parent);

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	ff 70 04	 push	 DWORD PTR [eax+4]
  00008	56		 push	 esi
  00009	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> > >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 255  :         ::operator delete(_Ptr, _Bytes);

  0000e	6a 2c		 push	 44			; 0000002cH
  00010	ff 36		 push	 DWORD PTR [esi]
  00012	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00017	83 c4 08	 add	 esp, 8
  0001a	5e		 pop	 esi
  0001b	c3		 ret	 0
??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE@XZ ENDP ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::~map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@2@QAU32@@Z
_TEXT	SEGMENT
__Head$1$ = -8						; size = 4
_this$1$ = -4						; size = 4
__Loc$ = 8						; size = 8
__Newnode$ = 16						; size = 4
?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@2@QAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Insert_node, COMDAT
; _this$ = ecx

; 644  :     _Nodeptr _Insert_node(const _Tree_id<_Nodeptr> _Loc, const _Nodeptr _Newnode) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 645  :         ++_Mysize;
; 646  :         const auto _Head  = _Myhead;
; 647  :         _Newnode->_Parent = _Loc._Parent;

  00006	8b 55 08	 mov	 edx, DWORD PTR __Loc$[ebp]
  00009	8b c1		 mov	 eax, ecx
  0000b	89 45 fc	 mov	 DWORD PTR _this$1$[ebp], eax
  0000e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00010	ff 40 04	 inc	 DWORD PTR [eax+4]
  00013	8b 45 10	 mov	 eax, DWORD PTR __Newnode$[ebp]
  00016	89 4d f8	 mov	 DWORD PTR __Head$1$[ebp], ecx
  00019	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 648  :         if (_Loc._Parent == _Head) { // first node in tree, just set head values

  0001c	3b d1		 cmp	 edx, ecx
  0001e	75 12		 jne	 SHORT $LN5@Insert_nod

; 649  :             _Head->_Left     = _Newnode;

  00020	89 01		 mov	 DWORD PTR [ecx], eax

; 650  :             _Head->_Parent   = _Newnode;

  00022	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 651  :             _Head->_Right    = _Newnode;

  00025	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 652  :             _Newnode->_Color = _Black; // the root is black

  00028	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 711  :     }

  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c2 0c 00	 ret	 12			; 0000000cH
$LN5@Insert_nod:

; 653  :             return _Newnode;
; 654  :         }
; 655  : 
; 656  :         _STL_INTERNAL_CHECK(_Loc._Child != _Tree_child::_Unused);
; 657  :         if (_Loc._Child == _Tree_child::_Right) { // add to right of _Loc._Parent

  00032	83 7d 0c 00	 cmp	 DWORD PTR __Loc$[ebp+4], 0
  00036	75 0d		 jne	 SHORT $LN6@Insert_nod

; 658  :             _STL_INTERNAL_CHECK(_Loc._Parent->_Right->_Isnil);
; 659  :             _Loc._Parent->_Right = _Newnode;

  00038	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 660  :             if (_Loc._Parent == _Head->_Right) { // remember rightmost node

  0003b	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  0003e	75 0d		 jne	 SHORT $LN9@Insert_nod

; 661  :                 _Head->_Right = _Newnode;

  00040	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 662  :             }
; 663  :         } else { // add to left of _Loc._Parent

  00043	eb 08		 jmp	 SHORT $LN9@Insert_nod
$LN6@Insert_nod:

; 664  :             _STL_INTERNAL_CHECK(_Loc._Parent->_Left->_Isnil);
; 665  :             _Loc._Parent->_Left = _Newnode;

  00045	89 02		 mov	 DWORD PTR [edx], eax

; 666  :             if (_Loc._Parent == _Head->_Left) { // remember leftmost node

  00047	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00049	75 02		 jne	 SHORT $LN9@Insert_nod

; 667  :                 _Head->_Left = _Newnode;

  0004b	89 01		 mov	 DWORD PTR [ecx], eax
$LN9@Insert_nod:

; 668  :             }
; 669  :         }
; 670  : 
; 671  :         for (_Nodeptr _Pnode = _Newnode; _Pnode->_Parent->_Color == _Red;) {

  0004d	8b d0		 mov	 edx, eax
  0004f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00052	80 78 0c 00	 cmp	 BYTE PTR [eax+12], 0
  00056	0f 85 99 01 00
	00		 jne	 $LN3@Insert_nod
  0005c	53		 push	 ebx
  0005d	56		 push	 esi
  0005e	57		 push	 edi
  0005f	90		 npad	 1
$LL2@Insert_nod:

; 672  :             if (_Pnode->_Parent == _Pnode->_Parent->_Parent->_Left) { // fixup red-red in left subtree

  00060	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00063	8d 7a 04	 lea	 edi, DWORD PTR [edx+4]
  00066	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00069	8d 59 04	 lea	 ebx, DWORD PTR [ecx+4]
  0006c	8b 06		 mov	 eax, DWORD PTR [esi]
  0006e	3b c8		 cmp	 ecx, eax
  00070	0f 85 ba 00 00
	00		 jne	 $LN10@Insert_nod

; 673  :                 const auto _Parent_sibling = _Pnode->_Parent->_Parent->_Right;

  00076	8b 46 08	 mov	 eax, DWORD PTR [esi+8]

; 674  :                 if (_Parent_sibling->_Color == _Red) { // parent's sibling has two red children, blacken both

  00079	80 78 0c 00	 cmp	 BYTE PTR [eax+12], 0
  0007d	0f 84 b3 00 00
	00		 je	 $LN53@Insert_nod

; 675  :                     _Pnode->_Parent->_Color          = _Black;
; 676  :                     _Parent_sibling->_Color          = _Black;
; 677  :                     _Pnode->_Parent->_Parent->_Color = _Red;
; 678  :                     _Pnode                           = _Pnode->_Parent->_Parent;
; 679  :                 } else { // parent's sibling has red and black children
; 680  :                     if (_Pnode == _Pnode->_Parent->_Right) { // rotate right child to left

  00083	8b 71 08	 mov	 esi, DWORD PTR [ecx+8]
  00086	3b d6		 cmp	 edx, esi
  00088	75 47		 jne	 SHORT $LN51@Insert_nod

; 460  :         _Wherenode->_Right = _Pnode->_Left;

  0008a	8b 06		 mov	 eax, DWORD PTR [esi]

; 681  :                         _Pnode = _Pnode->_Parent;

  0008c	8b d1		 mov	 edx, ecx

; 460  :         _Wherenode->_Right = _Pnode->_Left;

  0008e	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 461  : 
; 462  :         if (!_Pnode->_Left->_Isnil) {

  00091	8b 06		 mov	 eax, DWORD PTR [esi]
  00093	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00097	75 03		 jne	 SHORT $LN20@Insert_nod

; 463  :             _Pnode->_Left->_Parent = _Wherenode;

  00099	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN20@Insert_nod:

; 464  :         }
; 465  : 
; 466  :         _Pnode->_Parent = _Wherenode->_Parent;

  0009c	8b 03		 mov	 eax, DWORD PTR [ebx]
  0009e	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 467  : 
; 468  :         if (_Wherenode == _Myhead->_Parent) {

  000a1	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]
  000a4	8b 00		 mov	 eax, DWORD PTR [eax]
  000a6	3b 50 04	 cmp	 edx, DWORD PTR [eax+4]
  000a9	75 0b		 jne	 SHORT $LN21@Insert_nod

; 469  :             _Myhead->_Parent = _Pnode;

  000ab	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 477  :         _Wherenode->_Parent = _Pnode;

  000ae	8b fb		 mov	 edi, ebx
  000b0	89 16		 mov	 DWORD PTR [esi], edx
  000b2	89 33		 mov	 DWORD PTR [ebx], esi
  000b4	eb 1d		 jmp	 SHORT $LN49@Insert_nod
$LN21@Insert_nod:

; 470  :         } else if (_Wherenode == _Wherenode->_Parent->_Left) {

  000b6	8b 03		 mov	 eax, DWORD PTR [ebx]
  000b8	3b 10		 cmp	 edx, DWORD PTR [eax]
  000ba	75 0a		 jne	 SHORT $LN23@Insert_nod

; 471  :             _Wherenode->_Parent->_Left = _Pnode;

  000bc	89 30		 mov	 DWORD PTR [eax], esi

; 477  :         _Wherenode->_Parent = _Pnode;

  000be	8b fb		 mov	 edi, ebx
  000c0	89 16		 mov	 DWORD PTR [esi], edx
  000c2	89 33		 mov	 DWORD PTR [ebx], esi
  000c4	eb 0d		 jmp	 SHORT $LN49@Insert_nod
$LN23@Insert_nod:

; 473  :             _Wherenode->_Parent->_Right = _Pnode;

  000c6	89 70 08	 mov	 DWORD PTR [eax+8], esi

; 477  :         _Wherenode->_Parent = _Pnode;

  000c9	8b fb		 mov	 edi, ebx
  000cb	89 16		 mov	 DWORD PTR [esi], edx
  000cd	89 33		 mov	 DWORD PTR [ebx], esi
  000cf	eb 02		 jmp	 SHORT $LN49@Insert_nod
$LN51@Insert_nod:
  000d1	8b f1		 mov	 esi, ecx
$LN49@Insert_nod:

; 682  :                         _Lrotate(_Pnode);
; 683  :                     }
; 684  : 
; 685  :                     _Pnode->_Parent->_Color          = _Black; // propagate red up

  000d3	c6 46 0c 01	 mov	 BYTE PTR [esi+12], 1

; 686  :                     _Pnode->_Parent->_Parent->_Color = _Red;

  000d7	8b 07		 mov	 eax, DWORD PTR [edi]
  000d9	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000dc	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 687  :                     _Rrotate(_Pnode->_Parent->_Parent);

  000e0	8b 07		 mov	 eax, DWORD PTR [edi]
  000e2	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 481  :         _Nodeptr _Pnode   = _Wherenode->_Left;

  000e5	8b 31		 mov	 esi, DWORD PTR [ecx]

; 482  :         _Wherenode->_Left = _Pnode->_Right;

  000e7	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000ea	89 01		 mov	 DWORD PTR [ecx], eax

; 483  : 
; 484  :         if (!_Pnode->_Right->_Isnil) {

  000ec	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000ef	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  000f3	75 03		 jne	 SHORT $LN27@Insert_nod

; 485  :             _Pnode->_Right->_Parent = _Wherenode;

  000f5	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN27@Insert_nod:

; 486  :         }
; 487  : 
; 488  :         _Pnode->_Parent = _Wherenode->_Parent;

  000f8	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  000fb	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 489  : 
; 490  :         if (_Wherenode == _Myhead->_Parent) {

  000fe	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]
  00101	8b 00		 mov	 eax, DWORD PTR [eax]
  00103	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00106	75 0b		 jne	 SHORT $LN28@Insert_nod

; 491  :             _Myhead->_Parent = _Pnode;

  00108	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 496  :         }
; 497  : 
; 498  :         _Pnode->_Right      = _Wherenode;

  0010b	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 688  :                 }
; 689  :             } else { // fixup red-red in right subtree

  0010e	e9 cc 00 00 00	 jmp	 $LN52@Insert_nod
$LN28@Insert_nod:

; 492  :         } else if (_Wherenode == _Wherenode->_Parent->_Right) {

  00113	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00116	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00119	75 0b		 jne	 SHORT $LN30@Insert_nod

; 493  :             _Wherenode->_Parent->_Right = _Pnode;

  0011b	89 70 08	 mov	 DWORD PTR [eax+8], esi

; 496  :         }
; 497  : 
; 498  :         _Pnode->_Right      = _Wherenode;

  0011e	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 688  :                 }
; 689  :             } else { // fixup red-red in right subtree

  00121	e9 b9 00 00 00	 jmp	 $LN52@Insert_nod
$LN30@Insert_nod:

; 495  :             _Wherenode->_Parent->_Left = _Pnode;

  00126	89 30		 mov	 DWORD PTR [eax], esi

; 496  :         }
; 497  : 
; 498  :         _Pnode->_Right      = _Wherenode;

  00128	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 688  :                 }
; 689  :             } else { // fixup red-red in right subtree

  0012b	e9 af 00 00 00	 jmp	 $LN52@Insert_nod
$LN10@Insert_nod:

; 690  :                 const auto _Parent_sibling = _Pnode->_Parent->_Parent->_Left;
; 691  :                 if (_Parent_sibling->_Color == _Red) { // parent's sibling has two red children, blacken both

  00130	80 78 0c 00	 cmp	 BYTE PTR [eax+12], 0
  00134	75 1b		 jne	 SHORT $LN15@Insert_nod
$LN53@Insert_nod:

; 668  :             }
; 669  :         }
; 670  : 
; 671  :         for (_Nodeptr _Pnode = _Newnode; _Pnode->_Parent->_Color == _Red;) {

  00136	c6 41 0c 01	 mov	 BYTE PTR [ecx+12], 1
  0013a	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1
  0013e	8b 07		 mov	 eax, DWORD PTR [edi]
  00140	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00143	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0
  00147	8b 07		 mov	 eax, DWORD PTR [edi]
  00149	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0014c	e9 91 00 00 00	 jmp	 $LN46@Insert_nod
$LN15@Insert_nod:

; 692  :                     _Pnode->_Parent->_Color          = _Black;
; 693  :                     _Parent_sibling->_Color          = _Black;
; 694  :                     _Pnode->_Parent->_Parent->_Color = _Red;
; 695  :                     _Pnode                           = _Pnode->_Parent->_Parent;
; 696  :                 } else { // parent's sibling has red and black children
; 697  :                     if (_Pnode == _Pnode->_Parent->_Left) { // rotate left child to right

  00151	8b 01		 mov	 eax, DWORD PTR [ecx]
  00153	3b d0		 cmp	 edx, eax
  00155	75 3e		 jne	 SHORT $LN39@Insert_nod

; 698  :                         _Pnode = _Pnode->_Parent;

  00157	8b d1		 mov	 edx, ecx

; 481  :         _Nodeptr _Pnode   = _Wherenode->_Left;

  00159	8b c8		 mov	 ecx, eax

; 482  :         _Wherenode->_Left = _Pnode->_Right;

  0015b	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0015e	89 02		 mov	 DWORD PTR [edx], eax

; 483  : 
; 484  :         if (!_Pnode->_Right->_Isnil) {

  00160	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00163	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00167	75 03		 jne	 SHORT $LN34@Insert_nod

; 485  :             _Pnode->_Right->_Parent = _Wherenode;

  00169	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN34@Insert_nod:

; 486  :         }
; 487  : 
; 488  :         _Pnode->_Parent = _Wherenode->_Parent;

  0016c	8b 03		 mov	 eax, DWORD PTR [ebx]
  0016e	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 489  : 
; 490  :         if (_Wherenode == _Myhead->_Parent) {

  00171	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]
  00174	8b 00		 mov	 eax, DWORD PTR [eax]
  00176	3b 50 04	 cmp	 edx, DWORD PTR [eax+4]
  00179	75 05		 jne	 SHORT $LN35@Insert_nod

; 491  :             _Myhead->_Parent = _Pnode;

  0017b	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0017e	eb 0e		 jmp	 SHORT $LN38@Insert_nod
$LN35@Insert_nod:

; 492  :         } else if (_Wherenode == _Wherenode->_Parent->_Right) {

  00180	8b 03		 mov	 eax, DWORD PTR [ebx]
  00182	3b 50 08	 cmp	 edx, DWORD PTR [eax+8]
  00185	75 05		 jne	 SHORT $LN37@Insert_nod

; 493  :             _Wherenode->_Parent->_Right = _Pnode;

  00187	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 494  :         } else {

  0018a	eb 02		 jmp	 SHORT $LN38@Insert_nod
$LN37@Insert_nod:

; 495  :             _Wherenode->_Parent->_Left = _Pnode;

  0018c	89 08		 mov	 DWORD PTR [eax], ecx
$LN38@Insert_nod:

; 496  :         }
; 497  : 
; 498  :         _Pnode->_Right      = _Wherenode;

  0018e	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 499  :         _Wherenode->_Parent = _Pnode;

  00191	8b fb		 mov	 edi, ebx
  00193	89 0b		 mov	 DWORD PTR [ebx], ecx
$LN39@Insert_nod:

; 699  :                         _Rrotate(_Pnode);
; 700  :                     }
; 701  : 
; 702  :                     _Pnode->_Parent->_Color          = _Black; // propagate red up

  00195	c6 41 0c 01	 mov	 BYTE PTR [ecx+12], 1

; 703  :                     _Pnode->_Parent->_Parent->_Color = _Red;

  00199	8b 07		 mov	 eax, DWORD PTR [edi]
  0019b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0019e	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 704  :                     _Lrotate(_Pnode->_Parent->_Parent);

  001a2	8b 07		 mov	 eax, DWORD PTR [edi]
  001a4	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 459  :         _Nodeptr _Pnode    = _Wherenode->_Right;

  001a7	8b 71 08	 mov	 esi, DWORD PTR [ecx+8]

; 460  :         _Wherenode->_Right = _Pnode->_Left;

  001aa	8b 06		 mov	 eax, DWORD PTR [esi]
  001ac	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 461  : 
; 462  :         if (!_Pnode->_Left->_Isnil) {

  001af	8b 06		 mov	 eax, DWORD PTR [esi]
  001b1	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  001b5	75 03		 jne	 SHORT $LN41@Insert_nod

; 463  :             _Pnode->_Left->_Parent = _Wherenode;

  001b7	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN41@Insert_nod:

; 464  :         }
; 465  : 
; 466  :         _Pnode->_Parent = _Wherenode->_Parent;

  001ba	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  001bd	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 467  : 
; 468  :         if (_Wherenode == _Myhead->_Parent) {

  001c0	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]
  001c3	8b 00		 mov	 eax, DWORD PTR [eax]
  001c5	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  001c8	75 05		 jne	 SHORT $LN42@Insert_nod

; 469  :             _Myhead->_Parent = _Pnode;

  001ca	89 70 04	 mov	 DWORD PTR [eax+4], esi
  001cd	eb 0e		 jmp	 SHORT $LN45@Insert_nod
$LN42@Insert_nod:

; 470  :         } else if (_Wherenode == _Wherenode->_Parent->_Left) {

  001cf	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  001d2	3b 08		 cmp	 ecx, DWORD PTR [eax]
  001d4	75 04		 jne	 SHORT $LN44@Insert_nod

; 471  :             _Wherenode->_Parent->_Left = _Pnode;

  001d6	89 30		 mov	 DWORD PTR [eax], esi

; 472  :         } else {

  001d8	eb 03		 jmp	 SHORT $LN45@Insert_nod
$LN44@Insert_nod:

; 473  :             _Wherenode->_Parent->_Right = _Pnode;

  001da	89 70 08	 mov	 DWORD PTR [eax+8], esi
$LN45@Insert_nod:

; 474  :         }
; 475  : 
; 476  :         _Pnode->_Left       = _Wherenode;

  001dd	89 0e		 mov	 DWORD PTR [esi], ecx
$LN52@Insert_nod:

; 668  :             }
; 669  :         }
; 670  : 
; 671  :         for (_Nodeptr _Pnode = _Newnode; _Pnode->_Parent->_Color == _Red;) {

  001df	89 71 04	 mov	 DWORD PTR [ecx+4], esi
$LN46@Insert_nod:
  001e2	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  001e5	80 78 0c 00	 cmp	 BYTE PTR [eax+12], 0
  001e9	0f 84 71 fe ff
	ff		 je	 $LL2@Insert_nod
  001ef	8b 4d f8	 mov	 ecx, DWORD PTR __Head$1$[ebp]
  001f2	5f		 pop	 edi
  001f3	5e		 pop	 esi
  001f4	5b		 pop	 ebx
$LN3@Insert_nod:

; 705  :                 }
; 706  :             }
; 707  :         }
; 708  : 
; 709  :         _Head->_Parent->_Color = _Black; // root is always black

  001f5	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  001f8	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 710  :         return _Newnode;

  001fc	8b 45 10	 mov	 eax, DWORD PTR __Newnode$[ebp]

; 711  :     }

  001ff	8b e5		 mov	 esp, ebp
  00201	5d		 pop	 ebp
  00202	c2 0c 00	 ret	 12			; 0000000cH
?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@2@QAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Insert_node
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??R?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??R?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0@Z PROC ; std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator(), COMDAT
; _this$ = ecx

; 116  :     _NODISCARD constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2272 :         const value_type* _Result = _Bx._Buf;

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	8b c8		 mov	 ecx, eax

; 2286 :         return _BUF_SIZE <= _Myres;

  00008	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 2273 :         if (_Large_string_engaged()) {

  0000c	72 02		 jb	 SHORT $LN8@operator

; 2274 :             _Result = _Unfancy(_Bx._Ptr);

  0000e	8b 08		 mov	 ecx, DWORD PTR [eax]
$LN8@operator:
  00010	53		 push	 ebx
  00011	56		 push	 esi

; 2272 :         const value_type* _Result = _Bx._Buf;

  00012	8b 75 08	 mov	 esi, DWORD PTR __Left$[ebp]
  00015	8b d6		 mov	 edx, esi
  00017	57		 push	 edi

; 2286 :         return _BUF_SIZE <= _Myres;

  00018	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 2273 :         if (_Large_string_engaged()) {

  0001c	72 02		 jb	 SHORT $LN13@operator

; 2274 :             _Result = _Unfancy(_Bx._Ptr);

  0001e	8b 16		 mov	 edx, DWORD PTR [esi]
$LN13@operator:

; 4380 :         return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

  00020	8b 5e 10	 mov	 ebx, DWORD PTR [esi+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 66   :     return _Right < _Left ? _Right : _Left;

  00023	8b f3		 mov	 esi, ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4380 :         return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

  00025	8b 78 10	 mov	 edi, DWORD PTR [eax+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 66   :     return _Right < _Left ? _Right : _Left;

  00028	3b fb		 cmp	 edi, ebx
  0002a	0f 42 f7	 cmovb	 esi, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 384  :         return _CSTD memcmp(_First1, _First2, _Count);

  0002d	83 ee 04	 sub	 esi, 4
  00030	72 11		 jb	 SHORT $LN28@operator
$LL29@operator:
  00032	8b 02		 mov	 eax, DWORD PTR [edx]
  00034	3b 01		 cmp	 eax, DWORD PTR [ecx]
  00036	75 10		 jne	 SHORT $LN27@operator
  00038	83 c2 04	 add	 edx, 4
  0003b	83 c1 04	 add	 ecx, 4
  0003e	83 ee 04	 sub	 esi, 4
  00041	73 ef		 jae	 SHORT $LL29@operator
$LN28@operator:
  00043	83 fe fc	 cmp	 esi, -4			; fffffffcH
  00046	74 34		 je	 SHORT $LN26@operator
$LN27@operator:
  00048	8a 02		 mov	 al, BYTE PTR [edx]
  0004a	3a 01		 cmp	 al, BYTE PTR [ecx]
  0004c	75 27		 jne	 SHORT $LN30@operator
  0004e	83 fe fd	 cmp	 esi, -3			; fffffffdH
  00051	74 29		 je	 SHORT $LN26@operator
  00053	8a 42 01	 mov	 al, BYTE PTR [edx+1]
  00056	3a 41 01	 cmp	 al, BYTE PTR [ecx+1]
  00059	75 1a		 jne	 SHORT $LN30@operator
  0005b	83 fe fe	 cmp	 esi, -2			; fffffffeH
  0005e	74 1c		 je	 SHORT $LN26@operator
  00060	8a 42 02	 mov	 al, BYTE PTR [edx+2]
  00063	3a 41 02	 cmp	 al, BYTE PTR [ecx+2]
  00066	75 0d		 jne	 SHORT $LN30@operator
  00068	83 fe ff	 cmp	 esi, -1
  0006b	74 0f		 je	 SHORT $LN26@operator
  0006d	8a 42 03	 mov	 al, BYTE PTR [edx+3]
  00070	3a 41 03	 cmp	 al, BYTE PTR [ecx+3]
  00073	74 07		 je	 SHORT $LN26@operator
$LN30@operator:
  00075	1b c0		 sbb	 eax, eax
  00077	83 c8 01	 or	 eax, 1
  0007a	eb 02		 jmp	 SHORT $LN31@operator
$LN26@operator:
  0007c	33 c0		 xor	 eax, eax
$LN31@operator:

; 580  :     if (_Ans != 0) {

  0007e	85 c0		 test	 eax, eax
  00080	75 15		 jne	 SHORT $LN20@operator

; 581  :         return _Ans;
; 582  :     }
; 583  : 
; 584  :     if (_Left_size < _Right_size) {

  00082	3b fb		 cmp	 edi, ebx
  00084	76 0d		 jbe	 SHORT $LN32@operator
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 117  :         return _Left < _Right;

  00086	5f		 pop	 edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 585  :         return -1;

  00087	83 c8 ff	 or	 eax, -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 117  :         return _Left < _Right;

  0008a	5e		 pop	 esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4809 :     return _Left.compare(_Right) < 0;

  0008b	c1 e8 1f	 shr	 eax, 31			; 0000001fH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 117  :         return _Left < _Right;

  0008e	5b		 pop	 ebx

; 118  :     }

  0008f	5d		 pop	 ebp
  00090	c2 08 00	 ret	 8
$LN32@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 588  :     if (_Left_size > _Right_size) {

  00093	1b c0		 sbb	 eax, eax
  00095	f7 d8		 neg	 eax
$LN20@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 117  :         return _Left < _Right;

  00097	5f		 pop	 edi
  00098	5e		 pop	 esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4809 :     return _Left.compare(_Right) < 0;

  00099	c1 e8 1f	 shr	 eax, 31			; 0000001fH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 117  :         return _Left < _Right;

  0009c	5b		 pop	 ebx

; 118  :     }

  0009d	5d		 pop	 ebp
  0009e	c2 08 00	 ret	 8
??R?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0@Z ENDP ; std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp
;	COMDAT ?SetXScaleManagerImp@CXScaleTimeDiffManager@@QAEXPAVCXScaleManagerImp@@@Z
_TEXT	SEGMENT
_pXScaleManagerImp$ = 8					; size = 4
?SetXScaleManagerImp@CXScaleTimeDiffManager@@QAEXPAVCXScaleManagerImp@@@Z PROC ; CXScaleTimeDiffManager::SetXScaleManagerImp, COMDAT
; _this$ = ecx

; 45   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 46   : 	m_pXScaleManagerImp	= pXScaleManagerImp;

  00003	8b 45 08	 mov	 eax, DWORD PTR _pXScaleManagerImp$[ebp]
  00006	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 47   : }

  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?SetXScaleManagerImp@CXScaleTimeDiffManager@@QAEXPAVCXScaleManagerImp@@@Z ENDP ; CXScaleTimeDiffManager::SetXScaleManagerImp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp
;	COMDAT ??1CXScaleTimeDiffManager@@UAE@XZ
_TEXT	SEGMENT
??1CXScaleTimeDiffManager@@UAE@XZ PROC			; CXScaleTimeDiffManager::~CXScaleTimeDiffManager, COMDAT
; _this$ = ecx

; 39   : {

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f9		 mov	 edi, ecx

; 41   : }

  00004	8d 4f 20	 lea	 ecx, DWORD PTR [edi+32]
  00007	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7CXScaleTimeDiffManager@@6B@
  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 752  :         _Erase_tree(_Al, _Myhead->_Parent);

  00013	8b 47 18	 mov	 eax, DWORD PTR [edi+24]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp

; 41   : }

  00016	8d 77 18	 lea	 esi, DWORD PTR [edi+24]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 752  :         _Erase_tree(_Al, _Myhead->_Parent);

  00019	8b ce		 mov	 ecx, esi
  0001b	ff 70 04	 push	 DWORD PTR [eax+4]
  0001e	56		 push	 esi
  0001f	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,__int64> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,__int64>,void *> > >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 255  :         ::operator delete(_Ptr, _Bytes);

  00024	6a 30		 push	 48			; 00000030H
  00026	ff 36		 push	 DWORD PTR [esi]
  00028	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 752  :         _Erase_tree(_Al, _Myhead->_Parent);

  0002d	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp

; 41   : }

  00030	8d 77 10	 lea	 esi, DWORD PTR [edi+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 255  :         ::operator delete(_Ptr, _Bytes);

  00033	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 752  :         _Erase_tree(_Al, _Myhead->_Parent);

  00036	8b ce		 mov	 ecx, esi
  00038	ff 70 04	 push	 DWORD PTR [eax+4]
  0003b	56		 push	 esi
  0003c	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,tm> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,tm>,void *> > >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 255  :         ::operator delete(_Ptr, _Bytes);

  00041	6a 4c		 push	 76			; 0000004cH
  00043	ff 36		 push	 DWORD PTR [esi]
  00045	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 752  :         _Erase_tree(_Al, _Myhead->_Parent);

  0004a	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp

; 41   : }

  0004d	8d 77 08	 lea	 esi, DWORD PTR [edi+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 255  :         ::operator delete(_Ptr, _Bytes);

  00050	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 752  :         _Erase_tree(_Al, _Myhead->_Parent);

  00053	8b ce		 mov	 ecx, esi
  00055	ff 70 04	 push	 DWORD PTR [eax+4]
  00058	56		 push	 esi
  00059	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> > >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 255  :         ::operator delete(_Ptr, _Bytes);

  0005e	6a 2c		 push	 44			; 0000002cH
  00060	ff 36		 push	 DWORD PTR [esi]
  00062	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00067	83 c4 08	 add	 esp, 8
  0006a	5f		 pop	 edi
  0006b	5e		 pop	 esi
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp

; 41   : }

  0006c	c3		 ret	 0
??1CXScaleTimeDiffManager@@UAE@XZ ENDP			; CXScaleTimeDiffManager::~CXScaleTimeDiffManager
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp
;	COMDAT ??0CXScaleTimeDiffManager@@QAE@PAVCXScaleManagerImp@@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
_this$ = -20						; size = 4
_this$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_pXScaleManagerImp$ = 8					; size = 4
??0CXScaleTimeDiffManager@@QAE@PAVCXScaleManagerImp@@@Z PROC ; CXScaleTimeDiffManager::CXScaleTimeDiffManager, COMDAT
; _this$ = ecx

; 32   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CXScaleTimeDiffManager@@QAE@PAVCXScaleManagerImp@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	50		 push	 eax
  0001e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00027	8b f9		 mov	 edi, ecx
  00029	89 7d f0	 mov	 DWORD PTR _this$[ebp], edi
  0002c	8d 77 08	 lea	 esi, DWORD PTR [edi+8]
  0002f	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7CXScaleTimeDiffManager@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 79   :         return ::operator new(_Bytes);

  00035	6a 2c		 push	 44			; 0000002cH
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp

; 32   : {

  00037	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 435  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

  0003a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00040	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 79   :         return ::operator new(_Bytes);

  00047	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 345  :         _Construct_in_place(_Pnode->_Left, _Pnode);

  0004c	89 00		 mov	 DWORD PTR [eax], eax

; 346  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

  0004e	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 347  :         _Construct_in_place(_Pnode->_Right, _Pnode);

  00051	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 348  :         _Pnode->_Color = _Black;

  00054	66 c7 40 0c 01
	01		 mov	 WORD PTR [eax+12], 257	; 00000101H

; 1917 :         _Scary->_Myhead = _Node::_Buyheadnode(_Getal());

  0005a	89 06		 mov	 DWORD PTR [esi], eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp

; 32   : {

  0005c	8d 77 10	 lea	 esi, DWORD PTR [edi+16]
  0005f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 79   :         return ::operator new(_Bytes);

  00066	6a 4c		 push	 76			; 0000004cH
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp

; 32   : {

  00068	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 435  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

  0006b	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00071	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 79   :         return ::operator new(_Bytes);

  00078	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 345  :         _Construct_in_place(_Pnode->_Left, _Pnode);

  0007d	89 00		 mov	 DWORD PTR [eax], eax

; 346  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

  0007f	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 347  :         _Construct_in_place(_Pnode->_Right, _Pnode);

  00082	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 348  :         _Pnode->_Color = _Black;

  00085	66 c7 40 0c 01
	01		 mov	 WORD PTR [eax+12], 257	; 00000101H

; 1917 :         _Scary->_Myhead = _Node::_Buyheadnode(_Getal());

  0008b	89 06		 mov	 DWORD PTR [esi], eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp

; 32   : {

  0008d	8d 77 18	 lea	 esi, DWORD PTR [edi+24]
  00090	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 79   :         return ::operator new(_Bytes);

  00094	6a 30		 push	 48			; 00000030H
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp

; 32   : {

  00096	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 435  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

  00099	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0009f	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 79   :         return ::operator new(_Bytes);

  000a6	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000ab	83 c4 0c	 add	 esp, 12			; 0000000cH
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp

; 32   : {

  000ae	8d 4f 20	 lea	 ecx, DWORD PTR [edi+32]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 345  :         _Construct_in_place(_Pnode->_Left, _Pnode);

  000b1	89 00		 mov	 DWORD PTR [eax], eax

; 346  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

  000b3	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 347  :         _Construct_in_place(_Pnode->_Right, _Pnode);

  000b6	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 348  :         _Pnode->_Color = _Black;

  000b9	66 c7 40 0c 01
	01		 mov	 WORD PTR [eax+12], 257	; 00000101H

; 1917 :         _Scary->_Myhead = _Node::_Buyheadnode(_Getal());

  000bf	89 06		 mov	 DWORD PTR [esi], eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp

; 32   : {

  000c1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 33   : 	m_pXScaleManagerImp	= pXScaleManagerImp;

  000c7	8b 45 08	 mov	 eax, DWORD PTR _pXScaleManagerImp$[ebp]
  000ca	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 34   : 
; 35   : 	m_tmScreenTimeDiff = 0;
; 36   : }

  000cd	8b c7		 mov	 eax, edi
  000cf	c7 47 24 00 00
	00 00		 mov	 DWORD PTR [edi+36], 0
  000d6	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000d9	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000e0	59		 pop	 ecx
  000e1	5f		 pop	 edi
  000e2	5e		 pop	 esi
  000e3	8b e5		 mov	 esp, ebp
  000e5	5d		 pop	 ebp
  000e6	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CXScaleTimeDiffManager@@QAE@PAVCXScaleManagerImp@@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 08	 add	 ecx, 8
  00006	e9 00 00 00 00	 jmp	 ??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE@XZ
__unwindfunclet$??0CXScaleTimeDiffManager@@QAE@PAVCXScaleManagerImp@@@Z$1:
  0000b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	83 c1 10	 add	 ecx, 16			; 00000010H
  00011	e9 00 00 00 00	 jmp	 ??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@@2@@std@@QAE@XZ
  00016	cc		 int	 3
  00017	cc		 int	 3
  00018	cc		 int	 3
  00019	cc		 int	 3
  0001a	cc		 int	 3
__ehhandler$??0CXScaleTimeDiffManager@@QAE@PAVCXScaleManagerImp@@@Z:
  0001b	90		 npad	 1
  0001c	90		 npad	 1
  0001d	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00021	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00024	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00027	33 c8		 xor	 ecx, eax
  00029	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002e	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CXScaleTimeDiffManager@@QAE@PAVCXScaleManagerImp@@@Z
  00033	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CXScaleTimeDiffManager@@QAE@PAVCXScaleManagerImp@@@Z ENDP ; CXScaleTimeDiffManager::CXScaleTimeDiffManager
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp
;	COMDAT ??0CXScaleTimeDiffManager@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
_this$ = -20						; size = 4
_this$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CXScaleTimeDiffManager@@QAE@XZ PROC			; CXScaleTimeDiffManager::CXScaleTimeDiffManager, COMDAT
; _this$ = ecx

; 25   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CXScaleTimeDiffManager@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	50		 push	 eax
  0001e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00027	8b f9		 mov	 edi, ecx
  00029	89 7d f0	 mov	 DWORD PTR _this$[ebp], edi
  0002c	8d 77 08	 lea	 esi, DWORD PTR [edi+8]
  0002f	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7CXScaleTimeDiffManager@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 79   :         return ::operator new(_Bytes);

  00035	6a 2c		 push	 44			; 0000002cH
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp

; 25   : {

  00037	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 435  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

  0003a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00040	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 79   :         return ::operator new(_Bytes);

  00047	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 345  :         _Construct_in_place(_Pnode->_Left, _Pnode);

  0004c	89 00		 mov	 DWORD PTR [eax], eax

; 346  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

  0004e	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 347  :         _Construct_in_place(_Pnode->_Right, _Pnode);

  00051	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 348  :         _Pnode->_Color = _Black;

  00054	66 c7 40 0c 01
	01		 mov	 WORD PTR [eax+12], 257	; 00000101H

; 1917 :         _Scary->_Myhead = _Node::_Buyheadnode(_Getal());

  0005a	89 06		 mov	 DWORD PTR [esi], eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp

; 25   : {

  0005c	8d 77 10	 lea	 esi, DWORD PTR [edi+16]
  0005f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 79   :         return ::operator new(_Bytes);

  00066	6a 4c		 push	 76			; 0000004cH
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp

; 25   : {

  00068	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 435  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

  0006b	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00071	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 79   :         return ::operator new(_Bytes);

  00078	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 345  :         _Construct_in_place(_Pnode->_Left, _Pnode);

  0007d	89 00		 mov	 DWORD PTR [eax], eax

; 346  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

  0007f	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 347  :         _Construct_in_place(_Pnode->_Right, _Pnode);

  00082	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 348  :         _Pnode->_Color = _Black;

  00085	66 c7 40 0c 01
	01		 mov	 WORD PTR [eax+12], 257	; 00000101H

; 1917 :         _Scary->_Myhead = _Node::_Buyheadnode(_Getal());

  0008b	89 06		 mov	 DWORD PTR [esi], eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp

; 25   : {

  0008d	8d 77 18	 lea	 esi, DWORD PTR [edi+24]
  00090	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 79   :         return ::operator new(_Bytes);

  00094	6a 30		 push	 48			; 00000030H
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp

; 25   : {

  00096	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 435  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

  00099	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0009f	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 79   :         return ::operator new(_Bytes);

  000a6	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000ab	83 c4 0c	 add	 esp, 12			; 0000000cH
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp

; 25   : {

  000ae	8d 4f 20	 lea	 ecx, DWORD PTR [edi+32]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 345  :         _Construct_in_place(_Pnode->_Left, _Pnode);

  000b1	89 00		 mov	 DWORD PTR [eax], eax

; 346  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

  000b3	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 347  :         _Construct_in_place(_Pnode->_Right, _Pnode);

  000b6	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 348  :         _Pnode->_Color = _Black;

  000b9	66 c7 40 0c 01
	01		 mov	 WORD PTR [eax+12], 257	; 00000101H

; 1917 :         _Scary->_Myhead = _Node::_Buyheadnode(_Getal());

  000bf	89 06		 mov	 DWORD PTR [esi], eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp

; 25   : {

  000c1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 26   : 	m_pXScaleManagerImp	= NULL;

  000c7	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0

; 27   : 
; 28   : 	m_tmScreenTimeDiff = 0;
; 29   : }

  000ce	8b c7		 mov	 eax, edi
  000d0	c7 47 24 00 00
	00 00		 mov	 DWORD PTR [edi+36], 0
  000d7	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000da	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000e1	59		 pop	 ecx
  000e2	5f		 pop	 edi
  000e3	5e		 pop	 esi
  000e4	8b e5		 mov	 esp, ebp
  000e6	5d		 pop	 ebp
  000e7	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CXScaleTimeDiffManager@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 08	 add	 ecx, 8
  00006	e9 00 00 00 00	 jmp	 ??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE@XZ
__unwindfunclet$??0CXScaleTimeDiffManager@@QAE@XZ$1:
  0000b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	83 c1 10	 add	 ecx, 16			; 00000010H
  00011	e9 00 00 00 00	 jmp	 ??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Utm@@@std@@@2@@std@@QAE@XZ
  00016	cc		 int	 3
  00017	cc		 int	 3
  00018	cc		 int	 3
  00019	cc		 int	 3
  0001a	cc		 int	 3
__ehhandler$??0CXScaleTimeDiffManager@@QAE@XZ:
  0001b	90		 npad	 1
  0001c	90		 npad	 1
  0001d	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00021	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00024	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00027	33 c8		 xor	 ecx, eax
  00029	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002e	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CXScaleTimeDiffManager@@QAE@XZ
  00033	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CXScaleTimeDiffManager@@QAE@XZ ENDP			; CXScaleTimeDiffManager::CXScaleTimeDiffManager
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
__Old$1$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__New_ptr$1$ = 12					; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 3210 :         _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	8b f1		 mov	 esi, ecx
  00008	57		 push	 edi

; 3211 :         // assign [_Ptr, _Ptr + _Count)
; 3212 :         if (_Count <= _Mypair._Myval2._Myres) {

  00009	8b 7d 0c	 mov	 edi, DWORD PTR __Count$[ebp]
  0000c	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  0000f	89 4d fc	 mov	 DWORD PTR __Old$1$[ebp], ecx
  00012	3b f9		 cmp	 edi, ecx
  00014	77 28		 ja	 SHORT $LN2@assign

; 2263 :         value_type* _Result = _Bx._Buf;

  00016	8b de		 mov	 ebx, esi

; 2286 :         return _BUF_SIZE <= _Myres;

  00018	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 2264 :         if (_Large_string_engaged()) {

  0001b	72 02		 jb	 SHORT $LN5@assign

; 2265 :             _Result = _Unfancy(_Bx._Ptr);

  0001d	8b 1e		 mov	 ebx, DWORD PTR [esi]
$LN5@assign:

; 121  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  0001f	57		 push	 edi
  00020	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]

; 3213 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
; 3214 :             _Mypair._Myval2._Mysize = _Count;

  00023	89 7e 10	 mov	 DWORD PTR [esi+16], edi

; 121  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00026	53		 push	 ebx
  00027	e8 00 00 00 00	 call	 _memmove
  0002c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3215 :             _Traits::move(_Old_ptr, _Ptr, _Count);
; 3216 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  0002f	c6 04 3b 00	 mov	 BYTE PTR [ebx+edi], 0

; 3225 :             },
; 3226 :             _Ptr);
; 3227 :     }

  00033	8b c6		 mov	 eax, esi
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c2 08 00	 ret	 8
$LN2@assign:

; 4474 :         if (_New_size > max_size()) {

  0003e	81 ff ff ff ff
	7f		 cmp	 edi, 2147483647		; 7fffffffH
  00044	0f 87 9e 00 00
	00		 ja	 $LN50@assign

; 4454 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  0004a	8b df		 mov	 ebx, edi
  0004c	83 cb 0f	 or	 ebx, 15			; 0000000fH
  0004f	81 fb ff ff ff
	7f		 cmp	 ebx, 2147483647		; 7fffffffH

; 4455 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00055	76 07		 jbe	 SHORT $LN19@assign

; 4456 :             return _Max;

  00057	bb ff ff ff 7f	 mov	 ebx, 2147483647		; 7fffffffH
  0005c	eb 1e		 jmp	 SHORT $LN18@assign
$LN19@assign:

; 4457 :         }
; 4458 : 
; 4459 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  0005e	8b d1		 mov	 edx, ecx
  00060	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00065	d1 ea		 shr	 edx, 1
  00067	2b c2		 sub	 eax, edx
  00069	3b c8		 cmp	 ecx, eax
  0006b	76 07		 jbe	 SHORT $LN20@assign

; 4460 :             return _Max;

  0006d	bb ff ff ff 7f	 mov	 ebx, 2147483647		; 7fffffffH
  00072	eb 08		 jmp	 SHORT $LN18@assign
$LN20@assign:

; 4461 :         }
; 4462 : 
; 4463 :         return (_STD max)(_Masked, _Old + _Old / 2);

  00074	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 43   :     return _Left < _Right ? _Right : _Left;

  00077	3b d8		 cmp	 ebx, eax
  00079	0f 42 d8	 cmovb	 ebx, eax
$LN18@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4481 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  0007c	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
  0007f	8b ce		 mov	 ecx, esi
  00081	50		 push	 eax
  00082	e8 00 00 00 00	 call	 ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00087	57		 push	 edi
  00088	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]

; 4481 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  0008b	89 45 0c	 mov	 DWORD PTR __New_ptr$1$[ebp], eax

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0008e	50		 push	 eax

; 4489 :         _Mypair._Myval2._Mysize = _New_size;

  0008f	89 7e 10	 mov	 DWORD PTR [esi+16], edi

; 4490 :         _Mypair._Myval2._Myres  = _New_capacity;

  00092	89 5e 14	 mov	 DWORD PTR [esi+20], ebx

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00095	e8 00 00 00 00	 call	 _memcpy

; 3224 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  0009a	8b 5d 0c	 mov	 ebx, DWORD PTR __New_ptr$1$[ebp]

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0009d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4492 :         if (_BUF_SIZE <= _Old_capacity) {

  000a0	8b 45 fc	 mov	 eax, DWORD PTR __Old$1$[ebp]

; 3224 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  000a3	c6 04 3b 00	 mov	 BYTE PTR [ebx+edi], 0

; 4492 :         if (_BUF_SIZE <= _Old_capacity) {

  000a7	83 f8 10	 cmp	 eax, 16			; 00000010H
  000aa	72 29		 jb	 SHORT $LN13@assign

; 4493 :             _Al.deallocate(_Mypair._Myval2._Bx._Ptr, _Old_capacity + 1);

  000ac	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000af	8b 06		 mov	 eax, DWORD PTR [esi]

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  000b1	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  000b7	72 12		 jb	 SHORT $LN42@assign

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000b9	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  000bc	83 c1 23	 add	 ecx, 35			; 00000023H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  000bf	2b c2		 sub	 eax, edx

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000c1	83 c0 fc	 add	 eax, -4			; fffffffcH
  000c4	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  000c7	77 19		 ja	 SHORT $LN39@assign

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  000c9	8b c2		 mov	 eax, edx
$LN42@assign:

; 255  :         ::operator delete(_Ptr, _Bytes);

  000cb	51		 push	 ecx
  000cc	50		 push	 eax
  000cd	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  000d2	83 c4 08	 add	 esp, 8
$LN13@assign:
  000d5	5f		 pop	 edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 3220 :         return _Reallocate_for(

  000d6	89 1e		 mov	 DWORD PTR [esi], ebx

; 3225 :             },
; 3226 :             _Ptr);
; 3227 :     }

  000d8	8b c6		 mov	 eax, esi
  000da	5e		 pop	 esi
  000db	5b		 pop	 ebx
  000dc	8b e5		 mov	 esp, ebp
  000de	5d		 pop	 ebp
  000df	c2 08 00	 ret	 8
$LN39@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000e2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN50@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4475 :             _Xlen_string(); // result too long

  000e8	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN47@assign:
  000ed	cc		 int	 3
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2968 :     _CONSTEXPR20_CONTAINER ~basic_string() noexcept {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 2286 :         return _BUF_SIZE <= _Myres;

  00003	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00006	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 4584 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00009	72 27		 jb	 SHORT $LN12@basic_stri
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000b	8b 06		 mov	 eax, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4588 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0000d	41		 inc	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0000e	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00014	72 12		 jb	 SHORT $LN22@basic_stri

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00016	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00019	83 c1 23	 add	 ecx, 35			; 00000023H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001c	2b c2		 sub	 eax, edx

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0001e	83 c0 fc	 add	 eax, -4			; fffffffcH
  00021	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00024	77 1f		 ja	 SHORT $LN19@basic_stri

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00026	8b c2		 mov	 eax, edx
$LN22@basic_stri:

; 255  :         ::operator delete(_Ptr, _Bytes);

  00028	51		 push	 ecx
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	83 c4 08	 add	 esp, 8
$LN12@basic_stri:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4599 :             _Mypair._Myval2._Mysize = 0;

  00032	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 4600 :             _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00039	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 4601 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4602 :             _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00040	c6 06 00	 mov	 BYTE PTR [esi], 0
  00043	5e		 pop	 esi

; 2976 :     }

  00044	c3		 ret	 0
$LN19@basic_stri:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00045	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN27@basic_stri:
  0004b	cc		 int	 3
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 800  :     _NODISCARD _CONSTEXPR20_DYNALLOC __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 228  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0000b	72 29		 jb	 SHORT $LN4@allocate

; 129  :     const size_t _Block_size = _Non_user_size + _Bytes;

  0000d	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]

; 130  :     if (_Block_size <= _Bytes) {

  00010	3b c8		 cmp	 ecx, eax
  00012	76 39		 jbe	 SHORT $LN26@allocate

; 79   :         return ::operator new(_Bytes);

  00014	51		 push	 ecx
  00015	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 134  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  0001a	8b c8		 mov	 ecx, eax

; 79   :         return ::operator new(_Bytes);

  0001c	83 c4 04	 add	 esp, 4

; 135  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0001f	85 c9		 test	 ecx, ecx
  00021	74 0d		 je	 SHORT $LN13@allocate

; 136  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  00023	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00026	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 137  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00029	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 801  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 802  :     }

  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
$LN13@allocate:

; 135  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  00030	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN4@allocate:

; 234  :     if (_Bytes != 0) {

  00036	85 c0		 test	 eax, eax
  00038	74 0d		 je	 SHORT $LN5@allocate

; 79   :         return ::operator new(_Bytes);

  0003a	50		 push	 eax
  0003b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00040	83 c4 04	 add	 esp, 4

; 801  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 802  :     }

  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
$LN5@allocate:

; 238  :     return nullptr;

  00047	33 c0		 xor	 eax, eax

; 801  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 802  :     }

  00049	5d		 pop	 ebp
  0004a	c2 04 00	 ret	 4
$LN26@allocate:

; 131  :         _Throw_bad_array_new_length(); // add overflow

  0004d	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN24@allocate:
  00052	cc		 int	 3
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Xlen_string@std@@YAXXZ
_TEXT	SEGMENT
?_Xlen_string@std@@YAXXZ PROC				; std::_Xlen_string, COMDAT

; 2340 :     _Xlength_error("string too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlen_strin:
  0000a	cc		 int	 3
?_Xlen_string@std@@YAXXZ ENDP				; std::_Xlen_string
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ?_Throw_tree_length_error@std@@YAXXZ
_TEXT	SEGMENT
?_Throw_tree_length_error@std@@YAXXZ PROC		; std::_Throw_tree_length_error, COMDAT

; 416  :     _Xlength_error("map/set too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@GCADKGJO@map?1set?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Throw_tree:
  0000a	cc		 int	 3
?_Throw_tree_length_error@std@@YAXXZ ENDP		; std::_Throw_tree_length_error
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 315  : [[noreturn]] inline void _Throw_bad_array_new_length() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 316  :     _THROW(bad_array_new_length{});

  00006	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00009	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QAE@XZ ; std::bad_array_new_length::bad_array_new_length
  0000e	68 00 00 00 00	 push	 OFFSET __TI3?AVbad_array_new_length@std@@
  00013	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN3@Throw_bad_:
  0001c	cc		 int	 3
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 89   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 90   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN12@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN12@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 72   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0

; 71   :         : _Data()

  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_array_new_length@std@@6B@
  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx

; 90   :         __std_exception_destroy(&_Data);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx
  00010	c3		 ret	 0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 141  :     {

  00000	0f 57 c0	 xorps	 xmm0, xmm0

; 142  :     }

  00003	8b c1		 mov	 eax, ecx

; 65   :         : _Data()

  00005	66 0f d6 41 04	 movq	 QWORD PTR [ecx+4], xmm0

; 66   :     {
; 67   :         _Data._What = _Message;

  0000a	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@

; 141  :     {

  00011	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_array_new_length@std@@6B@

; 142  :     }

  00017	c3		 ret	 0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 89   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 90   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN9@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN9@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 72   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0

; 71   :         : _Data()

  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 89   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 90   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN6@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN6@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 95   :         return _Data._What ? _Data._What : "Unknown exception";

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
  00008	85 c9		 test	 ecx, ecx
  0000a	0f 45 c1	 cmovne	 eax, ecx

; 96   :     }

  0000d	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UAE@XZ
_TEXT	SEGMENT
??1exception@std@@UAE@XZ PROC				; std::exception::~exception, COMDAT
; _this$ = ecx

; 90   :         __std_exception_destroy(&_Data);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx

; 91   :     }

  00010	c3		 ret	 0
??1exception@std@@UAE@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 72   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0
  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8

; 74   :     }

  00026	8b c6		 mov	 eax, esi
  00028	5e		 pop	 esi
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	c2 00 00	 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleTimeDiffManager.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

  00000	c2 00 00	 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
