; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30145.0 

	TITLE	D:\git\src\IBK\IBK_DRFN\#DRfn-CS\_Obj\ChartObject\BlocksPositionCalculator.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?m_nMouseClickThickness@CBlocksPositionCalculator@@0HA ; CBlocksPositionCalculator::m_nMouseClickThickness
PUBLIC	?m_nMinBlockWidth@CBlocksPositionCalculator@@0HA ; CBlocksPositionCalculator::m_nMinBlockWidth
_DATA	SEGMENT
?m_nMouseClickThickness@CBlocksPositionCalculator@@0HA DD 02H ; CBlocksPositionCalculator::m_nMouseClickThickness
?m_nMinBlockWidth@CBlocksPositionCalculator@@0HA DD 04H	; CBlocksPositionCalculator::m_nMinBlockWidth
_DATA	ENDS
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	??1CObject@@UAE@XZ				; CObject::~CObject
PUBLIC	?Serialize@CObject@@UAEXAAVCArchive@@@Z		; CObject::Serialize
PUBLIC	?AssertValid@CObject@@UBEXXZ			; CObject::AssertValid
PUBLIC	?Dump@CObject@@UBEXAAVCDumpContext@@@Z		; CObject::Dump
PUBLIC	?IsBiggerThanMinMainRegion@CBlocksPositionCalculator@@SA_NHHHH@Z ; CBlocksPositionCalculator::IsBiggerThanMinMainRegion
PUBLIC	?IsRectInRect@CBlocksPositionCalculator@@SA_NABVCRect@@0@Z ; CBlocksPositionCalculator::IsRectInRect
PUBLIC	?Add_EqualityPartition@CBlocksPositionCalculator@@SAXAAV?$CList@NN@@HHHH@Z ; CBlocksPositionCalculator::Add_EqualityPartition
PUBLIC	?Add_DoubleSize@CBlocksPositionCalculator@@SAXAAV?$CList@NN@@HHHHH@Z ; CBlocksPositionCalculator::Add_DoubleSize
PUBLIC	?SetBlocksPosition@CBlocksPositionCalculator@@SAXAAV?$CList@NN@@HABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ; CBlocksPositionCalculator::SetBlocksPosition
PUBLIC	?GetSavedPosition@CBlocksPositionCalculator@@SA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@ABV?$CList@NN@@ABV23@@Z ; CBlocksPositionCalculator::GetSavedPosition
PUBLIC	?GetBlockRegion@CBlocksPositionCalculator@@SAXHHHABV?$CList@NN@@HAAN1@Z ; CBlocksPositionCalculator::GetBlockRegion
PUBLIC	?GetPositionLength@CBlocksPositionCalculator@@SAHHHHHHH@Z ; CBlocksPositionCalculator::GetPositionLength
PUBLIC	?GetAbsolutePoint@CBlocksPositionCalculator@@SA?AVCPoint@@ABV2@ABV?$CList@NN@@1HH@Z ; CBlocksPositionCalculator::GetAbsolutePoint
PUBLIC	?InitializePositions@CBlocksPositionCalculator@@SAXABVCRect@@HHAAV?$CList@HH@@1HH@Z ; CBlocksPositionCalculator::InitializePositions
PUBLIC	?RecalculatePositions@CBlocksPositionCalculator@@SAXABVCRect@@0AAV?$CList@NN@@1@Z ; CBlocksPositionCalculator::RecalculatePositions
PUBLIC	?FindCompartLine@CBlocksPositionCalculator@@SA_NABVCPoint@@ABV?$CList@NN@@10AAH2@Z ; CBlocksPositionCalculator::FindCompartLine
PUBLIC	?MoveBlocksPosition@CBlocksPositionCalculator@@SA_NAAV?$CList@NN@@0ABVCPoint@@HH@Z ; CBlocksPositionCalculator::MoveBlocksPosition
PUBLIC	?MoveBlockPosition@CBlocksPositionCalculator@@SA_NAAV?$CList@NN@@HH@Z ; CBlocksPositionCalculator::MoveBlockPosition
PUBLIC	?RecalculatePositions@CBlocksPositionCalculator@@SAXAAV?$CList@NN@@HH@Z ; CBlocksPositionCalculator::RecalculatePositions
PUBLIC	?GetDoubleSizeBlockCount@CBlocksPositionCalculator@@CAHHH@Z ; CBlocksPositionCalculator::GetDoubleSizeBlockCount
PUBLIC	?IsBlockInDoubleSize@CBlocksPositionCalculator@@CA_NHHH@Z ; CBlocksPositionCalculator::IsBlockInDoubleSize
PUBLIC	?GetBlocksPosition@CBlocksPositionCalculator@@CA_NABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAV?$CList@NN@@@Z ; CBlocksPositionCalculator::GetBlocksPosition
PUBLIC	?SetBlocksPosition@CBlocksPositionCalculator@@CA_NAAV?$CList@NN@@ABV2@@Z ; CBlocksPositionCalculator::SetBlocksPosition
PUBLIC	?GetAbsolutePosition@CBlocksPositionCalculator@@CANNABV?$CList@NN@@H@Z ; CBlocksPositionCalculator::GetAbsolutePosition
PUBLIC	?GetBlockLength@CBlocksPositionCalculator@@CAHHHHHHHH@Z ; CBlocksPositionCalculator::GetBlockLength
PUBLIC	?InitializePositions@CBlocksPositionCalculator@@CAXAAV?$CList@HH@@HHHH@Z ; CBlocksPositionCalculator::InitializePositions
PUBLIC	?GetChangedPosition@CBlocksPositionCalculator@@CAHHHHHH@Z ; CBlocksPositionCalculator::GetChangedPosition
PUBLIC	?AppropriateRowCompartLine@CBlocksPositionCalculator@@CA_NABVCPoint@@ABV?$CList@NN@@10AAH@Z ; CBlocksPositionCalculator::AppropriateRowCompartLine
PUBLIC	?AppropriateColumnCompartLine@CBlocksPositionCalculator@@CA_NABVCPoint@@ABV?$CList@NN@@10AAH@Z ; CBlocksPositionCalculator::AppropriateColumnCompartLine
PUBLIC	?IsPtInRect@CBlocksPositionCalculator@@CA_NABVCRect@@ABVCPoint@@@Z ; CBlocksPositionCalculator::IsPtInRect
PUBLIC	?MoveBlocksPosition@CBlocksPositionCalculator@@CA_NAAV?$CList@NN@@HH@Z ; CBlocksPositionCalculator::MoveBlocksPosition
PUBLIC	?IsMoveBlockPosition@CBlocksPositionCalculator@@CA_NHH@Z ; CBlocksPositionCalculator::IsMoveBlockPosition
PUBLIC	?GetChangedLengthInBlock@CBlocksPositionCalculator@@CA_NABV?$CList@NN@@HHAAV2@@Z ; CBlocksPositionCalculator::GetChangedLengthInBlock
PUBLIC	?GetChangedLengthInBlock@CBlocksPositionCalculator@@CA_NHHAAV?$CList@NN@@@Z ; CBlocksPositionCalculator::GetChangedLengthInBlock
PUBLIC	?GetData@CBlocksPositionCalculator@@CANABV?$CList@NN@@H@Z ; CBlocksPositionCalculator::GetData
PUBLIC	??0?$CList@NN@@QAE@H@Z				; CList<double,double>::CList<double,double>
PUBLIC	?AddHead@?$CList@NN@@QAEPAU__POSITION@@N@Z	; CList<double,double>::AddHead
PUBLIC	?AddTail@?$CList@NN@@QAEPAU__POSITION@@N@Z	; CList<double,double>::AddTail
PUBLIC	?RemoveAll@?$CList@NN@@QAEXXZ			; CList<double,double>::RemoveAll
PUBLIC	?RemoveAt@?$CList@NN@@QAEXPAU__POSITION@@@Z	; CList<double,double>::RemoveAt
PUBLIC	?InsertBefore@?$CList@NN@@QAEPAU__POSITION@@PAU2@N@Z ; CList<double,double>::InsertBefore
PUBLIC	?InsertAfter@?$CList@NN@@QAEPAU__POSITION@@PAU2@N@Z ; CList<double,double>::InsertAfter
PUBLIC	?FindIndex@?$CList@NN@@QBEPAU__POSITION@@H@Z	; CList<double,double>::FindIndex
PUBLIC	?NewNode@?$CList@NN@@IAEPAUCNode@1@PAU21@0@Z	; CList<double,double>::NewNode
PUBLIC	?FreeNode@?$CList@NN@@IAEXPAUCNode@1@@Z		; CList<double,double>::FreeNode
PUBLIC	??1?$CList@NN@@UAE@XZ				; CList<double,double>::~CList<double,double>
PUBLIC	?Serialize@?$CList@NN@@UAEXAAVCArchive@@@Z	; CList<double,double>::Serialize
PUBLIC	??_G?$CList@NN@@UAEPAXI@Z			; CList<double,double>::`scalar deleting destructor'
PUBLIC	??$SerializeElements@N@@YGXAAVCArchive@@PANH@Z	; SerializeElements<double>
PUBLIC	??_R0?AVCObject@@@8				; CObject `RTTI Type Descriptor'
PUBLIC	??_R3CObject@@8					; CObject::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CObject@@8					; CObject::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CObject@@8			; CObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_7?$CList@NN@@6B@				; CList<double,double>::`vftable'
PUBLIC	??_C@_02PCIJFNDE@?$AN?6@			; `string'
PUBLIC	??_C@_03DKDLPDCL@?$CFd?$DL@			; `string'
PUBLIC	??_C@_01ICJEACDI@?$DL@				; `string'
PUBLIC	??_R4?$CList@NN@@6B@				; CList<double,double>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CList@NN@@@8				; CList<double,double> `RTTI Type Descriptor'
PUBLIC	??_R3?$CList@NN@@8				; CList<double,double>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CList@NN@@8				; CList<double,double>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CList@NN@@8			; CList<double,double>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@0000000000000000
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	?__global_delete@@YAXPAXI@Z:PROC		; __global_delete
EXTRN	___std_terminate:PROC
EXTRN	__imp__PtInRect@12:PROC
EXTRN	__imp__atoi:PROC
EXTRN	?AfxThrowInvalidArgException@@YGXXZ:PROC	; AfxThrowInvalidArgException
EXTRN	?AfxThrowArchiveException@@YGXHPBD@Z:PROC	; AfxThrowArchiveException
EXTRN	?GetRuntimeClass@CObject@@UBEPAUCRuntimeClass@@XZ:PROC ; CObject::GetRuntimeClass
EXTRN	__imp_?Concatenate@?$CSimpleStringT@D$00@ATL@@KAXAAV12@PBDH1H@Z:PROC
EXTRN	__imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ:PROC
EXTRN	__imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PAUIAtlStringMgr@1@@Z:PROC
EXTRN	__imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z:PROC
EXTRN	__imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z:PROC
EXTRN	__imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ:PROC
EXTRN	__imp_??Y?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV?$CSimpleStringT@D$00@1@@Z:PROC
EXTRN	__imp_?GetManager@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEPAUIAtlStringMgr@2@XZ:PROC
EXTRN	__imp_?Format@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAAXPBDZZ:PROC
EXTRN	?Read@CArchive@@QAEIPAXI@Z:PROC			; CArchive::Read
EXTRN	?Write@CArchive@@QAEXPBXI@Z:PROC		; CArchive::Write
EXTRN	?ReadCount@CArchive@@QAEKXZ:PROC		; CArchive::ReadCount
EXTRN	?WriteCount@CArchive@@QAEXK@Z:PROC		; CArchive::WriteCount
EXTRN	?Create@CPlex@@SGPAU1@AAPAU1@II@Z:PROC		; CPlex::Create
EXTRN	?FreeDataChain@CPlex@@QAEXXZ:PROC		; CPlex::FreeDataChain
EXTRN	?Round@CMath@@SAHN@Z:PROC			; CMath::Round
EXTRN	?GetMidToTrimDataIndex@CDataConversion@@SA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@ABV23@0H_N@Z:PROC ; CDataConversion::GetMidToTrimDataIndex
EXTRN	?GetStringDataCount@CDataConversion@@SAHABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@0@Z:PROC ; CDataConversion::GetStringDataCount
EXTRN	??_E?$CList@NN@@UAEPAXI@Z:PROC			; CList<double,double>::`vector deleting destructor'
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CList@NN@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CList@NN@@8 DD FLAT:??_R0?AV?$CList@NN@@@8 ; CList<double,double>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CList@NN@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CList@NN@@8
rdata$r	SEGMENT
??_R2?$CList@NN@@8 DD FLAT:??_R1A@?0A@EA@?$CList@NN@@8	; CList<double,double>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CObject@@8
rdata$r	ENDS
;	COMDAT ??_R3?$CList@NN@@8
rdata$r	SEGMENT
??_R3?$CList@NN@@8 DD 00H				; CList<double,double>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$CList@NN@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CList@NN@@@8
data$rs	SEGMENT
??_R0?AV?$CList@NN@@@8 DD FLAT:??_7type_info@@6B@	; CList<double,double> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CList@NN@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CList@NN@@6B@
rdata$r	SEGMENT
??_R4?$CList@NN@@6B@ DD 00H				; CList<double,double>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CList@NN@@@8
	DD	FLAT:??_R3?$CList@NN@@8
rdata$r	ENDS
;	COMDAT ??_C@_01ICJEACDI@?$DL@
CONST	SEGMENT
??_C@_01ICJEACDI@?$DL@ DB ';', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03DKDLPDCL@?$CFd?$DL@
CONST	SEGMENT
??_C@_03DKDLPDCL@?$CFd?$DL@ DB '%d;', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02PCIJFNDE@?$AN?6@
CONST	SEGMENT
??_C@_02PCIJFNDE@?$AN?6@ DB 0dH, 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_7?$CList@NN@@6B@
CONST	SEGMENT
??_7?$CList@NN@@6B@ DD FLAT:??_R4?$CList@NN@@6B@	; CList<double,double>::`vftable'
	DD	FLAT:?GetRuntimeClass@CObject@@UBEPAUCRuntimeClass@@XZ
	DD	FLAT:??_E?$CList@NN@@UAEPAXI@Z
	DD	FLAT:?Serialize@?$CList@NN@@UAEXAAVCArchive@@@Z
	DD	FLAT:?AssertValid@CObject@@UBEXXZ
	DD	FLAT:?Dump@CObject@@UBEXAAVCDumpContext@@@Z
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@CObject@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CObject@@8 DD FLAT:??_R0?AVCObject@@@8	; CObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CObject@@8
rdata$r	ENDS
;	COMDAT ??_R2CObject@@8
rdata$r	SEGMENT
??_R2CObject@@8 DD FLAT:??_R1A@?0A@EA@CObject@@8	; CObject::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CObject@@8
rdata$r	SEGMENT
??_R3CObject@@8 DD 00H					; CObject::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CObject@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCObject@@@8
data$rs	SEGMENT
??_R0?AVCObject@@@8 DD FLAT:??_7type_info@@6B@		; CObject `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCObject@@', 00H
data$rs	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_G?$CList@NN@@UAEPAXI@Z DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??_G?$CList@NN@@UAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_G?$CList@NN@@UAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CList@NN@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?GetBlocksPosition@CBlocksPositionCalculator@@CA_NABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAV?$CList@NN@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetBlocksPosition@CBlocksPositionCalculator@@CA_NABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAV?$CList@NN@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?GetBlocksPosition@CBlocksPositionCalculator@@CA_NABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAV?$CList@NN@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?GetBlocksPosition@CBlocksPositionCalculator@@CA_NABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAV?$CList@NN@@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?GetBlocksPosition@CBlocksPositionCalculator@@CA_NABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAV?$CList@NN@@@Z$2
__ehfuncinfo$?GetBlocksPosition@CBlocksPositionCalculator@@CA_NABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAV?$CList@NN@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?GetBlocksPosition@CBlocksPositionCalculator@@CA_NABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAV?$CList@NN@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?MoveBlockPosition@CBlocksPositionCalculator@@SA_NAAV?$CList@NN@@HH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?MoveBlockPosition@CBlocksPositionCalculator@@SA_NAAV?$CList@NN@@HH@Z$0
	DD	0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$?MoveBlockPosition@CBlocksPositionCalculator@@SA_NAAV?$CList@NN@@HH@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?MoveBlockPosition@CBlocksPositionCalculator@@SA_NAAV?$CList@NN@@HH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?GetSavedPosition@CBlocksPositionCalculator@@SA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@ABV?$CList@NN@@ABV23@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetSavedPosition@CBlocksPositionCalculator@@SA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@ABV?$CList@NN@@ABV23@@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?GetSavedPosition@CBlocksPositionCalculator@@SA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@ABV?$CList@NN@@ABV23@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?GetSavedPosition@CBlocksPositionCalculator@@SA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@ABV?$CList@NN@@ABV23@@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$?GetSavedPosition@CBlocksPositionCalculator@@SA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@ABV?$CList@NN@@ABV23@@Z$4
__ehfuncinfo$?GetSavedPosition@CBlocksPositionCalculator@@SA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@ABV?$CList@NN@@ABV23@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?GetSavedPosition@CBlocksPositionCalculator@@SA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@ABV?$CList@NN@@ABV23@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?SetBlocksPosition@CBlocksPositionCalculator@@SAXAAV?$CList@NN@@HABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SetBlocksPosition@CBlocksPositionCalculator@@SAXAAV?$CList@NN@@HABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z$0
	DD	0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$?SetBlocksPosition@CBlocksPositionCalculator@@SAXAAV?$CList@NN@@HABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?SetBlocksPosition@CBlocksPositionCalculator@@SAXAAV?$CList@NN@@HABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@ABV10@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@ABV10@PBD@Z$0
__ehfuncinfo$??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@ABV10@PBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@ABV10@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ??$SerializeElements@N@@YGXAAVCArchive@@PANH@Z
_TEXT	SEGMENT
_ar$ = 8						; size = 4
_pElements$ = 12					; size = 4
_nCount$ = 16						; size = 4
??$SerializeElements@N@@YGXAAVCArchive@@PANH@Z PROC	; SerializeElements<double>, COMDAT

; 67   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 68   : 	ENSURE(nCount == 0 || pElements != NULL);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR _pElements$[ebp]
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b 75 10	 mov	 esi, DWORD PTR _nCount$[ebp]
  0000b	57		 push	 edi
  0000c	85 f6		 test	 esi, esi
  0000e	74 08		 je	 SHORT $LN2@SerializeE
  00010	85 c9		 test	 ecx, ecx
  00012	0f 84 89 00 00
	00		 je	 $LN34@SerializeE
$LN2@SerializeE:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 212  : 	{ return (m_nMode & CArchive::load) == 0; }

  00018	8b 55 08	 mov	 edx, DWORD PTR _ar$[ebp]
  0001b	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0001e	f7 d0		 not	 eax
  00020	a8 01		 test	 al, 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 73   : 	if (ar.IsStoring())

  00022	74 3c		 je	 SHORT $LN10@SerializeE

; 74   : 	{
; 75   : 		TYPE* pData;
; 76   : 		UINT_PTR nElementsLeft;
; 77   : 
; 78   : 		nElementsLeft = nCount;
; 79   : 		pData = pElements;
; 80   : 		while( nElementsLeft > 0 )

  00024	85 f6		 test	 esi, esi
  00026	74 31		 je	 SHORT $LN8@SerializeE
  00028	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL5@SerializeE:

; 81   : 		{
; 82   : 			UINT nElementsToWrite;
; 83   : 
; 84   : 			nElementsToWrite = UINT(__min(nElementsLeft, INT_MAX/sizeof(TYPE)));

  00030	bb ff ff ff 0f	 mov	 ebx, 268435455		; 0fffffffH
  00035	3b f3		 cmp	 esi, ebx
  00037	0f 42 de	 cmovb	 ebx, esi

; 85   : 			ar.Write(pData, nElementsToWrite*sizeof(TYPE));

  0003a	8d 3c dd 00 00
	00 00		 lea	 edi, DWORD PTR [ebx*8]
  00041	57		 push	 edi
  00042	51		 push	 ecx
  00043	8b ca		 mov	 ecx, edx
  00045	e8 00 00 00 00	 call	 ?Write@CArchive@@QAEXPBXI@Z ; CArchive::Write

; 86   : 			nElementsLeft -= nElementsToWrite;
; 87   : 			pData += nElementsToWrite;

  0004a	8b 4d 0c	 mov	 ecx, DWORD PTR _pElements$[ebp]
  0004d	8b 55 08	 mov	 edx, DWORD PTR _ar$[ebp]
  00050	03 cf		 add	 ecx, edi
  00052	89 4d 0c	 mov	 DWORD PTR _pElements$[ebp], ecx
  00055	2b f3		 sub	 esi, ebx
  00057	75 d7		 jne	 SHORT $LL5@SerializeE
$LN8@SerializeE:
  00059	5f		 pop	 edi

; 105  : 		}
; 106  : 	}
; 107  : }

  0005a	5e		 pop	 esi
  0005b	5b		 pop	 ebx
  0005c	5d		 pop	 ebp
  0005d	c2 0c 00	 ret	 12			; 0000000cH
$LN10@SerializeE:

; 97   : 		while( nElementsLeft > 0 )

  00060	85 f6		 test	 esi, esi
  00062	74 f5		 je	 SHORT $LN8@SerializeE
$LL7@SerializeE:

; 98   : 		{
; 99   : 			UINT nElementsToRead;
; 100  : 
; 101  : 			nElementsToRead = UINT(__min(nElementsLeft, INT_MAX/sizeof(TYPE)));

  00064	bf ff ff ff 0f	 mov	 edi, 268435455		; 0fffffffH
  00069	3b f7		 cmp	 esi, edi
  0006b	0f 42 fe	 cmovb	 edi, esi

; 102  : 			ar.EnsureRead(pData, nElementsToRead*sizeof(TYPE));

  0006e	8d 1c fd 00 00
	00 00		 lea	 ebx, DWORD PTR [edi*8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 399  : 	UINT nRead=Read(lpBuf, nCount);

  00075	53		 push	 ebx
  00076	51		 push	 ecx
  00077	8b ca		 mov	 ecx, edx
  00079	e8 00 00 00 00	 call	 ?Read@CArchive@@QAEIPAXI@Z ; CArchive::Read

; 400  : 	if(nRead!=nCount)

  0007e	3b c3		 cmp	 eax, ebx
  00080	75 16		 jne	 SHORT $LN23@SerializeE
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 97   : 		while( nElementsLeft > 0 )

  00082	8b 4d 0c	 mov	 ecx, DWORD PTR _pElements$[ebp]
  00085	8b 55 08	 mov	 edx, DWORD PTR _ar$[ebp]

; 103  : 			nElementsLeft -= nElementsToRead;
; 104  : 			pData += nElementsToRead;

  00088	03 cb		 add	 ecx, ebx
  0008a	89 4d 0c	 mov	 DWORD PTR _pElements$[ebp], ecx
  0008d	2b f7		 sub	 esi, edi
  0008f	75 d3		 jne	 SHORT $LL7@SerializeE

; 105  : 		}
; 106  : 	}
; 107  : }

  00091	5f		 pop	 edi
  00092	5e		 pop	 esi
  00093	5b		 pop	 ebx
  00094	5d		 pop	 ebp
  00095	c2 0c 00	 ret	 12			; 0000000cH
$LN23@SerializeE:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 402  : 		AfxThrowArchiveException(CArchiveException::endOfFile);

  00098	6a 00		 push	 0
  0009a	6a 03		 push	 3
  0009c	e8 00 00 00 00	 call	 ?AfxThrowArchiveException@@YGXHPBD@Z ; AfxThrowArchiveException
$LN34@SerializeE:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 68   : 	ENSURE(nCount == 0 || pElements != NULL);

  000a1	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN32@SerializeE:
  000a6	cc		 int	 3
??$SerializeElements@N@@YGXAAVCArchive@@PANH@Z ENDP	; SerializeElements<double>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
;	COMDAT ??_G?$CList@NN@@UAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_G?$CList@NN@@UAEPAXI@Z PROC				; CList<double,double>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_G?$CList@NN@@UAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 872  : 	m_pBlocks->FreeDataChain();

  00025	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]

; 878  : {

  00028	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0002f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CList@NN@@6B@

; 870  : 	m_nCount = 0;

  00035	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0

; 871  : 	m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;

  0003c	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00043	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  0004a	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 872  : 	m_pBlocks->FreeDataChain();

  00051	e8 00 00 00 00	 call	 ?FreeDataChain@CPlex@@QAEXXZ ; CPlex::FreeDataChain

; 873  : 	m_pBlocks = NULL;

  00056	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00059	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
  00060	a8 01		 test	 al, 1
  00062	74 2c		 je	 SHORT $LN22@scalar
  00064	a8 04		 test	 al, 4
  00066	75 1d		 jne	 SHORT $LN3@scalar
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 112  : 	{ ::operator delete(p); }

  00068	56		 push	 esi
  00069	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0006e	83 c4 04	 add	 esp, 4
  00071	8b c6		 mov	 eax, esi
  00073	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00076	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007d	59		 pop	 ecx
  0007e	5e		 pop	 esi
  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c2 04 00	 ret	 4
$LN3@scalar:
  00085	6a 1c		 push	 28			; 0000001cH
  00087	56		 push	 esi
  00088	e8 00 00 00 00	 call	 ?__global_delete@@YAXPAXI@Z ; __global_delete
  0008d	83 c4 08	 add	 esp, 8
$LN22@scalar:
  00090	8b c6		 mov	 eax, esi
  00092	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00095	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0009c	59		 pop	 ecx
  0009d	5e		 pop	 esi
  0009e	8b e5		 mov	 esp, ebp
  000a0	5d		 pop	 ebp
  000a1	c2 04 00	 ret	 4
  000a4	cc		 int	 3
  000a5	cc		 int	 3
  000a6	cc		 int	 3
  000a7	cc		 int	 3
  000a8	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??_G?$CList@NN@@UAEPAXI@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_G?$CList@NN@@UAEPAXI@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_G?$CList@NN@@UAEPAXI@Z ENDP				; CList<double,double>::`scalar deleting destructor'
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ?Serialize@?$CList@NN@@UAEXAAVCArchive@@@Z
_TEXT	SEGMENT
_newData$1 = -24					; size = 8
_nNewCount$1$ = -16					; size = 4
_newElement$1$ = -12					; size = 8
_pData$1$ = -8						; size = 4
_pData$1$ = -8						; size = 4
_pNode$1$ = -8						; size = 4
_nElementsLeft$1$ = -4					; size = 4
_this$1$ = -4						; size = 4
_ar$ = 8						; size = 4
?Serialize@?$CList@NN@@UAEXAAVCArchive@@@Z PROC		; CList<double,double>::Serialize, COMDAT
; _this$ = ecx

; 1169 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	53		 push	 ebx
  00007	8b d9		 mov	 ebx, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 212  : 	{ return (m_nMode & CArchive::load) == 0; }

  00009	8b 4d 08	 mov	 ecx, DWORD PTR _ar$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 1169 : {

  0000c	56		 push	 esi
  0000d	57		 push	 edi
  0000e	89 5d fc	 mov	 DWORD PTR _this$1$[ebp], ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 212  : 	{ return (m_nMode & CArchive::load) == 0; }

  00011	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  00014	f7 d0		 not	 eax
  00016	a8 01		 test	 al, 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 1174 : 	if (ar.IsStoring())

  00018	0f 84 ae 00 00
	00		 je	 $LN7@Serialize

; 1175 : 	{
; 1176 : 		ar.WriteCount(m_nCount);

  0001e	ff 73 0c	 push	 DWORD PTR [ebx+12]
  00021	e8 00 00 00 00	 call	 ?WriteCount@CArchive@@QAEXK@Z ; CArchive::WriteCount

; 1177 : 		for (CNode* pNode = m_pNodeHead; pNode != NULL; pNode = pNode->pNext)

  00026	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00029	89 45 f8	 mov	 DWORD PTR _pNode$1$[ebp], eax
  0002c	85 c0		 test	 eax, eax
  0002e	0f 84 ca 01 00
	00		 je	 $LN86@Serialize
$LL4@Serialize:

; 1178 : 		{
; 1179 : 			ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 1180 : 			TYPE* pData;
; 1181 : 			/*
; 1182 : 			 * in some cases the & operator might be overloaded, and we cannot use it to obtain
; 1183 : 			 * the address of a given object.  We then use the following trick to get the address
; 1184 : 			 */
; 1185 : 			pData = reinterpret_cast< TYPE* >( &reinterpret_cast< int& >( static_cast< TYPE& >( pNode->data ) ) );

  00034	8d 58 08	 lea	 ebx, DWORD PTR [eax+8]

; 68   : 	ENSURE(nCount == 0 || pElements != NULL);

  00037	85 db		 test	 ebx, ebx
  00039	0f 84 d1 01 00
	00		 je	 $LN76@Serialize
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 212  : 	{ return (m_nMode & CArchive::load) == 0; }

  0003f	8b 4d 08	 mov	 ecx, DWORD PTR _ar$[ebp]
  00042	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  00045	f7 d0		 not	 eax
  00047	a8 01		 test	 al, 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 73   : 	if (ar.IsStoring())

  00049	74 33		 je	 SHORT $LN21@Serialize

; 74   : 	{
; 75   : 		TYPE* pData;
; 76   : 		UINT_PTR nElementsLeft;
; 77   : 
; 78   : 		nElementsLeft = nCount;

  0004b	b8 01 00 00 00	 mov	 eax, 1
  00050	89 45 fc	 mov	 DWORD PTR _nElementsLeft$1$[ebp], eax
$LL16@Serialize:

; 80   : 		while( nElementsLeft > 0 )
; 81   : 		{
; 82   : 			UINT nElementsToWrite;
; 83   : 
; 84   : 			nElementsToWrite = UINT(__min(nElementsLeft, INT_MAX/sizeof(TYPE)));

  00053	bf ff ff ff 0f	 mov	 edi, 268435455		; 0fffffffH
  00058	3b c7		 cmp	 eax, edi
  0005a	0f 42 f8	 cmovb	 edi, eax

; 85   : 			ar.Write(pData, nElementsToWrite*sizeof(TYPE));

  0005d	8d 34 fd 00 00
	00 00		 lea	 esi, DWORD PTR [edi*8]
  00064	56		 push	 esi
  00065	53		 push	 ebx
  00066	e8 00 00 00 00	 call	 ?Write@CArchive@@QAEXPBXI@Z ; CArchive::Write

; 86   : 			nElementsLeft -= nElementsToWrite;

  0006b	8b 45 fc	 mov	 eax, DWORD PTR _nElementsLeft$1$[ebp]

; 87   : 			pData += nElementsToWrite;

  0006e	03 de		 add	 ebx, esi
  00070	8b 4d 08	 mov	 ecx, DWORD PTR _ar$[ebp]
  00073	2b c7		 sub	 eax, edi
  00075	89 45 fc	 mov	 DWORD PTR _nElementsLeft$1$[ebp], eax
  00078	85 c0		 test	 eax, eax
  0007a	75 d7		 jne	 SHORT $LL16@Serialize

; 88   : 		}
; 89   : 	}

  0007c	eb 35		 jmp	 SHORT $LN2@Serialize
$LN21@Serialize:

; 90   : 	else
; 91   : 	{
; 92   : 		TYPE* pData;
; 93   : 		UINT_PTR nElementsLeft;
; 94   : 
; 95   : 		nElementsLeft = nCount;

  0007e	be 01 00 00 00	 mov	 esi, 1
$LL18@Serialize:

; 98   : 		{
; 99   : 			UINT nElementsToRead;
; 100  : 
; 101  : 			nElementsToRead = UINT(__min(nElementsLeft, INT_MAX/sizeof(TYPE)));

  00083	bf ff ff ff 0f	 mov	 edi, 268435455		; 0fffffffH
  00088	3b f7		 cmp	 esi, edi
  0008a	0f 42 fe	 cmovb	 edi, esi

; 102  : 			ar.EnsureRead(pData, nElementsToRead*sizeof(TYPE));

  0008d	8d 04 fd 00 00
	00 00		 lea	 eax, DWORD PTR [edi*8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 399  : 	UINT nRead=Read(lpBuf, nCount);

  00094	50		 push	 eax
  00095	53		 push	 ebx
  00096	e8 00 00 00 00	 call	 ?Read@CArchive@@QAEIPAXI@Z ; CArchive::Read

; 400  : 	if(nRead!=nCount)

  0009b	8d 0c fd 00 00
	00 00		 lea	 ecx, DWORD PTR [edi*8]
  000a2	3b c1		 cmp	 eax, ecx
  000a4	0f 85 5d 01 00
	00		 jne	 $LN75@Serialize
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 97   : 		while( nElementsLeft > 0 )

  000aa	03 d9		 add	 ebx, ecx
  000ac	8b 4d 08	 mov	 ecx, DWORD PTR _ar$[ebp]

; 103  : 			nElementsLeft -= nElementsToRead;

  000af	2b f7		 sub	 esi, edi
  000b1	75 d0		 jne	 SHORT $LL18@Serialize
$LN2@Serialize:

; 1177 : 		for (CNode* pNode = m_pNodeHead; pNode != NULL; pNode = pNode->pNext)

  000b3	8b 45 f8	 mov	 eax, DWORD PTR _pNode$1$[ebp]
  000b6	8b 00		 mov	 eax, DWORD PTR [eax]
  000b8	89 45 f8	 mov	 DWORD PTR _pNode$1$[ebp], eax
  000bb	85 c0		 test	 eax, eax
  000bd	0f 85 71 ff ff
	ff		 jne	 $LL4@Serialize

; 1197 : 		}
; 1198 : 	}
; 1199 : }

  000c3	5f		 pop	 edi
  000c4	5e		 pop	 esi
  000c5	5b		 pop	 ebx
  000c6	8b e5		 mov	 esp, ebp
  000c8	5d		 pop	 ebp
  000c9	c2 04 00	 ret	 4
$LN7@Serialize:

; 1186 : 			SerializeElements<TYPE>(ar, pData, 1);
; 1187 : 		}
; 1188 : 	}
; 1189 : 	else
; 1190 : 	{
; 1191 : 		DWORD_PTR nNewCount = ar.ReadCount();

  000cc	e8 00 00 00 00	 call	 ?ReadCount@CArchive@@QAEKXZ ; CArchive::ReadCount

; 1192 : 		while (nNewCount--)

  000d1	85 c0		 test	 eax, eax
  000d3	0f 84 25 01 00
	00		 je	 $LN86@Serialize
  000d9	0f 1f 80 00 00
	00 00		 npad	 7
$LL5@Serialize:
  000e0	48		 dec	 eax
  000e1	89 45 f0	 mov	 DWORD PTR _nNewCount$1$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 212  : 	{ return (m_nMode & CArchive::load) == 0; }

  000e4	8b 45 08	 mov	 eax, DWORD PTR _ar$[ebp]
  000e7	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  000ea	f7 d1		 not	 ecx
  000ec	f6 c1 01	 test	 cl, 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 73   : 	if (ar.IsStoring())

  000ef	74 3d		 je	 SHORT $LN42@Serialize

; 79   : 		pData = pElements;

  000f1	8d 4d e8	 lea	 ecx, DWORD PTR _newData$1[ebp]
  000f4	bb 01 00 00 00	 mov	 ebx, 1
  000f9	89 4d f8	 mov	 DWORD PTR _pData$1$[ebp], ecx
  000fc	0f 1f 40 00	 npad	 4
$LL37@Serialize:

; 80   : 		while( nElementsLeft > 0 )
; 81   : 		{
; 82   : 			UINT nElementsToWrite;
; 83   : 
; 84   : 			nElementsToWrite = UINT(__min(nElementsLeft, INT_MAX/sizeof(TYPE)));

  00100	bf ff ff ff 0f	 mov	 edi, 268435455		; 0fffffffH
  00105	3b df		 cmp	 ebx, edi
  00107	0f 42 fb	 cmovb	 edi, ebx

; 85   : 			ar.Write(pData, nElementsToWrite*sizeof(TYPE));

  0010a	8d 34 fd 00 00
	00 00		 lea	 esi, DWORD PTR [edi*8]
  00111	56		 push	 esi
  00112	51		 push	 ecx
  00113	8b c8		 mov	 ecx, eax
  00115	e8 00 00 00 00	 call	 ?Write@CArchive@@QAEXPBXI@Z ; CArchive::Write

; 87   : 			pData += nElementsToWrite;

  0011a	8b 4d f8	 mov	 ecx, DWORD PTR _pData$1$[ebp]
  0011d	8b 45 08	 mov	 eax, DWORD PTR _ar$[ebp]
  00120	03 ce		 add	 ecx, esi
  00122	89 4d f8	 mov	 DWORD PTR _pData$1$[ebp], ecx
  00125	2b df		 sub	 ebx, edi
  00127	75 d7		 jne	 SHORT $LL37@Serialize

; 88   : 		}
; 89   : 	}

  00129	8b 5d fc	 mov	 ebx, DWORD PTR _this$1$[ebp]
  0012c	eb 4a		 jmp	 SHORT $LN40@Serialize
$LN42@Serialize:

; 96   : 		pData = pElements;

  0012e	8d 55 e8	 lea	 edx, DWORD PTR _newData$1[ebp]
  00131	be 01 00 00 00	 mov	 esi, 1
  00136	89 55 f8	 mov	 DWORD PTR _pData$1$[ebp], edx
  00139	0f 1f 80 00 00
	00 00		 npad	 7
$LL39@Serialize:

; 98   : 		{
; 99   : 			UINT nElementsToRead;
; 100  : 
; 101  : 			nElementsToRead = UINT(__min(nElementsLeft, INT_MAX/sizeof(TYPE)));

  00140	bf ff ff ff 0f	 mov	 edi, 268435455		; 0fffffffH
  00145	3b f7		 cmp	 esi, edi
  00147	0f 42 fe	 cmovb	 edi, esi

; 102  : 			ar.EnsureRead(pData, nElementsToRead*sizeof(TYPE));

  0014a	8d 0c fd 00 00
	00 00		 lea	 ecx, DWORD PTR [edi*8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 399  : 	UINT nRead=Read(lpBuf, nCount);

  00151	51		 push	 ecx
  00152	52		 push	 edx
  00153	8b c8		 mov	 ecx, eax
  00155	e8 00 00 00 00	 call	 ?Read@CArchive@@QAEIPAXI@Z ; CArchive::Read

; 400  : 	if(nRead!=nCount)

  0015a	8d 0c fd 00 00
	00 00		 lea	 ecx, DWORD PTR [edi*8]
  00161	3b c1		 cmp	 eax, ecx
  00163	0f 85 9e 00 00
	00		 jne	 $LN75@Serialize
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 97   : 		while( nElementsLeft > 0 )

  00169	8b 55 f8	 mov	 edx, DWORD PTR _pData$1$[ebp]
  0016c	8b 45 08	 mov	 eax, DWORD PTR _ar$[ebp]

; 104  : 			pData += nElementsToRead;

  0016f	03 d1		 add	 edx, ecx
  00171	89 55 f8	 mov	 DWORD PTR _pData$1$[ebp], edx
  00174	2b f7		 sub	 esi, edi
  00176	75 c8		 jne	 SHORT $LL39@Serialize
$LN40@Serialize:

; 902  : 	if (m_pNodeFree == NULL)

  00178	83 7b 10 00	 cmp	 DWORD PTR [ebx+16], 0

; 1193 : 		{
; 1194 : 			TYPE newData[1];
; 1195 : 			SerializeElements<TYPE>(ar, newData, 1);
; 1196 : 			AddTail(newData[0]);

  0017c	f2 0f 10 45 e8	 movsd	 xmm0, QWORD PTR _newData$1[ebp]

; 968  : 	CNode* pNewNode = NewNode(m_pNodeTail, NULL);

  00181	8b 73 08	 mov	 esi, DWORD PTR [ebx+8]

; 1193 : 		{
; 1194 : 			TYPE newData[1];
; 1195 : 			SerializeElements<TYPE>(ar, newData, 1);
; 1196 : 			AddTail(newData[0]);

  00184	f2 0f 11 45 f4	 movsd	 QWORD PTR _newElement$1$[ebp], xmm0

; 902  : 	if (m_pNodeFree == NULL)

  00189	75 3a		 jne	 SHORT $LN63@Serialize

; 903  : 	{
; 904  : 		// add another block
; 905  : 		CPlex* pNewBlock = CPlex::Create(m_pBlocks, m_nBlockSize,

  0018b	6a 10		 push	 16			; 00000010H
  0018d	ff 73 18	 push	 DWORD PTR [ebx+24]
  00190	8d 43 14	 lea	 eax, DWORD PTR [ebx+20]
  00193	50		 push	 eax
  00194	e8 00 00 00 00	 call	 ?Create@CPlex@@SGPAU1@AAPAU1@II@Z ; CPlex::Create

; 906  : 				 sizeof(CNode));
; 907  : 
; 908  : 		// chain them into free list
; 909  : 		CNode* pNode = (CNode*) pNewBlock->data();
; 910  : 		// free in reverse order to make it easier to debug
; 911  : 		pNode += m_nBlockSize - 1;

  00199	8b 53 18	 mov	 edx, DWORD PTR [ebx+24]
  0019c	83 c0 08	 add	 eax, 8
  0019f	8b ca		 mov	 ecx, edx
  001a1	c1 e1 04	 shl	 ecx, 4
  001a4	83 c1 f0	 add	 ecx, -16		; fffffff0H
  001a7	03 c8		 add	 ecx, eax

; 912  : 		for (INT_PTR i = m_nBlockSize-1; i >= 0; i--, pNode--)

  001a9	83 c2 ff	 add	 edx, -1
  001ac	78 12		 js	 SHORT $LN105@Serialize
  001ae	66 90		 npad	 2
$LL60@Serialize:

; 913  : 		{
; 914  : 			pNode->pNext = m_pNodeFree;

  001b0	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  001b3	89 01		 mov	 DWORD PTR [ecx], eax

; 915  : 			m_pNodeFree = pNode;

  001b5	89 4b 10	 mov	 DWORD PTR [ebx+16], ecx
  001b8	83 e9 10	 sub	 ecx, 16			; 00000010H
  001bb	83 ea 01	 sub	 edx, 1
  001be	79 f0		 jns	 SHORT $LL60@Serialize
$LN105@Serialize:

; 916  : 		}
; 917  : 	}
; 918  : 	ENSURE(m_pNodeFree != NULL);  // we must have something

  001c0	f2 0f 10 45 f4	 movsd	 xmm0, QWORD PTR _newElement$1$[ebp]
$LN63@Serialize:
  001c5	8b 4b 10	 mov	 ecx, DWORD PTR [ebx+16]
  001c8	85 c9		 test	 ecx, ecx
  001ca	74 44		 je	 SHORT $LN76@Serialize

; 919  : 
; 920  : 	CList::CNode* pNode = m_pNodeFree;
; 921  : 	m_pNodeFree = m_pNodeFree->pNext;

  001cc	8b 01		 mov	 eax, DWORD PTR [ecx]
  001ce	89 43 10	 mov	 DWORD PTR [ebx+16], eax

; 922  : 	pNode->pPrev = pPrev;

  001d1	89 71 04	 mov	 DWORD PTR [ecx+4], esi

; 923  : 	pNode->pNext = pNext;

  001d4	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 924  : 	m_nCount++;

  001da	ff 43 0c	 inc	 DWORD PTR [ebx+12]

; 969  : 	pNewNode->data = newElement;

  001dd	f2 0f 11 41 08	 movsd	 QWORD PTR [ecx+8], xmm0

; 970  : 	if (m_pNodeTail != NULL)

  001e2	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  001e5	85 c0		 test	 eax, eax
  001e7	74 04		 je	 SHORT $LN54@Serialize

; 971  : 		m_pNodeTail->pNext = pNewNode;

  001e9	89 08		 mov	 DWORD PTR [eax], ecx
  001eb	eb 03		 jmp	 SHORT $LN55@Serialize
$LN54@Serialize:

; 972  : 	else
; 973  : 		m_pNodeHead = pNewNode;

  001ed	89 4b 04	 mov	 DWORD PTR [ebx+4], ecx
$LN55@Serialize:

; 1192 : 		while (nNewCount--)

  001f0	8b 45 f0	 mov	 eax, DWORD PTR _nNewCount$1$[ebp]

; 974  : 	m_pNodeTail = pNewNode;

  001f3	89 4b 08	 mov	 DWORD PTR [ebx+8], ecx

; 1192 : 		while (nNewCount--)

  001f6	85 c0		 test	 eax, eax
  001f8	0f 85 e2 fe ff
	ff		 jne	 $LL5@Serialize
$LN86@Serialize:
  001fe	5f		 pop	 edi

; 1197 : 		}
; 1198 : 	}
; 1199 : }

  001ff	5e		 pop	 esi
  00200	5b		 pop	 ebx
  00201	8b e5		 mov	 esp, ebp
  00203	5d		 pop	 ebp
  00204	c2 04 00	 ret	 4
$LN75@Serialize:
  00207	6a 00		 push	 0
  00209	6a 03		 push	 3
  0020b	e8 00 00 00 00	 call	 ?AfxThrowArchiveException@@YGXHPBD@Z ; AfxThrowArchiveException
$LN76@Serialize:
  00210	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN106@Serialize:
  00215	cc		 int	 3
?Serialize@?$CList@NN@@UAEXAAVCArchive@@@Z ENDP		; CList<double,double>::Serialize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ??1?$CList@NN@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$CList@NN@@UAE@XZ PROC				; CList<double,double>::~CList<double,double>, COMDAT
; _this$ = ecx

; 878  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$CList@NN@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx

; 872  : 	m_pBlocks->FreeDataChain();

  00025	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]

; 878  : {

  00028	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CList@NN@@6B@

; 870  : 	m_nCount = 0;

  0002e	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0

; 871  : 	m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;

  00035	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0003c	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00043	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 872  : 	m_pBlocks->FreeDataChain();

  0004a	e8 00 00 00 00	 call	 ?FreeDataChain@CPlex@@QAEXXZ ; CPlex::FreeDataChain

; 873  : 	m_pBlocks = NULL;

  0004f	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 879  : 	RemoveAll();
; 880  : 	ASSERT(m_nCount == 0);
; 881  : }

  00056	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00059	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00060	59		 pop	 ecx
  00061	5e		 pop	 esi
  00062	8b e5		 mov	 esp, ebp
  00064	5d		 pop	 ebp
  00065	c3		 ret	 0
  00066	cc		 int	 3
  00067	cc		 int	 3
  00068	cc		 int	 3
  00069	cc		 int	 3
  0006a	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CList@NN@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$CList@NN@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$CList@NN@@UAE@XZ ENDP				; CList<double,double>::~CList<double,double>
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ?FreeNode@?$CList@NN@@IAEXPAUCNode@1@@Z
_TEXT	SEGMENT
_pNode$ = 8						; size = 4
?FreeNode@?$CList@NN@@IAEXPAUCNode@1@@Z PROC		; CList<double,double>::FreeNode, COMDAT
; _this$ = ecx

; 936  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 937  : 	pNode->data.~TYPE();
; 938  : 	pNode->pNext = m_pNodeFree;

  00003	8b 55 08	 mov	 edx, DWORD PTR _pNode$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0000c	89 02		 mov	 DWORD PTR [edx], eax

; 939  : 	m_pNodeFree = pNode;
; 940  : 	m_nCount--;

  0000e	83 46 0c ff	 add	 DWORD PTR [esi+12], -1
  00012	89 56 10	 mov	 DWORD PTR [esi+16], edx

; 941  : 	ASSERT(m_nCount >= 0);  // make sure we don't underflow
; 942  : 
; 943  : 	// if no more elements, cleanup completely
; 944  : 	if (m_nCount == 0)

  00015	75 2b		 jne	 SHORT $LN2@FreeNode

; 872  : 	m_pBlocks->FreeDataChain();

  00017	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  0001a	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  00021	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00028	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  0002f	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00036	e8 00 00 00 00	 call	 ?FreeDataChain@CPlex@@QAEXXZ ; CPlex::FreeDataChain

; 873  : 	m_pBlocks = NULL;

  0003b	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
$LN2@FreeNode:
  00042	5e		 pop	 esi

; 945  : 		RemoveAll();
; 946  : }

  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
?FreeNode@?$CList@NN@@IAEXPAUCNode@1@@Z ENDP		; CList<double,double>::FreeNode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ?NewNode@?$CList@NN@@IAEPAUCNode@1@PAU21@0@Z
_TEXT	SEGMENT
_pPrev$ = 8						; size = 4
_pNext$ = 12						; size = 4
?NewNode@?$CList@NN@@IAEPAUCNode@1@PAU21@0@Z PROC	; CList<double,double>::NewNode, COMDAT
; _this$ = ecx

; 901  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 902  : 	if (m_pNodeFree == NULL)

  00006	83 7e 10 00	 cmp	 DWORD PTR [esi+16], 0
  0000a	75 34		 jne	 SHORT $LN7@NewNode

; 903  : 	{
; 904  : 		// add another block
; 905  : 		CPlex* pNewBlock = CPlex::Create(m_pBlocks, m_nBlockSize,

  0000c	6a 10		 push	 16			; 00000010H
  0000e	ff 76 18	 push	 DWORD PTR [esi+24]
  00011	8d 46 14	 lea	 eax, DWORD PTR [esi+20]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ?Create@CPlex@@SGPAU1@AAPAU1@II@Z ; CPlex::Create

; 906  : 				 sizeof(CNode));
; 907  : 
; 908  : 		// chain them into free list
; 909  : 		CNode* pNode = (CNode*) pNewBlock->data();
; 910  : 		// free in reverse order to make it easier to debug
; 911  : 		pNode += m_nBlockSize - 1;

  0001a	8b 56 18	 mov	 edx, DWORD PTR [esi+24]
  0001d	83 c0 08	 add	 eax, 8
  00020	8b ca		 mov	 ecx, edx
  00022	c1 e1 04	 shl	 ecx, 4
  00025	83 c1 f0	 add	 ecx, -16		; fffffff0H
  00028	03 c1		 add	 eax, ecx

; 912  : 		for (INT_PTR i = m_nBlockSize-1; i >= 0; i--, pNode--)

  0002a	83 c2 ff	 add	 edx, -1
  0002d	78 11		 js	 SHORT $LN7@NewNode
  0002f	90		 npad	 1
$LL4@NewNode:

; 913  : 		{
; 914  : 			pNode->pNext = m_pNodeFree;

  00030	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00033	89 08		 mov	 DWORD PTR [eax], ecx

; 915  : 			m_pNodeFree = pNode;

  00035	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00038	83 e8 10	 sub	 eax, 16			; 00000010H
  0003b	83 ea 01	 sub	 edx, 1
  0003e	79 f0		 jns	 SHORT $LL4@NewNode
$LN7@NewNode:

; 916  : 		}
; 917  : 	}
; 918  : 	ENSURE(m_pNodeFree != NULL);  // we must have something

  00040	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00043	85 c0		 test	 eax, eax
  00045	74 18		 je	 SHORT $LN17@NewNode

; 919  : 
; 920  : 	CList::CNode* pNode = m_pNodeFree;
; 921  : 	m_pNodeFree = m_pNodeFree->pNext;

  00047	8b 08		 mov	 ecx, DWORD PTR [eax]
  00049	89 4e 10	 mov	 DWORD PTR [esi+16], ecx

; 922  : 	pNode->pPrev = pPrev;

  0004c	8b 4d 08	 mov	 ecx, DWORD PTR _pPrev$[ebp]
  0004f	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 923  : 	pNode->pNext = pNext;

  00052	8b 4d 0c	 mov	 ecx, DWORD PTR _pNext$[ebp]
  00055	89 08		 mov	 DWORD PTR [eax], ecx

; 924  : 	m_nCount++;

  00057	ff 46 0c	 inc	 DWORD PTR [esi+12]

; 925  : 	ASSERT(m_nCount > 0);  // make sure we don't overflow
; 926  : 
; 927  : #pragma push_macro("new")
; 928  : #undef new
; 929  : 	::new( (void*)( &pNode->data ) ) TYPE;
; 930  : #pragma pop_macro("new")
; 931  : 	return pNode;

  0005a	5e		 pop	 esi

; 932  : }

  0005b	5d		 pop	 ebp
  0005c	c2 08 00	 ret	 8
$LN17@NewNode:

; 916  : 		}
; 917  : 	}
; 918  : 	ENSURE(m_pNodeFree != NULL);  // we must have something

  0005f	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN15@NewNode:
  00064	cc		 int	 3
?NewNode@?$CList@NN@@IAEPAUCNode@1@PAU21@0@Z ENDP	; CList<double,double>::NewNode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ?FindIndex@?$CList@NN@@QBEPAU__POSITION@@H@Z
_TEXT	SEGMENT
_nIndex$ = 8						; size = 4
?FindIndex@?$CList@NN@@QBEPAU__POSITION@@H@Z PROC	; CList<double,double>::FindIndex, COMDAT
; _this$ = ecx

; 1130 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1131 : 	ASSERT_VALID(this);
; 1132 : 
; 1133 : 	if (nIndex >= m_nCount || nIndex < 0)

  00003	8b 55 08	 mov	 edx, DWORD PTR _nIndex$[ebp]
  00006	3b 51 0c	 cmp	 edx, DWORD PTR [ecx+12]
  00009	7d 14		 jge	 SHORT $LN5@FindIndex
  0000b	85 d2		 test	 edx, edx
  0000d	78 10		 js	 SHORT $LN5@FindIndex

; 1135 : 
; 1136 : 	CNode* pNode = m_pNodeHead;

  0000f	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 1137 : 	while (nIndex--)

  00012	74 0d		 je	 SHORT $LN1@FindIndex
$LL2@FindIndex:

; 1138 : 	{
; 1139 : 		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 1140 : 		pNode = pNode->pNext;

  00014	8b 00		 mov	 eax, DWORD PTR [eax]
  00016	83 ea 01	 sub	 edx, 1
  00019	75 f9		 jne	 SHORT $LL2@FindIndex

; 1141 : 	}
; 1142 : 	return (POSITION) pNode;
; 1143 : }

  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
$LN5@FindIndex:

; 1134 : 		return NULL;  // went too far

  0001f	33 c0		 xor	 eax, eax
$LN1@FindIndex:

; 1141 : 	}
; 1142 : 	return (POSITION) pNode;
; 1143 : }

  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
?FindIndex@?$CList@NN@@QBEPAU__POSITION@@H@Z ENDP	; CList<double,double>::FindIndex
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ?InsertAfter@?$CList@NN@@QAEPAU__POSITION@@PAU2@N@Z
_TEXT	SEGMENT
_position$ = 8						; size = 4
_newElement$ = 12					; size = 8
?InsertAfter@?$CList@NN@@QAEPAU__POSITION@@PAU2@N@Z PROC ; CList<double,double>::InsertAfter, COMDAT
; _this$ = ecx

; 1072 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 1073 : 	ASSERT_VALID(this);
; 1074 : 
; 1075 : 	if (position == NULL)

  00005	8b 7d 08	 mov	 edi, DWORD PTR _position$[ebp]
  00008	8b f1		 mov	 esi, ecx
  0000a	85 ff		 test	 edi, edi
  0000c	75 31		 jne	 SHORT $LN2@InsertAfte

; 968  : 	CNode* pNewNode = NewNode(m_pNodeTail, NULL);

  0000e	57		 push	 edi
  0000f	ff 76 08	 push	 DWORD PTR [esi+8]
  00012	e8 00 00 00 00	 call	 ?NewNode@?$CList@NN@@IAEPAUCNode@1@PAU21@0@Z ; CList<double,double>::NewNode

; 969  : 	pNewNode->data = newElement;

  00017	f2 0f 10 45 0c	 movsd	 xmm0, QWORD PTR _newElement$[ebp]
  0001c	f2 0f 11 40 08	 movsd	 QWORD PTR [eax+8], xmm0

; 970  : 	if (m_pNodeTail != NULL)

  00021	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00024	85 c9		 test	 ecx, ecx
  00026	74 0b		 je	 SHORT $LN7@InsertAfte

; 971  : 		m_pNodeTail->pNext = pNewNode;

  00028	89 01		 mov	 DWORD PTR [ecx], eax
  0002a	5f		 pop	 edi

; 974  : 	m_pNodeTail = pNewNode;

  0002b	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 1095 : 	return (POSITION) pNewNode;
; 1096 : }

  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 0c 00	 ret	 12			; 0000000cH
$LN7@InsertAfte:
  00033	5f		 pop	 edi

; 973  : 		m_pNodeHead = pNewNode;

  00034	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 974  : 	m_pNodeTail = pNewNode;

  00037	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 1095 : 	return (POSITION) pNewNode;
; 1096 : }

  0003a	5e		 pop	 esi
  0003b	5d		 pop	 ebp
  0003c	c2 0c 00	 ret	 12			; 0000000cH
$LN2@InsertAfte:

; 1076 : 		return AddTail(newElement); // insert after nothing -> tail of the list
; 1077 : 
; 1078 : 	// Insert it before position
; 1079 : 	CNode* pOldNode = (CNode*) position;
; 1080 : 	ASSERT(AfxIsValidAddress(pOldNode, sizeof(CNode)));
; 1081 : 	CNode* pNewNode = NewNode(pOldNode, pOldNode->pNext);

  0003f	ff 37		 push	 DWORD PTR [edi]
  00041	57		 push	 edi
  00042	e8 00 00 00 00	 call	 ?NewNode@?$CList@NN@@IAEPAUCNode@1@PAU21@0@Z ; CList<double,double>::NewNode

; 1082 : 	pNewNode->data = newElement;

  00047	f2 0f 10 45 0c	 movsd	 xmm0, QWORD PTR _newElement$[ebp]
  0004c	f2 0f 11 40 08	 movsd	 QWORD PTR [eax+8], xmm0

; 1083 : 
; 1084 : 	if (pOldNode->pNext != NULL)

  00051	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00053	85 c9		 test	 ecx, ecx
  00055	74 0b		 je	 SHORT $LN3@InsertAfte

; 1085 : 	{
; 1086 : 		ASSERT(AfxIsValidAddress(pOldNode->pNext, sizeof(CNode)));
; 1087 : 		pOldNode->pNext->pPrev = pNewNode;

  00057	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1093 : 	}
; 1094 : 	pOldNode->pNext = pNewNode;

  0005a	89 07		 mov	 DWORD PTR [edi], eax
  0005c	5f		 pop	 edi

; 1095 : 	return (POSITION) pNewNode;
; 1096 : }

  0005d	5e		 pop	 esi
  0005e	5d		 pop	 ebp
  0005f	c2 0c 00	 ret	 12			; 0000000cH
$LN3@InsertAfte:

; 1088 : 	}
; 1089 : 	else
; 1090 : 	{
; 1091 : 		ASSERT(pOldNode == m_pNodeTail);
; 1092 : 		m_pNodeTail = pNewNode;

  00062	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 1093 : 	}
; 1094 : 	pOldNode->pNext = pNewNode;

  00065	89 07		 mov	 DWORD PTR [edi], eax
  00067	5f		 pop	 edi

; 1095 : 	return (POSITION) pNewNode;
; 1096 : }

  00068	5e		 pop	 esi
  00069	5d		 pop	 ebp
  0006a	c2 0c 00	 ret	 12			; 0000000cH
?InsertAfter@?$CList@NN@@QAEPAU__POSITION@@PAU2@N@Z ENDP ; CList<double,double>::InsertAfter
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ?InsertBefore@?$CList@NN@@QAEPAU__POSITION@@PAU2@N@Z
_TEXT	SEGMENT
_position$ = 8						; size = 4
_newElement$ = 12					; size = 8
?InsertBefore@?$CList@NN@@QAEPAU__POSITION@@PAU2@N@Z PROC ; CList<double,double>::InsertBefore, COMDAT
; _this$ = ecx

; 1045 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 1046 : 	ASSERT_VALID(this);
; 1047 : 
; 1048 : 	if (position == NULL)

  00005	8b 7d 08	 mov	 edi, DWORD PTR _position$[ebp]
  00008	8b f1		 mov	 esi, ecx
  0000a	85 ff		 test	 edi, edi
  0000c	75 32		 jne	 SHORT $LN2@InsertBefo

; 953  : 	CNode* pNewNode = NewNode(NULL, m_pNodeHead);

  0000e	ff 76 04	 push	 DWORD PTR [esi+4]
  00011	57		 push	 edi
  00012	e8 00 00 00 00	 call	 ?NewNode@?$CList@NN@@IAEPAUCNode@1@PAU21@0@Z ; CList<double,double>::NewNode

; 954  : 	pNewNode->data = newElement;

  00017	f2 0f 10 45 0c	 movsd	 xmm0, QWORD PTR _newElement$[ebp]
  0001c	f2 0f 11 40 08	 movsd	 QWORD PTR [eax+8], xmm0

; 955  : 	if (m_pNodeHead != NULL)

  00021	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00024	85 c9		 test	 ecx, ecx
  00026	74 0c		 je	 SHORT $LN7@InsertBefo

; 956  : 		m_pNodeHead->pPrev = pNewNode;

  00028	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0002b	5f		 pop	 edi

; 959  : 	m_pNodeHead = pNewNode;

  0002c	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 1067 : 	return (POSITION) pNewNode;
; 1068 : }

  0002f	5e		 pop	 esi
  00030	5d		 pop	 ebp
  00031	c2 0c 00	 ret	 12			; 0000000cH
$LN7@InsertBefo:
  00034	5f		 pop	 edi

; 958  : 		m_pNodeTail = pNewNode;

  00035	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 959  : 	m_pNodeHead = pNewNode;

  00038	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 1067 : 	return (POSITION) pNewNode;
; 1068 : }

  0003b	5e		 pop	 esi
  0003c	5d		 pop	 ebp
  0003d	c2 0c 00	 ret	 12			; 0000000cH
$LN2@InsertBefo:

; 1049 : 		return AddHead(newElement); // insert before nothing -> head of the list
; 1050 : 
; 1051 : 	// Insert it before position
; 1052 : 	CNode* pOldNode = (CNode*) position;
; 1053 : 	CNode* pNewNode = NewNode(pOldNode->pPrev, pOldNode);

  00040	57		 push	 edi
  00041	ff 77 04	 push	 DWORD PTR [edi+4]
  00044	e8 00 00 00 00	 call	 ?NewNode@?$CList@NN@@IAEPAUCNode@1@PAU21@0@Z ; CList<double,double>::NewNode

; 1054 : 	pNewNode->data = newElement;

  00049	f2 0f 10 45 0c	 movsd	 xmm0, QWORD PTR _newElement$[ebp]
  0004e	f2 0f 11 40 08	 movsd	 QWORD PTR [eax+8], xmm0

; 1055 : 
; 1056 : 	if (pOldNode->pPrev != NULL)

  00053	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00056	85 c9		 test	 ecx, ecx
  00058	74 0b		 je	 SHORT $LN3@InsertBefo

; 1057 : 	{
; 1058 : 		ASSERT(AfxIsValidAddress(pOldNode->pPrev, sizeof(CNode)));
; 1059 : 		pOldNode->pPrev->pNext = pNewNode;

  0005a	89 01		 mov	 DWORD PTR [ecx], eax

; 1065 : 	}
; 1066 : 	pOldNode->pPrev = pNewNode;

  0005c	89 47 04	 mov	 DWORD PTR [edi+4], eax
  0005f	5f		 pop	 edi

; 1067 : 	return (POSITION) pNewNode;
; 1068 : }

  00060	5e		 pop	 esi
  00061	5d		 pop	 ebp
  00062	c2 0c 00	 ret	 12			; 0000000cH
$LN3@InsertBefo:

; 1060 : 	}
; 1061 : 	else
; 1062 : 	{
; 1063 : 		ASSERT(pOldNode == m_pNodeHead);
; 1064 : 		m_pNodeHead = pNewNode;

  00065	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 1065 : 	}
; 1066 : 	pOldNode->pPrev = pNewNode;

  00068	89 47 04	 mov	 DWORD PTR [edi+4], eax
  0006b	5f		 pop	 edi

; 1067 : 	return (POSITION) pNewNode;
; 1068 : }

  0006c	5e		 pop	 esi
  0006d	5d		 pop	 ebp
  0006e	c2 0c 00	 ret	 12			; 0000000cH
?InsertBefore@?$CList@NN@@QAEPAU__POSITION@@PAU2@N@Z ENDP ; CList<double,double>::InsertBefore
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ?RemoveAt@?$CList@NN@@QAEXPAU__POSITION@@@Z
_TEXT	SEGMENT
_position$ = 8						; size = 4
?RemoveAt@?$CList@NN@@QAEXPAU__POSITION@@@Z PROC	; CList<double,double>::RemoveAt, COMDAT
; _this$ = ecx

; 1100 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 1101 : 	ASSERT_VALID(this);
; 1102 : 
; 1103 : 	CNode* pOldNode = (CNode*) position;
; 1104 : 	ASSERT(AfxIsValidAddress(pOldNode, sizeof(CNode)));
; 1105 : 
; 1106 : 	// remove pOldNode from list
; 1107 : 	if (pOldNode == m_pNodeHead)

  00006	8b 4d 08	 mov	 ecx, DWORD PTR _position$[ebp]
  00009	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000b	3b 4e 04	 cmp	 ecx, DWORD PTR [esi+4]
  0000e	75 05		 jne	 SHORT $LN2@RemoveAt

; 1108 : 	{
; 1109 : 		m_pNodeHead = pOldNode->pNext;

  00010	89 56 04	 mov	 DWORD PTR [esi+4], edx

; 1110 : 	}

  00013	eb 05		 jmp	 SHORT $LN3@RemoveAt
$LN2@RemoveAt:

; 1111 : 	else
; 1112 : 	{
; 1113 : 		ASSERT(AfxIsValidAddress(pOldNode->pPrev, sizeof(CNode)));
; 1114 : 		pOldNode->pPrev->pNext = pOldNode->pNext;

  00015	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00018	89 10		 mov	 DWORD PTR [eax], edx
$LN3@RemoveAt:

; 1115 : 	}
; 1116 : 	if (pOldNode == m_pNodeTail)

  0001a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0001d	3b 4e 08	 cmp	 ecx, DWORD PTR [esi+8]
  00020	75 05		 jne	 SHORT $LN4@RemoveAt

; 1117 : 	{
; 1118 : 		m_pNodeTail = pOldNode->pPrev;

  00022	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 1119 : 	}

  00025	eb 05		 jmp	 SHORT $LN5@RemoveAt
$LN4@RemoveAt:

; 1120 : 	else
; 1121 : 	{
; 1122 : 		ASSERT(AfxIsValidAddress(pOldNode->pNext, sizeof(CNode)));
; 1123 : 		pOldNode->pNext->pPrev = pOldNode->pPrev;

  00027	8b 01		 mov	 eax, DWORD PTR [ecx]
  00029	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN5@RemoveAt:

; 938  : 	pNode->pNext = m_pNodeFree;

  0002c	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0002f	89 01		 mov	 DWORD PTR [ecx], eax

; 939  : 	m_pNodeFree = pNode;
; 940  : 	m_nCount--;

  00031	83 46 0c ff	 add	 DWORD PTR [esi+12], -1
  00035	89 4e 10	 mov	 DWORD PTR [esi+16], ecx

; 941  : 	ASSERT(m_nCount >= 0);  // make sure we don't underflow
; 942  : 
; 943  : 	// if no more elements, cleanup completely
; 944  : 	if (m_nCount == 0)

  00038	75 2b		 jne	 SHORT $LN8@RemoveAt

; 872  : 	m_pBlocks->FreeDataChain();

  0003a	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  0003d	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  00044	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0004b	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00052	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00059	e8 00 00 00 00	 call	 ?FreeDataChain@CPlex@@QAEXXZ ; CPlex::FreeDataChain

; 873  : 	m_pBlocks = NULL;

  0005e	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
$LN8@RemoveAt:
  00065	5e		 pop	 esi

; 1124 : 	}
; 1125 : 	FreeNode(pOldNode);
; 1126 : }

  00066	5d		 pop	 ebp
  00067	c2 04 00	 ret	 4
?RemoveAt@?$CList@NN@@QAEXPAU__POSITION@@@Z ENDP	; CList<double,double>::RemoveAt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ?RemoveAll@?$CList@NN@@QAEXXZ
_TEXT	SEGMENT
?RemoveAll@?$CList@NN@@QAEXXZ PROC			; CList<double,double>::RemoveAll, COMDAT
; _this$ = ecx

; 862  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 863  : 	ASSERT_VALID(this);
; 864  : 
; 865  : 	// destroy elements
; 866  : 	CNode* pNode;
; 867  : 	for (pNode = m_pNodeHead; pNode != NULL; pNode = pNode->pNext)
; 868  : 		pNode->data.~TYPE();
; 869  : 
; 870  : 	m_nCount = 0;
; 871  : 	m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
; 872  : 	m_pBlocks->FreeDataChain();

  00003	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00006	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  0000d	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00014	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  0001b	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00022	e8 00 00 00 00	 call	 ?FreeDataChain@CPlex@@QAEXXZ ; CPlex::FreeDataChain

; 873  : 	m_pBlocks = NULL;

  00027	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
  0002e	5e		 pop	 esi

; 874  : }

  0002f	c3		 ret	 0
?RemoveAll@?$CList@NN@@QAEXXZ ENDP			; CList<double,double>::RemoveAll
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ?AddTail@?$CList@NN@@QAEPAU__POSITION@@N@Z
_TEXT	SEGMENT
_newElement$ = 8					; size = 8
?AddTail@?$CList@NN@@QAEPAU__POSITION@@N@Z PROC		; CList<double,double>::AddTail, COMDAT
; _this$ = ecx

; 965  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 966  : 	ASSERT_VALID(this);
; 967  : 
; 968  : 	CNode* pNewNode = NewNode(m_pNodeTail, NULL);

  00006	6a 00		 push	 0
  00008	ff 76 08	 push	 DWORD PTR [esi+8]
  0000b	e8 00 00 00 00	 call	 ?NewNode@?$CList@NN@@IAEPAUCNode@1@PAU21@0@Z ; CList<double,double>::NewNode

; 969  : 	pNewNode->data = newElement;

  00010	f2 0f 10 45 08	 movsd	 xmm0, QWORD PTR _newElement$[ebp]
  00015	f2 0f 11 40 08	 movsd	 QWORD PTR [eax+8], xmm0

; 970  : 	if (m_pNodeTail != NULL)

  0001a	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0001d	85 c9		 test	 ecx, ecx
  0001f	74 0a		 je	 SHORT $LN2@AddTail

; 971  : 		m_pNodeTail->pNext = pNewNode;

  00021	89 01		 mov	 DWORD PTR [ecx], eax

; 974  : 	m_pNodeTail = pNewNode;
; 975  : 	return (POSITION) pNewNode;
; 976  : }

  00023	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00026	5e		 pop	 esi
  00027	5d		 pop	 ebp
  00028	c2 08 00	 ret	 8
$LN2@AddTail:

; 972  : 	else
; 973  : 		m_pNodeHead = pNewNode;

  0002b	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 974  : 	m_pNodeTail = pNewNode;
; 975  : 	return (POSITION) pNewNode;
; 976  : }

  0002e	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00031	5e		 pop	 esi
  00032	5d		 pop	 ebp
  00033	c2 08 00	 ret	 8
?AddTail@?$CList@NN@@QAEPAU__POSITION@@N@Z ENDP		; CList<double,double>::AddTail
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ?AddHead@?$CList@NN@@QAEPAU__POSITION@@N@Z
_TEXT	SEGMENT
_newElement$ = 8					; size = 8
?AddHead@?$CList@NN@@QAEPAU__POSITION@@N@Z PROC		; CList<double,double>::AddHead, COMDAT
; _this$ = ecx

; 950  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 951  : 	ASSERT_VALID(this);
; 952  : 
; 953  : 	CNode* pNewNode = NewNode(NULL, m_pNodeHead);

  00006	ff 76 04	 push	 DWORD PTR [esi+4]
  00009	6a 00		 push	 0
  0000b	e8 00 00 00 00	 call	 ?NewNode@?$CList@NN@@IAEPAUCNode@1@PAU21@0@Z ; CList<double,double>::NewNode

; 954  : 	pNewNode->data = newElement;

  00010	f2 0f 10 45 08	 movsd	 xmm0, QWORD PTR _newElement$[ebp]
  00015	f2 0f 11 40 08	 movsd	 QWORD PTR [eax+8], xmm0

; 955  : 	if (m_pNodeHead != NULL)

  0001a	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0001d	85 c9		 test	 ecx, ecx
  0001f	74 0b		 je	 SHORT $LN2@AddHead

; 956  : 		m_pNodeHead->pPrev = pNewNode;

  00021	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 959  : 	m_pNodeHead = pNewNode;
; 960  : 	return (POSITION) pNewNode;
; 961  : }

  00024	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00027	5e		 pop	 esi
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
$LN2@AddHead:

; 957  : 	else
; 958  : 		m_pNodeTail = pNewNode;

  0002c	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 959  : 	m_pNodeHead = pNewNode;
; 960  : 	return (POSITION) pNewNode;
; 961  : }

  0002f	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00032	5e		 pop	 esi
  00033	5d		 pop	 ebp
  00034	c2 08 00	 ret	 8
?AddHead@?$CList@NN@@QAEPAU__POSITION@@N@Z ENDP		; CList<double,double>::AddHead
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ??0?$CList@NN@@QAE@H@Z
_TEXT	SEGMENT
_nBlockSize$ = 8					; size = 4
??0?$CList@NN@@QAE@H@Z PROC				; CList<double,double>::CList<double,double>, COMDAT
; _this$ = ecx

; 851  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 852  : 	ASSERT(nBlockSize > 0);
; 853  : 
; 854  : 	m_nCount = 0;
; 855  : 	m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
; 856  : 	m_pBlocks = NULL;
; 857  : 	m_nBlockSize = nBlockSize;

  00003	8b 45 08	 mov	 eax, DWORD PTR _nBlockSize$[ebp]
  00006	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 858  : }

  00009	8b c1		 mov	 eax, ecx
  0000b	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CList@NN@@6B@
  00011	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0
  00018	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  0001f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00026	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0002d	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
??0?$CList@NN@@QAE@H@Z ENDP				; CList<double,double>::CList<double,double>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
;	COMDAT ?GetData@CBlocksPositionCalculator@@CANABV?$CList@NN@@H@Z
_TEXT	SEGMENT
_positionList$ = 8					; size = 4
_index$ = 12						; size = 4
?GetData@CBlocksPositionCalculator@@CANABV?$CList@NN@@H@Z PROC ; CBlocksPositionCalculator::GetData, COMDAT

; 515  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 1133 : 	if (nIndex >= m_nCount || nIndex < 0)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _positionList$[ebp]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp

; 516  : 	POSITION pos = positionList.FindIndex(index);

  00006	8b 45 0c	 mov	 eax, DWORD PTR _index$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 1133 : 	if (nIndex >= m_nCount || nIndex < 0)

  00009	3b 41 0c	 cmp	 eax, DWORD PTR [ecx+12]
  0000c	7d 19		 jge	 SHORT $LN15@GetData
  0000e	85 c0		 test	 eax, eax
  00010	78 15		 js	 SHORT $LN15@GetData

; 1134 : 		return NULL;  // went too far
; 1135 : 
; 1136 : 	CNode* pNode = m_pNodeHead;

  00012	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]

; 1137 : 	while (nIndex--)

  00015	74 07		 je	 SHORT $LN11@GetData
$LL5@GetData:

; 1138 : 	{
; 1139 : 		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 1140 : 		pNode = pNode->pNext;

  00017	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00019	83 e8 01	 sub	 eax, 1
  0001c	75 f9		 jne	 SHORT $LL5@GetData
$LN11@GetData:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp

; 517  : 	if(pos == NULL)

  0001e	85 c9		 test	 ecx, ecx
  00020	74 05		 je	 SHORT $LN15@GetData

; 519  : 	return positionList.GetAt(pos);

  00022	dd 41 08	 fld	 QWORD PTR [ecx+8]

; 520  : }

  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN15@GetData:

; 518  : 		return 0;

  00027	d9 ee		 fldz

; 520  : }

  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
?GetData@CBlocksPositionCalculator@@CANABV?$CList@NN@@H@Z ENDP ; CBlocksPositionCalculator::GetData
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
;	COMDAT ?GetChangedLengthInBlock@CBlocksPositionCalculator@@CA_NHHAAV?$CList@NN@@@Z
_TEXT	SEGMENT
_data$1$ = -8						; size = 8
_sourceIndex$ = 8					; size = 4
_targetIndex$ = 12					; size = 4
_lengthInBlock$ = 16					; size = 4
?GetChangedLengthInBlock@CBlocksPositionCalculator@@CA_NHHAAV?$CList@NN@@@Z PROC ; CBlocksPositionCalculator::GetChangedLengthInBlock, COMDAT

; 494  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 495  : 	if(sourceIndex < 0 || targetIndex < 0 || lengthInBlock.GetCount() <= 0)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _sourceIndex$[ebp]
  00006	83 ec 08	 sub	 esp, 8
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	85 c9		 test	 ecx, ecx
  0000e	0f 88 1f 01 00
	00		 js	 $LN3@GetChanged
  00014	8b 55 0c	 mov	 edx, DWORD PTR _targetIndex$[ebp]
  00017	85 d2		 test	 edx, edx
  00019	0f 88 14 01 00
	00		 js	 $LN3@GetChanged
  0001f	8b 75 10	 mov	 esi, DWORD PTR _lengthInBlock$[ebp]
  00022	8b 5e 0c	 mov	 ebx, DWORD PTR [esi+12]
  00025	85 db		 test	 ebx, ebx
  00027	0f 8e 06 01 00
	00		 jle	 $LN3@GetChanged

; 496  : 		return false;
; 497  : 	
; 498  : 	POSITION sourcePos = lengthInBlock.FindIndex(sourceIndex);

  0002d	8b c1		 mov	 eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 1133 : 	if (nIndex >= m_nCount || nIndex < 0)

  0002f	3b cb		 cmp	 ecx, ebx
  00031	7d 16		 jge	 SHORT $LN13@GetChanged

; 1135 : 
; 1136 : 	CNode* pNode = m_pNodeHead;

  00033	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]

; 1137 : 	while (nIndex--)

  00036	85 c9		 test	 ecx, ecx
  00038	74 11		 je	 SHORT $LN9@GetChanged
  0003a	66 0f 1f 44 00
	00		 npad	 6
$LL10@GetChanged:

; 1138 : 	{
; 1139 : 		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 1140 : 		pNode = pNode->pNext;

  00040	8b 3f		 mov	 edi, DWORD PTR [edi]
  00042	83 e8 01	 sub	 eax, 1
  00045	75 f9		 jne	 SHORT $LL10@GetChanged

; 1141 : 	}
; 1142 : 	return (POSITION) pNode;

  00047	eb 02		 jmp	 SHORT $LN9@GetChanged
$LN13@GetChanged:

; 1134 : 		return NULL;  // went too far

  00049	33 ff		 xor	 edi, edi
$LN9@GetChanged:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp

; 499  : 	POSITION targetPos = lengthInBlock.FindIndex(targetIndex);

  0004b	8b c2		 mov	 eax, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 1133 : 	if (nIndex >= m_nCount || nIndex < 0)

  0004d	3b d3		 cmp	 edx, ebx
  0004f	7d 10		 jge	 SHORT $LN19@GetChanged

; 1135 : 
; 1136 : 	CNode* pNode = m_pNodeHead;

  00051	8b 5e 04	 mov	 ebx, DWORD PTR [esi+4]

; 1137 : 	while (nIndex--)

  00054	85 d2		 test	 edx, edx
  00056	74 0b		 je	 SHORT $LN15@GetChanged
$LL16@GetChanged:

; 1138 : 	{
; 1139 : 		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 1140 : 		pNode = pNode->pNext;

  00058	8b 1b		 mov	 ebx, DWORD PTR [ebx]
  0005a	83 e8 01	 sub	 eax, 1
  0005d	75 f9		 jne	 SHORT $LL16@GetChanged

; 1141 : 	}
; 1142 : 	return (POSITION) pNode;

  0005f	eb 02		 jmp	 SHORT $LN15@GetChanged
$LN19@GetChanged:

; 1134 : 		return NULL;  // went too far

  00061	33 db		 xor	 ebx, ebx
$LN15@GetChanged:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp

; 500  : 	if(sourcePos == NULL || targetPos == NULL)

  00063	85 ff		 test	 edi, edi
  00065	0f 84 c8 00 00
	00		 je	 $LN3@GetChanged
  0006b	85 db		 test	 ebx, ebx
  0006d	0f 84 c0 00 00
	00		 je	 $LN3@GetChanged

; 501  : 		return false;
; 502  : 	
; 503  : 	double data = lengthInBlock.GetAt(sourcePos);

  00073	f2 0f 10 47 08	 movsd	 xmm0, QWORD PTR [edi+8]

; 504  : 	if(sourceIndex > targetIndex)

  00078	3b ca		 cmp	 ecx, edx
  0007a	f2 0f 11 45 f8	 movsd	 QWORD PTR _data$1$[ebp], xmm0
  0007f	8b ce		 mov	 ecx, esi
  00081	7e 29		 jle	 SHORT $LN6@GetChanged
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 1053 : 	CNode* pNewNode = NewNode(pOldNode->pPrev, pOldNode);

  00083	53		 push	 ebx
  00084	ff 73 04	 push	 DWORD PTR [ebx+4]
  00087	e8 00 00 00 00	 call	 ?NewNode@?$CList@NN@@IAEPAUCNode@1@PAU21@0@Z ; CList<double,double>::NewNode

; 1054 : 	pNewNode->data = newElement;

  0008c	f2 0f 10 45 f8	 movsd	 xmm0, QWORD PTR _data$1$[ebp]
  00091	f2 0f 11 40 08	 movsd	 QWORD PTR [eax+8], xmm0

; 1055 : 
; 1056 : 	if (pOldNode->pPrev != NULL)

  00096	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00099	85 c9		 test	 ecx, ecx
  0009b	74 07		 je	 SHORT $LN23@GetChanged

; 1057 : 	{
; 1058 : 		ASSERT(AfxIsValidAddress(pOldNode->pPrev, sizeof(CNode)));
; 1059 : 		pOldNode->pPrev->pNext = pNewNode;

  0009d	89 01		 mov	 DWORD PTR [ecx], eax

; 1065 : 	}
; 1066 : 	pOldNode->pPrev = pNewNode;

  0009f	89 43 04	 mov	 DWORD PTR [ebx+4], eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp

; 505  : 		lengthInBlock.InsertBefore(targetPos, data);

  000a2	eb 2a		 jmp	 SHORT $LN30@GetChanged
$LN23@GetChanged:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 1064 : 		m_pNodeHead = pNewNode;

  000a4	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 1065 : 	}
; 1066 : 	pOldNode->pPrev = pNewNode;

  000a7	89 43 04	 mov	 DWORD PTR [ebx+4], eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp

; 505  : 		lengthInBlock.InsertBefore(targetPos, data);

  000aa	eb 22		 jmp	 SHORT $LN30@GetChanged
$LN6@GetChanged:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 1081 : 	CNode* pNewNode = NewNode(pOldNode, pOldNode->pNext);

  000ac	ff 33		 push	 DWORD PTR [ebx]
  000ae	53		 push	 ebx
  000af	e8 00 00 00 00	 call	 ?NewNode@?$CList@NN@@IAEPAUCNode@1@PAU21@0@Z ; CList<double,double>::NewNode

; 1082 : 	pNewNode->data = newElement;

  000b4	f2 0f 10 45 f8	 movsd	 xmm0, QWORD PTR _data$1$[ebp]
  000b9	f2 0f 11 40 08	 movsd	 QWORD PTR [eax+8], xmm0

; 1083 : 
; 1084 : 	if (pOldNode->pNext != NULL)

  000be	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  000c0	85 c9		 test	 ecx, ecx
  000c2	74 05		 je	 SHORT $LN32@GetChanged

; 1085 : 	{
; 1086 : 		ASSERT(AfxIsValidAddress(pOldNode->pNext, sizeof(CNode)));
; 1087 : 		pOldNode->pNext->pPrev = pNewNode;

  000c4	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1088 : 	}

  000c7	eb 03		 jmp	 SHORT $LN33@GetChanged
$LN32@GetChanged:

; 1089 : 	else
; 1090 : 	{
; 1091 : 		ASSERT(pOldNode == m_pNodeTail);
; 1092 : 		m_pNodeTail = pNewNode;

  000c9	89 46 08	 mov	 DWORD PTR [esi+8], eax
$LN33@GetChanged:

; 1093 : 	}
; 1094 : 	pOldNode->pNext = pNewNode;

  000cc	89 03		 mov	 DWORD PTR [ebx], eax
$LN30@GetChanged:

; 1107 : 	if (pOldNode == m_pNodeHead)

  000ce	8b 0f		 mov	 ecx, DWORD PTR [edi]
  000d0	3b 7e 04	 cmp	 edi, DWORD PTR [esi+4]
  000d3	75 05		 jne	 SHORT $LN40@GetChanged

; 1108 : 	{
; 1109 : 		m_pNodeHead = pOldNode->pNext;

  000d5	89 4e 04	 mov	 DWORD PTR [esi+4], ecx

; 1110 : 	}

  000d8	eb 05		 jmp	 SHORT $LN41@GetChanged
$LN40@GetChanged:

; 1111 : 	else
; 1112 : 	{
; 1113 : 		ASSERT(AfxIsValidAddress(pOldNode->pPrev, sizeof(CNode)));
; 1114 : 		pOldNode->pPrev->pNext = pOldNode->pNext;

  000da	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  000dd	89 08		 mov	 DWORD PTR [eax], ecx
$LN41@GetChanged:

; 1115 : 	}
; 1116 : 	if (pOldNode == m_pNodeTail)

  000df	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  000e2	3b 7e 08	 cmp	 edi, DWORD PTR [esi+8]
  000e5	75 05		 jne	 SHORT $LN42@GetChanged

; 1117 : 	{
; 1118 : 		m_pNodeTail = pOldNode->pPrev;

  000e7	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 1119 : 	}

  000ea	eb 05		 jmp	 SHORT $LN43@GetChanged
$LN42@GetChanged:

; 1120 : 	else
; 1121 : 	{
; 1122 : 		ASSERT(AfxIsValidAddress(pOldNode->pNext, sizeof(CNode)));
; 1123 : 		pOldNode->pNext->pPrev = pOldNode->pPrev;

  000ec	8b 07		 mov	 eax, DWORD PTR [edi]
  000ee	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN43@GetChanged:

; 938  : 	pNode->pNext = m_pNodeFree;

  000f1	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000f4	89 07		 mov	 DWORD PTR [edi], eax

; 939  : 	m_pNodeFree = pNode;
; 940  : 	m_nCount--;

  000f6	83 46 0c ff	 add	 DWORD PTR [esi+12], -1
  000fa	89 7e 10	 mov	 DWORD PTR [esi+16], edi

; 941  : 	ASSERT(m_nCount >= 0);  // make sure we don't underflow
; 942  : 
; 943  : 	// if no more elements, cleanup completely
; 944  : 	if (m_nCount == 0)

  000fd	75 2b		 jne	 SHORT $LN46@GetChanged

; 872  : 	m_pBlocks->FreeDataChain();

  000ff	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00102	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  00109	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00110	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00117	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0011e	e8 00 00 00 00	 call	 ?FreeDataChain@CPlex@@QAEXXZ ; CPlex::FreeDataChain

; 873  : 	m_pBlocks = NULL;

  00123	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
$LN46@GetChanged:
  0012a	5f		 pop	 edi
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp

; 511  : }

  0012b	5e		 pop	 esi
  0012c	b0 01		 mov	 al, 1
  0012e	5b		 pop	 ebx
  0012f	8b e5		 mov	 esp, ebp
  00131	5d		 pop	 ebp
  00132	c3		 ret	 0
$LN3@GetChanged:
  00133	5f		 pop	 edi
  00134	5e		 pop	 esi
  00135	32 c0		 xor	 al, al
  00137	5b		 pop	 ebx
  00138	8b e5		 mov	 esp, ebp
  0013a	5d		 pop	 ebp
  0013b	c3		 ret	 0
?GetChangedLengthInBlock@CBlocksPositionCalculator@@CA_NHHAAV?$CList@NN@@@Z ENDP ; CBlocksPositionCalculator::GetChangedLengthInBlock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
;	COMDAT ?GetChangedLengthInBlock@CBlocksPositionCalculator@@CA_NABV?$CList@NN@@HHAAV2@@Z
_TEXT	SEGMENT
_data$1$ = -12						; size = 8
_pPrev$1$ = -4						; size = 4
_positionList$ = 8					; size = 4
_sourceIndex$ = 12					; size = 4
_targetIndex$ = 16					; size = 4
_lengthInBlock$ = 20					; size = 4
?GetChangedLengthInBlock@CBlocksPositionCalculator@@CA_NABV?$CList@NN@@HHAAV2@@Z PROC ; CBlocksPositionCalculator::GetChangedLengthInBlock, COMDAT

; 482  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 484  : 	for(int i = 1; i < positionList.GetCount(); i++){

  00003	8b 45 08	 mov	 eax, DWORD PTR _positionList$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	8b 75 14	 mov	 esi, DWORD PTR _lengthInBlock$[ebp]
  0000e	bb 01 00 00 00	 mov	 ebx, 1
  00013	57		 push	 edi
  00014	8b 78 0c	 mov	 edi, DWORD PTR [eax+12]
  00017	3b fb		 cmp	 edi, ebx
  00019	0f 8e ec 00 00
	00		 jle	 $LN63@GetChanged
  0001f	8b d7		 mov	 edx, edi
$LL4@GetChanged:

; 516  : 	POSITION pos = positionList.FindIndex(index);

  00021	8b cb		 mov	 ecx, ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 1133 : 	if (nIndex >= m_nCount || nIndex < 0)

  00023	3b da		 cmp	 ebx, edx
  00025	7d 1d		 jge	 SHORT $LN13@GetChanged
  00027	85 db		 test	 ebx, ebx
  00029	78 19		 js	 SHORT $LN13@GetChanged

; 1134 : 		return NULL;  // went too far
; 1135 : 
; 1136 : 	CNode* pNode = m_pNodeHead;

  0002b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 1137 : 	while (nIndex--)

  0002e	74 09		 je	 SHORT $LN45@GetChanged
$LL10@GetChanged:

; 1138 : 	{
; 1139 : 		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 1140 : 		pNode = pNode->pNext;

  00030	8b 00		 mov	 eax, DWORD PTR [eax]
  00032	83 e9 01	 sub	 ecx, 1
  00035	75 f9		 jne	 SHORT $LL10@GetChanged
  00037	8b d7		 mov	 edx, edi
$LN45@GetChanged:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp

; 517  : 	if(pos == NULL)

  00039	85 c0		 test	 eax, eax
  0003b	74 07		 je	 SHORT $LN13@GetChanged

; 518  : 		return 0;
; 519  : 	return positionList.GetAt(pos);

  0003d	f2 0f 10 48 08	 movsd	 xmm1, QWORD PTR [eax+8]
  00042	eb 03		 jmp	 SHORT $LN6@GetChanged
$LN13@GetChanged:
  00044	0f 57 c9	 xorps	 xmm1, xmm1
$LN6@GetChanged:

; 516  : 	POSITION pos = positionList.FindIndex(index);

  00047	8d 43 ff	 lea	 eax, DWORD PTR [ebx-1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 1133 : 	if (nIndex >= m_nCount || nIndex < 0)

  0004a	3b c2		 cmp	 eax, edx
  0004c	7d 24		 jge	 SHORT $LN59@GetChanged
  0004e	85 c0		 test	 eax, eax
  00050	78 20		 js	 SHORT $LN59@GetChanged

; 1134 : 		return NULL;  // went too far
; 1135 : 
; 1136 : 	CNode* pNode = m_pNodeHead;

  00052	8b 4d 08	 mov	 ecx, DWORD PTR _positionList$[ebp]
  00055	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]

; 1137 : 	while (nIndex--)

  00058	74 0d		 je	 SHORT $LN47@GetChanged
  0005a	66 0f 1f 44 00
	00		 npad	 6
$LL19@GetChanged:

; 1138 : 	{
; 1139 : 		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 1140 : 		pNode = pNode->pNext;

  00060	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00062	83 e8 01	 sub	 eax, 1
  00065	75 f9		 jne	 SHORT $LL19@GetChanged
$LN47@GetChanged:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp

; 517  : 	if(pos == NULL)

  00067	85 c9		 test	 ecx, ecx
  00069	74 07		 je	 SHORT $LN59@GetChanged

; 518  : 		return 0;
; 519  : 	return positionList.GetAt(pos);

  0006b	f2 0f 10 41 08	 movsd	 xmm0, QWORD PTR [ecx+8]
  00070	eb 03		 jmp	 SHORT $LN15@GetChanged
$LN59@GetChanged:
  00072	0f 57 c0	 xorps	 xmm0, xmm0
$LN15@GetChanged:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 902  : 	if (m_pNodeFree == NULL)

  00075	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp

; 485  : 		double data = GetData( positionList, i) - GetData( positionList, i -1);

  00078	f2 0f 5c c8	 subsd	 xmm1, xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 968  : 	CNode* pNewNode = NewNode(m_pNodeTail, NULL);

  0007c	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0007f	89 45 fc	 mov	 DWORD PTR _pPrev$1$[ebp], eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp

; 485  : 		double data = GetData( positionList, i) - GetData( positionList, i -1);

  00082	f2 0f 11 4d f4	 movsd	 QWORD PTR _data$1$[ebp], xmm1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 902  : 	if (m_pNodeFree == NULL)

  00087	85 d2		 test	 edx, edx
  00089	75 45		 jne	 SHORT $LN61@GetChanged

; 903  : 	{
; 904  : 		// add another block
; 905  : 		CPlex* pNewBlock = CPlex::Create(m_pBlocks, m_nBlockSize,

  0008b	6a 10		 push	 16			; 00000010H
  0008d	ff 76 18	 push	 DWORD PTR [esi+24]
  00090	8d 46 14	 lea	 eax, DWORD PTR [esi+20]
  00093	50		 push	 eax
  00094	e8 00 00 00 00	 call	 ?Create@CPlex@@SGPAU1@AAPAU1@II@Z ; CPlex::Create

; 906  : 				 sizeof(CNode));
; 907  : 
; 908  : 		// chain them into free list
; 909  : 		CNode* pNode = (CNode*) pNewBlock->data();
; 910  : 		// free in reverse order to make it easier to debug
; 911  : 		pNode += m_nBlockSize - 1;

  00099	8b 56 18	 mov	 edx, DWORD PTR [esi+24]
  0009c	83 c0 08	 add	 eax, 8
  0009f	8b ca		 mov	 ecx, edx
  000a1	c1 e1 04	 shl	 ecx, 4
  000a4	83 c1 f0	 add	 ecx, -16		; fffffff0H

; 912  : 		for (INT_PTR i = m_nBlockSize-1; i >= 0; i--, pNode--)

  000a7	8d 7a ff	 lea	 edi, DWORD PTR [edx-1]
  000aa	03 c8		 add	 ecx, eax
  000ac	85 ff		 test	 edi, edi
  000ae	78 14		 js	 SHORT $LN62@GetChanged
$LL31@GetChanged:

; 913  : 		{
; 914  : 			pNode->pNext = m_pNodeFree;

  000b0	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000b3	8b d1		 mov	 edx, ecx
  000b5	89 01		 mov	 DWORD PTR [ecx], eax

; 915  : 			m_pNodeFree = pNode;

  000b7	89 4e 10	 mov	 DWORD PTR [esi+16], ecx
  000ba	83 e9 10	 sub	 ecx, 16			; 00000010H
  000bd	83 ef 01	 sub	 edi, 1
  000c0	79 ee		 jns	 SHORT $LL31@GetChanged
  000c2	eb 03		 jmp	 SHORT $LN34@GetChanged
$LN62@GetChanged:
  000c4	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
$LN34@GetChanged:

; 918  : 	ENSURE(m_pNodeFree != NULL);  // we must have something

  000c7	85 d2		 test	 edx, edx
  000c9	74 56		 je	 SHORT $LN44@GetChanged
  000cb	f2 0f 10 4d f4	 movsd	 xmm1, QWORD PTR _data$1$[ebp]
$LN61@GetChanged:

; 919  : 
; 920  : 	CList::CNode* pNode = m_pNodeFree;
; 921  : 	m_pNodeFree = m_pNodeFree->pNext;

  000d0	8b 02		 mov	 eax, DWORD PTR [edx]
  000d2	89 46 10	 mov	 DWORD PTR [esi+16], eax

; 922  : 	pNode->pPrev = pPrev;

  000d5	8b 45 fc	 mov	 eax, DWORD PTR _pPrev$1$[ebp]
  000d8	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 923  : 	pNode->pNext = pNext;

  000db	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 924  : 	m_nCount++;

  000e1	ff 46 0c	 inc	 DWORD PTR [esi+12]

; 969  : 	pNewNode->data = newElement;

  000e4	f2 0f 11 4a 08	 movsd	 QWORD PTR [edx+8], xmm1

; 970  : 	if (m_pNodeTail != NULL)

  000e9	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000ec	85 c0		 test	 eax, eax
  000ee	74 04		 je	 SHORT $LN25@GetChanged

; 971  : 		m_pNodeTail->pNext = pNewNode;

  000f0	89 10		 mov	 DWORD PTR [eax], edx
  000f2	eb 03		 jmp	 SHORT $LN26@GetChanged
$LN25@GetChanged:

; 972  : 	else
; 973  : 		m_pNodeHead = pNewNode;

  000f4	89 56 04	 mov	 DWORD PTR [esi+4], edx
$LN26@GetChanged:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp

; 484  : 	for(int i = 1; i < positionList.GetCount(); i++){

  000f7	8b 45 08	 mov	 eax, DWORD PTR _positionList$[ebp]
  000fa	43		 inc	 ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 974  : 	m_pNodeTail = pNewNode;

  000fb	89 56 08	 mov	 DWORD PTR [esi+8], edx
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp

; 484  : 	for(int i = 1; i < positionList.GetCount(); i++){

  000fe	8b 78 0c	 mov	 edi, DWORD PTR [eax+12]
  00101	8b d7		 mov	 edx, edi
  00103	3b df		 cmp	 ebx, edi
  00105	0f 8c 16 ff ff
	ff		 jl	 $LL4@GetChanged
$LN63@GetChanged:

; 486  : 		lengthInBlock.AddTail(data);
; 487  : 	}
; 488  : 
; 489  : 	//  position 
; 490  : 	return GetChangedLengthInBlock(sourceIndex, targetIndex, lengthInBlock);

  0010b	56		 push	 esi
  0010c	ff 75 10	 push	 DWORD PTR _targetIndex$[ebp]
  0010f	ff 75 0c	 push	 DWORD PTR _sourceIndex$[ebp]
  00112	e8 00 00 00 00	 call	 ?GetChangedLengthInBlock@CBlocksPositionCalculator@@CA_NHHAAV?$CList@NN@@@Z ; CBlocksPositionCalculator::GetChangedLengthInBlock
  00117	83 c4 0c	 add	 esp, 12			; 0000000cH
  0011a	5f		 pop	 edi
  0011b	5e		 pop	 esi
  0011c	5b		 pop	 ebx

; 491  : }

  0011d	8b e5		 mov	 esp, ebp
  0011f	5d		 pop	 ebp
  00120	c3		 ret	 0
$LN44@GetChanged:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 918  : 	ENSURE(m_pNodeFree != NULL);  // we must have something

  00121	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN64@GetChanged:
  00126	cc		 int	 3
?GetChangedLengthInBlock@CBlocksPositionCalculator@@CA_NABV?$CList@NN@@HHAAV2@@Z ENDP ; CBlocksPositionCalculator::GetChangedLengthInBlock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
;	COMDAT ?IsMoveBlockPosition@CBlocksPositionCalculator@@CA_NHH@Z
_TEXT	SEGMENT
_num$ = 8						; size = 4
_allCount$ = 12						; size = 4
?IsMoveBlockPosition@CBlocksPositionCalculator@@CA_NHH@Z PROC ; CBlocksPositionCalculator::IsMoveBlockPosition, COMDAT

; 473  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 474  : 	if(allCount <= 2)

  00003	8b 45 0c	 mov	 eax, DWORD PTR _allCount$[ebp]
  00006	83 f8 02	 cmp	 eax, 2
  00009	7e 10		 jle	 SHORT $LN4@IsMoveBloc

; 475  : 		return false;
; 476  : 
; 477  : 	return (num > -1 && num < allCount);

  0000b	8b 4d 08	 mov	 ecx, DWORD PTR _num$[ebp]
  0000e	83 f9 ff	 cmp	 ecx, -1
  00011	7e 08		 jle	 SHORT $LN4@IsMoveBloc
  00013	3b c8		 cmp	 ecx, eax
  00015	7d 04		 jge	 SHORT $LN4@IsMoveBloc
  00017	b0 01		 mov	 al, 1

; 478  : }

  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
$LN4@IsMoveBloc:
  0001b	32 c0		 xor	 al, al
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
?IsMoveBlockPosition@CBlocksPositionCalculator@@CA_NHH@Z ENDP ; CBlocksPositionCalculator::IsMoveBlockPosition
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
;	COMDAT ?MoveBlocksPosition@CBlocksPositionCalculator@@CA_NAAV?$CList@NN@@HH@Z
_TEXT	SEGMENT
_dCurData$1$ = -8					; size = 8
_positionList$ = 8					; size = 4
_compartLineNum$ = 12					; size = 4
_modityData$ = 16					; size = 4
?MoveBlocksPosition@CBlocksPositionCalculator@@CA_NAAV?$CList@NN@@HH@Z PROC ; CBlocksPositionCalculator::MoveBlocksPosition, COMDAT

; 449  : {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 450  : 	// 0      !!
; 451  : 	if(compartLineNum <= 0 || compartLineNum >= positionList.GetCount() -1)

  00003	8b 55 0c	 mov	 edx, DWORD PTR _compartLineNum$[ebp]
  00006	83 ec 08	 sub	 esp, 8
  00009	56		 push	 esi
  0000a	85 d2		 test	 edx, edx
  0000c	0f 8e 82 00 00
	00		 jle	 $LN3@MoveBlocks
  00012	8b 75 08	 mov	 esi, DWORD PTR _positionList$[ebp]
  00015	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00018	8d 41 ff	 lea	 eax, DWORD PTR [ecx-1]
  0001b	3b d0		 cmp	 edx, eax
  0001d	7d 75		 jge	 SHORT $LN3@MoveBlocks

; 453  : 
; 454  : 	POSITION pos = positionList.FindIndex(compartLineNum -1);

  0001f	8d 42 ff	 lea	 eax, DWORD PTR [edx-1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 1133 : 	if (nIndex >= m_nCount || nIndex < 0)

  00022	3b c1		 cmp	 eax, ecx
  00024	7d 6e		 jge	 SHORT $LN3@MoveBlocks
  00026	85 c0		 test	 eax, eax
  00028	78 6a		 js	 SHORT $LN3@MoveBlocks

; 1134 : 		return NULL;  // went too far
; 1135 : 
; 1136 : 	CNode* pNode = m_pNodeHead;

  0002a	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]

; 1137 : 	while (nIndex--)

  0002d	74 08		 je	 SHORT $LN20@MoveBlocks
  0002f	90		 npad	 1
$LL8@MoveBlocks:

; 1138 : 	{
; 1139 : 		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 1140 : 		pNode = pNode->pNext;

  00030	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00032	83 e8 01	 sub	 eax, 1
  00035	75 f9		 jne	 SHORT $LL8@MoveBlocks
$LN20@MoveBlocks:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp

; 455  : 	if(pos == NULL)

  00037	85 c9		 test	 ecx, ecx
  00039	74 59		 je	 SHORT $LN3@MoveBlocks
  0003b	66 0f 6e 15 00
	00 00 00	 movd	 xmm2, DWORD PTR ?m_nMinBlockWidth@CBlocksPositionCalculator@@0HA ; CBlocksPositionCalculator::m_nMinBlockWidth
  00043	66 0f 6e 4d 10	 movd	 xmm1, DWORD PTR _modityData$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 811  : 	{ CNode* pNode = (CNode*) rPosition;

  00048	8b 01		 mov	 eax, DWORD PTR [ecx]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp

; 458  : 	double dPreData = positionList.GetNext( pos) + m_nMinBlockWidth;

  0004a	f3 0f e6 d2	 cvtdq2pd xmm2, xmm2

; 459  : 	double dCurData = positionList.GetNext( pos) + modityData;

  0004e	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1
  00052	0f 28 c2	 movaps	 xmm0, xmm2
  00055	f2 0f 58 48 08	 addsd	 xmm1, QWORD PTR [eax+8]
  0005a	f2 0f 58 41 08	 addsd	 xmm0, QWORD PTR [ecx+8]
  0005f	f2 0f 11 4d f8	 movsd	 QWORD PTR _dCurData$1$[ebp], xmm1

; 461  : 
; 462  : 	if( dCurData > dPreData && dCurData < dNextData){

  00064	66 0f 2f c8	 comisd	 xmm1, xmm0
  00068	76 2a		 jbe	 SHORT $LN3@MoveBlocks

; 460  : 	double dNextData = positionList.GetNext( pos) - m_nMinBlockWidth;

  0006a	8b 00		 mov	 eax, DWORD PTR [eax]
  0006c	f2 0f 10 40 08	 movsd	 xmm0, QWORD PTR [eax+8]
  00071	f2 0f 5c c2	 subsd	 xmm0, xmm2

; 461  : 
; 462  : 	if( dCurData > dPreData && dCurData < dNextData){

  00075	66 0f 2f c1	 comisd	 xmm0, xmm1
  00079	76 19		 jbe	 SHORT $LN3@MoveBlocks

; 463  : 		POSITION curPos = positionList.FindIndex(compartLineNum);

  0007b	52		 push	 edx
  0007c	8b ce		 mov	 ecx, esi
  0007e	e8 00 00 00 00	 call	 ?FindIndex@?$CList@NN@@QBEPAU__POSITION@@H@Z ; CList<double,double>::FindIndex

; 464  : 		positionList.SetAt(curPos, dCurData);

  00083	f2 0f 10 45 f8	 movsd	 xmm0, QWORD PTR _dCurData$1$[ebp]
  00088	5e		 pop	 esi
  00089	f2 0f 11 40 08	 movsd	 QWORD PTR [eax+8], xmm0

; 465  : 		return true;

  0008e	b0 01		 mov	 al, 1

; 466  : 	}
; 467  : 
; 468  : 	return false;
; 469  : }

  00090	8b e5		 mov	 esp, ebp
  00092	5d		 pop	 ebp
  00093	c3		 ret	 0
$LN3@MoveBlocks:

; 452  : 		return false;

  00094	32 c0		 xor	 al, al
  00096	5e		 pop	 esi

; 466  : 	}
; 467  : 
; 468  : 	return false;
; 469  : }

  00097	8b e5		 mov	 esp, ebp
  00099	5d		 pop	 ebp
  0009a	c3		 ret	 0
?MoveBlocksPosition@CBlocksPositionCalculator@@CA_NAAV?$CList@NN@@HH@Z ENDP ; CBlocksPositionCalculator::MoveBlocksPosition
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
;	COMDAT ?IsPtInRect@CBlocksPositionCalculator@@CA_NABVCRect@@ABVCPoint@@@Z
_TEXT	SEGMENT
_rect$ = 8						; size = 4
_point$ = 12						; size = 4
?IsPtInRect@CBlocksPositionCalculator@@CA_NABVCRect@@ABVCPoint@@@Z PROC ; CBlocksPositionCalculator::IsPtInRect, COMDAT

; 422  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 423  : 	return (rect.PtInRect(point) != 0) ? true: false;

  00003	8b 45 0c	 mov	 eax, DWORD PTR _point$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h

; 648  : 	return ::PtInRect(this, point);

  00006	ff 70 04	 push	 DWORD PTR [eax+4]
  00009	ff 30		 push	 DWORD PTR [eax]
  0000b	ff 75 08	 push	 DWORD PTR _rect$[ebp]
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PtInRect@12
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp

; 423  : 	return (rect.PtInRect(point) != 0) ? true: false;

  00014	85 c0		 test	 eax, eax
  00016	0f 95 c0	 setne	 al

; 424  : }

  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
?IsPtInRect@CBlocksPositionCalculator@@CA_NABVCRect@@ABVCPoint@@@Z ENDP ; CBlocksPositionCalculator::IsPtInRect
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
;	COMDAT ?AppropriateColumnCompartLine@CBlocksPositionCalculator@@CA_NABVCPoint@@ABV?$CList@NN@@10AAH@Z
_TEXT	SEGMENT
_columnCompartLineNum$GSCopy$1$ = -36			; size = 4
_absoluteOrgPt$GSCopy$1$ = -32				; size = 4
_point$GSCopy$1$ = -28					; size = 4
_columnList$GSCopy$1$ = -24				; size = 4
$T5 = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_absoluteOrgPt$ = 8					; size = 4
_rowList$ = 12						; size = 4
_columnList$ = 16					; size = 4
_point$ = 20						; size = 4
_columnCompartLineNum$ = 24				; size = 4
?AppropriateColumnCompartLine@CBlocksPositionCalculator@@CA_NABVCPoint@@ABV?$CList@NN@@10AAH@Z PROC ; CBlocksPositionCalculator::AppropriateColumnCompartLine, COMDAT

; 406  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 10	 mov	 eax, DWORD PTR _columnList$[ebp]
  00013	8b 55 14	 mov	 edx, DWORD PTR _point$[ebp]
  00016	8b 4d 08	 mov	 ecx, DWORD PTR _absoluteOrgPt$[ebp]
  00019	53		 push	 ebx
  0001a	56		 push	 esi
  0001b	57		 push	 edi

; 407  : 	for(int column = 1; column < columnList.GetCount() -1; column++){

  0001c	8b 78 0c	 mov	 edi, DWORD PTR [eax+12]
  0001f	be 01 00 00 00	 mov	 esi, 1
  00024	89 45 e8	 mov	 DWORD PTR _columnList$GSCopy$1$[ebp], eax
  00027	89 55 e4	 mov	 DWORD PTR _point$GSCopy$1$[ebp], edx
  0002a	8b 55 18	 mov	 edx, DWORD PTR _columnCompartLineNum$[ebp]
  0002d	8d 47 ff	 lea	 eax, DWORD PTR [edi-1]
  00030	89 4d e0	 mov	 DWORD PTR _absoluteOrgPt$GSCopy$1$[ebp], ecx
  00033	89 55 dc	 mov	 DWORD PTR _columnCompartLineNum$GSCopy$1$[ebp], edx
  00036	3b c6		 cmp	 eax, esi
  00038	0f 8e f2 00 00
	00		 jle	 $LN3@Appropriat
  0003e	8b d7		 mov	 edx, edi
$LL4@Appropriat:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 1133 : 	if (nIndex >= m_nCount || nIndex < 0)

  00040	8b 45 0c	 mov	 eax, DWORD PTR _rowList$[ebp]
  00043	66 0f 6e 59 04	 movd	 xmm3, DWORD PTR [ecx+4]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp

; 408  : 		CPoint start( ( int)GetAbsolutePosition(absoluteOrgPt.x, columnList, column) - m_nMouseClickThickness, 

  00048	f3 0f e6 db	 cvtdq2pd xmm3, xmm3
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 1133 : 	if (nIndex >= m_nCount || nIndex < 0)

  0004c	8b 58 0c	 mov	 ebx, DWORD PTR [eax+12]
  0004f	85 db		 test	 ebx, ebx
  00051	7e 11		 jle	 SHORT $LN8@Appropriat

; 1141 : 	}
; 1142 : 	return (POSITION) pNode;

  00053	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp

; 314  : 	if(pos != NULL)

  00056	85 c0		 test	 eax, eax
  00058	74 0a		 je	 SHORT $LN8@Appropriat

; 315  : 		return (positionList.GetAt(pos) + absoluteOrgPt);

  0005a	0f 28 cb	 movaps	 xmm1, xmm3
  0005d	f2 0f 58 48 08	 addsd	 xmm1, QWORD PTR [eax+8]
  00062	eb 03		 jmp	 SHORT $LN7@Appropriat
$LN8@Appropriat:

; 316  : 	return absoluteOrgPt;

  00064	0f 28 cb	 movaps	 xmm1, xmm3
$LN7@Appropriat:
  00067	66 0f 6e 11	 movd	 xmm2, DWORD PTR [ecx]

; 313  : 	POSITION pos = positionList.FindIndex(nIndex);

  0006b	8b ce		 mov	 ecx, esi

; 408  : 		CPoint start( ( int)GetAbsolutePosition(absoluteOrgPt.x, columnList, column) - m_nMouseClickThickness, 

  0006d	f3 0f e6 d2	 cvtdq2pd xmm2, xmm2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 1133 : 	if (nIndex >= m_nCount || nIndex < 0)

  00071	3b f2		 cmp	 esi, edx
  00073	7d 21		 jge	 SHORT $LN17@Appropriat
  00075	85 f6		 test	 esi, esi
  00077	78 1d		 js	 SHORT $LN17@Appropriat

; 1134 : 		return NULL;  // went too far
; 1135 : 
; 1136 : 	CNode* pNode = m_pNodeHead;

  00079	8b 45 e8	 mov	 eax, DWORD PTR _columnList$GSCopy$1$[ebp]
  0007c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 1137 : 	while (nIndex--)

  0007f	74 07		 je	 SHORT $LN61@Appropriat
$LL20@Appropriat:

; 1138 : 	{
; 1139 : 		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 1140 : 		pNode = pNode->pNext;

  00081	8b 00		 mov	 eax, DWORD PTR [eax]
  00083	83 e9 01	 sub	 ecx, 1
  00086	75 f9		 jne	 SHORT $LL20@Appropriat
$LN61@Appropriat:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp

; 314  : 	if(pos != NULL)

  00088	85 c0		 test	 eax, eax
  0008a	74 0a		 je	 SHORT $LN17@Appropriat

; 315  : 		return (positionList.GetAt(pos) + absoluteOrgPt);

  0008c	0f 28 c2	 movaps	 xmm0, xmm2
  0008f	f2 0f 58 40 08	 addsd	 xmm0, QWORD PTR [eax+8]
  00094	eb 03		 jmp	 SHORT $LN16@Appropriat
$LN17@Appropriat:

; 316  : 	return absoluteOrgPt;

  00096	0f 28 c2	 movaps	 xmm0, xmm2
$LN16@Appropriat:

; 408  : 		CPoint start( ( int)GetAbsolutePosition(absoluteOrgPt.x, columnList, column) - m_nMouseClickThickness, 

  00099	f2 0f 2c d0	 cvttsd2si edx, xmm0

; 410  : 		CPoint end( ( int)GetAbsolutePosition(absoluteOrgPt.x, columnList, column) + m_nMouseClickThickness, 

  0009d	8d 43 ff	 lea	 eax, DWORD PTR [ebx-1]
  000a0	2b 15 00 00 00
	00		 sub	 edx, DWORD PTR ?m_nMouseClickThickness@CBlocksPositionCalculator@@0HA ; CBlocksPositionCalculator::m_nMouseClickThickness
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 1133 : 	if (nIndex >= m_nCount || nIndex < 0)

  000a6	3b c3		 cmp	 eax, ebx
  000a8	7d 1c		 jge	 SHORT $LN28@Appropriat
  000aa	85 c0		 test	 eax, eax
  000ac	78 18		 js	 SHORT $LN28@Appropriat

; 1134 : 		return NULL;  // went too far
; 1135 : 
; 1136 : 	CNode* pNode = m_pNodeHead;

  000ae	8b 4d 0c	 mov	 ecx, DWORD PTR _rowList$[ebp]
  000b1	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]

; 1137 : 	while (nIndex--)

  000b4	74 07		 je	 SHORT $LN63@Appropriat
$LL31@Appropriat:

; 1138 : 	{
; 1139 : 		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 1140 : 		pNode = pNode->pNext;

  000b6	8b 09		 mov	 ecx, DWORD PTR [ecx]
  000b8	83 e8 01	 sub	 eax, 1
  000bb	75 f9		 jne	 SHORT $LL31@Appropriat
$LN63@Appropriat:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp

; 314  : 	if(pos != NULL)

  000bd	85 c9		 test	 ecx, ecx
  000bf	74 05		 je	 SHORT $LN28@Appropriat

; 315  : 		return (positionList.GetAt(pos) + absoluteOrgPt);

  000c1	f2 0f 58 59 08	 addsd	 xmm3, QWORD PTR [ecx+8]
$LN28@Appropriat:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 1133 : 	if (nIndex >= m_nCount || nIndex < 0)

  000c6	8b 5d e8	 mov	 ebx, DWORD PTR _columnList$GSCopy$1$[ebp]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp

; 313  : 	POSITION pos = positionList.FindIndex(nIndex);

  000c9	8b ce		 mov	 ecx, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 1133 : 	if (nIndex >= m_nCount || nIndex < 0)

  000cb	3b f7		 cmp	 esi, edi
  000cd	7d 19		 jge	 SHORT $LN37@Appropriat
  000cf	85 f6		 test	 esi, esi
  000d1	78 15		 js	 SHORT $LN37@Appropriat

; 1134 : 		return NULL;  // went too far
; 1135 : 
; 1136 : 	CNode* pNode = m_pNodeHead;

  000d3	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]

; 1137 : 	while (nIndex--)

  000d6	74 07		 je	 SHORT $LN65@Appropriat
$LL40@Appropriat:

; 1138 : 	{
; 1139 : 		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 1140 : 		pNode = pNode->pNext;

  000d8	8b 00		 mov	 eax, DWORD PTR [eax]
  000da	83 e9 01	 sub	 ecx, 1
  000dd	75 f9		 jne	 SHORT $LL40@Appropriat
$LN65@Appropriat:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp

; 314  : 	if(pos != NULL)

  000df	85 c0		 test	 eax, eax
  000e1	74 05		 je	 SHORT $LN37@Appropriat

; 315  : 		return (positionList.GetAt(pos) + absoluteOrgPt);

  000e3	f2 0f 58 50 08	 addsd	 xmm2, QWORD PTR [eax+8]
$LN37@Appropriat:

; 410  : 		CPoint end( ( int)GetAbsolutePosition(absoluteOrgPt.x, columnList, column) + m_nMouseClickThickness, 

  000e8	f2 0f 2c c3	 cvttsd2si eax, xmm3
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h

; 568  : 	left = topLeft.x;

  000ec	89 55 ec	 mov	 DWORD PTR $T5[ebp], edx
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp

; 410  : 		CPoint end( ( int)GetAbsolutePosition(absoluteOrgPt.x, columnList, column) + m_nMouseClickThickness, 

  000ef	f2 0f 2c ca	 cvttsd2si ecx, xmm2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h

; 571  : 	bottom = bottomRight.y;

  000f3	89 45 f8	 mov	 DWORD PTR $T5[ebp+12], eax

; 648  : 	return ::PtInRect(this, point);

  000f6	8b 45 e4	 mov	 eax, DWORD PTR _point$GSCopy$1$[ebp]
  000f9	ff 70 04	 push	 DWORD PTR [eax+4]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp

; 410  : 		CPoint end( ( int)GetAbsolutePosition(absoluteOrgPt.x, columnList, column) + m_nMouseClickThickness, 

  000fc	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?m_nMouseClickThickness@CBlocksPositionCalculator@@0HA ; CBlocksPositionCalculator::m_nMouseClickThickness
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h

; 648  : 	return ::PtInRect(this, point);

  00102	ff 30		 push	 DWORD PTR [eax]

; 569  : 	top = topLeft.y;

  00104	f2 0f 2c d1	 cvttsd2si edx, xmm1

; 648  : 	return ::PtInRect(this, point);

  00108	8d 45 ec	 lea	 eax, DWORD PTR $T5[ebp]

; 570  : 	right = bottomRight.x;

  0010b	89 4d f4	 mov	 DWORD PTR $T5[ebp+8], ecx

; 648  : 	return ::PtInRect(this, point);

  0010e	50		 push	 eax

; 569  : 	top = topLeft.y;

  0010f	89 55 f0	 mov	 DWORD PTR $T5[ebp+4], edx

; 648  : 	return ::PtInRect(this, point);

  00112	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PtInRect@12
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp

; 423  : 	return (rect.PtInRect(point) != 0) ? true: false;

  00118	85 c0		 test	 eax, eax

; 411  : 				( int)GetAbsolutePosition(absoluteOrgPt.y, rowList, rowList.GetCount()-1));
; 412  : 		if(IsPtInRect(CRect(start, end), point)){

  0011a	75 27		 jne	 SHORT $LN58@Appropriat

; 407  : 	for(int column = 1; column < columnList.GetCount() -1; column++){

  0011c	8b 7b 0c	 mov	 edi, DWORD PTR [ebx+12]
  0011f	46		 inc	 esi
  00120	8b 4d e0	 mov	 ecx, DWORD PTR _absoluteOrgPt$GSCopy$1$[ebp]
  00123	8b d7		 mov	 edx, edi
  00125	8d 47 ff	 lea	 eax, DWORD PTR [edi-1]
  00128	3b f0		 cmp	 esi, eax
  0012a	0f 8c 10 ff ff
	ff		 jl	 $LL4@Appropriat
$LN3@Appropriat:
  00130	5f		 pop	 edi

; 414  : 			return true;
; 415  : 		}
; 416  : 	}
; 417  : 	return false;
; 418  : }

  00131	5e		 pop	 esi
  00132	32 c0		 xor	 al, al
  00134	5b		 pop	 ebx
  00135	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00138	33 cd		 xor	 ecx, ebp
  0013a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0013f	8b e5		 mov	 esp, ebp
  00141	5d		 pop	 ebp
  00142	c3		 ret	 0
$LN58@Appropriat:

; 413  : 			columnCompartLineNum = column;

  00143	8b 45 dc	 mov	 eax, DWORD PTR _columnCompartLineNum$GSCopy$1$[ebp]

; 414  : 			return true;
; 415  : 		}
; 416  : 	}
; 417  : 	return false;
; 418  : }

  00146	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00149	5f		 pop	 edi
  0014a	33 cd		 xor	 ecx, ebp
  0014c	89 30		 mov	 DWORD PTR [eax], esi
  0014e	b0 01		 mov	 al, 1
  00150	5e		 pop	 esi
  00151	5b		 pop	 ebx
  00152	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00157	8b e5		 mov	 esp, ebp
  00159	5d		 pop	 ebp
  0015a	c3		 ret	 0
?AppropriateColumnCompartLine@CBlocksPositionCalculator@@CA_NABVCPoint@@ABV?$CList@NN@@10AAH@Z ENDP ; CBlocksPositionCalculator::AppropriateColumnCompartLine
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
;	COMDAT ?AppropriateRowCompartLine@CBlocksPositionCalculator@@CA_NABVCPoint@@ABV?$CList@NN@@10AAH@Z
_TEXT	SEGMENT
_rowCompartLineNum$GSCopy$1$ = -36			; size = 4
_point$GSCopy$1$ = -32					; size = 4
_columnList$GSCopy$1$ = -28				; size = 4
_absoluteOrgPt$GSCopy$1$ = -24				; size = 4
$T5 = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_absoluteOrgPt$ = 8					; size = 4
_rowList$ = 12						; size = 4
_columnList$ = 16					; size = 4
_point$ = 20						; size = 4
_rowCompartLineNum$ = 24				; size = 4
?AppropriateRowCompartLine@CBlocksPositionCalculator@@CA_NABVCPoint@@ABV?$CList@NN@@10AAH@Z PROC ; CBlocksPositionCalculator::AppropriateRowCompartLine, COMDAT

; 389  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _absoluteOrgPt$[ebp]
  00013	8b 4d 10	 mov	 ecx, DWORD PTR _columnList$[ebp]
  00016	53		 push	 ebx

; 390  : 	for(int row = 1; row < rowList.GetCount() -1; row++){

  00017	8b 5d 0c	 mov	 ebx, DWORD PTR _rowList$[ebp]
  0001a	89 45 e8	 mov	 DWORD PTR _absoluteOrgPt$GSCopy$1$[ebp], eax
  0001d	8b 45 14	 mov	 eax, DWORD PTR _point$[ebp]
  00020	89 45 e0	 mov	 DWORD PTR _point$GSCopy$1$[ebp], eax
  00023	8b 53 0c	 mov	 edx, DWORD PTR [ebx+12]
  00026	8b 45 18	 mov	 eax, DWORD PTR _rowCompartLineNum$[ebp]
  00029	56		 push	 esi
  0002a	89 45 dc	 mov	 DWORD PTR _rowCompartLineNum$GSCopy$1$[ebp], eax
  0002d	be 01 00 00 00	 mov	 esi, 1
  00032	8d 42 ff	 lea	 eax, DWORD PTR [edx-1]
  00035	89 4d e4	 mov	 DWORD PTR _columnList$GSCopy$1$[ebp], ecx
  00038	57		 push	 edi
  00039	3b c6		 cmp	 eax, esi
  0003b	0f 8e fa 00 00
	00		 jle	 $LN3@Appropriat
  00041	8b fa		 mov	 edi, edx
$LL4@Appropriat:

; 391  : 		CPoint start( ( int)GetAbsolutePosition(absoluteOrgPt.x, columnList, 0), 

  00043	8b 45 e8	 mov	 eax, DWORD PTR _absoluteOrgPt$GSCopy$1$[ebp]

; 313  : 	POSITION pos = positionList.FindIndex(nIndex);

  00046	8b ce		 mov	 ecx, esi
  00048	66 0f 6e 58 04	 movd	 xmm3, DWORD PTR [eax+4]

; 391  : 		CPoint start( ( int)GetAbsolutePosition(absoluteOrgPt.x, columnList, 0), 

  0004d	f3 0f e6 db	 cvtdq2pd xmm3, xmm3
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 1133 : 	if (nIndex >= m_nCount || nIndex < 0)

  00051	3b f7		 cmp	 esi, edi
  00053	7d 20		 jge	 SHORT $LN8@Appropriat
  00055	85 f6		 test	 esi, esi
  00057	78 1c		 js	 SHORT $LN8@Appropriat

; 1134 : 		return NULL;  // went too far
; 1135 : 
; 1136 : 	CNode* pNode = m_pNodeHead;

  00059	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]

; 1137 : 	while (nIndex--)

  0005c	74 09		 je	 SHORT $LN59@Appropriat
  0005e	66 90		 npad	 2
$LL11@Appropriat:

; 1138 : 	{
; 1139 : 		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 1140 : 		pNode = pNode->pNext;

  00060	8b 00		 mov	 eax, DWORD PTR [eax]
  00062	83 e9 01	 sub	 ecx, 1
  00065	75 f9		 jne	 SHORT $LL11@Appropriat
$LN59@Appropriat:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp

; 314  : 	if(pos != NULL)

  00067	85 c0		 test	 eax, eax
  00069	74 0a		 je	 SHORT $LN8@Appropriat

; 315  : 		return (positionList.GetAt(pos) + absoluteOrgPt);

  0006b	0f 28 c3	 movaps	 xmm0, xmm3
  0006e	f2 0f 58 40 08	 addsd	 xmm0, QWORD PTR [eax+8]
  00073	eb 03		 jmp	 SHORT $LN7@Appropriat
$LN8@Appropriat:

; 316  : 	return absoluteOrgPt;

  00075	0f 28 c3	 movaps	 xmm0, xmm3
$LN7@Appropriat:

; 391  : 		CPoint start( ( int)GetAbsolutePosition(absoluteOrgPt.x, columnList, 0), 

  00078	8b 45 e8	 mov	 eax, DWORD PTR _absoluteOrgPt$GSCopy$1$[ebp]
  0007b	66 0f 6e 10	 movd	 xmm2, DWORD PTR [eax]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 1133 : 	if (nIndex >= m_nCount || nIndex < 0)

  0007f	8b 45 e4	 mov	 eax, DWORD PTR _columnList$GSCopy$1$[ebp]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp

; 391  : 		CPoint start( ( int)GetAbsolutePosition(absoluteOrgPt.x, columnList, 0), 

  00082	f3 0f e6 d2	 cvtdq2pd xmm2, xmm2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 1133 : 	if (nIndex >= m_nCount || nIndex < 0)

  00086	8b 78 0c	 mov	 edi, DWORD PTR [eax+12]
  00089	85 ff		 test	 edi, edi
  0008b	7e 11		 jle	 SHORT $LN17@Appropriat

; 1134 : 		return NULL;  // went too far
; 1135 : 
; 1136 : 	CNode* pNode = m_pNodeHead;

  0008d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp

; 314  : 	if(pos != NULL)

  00090	85 c0		 test	 eax, eax
  00092	74 0a		 je	 SHORT $LN17@Appropriat

; 315  : 		return (positionList.GetAt(pos) + absoluteOrgPt);

  00094	0f 28 ca	 movaps	 xmm1, xmm2
  00097	f2 0f 58 48 08	 addsd	 xmm1, QWORD PTR [eax+8]
  0009c	eb 03		 jmp	 SHORT $LN16@Appropriat
$LN17@Appropriat:

; 316  : 	return absoluteOrgPt;

  0009e	0f 28 ca	 movaps	 xmm1, xmm2
$LN16@Appropriat:

; 391  : 		CPoint start( ( int)GetAbsolutePosition(absoluteOrgPt.x, columnList, 0), 

  000a1	f2 0f 2c d8	 cvttsd2si ebx, xmm0

; 313  : 	POSITION pos = positionList.FindIndex(nIndex);

  000a5	8b ce		 mov	 ecx, esi

; 391  : 		CPoint start( ( int)GetAbsolutePosition(absoluteOrgPt.x, columnList, 0), 

  000a7	2b 1d 00 00 00
	00		 sub	 ebx, DWORD PTR ?m_nMouseClickThickness@CBlocksPositionCalculator@@0HA ; CBlocksPositionCalculator::m_nMouseClickThickness
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 1133 : 	if (nIndex >= m_nCount || nIndex < 0)

  000ad	3b f2		 cmp	 esi, edx
  000af	7d 1f		 jge	 SHORT $LN28@Appropriat
  000b1	85 f6		 test	 esi, esi
  000b3	78 1b		 js	 SHORT $LN28@Appropriat

; 1134 : 		return NULL;  // went too far
; 1135 : 
; 1136 : 	CNode* pNode = m_pNodeHead;

  000b5	8b 45 0c	 mov	 eax, DWORD PTR _rowList$[ebp]
  000b8	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 1137 : 	while (nIndex--)

  000bb	74 0a		 je	 SHORT $LN63@Appropriat
  000bd	0f 1f 00	 npad	 3
$LL31@Appropriat:

; 1138 : 	{
; 1139 : 		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 1140 : 		pNode = pNode->pNext;

  000c0	8b 00		 mov	 eax, DWORD PTR [eax]
  000c2	83 e9 01	 sub	 ecx, 1
  000c5	75 f9		 jne	 SHORT $LL31@Appropriat
$LN63@Appropriat:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp

; 314  : 	if(pos != NULL)

  000c7	85 c0		 test	 eax, eax
  000c9	74 05		 je	 SHORT $LN28@Appropriat

; 315  : 		return (positionList.GetAt(pos) + absoluteOrgPt);

  000cb	f2 0f 58 58 08	 addsd	 xmm3, QWORD PTR [eax+8]
$LN28@Appropriat:

; 393  : 		CPoint end( ( int)GetAbsolutePosition(absoluteOrgPt.x, columnList, columnList.GetCount()-1), 

  000d0	8d 47 ff	 lea	 eax, DWORD PTR [edi-1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 1133 : 	if (nIndex >= m_nCount || nIndex < 0)

  000d3	3b c7		 cmp	 eax, edi
  000d5	7d 1c		 jge	 SHORT $LN37@Appropriat
  000d7	85 c0		 test	 eax, eax
  000d9	78 18		 js	 SHORT $LN37@Appropriat

; 1134 : 		return NULL;  // went too far
; 1135 : 
; 1136 : 	CNode* pNode = m_pNodeHead;

  000db	8b 4d e4	 mov	 ecx, DWORD PTR _columnList$GSCopy$1$[ebp]
  000de	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]

; 1137 : 	while (nIndex--)

  000e1	74 07		 je	 SHORT $LN65@Appropriat
$LL40@Appropriat:

; 1138 : 	{
; 1139 : 		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 1140 : 		pNode = pNode->pNext;

  000e3	8b 09		 mov	 ecx, DWORD PTR [ecx]
  000e5	83 e8 01	 sub	 eax, 1
  000e8	75 f9		 jne	 SHORT $LL40@Appropriat
$LN65@Appropriat:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp

; 314  : 	if(pos != NULL)

  000ea	85 c9		 test	 ecx, ecx
  000ec	74 05		 je	 SHORT $LN37@Appropriat

; 315  : 		return (positionList.GetAt(pos) + absoluteOrgPt);

  000ee	f2 0f 58 51 08	 addsd	 xmm2, QWORD PTR [ecx+8]
$LN37@Appropriat:

; 393  : 		CPoint end( ( int)GetAbsolutePosition(absoluteOrgPt.x, columnList, columnList.GetCount()-1), 

  000f3	f2 0f 2c c3	 cvttsd2si eax, xmm3
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h

; 569  : 	top = topLeft.y;

  000f7	89 5d f0	 mov	 DWORD PTR $T5[ebp+4], ebx
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp

; 393  : 		CPoint end( ( int)GetAbsolutePosition(absoluteOrgPt.x, columnList, columnList.GetCount()-1), 

  000fa	f2 0f 2c ca	 cvttsd2si ecx, xmm2
  000fe	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?m_nMouseClickThickness@CBlocksPositionCalculator@@0HA ; CBlocksPositionCalculator::m_nMouseClickThickness
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h

; 571  : 	bottom = bottomRight.y;

  00104	89 45 f8	 mov	 DWORD PTR $T5[ebp+12], eax

; 648  : 	return ::PtInRect(this, point);

  00107	8b 45 e0	 mov	 eax, DWORD PTR _point$GSCopy$1$[ebp]
  0010a	ff 70 04	 push	 DWORD PTR [eax+4]

; 568  : 	left = topLeft.x;

  0010d	f2 0f 2c d1	 cvttsd2si edx, xmm1

; 570  : 	right = bottomRight.x;

  00111	89 4d f4	 mov	 DWORD PTR $T5[ebp+8], ecx

; 648  : 	return ::PtInRect(this, point);

  00114	ff 30		 push	 DWORD PTR [eax]
  00116	8d 45 ec	 lea	 eax, DWORD PTR $T5[ebp]

; 568  : 	left = topLeft.x;

  00119	89 55 ec	 mov	 DWORD PTR $T5[ebp], edx

; 648  : 	return ::PtInRect(this, point);

  0011c	50		 push	 eax
  0011d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PtInRect@12
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp

; 423  : 	return (rect.PtInRect(point) != 0) ? true: false;

  00123	85 c0		 test	 eax, eax

; 394  : 				( int)GetAbsolutePosition(absoluteOrgPt.y, rowList, row) +m_nMouseClickThickness);
; 395  : 		if(IsPtInRect(CRect(start, end), point)){

  00125	75 27		 jne	 SHORT $LN58@Appropriat

; 390  : 	for(int row = 1; row < rowList.GetCount() -1; row++){

  00127	8b 5d 0c	 mov	 ebx, DWORD PTR _rowList$[ebp]
  0012a	46		 inc	 esi
  0012b	8b 53 0c	 mov	 edx, DWORD PTR [ebx+12]
  0012e	8b fa		 mov	 edi, edx
  00130	8d 42 ff	 lea	 eax, DWORD PTR [edx-1]
  00133	3b f0		 cmp	 esi, eax
  00135	0f 8c 08 ff ff
	ff		 jl	 $LL4@Appropriat
$LN3@Appropriat:
  0013b	5f		 pop	 edi

; 397  : 			return true;
; 398  : 		}
; 399  : 	}
; 400  : 	return false;
; 401  : }

  0013c	5e		 pop	 esi
  0013d	32 c0		 xor	 al, al
  0013f	5b		 pop	 ebx
  00140	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00143	33 cd		 xor	 ecx, ebp
  00145	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0014a	8b e5		 mov	 esp, ebp
  0014c	5d		 pop	 ebp
  0014d	c3		 ret	 0
$LN58@Appropriat:

; 396  : 			rowCompartLineNum = row;

  0014e	8b 45 dc	 mov	 eax, DWORD PTR _rowCompartLineNum$GSCopy$1$[ebp]

; 397  : 			return true;
; 398  : 		}
; 399  : 	}
; 400  : 	return false;
; 401  : }

  00151	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00154	5f		 pop	 edi
  00155	33 cd		 xor	 ecx, ebp
  00157	89 30		 mov	 DWORD PTR [eax], esi
  00159	b0 01		 mov	 al, 1
  0015b	5e		 pop	 esi
  0015c	5b		 pop	 ebx
  0015d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00162	8b e5		 mov	 esp, ebp
  00164	5d		 pop	 ebp
  00165	c3		 ret	 0
?AppropriateRowCompartLine@CBlocksPositionCalculator@@CA_NABVCPoint@@ABV?$CList@NN@@10AAH@Z ENDP ; CBlocksPositionCalculator::AppropriateRowCompartLine
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
;	COMDAT ?GetChangedPosition@CBlocksPositionCalculator@@CAHHHHHH@Z
_TEXT	SEGMENT
_oldAllRegionLength$ = 8				; size = 4
_newAllRegionLength$ = 12				; size = 4
_oldPositionValue$ = 16					; size = 4
_posNum$ = 20						; size = 4
_blockCount$ = 24					; size = 4
?GetChangedPosition@CBlocksPositionCalculator@@CAHHHHHH@Z PROC ; CBlocksPositionCalculator::GetChangedPosition, COMDAT

; 369  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 370  : 	// list count == 0 
; 371  : 	//		-->  
; 372  : 	//  -->  
; 373  : 
; 374  : 	if(posNum == 0)

  00003	8b 45 14	 mov	 eax, DWORD PTR _posNum$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 45		 je	 SHORT $LN7@GetChanged

; 375  : 		return oldPositionValue;
; 376  : 	else if(posNum == blockCount)

  0000a	3b 45 18	 cmp	 eax, DWORD PTR _blockCount$[ebp]
  0000d	75 05		 jne	 SHORT $LN4@GetChanged

; 377  : 		return newAllRegionLength;

  0000f	8b 45 0c	 mov	 eax, DWORD PTR _newAllRegionLength$[ebp]

; 383  : }

  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
$LN4@GetChanged:

; 378  : 
; 379  : 	if(oldAllRegionLength == 0)

  00014	8b 45 08	 mov	 eax, DWORD PTR _oldAllRegionLength$[ebp]
  00017	85 c0		 test	 eax, eax
  00019	74 34		 je	 SHORT $LN7@GetChanged

; 381  : 
; 382  : 	return CMath::Round(((double)newAllRegionLength*(double)oldPositionValue)/(double)oldAllRegionLength);

  0001b	66 0f 6e 4d 0c	 movd	 xmm1, DWORD PTR _newAllRegionLength$[ebp]
  00020	83 ec 08	 sub	 esp, 8
  00023	66 0f 6e 45 10	 movd	 xmm0, DWORD PTR _oldPositionValue$[ebp]
  00028	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  0002c	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1
  00030	f2 0f 59 c8	 mulsd	 xmm1, xmm0
  00034	66 0f 6e c0	 movd	 xmm0, eax
  00038	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  0003c	f2 0f 5e c8	 divsd	 xmm1, xmm0
  00040	f2 0f 11 0c 24	 movsd	 QWORD PTR [esp], xmm1
  00045	e8 00 00 00 00	 call	 ?Round@CMath@@SAHN@Z	; CMath::Round
  0004a	83 c4 08	 add	 esp, 8

; 383  : }

  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
$LN7@GetChanged:

; 380  : 		return oldPositionValue;

  0004f	8b 45 10	 mov	 eax, DWORD PTR _oldPositionValue$[ebp]

; 383  : }

  00052	5d		 pop	 ebp
  00053	c3		 ret	 0
?GetChangedPosition@CBlocksPositionCalculator@@CAHHHHHH@Z ENDP ; CBlocksPositionCalculator::GetChangedPosition
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
;	COMDAT ?InitializePositions@CBlocksPositionCalculator@@CAXAAV?$CList@HH@@HHHH@Z
_TEXT	SEGMENT
_realBlockCount$1$ = -4					; size = 4
_prePosition$1$ = 8					; size = 4
_positionList$ = 8					; size = 4
_nDoubleSizeBlockNum$ = 12				; size = 4
_allRegionLength$ = 16					; size = 4
_interBlockHalfGap$ = 20				; size = 4
_compartLineThickness$ = 24				; size = 4
?InitializePositions@CBlocksPositionCalculator@@CAXAAV?$CList@HH@@HHHH@Z PROC ; CBlocksPositionCalculator::InitializePositions, COMDAT

; 331  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 332  : 	POSITION pos = positionList.GetHeadPosition();

  00004	8b 45 08	 mov	 eax, DWORD PTR _positionList$[ebp]
  00007	57		 push	 edi
  00008	8b 78 04	 mov	 edi, DWORD PTR [eax+4]

; 333  : 	if(pos == NULL)

  0000b	85 ff		 test	 edi, edi
  0000d	74 69		 je	 SHORT $LN3@Initialize

; 334  : 		return;
; 335  : 
; 336  : 	int nBlockCount = positionList.GetCount() -1;

  0000f	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]

; 262  : 	if(doubleSizeBlockNum < 0 || doubleSizeBlockNum >= blockCount)

  00012	8b 4d 0c	 mov	 ecx, DWORD PTR _nDoubleSizeBlockNum$[ebp]

; 334  : 		return;
; 335  : 
; 336  : 	int nBlockCount = positionList.GetCount() -1;

  00015	48		 dec	 eax
  00016	53		 push	 ebx
  00017	56		 push	 esi

; 262  : 	if(doubleSizeBlockNum < 0 || doubleSizeBlockNum >= blockCount)

  00018	85 c9		 test	 ecx, ecx
  0001a	78 0f		 js	 SHORT $LN9@Initialize
  0001c	3b c8		 cmp	 ecx, eax
  0001e	7d 0b		 jge	 SHORT $LN9@Initialize

; 264  : 
; 265  : 	return (blockCount > 2 ? 2: 1);

  00020	33 db		 xor	 ebx, ebx
  00022	83 f8 02	 cmp	 eax, 2
  00025	0f 9f c3	 setg	 bl
  00028	43		 inc	 ebx
  00029	eb 02		 jmp	 SHORT $LN7@Initialize
$LN9@Initialize:

; 263  : 		return 0;

  0002b	33 db		 xor	 ebx, ebx
$LN7@Initialize:

; 337  : 	int doubleSizeCount = GetDoubleSizeBlockCount(nBlockCount, nDoubleSizeBlockNum);
; 338  : 	int realBlockCount = nBlockCount + doubleSizeCount;

  0002d	03 c3		 add	 eax, ebx

; 339  : 	int prePosition = 0, posNum = 0;

  0002f	33 c9		 xor	 ecx, ecx
  00031	89 45 fc	 mov	 DWORD PTR _realBlockCount$1$[ebp], eax
  00034	33 f6		 xor	 esi, esi
  00036	89 4d 08	 mov	 DWORD PTR _prePosition$1$[ebp], ecx
  00039	0f 1f 80 00 00
	00 00		 npad	 7
$LL2@Initialize:

; 341  : 		int length = GetPositionLength(prePosition, allRegionLength, posNum, realBlockCount, interBlockHalfGap, compartLineThickness);

  00040	ff 75 18	 push	 DWORD PTR _compartLineThickness$[ebp]
  00043	ff 75 14	 push	 DWORD PTR _interBlockHalfGap$[ebp]
  00046	50		 push	 eax
  00047	56		 push	 esi
  00048	ff 75 10	 push	 DWORD PTR _allRegionLength$[ebp]
  0004b	51		 push	 ecx
  0004c	e8 00 00 00 00	 call	 ?GetPositionLength@CBlocksPositionCalculator@@SAHHHHHHH@Z ; CBlocksPositionCalculator::GetPositionLength

; 342  : 		prePosition += length;

  00051	8b 4d 08	 mov	 ecx, DWORD PTR _prePosition$1$[ebp]
  00054	83 c4 18	 add	 esp, 24			; 00000018H
  00057	03 c8		 add	 ecx, eax

; 270  : 	return (curNum > doubleSizeBlockNum && curNum <= (doubleSizeBlockNum + doubleSizeCount));

  00059	8b 45 0c	 mov	 eax, DWORD PTR _nDoubleSizeBlockNum$[ebp]

; 342  : 		prePosition += length;

  0005c	89 4d 08	 mov	 DWORD PTR _prePosition$1$[ebp], ecx

; 270  : 	return (curNum > doubleSizeBlockNum && curNum <= (doubleSizeBlockNum + doubleSizeCount));

  0005f	3b f0		 cmp	 esi, eax
  00061	7e 06		 jle	 SHORT $LN13@Initialize
  00063	03 c3		 add	 eax, ebx
  00065	3b f0		 cmp	 esi, eax
  00067	7e 05		 jle	 SHORT $LN23@Initialize
$LN13@Initialize:

; 343  : 		if(IsBlockInDoubleSize(nDoubleSizeBlockNum, doubleSizeCount, posNum++))
; 344  : 			continue;
; 345  : 		positionList.SetAt(pos, prePosition);

  00069	89 4f 08	 mov	 DWORD PTR [edi+8], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 813  : 		rPosition = (POSITION) pNode->pNext;

  0006c	8b 3f		 mov	 edi, DWORD PTR [edi]
$LN23@Initialize:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp

; 340  : 	while(pos != NULL){

  0006e	8b 45 fc	 mov	 eax, DWORD PTR _realBlockCount$1$[ebp]
  00071	46		 inc	 esi
  00072	85 ff		 test	 edi, edi
  00074	75 ca		 jne	 SHORT $LL2@Initialize
  00076	5e		 pop	 esi
  00077	5b		 pop	 ebx
$LN3@Initialize:
  00078	5f		 pop	 edi

; 346  : 		positionList.GetNext(pos);
; 347  : 	}
; 348  : }

  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
?InitializePositions@CBlocksPositionCalculator@@CAXAAV?$CList@HH@@HHHH@Z ENDP ; CBlocksPositionCalculator::InitializePositions
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
;	COMDAT ?GetBlockLength@CBlocksPositionCalculator@@CAHHHHHHHH@Z
_TEXT	SEGMENT
_start$ = 8						; size = 4
_end$ = 12						; size = 4
_blockCount$ = 16					; size = 4
_gapCount$ = 20						; size = 4
_compartLineCount$ = 24					; size = 4
_interBlockHalfGap$ = 28				; size = 4
_compartLineThickness$ = 32				; size = 4
?GetBlockLength@CBlocksPositionCalculator@@CAHHHHHHHH@Z PROC ; CBlocksPositionCalculator::GetBlockLength, COMDAT

; 323  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 324  : 	return CMath::Round((double)((end - start) - interBlockHalfGap*gapCount - compartLineCount*compartLineThickness) / (double)blockCount);

  00003	8b 45 14	 mov	 eax, DWORD PTR _gapCount$[ebp]
  00006	83 ec 08	 sub	 esp, 8
  00009	0f af 45 1c	 imul	 eax, DWORD PTR _interBlockHalfGap$[ebp]
  0000d	8b 4d 0c	 mov	 ecx, DWORD PTR _end$[ebp]
  00010	66 0f 6e 45 10	 movd	 xmm0, DWORD PTR _blockCount$[ebp]
  00015	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00019	2b c8		 sub	 ecx, eax
  0001b	8b 45 18	 mov	 eax, DWORD PTR _compartLineCount$[ebp]
  0001e	0f af 45 20	 imul	 eax, DWORD PTR _compartLineThickness$[ebp]
  00022	2b c8		 sub	 ecx, eax
  00024	2b 4d 08	 sub	 ecx, DWORD PTR _start$[ebp]
  00027	66 0f 6e c9	 movd	 xmm1, ecx
  0002b	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1
  0002f	f2 0f 5e c8	 divsd	 xmm1, xmm0
  00033	f2 0f 11 0c 24	 movsd	 QWORD PTR [esp], xmm1
  00038	e8 00 00 00 00	 call	 ?Round@CMath@@SAHN@Z	; CMath::Round
  0003d	83 c4 08	 add	 esp, 8

; 325  : }

  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
?GetBlockLength@CBlocksPositionCalculator@@CAHHHHHHHH@Z ENDP ; CBlocksPositionCalculator::GetBlockLength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
;	COMDAT ?GetAbsolutePosition@CBlocksPositionCalculator@@CANNABV?$CList@NN@@H@Z
_TEXT	SEGMENT
_absoluteOrgPt$ = 8					; size = 8
_positionList$ = 16					; size = 4
_nIndex$ = 20						; size = 4
?GetAbsolutePosition@CBlocksPositionCalculator@@CANNABV?$CList@NN@@H@Z PROC ; CBlocksPositionCalculator::GetAbsolutePosition, COMDAT

; 312  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 1133 : 	if (nIndex >= m_nCount || nIndex < 0)

  00003	8b 4d 10	 mov	 ecx, DWORD PTR _positionList$[ebp]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp

; 313  : 	POSITION pos = positionList.FindIndex(nIndex);

  00006	8b 45 14	 mov	 eax, DWORD PTR _nIndex$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 1133 : 	if (nIndex >= m_nCount || nIndex < 0)

  00009	3b 41 0c	 cmp	 eax, DWORD PTR [ecx+12]
  0000c	7d 1c		 jge	 SHORT $LN2@GetAbsolut
  0000e	85 c0		 test	 eax, eax
  00010	78 18		 js	 SHORT $LN2@GetAbsolut

; 1134 : 		return NULL;  // went too far
; 1135 : 
; 1136 : 	CNode* pNode = m_pNodeHead;

  00012	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]

; 1137 : 	while (nIndex--)

  00015	74 07		 je	 SHORT $LN11@GetAbsolut
$LL5@GetAbsolut:

; 1138 : 	{
; 1139 : 		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 1140 : 		pNode = pNode->pNext;

  00017	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00019	83 e8 01	 sub	 eax, 1
  0001c	75 f9		 jne	 SHORT $LL5@GetAbsolut
$LN11@GetAbsolut:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp

; 314  : 	if(pos != NULL)

  0001e	85 c9		 test	 ecx, ecx
  00020	74 08		 je	 SHORT $LN2@GetAbsolut

; 315  : 		return (positionList.GetAt(pos) + absoluteOrgPt);

  00022	dd 41 08	 fld	 QWORD PTR [ecx+8]
  00025	dc 45 08	 fadd	 QWORD PTR _absoluteOrgPt$[ebp]

; 317  : }

  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
$LN2@GetAbsolut:

; 316  : 	return absoluteOrgPt;

  0002a	dd 45 08	 fld	 QWORD PTR _absoluteOrgPt$[ebp]

; 317  : }

  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
?GetAbsolutePosition@CBlocksPositionCalculator@@CANNABV?$CList@NN@@H@Z ENDP ; CBlocksPositionCalculator::GetAbsolutePosition
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
;	COMDAT ?SetBlocksPosition@CBlocksPositionCalculator@@CA_NAAV?$CList@NN@@ABV2@@Z
_TEXT	SEGMENT
_targetList$ = 8					; size = 4
_sourceList$ = 12					; size = 4
?SetBlocksPosition@CBlocksPositionCalculator@@CA_NAAV?$CList@NN@@ABV2@@Z PROC ; CBlocksPositionCalculator::SetBlocksPosition, COMDAT

; 291  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 292  : 	if(sourceList.GetCount() <= 0 || targetList.GetCount() != sourceList.GetCount())

  00003	8b 55 0c	 mov	 edx, DWORD PTR _sourceList$[ebp]
  00006	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00009	85 c0		 test	 eax, eax
  0000b	7e 2d		 jle	 SHORT $LN5@SetBlocksP
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _targetList$[ebp]
  00010	39 41 0c	 cmp	 DWORD PTR [ecx+12], eax
  00013	75 25		 jne	 SHORT $LN5@SetBlocksP

; 294  : 
; 295  : 	POSITION targetPos = targetList.GetHeadPosition();

  00015	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]

; 296  : 	POSITION sourcePos = sourceList.GetHeadPosition();

  00018	8b 42 04	 mov	 eax, DWORD PTR [edx+4]

; 297  : 	while(targetPos != NULL && sourcePos != NULL){

  0001b	85 c9		 test	 ecx, ecx
  0001d	74 17		 je	 SHORT $LN15@SetBlocksP
  0001f	90		 npad	 1
$LL2@SetBlocksP:
  00020	85 c0		 test	 eax, eax
  00022	74 12		 je	 SHORT $LN15@SetBlocksP

; 298  : 		double dData = sourceList.GetAt(sourcePos);
; 299  : 		targetList.SetAt(targetPos, dData);

  00024	f2 0f 10 40 08	 movsd	 xmm0, QWORD PTR [eax+8]
  00029	f2 0f 11 41 08	 movsd	 QWORD PTR [ecx+8], xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 813  : 		rPosition = (POSITION) pNode->pNext;

  0002e	8b 09		 mov	 ecx, DWORD PTR [ecx]

; 819  : 		rPosition = (POSITION) pNode->pNext;

  00030	8b 00		 mov	 eax, DWORD PTR [eax]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp

; 297  : 	while(targetPos != NULL && sourcePos != NULL){

  00032	85 c9		 test	 ecx, ecx
  00034	75 ea		 jne	 SHORT $LL2@SetBlocksP
$LN15@SetBlocksP:

; 300  : 
; 301  : 		targetList.GetNext(targetPos);
; 302  : 		sourceList.GetNext(sourcePos);
; 303  : 	}
; 304  : 
; 305  : 	return true;

  00036	b0 01		 mov	 al, 1

; 306  : }

  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
$LN5@SetBlocksP:

; 293  : 		return false;

  0003a	32 c0		 xor	 al, al

; 306  : }

  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
?SetBlocksPosition@CBlocksPositionCalculator@@CA_NAAV?$CList@NN@@ABV2@@Z ENDP ; CBlocksPositionCalculator::SetBlocksPosition
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
;	COMDAT ?GetBlocksPosition@CBlocksPositionCalculator@@CA_NABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAV?$CList@NN@@@Z
_TEXT	SEGMENT
_nData$1$ = -28						; size = 4
_nCount$1$ = -24					; size = 4
$T2 = -20						; size = 4
_pPrev$1$ = -16						; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_strPositon$ = 8					; size = 4
_strData$4 = 12						; size = 4
_positionList$ = 12					; size = 4
?GetBlocksPosition@CBlocksPositionCalculator@@CA_NABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAV?$CList@NN@@@Z PROC ; CBlocksPositionCalculator::GetBlocksPosition, COMDAT

; 275  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?GetBlocksPosition@CBlocksPositionCalculator@@CA_NABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAV?$CList@NN@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 867  : 	for (pNode = m_pNodeHead; pNode != NULL; pNode = pNode->pNext)

  00028	8b 75 0c	 mov	 esi, DWORD PTR _positionList$[ebp]

; 868  : 		pNode->data.~TYPE();
; 869  : 
; 870  : 	m_nCount = 0;
; 871  : 	m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
; 872  : 	m_pBlocks->FreeDataChain();

  0002b	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  0002e	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  00035	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0003c	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00043	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0004a	e8 00 00 00 00	 call	 ?FreeDataChain@CPlex@@QAEXXZ ; CPlex::FreeDataChain
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp

; 278  : 	int nCount = CDataConversion::GetStringDataCount(strPositon, ";");

  0004f	68 00 00 00 00	 push	 OFFSET ??_C@_01ICJEACDI@?$DL@
  00054	8d 4d f0	 lea	 ecx, DWORD PTR $T3[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 873  : 	m_pBlocks = NULL;

  00057	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp

; 278  : 	int nCount = CDataConversion::GetStringDataCount(strPositon, ";");

  0005e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  00064	8d 45 f0	 lea	 eax, DWORD PTR $T3[ebp]
  00067	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0006e	50		 push	 eax
  0006f	ff 75 08	 push	 DWORD PTR _strPositon$[ebp]
  00072	e8 00 00 00 00	 call	 ?GetStringDataCount@CDataConversion@@SAHABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@0@Z ; CDataConversion::GetStringDataCount
  00077	83 c4 08	 add	 esp, 8
  0007a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00081	8b f8		 mov	 edi, eax
  00083	8d 4d f0	 lea	 ecx, DWORD PTR $T3[ebp]
  00086	89 7d e8	 mov	 DWORD PTR _nCount$1$[ebp], edi
  00089	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 279  : 	for(int i = 0; i < nCount ; i++){

  0008f	33 db		 xor	 ebx, ebx
  00091	85 ff		 test	 edi, edi
  00093	0f 8e f6 00 00
	00		 jle	 $LN3@GetBlocksP
  00099	0f 1f 80 00 00
	00 00		 npad	 7
$LL4@GetBlocksP:

; 280  : 		CString strData = CDataConversion::GetMidToTrimDataIndex(strPositon, ";", i);

  000a0	68 00 00 00 00	 push	 OFFSET ??_C@_01ICJEACDI@?$DL@
  000a5	8d 4d ec	 lea	 ecx, DWORD PTR $T2[ebp]
  000a8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  000ae	6a 01		 push	 1
  000b0	53		 push	 ebx
  000b1	8d 45 ec	 lea	 eax, DWORD PTR $T2[ebp]
  000b4	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  000bb	50		 push	 eax
  000bc	ff 75 08	 push	 DWORD PTR _strPositon$[ebp]
  000bf	8d 45 0c	 lea	 eax, DWORD PTR _strData$4[ebp]
  000c2	50		 push	 eax
  000c3	e8 00 00 00 00	 call	 ?GetMidToTrimDataIndex@CDataConversion@@SA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@ABV23@0H_N@Z ; CDataConversion::GetMidToTrimDataIndex
  000c8	83 c4 14	 add	 esp, 20			; 00000014H
  000cb	8d 4d ec	 lea	 ecx, DWORD PTR $T2[ebp]
  000ce	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  000d2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h

; 519  : 		return( GetData()->nDataLength );

  000d8	8b 45 0c	 mov	 eax, DWORD PTR _strData$4[ebp]

; 533  : 		return( GetLength() == 0 );

  000db	83 78 f4 00	 cmp	 DWORD PTR [eax-12], 0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp

; 281  : 		if(strData.IsEmpty())

  000df	0f 84 c3 00 00
	00		 je	 $LN42@GetBlocksP

; 283  : 		int nData = atoi(strData);

  000e5	50		 push	 eax
  000e6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 902  : 	if (m_pNodeFree == NULL)

  000ec	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp

; 283  : 		int nData = atoi(strData);

  000ef	83 c4 04	 add	 esp, 4
  000f2	89 45 e4	 mov	 DWORD PTR _nData$1$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 968  : 	CNode* pNewNode = NewNode(m_pNodeTail, NULL);

  000f5	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000f8	89 45 f0	 mov	 DWORD PTR _pPrev$1$[ebp], eax

; 902  : 	if (m_pNodeFree == NULL)

  000fb	85 d2		 test	 edx, edx
  000fd	75 44		 jne	 SHORT $LN54@GetBlocksP

; 903  : 	{
; 904  : 		// add another block
; 905  : 		CPlex* pNewBlock = CPlex::Create(m_pBlocks, m_nBlockSize,

  000ff	6a 10		 push	 16			; 00000010H
  00101	ff 76 18	 push	 DWORD PTR [esi+24]
  00104	8d 46 14	 lea	 eax, DWORD PTR [esi+20]
  00107	50		 push	 eax
  00108	e8 00 00 00 00	 call	 ?Create@CPlex@@SGPAU1@AAPAU1@II@Z ; CPlex::Create

; 906  : 				 sizeof(CNode));
; 907  : 
; 908  : 		// chain them into free list
; 909  : 		CNode* pNode = (CNode*) pNewBlock->data();
; 910  : 		// free in reverse order to make it easier to debug
; 911  : 		pNode += m_nBlockSize - 1;

  0010d	8b 56 18	 mov	 edx, DWORD PTR [esi+24]
  00110	8b ca		 mov	 ecx, edx
  00112	c1 e1 04	 shl	 ecx, 4
  00115	83 c1 f8	 add	 ecx, -8			; fffffff8H
  00118	03 c8		 add	 ecx, eax

; 912  : 		for (INT_PTR i = m_nBlockSize-1; i >= 0; i--, pNode--)

  0011a	8d 7a ff	 lea	 edi, DWORD PTR [edx-1]
  0011d	85 ff		 test	 edi, edi
  0011f	78 14		 js	 SHORT $LN55@GetBlocksP
$LL30@GetBlocksP:

; 913  : 		{
; 914  : 			pNode->pNext = m_pNodeFree;

  00121	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00124	8b d1		 mov	 edx, ecx
  00126	89 01		 mov	 DWORD PTR [ecx], eax

; 915  : 			m_pNodeFree = pNode;

  00128	89 4e 10	 mov	 DWORD PTR [esi+16], ecx
  0012b	83 e9 10	 sub	 ecx, 16			; 00000010H
  0012e	83 ef 01	 sub	 edi, 1
  00131	79 ee		 jns	 SHORT $LL30@GetBlocksP
  00133	eb 03		 jmp	 SHORT $LN33@GetBlocksP
$LN55@GetBlocksP:
  00135	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
$LN33@GetBlocksP:

; 918  : 	ENSURE(m_pNodeFree != NULL);  // we must have something

  00138	85 d2		 test	 edx, edx
  0013a	0f 84 85 00 00
	00		 je	 $LN43@GetBlocksP
  00140	8b 7d e8	 mov	 edi, DWORD PTR _nCount$1$[ebp]
$LN54@GetBlocksP:

; 919  : 
; 920  : 	CList::CNode* pNode = m_pNodeFree;
; 921  : 	m_pNodeFree = m_pNodeFree->pNext;

  00143	8b 02		 mov	 eax, DWORD PTR [edx]
  00145	66 0f 6e 45 e4	 movd	 xmm0, DWORD PTR _nData$1$[ebp]
  0014a	89 46 10	 mov	 DWORD PTR [esi+16], eax

; 922  : 	pNode->pPrev = pPrev;

  0014d	8b 45 f0	 mov	 eax, DWORD PTR _pPrev$1$[ebp]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp

; 284  : 		positionList.AddTail(nData);

  00150	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 922  : 	pNode->pPrev = pPrev;

  00154	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 923  : 	pNode->pNext = pNext;

  00157	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 924  : 	m_nCount++;

  0015d	ff 46 0c	 inc	 DWORD PTR [esi+12]

; 969  : 	pNewNode->data = newElement;

  00160	f2 0f 11 42 08	 movsd	 QWORD PTR [edx+8], xmm0

; 970  : 	if (m_pNodeTail != NULL)

  00165	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00168	85 c0		 test	 eax, eax
  0016a	74 04		 je	 SHORT $LN24@GetBlocksP

; 971  : 		m_pNodeTail->pNext = pNewNode;

  0016c	89 10		 mov	 DWORD PTR [eax], edx
  0016e	eb 03		 jmp	 SHORT $LN25@GetBlocksP
$LN24@GetBlocksP:

; 972  : 	else
; 973  : 		m_pNodeHead = pNewNode;

  00170	89 56 04	 mov	 DWORD PTR [esi+4], edx
$LN25@GetBlocksP:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp

; 285  : 	}

  00173	8d 4d 0c	 lea	 ecx, DWORD PTR _strData$4[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 974  : 	m_pNodeTail = pNewNode;

  00176	89 56 08	 mov	 DWORD PTR [esi+8], edx
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp

; 285  : 	}

  00179	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00180	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00186	43		 inc	 ebx
  00187	3b df		 cmp	 ebx, edi
  00189	0f 8c 11 ff ff
	ff		 jl	 $LL4@GetBlocksP
$LN3@GetBlocksP:

; 286  : 
; 287  : 	return (positionList.GetCount() > 0);

  0018f	83 7e 0c 00	 cmp	 DWORD PTR [esi+12], 0
  00193	0f 9f c0	 setg	 al

; 288  : }

  00196	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00199	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001a0	59		 pop	 ecx
  001a1	5f		 pop	 edi
  001a2	5e		 pop	 esi
  001a3	5b		 pop	 ebx
  001a4	8b e5		 mov	 esp, ebp
  001a6	5d		 pop	 ebp
  001a7	c3		 ret	 0
$LN42@GetBlocksP:

; 282  : 			return false;

  001a8	8d 4d 0c	 lea	 ecx, DWORD PTR _strData$4[ebp]
  001ab	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  001b1	32 c0		 xor	 al, al

; 288  : }

  001b3	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001b6	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001bd	59		 pop	 ecx
  001be	5f		 pop	 edi
  001bf	5e		 pop	 esi
  001c0	5b		 pop	 ebx
  001c1	8b e5		 mov	 esp, ebp
  001c3	5d		 pop	 ebp
  001c4	c3		 ret	 0
$LN43@GetBlocksP:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 918  : 	ENSURE(m_pNodeFree != NULL);  // we must have something

  001c5	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN59@GetBlocksP:
  001ca	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetBlocksPosition@CBlocksPositionCalculator@@CA_NABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAV?$CList@NN@@@Z$0:
  00000	8d 4d f0	 lea	 ecx, DWORD PTR $T3[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?GetBlocksPosition@CBlocksPositionCalculator@@CA_NABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAV?$CList@NN@@@Z$1:
  00009	8d 4d ec	 lea	 ecx, DWORD PTR $T2[ebp]
  0000c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?GetBlocksPosition@CBlocksPositionCalculator@@CA_NABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAV?$CList@NN@@@Z$2:
  00012	8d 4d 0c	 lea	 ecx, DWORD PTR _strData$4[ebp]
  00015	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0001b	cc		 int	 3
  0001c	cc		 int	 3
  0001d	cc		 int	 3
  0001e	cc		 int	 3
  0001f	cc		 int	 3
__ehhandler$?GetBlocksPosition@CBlocksPositionCalculator@@CA_NABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAV?$CList@NN@@@Z:
  00020	90		 npad	 1
  00021	90		 npad	 1
  00022	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00026	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00029	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  0002c	33 c8		 xor	 ecx, eax
  0002e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00033	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?GetBlocksPosition@CBlocksPositionCalculator@@CA_NABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAV?$CList@NN@@@Z
  00038	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?GetBlocksPosition@CBlocksPositionCalculator@@CA_NABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAV?$CList@NN@@@Z ENDP ; CBlocksPositionCalculator::GetBlocksPosition
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
;	COMDAT ?IsBlockInDoubleSize@CBlocksPositionCalculator@@CA_NHHH@Z
_TEXT	SEGMENT
_doubleSizeBlockNum$ = 8				; size = 4
_doubleSizeCount$ = 12					; size = 4
_curNum$ = 16						; size = 4
?IsBlockInDoubleSize@CBlocksPositionCalculator@@CA_NHHH@Z PROC ; CBlocksPositionCalculator::IsBlockInDoubleSize, COMDAT

; 269  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 270  : 	return (curNum > doubleSizeBlockNum && curNum <= (doubleSizeBlockNum + doubleSizeCount));

  00003	8b 4d 10	 mov	 ecx, DWORD PTR _curNum$[ebp]
  00006	8b 55 08	 mov	 edx, DWORD PTR _doubleSizeBlockNum$[ebp]
  00009	3b ca		 cmp	 ecx, edx
  0000b	7e 0d		 jle	 SHORT $LN3@IsBlockInD
  0000d	8b 45 0c	 mov	 eax, DWORD PTR _doubleSizeCount$[ebp]
  00010	03 c2		 add	 eax, edx
  00012	3b c8		 cmp	 ecx, eax
  00014	7f 04		 jg	 SHORT $LN3@IsBlockInD
  00016	b0 01		 mov	 al, 1

; 271  : }

  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
$LN3@IsBlockInD:

; 270  : 	return (curNum > doubleSizeBlockNum && curNum <= (doubleSizeBlockNum + doubleSizeCount));

  0001a	32 c0		 xor	 al, al

; 271  : }

  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
?IsBlockInDoubleSize@CBlocksPositionCalculator@@CA_NHHH@Z ENDP ; CBlocksPositionCalculator::IsBlockInDoubleSize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
;	COMDAT ?GetDoubleSizeBlockCount@CBlocksPositionCalculator@@CAHHH@Z
_TEXT	SEGMENT
_blockCount$ = 8					; size = 4
_doubleSizeBlockNum$ = 12				; size = 4
?GetDoubleSizeBlockCount@CBlocksPositionCalculator@@CAHHH@Z PROC ; CBlocksPositionCalculator::GetDoubleSizeBlockCount, COMDAT

; 261  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 262  : 	if(doubleSizeBlockNum < 0 || doubleSizeBlockNum >= blockCount)

  00003	8b 45 0c	 mov	 eax, DWORD PTR _doubleSizeBlockNum$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	78 12		 js	 SHORT $LN3@GetDoubleS
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _blockCount$[ebp]
  0000d	3b c1		 cmp	 eax, ecx
  0000f	7d 0b		 jge	 SHORT $LN3@GetDoubleS

; 264  : 
; 265  : 	return (blockCount > 2 ? 2: 1);

  00011	33 c0		 xor	 eax, eax
  00013	83 f9 02	 cmp	 ecx, 2
  00016	0f 9f c0	 setg	 al
  00019	40		 inc	 eax

; 266  : }

  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
$LN3@GetDoubleS:

; 263  : 		return 0;

  0001c	33 c0		 xor	 eax, eax

; 266  : }

  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
?GetDoubleSizeBlockCount@CBlocksPositionCalculator@@CAHHH@Z ENDP ; CBlocksPositionCalculator::GetDoubleSizeBlockCount
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
;	COMDAT ?RecalculatePositions@CBlocksPositionCalculator@@SAXAAV?$CList@NN@@HH@Z
_TEXT	SEGMENT
_positionList$ = 8					; size = 4
_oldAllRegionLength$ = 12				; size = 4
_newAllRegionLength$ = 16				; size = 4
?RecalculatePositions@CBlocksPositionCalculator@@SAXAAV?$CList@NN@@HH@Z PROC ; CBlocksPositionCalculator::RecalculatePositions, COMDAT

; 352  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 353  : 	POSITION pos = positionList.GetHeadPosition();

  00003	8b 45 08	 mov	 eax, DWORD PTR _positionList$[ebp]
  00006	56		 push	 esi
  00007	8b 70 04	 mov	 esi, DWORD PTR [eax+4]

; 354  : 	if(pos == NULL)

  0000a	85 f6		 test	 esi, esi
  0000c	74 79		 je	 SHORT $LN3@Recalculat

; 355  : 		return;
; 356  : 
; 357  : 	int posNum = 0;

  0000e	8b 55 0c	 mov	 edx, DWORD PTR _oldAllRegionLength$[ebp]
  00011	53		 push	 ebx
  00012	8b 5d 10	 mov	 ebx, DWORD PTR _newAllRegionLength$[ebp]
  00015	57		 push	 edi
  00016	33 ff		 xor	 edi, edi
  00018	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL2@Recalculat:

; 359  : 		int length = GetChangedPosition(oldAllRegionLength, newAllRegionLength, 

  00020	f2 0f 2c 4e 08	 cvttsd2si ecx, QWORD PTR [esi+8]

; 374  : 	if(posNum == 0)

  00025	85 ff		 test	 edi, edi
  00027	74 48		 je	 SHORT $LN6@Recalculat

; 359  : 		int length = GetChangedPosition(oldAllRegionLength, newAllRegionLength, 

  00029	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0002c	48		 dec	 eax

; 376  : 	else if(posNum == blockCount)

  0002d	3b f8		 cmp	 edi, eax
  0002f	75 04		 jne	 SHORT $LN9@Recalculat

; 377  : 		return newAllRegionLength;

  00031	8b cb		 mov	 ecx, ebx
  00033	eb 39		 jmp	 SHORT $LN18@Recalculat
$LN9@Recalculat:

; 378  : 
; 379  : 	if(oldAllRegionLength == 0)

  00035	85 d2		 test	 edx, edx
  00037	74 35		 je	 SHORT $LN18@Recalculat
  00039	66 0f 6e c9	 movd	 xmm1, ecx

; 380  : 		return oldPositionValue;
; 381  : 
; 382  : 	return CMath::Round(((double)newAllRegionLength*(double)oldPositionValue)/(double)oldAllRegionLength);

  0003d	83 ec 08	 sub	 esp, 8
  00040	66 0f 6e c3	 movd	 xmm0, ebx
  00044	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00048	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1
  0004c	f2 0f 59 c8	 mulsd	 xmm1, xmm0
  00050	66 0f 6e c2	 movd	 xmm0, edx
  00054	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00058	f2 0f 5e c8	 divsd	 xmm1, xmm0
  0005c	f2 0f 11 0c 24	 movsd	 QWORD PTR [esp], xmm1
  00061	e8 00 00 00 00	 call	 ?Round@CMath@@SAHN@Z	; CMath::Round
  00066	8b 55 0c	 mov	 edx, DWORD PTR _oldAllRegionLength$[ebp]
  00069	83 c4 08	 add	 esp, 8
  0006c	8b c8		 mov	 ecx, eax
$LN18@Recalculat:

; 359  : 		int length = GetChangedPosition(oldAllRegionLength, newAllRegionLength, 

  0006e	8b 45 08	 mov	 eax, DWORD PTR _positionList$[ebp]
$LN6@Recalculat:
  00071	66 0f 6e c1	 movd	 xmm0, ecx
  00075	47		 inc	 edi

; 360  : 			(int)positionList.GetAt(pos), posNum++, (positionList.GetCount()-1));
; 361  : 		positionList.SetAt(pos, length);

  00076	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  0007a	f2 0f 11 46 08	 movsd	 QWORD PTR [esi+8], xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 813  : 		rPosition = (POSITION) pNode->pNext;

  0007f	8b 36		 mov	 esi, DWORD PTR [esi]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp

; 358  : 	while(pos != NULL){

  00081	85 f6		 test	 esi, esi
  00083	75 9b		 jne	 SHORT $LL2@Recalculat
  00085	5f		 pop	 edi
  00086	5b		 pop	 ebx
$LN3@Recalculat:
  00087	5e		 pop	 esi

; 362  : 		positionList.GetNext(pos);
; 363  : 	}
; 364  : }

  00088	5d		 pop	 ebp
  00089	c3		 ret	 0
?RecalculatePositions@CBlocksPositionCalculator@@SAXAAV?$CList@NN@@HH@Z ENDP ; CBlocksPositionCalculator::RecalculatePositions
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
;	COMDAT ?MoveBlockPosition@CBlocksPositionCalculator@@SA_NAAV?$CList@NN@@HH@Z
_TEXT	SEGMENT
_lengthInBlock$ = -40					; size = 28
__$EHRec$ = -12						; size = 12
_positionList$ = 8					; size = 4
_sourceIndex$ = 12					; size = 4
_targetIndex$ = 16					; size = 4
?MoveBlockPosition@CBlocksPositionCalculator@@SA_NAAV?$CList@NN@@HH@Z PROC ; CBlocksPositionCalculator::MoveBlockPosition, COMDAT

; 236  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?MoveBlockPosition@CBlocksPositionCalculator@@SA_NAAV?$CList@NN@@HH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 237  : 	int allCount = positionList.GetCount();

  00028	8b 7d 08	 mov	 edi, DWORD PTR _positionList$[ebp]
  0002b	8b 5f 0c	 mov	 ebx, DWORD PTR [edi+12]

; 474  : 	if(allCount <= 2)

  0002e	83 fb 02	 cmp	 ebx, 2
  00031	0f 8e 14 01 00
	00		 jle	 $LN6@MoveBlockP

; 475  : 		return false;
; 476  : 
; 477  : 	return (num > -1 && num < allCount);

  00037	8b 45 0c	 mov	 eax, DWORD PTR _sourceIndex$[ebp]
  0003a	83 f8 ff	 cmp	 eax, -1
  0003d	0f 8e 08 01 00
	00		 jle	 $LN6@MoveBlockP
  00043	3b c3		 cmp	 eax, ebx
  00045	0f 8d 00 01 00
	00		 jge	 $LN6@MoveBlockP
  0004b	8b 4d 10	 mov	 ecx, DWORD PTR _targetIndex$[ebp]
  0004e	83 f9 ff	 cmp	 ecx, -1
  00051	0f 8e f4 00 00
	00		 jle	 $LN6@MoveBlockP
  00057	3b cb		 cmp	 ecx, ebx
  00059	0f 8d ec 00 00
	00		 jge	 $LN6@MoveBlockP
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 851  : {

  0005f	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _lengthInBlock$[ebp], OFFSET ??_7?$CList@NN@@6B@

; 852  : 	ASSERT(nBlockSize > 0);
; 853  : 
; 854  : 	m_nCount = 0;

  00066	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _lengthInBlock$[ebp+12], 0

; 855  : 	m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;

  0006d	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _lengthInBlock$[ebp+16], 0
  00074	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _lengthInBlock$[ebp+8], 0
  0007b	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _lengthInBlock$[ebp+4], 0

; 856  : 	m_pBlocks = NULL;

  00082	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _lengthInBlock$[ebp+20], 0

; 857  : 	m_nBlockSize = nBlockSize;

  00089	c7 45 f0 0a 00
	00 00		 mov	 DWORD PTR _lengthInBlock$[ebp+24], 10 ; 0000000aH
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp

; 243  : 	if(!GetChangedLengthInBlock(positionList, sourceIndex, targetIndex, lengthInBlock))

  00090	8d 55 d8	 lea	 edx, DWORD PTR _lengthInBlock$[ebp]
  00093	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0009a	52		 push	 edx
  0009b	51		 push	 ecx
  0009c	50		 push	 eax
  0009d	57		 push	 edi
  0009e	e8 00 00 00 00	 call	 ?GetChangedLengthInBlock@CBlocksPositionCalculator@@CA_NABV?$CList@NN@@HHAAV2@@Z ; CBlocksPositionCalculator::GetChangedLengthInBlock
  000a3	83 c4 10	 add	 esp, 16			; 00000010H
  000a6	84 c0		 test	 al, al
  000a8	75 04		 jne	 SHORT $LN7@MoveBlockP
  000aa	32 db		 xor	 bl, bl
  000ac	eb 57		 jmp	 SHORT $LN11@MoveBlockP
$LN7@MoveBlockP:
  000ae	0f 57 c9	 xorps	 xmm1, xmm1

; 244  : 		return false;
; 245  : 
; 246  : 	//   block position list 
; 247  : 	double dSetData = 0;

  000b1	be 01 00 00 00	 mov	 esi, 1
$LL4@MoveBlockP:

; 249  : 		POSITION pos = positionList.FindIndex(i);

  000b6	8b c6		 mov	 eax, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 1133 : 	if (nIndex >= m_nCount || nIndex < 0)

  000b8	3b 77 0c	 cmp	 esi, DWORD PTR [edi+12]
  000bb	7d 41		 jge	 SHORT $LN2@MoveBlockP

; 1134 : 		return NULL;  // went too far
; 1135 : 
; 1136 : 	CNode* pNode = m_pNodeHead;

  000bd	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
$LL25@MoveBlockP:

; 1138 : 	{
; 1139 : 		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 1140 : 		pNode = pNode->pNext;

  000c0	8b 12		 mov	 edx, DWORD PTR [edx]
  000c2	83 e8 01	 sub	 eax, 1
  000c5	75 f9		 jne	 SHORT $LL25@MoveBlockP
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp

; 250  : 		if(pos != NULL){

  000c7	85 d2		 test	 edx, edx
  000c9	74 33		 je	 SHORT $LN2@MoveBlockP

; 516  : 	POSITION pos = positionList.FindIndex(index);

  000cb	8d 46 ff	 lea	 eax, DWORD PTR [esi-1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 1133 : 	if (nIndex >= m_nCount || nIndex < 0)

  000ce	3b 45 e4	 cmp	 eax, DWORD PTR _lengthInBlock$[ebp+12]
  000d1	7d 1f		 jge	 SHORT $LN68@MoveBlockP
  000d3	85 c0		 test	 eax, eax
  000d5	78 1b		 js	 SHORT $LN68@MoveBlockP

; 1134 : 		return NULL;  // went too far
; 1135 : 
; 1136 : 	CNode* pNode = m_pNodeHead;

  000d7	8b 4d dc	 mov	 ecx, DWORD PTR _lengthInBlock$[ebp+4]

; 1137 : 	while (nIndex--)

  000da	74 0b		 je	 SHORT $LN53@MoveBlockP
  000dc	0f 1f 40 00	 npad	 4
$LL34@MoveBlockP:

; 1138 : 	{
; 1139 : 		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 1140 : 		pNode = pNode->pNext;

  000e0	8b 09		 mov	 ecx, DWORD PTR [ecx]
  000e2	83 e8 01	 sub	 eax, 1
  000e5	75 f9		 jne	 SHORT $LL34@MoveBlockP
$LN53@MoveBlockP:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp

; 517  : 	if(pos == NULL)

  000e7	85 c9		 test	 ecx, ecx
  000e9	74 07		 je	 SHORT $LN68@MoveBlockP

; 518  : 		return 0;
; 519  : 	return positionList.GetAt(pos);

  000eb	f2 0f 10 41 08	 movsd	 xmm0, QWORD PTR [ecx+8]
  000f0	eb 03		 jmp	 SHORT $LN30@MoveBlockP
$LN68@MoveBlockP:
  000f2	0f 57 c0	 xorps	 xmm0, xmm0
$LN30@MoveBlockP:

; 251  : 			dSetData += GetData(lengthInBlock, i -1);

  000f5	f2 0f 58 c8	 addsd	 xmm1, xmm0

; 252  : 			positionList.SetAt(pos, dSetData);

  000f9	f2 0f 11 4a 08	 movsd	 QWORD PTR [edx+8], xmm1
$LN2@MoveBlockP:

; 248  : 	for(int i = 1; i < allCount; i++){

  000fe	46		 inc	 esi
  000ff	3b f3		 cmp	 esi, ebx
  00101	7c b3		 jl	 SHORT $LL4@MoveBlockP

; 255  : 	return true;

  00103	b3 01		 mov	 bl, 1
$LN11@MoveBlockP:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 872  : 	m_pBlocks->FreeDataChain();

  00105	8b 4d ec	 mov	 ecx, DWORD PTR _lengthInBlock$[ebp+20]

; 878  : {

  00108	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  0010f	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _lengthInBlock$[ebp], OFFSET ??_7?$CList@NN@@6B@

; 870  : 	m_nCount = 0;

  00116	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _lengthInBlock$[ebp+12], 0

; 871  : 	m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;

  0011d	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _lengthInBlock$[ebp+16], 0
  00124	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _lengthInBlock$[ebp+8], 0
  0012b	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _lengthInBlock$[ebp+4], 0

; 872  : 	m_pBlocks->FreeDataChain();

  00132	e8 00 00 00 00	 call	 ?FreeDataChain@CPlex@@QAEXXZ ; CPlex::FreeDataChain
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp

; 255  : 	return true;

  00137	8a c3		 mov	 al, bl

; 256  : }

  00139	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0013c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00143	59		 pop	 ecx
  00144	5f		 pop	 edi
  00145	5e		 pop	 esi
  00146	5b		 pop	 ebx
  00147	8b e5		 mov	 esp, ebp
  00149	5d		 pop	 ebp
  0014a	c3		 ret	 0
$LN6@MoveBlockP:

; 238  : 	if(!IsMoveBlockPosition(sourceIndex, allCount) || !IsMoveBlockPosition(targetIndex, allCount))
; 239  : 		return false;

  0014b	32 c0		 xor	 al, al

; 256  : }

  0014d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00150	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00157	59		 pop	 ecx
  00158	5f		 pop	 edi
  00159	5e		 pop	 esi
  0015a	5b		 pop	 ebx
  0015b	8b e5		 mov	 esp, ebp
  0015d	5d		 pop	 ebp
  0015e	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?MoveBlockPosition@CBlocksPositionCalculator@@SA_NAAV?$CList@NN@@HH@Z$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR _lengthInBlock$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$CList@NN@@UAE@XZ	; CList<double,double>::~CList<double,double>
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?MoveBlockPosition@CBlocksPositionCalculator@@SA_NAAV?$CList@NN@@HH@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a d4	 mov	 ecx, DWORD PTR [edx-44]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?MoveBlockPosition@CBlocksPositionCalculator@@SA_NAAV?$CList@NN@@HH@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?MoveBlockPosition@CBlocksPositionCalculator@@SA_NAAV?$CList@NN@@HH@Z ENDP ; CBlocksPositionCalculator::MoveBlockPosition
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
;	COMDAT ?MoveBlocksPosition@CBlocksPositionCalculator@@SA_NAAV?$CList@NN@@0ABVCPoint@@HH@Z
_TEXT	SEGMENT
_rowList$ = 8						; size = 4
_columnList$ = 12					; size = 4
_point$ = 16						; size = 4
_rowCompartLineNum$ = 20				; size = 4
_columnCompartLineNum$ = 24				; size = 4
?MoveBlocksPosition@CBlocksPositionCalculator@@SA_NAAV?$CList@NN@@0ABVCPoint@@HH@Z PROC ; CBlocksPositionCalculator::MoveBlocksPosition, COMDAT

; 224  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 225  : 	bool ret = false;
; 226  : 	if(MoveBlocksPosition(columnList, columnCompartLineNum, point.x))

  00005	8b 75 10	 mov	 esi, DWORD PTR _point$[ebp]
  00008	32 db		 xor	 bl, bl
  0000a	57		 push	 edi
  0000b	ff 36		 push	 DWORD PTR [esi]
  0000d	ff 75 18	 push	 DWORD PTR _columnCompartLineNum$[ebp]
  00010	ff 75 0c	 push	 DWORD PTR _columnList$[ebp]
  00013	e8 00 00 00 00	 call	 ?MoveBlocksPosition@CBlocksPositionCalculator@@CA_NAAV?$CList@NN@@HH@Z ; CBlocksPositionCalculator::MoveBlocksPosition

; 227  : 		ret = true;
; 228  : 	if(MoveBlocksPosition(rowList, rowCompartLineNum, point.y))

  00018	ff 76 04	 push	 DWORD PTR [esi+4]
  0001b	84 c0		 test	 al, al
  0001d	0f b6 db	 movzx	 ebx, bl
  00020	ff 75 14	 push	 DWORD PTR _rowCompartLineNum$[ebp]
  00023	bf 01 00 00 00	 mov	 edi, 1
  00028	ff 75 08	 push	 DWORD PTR _rowList$[ebp]
  0002b	0f 45 df	 cmovne	 ebx, edi
  0002e	e8 00 00 00 00	 call	 ?MoveBlocksPosition@CBlocksPositionCalculator@@CA_NAAV?$CList@NN@@HH@Z ; CBlocksPositionCalculator::MoveBlocksPosition
  00033	83 c4 18	 add	 esp, 24			; 00000018H
  00036	0f b6 cb	 movzx	 ecx, bl
  00039	84 c0		 test	 al, al
  0003b	0f 45 cf	 cmovne	 ecx, edi

; 229  : 		ret = true;
; 230  : 
; 231  : 	return ret;

  0003e	5f		 pop	 edi
  0003f	5e		 pop	 esi
  00040	8a c1		 mov	 al, cl
  00042	5b		 pop	 ebx

; 232  : }

  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
?MoveBlocksPosition@CBlocksPositionCalculator@@SA_NAAV?$CList@NN@@0ABVCPoint@@HH@Z ENDP ; CBlocksPositionCalculator::MoveBlocksPosition
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
;	COMDAT ?FindCompartLine@CBlocksPositionCalculator@@SA_NABVCPoint@@ABV?$CList@NN@@10AAH2@Z
_TEXT	SEGMENT
_absoluteOrgPt$ = 8					; size = 4
_rowList$ = 12						; size = 4
_columnList$ = 16					; size = 4
_point$ = 20						; size = 4
_blockRowIndex$ = 24					; size = 4
_blockColumnIndex$ = 28					; size = 4
?FindCompartLine@CBlocksPositionCalculator@@SA_NABVCPoint@@ABV?$CList@NN@@10AAH2@Z PROC ; CBlocksPositionCalculator::FindCompartLine, COMDAT

; 211  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 212  : 	bool ret = false;
; 213  : 	// ()  
; 214  : 	if(AppropriateRowCompartLine(absoluteOrgPt, rowList, columnList, point, blockRowIndex))

  00004	ff 75 18	 push	 DWORD PTR _blockRowIndex$[ebp]
  00007	32 db		 xor	 bl, bl
  00009	ff 75 14	 push	 DWORD PTR _point$[ebp]
  0000c	ff 75 10	 push	 DWORD PTR _columnList$[ebp]
  0000f	ff 75 0c	 push	 DWORD PTR _rowList$[ebp]
  00012	ff 75 08	 push	 DWORD PTR _absoluteOrgPt$[ebp]
  00015	e8 00 00 00 00	 call	 ?AppropriateRowCompartLine@CBlocksPositionCalculator@@CA_NABVCPoint@@ABV?$CList@NN@@10AAH@Z ; CBlocksPositionCalculator::AppropriateRowCompartLine

; 215  : 		ret = true;
; 216  : 	if(AppropriateColumnCompartLine(absoluteOrgPt, rowList, columnList, point, blockColumnIndex))

  0001a	ff 75 1c	 push	 DWORD PTR _blockColumnIndex$[ebp]
  0001d	84 c0		 test	 al, al
  0001f	0f b6 db	 movzx	 ebx, bl
  00022	ff 75 14	 push	 DWORD PTR _point$[ebp]
  00025	b9 01 00 00 00	 mov	 ecx, 1
  0002a	ff 75 10	 push	 DWORD PTR _columnList$[ebp]
  0002d	0f 45 d9	 cmovne	 ebx, ecx
  00030	ff 75 0c	 push	 DWORD PTR _rowList$[ebp]
  00033	ff 75 08	 push	 DWORD PTR _absoluteOrgPt$[ebp]
  00036	e8 00 00 00 00	 call	 ?AppropriateColumnCompartLine@CBlocksPositionCalculator@@CA_NABVCPoint@@ABV?$CList@NN@@10AAH@Z ; CBlocksPositionCalculator::AppropriateColumnCompartLine
  0003b	83 c4 28	 add	 esp, 40			; 00000028H
  0003e	0f b6 cb	 movzx	 ecx, bl
  00041	84 c0		 test	 al, al
  00043	b8 01 00 00 00	 mov	 eax, 1
  00048	0f 45 c8	 cmovne	 ecx, eax

; 217  : 		ret = true;
; 218  : 
; 219  : 	return ret;

  0004b	8a c1		 mov	 al, cl
  0004d	5b		 pop	 ebx

; 220  : }

  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
?FindCompartLine@CBlocksPositionCalculator@@SA_NABVCPoint@@ABV?$CList@NN@@10AAH2@Z ENDP ; CBlocksPositionCalculator::FindCompartLine
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
;	COMDAT ?RecalculatePositions@CBlocksPositionCalculator@@SAXABVCRect@@0AAV?$CList@NN@@1@Z
_TEXT	SEGMENT
_oldAllBlockRegion$ = 8					; size = 4
_newAllBlockRegion$ = 12				; size = 4
_rowList$ = 16						; size = 4
_columnList$ = 20					; size = 4
?RecalculatePositions@CBlocksPositionCalculator@@SAXABVCRect@@0AAV?$CList@NN@@1@Z PROC ; CBlocksPositionCalculator::RecalculatePositions, COMDAT

; 199  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h

; 581  : 	return bottom - top;

  00004	8b 75 08	 mov	 esi, DWORD PTR _oldAllBlockRegion$[ebp]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp

; 199  : {

  00007	57		 push	 edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h

; 581  : 	return bottom - top;

  00008	8b 7d 0c	 mov	 edi, DWORD PTR _newAllBlockRegion$[ebp]
  0000b	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0000e	2b 46 04	 sub	 eax, DWORD PTR [esi+4]
  00011	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  00014	2b 4f 04	 sub	 ecx, DWORD PTR [edi+4]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp

; 200  : 	if(oldAllBlockRegion.Height() != newAllBlockRegion.Height())

  00017	3b c1		 cmp	 eax, ecx
  00019	74 0d		 je	 SHORT $LN2@Recalculat

; 201  : 		RecalculatePositions(rowList, (oldAllBlockRegion.bottom - oldAllBlockRegion.top), (newAllBlockRegion.bottom - newAllBlockRegion.top));

  0001b	51		 push	 ecx
  0001c	50		 push	 eax
  0001d	ff 75 10	 push	 DWORD PTR _rowList$[ebp]
  00020	e8 00 00 00 00	 call	 ?RecalculatePositions@CBlocksPositionCalculator@@SAXAAV?$CList@NN@@HH@Z ; CBlocksPositionCalculator::RecalculatePositions
  00025	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@Recalculat:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h

; 576  : 	return right - left;

  00028	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  0002b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0002e	2b 07		 sub	 eax, DWORD PTR [edi]
  00030	2b 0e		 sub	 ecx, DWORD PTR [esi]
  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp

; 202  : 	if(oldAllBlockRegion.Width() != newAllBlockRegion.Width())

  00034	3b c8		 cmp	 ecx, eax
  00036	74 0d		 je	 SHORT $LN3@Recalculat

; 203  : 		RecalculatePositions(columnList, (oldAllBlockRegion.right - oldAllBlockRegion.left), (newAllBlockRegion.right - newAllBlockRegion.left));

  00038	50		 push	 eax
  00039	51		 push	 ecx
  0003a	ff 75 14	 push	 DWORD PTR _columnList$[ebp]
  0003d	e8 00 00 00 00	 call	 ?RecalculatePositions@CBlocksPositionCalculator@@SAXAAV?$CList@NN@@HH@Z ; CBlocksPositionCalculator::RecalculatePositions
  00042	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@Recalculat:

; 204  : }

  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
?RecalculatePositions@CBlocksPositionCalculator@@SAXABVCRect@@0AAV?$CList@NN@@1@Z ENDP ; CBlocksPositionCalculator::RecalculatePositions
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
;	COMDAT ?InitializePositions@CBlocksPositionCalculator@@SAXABVCRect@@HHAAV?$CList@HH@@1HH@Z
_TEXT	SEGMENT
_newAllBlockRegion$ = 8					; size = 4
_nDoubleSizeBlockRowNum$ = 12				; size = 4
_nDoubleSizeBlockColumnNum$ = 16			; size = 4
_rowList$ = 20						; size = 4
_columnList$ = 24					; size = 4
_interBlockHalfGap$ = 28				; size = 4
_compartLineThickness$ = 32				; size = 4
?InitializePositions@CBlocksPositionCalculator@@SAXABVCRect@@HHAAV?$CList@HH@@1HH@Z PROC ; CBlocksPositionCalculator::InitializePositions, COMDAT

; 192  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 193  : 	InitializePositions(rowList, nDoubleSizeBlockRowNum, newAllBlockRegion.bottom - newAllBlockRegion.top, interBlockHalfGap, compartLineThickness);

  00004	8b 7d 08	 mov	 edi, DWORD PTR _newAllBlockRegion$[ebp]
  00007	ff 75 20	 push	 DWORD PTR _compartLineThickness$[ebp]
  0000a	ff 75 1c	 push	 DWORD PTR _interBlockHalfGap$[ebp]
  0000d	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  00010	2b 47 04	 sub	 eax, DWORD PTR [edi+4]
  00013	50		 push	 eax
  00014	ff 75 0c	 push	 DWORD PTR _nDoubleSizeBlockRowNum$[ebp]
  00017	ff 75 14	 push	 DWORD PTR _rowList$[ebp]
  0001a	e8 00 00 00 00	 call	 ?InitializePositions@CBlocksPositionCalculator@@CAXAAV?$CList@HH@@HHHH@Z ; CBlocksPositionCalculator::InitializePositions

; 194  : 	InitializePositions(columnList, nDoubleSizeBlockColumnNum, newAllBlockRegion.right - newAllBlockRegion.left, interBlockHalfGap, compartLineThickness);

  0001f	ff 75 20	 push	 DWORD PTR _compartLineThickness$[ebp]
  00022	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00025	ff 75 1c	 push	 DWORD PTR _interBlockHalfGap$[ebp]
  00028	2b 07		 sub	 eax, DWORD PTR [edi]
  0002a	50		 push	 eax
  0002b	ff 75 10	 push	 DWORD PTR _nDoubleSizeBlockColumnNum$[ebp]
  0002e	ff 75 18	 push	 DWORD PTR _columnList$[ebp]
  00031	e8 00 00 00 00	 call	 ?InitializePositions@CBlocksPositionCalculator@@CAXAAV?$CList@HH@@HHHH@Z ; CBlocksPositionCalculator::InitializePositions
  00036	83 c4 28	 add	 esp, 40			; 00000028H
  00039	5f		 pop	 edi

; 195  : }

  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
?InitializePositions@CBlocksPositionCalculator@@SAXABVCRect@@HHAAV?$CList@HH@@1HH@Z ENDP ; CBlocksPositionCalculator::InitializePositions
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
;	COMDAT ?GetAbsolutePoint@CBlocksPositionCalculator@@SA?AVCPoint@@ABV2@ABV?$CList@NN@@1HH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_absoluteOrgPt$ = 12					; size = 4
_rowList$ = 16						; size = 4
_columnList$ = 20					; size = 4
_xIndex$ = 24						; size = 4
_yIndex$ = 28						; size = 4
?GetAbsolutePoint@CBlocksPositionCalculator@@SA?AVCPoint@@ABV2@ABV?$CList@NN@@1HH@Z PROC ; CBlocksPositionCalculator::GetAbsolutePoint, COMDAT

; 183  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 184  : 	return CPoint( ( int)GetAbsolutePosition(absoluteOrgPt.x, columnList, xIndex), ( int)GetAbsolutePosition(absoluteOrgPt.y, rowList, yIndex));

  00003	8b 55 0c	 mov	 edx, DWORD PTR _absoluteOrgPt$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 1133 : 	if (nIndex >= m_nCount || nIndex < 0)

  00006	8b 4d 10	 mov	 ecx, DWORD PTR _rowList$[ebp]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp

; 313  : 	POSITION pos = positionList.FindIndex(nIndex);

  00009	8b 45 1c	 mov	 eax, DWORD PTR _yIndex$[ebp]
  0000c	66 0f 6e 4a 04	 movd	 xmm1, DWORD PTR [edx+4]

; 184  : 	return CPoint( ( int)GetAbsolutePosition(absoluteOrgPt.x, columnList, xIndex), ( int)GetAbsolutePosition(absoluteOrgPt.y, rowList, yIndex));

  00011	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 1133 : 	if (nIndex >= m_nCount || nIndex < 0)

  00015	3b 41 0c	 cmp	 eax, DWORD PTR [ecx+12]
  00018	7d 19		 jge	 SHORT $LN4@GetAbsolut
  0001a	85 c0		 test	 eax, eax
  0001c	78 15		 js	 SHORT $LN4@GetAbsolut

; 1134 : 		return NULL;  // went too far
; 1135 : 
; 1136 : 	CNode* pNode = m_pNodeHead;

  0001e	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]

; 1137 : 	while (nIndex--)

  00021	74 07		 je	 SHORT $LN25@GetAbsolut
$LL7@GetAbsolut:

; 1138 : 	{
; 1139 : 		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 1140 : 		pNode = pNode->pNext;

  00023	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00025	83 e8 01	 sub	 eax, 1
  00028	75 f9		 jne	 SHORT $LL7@GetAbsolut
$LN25@GetAbsolut:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp

; 314  : 	if(pos != NULL)

  0002a	85 c9		 test	 ecx, ecx
  0002c	74 05		 je	 SHORT $LN4@GetAbsolut

; 315  : 		return (positionList.GetAt(pos) + absoluteOrgPt);

  0002e	f2 0f 58 49 08	 addsd	 xmm1, QWORD PTR [ecx+8]
$LN4@GetAbsolut:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 1133 : 	if (nIndex >= m_nCount || nIndex < 0)

  00033	8b 45 14	 mov	 eax, DWORD PTR _columnList$[ebp]
  00036	66 0f 6e 02	 movd	 xmm0, DWORD PTR [edx]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp

; 313  : 	POSITION pos = positionList.FindIndex(nIndex);

  0003a	8b 4d 18	 mov	 ecx, DWORD PTR _xIndex$[ebp]

; 184  : 	return CPoint( ( int)GetAbsolutePosition(absoluteOrgPt.x, columnList, xIndex), ( int)GetAbsolutePosition(absoluteOrgPt.y, rowList, yIndex));

  0003d	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 1133 : 	if (nIndex >= m_nCount || nIndex < 0)

  00041	3b 48 0c	 cmp	 ecx, DWORD PTR [eax+12]
  00044	7d 1a		 jge	 SHORT $LN13@GetAbsolut
  00046	85 c9		 test	 ecx, ecx
  00048	78 16		 js	 SHORT $LN13@GetAbsolut

; 1134 : 		return NULL;  // went too far
; 1135 : 
; 1136 : 	CNode* pNode = m_pNodeHead;

  0004a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 1137 : 	while (nIndex--)

  0004d	74 08		 je	 SHORT $LN27@GetAbsolut
  0004f	90		 npad	 1
$LL16@GetAbsolut:

; 1138 : 	{
; 1139 : 		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 1140 : 		pNode = pNode->pNext;

  00050	8b 00		 mov	 eax, DWORD PTR [eax]
  00052	83 e9 01	 sub	 ecx, 1
  00055	75 f9		 jne	 SHORT $LL16@GetAbsolut
$LN27@GetAbsolut:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp

; 314  : 	if(pos != NULL)

  00057	85 c0		 test	 eax, eax
  00059	74 05		 je	 SHORT $LN13@GetAbsolut

; 315  : 		return (positionList.GetAt(pos) + absoluteOrgPt);

  0005b	f2 0f 58 40 08	 addsd	 xmm0, QWORD PTR [eax+8]
$LN13@GetAbsolut:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h

; 408  : 	x = initX;

  00060	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp

; 184  : 	return CPoint( ( int)GetAbsolutePosition(absoluteOrgPt.x, columnList, xIndex), ( int)GetAbsolutePosition(absoluteOrgPt.y, rowList, yIndex));

  00063	f2 0f 2c c8	 cvttsd2si ecx, xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h

; 408  : 	x = initX;

  00067	89 08		 mov	 DWORD PTR [eax], ecx
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp

; 184  : 	return CPoint( ( int)GetAbsolutePosition(absoluteOrgPt.x, columnList, xIndex), ( int)GetAbsolutePosition(absoluteOrgPt.y, rowList, yIndex));

  00069	f2 0f 2c c9	 cvttsd2si ecx, xmm1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h

; 409  : 	y = initY;

  0006d	89 48 04	 mov	 DWORD PTR [eax+4], ecx
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp

; 185  : }

  00070	5d		 pop	 ebp
  00071	c3		 ret	 0
?GetAbsolutePoint@CBlocksPositionCalculator@@SA?AVCPoint@@ABV2@ABV?$CList@NN@@1HH@Z ENDP ; CBlocksPositionCalculator::GetAbsolutePoint
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
;	COMDAT ?GetPositionLength@CBlocksPositionCalculator@@SAHHHHHHH@Z
_TEXT	SEGMENT
_startPosition$ = 8					; size = 4
_endPosition$ = 12					; size = 4
_posNum$ = 16						; size = 4
_blockCount$ = 20					; size = 4
_interBlockHalfGap$ = 24				; size = 4
_compartLineThickness$ = 28				; size = 4
?GetPositionLength@CBlocksPositionCalculator@@SAHHHHHHH@Z PROC ; CBlocksPositionCalculator::GetPositionLength, COMDAT

; 161  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 162  : 	// list count == 0 
; 163  : 	//		--> list  == 0
; 164  : 	// list count == blockCount : list  
; 165  : 	//		--> list  ==  block  
; 166  : 	// list count == 1 :   block   (  : 0)
; 167  : 	//		--> gap : 1,  : 0   
; 168  : 	//  gap 
; 169  : 	//		--> 2,  : 1   
; 170  : 
; 171  : 	if(posNum == 0)

  00003	8b 45 10	 mov	 eax, DWORD PTR _posNum$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 02		 jne	 SHORT $LN2@GetPositio

; 179  : }

  0000a	5d		 pop	 ebp
  0000b	c3		 ret	 0
$LN2@GetPositio:

; 172  : 		return 0;
; 173  : 	else if(posNum == blockCount)

  0000c	8b 55 14	 mov	 edx, DWORD PTR _blockCount$[ebp]
  0000f	3b c2		 cmp	 eax, edx
  00011	75 08		 jne	 SHORT $LN4@GetPositio

; 174  : 		return (endPosition - startPosition);

  00013	8b 45 0c	 mov	 eax, DWORD PTR _endPosition$[ebp]
  00016	2b 45 08	 sub	 eax, DWORD PTR _startPosition$[ebp]

; 179  : }

  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
$LN4@GetPositio:

; 175  : 	else if(posNum == 1)

  0001b	8b ca		 mov	 ecx, edx
  0001d	2b c8		 sub	 ecx, eax
  0001f	56		 push	 esi
  00020	83 f8 01	 cmp	 eax, 1
  00023	75 41		 jne	 SHORT $LN6@GetPositio

; 324  : 	return CMath::Round((double)((end - start) - interBlockHalfGap*gapCount - compartLineCount*compartLineThickness) / (double)blockCount);

  00025	0f af 4d 18	 imul	 ecx, DWORD PTR _interBlockHalfGap$[ebp]

; 176  : 		return (GetBlockLength(startPosition, endPosition, blockCount, (blockCount-posNum)*2, (blockCount-1), interBlockHalfGap, compartLineThickness) + interBlockHalfGap);

  00029	8d 42 ff	 lea	 eax, DWORD PTR [edx-1]

; 324  : 	return CMath::Round((double)((end - start) - interBlockHalfGap*gapCount - compartLineCount*compartLineThickness) / (double)blockCount);

  0002c	0f af 45 1c	 imul	 eax, DWORD PTR _compartLineThickness$[ebp]
  00030	83 ec 08	 sub	 esp, 8
  00033	66 0f 6e c2	 movd	 xmm0, edx
  00037	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  0003b	f7 d9		 neg	 ecx
  0003d	03 c9		 add	 ecx, ecx
  0003f	2b c8		 sub	 ecx, eax
  00041	2b 4d 08	 sub	 ecx, DWORD PTR _startPosition$[ebp]
  00044	03 4d 0c	 add	 ecx, DWORD PTR _endPosition$[ebp]
  00047	66 0f 6e c9	 movd	 xmm1, ecx
  0004b	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1
  0004f	f2 0f 5e c8	 divsd	 xmm1, xmm0
  00053	f2 0f 11 0c 24	 movsd	 QWORD PTR [esp], xmm1
  00058	e8 00 00 00 00	 call	 ?Round@CMath@@SAHN@Z	; CMath::Round
  0005d	83 c4 08	 add	 esp, 8

; 176  : 		return (GetBlockLength(startPosition, endPosition, blockCount, (blockCount-posNum)*2, (blockCount-1), interBlockHalfGap, compartLineThickness) + interBlockHalfGap);

  00060	03 45 18	 add	 eax, DWORD PTR _interBlockHalfGap$[ebp]
  00063	5e		 pop	 esi

; 179  : }

  00064	5d		 pop	 ebp
  00065	c3		 ret	 0
$LN6@GetPositio:

; 177  : 
; 178  : 	return (GetBlockLength(startPosition, endPosition, blockCount-posNum+1, (blockCount-posNum)*2+1, blockCount-posNum+1, interBlockHalfGap, compartLineThickness) + interBlockHalfGap*2 +compartLineThickness);

  00066	8d 04 4d 01 00
	00 00		 lea	 eax, DWORD PTR [ecx*2+1]
  0006d	57		 push	 edi

; 324  : 	return CMath::Round((double)((end - start) - interBlockHalfGap*gapCount - compartLineCount*compartLineThickness) / (double)blockCount);

  0006e	8b 7d 18	 mov	 edi, DWORD PTR _interBlockHalfGap$[ebp]

; 177  : 
; 178  : 	return (GetBlockLength(startPosition, endPosition, blockCount-posNum+1, (blockCount-posNum)*2+1, blockCount-posNum+1, interBlockHalfGap, compartLineThickness) + interBlockHalfGap*2 +compartLineThickness);

  00071	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]

; 324  : 	return CMath::Round((double)((end - start) - interBlockHalfGap*gapCount - compartLineCount*compartLineThickness) / (double)blockCount);

  00074	8b 4d 0c	 mov	 ecx, DWORD PTR _endPosition$[ebp]
  00077	83 ec 08	 sub	 esp, 8
  0007a	0f af c7	 imul	 eax, edi
  0007d	66 0f 6e c2	 movd	 xmm0, edx
  00081	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00085	2b c8		 sub	 ecx, eax
  00087	8b c2		 mov	 eax, edx
  00089	0f af 45 1c	 imul	 eax, DWORD PTR _compartLineThickness$[ebp]
  0008d	2b c8		 sub	 ecx, eax
  0008f	2b 4d 08	 sub	 ecx, DWORD PTR _startPosition$[ebp]
  00092	66 0f 6e c9	 movd	 xmm1, ecx
  00096	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1
  0009a	f2 0f 5e c8	 divsd	 xmm1, xmm0
  0009e	f2 0f 11 0c 24	 movsd	 QWORD PTR [esp], xmm1
  000a3	e8 00 00 00 00	 call	 ?Round@CMath@@SAHN@Z	; CMath::Round
  000a8	83 c4 08	 add	 esp, 8

; 177  : 
; 178  : 	return (GetBlockLength(startPosition, endPosition, blockCount-posNum+1, (blockCount-posNum)*2+1, blockCount-posNum+1, interBlockHalfGap, compartLineThickness) + interBlockHalfGap*2 +compartLineThickness);

  000ab	03 45 1c	 add	 eax, DWORD PTR _compartLineThickness$[ebp]
  000ae	8d 04 78	 lea	 eax, DWORD PTR [eax+edi*2]
  000b1	5f		 pop	 edi
  000b2	5e		 pop	 esi

; 179  : }

  000b3	5d		 pop	 ebp
  000b4	c3		 ret	 0
?GetPositionLength@CBlocksPositionCalculator@@SAHHHHHHH@Z ENDP ; CBlocksPositionCalculator::GetPositionLength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
;	COMDAT ?GetBlockRegion@CBlocksPositionCalculator@@SAXHHHABV?$CList@NN@@HAAN1@Z
_TEXT	SEGMENT
_absoluteOrgPt$ = 8					; size = 4
_interBlockHalfGap$ = 12				; size = 4
_compartLineThickness$ = 16				; size = 4
_positionList$ = 20					; size = 4
_nIndex$ = 24						; size = 4
_x1$ = 28						; size = 4
_x2$ = 32						; size = 4
?GetBlockRegion@CBlocksPositionCalculator@@SAXHHHABV?$CList@NN@@HAAN1@Z PROC ; CBlocksPositionCalculator::GetBlockRegion, COMDAT

; 128  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 313  : 	POSITION pos = positionList.FindIndex(nIndex);

  00003	8b 55 18	 mov	 edx, DWORD PTR _nIndex$[ebp]
  00006	8b ca		 mov	 ecx, edx
  00008	66 0f 6e 4d 08	 movd	 xmm1, DWORD PTR _absoluteOrgPt$[ebp]

; 128  : {

  0000d	56		 push	 esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 1133 : 	if (nIndex >= m_nCount || nIndex < 0)

  0000e	8b 75 14	 mov	 esi, DWORD PTR _positionList$[ebp]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp

; 128  : {

  00011	57		 push	 edi

; 129  : 	// (2006/10/8 - Seung-Won, Bae) Make a simple logic.
; 130  : 	// Get Start Position
; 131  : 	x1 = GetAbsolutePosition(absoluteOrgPt, positionList, nIndex);

  00012	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 1133 : 	if (nIndex >= m_nCount || nIndex < 0)

  00016	3b 56 0c	 cmp	 edx, DWORD PTR [esi+12]
  00019	7d 1e		 jge	 SHORT $LN6@GetBlockRe
  0001b	85 d2		 test	 edx, edx
  0001d	78 1a		 js	 SHORT $LN6@GetBlockRe

; 1134 : 		return NULL;  // went too far
; 1135 : 
; 1136 : 	CNode* pNode = m_pNodeHead;

  0001f	8b 46 04	 mov	 eax, DWORD PTR [esi+4]

; 1137 : 	while (nIndex--)

  00022	74 07		 je	 SHORT $LN25@GetBlockRe
$LL9@GetBlockRe:

; 1138 : 	{
; 1139 : 		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 1140 : 		pNode = pNode->pNext;

  00024	8b 00		 mov	 eax, DWORD PTR [eax]
  00026	83 e9 01	 sub	 ecx, 1
  00029	75 f9		 jne	 SHORT $LL9@GetBlockRe
$LN25@GetBlockRe:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp

; 314  : 	if(pos != NULL)

  0002b	85 c0		 test	 eax, eax
  0002d	74 0a		 je	 SHORT $LN6@GetBlockRe

; 315  : 		return (positionList.GetAt(pos) + absoluteOrgPt);

  0002f	0f 28 d1	 movaps	 xmm2, xmm1
  00032	f2 0f 58 50 08	 addsd	 xmm2, QWORD PTR [eax+8]
  00037	eb 03		 jmp	 SHORT $LN5@GetBlockRe
$LN6@GetBlockRe:

; 316  : 	return absoluteOrgPt;

  00039	0f 28 d1	 movaps	 xmm2, xmm1
$LN5@GetBlockRe:

; 129  : 	// (2006/10/8 - Seung-Won, Bae) Make a simple logic.
; 130  : 	// Get Start Position
; 131  : 	x1 = GetAbsolutePosition(absoluteOrgPt, positionList, nIndex);

  0003c	8b 4d 1c	 mov	 ecx, DWORD PTR _x1$[ebp]

; 132  : 	if( 0 < nIndex) x1 += interBlockHalfGap + compartLineThickness;

  0003f	8b 7d 0c	 mov	 edi, DWORD PTR _interBlockHalfGap$[ebp]
  00042	f2 0f 11 11	 movsd	 QWORD PTR [ecx], xmm2
  00046	85 d2		 test	 edx, edx
  00048	7e 15		 jle	 SHORT $LN2@GetBlockRe
  0004a	8b 45 10	 mov	 eax, DWORD PTR _compartLineThickness$[ebp]
  0004d	03 c7		 add	 eax, edi
  0004f	66 0f 6e c0	 movd	 xmm0, eax
  00053	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00057	f2 0f 58 c2	 addsd	 xmm0, xmm2
  0005b	f2 0f 11 01	 movsd	 QWORD PTR [ecx], xmm0
$LN2@GetBlockRe:

; 133  : 
; 134  : 	// Get End Position
; 135  : 	x2 = GetAbsolutePosition(absoluteOrgPt, positionList, nIndex + 1);

  0005f	42		 inc	 edx

; 313  : 	POSITION pos = positionList.FindIndex(nIndex);

  00060	8b c2		 mov	 eax, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 1133 : 	if (nIndex >= m_nCount || nIndex < 0)

  00062	3b 46 0c	 cmp	 eax, DWORD PTR [esi+12]
  00065	7d 19		 jge	 SHORT $LN15@GetBlockRe
  00067	85 c0		 test	 eax, eax
  00069	78 15		 js	 SHORT $LN15@GetBlockRe

; 1134 : 		return NULL;  // went too far
; 1135 : 
; 1136 : 	CNode* pNode = m_pNodeHead;

  0006b	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]

; 1137 : 	while (nIndex--)

  0006e	74 07		 je	 SHORT $LN27@GetBlockRe
$LL18@GetBlockRe:

; 1138 : 	{
; 1139 : 		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 1140 : 		pNode = pNode->pNext;

  00070	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00072	83 e8 01	 sub	 eax, 1
  00075	75 f9		 jne	 SHORT $LL18@GetBlockRe
$LN27@GetBlockRe:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp

; 314  : 	if(pos != NULL)

  00077	85 c9		 test	 ecx, ecx
  00079	74 05		 je	 SHORT $LN15@GetBlockRe

; 315  : 		return (positionList.GetAt(pos) + absoluteOrgPt);

  0007b	f2 0f 58 49 08	 addsd	 xmm1, QWORD PTR [ecx+8]
$LN15@GetBlockRe:

; 133  : 
; 134  : 	// Get End Position
; 135  : 	x2 = GetAbsolutePosition(absoluteOrgPt, positionList, nIndex + 1);

  00080	8b 4d 20	 mov	 ecx, DWORD PTR _x2$[ebp]
  00083	f2 0f 11 09	 movsd	 QWORD PTR [ecx], xmm1

; 136  : 	if( positionList.GetCount() - 1 != nIndex + 1) x2 -= interBlockHalfGap;

  00087	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0008a	48		 dec	 eax
  0008b	3b c2		 cmp	 eax, edx
  0008d	74 10		 je	 SHORT $LN3@GetBlockRe
  0008f	66 0f 6e c7	 movd	 xmm0, edi
  00093	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00097	f2 0f 5c c8	 subsd	 xmm1, xmm0
  0009b	f2 0f 11 09	 movsd	 QWORD PTR [ecx], xmm1
$LN3@GetBlockRe:

; 137  : /*
; 138  : 	if(nIndex == 0 && positionList.GetCount() == 2){ // 2    
; 139  : 		x1 = GetAbsolutePosition(absoluteOrgPt, positionList, nIndex);
; 140  : 		x2 = GetAbsolutePosition(absoluteOrgPt, positionList, nIndex +1);
; 141  : 	}
; 142  : 	else if(nIndex == 0){ // 2  
; 143  : 		x1 = GetAbsolutePosition(absoluteOrgPt, positionList, nIndex);
; 144  : 		x2 = GetAbsolutePosition(absoluteOrgPt, positionList, nIndex +1) - (interBlockHalfGap + compartLineThickness);
; 145  : 	}
; 146  : 	else if(nIndex == positionList.GetCount() -1){ // 
; 147  : 		x1 = GetAbsolutePosition(absoluteOrgPt, positionList, nIndex) + (interBlockHalfGap + compartLineThickness);
; 148  : 		x2 = GetAbsolutePosition(absoluteOrgPt, positionList, nIndex +1);
; 149  : 	}
; 150  : 	else{ // 
; 151  : 		x1 = GetAbsolutePosition(absoluteOrgPt, positionList, nIndex) + (interBlockHalfGap + compartLineThickness);
; 152  : 		x2 = GetAbsolutePosition(absoluteOrgPt, positionList, nIndex +1) - (interBlockHalfGap + compartLineThickness);
; 153  : 	}
; 154  : */
; 155  : }

  0009f	5f		 pop	 edi
  000a0	5e		 pop	 esi
  000a1	5d		 pop	 ebp
  000a2	c3		 ret	 0
?GetBlockRegion@CBlocksPositionCalculator@@SAXHHHABV?$CList@NN@@HAAN1@Z ENDP ; CBlocksPositionCalculator::GetBlockRegion
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
;	COMDAT ?GetSavedPosition@CBlocksPositionCalculator@@SA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@ABV?$CList@NN@@ABV23@@Z
_TEXT	SEGMENT
$T2 = -24						; size = 4
_temp$3 = -20						; size = 4
_blocksPosition$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_positionList$ = 12					; size = 4
_positionKindName$ = 16					; size = 4
?GetSavedPosition@CBlocksPositionCalculator@@SA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@ABV?$CList@NN@@ABV23@@Z PROC ; CBlocksPositionCalculator::GetSavedPosition, COMDAT

; 109  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?GetSavedPosition@CBlocksPositionCalculator@@SA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@ABV?$CList@NN@@ABV23@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 110  : 	POSITION pos = positionList.GetHeadPosition();

  00028	8b 75 0c	 mov	 esi, DWORD PTR _positionList$[ebp]
  0002b	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0
  00032	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]

; 111  : 	if(pos == NULL)

  00035	85 ff		 test	 edi, edi
  00037	75 4c		 jne	 SHORT $LN5@GetSavedPo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h

; 2401 : 		CStringT strResult( str1.GetManager() );

  00039	8b 75 10	 mov	 esi, DWORD PTR _positionKindName$[ebp]
  0003c	8b ce		 mov	 ecx, esi
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp

; 112  : 		return (positionKindName + "\r\n");

  0003e	89 7d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h

; 2401 : 		CStringT strResult( str1.GetManager() );

  00041	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetManager@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEPAUIAtlStringMgr@2@XZ
  00047	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  0004a	8b cf		 mov	 ecx, edi
  0004c	50		 push	 eax
  0004d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PAUIAtlStringMgr@1@@Z
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h

; 519  : 		return( GetData()->nDataLength );

  00053	8b 0e		 mov	 ecx, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h

; 2403 : 		CThisSimpleString::Concatenate( strResult, str1, str1.GetLength(), psz2, CThisSimpleString::StringLength( psz2 ) );

  00055	6a 02		 push	 2
  00057	68 00 00 00 00	 push	 OFFSET ??_C@_02PCIJFNDE@?$AN?6@

; 2404 : 
; 2405 : 		return( strResult );

  0005c	c7 45 e8 02 00
	00 00		 mov	 DWORD PTR $T2[ebp], 2
  00063	ff 71 f4	 push	 DWORD PTR [ecx-12]
  00066	51		 push	 ecx
  00067	57		 push	 edi
  00068	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Concatenate@?$CSimpleStringT@D$00@ATL@@KAXAAV12@PBDH1H@Z
  0006e	83 c4 14	 add	 esp, 20			; 00000014H
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp

; 112  : 		return (positionKindName + "\r\n");

  00071	8b c7		 mov	 eax, edi

; 122  : }

  00073	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00076	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007d	59		 pop	 ecx
  0007e	5f		 pop	 edi
  0007f	5e		 pop	 esi
  00080	5b		 pop	 ebx
  00081	8b e5		 mov	 esp, ebp
  00083	5d		 pop	 ebp
  00084	c3		 ret	 0
$LN5@GetSavedPo:

; 113  : 
; 114  : 	CString blocksPosition = positionKindName;

  00085	ff 75 10	 push	 DWORD PTR _positionKindName$[ebp]
  00088	8d 4d f0	 lea	 ecx, DWORD PTR _blocksPosition$[ebp]
  0008b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z

; 115  : 	for(int i = 0; i < positionList.GetCount(); i++){

  00091	33 db		 xor	 ebx, ebx
  00093	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  0009a	39 5e 0c	 cmp	 DWORD PTR [esi+12], ebx
  0009d	7e 49		 jle	 SHORT $LN3@GetSavedPo
  0009f	90		 npad	 1
$LL4@GetSavedPo:

; 116  : 		int data = (int)positionList.GetNext(pos);

  000a0	f2 0f 2c 77 08	 cvttsd2si esi, QWORD PTR [edi+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 817  : 	{ CNode* pNode = (CNode*) rPosition;

  000a5	8d 07		 lea	 eax, DWORD PTR [edi]

; 818  : 		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 819  : 		rPosition = (POSITION) pNode->pNext;

  000a7	8b 3f		 mov	 edi, DWORD PTR [edi]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp

; 117  : 		CString temp;

  000a9	8d 4d ec	 lea	 ecx, DWORD PTR _temp$3[ebp]
  000ac	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 118  : 		temp.Format("%d;", data);

  000b2	56		 push	 esi
  000b3	8d 45 ec	 lea	 eax, DWORD PTR _temp$3[ebp]
  000b6	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  000ba	68 00 00 00 00	 push	 OFFSET ??_C@_03DKDLPDCL@?$CFd?$DL@
  000bf	50		 push	 eax
  000c0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Format@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAAXPBDZZ
  000c6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 119  : 		blocksPosition += temp;

  000c9	8d 45 ec	 lea	 eax, DWORD PTR _temp$3[ebp]
  000cc	8d 4d f0	 lea	 ecx, DWORD PTR _blocksPosition$[ebp]
  000cf	50		 push	 eax
  000d0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV?$CSimpleStringT@D$00@1@@Z

; 120  : 	}

  000d6	8d 4d ec	 lea	 ecx, DWORD PTR _temp$3[ebp]
  000d9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  000df	8b 45 0c	 mov	 eax, DWORD PTR _positionList$[ebp]
  000e2	43		 inc	 ebx
  000e3	3b 58 0c	 cmp	 ebx, DWORD PTR [eax+12]
  000e6	7c b8		 jl	 SHORT $LL4@GetSavedPo
$LN3@GetSavedPo:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h

; 2401 : 		CStringT strResult( str1.GetManager() );

  000e8	8d 4d f0	 lea	 ecx, DWORD PTR _blocksPosition$[ebp]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp

; 121  : 	return (blocksPosition + "\r\n");

  000eb	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h

; 2401 : 		CStringT strResult( str1.GetManager() );

  000ef	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetManager@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEPAUIAtlStringMgr@2@XZ
  000f5	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  000f8	8b ce		 mov	 ecx, esi
  000fa	50		 push	 eax
  000fb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PAUIAtlStringMgr@1@@Z

; 2403 : 		CThisSimpleString::Concatenate( strResult, str1, str1.GetLength(), psz2, CThisSimpleString::StringLength( psz2 ) );

  00101	8b 4d f0	 mov	 ecx, DWORD PTR _blocksPosition$[ebp]
  00104	6a 02		 push	 2
  00106	68 00 00 00 00	 push	 OFFSET ??_C@_02PCIJFNDE@?$AN?6@

; 2404 : 
; 2405 : 		return( strResult );

  0010b	c7 45 e8 04 00
	00 00		 mov	 DWORD PTR $T2[ebp], 4
  00112	ff 71 f4	 push	 DWORD PTR [ecx-12]
  00115	51		 push	 ecx
  00116	56		 push	 esi
  00117	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Concatenate@?$CSimpleStringT@D$00@ATL@@KAXAAV12@PBDH1H@Z
  0011d	83 c4 14	 add	 esp, 20			; 00000014H
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp

; 121  : 	return (blocksPosition + "\r\n");

  00120	8d 4d f0	 lea	 ecx, DWORD PTR _blocksPosition$[ebp]
  00123	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00129	8b c6		 mov	 eax, esi

; 122  : }

  0012b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0012e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00135	59		 pop	 ecx
  00136	5f		 pop	 edi
  00137	5e		 pop	 esi
  00138	5b		 pop	 ebx
  00139	8b e5		 mov	 esp, ebp
  0013b	5d		 pop	 ebp
  0013c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetSavedPosition@CBlocksPositionCalculator@@SA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@ABV?$CList@NN@@ABV23@@Z$3:
  00000	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]
  00003	83 e0 02	 and	 eax, 2
  00006	0f 84 0d 00 00
	00		 je	 $LN14@GetSavedPo
  0000c	83 65 e8 fd	 and	 DWORD PTR $T2[ebp], -3	; fffffffdH
  00010	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00013	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$LN14@GetSavedPo:
  00019	c3		 ret	 0
__unwindfunclet$?GetSavedPosition@CBlocksPositionCalculator@@SA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@ABV?$CList@NN@@ABV23@@Z$1:
  0001a	8d 4d f0	 lea	 ecx, DWORD PTR _blocksPosition$[ebp]
  0001d	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?GetSavedPosition@CBlocksPositionCalculator@@SA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@ABV?$CList@NN@@ABV23@@Z$2:
  00023	8d 4d ec	 lea	 ecx, DWORD PTR _temp$3[ebp]
  00026	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?GetSavedPosition@CBlocksPositionCalculator@@SA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@ABV?$CList@NN@@ABV23@@Z$4:
  0002c	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]
  0002f	83 e0 04	 and	 eax, 4
  00032	0f 84 0d 00 00
	00		 je	 $LN29@GetSavedPo
  00038	83 65 e8 fb	 and	 DWORD PTR $T2[ebp], -5	; fffffffbH
  0003c	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0003f	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$LN29@GetSavedPo:
  00045	c3		 ret	 0
  00046	cc		 int	 3
  00047	cc		 int	 3
  00048	cc		 int	 3
  00049	cc		 int	 3
  0004a	cc		 int	 3
__ehhandler$?GetSavedPosition@CBlocksPositionCalculator@@SA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@ABV?$CList@NN@@ABV23@@Z:
  0004b	90		 npad	 1
  0004c	90		 npad	 1
  0004d	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00051	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00054	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  00057	33 c8		 xor	 ecx, eax
  00059	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005e	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?GetSavedPosition@CBlocksPositionCalculator@@SA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@ABV?$CList@NN@@ABV23@@Z
  00063	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?GetSavedPosition@CBlocksPositionCalculator@@SA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@ABV?$CList@NN@@ABV23@@Z ENDP ; CBlocksPositionCalculator::GetSavedPosition
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
;	COMDAT ?SetBlocksPosition@CBlocksPositionCalculator@@SAXAAV?$CList@NN@@HABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
_TEXT	SEGMENT
_newPositionList$ = -40					; size = 28
__$EHRec$ = -12						; size = 12
_positionList$ = 8					; size = 4
_maxExtent$ = 12					; size = 4
_positionData$ = 16					; size = 4
?SetBlocksPosition@CBlocksPositionCalculator@@SAXAAV?$CList@NN@@HABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z PROC ; CBlocksPositionCalculator::SetBlocksPosition, COMDAT

; 79   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?SetBlocksPosition@CBlocksPositionCalculator@@SAXAAV?$CList@NN@@HABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	50		 push	 eax
  0001e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 80   : 	// position  .
; 81   : 	if(positionList.GetCount() <= 0){

  00027	8b 75 08	 mov	 esi, DWORD PTR _positionList$[ebp]
  0002a	83 7e 0c 00	 cmp	 DWORD PTR [esi+12], 0
  0002e	7f 1d		 jg	 SHORT $LN2@SetBlocksP

; 82   : 		GetBlocksPosition(positionData, positionList);

  00030	56		 push	 esi
  00031	ff 75 10	 push	 DWORD PTR _positionData$[ebp]
  00034	e8 00 00 00 00	 call	 ?GetBlocksPosition@CBlocksPositionCalculator@@CA_NABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAV?$CList@NN@@@Z ; CBlocksPositionCalculator::GetBlocksPosition
  00039	83 c4 08	 add	 esp, 8

; 104  : }

  0003c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0003f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00046	59		 pop	 ecx
  00047	5f		 pop	 edi
  00048	5e		 pop	 esi
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
$LN2@SetBlocksP:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 851  : {

  0004d	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _newPositionList$[ebp], OFFSET ??_7?$CList@NN@@6B@

; 852  : 	ASSERT(nBlockSize > 0);
; 853  : 
; 854  : 	m_nCount = 0;

  00054	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _newPositionList$[ebp+12], 0

; 855  : 	m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;

  0005b	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _newPositionList$[ebp+16], 0
  00062	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _newPositionList$[ebp+8], 0
  00069	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _newPositionList$[ebp+4], 0

; 856  : 	m_pBlocks = NULL;

  00070	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _newPositionList$[ebp+20], 0

; 857  : 	m_nBlockSize = nBlockSize;

  00077	c7 45 f0 0a 00
	00 00		 mov	 DWORD PTR _newPositionList$[ebp+24], 10 ; 0000000aH
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp

; 87   : 	if(!GetBlocksPosition(positionData, newPositionList))

  0007e	8d 45 d8	 lea	 eax, DWORD PTR _newPositionList$[ebp]
  00081	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00088	50		 push	 eax
  00089	ff 75 10	 push	 DWORD PTR _positionData$[ebp]
  0008c	e8 00 00 00 00	 call	 ?GetBlocksPosition@CBlocksPositionCalculator@@CA_NABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAV?$CList@NN@@@Z ; CBlocksPositionCalculator::GetBlocksPosition
  00091	83 c4 08	 add	 esp, 8
  00094	84 c0		 test	 al, al
  00096	74 4f		 je	 SHORT $LN5@SetBlocksP
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 797  : 	{ ENSURE(m_pNodeTail != NULL);

  00098	8b 45 e0	 mov	 eax, DWORD PTR _newPositionList$[ebp+8]
  0009b	85 c0		 test	 eax, eax
  0009d	0f 84 d3 00 00
	00		 je	 $LN73@SetBlocksP
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp

; 90   : 	if(newPositionList.GetTail() == maxExtent){

  000a3	66 0f 6e 45 0c	 movd	 xmm0, DWORD PTR _maxExtent$[ebp]
  000a8	f2 0f 10 48 08	 movsd	 xmm1, QWORD PTR [eax+8]
  000ad	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  000b1	66 0f 2e c8	 ucomisd xmm1, xmm0
  000b5	9f		 lahf
  000b6	f6 c4 44	 test	 ah, 68			; 00000044H
  000b9	7a 6f		 jp	 SHORT $LN32@SetBlocksP

; 292  : 	if(sourceList.GetCount() <= 0 || targetList.GetCount() != sourceList.GetCount())

  000bb	8b 45 e4	 mov	 eax, DWORD PTR _newPositionList$[ebp+12]
  000be	85 c0		 test	 eax, eax
  000c0	7e 25		 jle	 SHORT $LN5@SetBlocksP
  000c2	39 46 0c	 cmp	 DWORD PTR [esi+12], eax
  000c5	75 20		 jne	 SHORT $LN5@SetBlocksP

; 293  : 		return false;
; 294  : 
; 295  : 	POSITION targetPos = targetList.GetHeadPosition();

  000c7	8b 46 04	 mov	 eax, DWORD PTR [esi+4]

; 296  : 	POSITION sourcePos = sourceList.GetHeadPosition();

  000ca	8b 4d dc	 mov	 ecx, DWORD PTR _newPositionList$[ebp+4]

; 297  : 	while(targetPos != NULL && sourcePos != NULL){

  000cd	85 c0		 test	 eax, eax
  000cf	74 16		 je	 SHORT $LN5@SetBlocksP
$LL20@SetBlocksP:
  000d1	85 c9		 test	 ecx, ecx
  000d3	74 12		 je	 SHORT $LN5@SetBlocksP

; 298  : 		double dData = sourceList.GetAt(sourcePos);

  000d5	f2 0f 10 41 08	 movsd	 xmm0, QWORD PTR [ecx+8]

; 299  : 		targetList.SetAt(targetPos, dData);

  000da	f2 0f 11 40 08	 movsd	 QWORD PTR [eax+8], xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 813  : 		rPosition = (POSITION) pNode->pNext;

  000df	8b 00		 mov	 eax, DWORD PTR [eax]

; 819  : 		rPosition = (POSITION) pNode->pNext;

  000e1	8b 09		 mov	 ecx, DWORD PTR [ecx]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp

; 297  : 	while(targetPos != NULL && sourcePos != NULL){

  000e3	85 c0		 test	 eax, eax
  000e5	75 ea		 jne	 SHORT $LL20@SetBlocksP
$LN5@SetBlocksP:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 872  : 	m_pBlocks->FreeDataChain();

  000e7	8b 4d ec	 mov	 ecx, DWORD PTR _newPositionList$[ebp+20]

; 878  : {

  000ea	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  000f1	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _newPositionList$[ebp], OFFSET ??_7?$CList@NN@@6B@

; 870  : 	m_nCount = 0;

  000f8	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _newPositionList$[ebp+12], 0

; 871  : 	m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;

  000ff	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _newPositionList$[ebp+16], 0
  00106	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _newPositionList$[ebp+8], 0
  0010d	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _newPositionList$[ebp+4], 0

; 872  : 	m_pBlocks->FreeDataChain();

  00114	e8 00 00 00 00	 call	 ?FreeDataChain@CPlex@@QAEXXZ ; CPlex::FreeDataChain
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp

; 104  : }

  00119	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0011c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00123	59		 pop	 ecx
  00124	5f		 pop	 edi
  00125	5e		 pop	 esi
  00126	8b e5		 mov	 esp, ebp
  00128	5d		 pop	 ebp
  00129	c3		 ret	 0
$LN32@SetBlocksP:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 797  : 	{ ENSURE(m_pNodeTail != NULL);

  0012a	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp

; 100  : 	int nOldAllRegionLength = ( int)newPositionList.GetTail();

  0012d	f2 0f 2c d1	 cvttsd2si edx, xmm1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 797  : 	{ ENSURE(m_pNodeTail != NULL);

  00131	85 c0		 test	 eax, eax
  00133	74 41		 je	 SHORT $LN73@SetBlocksP
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp

; 101  : 	int nNewAllRegionLength = ( int)positionList.GetTail();

  00135	f2 0f 2c 78 08	 cvttsd2si edi, QWORD PTR [eax+8]

; 292  : 	if(sourceList.GetCount() <= 0 || targetList.GetCount() != sourceList.GetCount())

  0013a	8b 45 e4	 mov	 eax, DWORD PTR _newPositionList$[ebp+12]
  0013d	85 c0		 test	 eax, eax
  0013f	7e a6		 jle	 SHORT $LN5@SetBlocksP
  00141	39 46 0c	 cmp	 DWORD PTR [esi+12], eax
  00144	75 a1		 jne	 SHORT $LN5@SetBlocksP

; 293  : 		return false;
; 294  : 
; 295  : 	POSITION targetPos = targetList.GetHeadPosition();

  00146	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]

; 296  : 	POSITION sourcePos = sourceList.GetHeadPosition();

  00149	8b 45 dc	 mov	 eax, DWORD PTR _newPositionList$[ebp+4]

; 297  : 	while(targetPos != NULL && sourcePos != NULL){

  0014c	85 c9		 test	 ecx, ecx
  0014e	74 16		 je	 SHORT $LN74@SetBlocksP
$LL42@SetBlocksP:
  00150	85 c0		 test	 eax, eax
  00152	74 12		 je	 SHORT $LN74@SetBlocksP

; 298  : 		double dData = sourceList.GetAt(sourcePos);

  00154	f2 0f 10 40 08	 movsd	 xmm0, QWORD PTR [eax+8]

; 299  : 		targetList.SetAt(targetPos, dData);

  00159	f2 0f 11 41 08	 movsd	 QWORD PTR [ecx+8], xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 813  : 		rPosition = (POSITION) pNode->pNext;

  0015e	8b 09		 mov	 ecx, DWORD PTR [ecx]

; 819  : 		rPosition = (POSITION) pNode->pNext;

  00160	8b 00		 mov	 eax, DWORD PTR [eax]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp

; 297  : 	while(targetPos != NULL && sourcePos != NULL){

  00162	85 c9		 test	 ecx, ecx
  00164	75 ea		 jne	 SHORT $LL42@SetBlocksP
$LN74@SetBlocksP:

; 102  : 	if(SetBlocksPosition(positionList, newPositionList))
; 103  : 		RecalculatePositions(positionList, nOldAllRegionLength, nNewAllRegionLength);

  00166	57		 push	 edi
  00167	52		 push	 edx
  00168	56		 push	 esi
  00169	e8 00 00 00 00	 call	 ?RecalculatePositions@CBlocksPositionCalculator@@SAXAAV?$CList@NN@@HH@Z ; CBlocksPositionCalculator::RecalculatePositions
  0016e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00171	e9 71 ff ff ff	 jmp	 $LN5@SetBlocksP
$LN73@SetBlocksP:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 797  : 	{ ENSURE(m_pNodeTail != NULL);

  00176	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN76@SetBlocksP:
  0017b	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SetBlocksPosition@CBlocksPositionCalculator@@SAXAAV?$CList@NN@@HABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR _newPositionList$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$CList@NN@@UAE@XZ	; CList<double,double>::~CList<double,double>
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?SetBlocksPosition@CBlocksPositionCalculator@@SAXAAV?$CList@NN@@HABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a d8	 mov	 ecx, DWORD PTR [edx-40]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?SetBlocksPosition@CBlocksPositionCalculator@@SAXAAV?$CList@NN@@HABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?SetBlocksPosition@CBlocksPositionCalculator@@SAXAAV?$CList@NN@@HABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ENDP ; CBlocksPositionCalculator::SetBlocksPosition
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
;	COMDAT ?Add_DoubleSize@CBlocksPositionCalculator@@SAXAAV?$CList@NN@@HHHHH@Z
_TEXT	SEGMENT
_positionList$ = 8					; size = 4
_blockCount$ = 12					; size = 4
_doubleSizeBlockNum$ = 16				; size = 4
_allRegionLength$ = 20					; size = 4
_interBlockHalfGap$ = 24				; size = 4
_compartLineThickness$ = 28				; size = 4
?Add_DoubleSize@CBlocksPositionCalculator@@SAXAAV?$CList@NN@@HHHHH@Z PROC ; CBlocksPositionCalculator::Add_DoubleSize, COMDAT

; 62   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 262  : 	if(doubleSizeBlockNum < 0 || doubleSizeBlockNum >= blockCount)

  00003	8b 45 10	 mov	 eax, DWORD PTR _doubleSizeBlockNum$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR _blockCount$[ebp]

; 62   : {

  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 262  : 	if(doubleSizeBlockNum < 0 || doubleSizeBlockNum >= blockCount)

  0000c	85 c0		 test	 eax, eax
  0000e	78 0f		 js	 SHORT $LN9@Add_Double
  00010	3b c1		 cmp	 eax, ecx
  00012	7d 0b		 jge	 SHORT $LN9@Add_Double

; 264  : 
; 265  : 	return (blockCount > 2 ? 2: 1);

  00014	33 db		 xor	 ebx, ebx
  00016	83 f9 02	 cmp	 ecx, 2
  00019	0f 9f c3	 setg	 bl
  0001c	43		 inc	 ebx
  0001d	eb 02		 jmp	 SHORT $LN7@Add_Double
$LN9@Add_Double:

; 263  : 		return 0;

  0001f	33 db		 xor	 ebx, ebx
$LN7@Add_Double:

; 63   : 	int doubleSizeCount = GetDoubleSizeBlockCount(blockCount, doubleSizeBlockNum);
; 64   : 	int realBlockCount = blockCount + doubleSizeCount;

  00021	8d 04 0b	 lea	 eax, DWORD PTR [ebx+ecx]

; 65   : 	int prePosition = 0;

  00024	33 ff		 xor	 edi, edi
  00026	33 f6		 xor	 esi, esi

; 67   : 	for(int i = 0; i <= realBlockCount; i++){

  00028	85 c0		 test	 eax, eax
  0002a	78 5f		 js	 SHORT $LN3@Add_Double
  0002c	0f 1f 40 00	 npad	 4
$LL4@Add_Double:

; 68   : 		int length = GetPositionLength(prePosition, allRegionLength, 

  00030	ff 75 1c	 push	 DWORD PTR _compartLineThickness$[ebp]
  00033	ff 75 18	 push	 DWORD PTR _interBlockHalfGap$[ebp]
  00036	50		 push	 eax
  00037	56		 push	 esi
  00038	ff 75 14	 push	 DWORD PTR _allRegionLength$[ebp]
  0003b	57		 push	 edi
  0003c	e8 00 00 00 00	 call	 ?GetPositionLength@CBlocksPositionCalculator@@SAHHHHHHH@Z ; CBlocksPositionCalculator::GetPositionLength

; 69   : 					i, realBlockCount, interBlockHalfGap, compartLineThickness);
; 70   : 		prePosition += length;

  00041	03 f8		 add	 edi, eax
  00043	83 c4 18	 add	 esp, 24			; 00000018H

; 270  : 	return (curNum > doubleSizeBlockNum && curNum <= (doubleSizeBlockNum + doubleSizeCount));

  00046	8b 45 10	 mov	 eax, DWORD PTR _doubleSizeBlockNum$[ebp]
  00049	3b f0		 cmp	 esi, eax
  0004b	7e 06		 jle	 SHORT $LN13@Add_Double
  0004d	03 c3		 add	 eax, ebx
  0004f	3b f0		 cmp	 esi, eax
  00051	7e 2e		 jle	 SHORT $LN2@Add_Double
$LN13@Add_Double:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 968  : 	CNode* pNewNode = NewNode(m_pNodeTail, NULL);

  00053	8b 4d 08	 mov	 ecx, DWORD PTR _positionList$[ebp]
  00056	6a 00		 push	 0
  00058	ff 71 08	 push	 DWORD PTR [ecx+8]
  0005b	e8 00 00 00 00	 call	 ?NewNode@?$CList@NN@@IAEPAUCNode@1@PAU21@0@Z ; CList<double,double>::NewNode

; 970  : 	if (m_pNodeTail != NULL)

  00060	8b 4d 08	 mov	 ecx, DWORD PTR _positionList$[ebp]
  00063	66 0f 6e c7	 movd	 xmm0, edi
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp

; 72   : 			positionList.AddTail(prePosition);

  00067	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 969  : 	pNewNode->data = newElement;

  0006b	f2 0f 11 40 08	 movsd	 QWORD PTR [eax+8], xmm0

; 970  : 	if (m_pNodeTail != NULL)

  00070	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00073	85 d2		 test	 edx, edx
  00075	74 04		 je	 SHORT $LN16@Add_Double

; 971  : 		m_pNodeTail->pNext = pNewNode;

  00077	89 02		 mov	 DWORD PTR [edx], eax
  00079	eb 03		 jmp	 SHORT $LN17@Add_Double
$LN16@Add_Double:

; 972  : 	else
; 973  : 		m_pNodeHead = pNewNode;

  0007b	89 41 04	 mov	 DWORD PTR [ecx+4], eax
$LN17@Add_Double:

; 974  : 	m_pNodeTail = pNewNode;

  0007e	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN2@Add_Double:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp

; 67   : 	for(int i = 0; i <= realBlockCount; i++){

  00081	8b 45 0c	 mov	 eax, DWORD PTR _blockCount$[ebp]
  00084	46		 inc	 esi
  00085	03 c3		 add	 eax, ebx
  00087	3b f0		 cmp	 esi, eax
  00089	7e a5		 jle	 SHORT $LL4@Add_Double
$LN3@Add_Double:
  0008b	5f		 pop	 edi

; 73   : 	}
; 74   : }

  0008c	5e		 pop	 esi
  0008d	5b		 pop	 ebx
  0008e	5d		 pop	 ebp
  0008f	c3		 ret	 0
?Add_DoubleSize@CBlocksPositionCalculator@@SAXAAV?$CList@NN@@HHHHH@Z ENDP ; CBlocksPositionCalculator::Add_DoubleSize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
;	COMDAT ?Add_EqualityPartition@CBlocksPositionCalculator@@SAXAAV?$CList@NN@@HHHH@Z
_TEXT	SEGMENT
_pPrev$1$ = -8						; size = 4
_prePosition$1$ = -4					; size = 4
_positionList$ = 8					; size = 4
_blockCount$ = 12					; size = 4
_allRegionLength$ = 16					; size = 4
_interBlockHalfGap$ = 20				; size = 4
_compartLineThickness$ = 24				; size = 4
?Add_EqualityPartition@CBlocksPositionCalculator@@SAXAAV?$CList@NN@@HHHH@Z PROC ; CBlocksPositionCalculator::Add_EqualityPartition, COMDAT

; 50   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 52   : 	for(int i = 0; i <= blockCount; i++)

  00003	8b 45 0c	 mov	 eax, DWORD PTR _blockCount$[ebp]
  00006	83 ec 08	 sub	 esp, 8
  00009	53		 push	 ebx
  0000a	57		 push	 edi
  0000b	33 ff		 xor	 edi, edi
  0000d	33 db		 xor	 ebx, ebx
  0000f	85 c0		 test	 eax, eax
  00011	0f 88 b6 00 00
	00		 js	 $LN34@Add_Equali
  00017	56		 push	 esi
  00018	8b 75 08	 mov	 esi, DWORD PTR _positionList$[ebp]
  0001b	0f 1f 44 00 00	 npad	 5
$LL4@Add_Equali:

; 54   : 		int length = GetPositionLength(prePosition, allRegionLength, i, blockCount, interBlockHalfGap, compartLineThickness);

  00020	ff 75 18	 push	 DWORD PTR _compartLineThickness$[ebp]
  00023	ff 75 14	 push	 DWORD PTR _interBlockHalfGap$[ebp]
  00026	50		 push	 eax
  00027	53		 push	 ebx
  00028	ff 75 10	 push	 DWORD PTR _allRegionLength$[ebp]
  0002b	57		 push	 edi
  0002c	e8 00 00 00 00	 call	 ?GetPositionLength@CBlocksPositionCalculator@@SAHHHHHHH@Z ; CBlocksPositionCalculator::GetPositionLength
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 902  : 	if (m_pNodeFree == NULL)

  00031	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp

; 55   : 		prePosition += length;

  00034	03 f8		 add	 edi, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 968  : 	CNode* pNewNode = NewNode(m_pNodeTail, NULL);

  00036	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp

; 54   : 		int length = GetPositionLength(prePosition, allRegionLength, i, blockCount, interBlockHalfGap, compartLineThickness);

  00039	83 c4 18	 add	 esp, 24			; 00000018H

; 55   : 		prePosition += length;

  0003c	89 7d fc	 mov	 DWORD PTR _prePosition$1$[ebp], edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 968  : 	CNode* pNewNode = NewNode(m_pNodeTail, NULL);

  0003f	89 45 f8	 mov	 DWORD PTR _pPrev$1$[ebp], eax

; 902  : 	if (m_pNodeFree == NULL)

  00042	85 d2		 test	 edx, edx
  00044	75 48		 jne	 SHORT $LN32@Add_Equali

; 903  : 	{
; 904  : 		// add another block
; 905  : 		CPlex* pNewBlock = CPlex::Create(m_pBlocks, m_nBlockSize,

  00046	6a 10		 push	 16			; 00000010H
  00048	ff 76 18	 push	 DWORD PTR [esi+24]
  0004b	8d 46 14	 lea	 eax, DWORD PTR [esi+20]
  0004e	50		 push	 eax
  0004f	e8 00 00 00 00	 call	 ?Create@CPlex@@SGPAU1@AAPAU1@II@Z ; CPlex::Create

; 906  : 				 sizeof(CNode));
; 907  : 
; 908  : 		// chain them into free list
; 909  : 		CNode* pNode = (CNode*) pNewBlock->data();
; 910  : 		// free in reverse order to make it easier to debug
; 911  : 		pNode += m_nBlockSize - 1;

  00054	8b 56 18	 mov	 edx, DWORD PTR [esi+24]
  00057	83 c0 08	 add	 eax, 8
  0005a	8b ca		 mov	 ecx, edx
  0005c	c1 e1 04	 shl	 ecx, 4
  0005f	83 c1 f0	 add	 ecx, -16		; fffffff0H

; 912  : 		for (INT_PTR i = m_nBlockSize-1; i >= 0; i--, pNode--)

  00062	8d 7a ff	 lea	 edi, DWORD PTR [edx-1]
  00065	03 c8		 add	 ecx, eax
  00067	85 ff		 test	 edi, edi
  00069	78 19		 js	 SHORT $LN33@Add_Equali
  0006b	0f 1f 44 00 00	 npad	 5
$LL13@Add_Equali:

; 913  : 		{
; 914  : 			pNode->pNext = m_pNodeFree;

  00070	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00073	8b d1		 mov	 edx, ecx
  00075	89 01		 mov	 DWORD PTR [ecx], eax

; 915  : 			m_pNodeFree = pNode;

  00077	89 4e 10	 mov	 DWORD PTR [esi+16], ecx
  0007a	83 e9 10	 sub	 ecx, 16			; 00000010H
  0007d	83 ef 01	 sub	 edi, 1
  00080	79 ee		 jns	 SHORT $LL13@Add_Equali
  00082	eb 03		 jmp	 SHORT $LN16@Add_Equali
$LN33@Add_Equali:
  00084	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
$LN16@Add_Equali:

; 918  : 	ENSURE(m_pNodeFree != NULL);  // we must have something

  00087	85 d2		 test	 edx, edx
  00089	74 48		 je	 SHORT $LN24@Add_Equali
  0008b	8b 7d fc	 mov	 edi, DWORD PTR _prePosition$1$[ebp]
$LN32@Add_Equali:

; 919  : 
; 920  : 	CList::CNode* pNode = m_pNodeFree;
; 921  : 	m_pNodeFree = m_pNodeFree->pNext;

  0008e	8b 02		 mov	 eax, DWORD PTR [edx]
  00090	66 0f 6e c7	 movd	 xmm0, edi
  00094	89 46 10	 mov	 DWORD PTR [esi+16], eax

; 922  : 	pNode->pPrev = pPrev;

  00097	8b 45 f8	 mov	 eax, DWORD PTR _pPrev$1$[ebp]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp

; 56   : 		positionList.AddTail(prePosition);

  0009a	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 922  : 	pNode->pPrev = pPrev;

  0009e	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 923  : 	pNode->pNext = pNext;

  000a1	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 924  : 	m_nCount++;

  000a7	ff 46 0c	 inc	 DWORD PTR [esi+12]

; 969  : 	pNewNode->data = newElement;

  000aa	f2 0f 11 42 08	 movsd	 QWORD PTR [edx+8], xmm0

; 970  : 	if (m_pNodeTail != NULL)

  000af	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000b2	85 c0		 test	 eax, eax
  000b4	74 04		 je	 SHORT $LN7@Add_Equali

; 971  : 		m_pNodeTail->pNext = pNewNode;

  000b6	89 10		 mov	 DWORD PTR [eax], edx
  000b8	eb 03		 jmp	 SHORT $LN8@Add_Equali
$LN7@Add_Equali:

; 972  : 	else
; 973  : 		m_pNodeHead = pNewNode;

  000ba	89 56 04	 mov	 DWORD PTR [esi+4], edx
$LN8@Add_Equali:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp

; 52   : 	for(int i = 0; i <= blockCount; i++)

  000bd	8b 45 0c	 mov	 eax, DWORD PTR _blockCount$[ebp]
  000c0	43		 inc	 ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 974  : 	m_pNodeTail = pNewNode;

  000c1	89 56 08	 mov	 DWORD PTR [esi+8], edx
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp

; 52   : 	for(int i = 0; i <= blockCount; i++)

  000c4	3b d8		 cmp	 ebx, eax
  000c6	0f 8e 54 ff ff
	ff		 jle	 $LL4@Add_Equali
  000cc	5e		 pop	 esi
$LN34@Add_Equali:
  000cd	5f		 pop	 edi

; 58   : }

  000ce	5b		 pop	 ebx
  000cf	8b e5		 mov	 esp, ebp
  000d1	5d		 pop	 ebp
  000d2	c3		 ret	 0
$LN24@Add_Equali:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 918  : 	ENSURE(m_pNodeFree != NULL);  // we must have something

  000d3	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN36@Add_Equali:
  000d8	cc		 int	 3
?Add_EqualityPartition@CBlocksPositionCalculator@@SAXAAV?$CList@NN@@HHHH@Z ENDP ; CBlocksPositionCalculator::Add_EqualityPartition
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
;	COMDAT ?IsRectInRect@CBlocksPositionCalculator@@SA_NABVCRect@@0@Z
_TEXT	SEGMENT
_rect1$ = 8						; size = 4
_rect2$ = 12						; size = 4
?IsRectInRect@CBlocksPositionCalculator@@SA_NABVCRect@@0@Z PROC ; CBlocksPositionCalculator::IsRectInRect, COMDAT

; 36   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 37   : 	if(!rect1.PtInRect(rect2.TopLeft()))

  00004	8b 75 0c	 mov	 esi, DWORD PTR _rect2$[ebp]
  00007	57		 push	 edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h

; 648  : 	return ::PtInRect(this, point);

  00008	8b 7d 08	 mov	 edi, DWORD PTR _rect1$[ebp]
  0000b	ff 76 04	 push	 DWORD PTR [esi+4]
  0000e	ff 36		 push	 DWORD PTR [esi]
  00010	57		 push	 edi
  00011	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PtInRect@12
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp

; 37   : 	if(!rect1.PtInRect(rect2.TopLeft()))

  00017	85 c0		 test	 eax, eax
  00019	75 06		 jne	 SHORT $LN2@IsRectInRe

; 38   : 		return false;

  0001b	5f		 pop	 edi
  0001c	32 c0		 xor	 al, al

; 44   : }

  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
$LN2@IsRectInRe:

; 39   : 
; 40   : 	int bottom = rect2.bottom;

  00021	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]

; 43   : 	return rect1.PtInRect(CPoint(rect2.right, bottom)) ? true : false;

  00024	3b 47 0c	 cmp	 eax, DWORD PTR [edi+12]
  00027	8d 48 ff	 lea	 ecx, DWORD PTR [eax-1]
  0002a	0f 45 c8	 cmovne	 ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h

; 648  : 	return ::PtInRect(this, point);

  0002d	51		 push	 ecx
  0002e	ff 76 08	 push	 DWORD PTR [esi+8]
  00031	57		 push	 edi
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PtInRect@12
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp

; 43   : 	return rect1.PtInRect(CPoint(rect2.right, bottom)) ? true : false;

  00038	85 c0		 test	 eax, eax
  0003a	5f		 pop	 edi
  0003b	0f 95 c0	 setne	 al

; 44   : }

  0003e	5e		 pop	 esi
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
?IsRectInRect@CBlocksPositionCalculator@@SA_NABVCRect@@0@Z ENDP ; CBlocksPositionCalculator::IsRectInRect
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
;	COMDAT ?IsBiggerThanMinMainRegion@CBlocksPositionCalculator@@SA_NHHHH@Z
_TEXT	SEGMENT
_blockCount$ = 8					; size = 4
_allBlocksRegion$ = 12					; size = 4
_interBlockGap$ = 16					; size = 4
_compartLineThickness$ = 20				; size = 4
?IsBiggerThanMinMainRegion@CBlocksPositionCalculator@@SA_NHHHH@Z PROC ; CBlocksPositionCalculator::IsBiggerThanMinMainRegion, COMDAT

; 29   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 30   : 	int minMainRegion = (m_nMinBlockWidth * blockCount) + ((blockCount -1)*(interBlockGap + compartLineThickness));

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _blockCount$[ebp]
  00006	8b 55 10	 mov	 edx, DWORD PTR _interBlockGap$[ebp]
  00009	03 55 14	 add	 edx, DWORD PTR _compartLineThickness$[ebp]
  0000c	8d 41 ff	 lea	 eax, DWORD PTR [ecx-1]
  0000f	0f af 0d 00 00
	00 00		 imul	 ecx, DWORD PTR ?m_nMinBlockWidth@CBlocksPositionCalculator@@0HA ; CBlocksPositionCalculator::m_nMinBlockWidth
  00016	0f af d0	 imul	 edx, eax
  00019	03 d1		 add	 edx, ecx

; 31   : 	return (allBlocksRegion > minMainRegion);

  0001b	39 55 0c	 cmp	 DWORD PTR _allBlocksRegion$[ebp], edx
  0001e	0f 9f c0	 setg	 al

; 32   : }

  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
?IsBiggerThanMinMainRegion@CBlocksPositionCalculator@@SA_NHHHH@Z ENDP ; CBlocksPositionCalculator::IsBiggerThanMinMainRegion
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
;	COMDAT ?Dump@CObject@@UBEXAAVCDumpContext@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?Dump@CObject@@UBEXAAVCDumpContext@@@Z PROC		; CObject::Dump, COMDAT
; _this$ = ecx

; 122  : 	{ /* no dumping in release builds */ }

  00000	c2 04 00	 ret	 4
?Dump@CObject@@UBEXAAVCDumpContext@@@Z ENDP		; CObject::Dump
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
;	COMDAT ?AssertValid@CObject@@UBEXXZ
_TEXT	SEGMENT
?AssertValid@CObject@@UBEXXZ PROC			; CObject::AssertValid, COMDAT
; _this$ = ecx

; 120  : 	{ /* no asserts in release builds */ }

  00000	c2 00 00	 ret	 0
?AssertValid@CObject@@UBEXXZ ENDP			; CObject::AssertValid
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
;	COMDAT ?Serialize@CObject@@UAEXAAVCArchive@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?Serialize@CObject@@UAEXAAVCArchive@@@Z PROC		; CObject::Serialize, COMDAT
; _this$ = ecx

; 106  : 	{ /* CObject does not serialize anything by default */ }

  00000	c2 04 00	 ret	 4
?Serialize@CObject@@UAEXAAVCArchive@@@Z ENDP		; CObject::Serialize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
;	COMDAT ??1CObject@@UAE@XZ
_TEXT	SEGMENT
??1CObject@@UAE@XZ PROC					; CObject::~CObject, COMDAT
; _this$ = ecx

; 104  : 	{ }

  00000	c2 00 00	 ret	 0
??1CObject@@UAE@XZ ENDP					; CObject::~CObject
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	c2 00 00	 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\BlocksPositionCalculator.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

  00000	c2 00 00	 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
