; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30145.0 

	TITLE	D:\git\src\IBK\IBK_DRFN\#DRfn-CS\_Obj\ChartObject\XScaleManagerImp.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

CONST	SEGMENT
?_Fake_alloc@std@@3U_Fake_allocator@1@B	ORG $+1		; std::_Fake_alloc
CONST	ENDS
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	??3CObject@@SGXPAX@Z				; CObject::operator delete
PUBLIC	?Serialize@CObject@@UAEXAAVCArchive@@@Z		; CObject::Serialize
PUBLIC	?AssertValid@CObject@@UBEXXZ			; CObject::AssertValid
PUBLIC	?Dump@CObject@@UBEXAAVCDumpContext@@@Z		; CObject::Dump
PUBLIC	?AtlThrowImpl@ATL@@YGXJ@Z			; ATL::AtlThrowImpl
PUBLIC	?Format@CTime@ATL@@QBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@2@PBD@Z ; ATL::CTime::Format
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	??1exception@std@@UAE@XZ			; std::exception::~exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?_Throw_tree_length_error@std@@YAXXZ		; std::_Throw_tree_length_error
PUBLIC	?_Xlen_string@std@@YAXXZ			; std::_Xlen_string
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?_Xlength@?$vector@PAXV?$allocator@PAX@std@@@std@@CAXXZ ; std::vector<void *,std::allocator<void *> >::_Xlength
PUBLIC	?PushBackUNK@CDataBlockListUNK@@QAEXPAX@Z	; CDataBlockListUNK::PushBackUNK
PUBLIC	??_GCDataBlockListUNK@@UAEPAXI@Z		; CDataBlockListUNK::`scalar deleting destructor'
PUBLIC	??_GCMapTimeToLong@@UAEPAXI@Z			; CMapTimeToLong::`scalar deleting destructor'
PUBLIC	??1CXScaleManager@@UAE@XZ			; CXScaleManager::~CXScaleManager
PUBLIC	??_GCXScaleManager@@UAEPAXI@Z			; CXScaleManager::`scalar deleting destructor'
PUBLIC	??R?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0@Z ; std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator()
PUBLIC	?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@2@QAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Insert_node
PUBLIC	??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE@XZ ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::~map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >
PUBLIC	??0?$CDataBlockList@Utm@@$0CAA@@@QAE@XZ		; CDataBlockList<tm,512>::CDataBlockList<tm,512>
PUBLIC	??1?$CDataBlockList@Utm@@$0CAA@@@UAE@XZ		; CDataBlockList<tm,512>::~CDataBlockList<tm,512>
PUBLIC	??_G?$CDataBlockList@Utm@@$0CAA@@@UAEPAXI@Z	; CDataBlockList<tm,512>::`scalar deleting destructor'
PUBLIC	??0?$CDataBlockList@H$0CAA@@@QAE@XZ		; CDataBlockList<int,512>::CDataBlockList<int,512>
PUBLIC	??1?$CDataBlockList@H$0CAA@@@UAE@XZ		; CDataBlockList<int,512>::~CDataBlockList<int,512>
PUBLIC	??_G?$CDataBlockList@H$0CAA@@@UAEPAXI@Z		; CDataBlockList<int,512>::`scalar deleting destructor'
PUBLIC	??0CXScaleManagerImp@@QAE@XZ			; CXScaleManagerImp::CXScaleManagerImp
PUBLIC	??1CXScaleManagerImp@@UAE@XZ			; CXScaleManagerImp::~CXScaleManagerImp
PUBLIC	??0?$CDataBlockList@UtagAREA@CXScaleManager@@$0CAA@@@QAE@XZ ; CDataBlockList<CXScaleManager::tagAREA,512>::CDataBlockList<CXScaleManager::tagAREA,512>
PUBLIC	??1?$CDataBlockList@UtagAREA@CXScaleManager@@$0CAA@@@UAE@XZ ; CDataBlockList<CXScaleManager::tagAREA,512>::~CDataBlockList<CXScaleManager::tagAREA,512>
PUBLIC	??_G?$CDataBlockList@UtagAREA@CXScaleManager@@$0CAA@@@UAEPAXI@Z ; CDataBlockList<CXScaleManager::tagAREA,512>::`scalar deleting destructor'
PUBLIC	?GetLeastTime@CXScaleManagerImp@@IAE_JPAH00@Z	; CXScaleManagerImp::GetLeastTime
PUBLIC	?ClearData@CXScaleManagerImp@@IAEXXZ		; CXScaleManagerImp::ClearData
PUBLIC	?GetNextDRI_ByScaleInterval@CXScaleManagerImp@@IAEHW4HORZSCALEDRAWERTYPE@CScaleBaseData@@HH@Z ; CXScaleManagerImp::GetNextDRI_ByScaleInterval
PUBLIC	?GetTimeFromTimeValue@CXScaleManagerImp@@IAE_J_KV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAUtagRQ_INFO@1@AAUtm@@PBDPAVCMapTimeToLong@@@Z ; CXScaleManagerImp::GetTimeFromTimeValue
PUBLIC	?GetTimeValueFromTime@CXScaleManagerImp@@IAEN_JV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ; CXScaleManagerImp::GetTimeValueFromTime
PUBLIC	?GetDTIFromDRI@CXScaleManagerImp@@IAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z ; CXScaleManagerImp::GetDTIFromDRI
PUBLIC	?SetPacketListManager@CXScaleManagerImp@@UAEXPAVCPacketListManager@@@Z ; CXScaleManagerImp::SetPacketListManager
PUBLIC	?SetIndicatorList@CXScaleManagerImp@@UAEXPAVCIndicatorList@@@Z ; CXScaleManagerImp::SetIndicatorList
PUBLIC	?GetPacketListManager@CXScaleManagerImp@@UAEPAVCPacketListManager@@XZ ; CXScaleManagerImp::GetPacketListManager
PUBLIC	?SetApplyToolBar@CXScaleManagerImp@@UAEXH@Z	; CXScaleManagerImp::SetApplyToolBar
PUBLIC	?GetApplyToolBar@CXScaleManagerImp@@UAEHXZ	; CXScaleManagerImp::GetApplyToolBar
PUBLIC	?SetReverse@CXScaleManagerImp@@UAEXH@Z		; CXScaleManagerImp::SetReverse
PUBLIC	?GetReverse@CXScaleManagerImp@@UAEHXZ		; CXScaleManagerImp::GetReverse
PUBLIC	?SetWeightedVolume@CXScaleManagerImp@@UAEXHH@Z	; CXScaleManagerImp::SetWeightedVolume
PUBLIC	?GetWeightedVolume@CXScaleManagerImp@@UAEHXZ	; CXScaleManagerImp::GetWeightedVolume
PUBLIC	?SetLeftDataHideCount@CXScaleManagerImp@@UAEXHH@Z ; CXScaleManagerImp::SetLeftDataHideCount
PUBLIC	?GetLeftDataHideCount@CXScaleManagerImp@@UAEHXZ	; CXScaleManagerImp::GetLeftDataHideCount
PUBLIC	?GetUseOEBTMargin@CXScaleManagerImp@@UAEHXZ	; CXScaleManagerImp::GetUseOEBTMargin
PUBLIC	?SetUseOEBTMargin@CXScaleManagerImp@@UAEXH@Z	; CXScaleManagerImp::SetUseOEBTMargin
PUBLIC	?SetRightMarginWidth@CXScaleManagerImp@@UAEXH@Z	; CXScaleManagerImp::SetRightMarginWidth
PUBLIC	?SetCandleTypeOnResize@CXScaleManagerImp@@UAEXW4RSA_TYPE@CXScaleManager@@@Z ; CXScaleManagerImp::SetCandleTypeOnResize
PUBLIC	?GetCandleTypeOnResize@CXScaleManagerImp@@UAE?AW4RSA_TYPE@CXScaleManager@@XZ ; CXScaleManagerImp::GetCandleTypeOnResize
PUBLIC	?SetFixedInterval@CXScaleManagerImp@@UAEXHH@Z	; CXScaleManagerImp::SetFixedInterval
PUBLIC	?IsFixedInterval@CXScaleManagerImp@@UAEHXZ	; CXScaleManagerImp::IsFixedInterval
PUBLIC	?AddOEBTRQ@CXScaleManagerImp@@UAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@00@Z ; CXScaleManagerImp::AddOEBTRQ
PUBLIC	?DelOEBTRQ@CXScaleManagerImp@@UAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ; CXScaleManagerImp::DelOEBTRQ
PUBLIC	?Clear_OEBTRQ@CXScaleManagerImp@@UAEXXZ		; CXScaleManagerImp::Clear_OEBTRQ
PUBLIC	?RealDataReceived@CXScaleManagerImp@@UAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z ; CXScaleManagerImp::RealDataReceived
PUBLIC	?SetIChartCtrl@CXScaleManagerImp@@UAEXPAUIChartCtrl@@@Z ; CXScaleManagerImp::SetIChartCtrl
PUBLIC	?GetCount@CXScaleManagerImp@@UAEHXZ		; CXScaleManagerImp::GetCount
PUBLIC	?GetDrawCount_Cur@CXScaleManagerImp@@UAEHXZ	; CXScaleManagerImp::GetDrawCount_Cur
PUBLIC	?GetStartDrawIdx_Cur@CXScaleManagerImp@@UAEHXZ	; CXScaleManagerImp::GetStartDrawIdx_Cur
PUBLIC	?GetEndDrawIdx_Cur@CXScaleManagerImp@@UAEHXZ	; CXScaleManagerImp::GetEndDrawIdx_Cur
PUBLIC	?SetStartEndDrawIdx_Cur@CXScaleManagerImp@@UAEXHHH@Z ; CXScaleManagerImp::SetStartEndDrawIdx_Cur
PUBLIC	?GetStartEndDrawIdx_Cur@CXScaleManagerImp@@UAEXAAH0@Z ; CXScaleManagerImp::GetStartEndDrawIdx_Cur
PUBLIC	?GetPageCountNextStep@CXScaleManagerImp@@UAEHHHHHH@Z ; CXScaleManagerImp::GetPageCountNextStep
PUBLIC	?GetDrawIndex@CXScaleManagerImp@@UAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HHAAH1@Z ; CXScaleManagerImp::GetDrawIndex
PUBLIC	?GetDrawIndex@CXScaleManagerImp@@UAEXHHAAH0@Z	; CXScaleManagerImp::GetDrawIndex
PUBLIC	?GetDTIFromDRI_AbleRange@CXScaleManagerImp@@UAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HPAH@Z ; CXScaleManagerImp::GetDTIFromDRI_AbleRange
PUBLIC	?GetScaleUnit_Max@CXScaleManagerImp@@UAE?AW4HORZSCALEDRAWERTYPE@CScaleBaseData@@PBD@Z ; CXScaleManagerImp::GetScaleUnit_Max
PUBLIC	?GetScaleInterval_Unit_Max@CXScaleManagerImp@@UAEHXZ ; CXScaleManagerImp::GetScaleInterval_Unit_Max
PUBLIC	?SetCurScaleInfo@CXScaleManagerImp@@UAEXH@Z	; CXScaleManagerImp::SetCurScaleInfo
PUBLIC	?GetCurScaleInfo@CXScaleManagerImp@@UAEXAAH@Z	; CXScaleManagerImp::GetCurScaleInfo
PUBLIC	?GetPacketType@CXScaleManagerImp@@UAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PBD@Z ; CXScaleManagerImp::GetPacketType
PUBLIC	?GetScaleUnitAlphaWeight@CXScaleManagerImp@@UAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ; CXScaleManagerImp::GetScaleUnitAlphaWeight
PUBLIC	?IsUseable@CXScaleManagerImp@@UAEHXZ		; CXScaleManagerImp::IsUseable
PUBLIC	?GetTimeFromDRI@CXScaleManagerImp@@UAEXHPA_J@Z	; CXScaleManagerImp::GetTimeFromDRI
PUBLIC	?Initialize@CXScaleManagerImp@@UAEXH@Z		; CXScaleManagerImp::Initialize
PUBLIC	?SetThreadFlag@CXScaleManagerImp@@UAEXH@Z	; CXScaleManagerImp::SetThreadFlag
PUBLIC	?GetThreadFlag@CXScaleManagerImp@@UAEHXZ	; CXScaleManagerImp::GetThreadFlag
PUBLIC	?AddVerticalBoxInfo@CXScaleManagerImp@@UAEXPBDNKH@Z ; CXScaleManagerImp::AddVerticalBoxInfo
PUBLIC	?GetVerticalBoxInfo@CXScaleManagerImp@@UAEXPBD0AAVCRect@@AAKAAH@Z ; CXScaleManagerImp::GetVerticalBoxInfo
PUBLIC	?GetRQIndexFromString@CXScaleManagerImp@@MAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ; CXScaleManagerImp::GetRQIndexFromString
PUBLIC	?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@PAX@std@@@2@QAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,CXScaleManagerImp::VERTBOX_INFO *> > >::_Insert_node
PUBLIC	??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@@2@@std@@QAE@XZ ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,CXScaleManagerImp::VERTBOX_INFO *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,CXScaleManagerImp::VERTBOX_INFO *> > >::~map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,CXScaleManagerImp::VERTBOX_INFO *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,CXScaleManagerImp::VERTBOX_INFO *> > >
PUBLIC	??1?$CDataBlockList@_J$0CAA@@@UAE@XZ		; CDataBlockList<__int64,512>::~CDataBlockList<__int64,512>
PUBLIC	??_G?$CDataBlockList@_J$0CAA@@@UAEPAXI@Z	; CDataBlockList<__int64,512>::`scalar deleting destructor'
PUBLIC	?GetMinScaleInterval_nUnit@CXScaleManagerImp@@MAEHXZ ; CXScaleManagerImp::GetMinScaleInterval_nUnit
PUBLIC	?GetDTIFromDRI@CXScaleManagerImp@@IAEHPAV?$CDataBlockList@H$0CAA@@@H@Z ; CXScaleManagerImp::GetDTIFromDRI
PUBLIC	?GetDTIFromDRI_AbleRange@CXScaleManagerImp@@IAEHPAV?$CDataBlockList@H$0CAA@@@HPAH@Z ; CXScaleManagerImp::GetDTIFromDRI_AbleRange
PUBLIC	?Calc_DRI@CXScaleManagerImp@@MAEXH@Z		; CXScaleManagerImp::Calc_DRI
PUBLIC	?Calc_DRI_Merge@CXScaleManagerImp@@MAEXXZ	; CXScaleManagerImp::Calc_DRI_Merge
PUBLIC	?GetCalculationMode@CXScaleManagerImp@@MAEHXZ	; CXScaleManagerImp::GetCalculationMode
PUBLIC	?SetNeedCalcAreaFlag@CXScaleManagerImp@@MAEXH@Z	; CXScaleManagerImp::SetNeedCalcAreaFlag
PUBLIC	?SetDefaultDataSpace@CXScaleManagerImp@@MAEXHH@Z ; CXScaleManagerImp::SetDefaultDataSpace
PUBLIC	?Calc_AREA@CXScaleManagerImp@@MAEXH@Z		; CXScaleManagerImp::Calc_AREA
PUBLIC	?Calc_AREAofColumn@CXScaleManagerImp@@IAEXH@Z	; CXScaleManagerImp::Calc_AREAofColumn
PUBLIC	?Calc_ItemWidth@CXScaleManagerImp@@IAEXHHH@Z	; CXScaleManagerImp::Calc_ItemWidth
PUBLIC	?GetAreaFromDRI_Copy@CXScaleManagerImp@@IAEXHHAAUtagAREA@CXScaleManager@@@Z ; CXScaleManagerImp::GetAreaFromDRI_Copy
PUBLIC	?ItemIntervalApply@CXScaleManagerImp@@IAEXHAAUtagAREA@CXScaleManager@@H@Z ; CXScaleManagerImp::ItemIntervalApply
PUBLIC	?ItemIntervalApply_Reverse@CXScaleManagerImp@@IAEXHAAUtagAREA@CXScaleManager@@H@Z ; CXScaleManagerImp::ItemIntervalApply_Reverse
PUBLIC	?GetColumnWidth@CXScaleManagerImp@@MAEHH@Z	; CXScaleManagerImp::GetColumnWidth
PUBLIC	?GetDRInFromPt@CXScaleManagerImp@@MAEHHPAHPAPAUtagAREA@CXScaleManager@@HH@Z ; CXScaleManagerImp::GetDRInFromPt
PUBLIC	?GetGraphXArea_End@CXScaleManagerImp@@MAEHHH@Z	; CXScaleManagerImp::GetGraphXArea_End
PUBLIC	?GetGraphXArea_Left@CXScaleManagerImp@@MAEHHH@Z	; CXScaleManagerImp::GetGraphXArea_Left
PUBLIC	?GetGraphXArea_Right@CXScaleManagerImp@@MAEHHH@Z ; CXScaleManagerImp::GetGraphXArea_Right
PUBLIC	?GetGraphXArea_Start@CXScaleManagerImp@@MAEHHH@Z ; CXScaleManagerImp::GetGraphXArea_Start
PUBLIC	?GetScaleDRIandTime@CXScaleManagerImp@@MAEHHAAPAV?$CDataBlockList@H$0CAA@@@AAPAV?$CDataBlockList@Utm@@$0CAA@@@HW4HORZSCALEDRAWERTYPE@CScaleBaseData@@HPBDAAHABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ; CXScaleManagerImp::GetScaleDRIandTime
PUBLIC	?GetScreenWidth@CXScaleManagerImp@@MAEHH@Z	; CXScaleManagerImp::GetScreenWidth
PUBLIC	?GetXFromTime@CXScaleManagerImp@@MAEHH_JPAPAUtagAREA@CXScaleManager@@H@Z ; CXScaleManagerImp::GetXFromTime
PUBLIC	?GetDTInAREAfRQnPt@CXScaleManagerImp@@MAEHHAAHPAHPAUtagAREA@CXScaleManager@@@Z ; CXScaleManagerImp::GetDTInAREAfRQnPt
PUBLIC	?GetDTInAREAfRQnPt@CXScaleManagerImp@@MAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HAAHPAHPAUtagAREA@CXScaleManager@@H@Z ; CXScaleManagerImp::GetDTInAREAfRQnPt
PUBLIC	?IsAllOnePixel@CXScaleManagerImp@@MAEHHPBD@Z	; CXScaleManagerImp::IsAllOnePixel
PUBLIC	?IsInGraphXArea@CXScaleManagerImp@@MAEHHHH@Z	; CXScaleManagerImp::IsInGraphXArea
PUBLIC	?GetAreaFromDRI@CXScaleManagerImp@@MAEXHHPAPAUtagAREA@CXScaleManager@@@Z ; CXScaleManagerImp::GetAreaFromDRI
PUBLIC	?GetGraphXAreaLR@CXScaleManagerImp@@MAEXHAAH0H@Z ; CXScaleManagerImp::GetGraphXAreaLR
PUBLIC	?GetGraphXAreaSE@CXScaleManagerImp@@MAEXHAAH0H@Z ; CXScaleManagerImp::GetGraphXAreaSE
PUBLIC	?SetColumnWidth@CXScaleManagerImp@@MAEXHH@Z	; CXScaleManagerImp::SetColumnWidth
PUBLIC	?SetScreenRegion@CXScaleManagerImp@@MAEXHHHH@Z	; CXScaleManagerImp::SetScreenRegion
PUBLIC	?GetDTIArea@CXScaleManagerImp@@MAEPAV?$CDataBlockList@UtagAREA@CXScaleManager@@$0CAA@@@HPBDAAH@Z ; CXScaleManagerImp::GetDTIArea
PUBLIC	?GetTimeFromXWithRightMargin@CXScaleManagerImp@@IAE_JHPAHPAPAUtagAREA@CXScaleManager@@@Z ; CXScaleManagerImp::GetTimeFromXWithRightMargin
PUBLIC	?SetBlockColumnCount@CXScaleManagerImp@@MAEXH@Z	; CXScaleManagerImp::SetBlockColumnCount
PUBLIC	?SetBlockColumn_Cur@CXScaleManagerImp@@MAEXH@Z	; CXScaleManagerImp::SetBlockColumn_Cur
PUBLIC	?NextScaleTime@CXScaleManagerImp@@MAEHPA_JPAPAUtagAREA@CXScaleManager@@@Z ; CXScaleManagerImp::NextScaleTime
PUBLIC	?PrevScaleTime@CXScaleManagerImp@@MAEXPA_JPAPAUtagAREA@CXScaleManager@@@Z ; CXScaleManagerImp::PrevScaleTime
PUBLIC	?GetAt_ScaleTime@CXScaleManagerImp@@MAEXHPA_JPAPAUtagAREA@CXScaleManager@@@Z ; CXScaleManagerImp::GetAt_ScaleTime
PUBLIC	?GetAREAfRQnDTI@CXScaleManagerImp@@MAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HHPAUtagAREA@CXScaleManager@@@Z ; CXScaleManagerImp::GetAREAfRQnDTI
PUBLIC	?GetAREAfRQnDTI@CXScaleManagerImp@@MAEHHHPAUtagAREA@CXScaleManager@@@Z ; CXScaleManagerImp::GetAREAfRQnDTI
PUBLIC	?GetRQInfosFromPt@CXScaleManagerImp@@MAEHHAAHAAVCStringArray@@AAV?$CArray@HH@@PAUtagAREA@CXScaleManager@@@Z ; CXScaleManagerImp::GetRQInfosFromPt
PUBLIC	?GetTimeFromX@CXScaleManagerImp@@MAE_JHPAHPAPAUtagAREA@CXScaleManager@@@Z ; CXScaleManagerImp::GetTimeFromX
PUBLIC	?GetDoubleFromX@CXScaleManagerImp@@MAENHHHPAHPAPAUtagAREA@CXScaleManager@@PBD@Z ; CXScaleManagerImp::GetDoubleFromX
PUBLIC	?GetXFromDouble@CXScaleManagerImp@@MAEHHHNPAPAUtagAREA@CXScaleManager@@@Z ; CXScaleManagerImp::GetXFromDouble
PUBLIC	?OnUserZoomChanged@CXScaleManagerImp@@MAEXXZ	; CXScaleManagerImp::OnUserZoomChanged
PUBLIC	?SetFlagForCalcDRIandScrollByReal@CXScaleManagerImp@@MAEXH@Z ; CXScaleManagerImp::SetFlagForCalcDRIandScrollByReal
PUBLIC	?IsScrollByReal@CXScaleManagerImp@@MAEHXZ	; CXScaleManagerImp::IsScrollByReal
PUBLIC	?GetFutureTimeCount@CXScaleManagerImp@@MAEHXZ	; CXScaleManagerImp::GetFutureTimeCount
PUBLIC	?SetFutureTimeCount@CXScaleManagerImp@@MAEXH@Z	; CXScaleManagerImp::SetFutureTimeCount
PUBLIC	?SetRightMarginAndFutureTime@CXScaleManagerImp@@MAEXHH@Z ; CXScaleManagerImp::SetRightMarginAndFutureTime
PUBLIC	?IsEmptyData@CXScaleManagerImp@@MAEHXZ		; CXScaleManagerImp::IsEmptyData
PUBLIC	?GetTimeDiffWithCurrentRQ@CXScaleManagerImp@@IAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ; CXScaleManagerImp::GetTimeDiffWithCurrentRQ
PUBLIC	??1?$CTypedPtrMap@VCMapWordToPtr@@FPAVCXScaleGridTime@@@@UAE@XZ ; CTypedPtrMap<CMapWordToPtr,short,CXScaleGridTime *>::~CTypedPtrMap<CMapWordToPtr,short,CXScaleGridTime *>
PUBLIC	??_G?$CTypedPtrMap@VCMapWordToPtr@@FPAVCXScaleGridTime@@@@UAEPAXI@Z ; CTypedPtrMap<CMapWordToPtr,short,CXScaleGridTime *>::`scalar deleting destructor'
PUBLIC	?PopLastScaleDataTime@CXScaleManagerImp@@IAEXXZ	; CXScaleManagerImp::PopLastScaleDataTime
PUBLIC	?PushScaleDataTime@CXScaleManagerImp@@IAEXH_JH@Z ; CXScaleManagerImp::PushScaleDataTime
PUBLIC	?IsSpecialTime@CXScaleManagerImp@@MAEHPBD_JAAJ@Z ; CXScaleManagerImp::IsSpecialTime
PUBLIC	?SetPriceMinMaxShowType@CXScaleManagerImp@@MAEXH@Z ; CXScaleManagerImp::SetPriceMinMaxShowType
PUBLIC	?GetPriceMinMaxShowType@CXScaleManagerImp@@MAEHXZ ; CXScaleManagerImp::GetPriceMinMaxShowType
PUBLIC	?GetScaleDRIandTimeAllData@CXScaleManagerImp@@UAEHHAAPAV?$CDataBlockList@H$0CAA@@@AAPAV?$CDataBlockList@Utm@@$0CAA@@@W4HORZSCALEDRAWERTYPE@CScaleBaseData@@PBDAAH@Z ; CXScaleManagerImp::GetScaleDRIandTimeAllData
PUBLIC	??_GCXScaleManagerImp@@UAEPAXI@Z		; CXScaleManagerImp::`scalar deleting destructor'
PUBLIC	?FindIndex@?$CList@NN@@QBEPAU__POSITION@@H@Z	; CList<double,double>::FindIndex
PUBLIC	??1?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@QAE@XZ ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int>::~pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int>
PUBLIC	?SetSize@?$CArray@HH@@QAEXHH@Z			; CArray<int,int>::SetSize
PUBLIC	?SetAtGrow@?$CArray@HH@@QAEXHH@Z		; CArray<int,int>::SetAtGrow
PUBLIC	??1?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@QAE@XZ ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,CXScaleManagerImp::VERTBOX_INFO *>::~pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,CXScaleManagerImp::VERTBOX_INFO *>
PUBLIC	??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,CXScaleManagerImp::VERTBOX_INFO *> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,CXScaleManagerImp::VERTBOX_INFO *>,void *> > >
PUBLIC	??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> > >
PUBLIC	??$_Emplace_reallocate@ABQAX@?$vector@PAXV?$allocator@PAX@std@@@std@@QAEPAPAXQAPAXABQAX@Z ; std::vector<void *,std::allocator<void *> >::_Emplace_reallocate<void * const &>
PUBLIC	??$_Find_lower_bound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@PAX@std@@@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,CXScaleManagerImp::VERTBOX_INFO *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,CXScaleManagerImp::VERTBOX_INFO *> >,0> >::_Find_lower_bound<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$_Find_lower_bound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Find_lower_bound<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??$_Copy_memmove@PAPAXPAPAX@std@@YAPAPAXPAPAX00@Z ; std::_Copy_memmove<void * *,void * *>
PUBLIC	??$?MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> > >
PUBLIC	??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,CXScaleManagerImp::VERTBOX_INFO *>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,CXScaleManagerImp::VERTBOX_INFO *>,void *> > >
PUBLIC	??_R0?AVCObject@@@8				; CObject `RTTI Type Descriptor'
PUBLIC	??_R3CObject@@8					; CObject::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CObject@@8					; CObject::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CObject@@8			; CObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_C@_0BB@GCADKGJO@map?1set?5too?5long@		; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	??_7CDataBlockListUNK@@6B@			; CDataBlockListUNK::`vftable'
PUBLIC	??_7CMapTimeToLong@@6B@				; CMapTimeToLong::`vftable'
PUBLIC	??_7CXScaleManager@@6B@				; CXScaleManager::`vftable'
PUBLIC	??_7?$CDataBlockList@Utm@@$0CAA@@@6B@		; CDataBlockList<tm,512>::`vftable'
PUBLIC	??_7?$CDataBlockList@H$0CAA@@@6B@		; CDataBlockList<int,512>::`vftable'
PUBLIC	??_7?$CDataBlockList@UtagAREA@CXScaleManager@@$0CAA@@@6B@ ; CDataBlockList<CXScaleManager::tagAREA,512>::`vftable'
PUBLIC	??_7?$CDataBlockList@_J$0CAA@@@6B@		; CDataBlockList<__int64,512>::`vftable'
PUBLIC	??_7?$CTypedPtrMap@VCMapWordToPtr@@FPAVCXScaleGridTime@@@@6B@ ; CTypedPtrMap<CMapWordToPtr,short,CXScaleGridTime *>::`vftable'
PUBLIC	??_7CXScaleManagerImp@@6B@			; CXScaleManagerImp::`vftable'
PUBLIC	??_C@_02PPNCLIJD@SS@				; `string'
PUBLIC	??_C@_07MGCPDNLD@DEFAULT@			; `string'
PUBLIC	??_C@_08KLIIINKM@MMDDHHMM@			; `string'
PUBLIC	??_C@_06EBMMBHJD@YYYYMM@			; `string'
PUBLIC	??_C@_04GICMHJFP@?$CFY?$CFm@			; `string'
PUBLIC	??_C@_08DKDJLCMP@YYYYMMDD@			; `string'
PUBLIC	??_C@_06CLONMKIH@?$CFY?$CFm?$CFd@		; `string'
PUBLIC	??_C@_08LIEOKHEF@?$CFm?$CFd?$CFH?$CFM@		; `string'
PUBLIC	??_C@_06MAANBBPI@HHMMSS@			; `string'
PUBLIC	??_C@_06NDFCBELD@?$CFH?$CFM?$CFS@		; `string'
PUBLIC	??_C@_08JFMBEEDE@DDHHMMSS@			; `string'
PUBLIC	??_C@_08DEPALGMO@?$CFd?$CFH?$CFM?$CFS@		; `string'
PUBLIC	??_C@_0P@IMPIBBAB@YYYYMMDDHHMMSS@		; `string'
PUBLIC	??_C@_0N@BNMNAMM@?$CFY?$CFm?$CFd?$CFH?$CFM?$CFS@ ; `string'
PUBLIC	??_C@_01GBGANLPD@0@				; `string'
PUBLIC	??_C@_0BA@FOIKENOD@vector?5too?5long@		; `string'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4CDataBlockListUNK@@6B@			; CDataBlockListUNK::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCDataBlockListUNK@@@8			; CDataBlockListUNK `RTTI Type Descriptor'
PUBLIC	??_R3CDataBlockListUNK@@8			; CDataBlockListUNK::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CDataBlockListUNK@@8			; CDataBlockListUNK::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CDataBlockListUNK@@8		; CDataBlockListUNK::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4CMapTimeToLong@@6B@			; CMapTimeToLong::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCMapTimeToLong@@@8			; CMapTimeToLong `RTTI Type Descriptor'
PUBLIC	??_R3CMapTimeToLong@@8				; CMapTimeToLong::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CMapTimeToLong@@8				; CMapTimeToLong::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CMapTimeToLong@@8			; CMapTimeToLong::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@CMapPtrToPtr@@8			; CMapPtrToPtr::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCMapPtrToPtr@@@8			; CMapPtrToPtr `RTTI Type Descriptor'
PUBLIC	??_R3CMapPtrToPtr@@8				; CMapPtrToPtr::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CMapPtrToPtr@@8				; CMapPtrToPtr::`RTTI Base Class Array'
PUBLIC	??_R4CXScaleManager@@6B@			; CXScaleManager::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCXScaleManager@@@8			; CXScaleManager `RTTI Type Descriptor'
PUBLIC	??_R3CXScaleManager@@8				; CXScaleManager::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CXScaleManager@@8				; CXScaleManager::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CXScaleManager@@8			; CXScaleManager::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDataBlockList@H$0CAA@@@6B@		; CDataBlockList<int,512>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDataBlockList@H$0CAA@@@@8		; CDataBlockList<int,512> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDataBlockList@H$0CAA@@@8		; CDataBlockList<int,512>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDataBlockList@H$0CAA@@@8		; CDataBlockList<int,512>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDataBlockList@H$0CAA@@@8	; CDataBlockList<int,512>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDataBlockList@Utm@@$0CAA@@@6B@		; CDataBlockList<tm,512>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDataBlockList@Utm@@$0CAA@@@@8	; CDataBlockList<tm,512> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDataBlockList@Utm@@$0CAA@@@8		; CDataBlockList<tm,512>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDataBlockList@Utm@@$0CAA@@@8		; CDataBlockList<tm,512>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDataBlockList@Utm@@$0CAA@@@8	; CDataBlockList<tm,512>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDataBlockList@UtagAREA@CXScaleManager@@$0CAA@@@6B@ ; CDataBlockList<CXScaleManager::tagAREA,512>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDataBlockList@UtagAREA@CXScaleManager@@$0CAA@@@@8 ; CDataBlockList<CXScaleManager::tagAREA,512> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDataBlockList@UtagAREA@CXScaleManager@@$0CAA@@@8 ; CDataBlockList<CXScaleManager::tagAREA,512>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDataBlockList@UtagAREA@CXScaleManager@@$0CAA@@@8 ; CDataBlockList<CXScaleManager::tagAREA,512>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDataBlockList@UtagAREA@CXScaleManager@@$0CAA@@@8 ; CDataBlockList<CXScaleManager::tagAREA,512>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4CXScaleManagerImp@@6B@			; CXScaleManagerImp::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCXScaleManagerImp@@@8			; CXScaleManagerImp `RTTI Type Descriptor'
PUBLIC	??_R3CXScaleManagerImp@@8			; CXScaleManagerImp::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CXScaleManagerImp@@8			; CXScaleManagerImp::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CXScaleManagerImp@@8		; CXScaleManagerImp::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDataBlockList@_J$0CAA@@@6B@		; CDataBlockList<__int64,512>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDataBlockList@_J$0CAA@@@@8		; CDataBlockList<__int64,512> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDataBlockList@_J$0CAA@@@8		; CDataBlockList<__int64,512>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDataBlockList@_J$0CAA@@@8		; CDataBlockList<__int64,512>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDataBlockList@_J$0CAA@@@8	; CDataBlockList<__int64,512>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CTypedPtrMap@VCMapWordToPtr@@FPAVCXScaleGridTime@@@@6B@ ; CTypedPtrMap<CMapWordToPtr,short,CXScaleGridTime *>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CTypedPtrMap@VCMapWordToPtr@@FPAVCXScaleGridTime@@@@@8 ; CTypedPtrMap<CMapWordToPtr,short,CXScaleGridTime *> `RTTI Type Descriptor'
PUBLIC	??_R3?$CTypedPtrMap@VCMapWordToPtr@@FPAVCXScaleGridTime@@@@8 ; CTypedPtrMap<CMapWordToPtr,short,CXScaleGridTime *>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CTypedPtrMap@VCMapWordToPtr@@FPAVCXScaleGridTime@@@@8 ; CTypedPtrMap<CMapWordToPtr,short,CXScaleGridTime *>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CTypedPtrMap@VCMapWordToPtr@@FPAVCXScaleGridTime@@@@8 ; CTypedPtrMap<CMapWordToPtr,short,CXScaleGridTime *>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@CMapWordToPtr@@8			; CMapWordToPtr::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCMapWordToPtr@@@8			; CMapWordToPtr `RTTI Type Descriptor'
PUBLIC	??_R3CMapWordToPtr@@8				; CMapWordToPtr::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CMapWordToPtr@@8				; CMapWordToPtr::`RTTI Base Class Array'
PUBLIC	__real@0000000000000000
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@4000000000000000
PUBLIC	__real@40dfffc000000000
PUBLIC	__real@c0e0000000000000
PUBLIC	__xmm@3ff00000000000003ff0000000000000
PUBLIC	__xmm@80000000000000008000000000000000
EXTRN	??_L@YGXPAXIIP6EX0@Z1@Z:PROC			; `eh vector constructor iterator'
EXTRN	??_M@YGXPAXIIP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	?__global_delete@@YAXPAXI@Z:PROC		; __global_delete
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	___std_terminate:PROC
EXTRN	__imp___invalid_parameter_noinfo:PROC
EXTRN	__imp___invalid_parameter_noinfo_noreturn:PROC
EXTRN	__imp___errno:PROC
EXTRN	__imp__lstrcmpA@8:PROC
EXTRN	__imp__SetRectEmpty@4:PROC
EXTRN	__imp__InflateRect@12:PROC
EXTRN	__imp__IsRectEmpty@4:PROC
EXTRN	__imp__EqualRect@8:PROC
EXTRN	__imp__malloc:PROC
EXTRN	__imp__atof:PROC
EXTRN	__imp___localtime64:PROC
EXTRN	__imp___localtime64_s:PROC
EXTRN	__imp___mktime64:PROC
EXTRN	__imp__strftime:PROC
EXTRN	__imp___time64:PROC
EXTRN	?AfxThrowMemoryException@@YGXXZ:PROC		; AfxThrowMemoryException
EXTRN	?AfxThrowInvalidArgException@@YGXXZ:PROC	; AfxThrowInvalidArgException
EXTRN	?AfxThrowOleException@@YGXJ@Z:PROC		; AfxThrowOleException
EXTRN	__imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ:PROC
EXTRN	__imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z:PROC
EXTRN	__imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z:PROC
EXTRN	__imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ:PROC
EXTRN	__imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z:PROC
EXTRN	__imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z:PROC
EXTRN	__imp_?Compare@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEHPBD@Z:PROC
EXTRN	__imp_?Find@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEHPBDH@Z:PROC
EXTRN	??0CStringArray@@QAE@XZ:PROC			; CStringArray::CStringArray
EXTRN	?SetSize@CStringArray@@QAEXHH@Z:PROC		; CStringArray::SetSize
EXTRN	?SetAtGrow@CStringArray@@QAEXHABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z:PROC ; CStringArray::SetAtGrow
EXTRN	?Append@CStringArray@@QAEHABV1@@Z:PROC		; CStringArray::Append
EXTRN	??1CStringArray@@UAE@XZ:PROC			; CStringArray::~CStringArray
EXTRN	?GetRuntimeClass@CMapWordToPtr@@UBEPAUCRuntimeClass@@XZ:PROC ; CMapWordToPtr::GetRuntimeClass
EXTRN	??0CMapWordToPtr@@QAE@H@Z:PROC			; CMapWordToPtr::CMapWordToPtr
EXTRN	?Lookup@CMapWordToPtr@@QBEHGAAPAX@Z:PROC	; CMapWordToPtr::Lookup
EXTRN	??ACMapWordToPtr@@QAEAAPAXG@Z:PROC		; CMapWordToPtr::operator[]
EXTRN	?RemoveAll@CMapWordToPtr@@QAEXXZ:PROC		; CMapWordToPtr::RemoveAll
EXTRN	?GetNextAssoc@CMapWordToPtr@@QBEXAAPAU__POSITION@@AAGAAPAX@Z:PROC ; CMapWordToPtr::GetNextAssoc
EXTRN	??1CMapWordToPtr@@UAE@XZ:PROC			; CMapWordToPtr::~CMapWordToPtr
EXTRN	?GetRuntimeClass@CMapPtrToPtr@@UBEPAUCRuntimeClass@@XZ:PROC ; CMapPtrToPtr::GetRuntimeClass
EXTRN	??0CMapPtrToPtr@@QAE@H@Z:PROC			; CMapPtrToPtr::CMapPtrToPtr
EXTRN	?Lookup@CMapPtrToPtr@@QBEHPAXAAPAX@Z:PROC	; CMapPtrToPtr::Lookup
EXTRN	??ACMapPtrToPtr@@QAEAAPAXPAX@Z:PROC		; CMapPtrToPtr::operator[]
EXTRN	?RemoveKey@CMapPtrToPtr@@QAEHPAX@Z:PROC		; CMapPtrToPtr::RemoveKey
EXTRN	?RemoveAll@CMapPtrToPtr@@QAEXXZ:PROC		; CMapPtrToPtr::RemoveAll
EXTRN	??1CMapPtrToPtr@@UAE@XZ:PROC			; CMapPtrToPtr::~CMapPtrToPtr
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	??1CDataBlockListUNK@@UAE@XZ:PROC		; CDataBlockListUNK::~CDataBlockListUNK
EXTRN	?Clear@CDataBlockListUNK@@QAEXXZ:PROC		; CDataBlockListUNK::Clear
EXTRN	?GetItemCount@CDataBlockListUNK@@QAEHXZ:PROC	; CDataBlockListUNK::GetItemCount
EXTRN	?DeleteBack@CDataBlockListUNK@@QAEXH@Z:PROC	; CDataBlockListUNK::DeleteBack
EXTRN	?SetAtUNK@CDataBlockListUNK@@QAEHHPAX@Z:PROC	; CDataBlockListUNK::SetAtUNK
EXTRN	?GetAtUNK@CDataBlockListUNK@@QAEPAXH@Z:PROC	; CDataBlockListUNK::GetAtUNK
EXTRN	?SetIndex@CDataBlockListUNK@@QAEXH@Z:PROC	; CDataBlockListUNK::SetIndex
EXTRN	?GetIndex@CDataBlockListUNK@@QAEHXZ:PROC	; CDataBlockListUNK::GetIndex
EXTRN	?GetNextUNK@CDataBlockListUNK@@QAEPAXXZ:PROC	; CDataBlockListUNK::GetNextUNK
EXTRN	?GetPrevUNK@CDataBlockListUNK@@QAEPAXXZ:PROC	; CDataBlockListUNK::GetPrevUNK
EXTRN	??_ECDataBlockListUNK@@UAEPAXI@Z:PROC		; CDataBlockListUNK::`vector deleting destructor'
EXTRN	??_ECMapTimeToLong@@UAEPAXI@Z:PROC		; CMapTimeToLong::`vector deleting destructor'
EXTRN	??_ECXScaleManager@@UAEPAXI@Z:PROC		; CXScaleManager::`vector deleting destructor'
EXTRN	??0CXScaleTimeDiffManager@@QAE@XZ:PROC		; CXScaleTimeDiffManager::CXScaleTimeDiffManager
EXTRN	??1CXScaleTimeDiffManager@@UAE@XZ:PROC		; CXScaleTimeDiffManager::~CXScaleTimeDiffManager
EXTRN	?SetXScaleManagerImp@CXScaleTimeDiffManager@@QAEXPAVCXScaleManagerImp@@@Z:PROC ; CXScaleTimeDiffManager::SetXScaleManagerImp
EXTRN	?InitRQDiffTime@CXScaleTimeDiffManager@@QAEXXZ:PROC ; CXScaleTimeDiffManager::InitRQDiffTime
EXTRN	?InitRQMarketTime@CXScaleTimeDiffManager@@QAEXXZ:PROC ; CXScaleTimeDiffManager::InitRQMarketTime
EXTRN	?SetRQDiffTime@CXScaleTimeDiffManager@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H_J@Z:PROC ; CXScaleTimeDiffManager::SetRQDiffTime
EXTRN	?SetRQMarketTime@CXScaleTimeDiffManager@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HHW4MARKETDAYTYPE@CPacketType@@@Z:PROC ; CXScaleTimeDiffManager::SetRQMarketTime
EXTRN	?SetCurrentRQ@CXScaleTimeDiffManager@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z:PROC ; CXScaleTimeDiffManager::SetCurrentRQ
EXTRN	?GetRQScreenTime@CXScaleTimeDiffManager@@QAE_JV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAUtm@@@Z:PROC ; CXScaleTimeDiffManager::GetRQScreenTime
EXTRN	?GetRQScreenDateTime@CXScaleTimeDiffManager@@QAE_JV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@_J@Z:PROC ; CXScaleTimeDiffManager::GetRQScreenDateTime
EXTRN	?CalcCurrentDateTimToPacketTime@CXScaleTimeDiffManager@@QAEPAUtm@@V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z:PROC ; CXScaleTimeDiffManager::CalcCurrentDateTimToPacketTime
EXTRN	??0CXScaleGridTime@@QAE@XZ:PROC			; CXScaleGridTime::CXScaleGridTime
EXTRN	??_E?$CDataBlockList@Utm@@$0CAA@@@UAEPAXI@Z:PROC ; CDataBlockList<tm,512>::`vector deleting destructor'
EXTRN	??_E?$CDataBlockList@H$0CAA@@@UAEPAXI@Z:PROC	; CDataBlockList<int,512>::`vector deleting destructor'
EXTRN	?PopLastScaleDataTime@CXScaleGridTime@@QAEXXZ:PROC ; CXScaleGridTime::PopLastScaleDataTime
EXTRN	?PushScaleDataTime@CXScaleGridTime@@QAEXHHUtm@@H@Z:PROC ; CXScaleGridTime::PushScaleDataTime
EXTRN	?RecalculateScaleType@CXScaleGridTime@@QAEHABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@W4HORZSCALEDRAWERTYPE@CScaleBaseData@@HAAHHW4CHART_MODE@CChartInfo@@@Z:PROC ; CXScaleGridTime::RecalculateScaleType
EXTRN	?GetLastDRI@CXScaleGridTime@@QAEHXZ:PROC	; CXScaleGridTime::GetLastDRI
EXTRN	?MakeScaleData@CXScaleGridTime@@QAEXHAAV?$CDataBlockList@Utm@@$0CAA@@@AAV?$CDataBlockList@H$0CAA@@@HW4CHART_MODE@CChartInfo@@@Z:PROC ; CXScaleGridTime::MakeScaleData
EXTRN	??_E?$CDataBlockList@UtagAREA@CXScaleManager@@$0CAA@@@UAEPAXI@Z:PROC ; CDataBlockList<CXScaleManager::tagAREA,512>::`vector deleting destructor'
EXTRN	??_E?$CDataBlockList@_J$0CAA@@@UAEPAXI@Z:PROC	; CDataBlockList<__int64,512>::`vector deleting destructor'
EXTRN	??_E?$CTypedPtrMap@VCMapWordToPtr@@FPAVCXScaleGridTime@@@@UAEPAXI@Z:PROC ; CTypedPtrMap<CMapWordToPtr,short,CXScaleGridTime *>::`vector deleting destructor'
EXTRN	??_ECXScaleManagerImp@@UAEPAXI@Z:PROC		; CXScaleManagerImp::`vector deleting destructor'
EXTRN	__imp_?GetType@CPacket@@QAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@_N@Z:PROC
EXTRN	__imp_?GetnumericDataList@CPacket@@QAEPAV?$CList@NN@@XZ:PROC
EXTRN	__imp_?GetstrDataList@CPacket@@QAEPAV?$CList@V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@XZ:PROC
EXTRN	__imp_?GetRealType@CPacketList@@QBE?AW4REALTYPE@CPacketType@@XZ:PROC
EXTRN	__imp_?GetTimeInterval@CPacketList@@QAEHXZ:PROC
EXTRN	__imp_?GetDateUnitType@CPacketList@@QAE?AW4HORZSCALEDRAWERTYPE@CScaleBaseData@@XZ:PROC
EXTRN	__imp_?GetBaseData@CPacketList@@QAEPAVCPacket@@V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@_N@Z:PROC
EXTRN	__imp_?GetBaseTimeDifference@CPacketList@@QAEHXZ:PROC
EXTRN	__imp_?GetCurrDateTime@CPacketList@@QBE_JXZ:PROC
EXTRN	__imp_?GetMarketTime@CPacketList@@QBE_NAAH0@Z:PROC
EXTRN	__imp_?GetMarketDayType@CPacketList@@QAE?AW4MARKETDAYTYPE@CPacketType@@XZ:PROC
EXTRN	__imp_?GetGraphIndicatorInfo@CIndicatorList@@QAEPAVCIndicatorInfo@@W4EIndicatorListType@@PBD1W4EIndicatorInfoGettingType@@@Z:PROC
EXTRN	__imp_?GetCommonCalConditionList@CIndicatorInfo@@QAEPAV?$CList@NN@@XZ:PROC
EXTRN	?IsSpecialTime@IMetaTable@@QAEHH@Z:PROC		; IMetaTable::IsSpecialTime
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__aulldvrm:PROC
EXTRN	__aullrem:PROC
EXTRN	__dtol3:PROC
EXTRN	_ceil:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	_memset:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?g_iMetaTable@@3VIMetaTable@@A:BYTE		; g_iMetaTable
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT __xmm@80000000000000008000000000000000
CONST	SEGMENT
__xmm@80000000000000008000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __xmm@3ff00000000000003ff0000000000000
CONST	SEGMENT
__xmm@3ff00000000000003ff0000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 0f0H
	DB	'?', 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, '?'
CONST	ENDS
;	COMDAT __real@c0e0000000000000
CONST	SEGMENT
__real@c0e0000000000000 DQ 0c0e0000000000000r	; -32768
CONST	ENDS
;	COMDAT __real@40dfffc000000000
CONST	SEGMENT
__real@40dfffc000000000 DQ 040dfffc000000000r	; 32767
CONST	ENDS
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT ??_R2CMapWordToPtr@@8
rdata$r	SEGMENT
??_R2CMapWordToPtr@@8 DD FLAT:??_R1A@?0A@EA@CMapWordToPtr@@8 ; CMapWordToPtr::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CObject@@8
rdata$r	ENDS
;	COMDAT ??_R3CMapWordToPtr@@8
rdata$r	SEGMENT
??_R3CMapWordToPtr@@8 DD 00H				; CMapWordToPtr::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CMapWordToPtr@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCMapWordToPtr@@@8
data$rs	SEGMENT
??_R0?AVCMapWordToPtr@@@8 DD FLAT:??_7type_info@@6B@	; CMapWordToPtr `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCMapWordToPtr@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@CMapWordToPtr@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CMapWordToPtr@@8 DD FLAT:??_R0?AVCMapWordToPtr@@@8 ; CMapWordToPtr::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CMapWordToPtr@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CTypedPtrMap@VCMapWordToPtr@@FPAVCXScaleGridTime@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CTypedPtrMap@VCMapWordToPtr@@FPAVCXScaleGridTime@@@@8 DD FLAT:??_R0?AV?$CTypedPtrMap@VCMapWordToPtr@@FPAVCXScaleGridTime@@@@@8 ; CTypedPtrMap<CMapWordToPtr,short,CXScaleGridTime *>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CTypedPtrMap@VCMapWordToPtr@@FPAVCXScaleGridTime@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CTypedPtrMap@VCMapWordToPtr@@FPAVCXScaleGridTime@@@@8
rdata$r	SEGMENT
??_R2?$CTypedPtrMap@VCMapWordToPtr@@FPAVCXScaleGridTime@@@@8 DD FLAT:??_R1A@?0A@EA@?$CTypedPtrMap@VCMapWordToPtr@@FPAVCXScaleGridTime@@@@8 ; CTypedPtrMap<CMapWordToPtr,short,CXScaleGridTime *>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CMapWordToPtr@@8
	DD	FLAT:??_R1A@?0A@EA@CObject@@8
rdata$r	ENDS
;	COMDAT ??_R3?$CTypedPtrMap@VCMapWordToPtr@@FPAVCXScaleGridTime@@@@8
rdata$r	SEGMENT
??_R3?$CTypedPtrMap@VCMapWordToPtr@@FPAVCXScaleGridTime@@@@8 DD 00H ; CTypedPtrMap<CMapWordToPtr,short,CXScaleGridTime *>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2?$CTypedPtrMap@VCMapWordToPtr@@FPAVCXScaleGridTime@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CTypedPtrMap@VCMapWordToPtr@@FPAVCXScaleGridTime@@@@@8
data$rs	SEGMENT
??_R0?AV?$CTypedPtrMap@VCMapWordToPtr@@FPAVCXScaleGridTime@@@@@8 DD FLAT:??_7type_info@@6B@ ; CTypedPtrMap<CMapWordToPtr,short,CXScaleGridTime *> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CTypedPtrMap@VCMapWordToPtr@@FPAVCXScaleGridTime@@'
	DB	'@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CTypedPtrMap@VCMapWordToPtr@@FPAVCXScaleGridTime@@@@6B@
rdata$r	SEGMENT
??_R4?$CTypedPtrMap@VCMapWordToPtr@@FPAVCXScaleGridTime@@@@6B@ DD 00H ; CTypedPtrMap<CMapWordToPtr,short,CXScaleGridTime *>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CTypedPtrMap@VCMapWordToPtr@@FPAVCXScaleGridTime@@@@@8
	DD	FLAT:??_R3?$CTypedPtrMap@VCMapWordToPtr@@FPAVCXScaleGridTime@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDataBlockList@_J$0CAA@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDataBlockList@_J$0CAA@@@8 DD FLAT:??_R0?AV?$CDataBlockList@_J$0CAA@@@@8 ; CDataBlockList<__int64,512>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDataBlockList@_J$0CAA@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDataBlockList@_J$0CAA@@@8
rdata$r	SEGMENT
??_R2?$CDataBlockList@_J$0CAA@@@8 DD FLAT:??_R1A@?0A@EA@?$CDataBlockList@_J$0CAA@@@8 ; CDataBlockList<__int64,512>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CDataBlockListUNK@@8
rdata$r	ENDS
;	COMDAT ??_R3?$CDataBlockList@_J$0CAA@@@8
rdata$r	SEGMENT
??_R3?$CDataBlockList@_J$0CAA@@@8 DD 00H		; CDataBlockList<__int64,512>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$CDataBlockList@_J$0CAA@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDataBlockList@_J$0CAA@@@@8
data$rs	SEGMENT
??_R0?AV?$CDataBlockList@_J$0CAA@@@@8 DD FLAT:??_7type_info@@6B@ ; CDataBlockList<__int64,512> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDataBlockList@_J$0CAA@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CDataBlockList@_J$0CAA@@@6B@
rdata$r	SEGMENT
??_R4?$CDataBlockList@_J$0CAA@@@6B@ DD 00H		; CDataBlockList<__int64,512>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDataBlockList@_J$0CAA@@@@8
	DD	FLAT:??_R3?$CDataBlockList@_J$0CAA@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CXScaleManagerImp@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CXScaleManagerImp@@8 DD FLAT:??_R0?AVCXScaleManagerImp@@@8 ; CXScaleManagerImp::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CXScaleManagerImp@@8
rdata$r	ENDS
;	COMDAT ??_R2CXScaleManagerImp@@8
rdata$r	SEGMENT
??_R2CXScaleManagerImp@@8 DD FLAT:??_R1A@?0A@EA@CXScaleManagerImp@@8 ; CXScaleManagerImp::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CXScaleManager@@8
rdata$r	ENDS
;	COMDAT ??_R3CXScaleManagerImp@@8
rdata$r	SEGMENT
??_R3CXScaleManagerImp@@8 DD 00H			; CXScaleManagerImp::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CXScaleManagerImp@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCXScaleManagerImp@@@8
data$rs	SEGMENT
??_R0?AVCXScaleManagerImp@@@8 DD FLAT:??_7type_info@@6B@ ; CXScaleManagerImp `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCXScaleManagerImp@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CXScaleManagerImp@@6B@
rdata$r	SEGMENT
??_R4CXScaleManagerImp@@6B@ DD 00H			; CXScaleManagerImp::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCXScaleManagerImp@@@8
	DD	FLAT:??_R3CXScaleManagerImp@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDataBlockList@UtagAREA@CXScaleManager@@$0CAA@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDataBlockList@UtagAREA@CXScaleManager@@$0CAA@@@8 DD FLAT:??_R0?AV?$CDataBlockList@UtagAREA@CXScaleManager@@$0CAA@@@@8 ; CDataBlockList<CXScaleManager::tagAREA,512>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDataBlockList@UtagAREA@CXScaleManager@@$0CAA@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDataBlockList@UtagAREA@CXScaleManager@@$0CAA@@@8
rdata$r	SEGMENT
??_R2?$CDataBlockList@UtagAREA@CXScaleManager@@$0CAA@@@8 DD FLAT:??_R1A@?0A@EA@?$CDataBlockList@UtagAREA@CXScaleManager@@$0CAA@@@8 ; CDataBlockList<CXScaleManager::tagAREA,512>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CDataBlockListUNK@@8
rdata$r	ENDS
;	COMDAT ??_R3?$CDataBlockList@UtagAREA@CXScaleManager@@$0CAA@@@8
rdata$r	SEGMENT
??_R3?$CDataBlockList@UtagAREA@CXScaleManager@@$0CAA@@@8 DD 00H ; CDataBlockList<CXScaleManager::tagAREA,512>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$CDataBlockList@UtagAREA@CXScaleManager@@$0CAA@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDataBlockList@UtagAREA@CXScaleManager@@$0CAA@@@@8
data$rs	SEGMENT
??_R0?AV?$CDataBlockList@UtagAREA@CXScaleManager@@$0CAA@@@@8 DD FLAT:??_7type_info@@6B@ ; CDataBlockList<CXScaleManager::tagAREA,512> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDataBlockList@UtagAREA@CXScaleManager@@$0CAA@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CDataBlockList@UtagAREA@CXScaleManager@@$0CAA@@@6B@
rdata$r	SEGMENT
??_R4?$CDataBlockList@UtagAREA@CXScaleManager@@$0CAA@@@6B@ DD 00H ; CDataBlockList<CXScaleManager::tagAREA,512>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDataBlockList@UtagAREA@CXScaleManager@@$0CAA@@@@8
	DD	FLAT:??_R3?$CDataBlockList@UtagAREA@CXScaleManager@@$0CAA@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDataBlockList@Utm@@$0CAA@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDataBlockList@Utm@@$0CAA@@@8 DD FLAT:??_R0?AV?$CDataBlockList@Utm@@$0CAA@@@@8 ; CDataBlockList<tm,512>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDataBlockList@Utm@@$0CAA@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDataBlockList@Utm@@$0CAA@@@8
rdata$r	SEGMENT
??_R2?$CDataBlockList@Utm@@$0CAA@@@8 DD FLAT:??_R1A@?0A@EA@?$CDataBlockList@Utm@@$0CAA@@@8 ; CDataBlockList<tm,512>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CDataBlockListUNK@@8
rdata$r	ENDS
;	COMDAT ??_R3?$CDataBlockList@Utm@@$0CAA@@@8
rdata$r	SEGMENT
??_R3?$CDataBlockList@Utm@@$0CAA@@@8 DD 00H		; CDataBlockList<tm,512>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$CDataBlockList@Utm@@$0CAA@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDataBlockList@Utm@@$0CAA@@@@8
data$rs	SEGMENT
??_R0?AV?$CDataBlockList@Utm@@$0CAA@@@@8 DD FLAT:??_7type_info@@6B@ ; CDataBlockList<tm,512> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDataBlockList@Utm@@$0CAA@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CDataBlockList@Utm@@$0CAA@@@6B@
rdata$r	SEGMENT
??_R4?$CDataBlockList@Utm@@$0CAA@@@6B@ DD 00H		; CDataBlockList<tm,512>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDataBlockList@Utm@@$0CAA@@@@8
	DD	FLAT:??_R3?$CDataBlockList@Utm@@$0CAA@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDataBlockList@H$0CAA@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDataBlockList@H$0CAA@@@8 DD FLAT:??_R0?AV?$CDataBlockList@H$0CAA@@@@8 ; CDataBlockList<int,512>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDataBlockList@H$0CAA@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDataBlockList@H$0CAA@@@8
rdata$r	SEGMENT
??_R2?$CDataBlockList@H$0CAA@@@8 DD FLAT:??_R1A@?0A@EA@?$CDataBlockList@H$0CAA@@@8 ; CDataBlockList<int,512>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CDataBlockListUNK@@8
rdata$r	ENDS
;	COMDAT ??_R3?$CDataBlockList@H$0CAA@@@8
rdata$r	SEGMENT
??_R3?$CDataBlockList@H$0CAA@@@8 DD 00H			; CDataBlockList<int,512>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$CDataBlockList@H$0CAA@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDataBlockList@H$0CAA@@@@8
data$rs	SEGMENT
??_R0?AV?$CDataBlockList@H$0CAA@@@@8 DD FLAT:??_7type_info@@6B@ ; CDataBlockList<int,512> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDataBlockList@H$0CAA@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CDataBlockList@H$0CAA@@@6B@
rdata$r	SEGMENT
??_R4?$CDataBlockList@H$0CAA@@@6B@ DD 00H		; CDataBlockList<int,512>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDataBlockList@H$0CAA@@@@8
	DD	FLAT:??_R3?$CDataBlockList@H$0CAA@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CXScaleManager@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CXScaleManager@@8 DD FLAT:??_R0?AVCXScaleManager@@@8 ; CXScaleManager::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CXScaleManager@@8
rdata$r	ENDS
;	COMDAT ??_R2CXScaleManager@@8
rdata$r	SEGMENT
??_R2CXScaleManager@@8 DD FLAT:??_R1A@?0A@EA@CXScaleManager@@8 ; CXScaleManager::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CXScaleManager@@8
rdata$r	SEGMENT
??_R3CXScaleManager@@8 DD 00H				; CXScaleManager::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CXScaleManager@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCXScaleManager@@@8
data$rs	SEGMENT
??_R0?AVCXScaleManager@@@8 DD FLAT:??_7type_info@@6B@	; CXScaleManager `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCXScaleManager@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CXScaleManager@@6B@
rdata$r	SEGMENT
??_R4CXScaleManager@@6B@ DD 00H				; CXScaleManager::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCXScaleManager@@@8
	DD	FLAT:??_R3CXScaleManager@@8
rdata$r	ENDS
;	COMDAT ??_R2CMapPtrToPtr@@8
rdata$r	SEGMENT
??_R2CMapPtrToPtr@@8 DD FLAT:??_R1A@?0A@EA@CMapPtrToPtr@@8 ; CMapPtrToPtr::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CObject@@8
rdata$r	ENDS
;	COMDAT ??_R3CMapPtrToPtr@@8
rdata$r	SEGMENT
??_R3CMapPtrToPtr@@8 DD 00H				; CMapPtrToPtr::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CMapPtrToPtr@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCMapPtrToPtr@@@8
data$rs	SEGMENT
??_R0?AVCMapPtrToPtr@@@8 DD FLAT:??_7type_info@@6B@	; CMapPtrToPtr `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCMapPtrToPtr@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@CMapPtrToPtr@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CMapPtrToPtr@@8 DD FLAT:??_R0?AVCMapPtrToPtr@@@8 ; CMapPtrToPtr::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CMapPtrToPtr@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CMapTimeToLong@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CMapTimeToLong@@8 DD FLAT:??_R0?AVCMapTimeToLong@@@8 ; CMapTimeToLong::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CMapTimeToLong@@8
rdata$r	ENDS
;	COMDAT ??_R2CMapTimeToLong@@8
rdata$r	SEGMENT
??_R2CMapTimeToLong@@8 DD FLAT:??_R1A@?0A@EA@CMapTimeToLong@@8 ; CMapTimeToLong::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CMapPtrToPtr@@8
	DD	FLAT:??_R1A@?0A@EA@CObject@@8
rdata$r	ENDS
;	COMDAT ??_R3CMapTimeToLong@@8
rdata$r	SEGMENT
??_R3CMapTimeToLong@@8 DD 00H				; CMapTimeToLong::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2CMapTimeToLong@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCMapTimeToLong@@@8
data$rs	SEGMENT
??_R0?AVCMapTimeToLong@@@8 DD FLAT:??_7type_info@@6B@	; CMapTimeToLong `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCMapTimeToLong@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CMapTimeToLong@@6B@
rdata$r	SEGMENT
??_R4CMapTimeToLong@@6B@ DD 00H				; CMapTimeToLong::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCMapTimeToLong@@@8
	DD	FLAT:??_R3CMapTimeToLong@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CDataBlockListUNK@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CDataBlockListUNK@@8 DD FLAT:??_R0?AVCDataBlockListUNK@@@8 ; CDataBlockListUNK::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CDataBlockListUNK@@8
rdata$r	ENDS
;	COMDAT ??_R2CDataBlockListUNK@@8
rdata$r	SEGMENT
??_R2CDataBlockListUNK@@8 DD FLAT:??_R1A@?0A@EA@CDataBlockListUNK@@8 ; CDataBlockListUNK::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CDataBlockListUNK@@8
rdata$r	SEGMENT
??_R3CDataBlockListUNK@@8 DD 00H			; CDataBlockListUNK::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CDataBlockListUNK@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCDataBlockListUNK@@@8
data$rs	SEGMENT
??_R0?AVCDataBlockListUNK@@@8 DD FLAT:??_7type_info@@6B@ ; CDataBlockListUNK `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCDataBlockListUNK@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CDataBlockListUNK@@6B@
rdata$r	SEGMENT
??_R4CDataBlockListUNK@@6B@ DD 00H			; CDataBlockListUNK::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCDataBlockListUNK@@@8
	DD	FLAT:??_R3CDataBlockListUNK@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@FOIKENOD@vector?5too?5long@
CONST	SEGMENT
??_C@_0BA@FOIKENOD@vector?5too?5long@ DB 'vector too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01GBGANLPD@0@
CONST	SEGMENT
??_C@_01GBGANLPD@0@ DB '0', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BNMNAMM@?$CFY?$CFm?$CFd?$CFH?$CFM?$CFS@
CONST	SEGMENT
??_C@_0N@BNMNAMM@?$CFY?$CFm?$CFd?$CFH?$CFM?$CFS@ DB '%Y%m%d%H%M%S', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@IMPIBBAB@YYYYMMDDHHMMSS@
CONST	SEGMENT
??_C@_0P@IMPIBBAB@YYYYMMDDHHMMSS@ DB 'YYYYMMDDHHMMSS', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08DEPALGMO@?$CFd?$CFH?$CFM?$CFS@
CONST	SEGMENT
??_C@_08DEPALGMO@?$CFd?$CFH?$CFM?$CFS@ DB '%d%H%M%S', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08JFMBEEDE@DDHHMMSS@
CONST	SEGMENT
??_C@_08JFMBEEDE@DDHHMMSS@ DB 'DDHHMMSS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06NDFCBELD@?$CFH?$CFM?$CFS@
CONST	SEGMENT
??_C@_06NDFCBELD@?$CFH?$CFM?$CFS@ DB '%H%M%S', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06MAANBBPI@HHMMSS@
CONST	SEGMENT
??_C@_06MAANBBPI@HHMMSS@ DB 'HHMMSS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08LIEOKHEF@?$CFm?$CFd?$CFH?$CFM@
CONST	SEGMENT
??_C@_08LIEOKHEF@?$CFm?$CFd?$CFH?$CFM@ DB '%m%d%H%M', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06CLONMKIH@?$CFY?$CFm?$CFd@
CONST	SEGMENT
??_C@_06CLONMKIH@?$CFY?$CFm?$CFd@ DB '%Y%m%d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08DKDJLCMP@YYYYMMDD@
CONST	SEGMENT
??_C@_08DKDJLCMP@YYYYMMDD@ DB 'YYYYMMDD', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04GICMHJFP@?$CFY?$CFm@
CONST	SEGMENT
??_C@_04GICMHJFP@?$CFY?$CFm@ DB '%Y%m', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06EBMMBHJD@YYYYMM@
CONST	SEGMENT
??_C@_06EBMMBHJD@YYYYMM@ DB 'YYYYMM', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08KLIIINKM@MMDDHHMM@
CONST	SEGMENT
??_C@_08KLIIINKM@MMDDHHMM@ DB 'MMDDHHMM', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07MGCPDNLD@DEFAULT@
CONST	SEGMENT
??_C@_07MGCPDNLD@DEFAULT@ DB 'DEFAULT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02PPNCLIJD@SS@
CONST	SEGMENT
??_C@_02PPNCLIJD@SS@ DB 'SS', 00H			; `string'
CONST	ENDS
;	COMDAT ??_7CXScaleManagerImp@@6B@
CONST	SEGMENT
??_7CXScaleManagerImp@@6B@ DD FLAT:??_R4CXScaleManagerImp@@6B@ ; CXScaleManagerImp::`vftable'
	DD	FLAT:??_ECXScaleManagerImp@@UAEPAXI@Z
	DD	FLAT:?GetRQIndexFromString@CXScaleManagerImp@@MAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
	DD	FLAT:?SetPacketListManager@CXScaleManagerImp@@UAEXPAVCPacketListManager@@@Z
	DD	FLAT:?SetIndicatorList@CXScaleManagerImp@@UAEXPAVCIndicatorList@@@Z
	DD	FLAT:?GetPacketListManager@CXScaleManagerImp@@UAEPAVCPacketListManager@@XZ
	DD	FLAT:?SetApplyToolBar@CXScaleManagerImp@@UAEXH@Z
	DD	FLAT:?GetApplyToolBar@CXScaleManagerImp@@UAEHXZ
	DD	FLAT:?SetReverse@CXScaleManagerImp@@UAEXH@Z
	DD	FLAT:?GetReverse@CXScaleManagerImp@@UAEHXZ
	DD	FLAT:?GetMinScaleInterval_nUnit@CXScaleManagerImp@@MAEHXZ
	DD	FLAT:?SetWeightedVolume@CXScaleManagerImp@@UAEXHH@Z
	DD	FLAT:?GetWeightedVolume@CXScaleManagerImp@@UAEHXZ
	DD	FLAT:?SetFutureTimeCount@CXScaleManagerImp@@MAEXH@Z
	DD	FLAT:?GetFutureTimeCount@CXScaleManagerImp@@MAEHXZ
	DD	FLAT:?SetLeftDataHideCount@CXScaleManagerImp@@UAEXHH@Z
	DD	FLAT:?GetLeftDataHideCount@CXScaleManagerImp@@UAEHXZ
	DD	FLAT:?GetUseOEBTMargin@CXScaleManagerImp@@UAEHXZ
	DD	FLAT:?SetUseOEBTMargin@CXScaleManagerImp@@UAEXH@Z
	DD	FLAT:?SetRightMarginWidth@CXScaleManagerImp@@UAEXH@Z
	DD	FLAT:?SetRightMarginAndFutureTime@CXScaleManagerImp@@MAEXHH@Z
	DD	FLAT:?SetCandleTypeOnResize@CXScaleManagerImp@@UAEXW4RSA_TYPE@CXScaleManager@@@Z
	DD	FLAT:?GetCandleTypeOnResize@CXScaleManagerImp@@UAE?AW4RSA_TYPE@CXScaleManager@@XZ
	DD	FLAT:?SetFixedInterval@CXScaleManagerImp@@UAEXHH@Z
	DD	FLAT:?IsFixedInterval@CXScaleManagerImp@@UAEHXZ
	DD	FLAT:?AddOEBTRQ@CXScaleManagerImp@@UAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@00@Z
	DD	FLAT:?DelOEBTRQ@CXScaleManagerImp@@UAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
	DD	FLAT:?Clear_OEBTRQ@CXScaleManagerImp@@UAEXXZ
	DD	FLAT:?Calc_DRI@CXScaleManagerImp@@MAEXH@Z
	DD	FLAT:?Calc_DRI_Merge@CXScaleManagerImp@@MAEXXZ
	DD	FLAT:?RealDataReceived@CXScaleManagerImp@@UAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z
	DD	FLAT:?SetBlockColumnCount@CXScaleManagerImp@@MAEXH@Z
	DD	FLAT:?SetBlockColumn_Cur@CXScaleManagerImp@@MAEXH@Z
	DD	FLAT:?SetIChartCtrl@CXScaleManagerImp@@UAEXPAUIChartCtrl@@@Z
	DD	FLAT:?GetCount@CXScaleManagerImp@@UAEHXZ
	DD	FLAT:?GetDrawCount_Cur@CXScaleManagerImp@@UAEHXZ
	DD	FLAT:?GetStartDrawIdx_Cur@CXScaleManagerImp@@UAEHXZ
	DD	FLAT:?GetEndDrawIdx_Cur@CXScaleManagerImp@@UAEHXZ
	DD	FLAT:?SetStartEndDrawIdx_Cur@CXScaleManagerImp@@UAEXHHH@Z
	DD	FLAT:?GetStartEndDrawIdx_Cur@CXScaleManagerImp@@UAEXAAH0@Z
	DD	FLAT:?GetPageCountNextStep@CXScaleManagerImp@@UAEHHHHHH@Z
	DD	FLAT:?GetDrawIndex@CXScaleManagerImp@@UAEXHHAAH0@Z
	DD	FLAT:?GetDrawIndex@CXScaleManagerImp@@UAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HHAAH1@Z
	DD	FLAT:?GetDTIFromDRI_AbleRange@CXScaleManagerImp@@UAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HPAH@Z
	DD	FLAT:?GetScaleUnit_Max@CXScaleManagerImp@@UAE?AW4HORZSCALEDRAWERTYPE@CScaleBaseData@@PBD@Z
	DD	FLAT:?GetScaleInterval_Unit_Max@CXScaleManagerImp@@UAEHXZ
	DD	FLAT:?SetCurScaleInfo@CXScaleManagerImp@@UAEXH@Z
	DD	FLAT:?GetCurScaleInfo@CXScaleManagerImp@@UAEXAAH@Z
	DD	FLAT:?NextScaleTime@CXScaleManagerImp@@MAEHPA_JPAPAUtagAREA@CXScaleManager@@@Z
	DD	FLAT:?PrevScaleTime@CXScaleManagerImp@@MAEXPA_JPAPAUtagAREA@CXScaleManager@@@Z
	DD	FLAT:?GetAt_ScaleTime@CXScaleManagerImp@@MAEXHPA_JPAPAUtagAREA@CXScaleManager@@@Z
	DD	FLAT:?GetPacketType@CXScaleManagerImp@@UAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PBD@Z
	DD	FLAT:?GetAREAfRQnDTI@CXScaleManagerImp@@MAEHHHPAUtagAREA@CXScaleManager@@@Z
	DD	FLAT:?GetAREAfRQnDTI@CXScaleManagerImp@@MAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HHPAUtagAREA@CXScaleManager@@@Z
	DD	FLAT:?GetRQInfosFromPt@CXScaleManagerImp@@MAEHHAAHAAVCStringArray@@AAV?$CArray@HH@@PAUtagAREA@CXScaleManager@@@Z
	DD	FLAT:?GetTimeFromX@CXScaleManagerImp@@MAE_JHPAHPAPAUtagAREA@CXScaleManager@@@Z
	DD	FLAT:?GetDoubleFromX@CXScaleManagerImp@@MAENHHHPAHPAPAUtagAREA@CXScaleManager@@PBD@Z
	DD	FLAT:?GetXFromDouble@CXScaleManagerImp@@MAEHHHNPAPAUtagAREA@CXScaleManager@@@Z
	DD	FLAT:?GetScaleUnitAlphaWeight@CXScaleManagerImp@@UAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
	DD	FLAT:?IsUseable@CXScaleManagerImp@@UAEHXZ
	DD	FLAT:?GetTimeFromDRI@CXScaleManagerImp@@UAEXHPA_J@Z
	DD	FLAT:?Initialize@CXScaleManagerImp@@UAEXH@Z
	DD	FLAT:?SetThreadFlag@CXScaleManagerImp@@UAEXH@Z
	DD	FLAT:?GetThreadFlag@CXScaleManagerImp@@UAEHXZ
	DD	FLAT:?GetCalculationMode@CXScaleManagerImp@@MAEHXZ
	DD	FLAT:?SetNeedCalcAreaFlag@CXScaleManagerImp@@MAEXH@Z
	DD	FLAT:?IsSpecialTime@CXScaleManagerImp@@MAEHPBD_JAAJ@Z
	DD	FLAT:?SetDefaultDataSpace@CXScaleManagerImp@@MAEXHH@Z
	DD	FLAT:?Calc_AREA@CXScaleManagerImp@@MAEXH@Z
	DD	FLAT:?GetColumnWidth@CXScaleManagerImp@@MAEHH@Z
	DD	FLAT:?GetDRInFromPt@CXScaleManagerImp@@MAEHHPAHPAPAUtagAREA@CXScaleManager@@HH@Z
	DD	FLAT:?GetGraphXArea_End@CXScaleManagerImp@@MAEHHH@Z
	DD	FLAT:?GetGraphXArea_Left@CXScaleManagerImp@@MAEHHH@Z
	DD	FLAT:?GetGraphXArea_Right@CXScaleManagerImp@@MAEHHH@Z
	DD	FLAT:?GetGraphXArea_Start@CXScaleManagerImp@@MAEHHH@Z
	DD	FLAT:?GetScaleDRIandTime@CXScaleManagerImp@@MAEHHAAPAV?$CDataBlockList@H$0CAA@@@AAPAV?$CDataBlockList@Utm@@$0CAA@@@HW4HORZSCALEDRAWERTYPE@CScaleBaseData@@HPBDAAHABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
	DD	FLAT:?GetScreenWidth@CXScaleManagerImp@@MAEHH@Z
	DD	FLAT:?GetXFromTime@CXScaleManagerImp@@MAEHH_JPAPAUtagAREA@CXScaleManager@@H@Z
	DD	FLAT:?GetDTInAREAfRQnPt@CXScaleManagerImp@@MAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HAAHPAHPAUtagAREA@CXScaleManager@@H@Z
	DD	FLAT:?GetDTInAREAfRQnPt@CXScaleManagerImp@@MAEHHAAHPAHPAUtagAREA@CXScaleManager@@@Z
	DD	FLAT:?IsAllOnePixel@CXScaleManagerImp@@MAEHHPBD@Z
	DD	FLAT:?IsInGraphXArea@CXScaleManagerImp@@MAEHHHH@Z
	DD	FLAT:?GetAreaFromDRI@CXScaleManagerImp@@MAEXHHPAPAUtagAREA@CXScaleManager@@@Z
	DD	FLAT:?GetGraphXAreaLR@CXScaleManagerImp@@MAEXHAAH0H@Z
	DD	FLAT:?GetGraphXAreaSE@CXScaleManagerImp@@MAEXHAAH0H@Z
	DD	FLAT:?SetColumnWidth@CXScaleManagerImp@@MAEXHH@Z
	DD	FLAT:?SetScreenRegion@CXScaleManagerImp@@MAEXHHHH@Z
	DD	FLAT:?GetDTIArea@CXScaleManagerImp@@MAEPAV?$CDataBlockList@UtagAREA@CXScaleManager@@$0CAA@@@HPBDAAH@Z
	DD	FLAT:?SetFlagForCalcDRIandScrollByReal@CXScaleManagerImp@@MAEXH@Z
	DD	FLAT:?IsScrollByReal@CXScaleManagerImp@@MAEHXZ
	DD	FLAT:?OnUserZoomChanged@CXScaleManagerImp@@MAEXXZ
	DD	FLAT:?IsEmptyData@CXScaleManagerImp@@MAEHXZ
	DD	FLAT:?AddVerticalBoxInfo@CXScaleManagerImp@@UAEXPBDNKH@Z
	DD	FLAT:?GetVerticalBoxInfo@CXScaleManagerImp@@UAEXPBD0AAVCRect@@AAKAAH@Z
	DD	FLAT:?GetPriceMinMaxShowType@CXScaleManagerImp@@MAEHXZ
	DD	FLAT:?SetPriceMinMaxShowType@CXScaleManagerImp@@MAEXH@Z
	DD	FLAT:?GetScaleDRIandTimeAllData@CXScaleManagerImp@@UAEHHAAPAV?$CDataBlockList@H$0CAA@@@AAPAV?$CDataBlockList@Utm@@$0CAA@@@W4HORZSCALEDRAWERTYPE@CScaleBaseData@@PBDAAH@Z
CONST	ENDS
;	COMDAT ??_7?$CTypedPtrMap@VCMapWordToPtr@@FPAVCXScaleGridTime@@@@6B@
CONST	SEGMENT
??_7?$CTypedPtrMap@VCMapWordToPtr@@FPAVCXScaleGridTime@@@@6B@ DD FLAT:??_R4?$CTypedPtrMap@VCMapWordToPtr@@FPAVCXScaleGridTime@@@@6B@ ; CTypedPtrMap<CMapWordToPtr,short,CXScaleGridTime *>::`vftable'
	DD	FLAT:?GetRuntimeClass@CMapWordToPtr@@UBEPAUCRuntimeClass@@XZ
	DD	FLAT:??_E?$CTypedPtrMap@VCMapWordToPtr@@FPAVCXScaleGridTime@@@@UAEPAXI@Z
	DD	FLAT:?Serialize@CObject@@UAEXAAVCArchive@@@Z
	DD	FLAT:?AssertValid@CObject@@UBEXXZ
	DD	FLAT:?Dump@CObject@@UBEXAAVCDumpContext@@@Z
CONST	ENDS
;	COMDAT ??_7?$CDataBlockList@_J$0CAA@@@6B@
CONST	SEGMENT
??_7?$CDataBlockList@_J$0CAA@@@6B@ DD FLAT:??_R4?$CDataBlockList@_J$0CAA@@@6B@ ; CDataBlockList<__int64,512>::`vftable'
	DD	FLAT:??_E?$CDataBlockList@_J$0CAA@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$CDataBlockList@UtagAREA@CXScaleManager@@$0CAA@@@6B@
CONST	SEGMENT
??_7?$CDataBlockList@UtagAREA@CXScaleManager@@$0CAA@@@6B@ DD FLAT:??_R4?$CDataBlockList@UtagAREA@CXScaleManager@@$0CAA@@@6B@ ; CDataBlockList<CXScaleManager::tagAREA,512>::`vftable'
	DD	FLAT:??_E?$CDataBlockList@UtagAREA@CXScaleManager@@$0CAA@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$CDataBlockList@H$0CAA@@@6B@
CONST	SEGMENT
??_7?$CDataBlockList@H$0CAA@@@6B@ DD FLAT:??_R4?$CDataBlockList@H$0CAA@@@6B@ ; CDataBlockList<int,512>::`vftable'
	DD	FLAT:??_E?$CDataBlockList@H$0CAA@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$CDataBlockList@Utm@@$0CAA@@@6B@
CONST	SEGMENT
??_7?$CDataBlockList@Utm@@$0CAA@@@6B@ DD FLAT:??_R4?$CDataBlockList@Utm@@$0CAA@@@6B@ ; CDataBlockList<tm,512>::`vftable'
	DD	FLAT:??_E?$CDataBlockList@Utm@@$0CAA@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7CXScaleManager@@6B@
CONST	SEGMENT
??_7CXScaleManager@@6B@ DD FLAT:??_R4CXScaleManager@@6B@ ; CXScaleManager::`vftable'
	DD	FLAT:??_ECXScaleManager@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??_7CMapTimeToLong@@6B@
CONST	SEGMENT
??_7CMapTimeToLong@@6B@ DD FLAT:??_R4CMapTimeToLong@@6B@ ; CMapTimeToLong::`vftable'
	DD	FLAT:?GetRuntimeClass@CMapPtrToPtr@@UBEPAUCRuntimeClass@@XZ
	DD	FLAT:??_ECMapTimeToLong@@UAEPAXI@Z
	DD	FLAT:?Serialize@CObject@@UAEXAAVCArchive@@@Z
	DD	FLAT:?AssertValid@CObject@@UBEXXZ
	DD	FLAT:?Dump@CObject@@UBEXAAVCDumpContext@@@Z
CONST	ENDS
;	COMDAT ??_7CDataBlockListUNK@@6B@
CONST	SEGMENT
??_7CDataBlockListUNK@@6B@ DD FLAT:??_R4CDataBlockListUNK@@6B@ ; CDataBlockListUNK::`vftable'
	DD	FLAT:??_ECDataBlockListUNK@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GCADKGJO@map?1set?5too?5long@
CONST	SEGMENT
??_C@_0BB@GCADKGJO@map?1set?5too?5long@ DB 'map/set too long', 00H ; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@CObject@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CObject@@8 DD FLAT:??_R0?AVCObject@@@8	; CObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CObject@@8
rdata$r	ENDS
;	COMDAT ??_R2CObject@@8
rdata$r	SEGMENT
??_R2CObject@@8 DD FLAT:??_R1A@?0A@EA@CObject@@8	; CObject::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CObject@@8
rdata$r	SEGMENT
??_R3CObject@@8 DD 00H					; CObject::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CObject@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCObject@@@8
data$rs	SEGMENT
??_R0?AVCObject@@@8 DD FLAT:??_7type_info@@6B@		; CObject `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCObject@@', 00H
data$rs	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$?0U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@PAX@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?0U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@PAX@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@1@@Z$1
__ehfuncinfo$??$?0U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@PAX@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?0U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@PAX@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@PAX@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@PAX@std@@@1@@Z$0
__ehfuncinfo$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@PAX@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@PAX@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$?0U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?0U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@@Z$1
__ehfuncinfo$??$?0U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?0U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@1@@Z$0
__ehfuncinfo$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Emplace@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@PAX@std@@_N@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Emplace@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@PAX@std@@_N@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@1@@Z$2
__ehfuncinfo$??$_Emplace@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@PAX@std@@_N@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Emplace@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@PAX@std@@_N@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Emplace@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@_N@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Emplace@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@_N@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@@Z$2
__ehfuncinfo$??$_Emplace@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@_N@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Emplace@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@_N@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$emplace@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$emplace@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@1@@Z$2
__ehfuncinfo$??$emplace@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$emplace@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$emplace@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$emplace@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@@Z$2
__ehfuncinfo$??$emplace@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$emplace@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$insert@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@$0A@@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$insert@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@$0A@@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@1@@Z$2
__ehfuncinfo$??$insert@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@$0A@@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$insert@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@$0A@@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$insert@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@$0A@@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$insert@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@$0A@@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@@Z$2
__ehfuncinfo$??$insert@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@$0A@@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$insert@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@$0A@@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_GCXScaleManagerImp@@UAEPAXI@Z DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??_GCXScaleManagerImp@@UAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_GCXScaleManagerImp@@UAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?GetTimeDiffWithCurrentRQ@CXScaleManagerImp@@IAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetTimeDiffWithCurrentRQ@CXScaleManagerImp@@IAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z$0
__ehfuncinfo$?GetTimeDiffWithCurrentRQ@CXScaleManagerImp@@IAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetTimeDiffWithCurrentRQ@CXScaleManagerImp@@IAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?GetXFromDouble@CXScaleManagerImp@@MAEHHHNPAPAUtagAREA@CXScaleManager@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetXFromDouble@CXScaleManagerImp@@MAEHHHNPAPAUtagAREA@CXScaleManager@@@Z$1
__ehfuncinfo$?GetXFromDouble@CXScaleManagerImp@@MAEHHHNPAPAUtagAREA@CXScaleManager@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetXFromDouble@CXScaleManagerImp@@MAEHHHNPAPAUtagAREA@CXScaleManager@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?GetAREAfRQnDTI@CXScaleManagerImp@@MAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HHPAUtagAREA@CXScaleManager@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetAREAfRQnDTI@CXScaleManagerImp@@MAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HHPAUtagAREA@CXScaleManager@@@Z$0
__ehfuncinfo$?GetAREAfRQnDTI@CXScaleManagerImp@@MAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HHPAUtagAREA@CXScaleManager@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetAREAfRQnDTI@CXScaleManagerImp@@MAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HHPAUtagAREA@CXScaleManager@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?GetDTInAREAfRQnPt@CXScaleManagerImp@@MAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HAAHPAHPAUtagAREA@CXScaleManager@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetDTInAREAfRQnPt@CXScaleManagerImp@@MAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HAAHPAHPAUtagAREA@CXScaleManager@@H@Z$0
__ehfuncinfo$?GetDTInAREAfRQnPt@CXScaleManagerImp@@MAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HAAHPAHPAUtagAREA@CXScaleManager@@H@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetDTInAREAfRQnPt@CXScaleManagerImp@@MAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HAAHPAHPAUtagAREA@CXScaleManager@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Calc_AREA@CXScaleManagerImp@@MAEXH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Calc_AREA@CXScaleManagerImp@@MAEXH@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Calc_AREA@CXScaleManagerImp@@MAEXH@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$?Calc_AREA@CXScaleManagerImp@@MAEXH@Z$3
__ehfuncinfo$?Calc_AREA@CXScaleManagerImp@@MAEXH@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?Calc_AREA@CXScaleManagerImp@@MAEXH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Calc_DRI_Merge@CXScaleManagerImp@@MAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Calc_DRI_Merge@CXScaleManagerImp@@MAEXXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Calc_DRI_Merge@CXScaleManagerImp@@MAEXXZ$1
__ehfuncinfo$?Calc_DRI_Merge@CXScaleManagerImp@@MAEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?Calc_DRI_Merge@CXScaleManagerImp@@MAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?Calc_DRI@CXScaleManagerImp@@MAEXH@Z DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$?Calc_DRI@CXScaleManagerImp@@MAEXH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?Calc_DRI@CXScaleManagerImp@@MAEXH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Calc_DRI@CXScaleManagerImp@@MAEXH@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?Calc_DRI@CXScaleManagerImp@@MAEXH@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?Calc_DRI@CXScaleManagerImp@@MAEXH@Z$21
	DD	00H
	DD	FLAT:__unwindfunclet$?Calc_DRI@CXScaleManagerImp@@MAEXH@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?Calc_DRI@CXScaleManagerImp@@MAEXH@Z$6
	DD	00H
	DD	FLAT:__unwindfunclet$?Calc_DRI@CXScaleManagerImp@@MAEXH@Z$8
	DD	00H
	DD	FLAT:__unwindfunclet$?Calc_DRI@CXScaleManagerImp@@MAEXH@Z$9
	DD	06H
	DD	FLAT:__unwindfunclet$?Calc_DRI@CXScaleManagerImp@@MAEXH@Z$10
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?GetRQIndexFromString@CXScaleManagerImp@@MAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetRQIndexFromString@CXScaleManagerImp@@MAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z$0
__ehfuncinfo$?GetRQIndexFromString@CXScaleManagerImp@@MAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetRQIndexFromString@CXScaleManagerImp@@MAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?AddVerticalBoxInfo@CXScaleManagerImp@@UAEXPBDNKH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AddVerticalBoxInfo@CXScaleManagerImp@@UAEXPBDNKH@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?AddVerticalBoxInfo@CXScaleManagerImp@@UAEXPBDNKH@Z$10
__ehfuncinfo$?AddVerticalBoxInfo@CXScaleManagerImp@@UAEXPBDNKH@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?AddVerticalBoxInfo@CXScaleManagerImp@@UAEXPBDNKH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?GetScaleUnitAlphaWeight@CXScaleManagerImp@@UAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetScaleUnitAlphaWeight@CXScaleManagerImp@@UAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z$0
__ehfuncinfo$?GetScaleUnitAlphaWeight@CXScaleManagerImp@@UAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetScaleUnitAlphaWeight@CXScaleManagerImp@@UAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?GetPacketType@CXScaleManagerImp@@UAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetPacketType@CXScaleManagerImp@@UAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PBD@Z$0
__ehfuncinfo$?GetPacketType@CXScaleManagerImp@@UAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetPacketType@CXScaleManagerImp@@UAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?GetDTIFromDRI_AbleRange@CXScaleManagerImp@@UAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HPAH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetDTIFromDRI_AbleRange@CXScaleManagerImp@@UAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HPAH@Z$0
__ehfuncinfo$?GetDTIFromDRI_AbleRange@CXScaleManagerImp@@UAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HPAH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetDTIFromDRI_AbleRange@CXScaleManagerImp@@UAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HPAH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?GetDrawIndex@CXScaleManagerImp@@UAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HHAAH1@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetDrawIndex@CXScaleManagerImp@@UAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HHAAH1@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?GetDrawIndex@CXScaleManagerImp@@UAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HHAAH1@Z$1
__ehfuncinfo$?GetDrawIndex@CXScaleManagerImp@@UAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HHAAH1@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?GetDrawIndex@CXScaleManagerImp@@UAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HHAAH1@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?RealDataReceived@CXScaleManagerImp@@UAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?RealDataReceived@CXScaleManagerImp@@UAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z$0
__ehfuncinfo$?RealDataReceived@CXScaleManagerImp@@UAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?RealDataReceived@CXScaleManagerImp@@UAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?DelOEBTRQ@CXScaleManagerImp@@UAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DelOEBTRQ@CXScaleManagerImp@@UAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z$0
__ehfuncinfo$?DelOEBTRQ@CXScaleManagerImp@@UAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?DelOEBTRQ@CXScaleManagerImp@@UAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?AddOEBTRQ@CXScaleManagerImp@@UAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@00@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AddOEBTRQ@CXScaleManagerImp@@UAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@00@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?AddOEBTRQ@CXScaleManagerImp@@UAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@00@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?AddOEBTRQ@CXScaleManagerImp@@UAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@00@Z$2
__ehfuncinfo$?AddOEBTRQ@CXScaleManagerImp@@UAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@00@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?AddOEBTRQ@CXScaleManagerImp@@UAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@00@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?GetDTIFromDRI@CXScaleManagerImp@@IAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetDTIFromDRI@CXScaleManagerImp@@IAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z$0
__ehfuncinfo$?GetDTIFromDRI@CXScaleManagerImp@@IAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetDTIFromDRI@CXScaleManagerImp@@IAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?GetTimeValueFromTime@CXScaleManagerImp@@IAEN_JV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$?GetTimeValueFromTime@CXScaleManagerImp@@IAEN_JV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?GetTimeValueFromTime@CXScaleManagerImp@@IAEN_JV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetTimeValueFromTime@CXScaleManagerImp@@IAEN_JV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?GetTimeValueFromTime@CXScaleManagerImp@@IAEN_JV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?GetTimeValueFromTime@CXScaleManagerImp@@IAEN_JV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$?GetTimeValueFromTime@CXScaleManagerImp@@IAEN_JV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$?GetTimeValueFromTime@CXScaleManagerImp@@IAEN_JV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z$4
	DD	01H
	DD	FLAT:__unwindfunclet$?GetTimeValueFromTime@CXScaleManagerImp@@IAEN_JV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z$5
	DD	01H
	DD	FLAT:__unwindfunclet$?GetTimeValueFromTime@CXScaleManagerImp@@IAEN_JV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z$6
	DD	01H
	DD	FLAT:__unwindfunclet$?GetTimeValueFromTime@CXScaleManagerImp@@IAEN_JV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z$7
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0e35H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?GetTimeFromTimeValue@CXScaleManagerImp@@IAE_J_KV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAUtagRQ_INFO@1@AAUtm@@PBDPAVCMapTimeToLong@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetTimeFromTimeValue@CXScaleManagerImp@@IAE_J_KV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAUtagRQ_INFO@1@AAUtm@@PBDPAVCMapTimeToLong@@@Z$0
__ehfuncinfo$?GetTimeFromTimeValue@CXScaleManagerImp@@IAE_J_KV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAUtagRQ_INFO@1@AAUtm@@PBDPAVCMapTimeToLong@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetTimeFromTimeValue@CXScaleManagerImp@@IAE_J_KV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAUtagRQ_INFO@1@AAUtm@@PBDPAVCMapTimeToLong@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CXScaleManagerImp@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0CXScaleManagerImp@@QAE@XZ DD 019930522H
	DD	0dH
	DD	FLAT:__unwindtable$??0CXScaleManagerImp@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0CXScaleManagerImp@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CXScaleManagerImp@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CXScaleManagerImp@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0CXScaleManagerImp@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0CXScaleManagerImp@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0CXScaleManagerImp@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??0CXScaleManagerImp@@QAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??0CXScaleManagerImp@@QAE@XZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$??0CXScaleManagerImp@@QAE@XZ$7
	DD	07H
	DD	FLAT:__unwindfunclet$??0CXScaleManagerImp@@QAE@XZ$8
	DD	08H
	DD	FLAT:__unwindfunclet$??0CXScaleManagerImp@@QAE@XZ$9
	DD	09H
	DD	FLAT:__unwindfunclet$??0CXScaleManagerImp@@QAE@XZ$10
	DD	0aH
	DD	FLAT:__unwindfunclet$??0CXScaleManagerImp@@QAE@XZ$11
	DD	0bH
	DD	FLAT:__unwindfunclet$??0CXScaleManagerImp@@QAE@XZ$12
xdata$x	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,CXScaleManagerImp::VERTBOX_INFO *>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,CXScaleManagerImp::VERTBOX_INFO *>,void *> > >, COMDAT
; _this$ = ecx

; 970  :         if (_Ptr) {

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	85 c0		 test	 eax, eax
  00005	74 0b		 je	 SHORT $LN8@Alloc_cons

; 255  :         ::operator delete(_Ptr, _Bytes);

  00007	6a 2c		 push	 44			; 0000002cH
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000f	83 c4 08	 add	 esp, 8
$LN8@Alloc_cons:

; 971  :             _Al.deallocate(_Ptr, 1);
; 972  :         }
; 973  :     }

  00012	c3		 ret	 0
??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,CXScaleManagerImp::VERTBOX_INFO *>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,CXScaleManagerImp::VERTBOX_INFO *>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> > >, COMDAT
; _this$ = ecx

; 970  :         if (_Ptr) {

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	85 c0		 test	 eax, eax
  00005	74 0b		 je	 SHORT $LN8@Alloc_cons

; 255  :         ::operator delete(_Ptr, _Bytes);

  00007	6a 2c		 push	 44			; 0000002cH
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000f	83 c4 08	 add	 esp, 8
$LN8@Alloc_cons:

; 971  :             _Al.deallocate(_Ptr, 1);
; 972  :         }
; 973  :     }

  00012	c3		 ret	 0
??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??$?MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z PROC ; std::operator<<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 4808 :     const basic_string<_Elem, _Traits, _Alloc>& _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2272 :         const value_type* _Result = _Bx._Buf;

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	8b c8		 mov	 ecx, eax

; 2286 :         return _BUF_SIZE <= _Myres;

  00008	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 2273 :         if (_Large_string_engaged()) {

  0000c	72 02		 jb	 SHORT $LN6@operator

; 2274 :             _Result = _Unfancy(_Bx._Ptr);

  0000e	8b 08		 mov	 ecx, DWORD PTR [eax]
$LN6@operator:
  00010	53		 push	 ebx
  00011	56		 push	 esi

; 2272 :         const value_type* _Result = _Bx._Buf;

  00012	8b 75 08	 mov	 esi, DWORD PTR __Left$[ebp]
  00015	8b d6		 mov	 edx, esi
  00017	57		 push	 edi

; 2286 :         return _BUF_SIZE <= _Myres;

  00018	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 2273 :         if (_Large_string_engaged()) {

  0001c	72 02		 jb	 SHORT $LN11@operator

; 2274 :             _Result = _Unfancy(_Bx._Ptr);

  0001e	8b 16		 mov	 edx, DWORD PTR [esi]
$LN11@operator:

; 4380 :         return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

  00020	8b 5e 10	 mov	 ebx, DWORD PTR [esi+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 66   :     return _Right < _Left ? _Right : _Left;

  00023	8b f3		 mov	 esi, ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4380 :         return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

  00025	8b 78 10	 mov	 edi, DWORD PTR [eax+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 66   :     return _Right < _Left ? _Right : _Left;

  00028	3b fb		 cmp	 edi, ebx
  0002a	0f 42 f7	 cmovb	 esi, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 384  :         return _CSTD memcmp(_First1, _First2, _Count);

  0002d	83 ee 04	 sub	 esi, 4
  00030	72 11		 jb	 SHORT $LN26@operator
$LL27@operator:
  00032	8b 02		 mov	 eax, DWORD PTR [edx]
  00034	3b 01		 cmp	 eax, DWORD PTR [ecx]
  00036	75 10		 jne	 SHORT $LN25@operator
  00038	83 c2 04	 add	 edx, 4
  0003b	83 c1 04	 add	 ecx, 4
  0003e	83 ee 04	 sub	 esi, 4
  00041	73 ef		 jae	 SHORT $LL27@operator
$LN26@operator:
  00043	83 fe fc	 cmp	 esi, -4			; fffffffcH
  00046	74 34		 je	 SHORT $LN24@operator
$LN25@operator:
  00048	8a 02		 mov	 al, BYTE PTR [edx]
  0004a	3a 01		 cmp	 al, BYTE PTR [ecx]
  0004c	75 27		 jne	 SHORT $LN28@operator
  0004e	83 fe fd	 cmp	 esi, -3			; fffffffdH
  00051	74 29		 je	 SHORT $LN24@operator
  00053	8a 42 01	 mov	 al, BYTE PTR [edx+1]
  00056	3a 41 01	 cmp	 al, BYTE PTR [ecx+1]
  00059	75 1a		 jne	 SHORT $LN28@operator
  0005b	83 fe fe	 cmp	 esi, -2			; fffffffeH
  0005e	74 1c		 je	 SHORT $LN24@operator
  00060	8a 42 02	 mov	 al, BYTE PTR [edx+2]
  00063	3a 41 02	 cmp	 al, BYTE PTR [ecx+2]
  00066	75 0d		 jne	 SHORT $LN28@operator
  00068	83 fe ff	 cmp	 esi, -1
  0006b	74 0f		 je	 SHORT $LN24@operator
  0006d	8a 42 03	 mov	 al, BYTE PTR [edx+3]
  00070	3a 41 03	 cmp	 al, BYTE PTR [ecx+3]
  00073	74 07		 je	 SHORT $LN24@operator
$LN28@operator:
  00075	1b c0		 sbb	 eax, eax
  00077	83 c8 01	 or	 eax, 1
  0007a	eb 02		 jmp	 SHORT $LN29@operator
$LN24@operator:
  0007c	33 c0		 xor	 eax, eax
$LN29@operator:

; 580  :     if (_Ans != 0) {

  0007e	85 c0		 test	 eax, eax
  00080	75 13		 jne	 SHORT $LN18@operator

; 581  :         return _Ans;
; 582  :     }
; 583  : 
; 584  :     if (_Left_size < _Right_size) {

  00082	3b fb		 cmp	 edi, ebx
  00084	76 0b		 jbe	 SHORT $LN30@operator

; 4809 :     return _Left.compare(_Right) < 0;

  00086	5f		 pop	 edi

; 585  :         return -1;

  00087	83 c8 ff	 or	 eax, -1

; 4809 :     return _Left.compare(_Right) < 0;

  0008a	5e		 pop	 esi
  0008b	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0008e	5b		 pop	 ebx

; 4810 : }

  0008f	5d		 pop	 ebp
  00090	c3		 ret	 0
$LN30@operator:

; 588  :     if (_Left_size > _Right_size) {

  00091	1b c0		 sbb	 eax, eax
  00093	f7 d8		 neg	 eax
$LN18@operator:

; 4809 :     return _Left.compare(_Right) < 0;

  00095	5f		 pop	 edi
  00096	5e		 pop	 esi
  00097	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0009a	5b		 pop	 ebx

; 4810 : }

  0009b	5d		 pop	 ebp
  0009c	c3		 ret	 0
??$?MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ENDP ; std::operator<<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Copy_memmove@PAPAXPAPAX@std@@YAPAPAXPAPAX00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAPAXPAPAX@std@@YAPAPAXPAPAX00@Z PROC	; std::_Copy_memmove<void * *,void * *>, COMDAT

; 4058 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4059 :     auto _FirstPtr              = _To_address(_First);
; 4060 :     auto _LastPtr               = _To_address(_Last);
; 4061 :     auto _DestPtr               = _To_address(_Dest);
; 4062 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));
; 4063 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));
; 4064 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));
; 4065 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	56		 push	 esi

; 4066 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00007	8b 75 10	 mov	 esi, DWORD PTR __Dest$[ebp]
  0000a	57		 push	 edi
  0000b	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000e	2b f8		 sub	 edi, eax
  00010	57		 push	 edi
  00011	50		 push	 eax
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 _memmove
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4067 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4068 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

  0001b	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi

; 4069 :     } else {
; 4070 :         return _Dest + (_LastPtr - _FirstPtr);
; 4071 :     }
; 4072 : }

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??$_Copy_memmove@PAPAXPAPAX@std@@YAPAPAXPAPAX00@Z ENDP	; std::_Copy_memmove<void * *,void * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 127  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 128  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 129  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00006	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]

; 130  :     if (_Block_size <= _Bytes) {

  00009	3b c8		 cmp	 ecx, eax
  0000b	0f 86 00 00 00
	00		 jbe	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length

; 79   :         return ::operator new(_Bytes);

  00011	51		 push	 ecx
  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 131  :         _Throw_bad_array_new_length(); // add overflow
; 132  :     }
; 133  : 
; 134  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00017	8b c8		 mov	 ecx, eax

; 79   :         return ::operator new(_Bytes);

  00019	83 c4 04	 add	 esp, 4

; 135  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0001c	85 c9		 test	 ecx, ecx
  0001e	74 0b		 je	 SHORT $LN7@Allocate_m

; 136  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  00020	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00023	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 137  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00026	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 138  : 
; 139  : #ifdef _DEBUG
; 140  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 141  : #endif // _DEBUG
; 142  :     return _Ptr;
; 143  : }

  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
$LN7@Allocate_m:

; 135  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0002b	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ??$_Find_lower_bound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
tv409 = -8						; size = 4
tv405 = -4						; size = 4
tv410 = 8						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
??$_Find_lower_bound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Find_lower_bound<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 1595 :     _Tree_find_result<_Nodeptr> _Find_lower_bound(const _Keyty& _Keyval) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1596 :         const auto _Scary = _Get_scary();
; 1597 :         _Tree_find_result<_Nodeptr> _Result{{_Scary->_Myhead->_Parent, _Tree_child::_Right}, _Scary->_Myhead};

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	83 ec 08	 sub	 esp, 8
  00008	53		 push	 ebx
  00009	8b 5d 08	 mov	 ebx, DWORD PTR ___$ReturnUdt$[ebp]
  0000c	57		 push	 edi
  0000d	8b 78 04	 mov	 edi, DWORD PTR [eax+4]
  00010	89 3b		 mov	 DWORD PTR [ebx], edi
  00012	c7 43 04 00 00
	00 00		 mov	 DWORD PTR [ebx+4], 0

; 1598 :         _Nodeptr _Trynode = _Result._Location._Parent;
; 1599 :         while (!_Trynode->_Isnil) {

  00019	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  0001d	89 43 08	 mov	 DWORD PTR [ebx+8], eax
  00020	0f 85 ab 00 00
	00		 jne	 $LN42@Find_lower
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2286 :         return _BUF_SIZE <= _Myres;

  00026	8b 45 0c	 mov	 eax, DWORD PTR __Keyval$[ebp]
  00029	56		 push	 esi
  0002a	8b 70 14	 mov	 esi, DWORD PTR [eax+20]

; 4380 :         return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

  0002d	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]

; 2286 :         return _BUF_SIZE <= _Myres;

  00030	89 75 f8	 mov	 DWORD PTR tv409[ebp], esi

; 4380 :         return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

  00033	89 4d 08	 mov	 DWORD PTR tv410[ebp], ecx
$LL2@Find_lower:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1600 :             _Result._Location._Parent = _Trynode;

  00036	89 3b		 mov	 DWORD PTR [ebx], edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2272 :         const value_type* _Result = _Bx._Buf;

  00038	8b d0		 mov	 edx, eax

; 2286 :         return _BUF_SIZE <= _Myres;

  0003a	83 fe 10	 cmp	 esi, 16			; 00000010H

; 2273 :         if (_Large_string_engaged()) {

  0003d	72 02		 jb	 SHORT $LN14@Find_lower

; 2274 :             _Result = _Unfancy(_Bx._Ptr);

  0003f	8b 10		 mov	 edx, DWORD PTR [eax]
$LN14@Find_lower:

; 2286 :         return _BUF_SIZE <= _Myres;

  00041	83 7f 24 10	 cmp	 DWORD PTR [edi+36], 16	; 00000010H

; 2272 :         const value_type* _Result = _Bx._Buf;

  00045	8d 47 10	 lea	 eax, DWORD PTR [edi+16]

; 2273 :         if (_Large_string_engaged()) {

  00048	72 03		 jb	 SHORT $LN19@Find_lower

; 2274 :             _Result = _Unfancy(_Bx._Ptr);

  0004a	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
$LN19@Find_lower:

; 4380 :         return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

  0004d	8b 4f 20	 mov	 ecx, DWORD PTR [edi+32]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 66   :     return _Right < _Left ? _Right : _Left;

  00050	8b f1		 mov	 esi, ecx
  00052	39 4d 08	 cmp	 DWORD PTR tv410[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4380 :         return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

  00055	89 4d fc	 mov	 DWORD PTR tv405[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 66   :     return _Right < _Left ? _Right : _Left;

  00058	0f 42 75 08	 cmovb	 esi, DWORD PTR tv410[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 384  :         return _CSTD memcmp(_First1, _First2, _Count);

  0005c	83 ee 04	 sub	 esi, 4
  0005f	72 11		 jb	 SHORT $LN38@Find_lower
$LL39@Find_lower:
  00061	8b 08		 mov	 ecx, DWORD PTR [eax]
  00063	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  00065	75 10		 jne	 SHORT $LN37@Find_lower
  00067	83 c0 04	 add	 eax, 4
  0006a	83 c2 04	 add	 edx, 4
  0006d	83 ee 04	 sub	 esi, 4
  00070	73 ef		 jae	 SHORT $LL39@Find_lower
$LN38@Find_lower:
  00072	83 fe fc	 cmp	 esi, -4			; fffffffcH
  00075	74 34		 je	 SHORT $LN36@Find_lower
$LN37@Find_lower:
  00077	8a 08		 mov	 cl, BYTE PTR [eax]
  00079	3a 0a		 cmp	 cl, BYTE PTR [edx]
  0007b	75 27		 jne	 SHORT $LN40@Find_lower
  0007d	83 fe fd	 cmp	 esi, -3			; fffffffdH
  00080	74 29		 je	 SHORT $LN36@Find_lower
  00082	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  00085	3a 4a 01	 cmp	 cl, BYTE PTR [edx+1]
  00088	75 1a		 jne	 SHORT $LN40@Find_lower
  0008a	83 fe fe	 cmp	 esi, -2			; fffffffeH
  0008d	74 1c		 je	 SHORT $LN36@Find_lower
  0008f	8a 48 02	 mov	 cl, BYTE PTR [eax+2]
  00092	3a 4a 02	 cmp	 cl, BYTE PTR [edx+2]
  00095	75 0d		 jne	 SHORT $LN40@Find_lower
  00097	83 fe ff	 cmp	 esi, -1
  0009a	74 0f		 je	 SHORT $LN36@Find_lower
  0009c	8a 40 03	 mov	 al, BYTE PTR [eax+3]
  0009f	3a 42 03	 cmp	 al, BYTE PTR [edx+3]
  000a2	74 07		 je	 SHORT $LN36@Find_lower
$LN40@Find_lower:
  000a4	1b c0		 sbb	 eax, eax
  000a6	83 c8 01	 or	 eax, 1
  000a9	eb 02		 jmp	 SHORT $LN41@Find_lower
$LN36@Find_lower:
  000ab	33 c0		 xor	 eax, eax
$LN41@Find_lower:

; 580  :     if (_Ans != 0) {

  000ad	85 c0		 test	 eax, eax
  000af	74 2a		 je	 SHORT $LN24@Find_lower
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1601 :             if (_DEBUG_LT_PRED(_Getcomp(), _Traits::_Kfn(_Trynode->_Myval), _Keyval)) {

  000b1	78 30		 js	 SHORT $LN35@Find_lower
$LN4@Find_lower:

; 1605 :                 _Result._Location._Child = _Tree_child::_Left;
; 1606 :                 _Result._Bound           = _Trynode;

  000b3	89 7b 08	 mov	 DWORD PTR [ebx+8], edi

; 1607 :                 _Trynode                 = _Trynode->_Left;

  000b6	b8 01 00 00 00	 mov	 eax, 1
  000bb	8b 3f		 mov	 edi, DWORD PTR [edi]
$LN5@Find_lower:

; 1598 :         _Nodeptr _Trynode = _Result._Location._Parent;
; 1599 :         while (!_Trynode->_Isnil) {

  000bd	8b 75 f8	 mov	 esi, DWORD PTR tv409[ebp]
  000c0	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  000c3	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  000c7	8b 45 0c	 mov	 eax, DWORD PTR __Keyval$[ebp]
  000ca	0f 84 66 ff ff
	ff		 je	 $LL2@Find_lower

; 1608 :             }
; 1609 :         }
; 1610 : 
; 1611 :         return _Result;

  000d0	5e		 pop	 esi
$LN42@Find_lower:
  000d1	5f		 pop	 edi

; 1612 :     }

  000d2	8b c3		 mov	 eax, ebx
  000d4	5b		 pop	 ebx
  000d5	8b e5		 mov	 esp, ebp
  000d7	5d		 pop	 ebp
  000d8	c2 08 00	 ret	 8
$LN24@Find_lower:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 584  :     if (_Left_size < _Right_size) {

  000db	8b 45 08	 mov	 eax, DWORD PTR tv410[ebp]
  000de	39 45 fc	 cmp	 DWORD PTR tv405[ebp], eax
  000e1	73 d0		 jae	 SHORT $LN4@Find_lower
$LN35@Find_lower:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1603 :                 _Trynode                 = _Trynode->_Right;

  000e3	8b 7f 08	 mov	 edi, DWORD PTR [edi+8]
  000e6	33 c0		 xor	 eax, eax

; 1604 :             } else {

  000e8	eb d3		 jmp	 SHORT $LN5@Find_lower
??$_Find_lower_bound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Find_lower_bound<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ??$_Find_lower_bound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@PAX@std@@@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
tv409 = -8						; size = 4
tv405 = -4						; size = 4
tv410 = 8						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
??$_Find_lower_bound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@PAX@std@@@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,CXScaleManagerImp::VERTBOX_INFO *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,CXScaleManagerImp::VERTBOX_INFO *> >,0> >::_Find_lower_bound<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 1595 :     _Tree_find_result<_Nodeptr> _Find_lower_bound(const _Keyty& _Keyval) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1596 :         const auto _Scary = _Get_scary();
; 1597 :         _Tree_find_result<_Nodeptr> _Result{{_Scary->_Myhead->_Parent, _Tree_child::_Right}, _Scary->_Myhead};

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	83 ec 08	 sub	 esp, 8
  00008	53		 push	 ebx
  00009	8b 5d 08	 mov	 ebx, DWORD PTR ___$ReturnUdt$[ebp]
  0000c	57		 push	 edi
  0000d	8b 78 04	 mov	 edi, DWORD PTR [eax+4]
  00010	89 3b		 mov	 DWORD PTR [ebx], edi
  00012	c7 43 04 00 00
	00 00		 mov	 DWORD PTR [ebx+4], 0

; 1598 :         _Nodeptr _Trynode = _Result._Location._Parent;
; 1599 :         while (!_Trynode->_Isnil) {

  00019	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  0001d	89 43 08	 mov	 DWORD PTR [ebx+8], eax
  00020	0f 85 ab 00 00
	00		 jne	 $LN42@Find_lower
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2286 :         return _BUF_SIZE <= _Myres;

  00026	8b 45 0c	 mov	 eax, DWORD PTR __Keyval$[ebp]
  00029	56		 push	 esi
  0002a	8b 70 14	 mov	 esi, DWORD PTR [eax+20]

; 4380 :         return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

  0002d	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]

; 2286 :         return _BUF_SIZE <= _Myres;

  00030	89 75 f8	 mov	 DWORD PTR tv409[ebp], esi

; 4380 :         return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

  00033	89 4d 08	 mov	 DWORD PTR tv410[ebp], ecx
$LL2@Find_lower:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1600 :             _Result._Location._Parent = _Trynode;

  00036	89 3b		 mov	 DWORD PTR [ebx], edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2272 :         const value_type* _Result = _Bx._Buf;

  00038	8b d0		 mov	 edx, eax

; 2286 :         return _BUF_SIZE <= _Myres;

  0003a	83 fe 10	 cmp	 esi, 16			; 00000010H

; 2273 :         if (_Large_string_engaged()) {

  0003d	72 02		 jb	 SHORT $LN14@Find_lower

; 2274 :             _Result = _Unfancy(_Bx._Ptr);

  0003f	8b 10		 mov	 edx, DWORD PTR [eax]
$LN14@Find_lower:

; 2286 :         return _BUF_SIZE <= _Myres;

  00041	83 7f 24 10	 cmp	 DWORD PTR [edi+36], 16	; 00000010H

; 2272 :         const value_type* _Result = _Bx._Buf;

  00045	8d 47 10	 lea	 eax, DWORD PTR [edi+16]

; 2273 :         if (_Large_string_engaged()) {

  00048	72 03		 jb	 SHORT $LN19@Find_lower

; 2274 :             _Result = _Unfancy(_Bx._Ptr);

  0004a	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
$LN19@Find_lower:

; 4380 :         return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

  0004d	8b 4f 20	 mov	 ecx, DWORD PTR [edi+32]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 66   :     return _Right < _Left ? _Right : _Left;

  00050	8b f1		 mov	 esi, ecx
  00052	39 4d 08	 cmp	 DWORD PTR tv410[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4380 :         return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

  00055	89 4d fc	 mov	 DWORD PTR tv405[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 66   :     return _Right < _Left ? _Right : _Left;

  00058	0f 42 75 08	 cmovb	 esi, DWORD PTR tv410[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 384  :         return _CSTD memcmp(_First1, _First2, _Count);

  0005c	83 ee 04	 sub	 esi, 4
  0005f	72 11		 jb	 SHORT $LN38@Find_lower
$LL39@Find_lower:
  00061	8b 08		 mov	 ecx, DWORD PTR [eax]
  00063	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  00065	75 10		 jne	 SHORT $LN37@Find_lower
  00067	83 c0 04	 add	 eax, 4
  0006a	83 c2 04	 add	 edx, 4
  0006d	83 ee 04	 sub	 esi, 4
  00070	73 ef		 jae	 SHORT $LL39@Find_lower
$LN38@Find_lower:
  00072	83 fe fc	 cmp	 esi, -4			; fffffffcH
  00075	74 34		 je	 SHORT $LN36@Find_lower
$LN37@Find_lower:
  00077	8a 08		 mov	 cl, BYTE PTR [eax]
  00079	3a 0a		 cmp	 cl, BYTE PTR [edx]
  0007b	75 27		 jne	 SHORT $LN40@Find_lower
  0007d	83 fe fd	 cmp	 esi, -3			; fffffffdH
  00080	74 29		 je	 SHORT $LN36@Find_lower
  00082	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  00085	3a 4a 01	 cmp	 cl, BYTE PTR [edx+1]
  00088	75 1a		 jne	 SHORT $LN40@Find_lower
  0008a	83 fe fe	 cmp	 esi, -2			; fffffffeH
  0008d	74 1c		 je	 SHORT $LN36@Find_lower
  0008f	8a 48 02	 mov	 cl, BYTE PTR [eax+2]
  00092	3a 4a 02	 cmp	 cl, BYTE PTR [edx+2]
  00095	75 0d		 jne	 SHORT $LN40@Find_lower
  00097	83 fe ff	 cmp	 esi, -1
  0009a	74 0f		 je	 SHORT $LN36@Find_lower
  0009c	8a 40 03	 mov	 al, BYTE PTR [eax+3]
  0009f	3a 42 03	 cmp	 al, BYTE PTR [edx+3]
  000a2	74 07		 je	 SHORT $LN36@Find_lower
$LN40@Find_lower:
  000a4	1b c0		 sbb	 eax, eax
  000a6	83 c8 01	 or	 eax, 1
  000a9	eb 02		 jmp	 SHORT $LN41@Find_lower
$LN36@Find_lower:
  000ab	33 c0		 xor	 eax, eax
$LN41@Find_lower:

; 580  :     if (_Ans != 0) {

  000ad	85 c0		 test	 eax, eax
  000af	74 2a		 je	 SHORT $LN24@Find_lower
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1601 :             if (_DEBUG_LT_PRED(_Getcomp(), _Traits::_Kfn(_Trynode->_Myval), _Keyval)) {

  000b1	78 30		 js	 SHORT $LN35@Find_lower
$LN4@Find_lower:

; 1605 :                 _Result._Location._Child = _Tree_child::_Left;
; 1606 :                 _Result._Bound           = _Trynode;

  000b3	89 7b 08	 mov	 DWORD PTR [ebx+8], edi

; 1607 :                 _Trynode                 = _Trynode->_Left;

  000b6	b8 01 00 00 00	 mov	 eax, 1
  000bb	8b 3f		 mov	 edi, DWORD PTR [edi]
$LN5@Find_lower:

; 1598 :         _Nodeptr _Trynode = _Result._Location._Parent;
; 1599 :         while (!_Trynode->_Isnil) {

  000bd	8b 75 f8	 mov	 esi, DWORD PTR tv409[ebp]
  000c0	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  000c3	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  000c7	8b 45 0c	 mov	 eax, DWORD PTR __Keyval$[ebp]
  000ca	0f 84 66 ff ff
	ff		 je	 $LL2@Find_lower

; 1608 :             }
; 1609 :         }
; 1610 : 
; 1611 :         return _Result;

  000d0	5e		 pop	 esi
$LN42@Find_lower:
  000d1	5f		 pop	 edi

; 1612 :     }

  000d2	8b c3		 mov	 eax, ebx
  000d4	5b		 pop	 ebx
  000d5	8b e5		 mov	 esp, ebp
  000d7	5d		 pop	 ebp
  000d8	c2 08 00	 ret	 8
$LN24@Find_lower:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 584  :     if (_Left_size < _Right_size) {

  000db	8b 45 08	 mov	 eax, DWORD PTR tv410[ebp]
  000de	39 45 fc	 cmp	 DWORD PTR tv405[ebp], eax
  000e1	73 d0		 jae	 SHORT $LN4@Find_lower
$LN35@Find_lower:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1603 :                 _Trynode                 = _Trynode->_Right;

  000e3	8b 7f 08	 mov	 edi, DWORD PTR [edi+8]
  000e6	33 c0		 xor	 eax, eax

; 1604 :             } else {

  000e8	eb d3		 jmp	 SHORT $LN5@Find_lower
??$_Find_lower_bound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@PAX@std@@@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,CXScaleManagerImp::VERTBOX_INFO *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,CXScaleManagerImp::VERTBOX_INFO *> >,0> >::_Find_lower_bound<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_reallocate@ABQAX@?$vector@PAXV?$allocator@PAX@std@@@std@@QAEPAPAXQAPAXABQAX@Z
_TEXT	SEGMENT
__Newsize$1$ = -8					; size = 4
tv710 = -4						; size = 4
__Whereoff$1$ = -4					; size = 4
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@ABQAX@?$vector@PAXV?$allocator@PAX@std@@@std@@QAEPAPAXQAPAXABQAX@Z PROC ; std::vector<void *,std::allocator<void *> >::_Emplace_reallocate<void * const &>, COMDAT
; _this$ = ecx

; 752  :     _CONSTEXPR20_CONTAINER pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 753  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 754  :         _Alty& _Al        = _Getal();
; 755  :         auto& _My_data    = _Mypair._Myval2;
; 756  :         pointer& _Myfirst = _My_data._Myfirst;
; 757  :         pointer& _Mylast  = _My_data._Mylast;
; 758  : 
; 759  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 760  : 
; 761  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00006	8b 45 08	 mov	 eax, DWORD PTR __Whereptr$[ebp]
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b f9		 mov	 edi, ecx
  0000e	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00010	2b c1		 sub	 eax, ecx
  00012	c1 f8 02	 sar	 eax, 2
  00015	89 45 fc	 mov	 DWORD PTR __Whereoff$1$[ebp], eax

; 762  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00018	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0001b	2b c1		 sub	 eax, ecx
  0001d	c1 f8 02	 sar	 eax, 2

; 763  : 
; 764  :         if (_Oldsize == max_size()) {

  00020	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00025	0f 84 24 01 00
	00		 je	 $LN117@Emplace_re

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0002b	8b 57 08	 mov	 edx, DWORD PTR [edi+8]

; 766  :         }
; 767  : 
; 768  :         const size_type _Newsize     = _Oldsize + 1;

  0002e	8d 70 01	 lea	 esi, DWORD PTR [eax+1]

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00031	2b d1		 sub	 edx, ecx

; 766  :         }
; 767  : 
; 768  :         const size_type _Newsize     = _Oldsize + 1;

  00033	89 75 f8	 mov	 DWORD PTR __Newsize$1$[ebp], esi

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00036	c1 fa 02	 sar	 edx, 2

; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  00039	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH
  0003e	8b ca		 mov	 ecx, edx
  00040	d1 e9		 shr	 ecx, 1
  00042	2b c1		 sub	 eax, ecx
  00044	3b d0		 cmp	 edx, eax
  00046	0f 87 fe 00 00
	00		 ja	 $LN114@Emplace_re

; 1676 :             return _Max; // geometric growth would overflow
; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  0004c	8d 04 11	 lea	 eax, DWORD PTR [ecx+edx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 60   :         if (_Count > _Max_possible) {

  0004f	8b de		 mov	 ebx, esi
  00051	3b c6		 cmp	 eax, esi
  00053	0f 43 d8	 cmovae	 ebx, eax
  00056	81 fb ff ff ff
	3f		 cmp	 ebx, 1073741823		; 3fffffffH
  0005c	0f 87 e8 00 00
	00		 ja	 $LN114@Emplace_re

; 61   :             _Throw_bad_array_new_length(); // multiply overflow
; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00062	c1 e3 02	 shl	 ebx, 2

; 228  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00065	81 fb 00 10 00
	00		 cmp	 ebx, 4096		; 00001000H
  0006b	72 27		 jb	 SHORT $LN24@Emplace_re

; 129  :     const size_t _Block_size = _Non_user_size + _Bytes;

  0006d	8d 43 23	 lea	 eax, DWORD PTR [ebx+35]

; 130  :     if (_Block_size <= _Bytes) {

  00070	3b c3		 cmp	 eax, ebx
  00072	0f 86 d2 00 00
	00		 jbe	 $LN114@Emplace_re

; 79   :         return ::operator new(_Bytes);

  00078	50		 push	 eax
  00079	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0007e	83 c4 04	 add	 esp, 4

; 135  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  00081	85 c0		 test	 eax, eax
  00083	0f 84 bb 00 00
	00		 je	 $LN105@Emplace_re

; 136  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  00089	8d 70 23	 lea	 esi, DWORD PTR [eax+35]
  0008c	83 e6 e0	 and	 esi, -32		; ffffffe0H

; 137  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  0008f	89 46 fc	 mov	 DWORD PTR [esi-4], eax

; 229  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00092	eb 13		 jmp	 SHORT $LN23@Emplace_re
$LN24@Emplace_re:

; 230  :         }
; 231  :     }
; 232  : #endif // defined(_M_IX86) || defined(_M_X64)
; 233  : 
; 234  :     if (_Bytes != 0) {

  00094	85 db		 test	 ebx, ebx
  00096	74 0d		 je	 SHORT $LN25@Emplace_re

; 79   :         return ::operator new(_Bytes);

  00098	53		 push	 ebx
  00099	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0009e	83 c4 04	 add	 esp, 4

; 235  :         return _Traits::_Allocate(_Bytes);

  000a1	8b f0		 mov	 esi, eax
  000a3	eb 02		 jmp	 SHORT $LN23@Emplace_re
$LN25@Emplace_re:

; 236  :     }
; 237  : 
; 238  :     return nullptr;

  000a5	33 f6		 xor	 esi, esi
$LN23@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 776  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  000a7	8b 45 fc	 mov	 eax, DWORD PTR __Whereoff$1$[ebp]

; 777  :         _Constructed_first = _Newvec + _Whereoff;
; 778  : 
; 779  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  000aa	8b 55 08	 mov	 edx, DWORD PTR __Whereptr$[ebp]
  000ad	8d 0c 86	 lea	 ecx, DWORD PTR [esi+eax*4]
  000b0	8b 45 0c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  000b3	89 4d fc	 mov	 DWORD PTR tv710[ebp], ecx
  000b6	8b 00		 mov	 eax, DWORD PTR [eax]
  000b8	89 01		 mov	 DWORD PTR [ecx], eax
  000ba	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  000bd	8b 0f		 mov	 ecx, DWORD PTR [edi]
  000bf	3b d0		 cmp	 edx, eax
  000c1	75 0f		 jne	 SHORT $LN4@Emplace_re
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4065 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  000c3	2b c1		 sub	 eax, ecx

; 4066 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  000c5	50		 push	 eax
  000c6	51		 push	 ecx
  000c7	56		 push	 esi
  000c8	e8 00 00 00 00	 call	 _memmove
  000cd	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 781  :         } else { // provide basic guarantee

  000d0	eb 23		 jmp	 SHORT $LN78@Emplace_re
$LN4@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4065 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  000d2	2b d1		 sub	 edx, ecx

; 4066 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  000d4	52		 push	 edx
  000d5	51		 push	 ecx
  000d6	56		 push	 esi
  000d7	e8 00 00 00 00	 call	 _memmove

; 4065 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  000dc	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  000df	8b 4d 08	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  000e2	2b c1		 sub	 eax, ecx

; 4066 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  000e4	50		 push	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 784  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  000e5	8b 45 fc	 mov	 eax, DWORD PTR tv710[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4066 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  000e8	51		 push	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 784  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  000e9	83 c0 04	 add	 eax, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4066 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  000ec	50		 push	 eax
  000ed	e8 00 00 00 00	 call	 _memmove
  000f2	83 c4 18	 add	 esp, 24			; 00000018H
$LN78@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1732 :         if (_Myfirst) { // destroy and deallocate old array

  000f5	8b 07		 mov	 eax, DWORD PTR [edi]
  000f7	85 c0		 test	 eax, eax
  000f9	74 2c		 je	 SHORT $LN98@Emplace_re

; 1733 :             _Destroy(_Myfirst, _Mylast);
; 1734 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  000fb	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  000fe	2b c8		 sub	 ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00100	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00103	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00109	72 12		 jb	 SHORT $LN108@Emplace_re

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0010b	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0010e	83 c1 23	 add	 ecx, 35			; 00000023H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00111	2b c2		 sub	 eax, edx

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00113	83 c0 fc	 add	 eax, -4			; fffffffcH
  00116	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00119	77 29		 ja	 SHORT $LN105@Emplace_re

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0011b	8b c2		 mov	 eax, edx
$LN108@Emplace_re:

; 255  :         ::operator delete(_Ptr, _Bytes);

  0011d	51		 push	 ecx
  0011e	50		 push	 eax
  0011f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00124	83 c4 08	 add	 esp, 8
$LN98@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1738 :         _Mylast  = _Newvec + _Newsize;

  00127	8b 45 f8	 mov	 eax, DWORD PTR __Newsize$1$[ebp]
  0012a	89 37		 mov	 DWORD PTR [edi], esi
  0012c	8d 0c 86	 lea	 ecx, DWORD PTR [esi+eax*4]

; 785  :         }
; 786  :         _CATCH_ALL
; 787  :         _Destroy(_Constructed_first, _Constructed_last);
; 788  :         _Al.deallocate(_Newvec, _Newcapacity);
; 789  :         _RERAISE;
; 790  :         _CATCH_END
; 791  : 
; 792  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 793  :         return _Newvec + _Whereoff;

  0012f	8b 45 fc	 mov	 eax, DWORD PTR tv710[ebp]

; 1738 :         _Mylast  = _Newvec + _Newsize;

  00132	89 4f 04	 mov	 DWORD PTR [edi+4], ecx

; 1739 :         _Myend   = _Newvec + _Newcapacity;

  00135	8d 0c 33	 lea	 ecx, DWORD PTR [ebx+esi]
  00138	89 4f 08	 mov	 DWORD PTR [edi+8], ecx

; 785  :         }
; 786  :         _CATCH_ALL
; 787  :         _Destroy(_Constructed_first, _Constructed_last);
; 788  :         _Al.deallocate(_Newvec, _Newcapacity);
; 789  :         _RERAISE;
; 790  :         _CATCH_END
; 791  : 
; 792  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 793  :         return _Newvec + _Whereoff;

  0013b	5f		 pop	 edi
  0013c	5e		 pop	 esi
  0013d	5b		 pop	 ebx

; 794  :     }

  0013e	8b e5		 mov	 esp, ebp
  00140	5d		 pop	 ebp
  00141	c2 08 00	 ret	 8
$LN105@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00144	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN114@Emplace_re:

; 131  :         _Throw_bad_array_new_length(); // add overflow

  0014a	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN117@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 765  :             _Xlength();

  0014f	e8 00 00 00 00	 call	 ?_Xlength@?$vector@PAXV?$allocator@PAX@std@@@std@@CAXXZ ; std::vector<void *,std::allocator<void *> >::_Xlength
$LN115@Emplace_re:
  00154	cc		 int	 3
??$_Emplace_reallocate@ABQAX@?$vector@PAXV?$allocator@PAX@std@@@std@@QAEPAPAXQAPAXABQAX@Z ENDP ; std::vector<void *,std::allocator<void *> >::_Emplace_reallocate<void * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
__Al$ = 8						; size = 4
__Rootnode$ = 12					; size = 4
??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> > >, COMDAT
; _this$ = ecx

; 742  :     void _Erase_tree(_Alnode& _Al, _Nodeptr _Rootnode) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	57		 push	 edi

; 743  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

  00005	8b 7d 0c	 mov	 edi, DWORD PTR __Rootnode$[ebp]
  00008	8b c1		 mov	 eax, ecx
  0000a	89 45 fc	 mov	 DWORD PTR _this$1$[ebp], eax
  0000d	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  00011	75 74		 jne	 SHORT $LN73@Erase_tree
  00013	53		 push	 ebx
  00014	8b 5d 08	 mov	 ebx, DWORD PTR __Al$[ebp]
  00017	56		 push	 esi
$LL2@Erase_tree:

; 744  :             _Erase_tree(_Al, _Rootnode->_Right);

  00018	ff 77 08	 push	 DWORD PTR [edi+8]
  0001b	8b c8		 mov	 ecx, eax
  0001d	53		 push	 ebx
  0001e	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> > >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 602  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  00023	8b f7		 mov	 esi, edi

; 603  :     _Val         = static_cast<_Other&&>(_New_val);

  00025	8b 3f		 mov	 edi, DWORD PTR [edi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2286 :         return _BUF_SIZE <= _Myres;

  00027	8b 4e 24	 mov	 ecx, DWORD PTR [esi+36]
  0002a	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 4584 :         if (_Mypair._Myval2._Large_string_engaged()) {

  0002d	72 28		 jb	 SHORT $LN29@Erase_tree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0002f	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4588 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00032	41		 inc	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00033	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00039	72 12		 jb	 SHORT $LN39@Erase_tree

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0003b	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0003e	83 c1 23	 add	 ecx, 35			; 00000023H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00041	2b c2		 sub	 eax, edx

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00043	83 c0 fc	 add	 eax, -4			; fffffffcH
  00046	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00049	77 34		 ja	 SHORT $LN36@Erase_tree

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0004b	8b c2		 mov	 eax, edx
$LN39@Erase_tree:

; 255  :         ::operator delete(_Ptr, _Bytes);

  0004d	51		 push	 ecx
  0004e	50		 push	 eax
  0004f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00054	83 c4 08	 add	 esp, 8
$LN29@Erase_tree:
  00057	6a 2c		 push	 44			; 0000002cH
  00059	56		 push	 esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4599 :             _Mypair._Myval2._Mysize = 0;

  0005a	c7 46 20 00 00
	00 00		 mov	 DWORD PTR [esi+32], 0

; 4600 :             _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00061	c7 46 24 0f 00
	00 00		 mov	 DWORD PTR [esi+36], 15	; 0000000fH

; 4601 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4602 :             _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00068	c6 46 10 00	 mov	 BYTE PTR [esi+16], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 255  :         ::operator delete(_Ptr, _Bytes);

  0006c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00071	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 743  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

  00074	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  00078	75 0b		 jne	 SHORT $LN75@Erase_tree
  0007a	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]
  0007d	eb 99		 jmp	 SHORT $LL2@Erase_tree
$LN36@Erase_tree:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0007f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN75@Erase_tree:
  00085	5e		 pop	 esi
  00086	5b		 pop	 ebx
$LN73@Erase_tree:
  00087	5f		 pop	 edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 747  :     }

  00088	8b e5		 mov	 esp, ebp
  0008a	5d		 pop	 ebp
  0008b	c2 08 00	 ret	 8
$LN76@Erase_tree:
??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@PAX@1@@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
__Al$ = 8						; size = 4
__Rootnode$ = 12					; size = 4
??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@PAX@1@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,CXScaleManagerImp::VERTBOX_INFO *> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,CXScaleManagerImp::VERTBOX_INFO *>,void *> > >, COMDAT
; _this$ = ecx

; 742  :     void _Erase_tree(_Alnode& _Al, _Nodeptr _Rootnode) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	57		 push	 edi

; 743  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

  00005	8b 7d 0c	 mov	 edi, DWORD PTR __Rootnode$[ebp]
  00008	8b c1		 mov	 eax, ecx
  0000a	89 45 fc	 mov	 DWORD PTR _this$1$[ebp], eax
  0000d	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  00011	75 74		 jne	 SHORT $LN73@Erase_tree
  00013	53		 push	 ebx
  00014	8b 5d 08	 mov	 ebx, DWORD PTR __Al$[ebp]
  00017	56		 push	 esi
$LL2@Erase_tree:

; 744  :             _Erase_tree(_Al, _Rootnode->_Right);

  00018	ff 77 08	 push	 DWORD PTR [edi+8]
  0001b	8b c8		 mov	 ecx, eax
  0001d	53		 push	 ebx
  0001e	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,CXScaleManagerImp::VERTBOX_INFO *> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,CXScaleManagerImp::VERTBOX_INFO *>,void *> > >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 602  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  00023	8b f7		 mov	 esi, edi

; 603  :     _Val         = static_cast<_Other&&>(_New_val);

  00025	8b 3f		 mov	 edi, DWORD PTR [edi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2286 :         return _BUF_SIZE <= _Myres;

  00027	8b 4e 24	 mov	 ecx, DWORD PTR [esi+36]
  0002a	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 4584 :         if (_Mypair._Myval2._Large_string_engaged()) {

  0002d	72 28		 jb	 SHORT $LN29@Erase_tree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0002f	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4588 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00032	41		 inc	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00033	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00039	72 12		 jb	 SHORT $LN39@Erase_tree

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0003b	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0003e	83 c1 23	 add	 ecx, 35			; 00000023H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00041	2b c2		 sub	 eax, edx

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00043	83 c0 fc	 add	 eax, -4			; fffffffcH
  00046	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00049	77 34		 ja	 SHORT $LN36@Erase_tree

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0004b	8b c2		 mov	 eax, edx
$LN39@Erase_tree:

; 255  :         ::operator delete(_Ptr, _Bytes);

  0004d	51		 push	 ecx
  0004e	50		 push	 eax
  0004f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00054	83 c4 08	 add	 esp, 8
$LN29@Erase_tree:
  00057	6a 2c		 push	 44			; 0000002cH
  00059	56		 push	 esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4599 :             _Mypair._Myval2._Mysize = 0;

  0005a	c7 46 20 00 00
	00 00		 mov	 DWORD PTR [esi+32], 0

; 4600 :             _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00061	c7 46 24 0f 00
	00 00		 mov	 DWORD PTR [esi+36], 15	; 0000000fH

; 4601 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4602 :             _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00068	c6 46 10 00	 mov	 BYTE PTR [esi+16], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 255  :         ::operator delete(_Ptr, _Bytes);

  0006c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00071	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 743  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

  00074	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  00078	75 0b		 jne	 SHORT $LN75@Erase_tree
  0007a	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]
  0007d	eb 99		 jmp	 SHORT $LL2@Erase_tree
$LN36@Erase_tree:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0007f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN75@Erase_tree:
  00085	5e		 pop	 esi
  00086	5b		 pop	 ebx
$LN73@Erase_tree:
  00087	5f		 pop	 edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 747  :     }

  00088	8b e5		 mov	 esp, ebp
  0008a	5d		 pop	 ebp
  0008b	c2 08 00	 ret	 8
$LN76@Erase_tree:
??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@PAX@1@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,CXScaleManagerImp::VERTBOX_INFO *> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,CXScaleManagerImp::VERTBOX_INFO *>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@QAE@XZ PROC ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,CXScaleManagerImp::VERTBOX_INFO *>::~pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,CXScaleManagerImp::VERTBOX_INFO *>, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2286 :         return _BUF_SIZE <= _Myres;

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00006	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 4584 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00009	72 27		 jb	 SHORT $LN15@pair
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000b	8b 06		 mov	 eax, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4588 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0000d	41		 inc	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0000e	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00014	72 12		 jb	 SHORT $LN25@pair

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00016	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00019	83 c1 23	 add	 ecx, 35			; 00000023H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001c	2b c2		 sub	 eax, edx

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0001e	83 c0 fc	 add	 eax, -4			; fffffffcH
  00021	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00024	77 1f		 ja	 SHORT $LN22@pair

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00026	8b c2		 mov	 eax, edx
$LN25@pair:

; 255  :         ::operator delete(_Ptr, _Bytes);

  00028	51		 push	 ecx
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	83 c4 08	 add	 esp, 8
$LN15@pair:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4599 :             _Mypair._Myval2._Mysize = 0;

  00032	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 4600 :             _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00039	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 4601 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4602 :             _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00040	c6 06 00	 mov	 BYTE PTR [esi], 0
  00043	5e		 pop	 esi
  00044	c3		 ret	 0
$LN22@pair:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00045	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN31@pair:
  0004b	cc		 int	 3
??1?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@QAE@XZ ENDP ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,CXScaleManagerImp::VERTBOX_INFO *>::~pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,CXScaleManagerImp::VERTBOX_INFO *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ?SetAtGrow@?$CArray@HH@@QAEXHH@Z
_TEXT	SEGMENT
_nIndex$ = 8						; size = 4
_newElement$ = 12					; size = 4
?SetAtGrow@?$CArray@HH@@QAEXHH@Z PROC			; CArray<int,int>::SetAtGrow, COMDAT
; _this$ = ecx

; 534  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 535  : 	ASSERT_VALID(this);
; 536  : 	ASSERT(nIndex >= 0);
; 537  : 
; 538  : 	if(nIndex < 0)

  00004	8b 75 08	 mov	 esi, DWORD PTR _nIndex$[ebp]
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
  0000a	85 f6		 test	 esi, esi
  0000c	78 1f		 js	 SHORT $LN7@SetAtGrow

; 540  : 
; 541  : 	if (nIndex >= m_nSize)

  0000e	3b 77 08	 cmp	 esi, DWORD PTR [edi+8]
  00011	7c 0b		 jl	 SHORT $LN3@SetAtGrow

; 542  : 		SetSize(nIndex+1, -1);

  00013	6a ff		 push	 -1
  00015	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ?SetSize@?$CArray@HH@@QAEXHH@Z ; CArray<int,int>::SetSize
$LN3@SetAtGrow:

; 543  : 	m_pData[nIndex] = newElement;

  0001e	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00021	8b 45 0c	 mov	 eax, DWORD PTR _newElement$[ebp]
  00024	5f		 pop	 edi
  00025	89 04 b1	 mov	 DWORD PTR [ecx+esi*4], eax
  00028	5e		 pop	 esi

; 544  : }

  00029	5d		 pop	 ebp
  0002a	c2 08 00	 ret	 8
$LN7@SetAtGrow:

; 539  : 		AfxThrowInvalidArgException();

  0002d	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN5@SetAtGrow:
  00032	cc		 int	 3
?SetAtGrow@?$CArray@HH@@QAEXHH@Z ENDP			; CArray<int,int>::SetAtGrow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_memcpy_s.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_memcpy_s.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ?SetSize@?$CArray@HH@@QAEXHH@Z
_TEXT	SEGMENT
__N$1$ = -8						; size = 4
__S1max$1$ = -4						; size = 4
__S2$1$ = 8						; size = 4
_nNewSize$ = 8						; size = 4
_pNewData$1$ = 12					; size = 4
_nGrowBy$ = 12						; size = 4
?SetSize@?$CArray@HH@@QAEXHH@Z PROC			; CArray<int,int>::SetSize, COMDAT
; _this$ = ecx

; 368  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 369  : 	ASSERT_VALID(this);
; 370  : 	ASSERT(nNewSize >= 0);
; 371  : 
; 372  : 	if(nNewSize < 0 )

  00008	8b 75 08	 mov	 esi, DWORD PTR _nNewSize$[ebp]
  0000b	8b d9		 mov	 ebx, ecx
  0000d	57		 push	 edi
  0000e	85 f6		 test	 esi, esi
  00010	0f 88 9a 01 00
	00		 js	 $LN56@SetSize

; 373  : 		AfxThrowInvalidArgException();
; 374  : 
; 375  : 	if (nGrowBy >= 0)

  00016	8b 45 0c	 mov	 eax, DWORD PTR _nGrowBy$[ebp]
  00019	85 c0		 test	 eax, eax
  0001b	78 03		 js	 SHORT $LN82@SetSize

; 376  : 		m_nGrowBy = nGrowBy;  // set new size

  0001d	89 43 10	 mov	 DWORD PTR [ebx+16], eax
$LN82@SetSize:

; 377  : 
; 378  : 	if (nNewSize == 0)

  00020	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00023	85 f6		 test	 esi, esi
  00025	75 27		 jne	 SHORT $LN19@SetSize

; 379  : 	{
; 380  : 		// shrink to nothing
; 381  : 		if (m_pData != NULL)

  00027	85 c9		 test	 ecx, ecx
  00029	74 0c		 je	 SHORT $LN21@SetSize

; 382  : 		{
; 383  : 			for( int i = 0; i < m_nSize; i++ )
; 384  : 				(m_pData + i)->~TYPE();
; 385  : 			delete[] (BYTE*)m_pData;

  0002b	51		 push	 ecx
  0002c	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00031	83 c4 04	 add	 esp, 4

; 386  : 			m_pData = NULL;

  00034	89 73 04	 mov	 DWORD PTR [ebx+4], esi
$LN21@SetSize:

; 475  : }

  00037	5f		 pop	 edi
  00038	5e		 pop	 esi
  00039	c7 43 0c 00 00
	00 00		 mov	 DWORD PTR [ebx+12], 0
  00040	c7 43 08 00 00
	00 00		 mov	 DWORD PTR [ebx+8], 0
  00047	5b		 pop	 ebx
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c2 08 00	 ret	 8
$LN19@SetSize:

; 387  : 		}
; 388  : 		m_nSize = m_nMaxSize = 0;
; 389  : 	}
; 390  : 	else if (m_pData == NULL)

  0004e	85 c9		 test	 ecx, ecx
  00050	75 36		 jne	 SHORT $LN22@SetSize

; 391  : 	{
; 392  : 		// create buffer big enough to hold number of requested elements or
; 393  : 		// m_nGrowBy elements, whichever is larger.
; 394  : #ifdef SIZE_T_MAX
; 395  : 		ASSERT(nNewSize <= SIZE_T_MAX/sizeof(TYPE));    // no overflow
; 396  : #endif
; 397  : 		size_t nAllocSize = __max(nNewSize, m_nGrowBy);

  00052	8b 7b 10	 mov	 edi, DWORD PTR [ebx+16]
  00055	3b f7		 cmp	 esi, edi
  00057	0f 4f fe	 cmovg	 edi, esi

; 398  : 		m_pData = (TYPE*) new BYTE[(size_t)nAllocSize * sizeof(TYPE)];

  0005a	8d 34 bd 00 00
	00 00		 lea	 esi, DWORD PTR [edi*4]
  00061	56		 push	 esi
  00062	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]

; 399  : 		memset((void*)m_pData, 0, (size_t)nAllocSize * sizeof(TYPE));

  00067	56		 push	 esi
  00068	6a 00		 push	 0
  0006a	50		 push	 eax
  0006b	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  0006e	e8 00 00 00 00	 call	 _memset

; 400  : 		for( int i = 0; i < nNewSize; i++ )
; 401  : #pragma push_macro("new")
; 402  : #undef new
; 403  : 			::new( (void*)( m_pData + i ) ) TYPE;
; 404  : #pragma pop_macro("new")
; 405  : 		m_nSize = nNewSize;

  00073	8b 45 08	 mov	 eax, DWORD PTR _nNewSize$[ebp]
  00076	83 c4 10	 add	 esp, 16			; 00000010H

; 475  : }

  00079	89 7b 0c	 mov	 DWORD PTR [ebx+12], edi
  0007c	89 43 08	 mov	 DWORD PTR [ebx+8], eax
  0007f	5f		 pop	 edi
  00080	5e		 pop	 esi
  00081	5b		 pop	 ebx
  00082	8b e5		 mov	 esp, ebp
  00084	5d		 pop	 ebp
  00085	c2 08 00	 ret	 8
$LN22@SetSize:

; 406  : 		m_nMaxSize = nAllocSize;
; 407  : 	}
; 408  : 	else if (nNewSize <= m_nMaxSize)

  00088	8b 7b 0c	 mov	 edi, DWORD PTR [ebx+12]
  0008b	3b f7		 cmp	 esi, edi
  0008d	7f 29		 jg	 SHORT $LN24@SetSize

; 409  : 	{
; 410  : 		// it fits
; 411  : 		if (nNewSize > m_nSize)

  0008f	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]
  00092	3b f2		 cmp	 esi, edx
  00094	7e 16		 jle	 SHORT $LN26@SetSize

; 412  : 		{
; 413  : 			// initialize the new elements
; 414  : 			memset((void*)(m_pData + m_nSize), 0, (size_t)(nNewSize-m_nSize) * sizeof(TYPE));

  00096	8b c6		 mov	 eax, esi
  00098	2b c2		 sub	 eax, edx
  0009a	c1 e0 02	 shl	 eax, 2
  0009d	50		 push	 eax
  0009e	8d 04 91	 lea	 eax, DWORD PTR [ecx+edx*4]
  000a1	6a 00		 push	 0
  000a3	50		 push	 eax
  000a4	e8 00 00 00 00	 call	 _memset
  000a9	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN26@SetSize:

; 415  : 			for( int i = 0; i < nNewSize-m_nSize; i++ )
; 416  : #pragma push_macro("new")
; 417  : #undef new
; 418  : 				::new( (void*)( m_pData + m_nSize + i ) ) TYPE;
; 419  : #pragma pop_macro("new")
; 420  : 		}
; 421  : 		else if (m_nSize > nNewSize)
; 422  : 		{
; 423  : 			// destroy the old elements
; 424  : 			for( int i = 0; i < m_nSize-nNewSize; i++ )
; 425  : 				(m_pData + nNewSize + i)->~TYPE();
; 426  : 		}
; 427  : 		m_nSize = nNewSize;

  000ac	5f		 pop	 edi
  000ad	89 73 08	 mov	 DWORD PTR [ebx+8], esi

; 475  : }

  000b0	5e		 pop	 esi
  000b1	5b		 pop	 ebx
  000b2	8b e5		 mov	 esp, ebp
  000b4	5d		 pop	 ebp
  000b5	c2 08 00	 ret	 8
$LN24@SetSize:

; 428  : 	}
; 429  : 	else
; 430  : 	{
; 431  : 		// otherwise, grow array
; 432  : 		nGrowBy = m_nGrowBy;

  000b8	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]

; 433  : 		if (nGrowBy == 0)

  000bb	85 c0		 test	 eax, eax
  000bd	75 22		 jne	 SHORT $LN37@SetSize

; 434  : 		{
; 435  : 			// heuristically determine growth when nGrowBy == 0
; 436  : 			//  (this avoids heap fragmentation in many situations)
; 437  : 			nGrowBy = m_nSize / 8;

  000bf	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  000c2	99		 cdq
  000c3	83 e2 07	 and	 edx, 7
  000c6	03 c2		 add	 eax, edx
  000c8	c1 f8 03	 sar	 eax, 3

; 438  : 			nGrowBy = (nGrowBy < 4) ? 4 : ((nGrowBy > 1024) ? 1024 : nGrowBy);

  000cb	83 f8 04	 cmp	 eax, 4
  000ce	7d 07		 jge	 SHORT $LN36@SetSize
  000d0	b8 04 00 00 00	 mov	 eax, 4
  000d5	eb 0a		 jmp	 SHORT $LN37@SetSize
$LN36@SetSize:
  000d7	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  000dc	3b c1		 cmp	 eax, ecx
  000de	0f 4f c1	 cmovg	 eax, ecx
$LN37@SetSize:

; 439  : 		}
; 440  : 		INT_PTR nNewMax;
; 441  : 		if (nNewSize < m_nMaxSize + nGrowBy)

  000e1	03 f8		 add	 edi, eax
  000e3	3b f7		 cmp	 esi, edi
  000e5	7d 0b		 jge	 SHORT $LN30@SetSize

; 445  : 
; 446  : 		ASSERT(nNewMax >= m_nMaxSize);  // no wrap around
; 447  : 
; 448  : 		if(nNewMax  < m_nMaxSize)

  000e7	3b 7b 0c	 cmp	 edi, DWORD PTR [ebx+12]
  000ea	0f 8c c0 00 00
	00		 jl	 $LN56@SetSize
  000f0	eb 02		 jmp	 SHORT $LN32@SetSize
$LN30@SetSize:

; 442  : 			nNewMax = m_nMaxSize + nGrowBy;  // granularity
; 443  : 		else
; 444  : 			nNewMax = nNewSize;  // no slush

  000f2	8b fe		 mov	 edi, esi
$LN32@SetSize:

; 449  : 			AfxThrowInvalidArgException();
; 450  : 
; 451  : #ifdef SIZE_T_MAX
; 452  : 		ASSERT(nNewMax <= SIZE_T_MAX/sizeof(TYPE)); // no overflow
; 453  : #endif
; 454  : 		TYPE* pNewData = (TYPE*) new BYTE[(size_t)nNewMax * sizeof(TYPE)];

  000f4	8d 04 bd 00 00
	00 00		 lea	 eax, DWORD PTR [edi*4]
  000fb	50		 push	 eax
  000fc	89 45 fc	 mov	 DWORD PTR __S1max$1$[ebp], eax
  000ff	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]

; 455  : 
; 456  : 		// copy new data from old
; 457  : 		::ATL::Checked::memcpy_s(pNewData, (size_t)nNewMax * sizeof(TYPE),

  00104	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  00107	83 c4 04	 add	 esp, 4
  0010a	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  0010d	c1 e1 02	 shl	 ecx, 2
  00110	89 45 0c	 mov	 DWORD PTR _pNewData$1$[ebp], eax
  00113	89 4d f8	 mov	 DWORD PTR __N$1$[ebp], ecx
  00116	89 55 08	 mov	 DWORD PTR __S2$1$[ebp], edx
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_memcpy_s.h

; 46   :         if (_SourceSize == 0)

  00119	85 c9		 test	 ecx, ecx
  0011b	74 20		 je	 SHORT $LN54@SetSize

; 47   :         {
; 48   :             return 0;
; 49   :         }
; 50   : 
; 51   :         _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Destination != NULL, EINVAL);

  0011d	85 c0		 test	 eax, eax
  0011f	74 7d		 je	 SHORT $LN84@SetSize

; 52   :         if (_Source == NULL || _DestinationSize < _SourceSize)

  00121	85 d2		 test	 edx, edx
  00123	74 51		 je	 SHORT $LN76@SetSize
  00125	8d 14 bd 00 00
	00 00		 lea	 edx, DWORD PTR [edi*4]
  0012c	3b d1		 cmp	 edx, ecx
  0012e	72 46		 jb	 SHORT $LN76@SetSize

; 58   : 
; 59   :             // Unreachable, but required to suppress /analyze warnings:
; 60   :             return EINVAL;
; 61   :         }
; 62   :         memcpy(_Destination, _Source, _SourceSize);

  00130	51		 push	 ecx
  00131	ff 75 08	 push	 DWORD PTR __S2$1$[ebp]
  00134	50		 push	 eax
  00135	e8 00 00 00 00	 call	 _memcpy
  0013a	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN54@SetSize:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 462  : 		memset((void*)(pNewData + m_nSize), 0, (size_t)(nNewSize-m_nSize) * sizeof(TYPE));

  0013d	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  00140	8b c6		 mov	 eax, esi
  00142	2b c1		 sub	 eax, ecx
  00144	c1 e0 02	 shl	 eax, 2
  00147	50		 push	 eax
  00148	8b 45 0c	 mov	 eax, DWORD PTR _pNewData$1$[ebp]
  0014b	6a 00		 push	 0
  0014d	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  00150	50		 push	 eax
  00151	e8 00 00 00 00	 call	 _memset

; 463  : 		for( int i = 0; i < nNewSize-m_nSize; i++ )
; 464  : #pragma push_macro("new")
; 465  : #undef new
; 466  : 			::new( (void*)( pNewData + m_nSize + i ) ) TYPE;
; 467  : #pragma pop_macro("new")
; 468  : 
; 469  : 		// get rid of old stuff (note: no destructors called)
; 470  : 		delete[] (BYTE*)m_pData;

  00156	ff 73 04	 push	 DWORD PTR [ebx+4]
  00159	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]

; 471  : 		m_pData = pNewData;

  0015e	8b 45 0c	 mov	 eax, DWORD PTR _pNewData$1$[ebp]
  00161	83 c4 10	 add	 esp, 16			; 00000010H

; 475  : }

  00164	89 7b 0c	 mov	 DWORD PTR [ebx+12], edi
  00167	89 73 08	 mov	 DWORD PTR [ebx+8], esi
  0016a	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  0016d	5f		 pop	 edi
  0016e	5e		 pop	 esi
  0016f	5b		 pop	 ebx
  00170	8b e5		 mov	 esp, ebp
  00172	5d		 pop	 ebp
  00173	c2 08 00	 ret	 8
$LN76@SetSize:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_memcpy_s.h

; 54   :             memset(_Destination, 0, _DestinationSize);

  00176	8b 5d fc	 mov	 ebx, DWORD PTR __S1max$1$[ebp]
  00179	53		 push	 ebx
  0017a	6a 00		 push	 0
  0017c	50		 push	 eax
  0017d	e8 00 00 00 00	 call	 _memset
  00182	83 c4 0c	 add	 esp, 12			; 0000000cH

; 55   : 
; 56   :             _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Source != NULL,                 EINVAL);

  00185	83 7d 08 00	 cmp	 DWORD PTR __S2$1$[ebp], 0
  00189	74 13		 je	 SHORT $LN84@SetSize

; 57   :             _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_DestinationSize >= _SourceSize, ERANGE);

  0018b	3b 5d f8	 cmp	 ebx, DWORD PTR __N$1$[ebp]
  0018e	73 20		 jae	 SHORT $LN56@SetSize
  00190	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___errno
  00196	c7 00 22 00 00
	00		 mov	 DWORD PTR [eax], 34	; 00000022H
  0019c	eb 0c		 jmp	 SHORT $LN85@SetSize
$LN84@SetSize:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.h

; 517  : 		AfxThrowInvalidArgException();

  0019e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___errno
  001a4	c7 00 16 00 00
	00		 mov	 DWORD PTR [eax], 22	; 00000016H
$LN85@SetSize:
  001aa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo
$LN56@SetSize:
  001b0	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN83@SetSize:
  001b5	cc		 int	 3
?SetSize@?$CArray@HH@@QAEXHH@Z ENDP			; CArray<int,int>::SetSize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@QAE@XZ
_TEXT	SEGMENT
??1?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@QAE@XZ PROC ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int>::~pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int>, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2286 :         return _BUF_SIZE <= _Myres;

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00006	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 4584 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00009	72 27		 jb	 SHORT $LN15@pair
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000b	8b 06		 mov	 eax, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4588 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0000d	41		 inc	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0000e	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00014	72 12		 jb	 SHORT $LN25@pair

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00016	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00019	83 c1 23	 add	 ecx, 35			; 00000023H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001c	2b c2		 sub	 eax, edx

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0001e	83 c0 fc	 add	 eax, -4			; fffffffcH
  00021	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00024	77 1f		 ja	 SHORT $LN22@pair

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00026	8b c2		 mov	 eax, edx
$LN25@pair:

; 255  :         ::operator delete(_Ptr, _Bytes);

  00028	51		 push	 ecx
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	83 c4 08	 add	 esp, 8
$LN15@pair:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4599 :             _Mypair._Myval2._Mysize = 0;

  00032	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 4600 :             _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00039	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 4601 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4602 :             _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00040	c6 06 00	 mov	 BYTE PTR [esi], 0
  00043	5e		 pop	 esi
  00044	c3		 ret	 0
$LN22@pair:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00045	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN31@pair:
  0004b	cc		 int	 3
??1?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@QAE@XZ ENDP ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int>::~pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ?FindIndex@?$CList@NN@@QBEPAU__POSITION@@H@Z
_TEXT	SEGMENT
_nIndex$ = 8						; size = 4
?FindIndex@?$CList@NN@@QBEPAU__POSITION@@H@Z PROC	; CList<double,double>::FindIndex, COMDAT
; _this$ = ecx

; 1130 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1131 : 	ASSERT_VALID(this);
; 1132 : 
; 1133 : 	if (nIndex >= m_nCount || nIndex < 0)

  00003	8b 55 08	 mov	 edx, DWORD PTR _nIndex$[ebp]
  00006	3b 51 0c	 cmp	 edx, DWORD PTR [ecx+12]
  00009	7d 14		 jge	 SHORT $LN5@FindIndex
  0000b	85 d2		 test	 edx, edx
  0000d	78 10		 js	 SHORT $LN5@FindIndex

; 1135 : 
; 1136 : 	CNode* pNode = m_pNodeHead;

  0000f	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 1137 : 	while (nIndex--)

  00012	74 0d		 je	 SHORT $LN1@FindIndex
$LL2@FindIndex:

; 1138 : 	{
; 1139 : 		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 1140 : 		pNode = pNode->pNext;

  00014	8b 00		 mov	 eax, DWORD PTR [eax]
  00016	83 ea 01	 sub	 edx, 1
  00019	75 f9		 jne	 SHORT $LL2@FindIndex

; 1141 : 	}
; 1142 : 	return (POSITION) pNode;
; 1143 : }

  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
$LN5@FindIndex:

; 1134 : 		return NULL;  // went too far

  0001f	33 c0		 xor	 eax, eax
$LN1@FindIndex:

; 1141 : 	}
; 1142 : 	return (POSITION) pNode;
; 1143 : }

  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
?FindIndex@?$CList@NN@@QBEPAU__POSITION@@H@Z ENDP	; CList<double,double>::FindIndex
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ??_GCXScaleManagerImp@@UAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_GCXScaleManagerImp@@UAEPAXI@Z PROC			; CXScaleManagerImp::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_GCXScaleManagerImp@@UAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f9		 mov	 edi, ecx

; 126  : {

  00026	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0002d	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7CXScaleManagerImp@@6B@

; 127  : 	ClearData();

  00033	e8 00 00 00 00	 call	 ?ClearData@CXScaleManagerImp@@IAEXXZ ; CXScaleManagerImp::ClearData

; 128  : }

  00038	68 00 00 00 00	 push	 OFFSET ??1?$CDataBlockList@H$0CAA@@@UAE@XZ ; CDataBlockList<int,512>::~CDataBlockList<int,512>
  0003d	6a 0a		 push	 10			; 0000000aH
  0003f	6a 34		 push	 52			; 00000034H
  00041	8d 87 84 0c 00
	00		 lea	 eax, DWORD PTR [edi+3204]
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  0004d	68 00 00 00 00	 push	 OFFSET ??1?$CDataBlockList@Utm@@$0CAA@@@UAE@XZ ; CDataBlockList<tm,512>::~CDataBlockList<tm,512>
  00052	6a 0a		 push	 10			; 0000000aH
  00054	6a 34		 push	 52			; 00000034H
  00056	8d 87 7c 0a 00
	00		 lea	 eax, DWORD PTR [edi+2684]
  0005c	50		 push	 eax
  0005d	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  00062	8d 8f 74 0a 00
	00		 lea	 ecx, DWORD PTR [edi+2676]
  00068	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0006e	68 00 00 00 00	 push	 OFFSET ??1?$CDataBlockList@H$0CAA@@@UAE@XZ ; CDataBlockList<int,512>::~CDataBlockList<int,512>
  00073	6a 0a		 push	 10			; 0000000aH
  00075	6a 34		 push	 52			; 00000034H
  00077	8d 87 64 08 00
	00		 lea	 eax, DWORD PTR [edi+2148]
  0007d	50		 push	 eax
  0007e	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  00083	68 00 00 00 00	 push	 OFFSET ??1?$CDataBlockList@Utm@@$0CAA@@@UAE@XZ ; CDataBlockList<tm,512>::~CDataBlockList<tm,512>
  00088	6a 0a		 push	 10			; 0000000aH
  0008a	6a 34		 push	 52			; 00000034H
  0008c	8d 87 5c 06 00
	00		 lea	 eax, DWORD PTR [edi+1628]
  00092	50		 push	 eax
  00093	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  00098	8d 8f 18 06 00
	00		 lea	 ecx, DWORD PTR [edi+1560]
  0009e	e8 00 00 00 00	 call	 ??1CMapWordToPtr@@UAE@XZ ; CMapWordToPtr::~CMapWordToPtr
  000a3	8d 8f ec 05 00
	00		 lea	 ecx, DWORD PTR [edi+1516]
  000a9	e8 00 00 00 00	 call	 ??1CXScaleTimeDiffManager@@UAE@XZ ; CXScaleTimeDiffManager::~CXScaleTimeDiffManager
  000ae	68 00 00 00 00	 push	 OFFSET ??1?$CDataBlockList@UtagAREA@CXScaleManager@@$0CAA@@@UAE@XZ ; CDataBlockList<CXScaleManager::tagAREA,512>::~CDataBlockList<CXScaleManager::tagAREA,512>
  000b3	6a 0a		 push	 10			; 0000000aH
  000b5	6a 34		 push	 52			; 00000034H
  000b7	8d 87 88 03 00
	00		 lea	 eax, DWORD PTR [edi+904]
  000bd	50		 push	 eax
  000be	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  000c3	8d 8f ac 00 00
	00		 lea	 ecx, DWORD PTR [edi+172]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 163  : 	{

  000c9	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CDataBlockList@_J$0CAA@@@6B@

; 164  : 	}

  000cf	e8 00 00 00 00	 call	 ??1CDataBlockListUNK@@UAE@XZ ; CDataBlockListUNK::~CDataBlockListUNK
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 752  :         _Erase_tree(_Al, _Myhead->_Parent);

  000d4	8b 87 94 00 00
	00		 mov	 eax, DWORD PTR [edi+148]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 128  : }

  000da	8d b7 94 00 00
	00		 lea	 esi, DWORD PTR [edi+148]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 752  :         _Erase_tree(_Al, _Myhead->_Parent);

  000e0	8b ce		 mov	 ecx, esi
  000e2	ff 70 04	 push	 DWORD PTR [eax+4]
  000e5	56		 push	 esi
  000e6	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,CXScaleManagerImp::VERTBOX_INFO *> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,CXScaleManagerImp::VERTBOX_INFO *>,void *> > >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 255  :         ::operator delete(_Ptr, _Bytes);

  000eb	6a 2c		 push	 44			; 0000002cH
  000ed	ff 36		 push	 DWORD PTR [esi]
  000ef	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  000f4	83 c4 08	 add	 esp, 8
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 128  : }

  000f7	8d 4f 78	 lea	 ecx, DWORD PTR [edi+120]
  000fa	e8 00 00 00 00	 call	 ??1CStringArray@@UAE@XZ	; CStringArray::~CStringArray
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 752  :         _Erase_tree(_Al, _Myhead->_Parent);

  000ff	8b 47 70	 mov	 eax, DWORD PTR [edi+112]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 128  : }

  00102	8d 77 70	 lea	 esi, DWORD PTR [edi+112]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 752  :         _Erase_tree(_Al, _Myhead->_Parent);

  00105	8b ce		 mov	 ecx, esi
  00107	ff 70 04	 push	 DWORD PTR [eax+4]
  0010a	56		 push	 esi
  0010b	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> > >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 255  :         ::operator delete(_Ptr, _Bytes);

  00110	6a 2c		 push	 44			; 0000002cH
  00112	ff 36		 push	 DWORD PTR [esi]
  00114	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00119	83 c4 08	 add	 esp, 8
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 128  : }

  0011c	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7CXScaleManager@@6B@
  00122	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00126	74 0e		 je	 SHORT $LN75@scalar
  00128	68 90 0e 00 00	 push	 3728			; 00000e90H
  0012d	57		 push	 edi
  0012e	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00133	83 c4 08	 add	 esp, 8
$LN75@scalar:
  00136	8b c7		 mov	 eax, edi
  00138	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0013b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00142	59		 pop	 ecx
  00143	5f		 pop	 edi
  00144	5e		 pop	 esi
  00145	8b e5		 mov	 esp, ebp
  00147	5d		 pop	 ebp
  00148	c2 04 00	 ret	 4
  0014b	cc		 int	 3
  0014c	cc		 int	 3
  0014d	cc		 int	 3
  0014e	cc		 int	 3
  0014f	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??_GCXScaleManagerImp@@UAEPAXI@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_GCXScaleManagerImp@@UAEPAXI@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_GCXScaleManagerImp@@UAEPAXI@Z ENDP			; CXScaleManagerImp::`scalar deleting destructor'
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?GetScaleDRIandTimeAllData@CXScaleManagerImp@@UAEHHAAPAV?$CDataBlockList@H$0CAA@@@AAPAV?$CDataBlockList@Utm@@$0CAA@@@W4HORZSCALEDRAWERTYPE@CScaleBaseData@@PBDAAH@Z
_TEXT	SEGMENT
tv258 = -8						; size = 4
_pXScaleGridTime$ = -4					; size = 4
_p_nColumn$ = 8						; size = 4
_p_pblScaleDRI$ = 12					; size = 4
_p_pblScaleTime$ = 16					; size = 4
_p_eScaleDrawType$ = 20					; size = 4
tv257 = 24						; size = 4
_p_szRQ$ = 24						; size = 4
_p_nSkipFactor$ = 28					; size = 4
?GetScaleDRIandTimeAllData@CXScaleManagerImp@@UAEHHAAPAV?$CDataBlockList@H$0CAA@@@AAPAV?$CDataBlockList@Utm@@$0CAA@@@W4HORZSCALEDRAWERTYPE@CScaleBaseData@@PBDAAH@Z PROC ; CXScaleManagerImp::GetScaleDRIandTimeAllData, COMDAT
; _this$ = ecx

; 4065 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx

; 4066 : 	// 1. Get X Scale Grid Object.
; 4067 : 	CXScaleGridTime *pXScaleGridTime = NULL;
; 4068 : 	int nTimeDiff = GetTimeDiffWithCurrentRQ( p_szRQ);

  00007	8b 5d 18	 mov	 ebx, DWORD PTR _p_szRQ$[ebp]
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8b f9		 mov	 edi, ecx
  0000f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pXScaleGridTime$[ebp], 0
  00016	8b cc		 mov	 ecx, esp
  00018	53		 push	 ebx
  00019	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  0001f	8b cf		 mov	 ecx, edi
  00021	e8 00 00 00 00	 call	 ?GetTimeDiffWithCurrentRQ@CXScaleManagerImp@@IAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ; CXScaleManagerImp::GetTimeDiffWithCurrentRQ
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 2052 : 		{ return BASE_CLASS::Lookup(key, (typename BASE_CLASS::BASE_VALUE&)rValue); }

  00026	8d 4d fc	 lea	 ecx, DWORD PTR _pXScaleGridTime$[ebp]
  00029	51		 push	 ecx
  0002a	50		 push	 eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 4069 : 	if( !m_mapXGridTime.Lookup( nTimeDiff, pXScaleGridTime)) return -1;

  0002b	8d 8f 18 06 00
	00		 lea	 ecx, DWORD PTR [edi+1560]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 2052 : 		{ return BASE_CLASS::Lookup(key, (typename BASE_CLASS::BASE_VALUE&)rValue); }

  00031	e8 00 00 00 00	 call	 ?Lookup@CMapWordToPtr@@QBEHGAAPAX@Z ; CMapWordToPtr::Lookup
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 4069 : 	if( !m_mapXGridTime.Lookup( nTimeDiff, pXScaleGridTime)) return -1;

  00036	85 c0		 test	 eax, eax
  00038	0f 84 a6 00 00
	00		 je	 $LN10@GetScaleDR

; 4070 : 
; 4071 : 	p_pblScaleDRI = &m_blScaleDRI2[ p_nColumn];			// DRI value for scale of YYYY/MM/DD/HH/mm/SS

  0003e	6b 4d 08 34	 imul	 ecx, DWORD PTR _p_nColumn$[ebp], 52
  00042	8b 45 0c	 mov	 eax, DWORD PTR _p_pblScaleDRI$[ebp]
  00045	03 cf		 add	 ecx, edi
  00047	8d b1 84 0c 00
	00		 lea	 esi, DWORD PTR [ecx+3204]

; 4072 : 	p_pblScaleTime = &m_blScaleTime2[ p_nColumn];		// Time value for scale of YYYY/MM/DD/HH/mm/SS

  0004d	81 c1 7c 0a 00
	00		 add	 ecx, 2684		; 00000a7cH
  00053	89 30		 mov	 DWORD PTR [eax], esi
  00055	8b 45 10	 mov	 eax, DWORD PTR _p_pblScaleTime$[ebp]

; 4073 : 
; 4074 : 
; 4075 : 	int nRQ = GetRQIndexFromString( p_szRQ);

  00058	51		 push	 ecx
  00059	89 4d 18	 mov	 DWORD PTR tv257[ebp], ecx
  0005c	89 75 f8	 mov	 DWORD PTR tv258[ebp], esi
  0005f	89 08		 mov	 DWORD PTR [eax], ecx
  00061	8b cc		 mov	 ecx, esp
  00063	53		 push	 ebx
  00064	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  0006a	8b 07		 mov	 eax, DWORD PTR [edi]
  0006c	8b cf		 mov	 ecx, edi
  0006e	ff 50 04	 call	 DWORD PTR [eax+4]

; 4076 : 	if( nRQ < 0) return -1;

  00071	85 c0		 test	 eax, eax
  00073	78 6f		 js	 SHORT $LN10@GetScaleDR

; 4077 : 
; 4078 : 	m_blScaleDRI2[ p_nColumn].Clear();		// DRI value for scale of YYYY/MM/DD/HH/mm/SS

  00075	8b ce		 mov	 ecx, esi
  00077	e8 00 00 00 00	 call	 ?Clear@CDataBlockListUNK@@QAEXXZ ; CDataBlockListUNK::Clear

; 4079 : 	m_blScaleTime2[ p_nColumn].Clear();		// Time value for scale of YYYY/MM/DD/HH/mm/SS

  0007c	8b 4d 18	 mov	 ecx, DWORD PTR tv257[ebp]
  0007f	e8 00 00 00 00	 call	 ?Clear@CDataBlockListUNK@@QAEXXZ ; CDataBlockListUNK::Clear

; 4080 : 
; 4081 : 	// (2009/5/28 - Seung-Won, Bae) Do not draw scale on no data.
; 4082 : 	if( IsEmptyData()) return -1;

  00084	8b 07		 mov	 eax, DWORD PTR [edi]
  00086	8b cf		 mov	 ecx, edi
  00088	ff 90 68 01 00
	00		 call	 DWORD PTR [eax+360]
  0008e	85 c0		 test	 eax, eax
  00090	75 52		 jne	 SHORT $LN10@GetScaleDR

; 4083 : 
; 4084 : 	p_nSkipFactor = 1;

  00092	8b 75 1c	 mov	 esi, DWORD PTR _p_nSkipFactor$[ebp]

; 4085 : 	pXScaleGridTime->MakeScaleData( 2, m_blScaleTime2[ p_nColumn], m_blScaleDRI2[ p_nColumn], p_nSkipFactor, m_eChartMode);

  00095	8b 4d fc	 mov	 ecx, DWORD PTR _pXScaleGridTime$[ebp]
  00098	c7 06 01 00 00
	00		 mov	 DWORD PTR [esi], 1
  0009e	ff b7 e8 05 00
	00		 push	 DWORD PTR [edi+1512]
  000a4	6a 01		 push	 1
  000a6	ff 75 f8	 push	 DWORD PTR tv258[ebp]
  000a9	ff 75 18	 push	 DWORD PTR tv257[ebp]
  000ac	6a 02		 push	 2
  000ae	e8 00 00 00 00	 call	 ?MakeScaleData@CXScaleGridTime@@QAEXHAAV?$CDataBlockList@Utm@@$0CAA@@@AAV?$CDataBlockList@H$0CAA@@@HW4CHART_MODE@CChartInfo@@@Z ; CXScaleGridTime::MakeScaleData

; 4086 : 	
; 4087 : 	m_nSkipFactor = p_nSkipFactor;

  000b3	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000b5	89 8f 6c 0a 00
	00		 mov	 DWORD PTR [edi+2668], ecx

; 4088 : 	m_eScaleDrawType = p_eScaleDrawType;

  000bb	8b 4d 14	 mov	 ecx, DWORD PTR _p_eScaleDrawType$[ebp]
  000be	89 8f 70 0a 00
	00		 mov	 DWORD PTR [edi+2672], ecx

; 4089 : 	m_strScaleRQ = p_szRQ;

  000c4	8d 8f 74 0a 00
	00		 lea	 ecx, DWORD PTR [edi+2676]
  000ca	53		 push	 ebx
  000cb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z

; 4090 : 
; 4091 : 	return m_naScaleType[ p_nColumn];

  000d1	8b 45 08	 mov	 eax, DWORD PTR _p_nColumn$[ebp]
  000d4	8b 84 87 34 06
	00 00		 mov	 eax, DWORD PTR [edi+eax*4+1588]

; 4092 : }

  000db	5f		 pop	 edi
  000dc	5e		 pop	 esi
  000dd	5b		 pop	 ebx
  000de	8b e5		 mov	 esp, ebp
  000e0	5d		 pop	 ebp
  000e1	c2 18 00	 ret	 24			; 00000018H
$LN10@GetScaleDR:
  000e4	5f		 pop	 edi
  000e5	5e		 pop	 esi
  000e6	83 c8 ff	 or	 eax, -1
  000e9	5b		 pop	 ebx
  000ea	8b e5		 mov	 esp, ebp
  000ec	5d		 pop	 ebp
  000ed	c2 18 00	 ret	 24			; 00000018H
?GetScaleDRIandTimeAllData@CXScaleManagerImp@@UAEHHAAPAV?$CDataBlockList@H$0CAA@@@AAPAV?$CDataBlockList@Utm@@$0CAA@@@W4HORZSCALEDRAWERTYPE@CScaleBaseData@@PBDAAH@Z ENDP ; CXScaleManagerImp::GetScaleDRIandTimeAllData
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.h
;	COMDAT ?GetPriceMinMaxShowType@CXScaleManagerImp@@MAEHXZ
_TEXT	SEGMENT
?GetPriceMinMaxShowType@CXScaleManagerImp@@MAEHXZ PROC	; CXScaleManagerImp::GetPriceMinMaxShowType, COMDAT
; _this$ = ecx

; 581  : 	int		GetPriceMinMaxShowType( void)		{	return m_nMinMaxRatio;	}

  00000	8b 81 78 0a 00
	00		 mov	 eax, DWORD PTR [ecx+2680]
  00006	c3		 ret	 0
?GetPriceMinMaxShowType@CXScaleManagerImp@@MAEHXZ ENDP	; CXScaleManagerImp::GetPriceMinMaxShowType
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.h
;	COMDAT ?SetPriceMinMaxShowType@CXScaleManagerImp@@MAEXH@Z
_TEXT	SEGMENT
_nMinMaxRatio$ = 8					; size = 4
?SetPriceMinMaxShowType@CXScaleManagerImp@@MAEXH@Z PROC	; CXScaleManagerImp::SetPriceMinMaxShowType, COMDAT
; _this$ = ecx

; 580  : 	void	SetPriceMinMaxShowType( int nMinMaxRatio) { m_nMinMaxRatio = nMinMaxRatio; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _nMinMaxRatio$[ebp]
  00006	89 81 78 0a 00
	00		 mov	 DWORD PTR [ecx+2680], eax
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
?SetPriceMinMaxShowType@CXScaleManagerImp@@MAEXH@Z ENDP	; CXScaleManagerImp::SetPriceMinMaxShowType
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\Dll_Load\XScaleManager.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?IsSpecialTime@CXScaleManagerImp@@MAEHPBD_JAAJ@Z
_TEXT	SEGMENT
_p_szRQ$ = 8						; size = 4
_p_time$ = 12						; size = 8
_pValue$1 = 20						; size = 4
_p_lSpecialTimeCode$ = 20				; size = 4
?IsSpecialTime@CXScaleManagerImp@@MAEHPBD_JAAJ@Z PROC	; CXScaleManagerImp::IsSpecialTime, COMDAT
; _this$ = ecx

; 2806 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 2807 : 	p_lSpecialTimeCode = 0;

  00005	8b 7d 14	 mov	 edi, DWORD PTR _p_lSpecialTimeCode$[ebp]
  00008	8b f1		 mov	 esi, ecx

; 2808 : 	int nRQ = GetRQIndexFromString( p_szRQ);

  0000a	51		 push	 ecx
  0000b	8b cc		 mov	 ecx, esp
  0000d	ff 75 08	 push	 DWORD PTR _p_szRQ$[ebp]
  00010	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  0001c	8b 06		 mov	 eax, DWORD PTR [esi]
  0001e	8b ce		 mov	 ecx, esi
  00020	ff 50 04	 call	 DWORD PTR [eax+4]
  00023	8b c8		 mov	 ecx, eax

; 2809 : 	if( nRQ < 0) return FALSE;

  00025	85 c9		 test	 ecx, ecx
  00027	79 08		 jns	 SHORT $LN2@IsSpecialT
  00029	33 c0		 xor	 eax, eax

; 2811 : }

  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5d		 pop	 ebp
  0002e	c2 10 00	 ret	 16			; 00000010H
$LN2@IsSpecialT:

; 2810 : 	return m_pamapSpecialTime[ nRQ]->Lookup( p_time, p_lSpecialTimeCode);

  00031	8b 86 a4 00 00
	00		 mov	 eax, DWORD PTR [esi+164]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\Dll_Load\XScaleManager.h

; 38   : 				BOOL bResult = CMapPtrToPtr::Lookup( ( void *)key, pValue);

  00037	8d 55 14	 lea	 edx, DWORD PTR _pValue$1[ebp]
  0003a	52		 push	 edx
  0003b	ff 75 0c	 push	 DWORD PTR _p_time$[ebp]
  0003e	8b 0c 88	 mov	 ecx, DWORD PTR [eax+ecx*4]
  00041	e8 00 00 00 00	 call	 ?Lookup@CMapPtrToPtr@@QBEHPAXAAPAX@Z ; CMapPtrToPtr::Lookup

; 39   : 				rValue = ( long)pValue;

  00046	8b 4d 14	 mov	 ecx, DWORD PTR _pValue$1[ebp]
  00049	89 0f		 mov	 DWORD PTR [edi], ecx
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 2811 : }

  0004b	5f		 pop	 edi
  0004c	5e		 pop	 esi
  0004d	5d		 pop	 ebp
  0004e	c2 10 00	 ret	 16			; 00000010H
?IsSpecialTime@CXScaleManagerImp@@MAEHPBD_JAAJ@Z ENDP	; CXScaleManagerImp::IsSpecialTime
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\time.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\time.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\time.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?PushScaleDataTime@CXScaleManagerImp@@IAEXH_JH@Z
_TEXT	SEGMENT
_psnXGridTime$ = -52					; size = 4
_nTimeDiff$ = -48					; size = 2
_pXScaleGridTime$ = -44					; size = 4
_tmDRI$ = -40						; size = 36
__$ArrayPad$ = -4					; size = 4
_p_nDRI$ = 8						; size = 4
_p_timeDRI$ = 12					; size = 8
_p_bEndDRI$ = 20					; size = 4
?PushScaleDataTime@CXScaleManagerImp@@IAEXH_JH@Z PROC	; CXScaleManagerImp::PushScaleDataTime, COMDAT
; _this$ = ecx

; 1024 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1025 : 	if( p_timeDRI < 0)

  00010	83 7d 10 00	 cmp	 DWORD PTR _p_timeDRI$[ebp+4], 0
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	8b f1		 mov	 esi, ecx
  00019	0f 8c cb 00 00
	00		 jl	 $LN3@PushScaleD
  0001f	7f 0a		 jg	 SHORT $LN22@PushScaleD
  00021	83 7d 0c 00	 cmp	 DWORD PTR _p_timeDRI$[ebp], 0
  00025	0f 82 bf 00 00
	00		 jb	 $LN3@PushScaleD
$LN22@PushScaleD:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\time.h

; 499  :             return _localtime64(_Time);

  0002b	8d 45 0c	 lea	 eax, DWORD PTR _p_timeDRI$[ebp]
  0002e	50		 push	 eax
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___localtime64
  00035	83 c4 04	 add	 esp, 4
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 1033 : 	if( !ptmCur) return;

  00038	85 c0		 test	 eax, eax
  0003a	0f 84 aa 00 00
	00		 je	 $LN3@PushScaleD

; 1034 : 	tm tmDRI = *ptmCur;
; 1035 : 
; 1036 : 	// (2009/6/4 - Seung-Won, Bae) for ceiled Minute Scale with second time data.
; 1037 : 	if( m_bCeiling && 0 < tmDRI.tm_sec)

  00040	83 be e4 05 00
	00 00		 cmp	 DWORD PTR [esi+1508], 0
  00047	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  0004a	0f 11 45 d8	 movups	 XMMWORD PTR _tmDRI$[ebp], xmm0
  0004e	0f 10 40 10	 movups	 xmm0, XMMWORD PTR [eax+16]
  00052	0f 11 45 e8	 movups	 XMMWORD PTR _tmDRI$[ebp+16], xmm0
  00056	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  00059	89 45 f8	 mov	 DWORD PTR _tmDRI$[ebp+32], eax
  0005c	74 1a		 je	 SHORT $LN6@PushScaleD
  0005e	83 7d d8 00	 cmp	 DWORD PTR _tmDRI$[ebp], 0
  00062	7e 14		 jle	 SHORT $LN6@PushScaleD
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\time.h

; 515  :             return _mktime64(_Tm);

  00064	8d 45 d8	 lea	 eax, DWORD PTR _tmDRI$[ebp]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 1039 : 		tmDRI.tm_sec += 60 - tmDRI.tm_sec;

  00067	c7 45 d8 3c 00
	00 00		 mov	 DWORD PTR _tmDRI$[ebp], 60 ; 0000003cH
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\time.h

; 515  :             return _mktime64(_Tm);

  0006e	50		 push	 eax
  0006f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___mktime64
  00075	83 c4 04	 add	 esp, 4
$LN6@PushScaleD:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl

; 567  : 	{ return (m_nCount == 0) ? NULL : BEFORE_START_POSITION; }

  00078	8b 8e 24 06 00
	00		 mov	 ecx, DWORD PTR [esi+1572]
  0007e	8b c1		 mov	 eax, ecx
  00080	f7 d8		 neg	 eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 1043 : 	signed short nTimeDiff = 0;

  00082	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _nTimeDiff$[ebp], 0

; 1044 : 	CXScaleGridTime *pXScaleGridTime = NULL;

  00089	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _pXScaleGridTime$[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl

; 567  : 	{ return (m_nCount == 0) ? NULL : BEFORE_START_POSITION; }

  00090	1b c0		 sbb	 eax, eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 1045 : 	POSITION psnXGridTime = m_mapXGridTime.GetStartPosition();

  00092	89 45 cc	 mov	 DWORD PTR _psnXGridTime$[ebp], eax
  00095	85 c9		 test	 ecx, ecx

; 1046 : 	while( psnXGridTime)

  00097	74 51		 je	 SHORT $LN3@PushScaleD
  00099	8b 7d 14	 mov	 edi, DWORD PTR _p_bEndDRI$[ebp]
  0009c	8b 5d 08	 mov	 ebx, DWORD PTR _p_nDRI$[ebp]
  0009f	90		 npad	 1
$LL2@PushScaleD:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 2068 : 		{ BASE_CLASS::GetNextAssoc(rPosition, (typename BASE_CLASS::BASE_KEY&)rKey,

  000a0	8d 45 d4	 lea	 eax, DWORD PTR _pXScaleGridTime$[ebp]
  000a3	50		 push	 eax
  000a4	8d 45 d0	 lea	 eax, DWORD PTR _nTimeDiff$[ebp]
  000a7	50		 push	 eax
  000a8	8d 45 cc	 lea	 eax, DWORD PTR _psnXGridTime$[ebp]
  000ab	50		 push	 eax
  000ac	8d 8e 18 06 00
	00		 lea	 ecx, DWORD PTR [esi+1560]
  000b2	e8 00 00 00 00	 call	 ?GetNextAssoc@CMapWordToPtr@@QBEXAAPAU__POSITION@@AAGAAPAX@Z ; CMapWordToPtr::GetNextAssoc
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 1049 : 		if( !pXScaleGridTime) continue;

  000b7	8b 4d d4	 mov	 ecx, DWORD PTR _pXScaleGridTime$[ebp]
  000ba	85 c9		 test	 ecx, ecx
  000bc	74 26		 je	 SHORT $LN19@PushScaleD

; 1050 : 		pXScaleGridTime->PushScaleDataTime( nTimeDiff, p_nDRI, tmDRI, p_bEndDRI);

  000be	0f 10 45 d8	 movups	 xmm0, XMMWORD PTR _tmDRI$[ebp]
  000c2	8b 45 f8	 mov	 eax, DWORD PTR _tmDRI$[ebp+32]
  000c5	57		 push	 edi
  000c6	83 ec 24	 sub	 esp, 36			; 00000024H
  000c9	8b d4		 mov	 edx, esp
  000cb	53		 push	 ebx
  000cc	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0
  000cf	0f 10 45 e8	 movups	 xmm0, XMMWORD PTR _tmDRI$[ebp+16]
  000d3	0f 11 42 10	 movups	 XMMWORD PTR [edx+16], xmm0
  000d7	89 42 20	 mov	 DWORD PTR [edx+32], eax
  000da	0f bf 45 d0	 movsx	 eax, WORD PTR _nTimeDiff$[ebp]
  000de	50		 push	 eax
  000df	e8 00 00 00 00	 call	 ?PushScaleDataTime@CXScaleGridTime@@QAEXHHUtm@@H@Z ; CXScaleGridTime::PushScaleDataTime
$LN19@PushScaleD:

; 1046 : 	while( psnXGridTime)

  000e4	83 7d cc 00	 cmp	 DWORD PTR _psnXGridTime$[ebp], 0
  000e8	75 b6		 jne	 SHORT $LL2@PushScaleD
$LN3@PushScaleD:

; 1051 : 	}
; 1052 : }

  000ea	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ed	5f		 pop	 edi
  000ee	5e		 pop	 esi
  000ef	33 cd		 xor	 ecx, ebp
  000f1	5b		 pop	 ebx
  000f2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000f7	8b e5		 mov	 esp, ebp
  000f9	5d		 pop	 ebp
  000fa	c2 10 00	 ret	 16			; 00000010H
?PushScaleDataTime@CXScaleManagerImp@@IAEXH_JH@Z ENDP	; CXScaleManagerImp::PushScaleDataTime
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?PopLastScaleDataTime@CXScaleManagerImp@@IAEXXZ
_TEXT	SEGMENT
_nTimeDiff$ = -12					; size = 2
_psnXGridTime$ = -8					; size = 4
_pXScaleGridTime$ = -4					; size = 4
?PopLastScaleDataTime@CXScaleManagerImp@@IAEXXZ PROC	; CXScaleManagerImp::PopLastScaleDataTime, COMDAT
; _this$ = ecx

; 1011 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl

; 567  : 	{ return (m_nCount == 0) ? NULL : BEFORE_START_POSITION; }

  00006	8b 91 24 06 00
	00		 mov	 edx, DWORD PTR [ecx+1572]
  0000c	8b c2		 mov	 eax, edx
  0000e	f7 d8		 neg	 eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 1012 : 	signed short nTimeDiff = 0;

  00010	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _nTimeDiff$[ebp], 0

; 1013 : 	CXScaleGridTime *pXScaleGridTime = NULL;

  00017	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pXScaleGridTime$[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl

; 567  : 	{ return (m_nCount == 0) ? NULL : BEFORE_START_POSITION; }

  0001e	1b c0		 sbb	 eax, eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 1014 : 	POSITION psnXGridTime = m_mapXGridTime.GetStartPosition();

  00020	89 45 f8	 mov	 DWORD PTR _psnXGridTime$[ebp], eax
  00023	85 d2		 test	 edx, edx

; 1015 : 	while( psnXGridTime)

  00025	74 2f		 je	 SHORT $LN3@PopLastSca
  00027	56		 push	 esi
  00028	8d b1 18 06 00
	00		 lea	 esi, DWORD PTR [ecx+1560]
  0002e	66 90		 npad	 2
$LL2@PopLastSca:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 2068 : 		{ BASE_CLASS::GetNextAssoc(rPosition, (typename BASE_CLASS::BASE_KEY&)rKey,

  00030	8d 45 fc	 lea	 eax, DWORD PTR _pXScaleGridTime$[ebp]
  00033	8b ce		 mov	 ecx, esi
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR _nTimeDiff$[ebp]
  00039	50		 push	 eax
  0003a	8d 45 f8	 lea	 eax, DWORD PTR _psnXGridTime$[ebp]
  0003d	50		 push	 eax
  0003e	e8 00 00 00 00	 call	 ?GetNextAssoc@CMapWordToPtr@@QBEXAAPAU__POSITION@@AAGAAPAX@Z ; CMapWordToPtr::GetNextAssoc
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 1018 : 		if( !pXScaleGridTime) continue;

  00043	8b 4d fc	 mov	 ecx, DWORD PTR _pXScaleGridTime$[ebp]
  00046	85 c9		 test	 ecx, ecx
  00048	74 05		 je	 SHORT $LN12@PopLastSca

; 1019 : 		pXScaleGridTime->PopLastScaleDataTime();

  0004a	e8 00 00 00 00	 call	 ?PopLastScaleDataTime@CXScaleGridTime@@QAEXXZ ; CXScaleGridTime::PopLastScaleDataTime
$LN12@PopLastSca:

; 1015 : 	while( psnXGridTime)

  0004f	83 7d f8 00	 cmp	 DWORD PTR _psnXGridTime$[ebp], 0
  00053	75 db		 jne	 SHORT $LL2@PopLastSca
  00055	5e		 pop	 esi
$LN3@PopLastSca:

; 1020 : 	}
; 1021 : }

  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c3		 ret	 0
?PopLastScaleDataTime@CXScaleManagerImp@@IAEXXZ ENDP	; CXScaleManagerImp::PopLastScaleDataTime
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
;	COMDAT ??_G?$CTypedPtrMap@VCMapWordToPtr@@FPAVCXScaleGridTime@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CTypedPtrMap@VCMapWordToPtr@@FPAVCXScaleGridTime@@@@UAEPAXI@Z PROC ; CTypedPtrMap<CMapWordToPtr,short,CXScaleGridTime *>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CMapWordToPtr@@UAE@XZ ; CMapWordToPtr::~CMapWordToPtr
  0000b	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  0000e	a8 01		 test	 al, 1
  00010	74 1f		 je	 SHORT $LN12@scalar
  00012	a8 04		 test	 al, 4
  00014	75 10		 jne	 SHORT $LN3@scalar

; 112  : 	{ ::operator delete(p); }

  00016	56		 push	 esi
  00017	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001c	83 c4 04	 add	 esp, 4
  0001f	8b c6		 mov	 eax, esi
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
$LN3@scalar:
  00026	6a 1c		 push	 28			; 0000001cH
  00028	56		 push	 esi
  00029	e8 00 00 00 00	 call	 ?__global_delete@@YAXPAXI@Z ; __global_delete
  0002e	83 c4 08	 add	 esp, 8
$LN12@scalar:
  00031	8b c6		 mov	 eax, esi
  00033	5e		 pop	 esi
  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
??_G?$CTypedPtrMap@VCMapWordToPtr@@FPAVCXScaleGridTime@@@@UAEPAXI@Z ENDP ; CTypedPtrMap<CMapWordToPtr,short,CXScaleGridTime *>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$CTypedPtrMap@VCMapWordToPtr@@FPAVCXScaleGridTime@@@@UAE@XZ
_TEXT	SEGMENT
??1?$CTypedPtrMap@VCMapWordToPtr@@FPAVCXScaleGridTime@@@@UAE@XZ PROC ; CTypedPtrMap<CMapWordToPtr,short,CXScaleGridTime *>::~CTypedPtrMap<CMapWordToPtr,short,CXScaleGridTime *>, COMDAT
; _this$ = ecx
  00000	e9 00 00 00 00	 jmp	 ??1CMapWordToPtr@@UAE@XZ ; CMapWordToPtr::~CMapWordToPtr
??1?$CTypedPtrMap@VCMapWordToPtr@@FPAVCXScaleGridTime@@@@UAE@XZ ENDP ; CTypedPtrMap<CMapWordToPtr,short,CXScaleGridTime *>::~CTypedPtrMap<CMapWordToPtr,short,CXScaleGridTime *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?GetTimeDiffWithCurrentRQ@CXScaleManagerImp@@IAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_p_strRQ$ = 8						; size = 4
?GetTimeDiffWithCurrentRQ@CXScaleManagerImp@@IAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z PROC ; CXScaleManagerImp::GetTimeDiffWithCurrentRQ, COMDAT
; _this$ = ecx

; 4050 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?GetTimeDiffWithCurrentRQ@CXScaleManagerImp@@IAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	53		 push	 ebx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f9		 mov	 edi, ecx

; 4051 : 	const char *szCurrentRQ = m_pIChartCtrl->GetCurrentRQ();

  00027	8b 4f 50	 mov	 ecx, DWORD PTR [edi+80]
  0002a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00031	8b 01		 mov	 eax, DWORD PTR [ecx]
  00033	ff 90 d8 02 00
	00		 call	 DWORD PTR [eax+728]
  00039	8b f0		 mov	 esi, eax

; 4052 : 	if( !szCurrentRQ) return 0;

  0003b	85 f6		 test	 esi, esi
  0003d	74 40		 je	 SHORT $LN5@GetTimeDif
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h

; 2486 : 		return(str1.Compare(psz2) == 0);

  0003f	56		 push	 esi
  00040	8d 4d 08	 lea	 ecx, DWORD PTR _p_strRQ$[ebp]
  00043	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Compare@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEHPBD@Z
  00049	85 c0		 test	 eax, eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 4053 : 	if( p_strRQ == szCurrentRQ) return 0;

  0004b	74 32		 je	 SHORT $LN5@GetTimeDif

; 4054 : 
; 4055 : 	CPacketList *pPacketListMain = m_ppacketListManager->GetPacketList( szCurrentRQ);

  0004d	8b 4f 48	 mov	 ecx, DWORD PTR [edi+72]
  00050	56		 push	 esi
  00051	8b 01		 mov	 eax, DWORD PTR [ecx]
  00053	ff 50 1c	 call	 DWORD PTR [eax+28]

; 4056 : 	CPacketList *pPacketList = m_ppacketListManager->GetPacketList( p_strRQ);

  00056	8b 4f 48	 mov	 ecx, DWORD PTR [edi+72]
  00059	8b d8		 mov	 ebx, eax
  0005b	ff 75 08	 push	 DWORD PTR _p_strRQ$[ebp]
  0005e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00060	ff 52 1c	 call	 DWORD PTR [edx+28]

; 4057 : 	if( !pPacketListMain || !pPacketList) return 0;

  00063	85 db		 test	 ebx, ebx
  00065	74 18		 je	 SHORT $LN5@GetTimeDif
  00067	85 c0		 test	 eax, eax
  00069	74 14		 je	 SHORT $LN5@GetTimeDif

; 4058 : 
; 4059 : 	return pPacketList->GetBaseTimeDifference() - pPacketListMain->GetBaseTimeDifference();

  0006b	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp_?GetBaseTimeDifference@CPacketList@@QAEHXZ
  00071	8b c8		 mov	 ecx, eax
  00073	ff d6		 call	 esi
  00075	8b cb		 mov	 ecx, ebx
  00077	8b f8		 mov	 edi, eax
  00079	ff d6		 call	 esi
  0007b	2b f8		 sub	 edi, eax
  0007d	eb 02		 jmp	 SHORT $LN10@GetTimeDif
$LN5@GetTimeDif:
  0007f	33 ff		 xor	 edi, edi
$LN10@GetTimeDif:
  00081	8d 4d 08	 lea	 ecx, DWORD PTR _p_strRQ$[ebp]
  00084	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0008a	8b c7		 mov	 eax, edi

; 4060 : }

  0008c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0008f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00096	59		 pop	 ecx
  00097	5f		 pop	 edi
  00098	5e		 pop	 esi
  00099	5b		 pop	 ebx
  0009a	8b e5		 mov	 esp, ebp
  0009c	5d		 pop	 ebp
  0009d	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetTimeDiffWithCurrentRQ@CXScaleManagerImp@@IAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z$0:
  00000	8d 4d 08	 lea	 ecx, DWORD PTR _p_strRQ$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
  0000d	cc		 int	 3
__ehhandler$?GetTimeDiffWithCurrentRQ@CXScaleManagerImp@@IAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z:
  0000e	90		 npad	 1
  0000f	90		 npad	 1
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?GetTimeDiffWithCurrentRQ@CXScaleManagerImp@@IAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
  00026	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?GetTimeDiffWithCurrentRQ@CXScaleManagerImp@@IAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ENDP ; CXScaleManagerImp::GetTimeDiffWithCurrentRQ
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?IsEmptyData@CXScaleManagerImp@@MAEHXZ
_TEXT	SEGMENT
?IsEmptyData@CXScaleManagerImp@@MAEHXZ PROC		; CXScaleManagerImp::IsEmptyData, COMDAT
; _this$ = ecx

; 3983 : {

  00000	56		 push	 esi

; 3984 : 	for( int i = 0; i < m_nCountOfRQ; i++)

  00001	8b 71 6c	 mov	 esi, DWORD PTR [ecx+108]
  00004	33 d2		 xor	 edx, edx
  00006	85 f6		 test	 esi, esi
  00008	7e 16		 jle	 SHORT $LN3@IsEmptyDat

; 3985 : 		if( 0 <= m_pifaRQ[ i]->nLastRealDTI) return FALSE;

  0000a	8b 89 8c 00 00
	00		 mov	 ecx, DWORD PTR [ecx+140]
$LL4@IsEmptyDat:
  00010	8b 01		 mov	 eax, DWORD PTR [ecx]
  00012	83 78 28 00	 cmp	 DWORD PTR [eax+40], 0
  00016	7d 0f		 jge	 SHORT $LN8@IsEmptyDat

; 3984 : 	for( int i = 0; i < m_nCountOfRQ; i++)

  00018	42		 inc	 edx
  00019	83 c1 04	 add	 ecx, 4
  0001c	3b d6		 cmp	 edx, esi
  0001e	7c f0		 jl	 SHORT $LL4@IsEmptyDat
$LN3@IsEmptyDat:

; 3986 : 	return TRUE;

  00020	b8 01 00 00 00	 mov	 eax, 1
  00025	5e		 pop	 esi

; 3987 : }

  00026	c3		 ret	 0
$LN8@IsEmptyDat:

; 3985 : 		if( 0 <= m_pifaRQ[ i]->nLastRealDTI) return FALSE;

  00027	33 c0		 xor	 eax, eax
  00029	5e		 pop	 esi

; 3987 : }

  0002a	c3		 ret	 0
?IsEmptyData@CXScaleManagerImp@@MAEHXZ ENDP		; CXScaleManagerImp::IsEmptyData
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?SetRightMarginAndFutureTime@CXScaleManagerImp@@MAEXHH@Z
_TEXT	SEGMENT
_p_nRightMarginWidth$ = 8				; size = 4
_p_nFutureTimeCount$ = 12				; size = 4
?SetRightMarginAndFutureTime@CXScaleManagerImp@@MAEXHH@Z PROC ; CXScaleManagerImp::SetRightMarginAndFutureTime, COMDAT
; _this$ = ecx

; 236  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 237  : 	m_nRightMarginWidth = p_nRightMarginWidth * 8;

  00003	8b 45 08	 mov	 eax, DWORD PTR _p_nRightMarginWidth$[ebp]
  00006	c1 e0 03	 shl	 eax, 3
  00009	89 41 1c	 mov	 DWORD PTR [ecx+28], eax

; 238  : 	m_nFutureTimeCount = p_nFutureTimeCount;

  0000c	8b 45 0c	 mov	 eax, DWORD PTR _p_nFutureTimeCount$[ebp]
  0000f	89 81 e0 05 00
	00		 mov	 DWORD PTR [ecx+1504], eax

; 239  : }

  00015	5d		 pop	 ebp
  00016	c2 08 00	 ret	 8
?SetRightMarginAndFutureTime@CXScaleManagerImp@@MAEXHH@Z ENDP ; CXScaleManagerImp::SetRightMarginAndFutureTime
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?SetFutureTimeCount@CXScaleManagerImp@@MAEXH@Z
_TEXT	SEGMENT
_nFutureTimeCount$ = 8					; size = 4
?SetFutureTimeCount@CXScaleManagerImp@@MAEXH@Z PROC	; CXScaleManagerImp::SetFutureTimeCount, COMDAT
; _this$ = ecx

; 189  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 190  : 	m_nFutureTimeCount = nFutureTimeCount;

  00003	8b 45 08	 mov	 eax, DWORD PTR _nFutureTimeCount$[ebp]
  00006	89 81 e0 05 00
	00		 mov	 DWORD PTR [ecx+1504], eax

; 191  : }

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
?SetFutureTimeCount@CXScaleManagerImp@@MAEXH@Z ENDP	; CXScaleManagerImp::SetFutureTimeCount
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?GetFutureTimeCount@CXScaleManagerImp@@MAEHXZ
_TEXT	SEGMENT
?GetFutureTimeCount@CXScaleManagerImp@@MAEHXZ PROC	; CXScaleManagerImp::GetFutureTimeCount, COMDAT
; _this$ = ecx

; 195  : 	return m_nFutureTimeCount;

  00000	8b 81 e0 05 00
	00		 mov	 eax, DWORD PTR [ecx+1504]

; 196  : }

  00006	c3		 ret	 0
?GetFutureTimeCount@CXScaleManagerImp@@MAEHXZ ENDP	; CXScaleManagerImp::GetFutureTimeCount
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.h
;	COMDAT ?IsScrollByReal@CXScaleManagerImp@@MAEHXZ
_TEXT	SEGMENT
?IsScrollByReal@CXScaleManagerImp@@MAEHXZ PROC		; CXScaleManagerImp::IsScrollByReal, COMDAT
; _this$ = ecx

; 531  : 	virtual BOOL	IsScrollByReal( void)	{	return m_bScrollByReal;	}

  00000	8b 81 d8 05 00
	00		 mov	 eax, DWORD PTR [ecx+1496]
  00006	c3		 ret	 0
?IsScrollByReal@CXScaleManagerImp@@MAEHXZ ENDP		; CXScaleManagerImp::IsScrollByReal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?SetFlagForCalcDRIandScrollByReal@CXScaleManagerImp@@MAEXH@Z
_TEXT	SEGMENT
_p_bWithTrucated$ = 8					; size = 4
?SetFlagForCalcDRIandScrollByReal@CXScaleManagerImp@@MAEXH@Z PROC ; CXScaleManagerImp::SetFlagForCalcDRIandScrollByReal, COMDAT
; _this$ = ecx

; 3969 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3970 : 	m_bScrollByReal = TRUE;
; 3971 : 	if( p_bWithTrucated) m_bTruncatedByReal = TRUE;

  00003	83 7d 08 00	 cmp	 DWORD PTR _p_bWithTrucated$[ebp], 0
  00007	c7 81 d8 05 00
	00 01 00 00 00	 mov	 DWORD PTR [ecx+1496], 1
  00011	74 0a		 je	 SHORT $LN2@SetFlagFor
  00013	c7 81 dc 05 00
	00 01 00 00 00	 mov	 DWORD PTR [ecx+1500], 1
$LN2@SetFlagFor:

; 3972 : }

  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?SetFlagForCalcDRIandScrollByReal@CXScaleManagerImp@@MAEXH@Z ENDP ; CXScaleManagerImp::SetFlagForCalcDRIandScrollByReal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?OnUserZoomChanged@CXScaleManagerImp@@MAEXXZ
_TEXT	SEGMENT
?OnUserZoomChanged@CXScaleManagerImp@@MAEXXZ PROC	; CXScaleManagerImp::OnUserZoomChanged, COMDAT
; _this$ = ecx

; 3977 : 	if( m_bOnResizing) return;

  00000	83 b9 c8 05 00
	00 00		 cmp	 DWORD PTR [ecx+1480], 0
  00007	75 0a		 jne	 SHORT $LN1@OnUserZoom

; 3978 : 	m_bOnUserZoomChanged = TRUE;

  00009	c7 81 cc 05 00
	00 01 00 00 00	 mov	 DWORD PTR [ecx+1484], 1
$LN1@OnUserZoom:

; 3979 : }

  00013	c3		 ret	 0
?OnUserZoomChanged@CXScaleManagerImp@@MAEXXZ ENDP	; CXScaleManagerImp::OnUserZoomChanged
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?GetXFromDouble@CXScaleManagerImp@@MAEHHHNPAPAUtagAREA@CXScaleManager@@@Z
_TEXT	SEGMENT
_nCol$GSCopy$1$ = -68					; size = 4
_pparea$GSCopy$1$ = -64					; size = 4
_strType$ = -56						; size = 4
_tmResult$ = -52					; size = 36
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_nRow$ = 8						; size = 4
_nCol$ = 12						; size = 4
_dblFind$ = 16						; size = 8
_pparea$ = 24						; size = 4
?GetXFromDouble@CXScaleManagerImp@@MAEHHHNPAPAUtagAREA@CXScaleManager@@@Z PROC ; CXScaleManagerImp::GetXFromDouble, COMDAT
; _this$ = ecx

; 1792 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?GetXFromDouble@CXScaleManagerImp@@MAEHHHNPAPAUtagAREA@CXScaleManager@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 38	 sub	 esp, 56			; 00000038H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b f9		 mov	 edi, ecx

; 1793 : 	LPCTSTR lpszRQ = m_pIChartCtrl->GetMasterValueRQ(nRow, nCol);

  0002d	8b 4f 50	 mov	 ecx, DWORD PTR [edi+80]
  00030	8b 45 18	 mov	 eax, DWORD PTR _pparea$[ebp]
  00033	8b 5d 0c	 mov	 ebx, DWORD PTR _nCol$[ebp]
  00036	8b 55 08	 mov	 edx, DWORD PTR _nRow$[ebp]
  00039	89 45 c0	 mov	 DWORD PTR _pparea$GSCopy$1$[ebp], eax
  0003c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0003e	53		 push	 ebx
  0003f	52		 push	 edx
  00040	89 5d bc	 mov	 DWORD PTR _nCol$GSCopy$1$[ebp], ebx
  00043	ff 90 2c 04 00
	00		 call	 DWORD PTR [eax+1068]

; 1794 : 
; 1795 : 	CPacketRQ* lpPacketRQ = (CPacketRQ*)m_ppacketListManager->GetPacketRQ(lpszRQ);

  00049	8b 4f 48	 mov	 ecx, DWORD PTR [edi+72]
  0004c	8b d8		 mov	 ebx, eax
  0004e	53		 push	 ebx
  0004f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00051	ff 52 20	 call	 DWORD PTR [edx+32]

; 1796 : 	if(::lstrcmp(lpPacketRQ->GetPacketName(), _MTEXT( C0_DATE_TIME)))

  00054	8b 0d 54 00 00
	00		 mov	 ecx, DWORD PTR ?g_iMetaTable@@3VIMetaTable@@A+84
  0005a	ff 31		 push	 DWORD PTR [ecx]
  0005c	ff 70 10	 push	 DWORD PTR [eax+16]
  0005f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrcmpA@8
  00065	85 c0		 test	 eax, eax
  00067	0f 85 c6 00 00
	00		 jne	 $LN26@GetXFromDo

; 1797 : 		return 0;
; 1798 : 
; 1799 : 	CPacketList* pPacketList = m_ppacketListManager->GetPacketList(lpszRQ);

  0006d	8b 4f 48	 mov	 ecx, DWORD PTR [edi+72]
  00070	53		 push	 ebx
  00071	8b 01		 mov	 eax, DWORD PTR [ecx]
  00073	ff 50 1c	 call	 DWORD PTR [eax+28]

; 1800 : 	CPacket* pPacket = pPacketList->GetBaseData( _MTEXT( C0_DATE_TIME));

  00076	6a 01		 push	 1
  00078	51		 push	 ecx
  00079	8b 0d 54 00 00
	00		 mov	 ecx, DWORD PTR ?g_iMetaTable@@3VIMetaTable@@A+84
  0007f	8b d4		 mov	 edx, esp
  00081	8b f0		 mov	 esi, eax
  00083	ff 31		 push	 DWORD PTR [ecx]
  00085	8b ca		 mov	 ecx, edx
  00087	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  0008d	8b ce		 mov	 ecx, esi
  0008f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetBaseData@CPacketList@@QAEPAVCPacket@@V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@_N@Z

; 1801 : 	if(pPacket == NULL) 

  00095	85 c0		 test	 eax, eax
  00097	0f 84 96 00 00
	00		 je	 $LN26@GetXFromDo

; 1803 : 
; 1804 : 	CString strType = pPacket->GetType();

  0009d	6a 01		 push	 1
  0009f	8d 4d c8	 lea	 ecx, DWORD PTR _strType$[ebp]
  000a2	51		 push	 ecx
  000a3	8b c8		 mov	 ecx, eax
  000a5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetType@CPacket@@QAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@_N@Z

; 1805 : 
; 1806 : 	int	nRQ = GetRQIndexFromString( lpszRQ);

  000ab	51		 push	 ecx
  000ac	8b cc		 mov	 ecx, esp
  000ae	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  000b5	53		 push	 ebx
  000b6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  000bc	8b 07		 mov	 eax, DWORD PTR [edi]
  000be	8b cf		 mov	 ecx, edi
  000c0	ff 50 04	 call	 DWORD PTR [eax+4]
  000c3	8b c8		 mov	 ecx, eax

; 1807 : 	tm tmResult = { 0, 0, 0, 0, 0, 0, 0, 0, -1};	//[A00000554]alzioyes:20110530  .

  000c5	c7 45 ec ff ff
	ff ff		 mov	 DWORD PTR _tmResult$[ebp+32], -1
  000cc	0f 57 c0	 xorps	 xmm0, xmm0
  000cf	0f 11 45 cc	 movups	 XMMWORD PTR _tmResult$[ebp], xmm0
  000d3	0f 11 45 dc	 movups	 XMMWORD PTR _tmResult$[ebp+16], xmm0

; 1808 : 	
; 1809 : 	// 20080925 JS.Kim	   Scale .
; 1810 : 	// 2011.01.27 by SYS >>  YYYY()  : / 14Byte  (YYYYMMDDhhmmss)
; 1811 : 	//time_t timeFind = GetTimeFromTimeValue( ( __int64)dblFind, strType, 0 <= nRQ ? m_pifaRQ[ nRQ] : NULL, tmResult, lpszRQ);
; 1812 : 	//CScaleBaseData::HORZSCALEDRAWERTYPE eDateUnit = (CScaleBaseData::HORZSCALEDRAWERTYPE)pPacket->GetDateUnitType();
; 1813 : 	time_t timeFind = GetTimeFromTimeValue( ( __int64)dblFind, strType, 0 <= nRQ ? m_pifaRQ[ nRQ] : NULL, tmResult, lpszRQ);

  000d7	85 c9		 test	 ecx, ecx
  000d9	78 0b		 js	 SHORT $LN5@GetXFromDo
  000db	8b 87 8c 00 00
	00		 mov	 eax, DWORD PTR [edi+140]
  000e1	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
  000e4	eb 02		 jmp	 SHORT $LN6@GetXFromDo
$LN5@GetXFromDo:
  000e6	33 c0		 xor	 eax, eax
$LN6@GetXFromDo:
  000e8	6a 00		 push	 0
  000ea	53		 push	 ebx
  000eb	8d 4d cc	 lea	 ecx, DWORD PTR _tmResult$[ebp]
  000ee	51		 push	 ecx
  000ef	50		 push	 eax
  000f0	51		 push	 ecx
  000f1	8d 45 c8	 lea	 eax, DWORD PTR _strType$[ebp]
  000f4	8b cc		 mov	 ecx, esp
  000f6	50		 push	 eax
  000f7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z
  000fd	f2 0f 10 45 10	 movsd	 xmm0, QWORD PTR _dblFind$[ebp]
  00102	e8 00 00 00 00	 call	 __dtol3
  00107	52		 push	 edx
  00108	50		 push	 eax
  00109	8b cf		 mov	 ecx, edi
  0010b	e8 00 00 00 00	 call	 ?GetTimeFromTimeValue@CXScaleManagerImp@@IAE_J_KV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAUtagRQ_INFO@1@AAUtm@@PBDPAVCMapTimeToLong@@@Z ; CXScaleManagerImp::GetTimeFromTimeValue

; 1814 : 	// 2011.01.27 by SYS <<
; 1815 : 
; 1816 : 
; 1817 : 	return GetXFromTime( nCol, timeFind, pparea, TRUE);

  00110	8b 37		 mov	 esi, DWORD PTR [edi]
  00112	8b cf		 mov	 ecx, edi
  00114	6a 01		 push	 1
  00116	ff 75 c0	 push	 DWORD PTR _pparea$GSCopy$1$[ebp]
  00119	52		 push	 edx
  0011a	50		 push	 eax
  0011b	ff 75 bc	 push	 DWORD PTR _nCol$GSCopy$1$[ebp]
  0011e	ff 96 30 01 00
	00		 call	 DWORD PTR [esi+304]
  00124	8d 4d c8	 lea	 ecx, DWORD PTR _strType$[ebp]
  00127	8b f0		 mov	 esi, eax
  00129	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0012f	8b c6		 mov	 eax, esi
  00131	eb 02		 jmp	 SHORT $LN1@GetXFromDo
$LN26@GetXFromDo:

; 1802 : 		return 0;

  00133	33 c0		 xor	 eax, eax
$LN1@GetXFromDo:

; 1818 : }

  00135	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00138	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0013f	59		 pop	 ecx
  00140	5f		 pop	 edi
  00141	5e		 pop	 esi
  00142	5b		 pop	 ebx
  00143	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00146	33 cd		 xor	 ecx, ebp
  00148	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0014d	8b e5		 mov	 esp, ebp
  0014f	5d		 pop	 ebp
  00150	c2 14 00	 ret	 20			; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetXFromDouble@CXScaleManagerImp@@MAEHHHNPAPAUtagAREA@CXScaleManager@@@Z$1:
  00000	8d 4d c8	 lea	 ecx, DWORD PTR _strType$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
  0000d	cc		 int	 3
__ehhandler$?GetXFromDouble@CXScaleManagerImp@@MAEHHHNPAPAUtagAREA@CXScaleManager@@@Z:
  0000e	90		 npad	 1
  0000f	90		 npad	 1
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00024	33 c8		 xor	 ecx, eax
  00026	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?GetXFromDouble@CXScaleManagerImp@@MAEHHHNPAPAUtagAREA@CXScaleManager@@@Z
  00030	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?GetXFromDouble@CXScaleManagerImp@@MAEHHHNPAPAUtagAREA@CXScaleManager@@@Z ENDP ; CXScaleManagerImp::GetXFromDouble
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?GetDoubleFromX@CXScaleManagerImp@@MAENHHHPAHPAPAUtagAREA@CXScaleManager@@PBD@Z
_TEXT	SEGMENT
_nRow$ = 8						; size = 4
_nCol$ = 12						; size = 4
_nCursor_x$ = 16					; size = 4
_pnBlockColumn$ = 20					; size = 4
_pparea$ = 24						; size = 4
_pPacket$1$ = 28					; size = 4
_p_szRQ$ = 28						; size = 4
?GetDoubleFromX@CXScaleManagerImp@@MAENHHHPAHPAPAUtagAREA@CXScaleManager@@PBD@Z PROC ; CXScaleManagerImp::GetDoubleFromX, COMDAT
; _this$ = ecx

; 1763 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 1764 : 	LPCTSTR lpszRQ = p_szRQ;

  00005	8b 75 1c	 mov	 esi, DWORD PTR _p_szRQ$[ebp]
  00008	57		 push	 edi
  00009	8b f9		 mov	 edi, ecx

; 1765 : 	if( lpszRQ) if( !*lpszRQ) lpszRQ = NULL;

  0000b	85 f6		 test	 esi, esi
  0000d	74 05		 je	 SHORT $LN17@GetDoubleF
  0000f	80 3e 00	 cmp	 BYTE PTR [esi], 0
  00012	75 13		 jne	 SHORT $LN4@GetDoubleF
$LN17@GetDoubleF:

; 1766 : 	if( !lpszRQ) lpszRQ = m_pIChartCtrl->GetMasterValueRQ( nRow, nCol);

  00014	8b 4f 50	 mov	 ecx, DWORD PTR [edi+80]
  00017	ff 75 0c	 push	 DWORD PTR _nCol$[ebp]
  0001a	ff 75 08	 push	 DWORD PTR _nRow$[ebp]
  0001d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0001f	ff 90 2c 04 00
	00		 call	 DWORD PTR [eax+1068]
  00025	8b f0		 mov	 esi, eax
$LN4@GetDoubleF:

; 1767 : 
; 1768 : 	CPacketRQ* lpPacketRQ = (CPacketRQ*)m_ppacketListManager->GetPacketRQ(lpszRQ);

  00027	8b 4f 48	 mov	 ecx, DWORD PTR [edi+72]
  0002a	56		 push	 esi
  0002b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0002d	ff 52 20	 call	 DWORD PTR [edx+32]

; 1769 : 	if(::lstrcmp(lpPacketRQ->GetPacketName(), _MTEXT( C0_DATE_TIME)))

  00030	8b 0d 54 00 00
	00		 mov	 ecx, DWORD PTR ?g_iMetaTable@@3VIMetaTable@@A+84
  00036	ff 31		 push	 DWORD PTR [ecx]
  00038	ff 70 10	 push	 DWORD PTR [eax+16]
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrcmpA@8
  00041	85 c0		 test	 eax, eax
  00043	0f 85 ac 00 00
	00		 jne	 $LN18@GetDoubleF

; 1770 : 		return 0.;
; 1771 : 
; 1772 : 	CPacketList* pPacketList = m_ppacketListManager->GetPacketList(lpszRQ);

  00049	8b 4f 48	 mov	 ecx, DWORD PTR [edi+72]
  0004c	56		 push	 esi
  0004d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0004f	ff 50 1c	 call	 DWORD PTR [eax+28]

; 1773 : 	CPacket* pPacket = pPacketList->GetBaseData( _MTEXT( C0_DATE_TIME));

  00052	6a 01		 push	 1
  00054	51		 push	 ecx
  00055	8b 0d 54 00 00
	00		 mov	 ecx, DWORD PTR ?g_iMetaTable@@3VIMetaTable@@A+84
  0005b	8b d4		 mov	 edx, esp
  0005d	8b f0		 mov	 esi, eax
  0005f	ff 31		 push	 DWORD PTR [ecx]
  00061	8b ca		 mov	 ecx, edx
  00063	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  00069	8b ce		 mov	 ecx, esi
  0006b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetBaseData@CPacketList@@QAEPAVCPacket@@V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@_N@Z
  00071	89 45 1c	 mov	 DWORD PTR _pPacket$1$[ebp], eax

; 1774 : 	if(pPacket == NULL) 

  00074	85 c0		 test	 eax, eax
  00076	74 7d		 je	 SHORT $LN18@GetDoubleF

; 1775 : 		return 0.;
; 1776 : 
; 1777 : 	int nDRI = GetDRInFromPt( nCursor_x, pnBlockColumn, pparea, TRUE);

  00078	8b 07		 mov	 eax, DWORD PTR [edi]
  0007a	8b cf		 mov	 ecx, edi
  0007c	6a 00		 push	 0
  0007e	6a 01		 push	 1
  00080	ff 75 18	 push	 DWORD PTR _pparea$[ebp]
  00083	ff 75 14	 push	 DWORD PTR _pnBlockColumn$[ebp]
  00086	ff 75 10	 push	 DWORD PTR _nCursor_x$[ebp]
  00089	ff 90 14 01 00
	00		 call	 DWORD PTR [eax+276]
  0008f	8b f0		 mov	 esi, eax

; 1778 : 	// (2009/5/15 - Seung-Won, Bae) for future DRI.
; 1779 : 	if( nDRI < 0) nDRI = 0;

  00091	85 f6		 test	 esi, esi
  00093	79 04		 jns	 SHORT $LN7@GetDoubleF
  00095	33 f6		 xor	 esi, esi
  00097	eb 1d		 jmp	 SHORT $LN9@GetDoubleF
$LN7@GetDoubleF:

; 1780 : 	else if( m_blTimefDRI.GetItemCount() <= nDRI) nDRI = m_blTimefDRI.GetItemCount() - 1;

  00099	8d 8f ac 00 00
	00		 lea	 ecx, DWORD PTR [edi+172]
  0009f	e8 00 00 00 00	 call	 ?GetItemCount@CDataBlockListUNK@@QAEHXZ ; CDataBlockListUNK::GetItemCount
  000a4	3b c6		 cmp	 eax, esi
  000a6	7f 0e		 jg	 SHORT $LN9@GetDoubleF
  000a8	8d 8f ac 00 00
	00		 lea	 ecx, DWORD PTR [edi+172]
  000ae	e8 00 00 00 00	 call	 ?GetItemCount@CDataBlockListUNK@@QAEHXZ ; CDataBlockListUNK::GetItemCount
  000b3	8d 70 ff	 lea	 esi, DWORD PTR [eax-1]
$LN9@GetDoubleF:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 215  : 	T*	GetAt( int nIndex)	{	return ( T*)GetAtUNK( nIndex);	}

  000b6	56		 push	 esi
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 1782 : 	m_pTReturn = m_blTimefDRI.GetAt( nDRI);

  000b7	8d 8f ac 00 00
	00		 lea	 ecx, DWORD PTR [edi+172]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 215  : 	T*	GetAt( int nIndex)	{	return ( T*)GetAtUNK( nIndex);	}

  000bd	e8 00 00 00 00	 call	 ?GetAtUNK@CDataBlockListUNK@@QAEPAXH@Z ; CDataBlockListUNK::GetAtUNK
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 1782 : 	m_pTReturn = m_blTimefDRI.GetAt( nDRI);

  000c2	89 47 5c	 mov	 DWORD PTR [edi+92], eax

; 1783 : 	if( m_pTReturn) timeDRI = *m_pTReturn;

  000c5	85 c0		 test	 eax, eax
  000c7	74 2c		 je	 SHORT $LN18@GetDoubleF
  000c9	8b 18		 mov	 ebx, DWORD PTR [eax]
  000cb	8b 70 04	 mov	 esi, DWORD PTR [eax+4]

; 1784 : 	if( 0 == timeDRI) return 0;

  000ce	85 db		 test	 ebx, ebx
  000d0	75 04		 jne	 SHORT $LN19@GetDoubleF
  000d2	85 f6		 test	 esi, esi
  000d4	74 1f		 je	 SHORT $LN18@GetDoubleF
$LN19@GetDoubleF:

; 1785 : 	return GetTimeValueFromTime( timeDRI, pPacket->GetType());

  000d6	51		 push	 ecx
  000d7	8b 4d 1c	 mov	 ecx, DWORD PTR _pPacket$1$[ebp]
  000da	8b c4		 mov	 eax, esp
  000dc	6a 01		 push	 1
  000de	50		 push	 eax
  000df	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetType@CPacket@@QAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@_N@Z
  000e5	56		 push	 esi
  000e6	53		 push	 ebx
  000e7	8b cf		 mov	 ecx, edi
  000e9	e8 00 00 00 00	 call	 ?GetTimeValueFromTime@CXScaleManagerImp@@IAEN_JV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ; CXScaleManagerImp::GetTimeValueFromTime

; 1786 : }

  000ee	5f		 pop	 edi
  000ef	5e		 pop	 esi
  000f0	5b		 pop	 ebx
  000f1	5d		 pop	 ebp
  000f2	c2 18 00	 ret	 24			; 00000018H
$LN18@GetDoubleF:

; 1784 : 	if( 0 == timeDRI) return 0;

  000f5	d9 ee		 fldz

; 1786 : }

  000f7	5f		 pop	 edi
  000f8	5e		 pop	 esi
  000f9	5b		 pop	 ebx
  000fa	5d		 pop	 ebp
  000fb	c2 18 00	 ret	 24			; 00000018H
?GetDoubleFromX@CXScaleManagerImp@@MAENHHHPAHPAPAUtagAREA@CXScaleManager@@PBD@Z ENDP ; CXScaleManagerImp::GetDoubleFromX
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?GetTimeFromX@CXScaleManagerImp@@MAE_JHPAHPAPAUtagAREA@CXScaleManager@@@Z
_TEXT	SEGMENT
_timeResult$ = -8					; size = 8
_nCursor_x$ = 8						; size = 4
_pnBlockColumn$ = 12					; size = 4
_pparea$ = 16						; size = 4
?GetTimeFromX@CXScaleManagerImp@@MAE_JHPAHPAPAUtagAREA@CXScaleManager@@@Z PROC ; CXScaleManagerImp::GetTimeFromX, COMDAT
; _this$ = ecx

; 1725 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi

; 1726 : 	time_t timeResult;
; 1727 : 
; 1728 : 	int nDRI = GetDRInFromPt(nCursor_x, pnBlockColumn, pparea);

  00007	6a 00		 push	 0
  00009	6a 00		 push	 0
  0000b	ff 75 10	 push	 DWORD PTR _pparea$[ebp]
  0000e	8b f1		 mov	 esi, ecx
  00010	ff 75 0c	 push	 DWORD PTR _pnBlockColumn$[ebp]
  00013	ff 75 08	 push	 DWORD PTR _nCursor_x$[ebp]
  00016	8b 06		 mov	 eax, DWORD PTR [esi]
  00018	ff 90 14 01 00
	00		 call	 DWORD PTR [eax+276]

; 1729 : 	GetTimeFromDRI(nDRI, &timeResult);

  0001e	8b 16		 mov	 edx, DWORD PTR [esi]
  00020	8d 4d f8	 lea	 ecx, DWORD PTR _timeResult$[ebp]
  00023	51		 push	 ecx
  00024	50		 push	 eax
  00025	8b ce		 mov	 ecx, esi
  00027	ff 92 ec 00 00
	00		 call	 DWORD PTR [edx+236]

; 1730 : 
; 1731 : 	return timeResult;

  0002d	8b 45 f8	 mov	 eax, DWORD PTR _timeResult$[ebp]
  00030	8b 55 fc	 mov	 edx, DWORD PTR _timeResult$[ebp+4]
  00033	5e		 pop	 esi

; 1732 : }

  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c2 0c 00	 ret	 12			; 0000000cH
?GetTimeFromX@CXScaleManagerImp@@MAE_JHPAHPAPAUtagAREA@CXScaleManager@@@Z ENDP ; CXScaleManagerImp::GetTimeFromX
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?GetRQInfosFromPt@CXScaleManagerImp@@MAEHHAAHAAVCStringArray@@AAV?$CArray@HH@@PAUtagAREA@CXScaleManager@@@Z
_TEXT	SEGMENT
_nDRI$1$ = 8						; size = 4
_nCursor_x$ = 8						; size = 4
_nDTI$1 = 12						; size = 4
_nBlockColumn$ = 12					; size = 4
_saRQ$ = 16						; size = 4
_naDTI$ = 20						; size = 4
_parea$ = 24						; size = 4
?GetRQInfosFromPt@CXScaleManagerImp@@MAEHHAAHAAVCStringArray@@AAV?$CArray@HH@@PAUtagAREA@CXScaleManager@@@Z PROC ; CXScaleManagerImp::GetRQInfosFromPt, COMDAT
; _this$ = ecx

; 1700 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl

; 286  : 	{ SetSize(0); }

  00006	6a ff		 push	 -1
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 1700 : {

  00008	8b f9		 mov	 edi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl

; 286  : 	{ SetSize(0); }

  0000a	8b 4d 10	 mov	 ecx, DWORD PTR _saRQ$[ebp]
  0000d	6a 00		 push	 0
  0000f	e8 00 00 00 00	 call	 ?SetSize@CStringArray@@QAEXHH@Z ; CStringArray::SetSize
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 381  : 		if (m_pData != NULL)

  00014	8b 5d 14	 mov	 ebx, DWORD PTR _naDTI$[ebp]
  00017	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0001a	85 c0		 test	 eax, eax
  0001c	74 10		 je	 SHORT $LN32@GetRQInfos

; 382  : 		{
; 383  : 			for( int i = 0; i < m_nSize; i++ )
; 384  : 				(m_pData + i)->~TYPE();
; 385  : 			delete[] (BYTE*)m_pData;

  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00024	83 c4 04	 add	 esp, 4

; 386  : 			m_pData = NULL;

  00027	c7 43 04 00 00
	00 00		 mov	 DWORD PTR [ebx+4], 0
$LN32@GetRQInfos:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 1704 : 	int nDRI = GetDRInFromPt( nCursor_x, &nBlockColumn);

  0002e	8b 75 0c	 mov	 esi, DWORD PTR _nBlockColumn$[ebp]
  00031	8b cf		 mov	 ecx, edi
  00033	6a 00		 push	 0
  00035	6a 00		 push	 0
  00037	6a 00		 push	 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 388  : 		m_nSize = m_nMaxSize = 0;

  00039	c7 43 0c 00 00
	00 00		 mov	 DWORD PTR [ebx+12], 0
  00040	c7 43 08 00 00
	00 00		 mov	 DWORD PTR [ebx+8], 0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 1704 : 	int nDRI = GetDRInFromPt( nCursor_x, &nBlockColumn);

  00047	8b 07		 mov	 eax, DWORD PTR [edi]
  00049	56		 push	 esi
  0004a	ff 75 08	 push	 DWORD PTR _nCursor_x$[ebp]
  0004d	ff 90 14 01 00
	00		 call	 DWORD PTR [eax+276]

; 1705 : 	GetAreaFromDRI_Copy( nBlockColumn, nDRI, *parea);

  00053	ff 75 18	 push	 DWORD PTR _parea$[ebp]
  00056	8b cf		 mov	 ecx, edi
  00058	89 45 08	 mov	 DWORD PTR _nDRI$1$[ebp], eax
  0005b	50		 push	 eax
  0005c	ff 36		 push	 DWORD PTR [esi]
  0005e	e8 00 00 00 00	 call	 ?GetAreaFromDRI_Copy@CXScaleManagerImp@@IAEXHHAAUtagAREA@CXScaleManager@@@Z ; CXScaleManagerImp::GetAreaFromDRI_Copy

; 1707 : 	for(int nRQ = 0; nRQ < m_nCountOfRQ; nRQ++)

  00063	33 f6		 xor	 esi, esi
  00065	39 77 6c	 cmp	 DWORD PTR [edi+108], esi
  00068	0f 8e 7f 00 00
	00		 jle	 $LN99@GetRQInfos
  0006e	66 90		 npad	 2
$LL4@GetRQInfos:

; 1711 : 		m_pIReturn = m_pblaDTIfDRI[nRQ]->GetAt( nDRI);

  00070	8b 87 a8 00 00
	00		 mov	 eax, DWORD PTR [edi+168]
  00076	8d 0c b5 00 00
	00 00		 lea	 ecx, DWORD PTR [esi*4]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 215  : 	T*	GetAt( int nIndex)	{	return ( T*)GetAtUNK( nIndex);	}

  0007d	ff 75 08	 push	 DWORD PTR _nDRI$1$[ebp]
  00080	8b 0c 01	 mov	 ecx, DWORD PTR [ecx+eax]
  00083	e8 00 00 00 00	 call	 ?GetAtUNK@CDataBlockListUNK@@QAEPAXH@Z ; CDataBlockListUNK::GetAtUNK
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 1711 : 		m_pIReturn = m_pblaDTIfDRI[nRQ]->GetAt( nDRI);

  00088	89 47 60	 mov	 DWORD PTR [edi+96], eax

; 1712 : 		if( m_pIReturn) nDTI = nDTI_Org = *m_pIReturn;

  0008b	85 c0		 test	 eax, eax
  0008d	74 07		 je	 SHORT $LN100@GetRQInfos
  0008f	8b 00		 mov	 eax, DWORD PTR [eax]
  00091	89 45 0c	 mov	 DWORD PTR _nDTI$1[ebp], eax
  00094	eb 03		 jmp	 SHORT $LN96@GetRQInfos
$LN100@GetRQInfos:
  00096	8b 45 0c	 mov	 eax, DWORD PTR _nDTI$1[ebp]
$LN96@GetRQInfos:

; 1713 : 
; 1714 : 		if(nDTI >= 0)

  00099	85 c0		 test	 eax, eax
  0009b	78 4a		 js	 SHORT $LN2@GetRQInfos
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl

; 289  : 		if( nIndex < 0 || nIndex >= m_nSize )

  0009d	85 f6		 test	 esi, esi
  0009f	78 5e		 js	 SHORT $LN77@GetRQInfos
  000a1	3b b7 80 00 00
	00		 cmp	 esi, DWORD PTR [edi+128]
  000a7	7d 56		 jge	 SHORT $LN77@GetRQInfos

; 291  : 		return m_pData[nIndex]; }

  000a9	8b 47 7c	 mov	 eax, DWORD PTR [edi+124]
  000ac	8d 0c b5 00 00
	00 00		 lea	 ecx, DWORD PTR [esi*4]
  000b3	03 c1		 add	 eax, ecx

; 321  : 		SetAtGrow(nIndex, newElement);

  000b5	50		 push	 eax
  000b6	8b 45 10	 mov	 eax, DWORD PTR _saRQ$[ebp]
  000b9	8b c8		 mov	 ecx, eax
  000bb	ff 70 08	 push	 DWORD PTR [eax+8]
  000be	e8 00 00 00 00	 call	 ?SetAtGrow@CStringArray@@QAEXHABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ; CStringArray::SetAtGrow
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 333  : 	{ INT_PTR nIndex = m_nSize;

  000c3	8b 5b 08	 mov	 ebx, DWORD PTR [ebx+8]

; 538  : 	if(nIndex < 0)

  000c6	85 db		 test	 ebx, ebx
  000c8	78 35		 js	 SHORT $LN77@GetRQInfos

; 539  : 		AfxThrowInvalidArgException();
; 540  : 
; 541  : 	if (nIndex >= m_nSize)
; 542  : 		SetSize(nIndex+1, -1);

  000ca	8b 4d 14	 mov	 ecx, DWORD PTR _naDTI$[ebp]
  000cd	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
  000d0	6a ff		 push	 -1
  000d2	50		 push	 eax
  000d3	e8 00 00 00 00	 call	 ?SetSize@?$CArray@HH@@QAEXHH@Z ; CArray<int,int>::SetSize

; 543  : 	m_pData[nIndex] = newElement;

  000d8	8b 4d 14	 mov	 ecx, DWORD PTR _naDTI$[ebp]
  000db	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  000de	8b 4d 0c	 mov	 ecx, DWORD PTR _nDTI$1[ebp]
  000e1	89 0c 98	 mov	 DWORD PTR [eax+ebx*4], ecx
  000e4	8b 5d 14	 mov	 ebx, DWORD PTR _naDTI$[ebp]
$LN2@GetRQInfos:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 1707 : 	for(int nRQ = 0; nRQ < m_nCountOfRQ; nRQ++)

  000e7	46		 inc	 esi
  000e8	3b 77 6c	 cmp	 esi, DWORD PTR [edi+108]
  000eb	7c 83		 jl	 SHORT $LL4@GetRQInfos
$LN99@GetRQInfos:

; 1715 : 		{
; 1716 : 			saRQ.Add(m_saRQ.GetAt(nRQ));
; 1717 : 			naDTI.Add(nDTI);
; 1718 : 		}
; 1719 : 	}
; 1720 : 	
; 1721 : 	return (saRQ.GetSize() > 0);

  000ed	8b 4d 10	 mov	 ecx, DWORD PTR _saRQ$[ebp]
  000f0	33 c0		 xor	 eax, eax
  000f2	5f		 pop	 edi
  000f3	5e		 pop	 esi
  000f4	5b		 pop	 ebx
  000f5	39 41 08	 cmp	 DWORD PTR [ecx+8], eax
  000f8	0f 9f c0	 setg	 al

; 1722 : }

  000fb	5d		 pop	 ebp
  000fc	c2 14 00	 ret	 20			; 00000014H
$LN77@GetRQInfos:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl

; 290  : 			AfxThrowInvalidArgException();

  000ff	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN101@GetRQInfos:
  00104	cc		 int	 3
?GetRQInfosFromPt@CXScaleManagerImp@@MAEHHAAHAAVCStringArray@@AAV?$CArray@HH@@PAUtagAREA@CXScaleManager@@@Z ENDP ; CXScaleManagerImp::GetRQInfosFromPt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?GetAREAfRQnDTI@CXScaleManagerImp@@MAEHHHPAUtagAREA@CXScaleManager@@@Z
_TEXT	SEGMENT
_nDTI$ = 8						; size = 4
_nBlockColumn$ = 12					; size = 4
_parea$ = 16						; size = 4
?GetAREAfRQnDTI@CXScaleManagerImp@@MAEHHHPAUtagAREA@CXScaleManager@@@Z PROC ; CXScaleManagerImp::GetAREAfRQnDTI, COMDAT
; _this$ = ecx

; 1691 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 1692 : 	if(m_ppacketListManager)

  00005	ff 75 10	 push	 DWORD PTR _parea$[ebp]
  00008	8b f9		 mov	 edi, ecx
  0000a	ff 75 0c	 push	 DWORD PTR _nBlockColumn$[ebp]
  0000d	ff 75 08	 push	 DWORD PTR _nDTI$[ebp]
  00010	83 7f 48 00	 cmp	 DWORD PTR [edi+72], 0
  00014	74 13		 je	 SHORT $LN2@GetAREAfRQ

; 1693 : 		return GetAREAfRQnDTI( m_pIChartCtrl->GetCurrentRQ(), nDTI, nBlockColumn, parea);

  00016	8b 4f 50	 mov	 ecx, DWORD PTR [edi+80]
  00019	51		 push	 ecx
  0001a	8b f4		 mov	 esi, esp
  0001c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0001e	ff 90 d8 02 00
	00		 call	 DWORD PTR [eax+728]
  00024	50		 push	 eax
  00025	8b ce		 mov	 ecx, esi
  00027	eb 08		 jmp	 SHORT $LN7@GetAREAfRQ
$LN2@GetAREAfRQ:

; 1694 : 	else
; 1695 : 		return GetAREAfRQnDTI(_T("DEFAULT"), nDTI, nBlockColumn, parea);

  00029	51		 push	 ecx
  0002a	8b cc		 mov	 ecx, esp
  0002c	68 00 00 00 00	 push	 OFFSET ??_C@_07MGCPDNLD@DEFAULT@
$LN7@GetAREAfRQ:

; 1696 : }

  00031	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  00037	8b 07		 mov	 eax, DWORD PTR [edi]
  00039	8b cf		 mov	 ecx, edi
  0003b	ff 90 d0 00 00
	00		 call	 DWORD PTR [eax+208]
  00041	5f		 pop	 edi
  00042	5e		 pop	 esi
  00043	5d		 pop	 ebp
  00044	c2 0c 00	 ret	 12			; 0000000cH
?GetAREAfRQnDTI@CXScaleManagerImp@@MAEHHHPAUtagAREA@CXScaleManager@@@Z ENDP ; CXScaleManagerImp::GetAREAfRQnDTI
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?GetAREAfRQnDTI@CXScaleManagerImp@@MAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HHPAUtagAREA@CXScaleManager@@@Z
_TEXT	SEGMENT
_nDTI_Total$1$ = -24					; size = 4
_pifRQ$1$ = -20						; size = 4
_parea_Next$2 = -20					; size = 4
_nRQ$1$ = -16						; size = 4
_parea_Cur$3 = -16					; size = 4
__$EHRec$ = -12						; size = 12
_strRQ$ = 8						; size = 4
_nDRI_Cur$1$ = 12					; size = 4
_nDTI$ = 12						; size = 4
_nDRI_Next$ = 16					; size = 4
_nDRI_Cur$ = 16						; size = 4
_nBlockColumn$ = 16					; size = 4
_pblDRIfDTI$1$ = 20					; size = 4
_parea_Cur$4 = 20					; size = 4
_parea_Cur$5 = 20					; size = 4
_parea$ = 20						; size = 4
?GetAREAfRQnDTI@CXScaleManagerImp@@MAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HHPAUtagAREA@CXScaleManager@@@Z PROC ; CXScaleManagerImp::GetAREAfRQnDTI, COMDAT
; _this$ = ecx

; 1598 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?GetAREAfRQnDTI@CXScaleManagerImp@@MAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HHPAUtagAREA@CXScaleManager@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b f1		 mov	 esi, ecx

; 1599 : 	*parea = m_areaNONE;

  0002a	8b 5d 14	 mov	 ebx, DWORD PTR _parea$[ebp]
  0002d	8b 46 3c	 mov	 eax, DWORD PTR [esi+60]

; 1600 : 
; 1601 : 	int nDRI_Cur, nDRI_Next;
; 1602 : 
; 1603 : 	CDataBlockList<int>* pblDRIfDTI = NULL;
; 1604 : 	int	nRQ = GetRQIndexFromString( strRQ);

  00030	51		 push	 ecx
  00031	8b cc		 mov	 ecx, esp
  00033	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003a	89 03		 mov	 DWORD PTR [ebx], eax
  0003c	66 8b 46 40	 mov	 ax, WORD PTR [esi+64]
  00040	66 89 43 04	 mov	 WORD PTR [ebx+4], ax
  00044	8d 45 08	 lea	 eax, DWORD PTR _strRQ$[ebp]
  00047	50		 push	 eax
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z
  0004e	8b 06		 mov	 eax, DWORD PTR [esi]
  00050	8b ce		 mov	 ecx, esi
  00052	ff 50 04	 call	 DWORD PTR [eax+4]
  00055	8b d0		 mov	 edx, eax
  00057	89 55 f0	 mov	 DWORD PTR _nRQ$1$[ebp], edx

; 1605 : 	if( 0 <= nRQ) pblDRIfDTI = m_pblaDRIfDTI[ nRQ];

  0005a	85 d2		 test	 edx, edx
  0005c	78 14		 js	 SHORT $LN2@GetAREAfRQ
  0005e	8b 8e a0 00 00
	00		 mov	 ecx, DWORD PTR [esi+160]
  00064	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]

; 1608 : 	if( 0 <= nRQ) pifRQ = m_pifaRQ[ nRQ];

  00067	8b 8e 8c 00 00
	00		 mov	 ecx, DWORD PTR [esi+140]
  0006d	8b 0c 91	 mov	 ecx, DWORD PTR [ecx+edx*4]
  00070	eb 04		 jmp	 SHORT $LN48@GetAREAfRQ
$LN2@GetAREAfRQ:

; 1606 : 
; 1607 : 	RQ_INFO* pifRQ = NULL;

  00072	33 c9		 xor	 ecx, ecx
  00074	33 c0		 xor	 eax, eax
$LN48@GetAREAfRQ:

; 1609 : 	
; 1610 : 	int nDTI_Total = pblDRIfDTI->GetItemCount();

  00076	89 4d ec	 mov	 DWORD PTR _pifRQ$1$[ebp], ecx
  00079	8b c8		 mov	 ecx, eax
  0007b	89 45 14	 mov	 DWORD PTR _pblDRIfDTI$1$[ebp], eax
  0007e	e8 00 00 00 00	 call	 ?GetItemCount@CDataBlockListUNK@@QAEHXZ ; CDataBlockListUNK::GetItemCount

; 1611 : 	if( 0 <= nDTI && nDTI < nDTI_Total - 1)	// (2009/2/20 - Seung-Won, Bae) -1 is end mark.

  00083	8b 7d 0c	 mov	 edi, DWORD PTR _nDTI$[ebp]
  00086	89 45 e8	 mov	 DWORD PTR _nDTI_Total$1$[ebp], eax
  00089	85 ff		 test	 edi, edi
  0008b	0f 88 59 01 00
	00		 js	 $LN50@GetAREAfRQ
  00091	8d 48 ff	 lea	 ecx, DWORD PTR [eax-1]
  00094	3b f9		 cmp	 edi, ecx
  00096	0f 8d 4a 01 00
	00		 jge	 $LN4@GetAREAfRQ

; 1612 : 	{
; 1613 : 		if( pifRQ->nDTI_Start_Data <= nDTI && nDTI <= pifRQ->nDTI_End_Data)

  0009c	8b 45 ec	 mov	 eax, DWORD PTR _pifRQ$1$[ebp]
  0009f	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  000a2	3b d7		 cmp	 edx, edi
  000a4	7f 3d		 jg	 SHORT $LN6@GetAREAfRQ
  000a6	3b 78 10	 cmp	 edi, DWORD PTR [eax+16]
  000a9	7f 38		 jg	 SHORT $LN6@GetAREAfRQ

; 1614 : 		{
; 1615 : 			CDataBlockList< AREA> *pblAreafDTI = NULL;
; 1616 : 			if( 0 <= nRQ) pblAreafDTI = m_pblaAreafDTI[ nBlockColumn][ nRQ];

  000ab	8b 4d f0	 mov	 ecx, DWORD PTR _nRQ$1$[ebp]
  000ae	33 c0		 xor	 eax, eax
  000b0	85 c9		 test	 ecx, ecx
  000b2	78 0d		 js	 SHORT $LN8@GetAREAfRQ
  000b4	8b 45 10	 mov	 eax, DWORD PTR _nBlockColumn$[ebp]
  000b7	8b 84 86 90 05
	00 00		 mov	 eax, DWORD PTR [esi+eax*4+1424]
  000be	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
$LN8@GetAREAfRQ:

; 1617 : 
; 1618 : 			int nDTI_View = nDTI - pifRQ->nDTI_Start_Data;

  000c1	2b fa		 sub	 edi, edx

; 1619 : 
; 1620 : 			m_pAReturn = ( PAREA)pblAreafDTI->GetAtUNK( nDTI_View);

  000c3	8b c8		 mov	 ecx, eax
  000c5	57		 push	 edi
  000c6	e8 00 00 00 00	 call	 ?GetAtUNK@CDataBlockListUNK@@QAEPAXH@Z ; CDataBlockListUNK::GetAtUNK
  000cb	89 46 64	 mov	 DWORD PTR [esi+100], eax

; 1621 : 			if( m_pAReturn) *parea = *m_pAReturn;

  000ce	85 c0		 test	 eax, eax
  000d0	0f 84 5a 01 00
	00		 je	 $LN22@GetAREAfRQ
  000d6	8b 08		 mov	 ecx, DWORD PTR [eax]
  000d8	89 0b		 mov	 DWORD PTR [ebx], ecx
  000da	66 8b 40 04	 mov	 ax, WORD PTR [eax+4]

; 1622 : 		}

  000de	e9 49 01 00 00	 jmp	 $LN51@GetAREAfRQ
$LN6@GetAREAfRQ:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 215  : 	T*	GetAt( int nIndex)	{	return ( T*)GetAtUNK( nIndex);	}

  000e3	8b 4d 14	 mov	 ecx, DWORD PTR _pblDRIfDTI$1$[ebp]
  000e6	57		 push	 edi
  000e7	e8 00 00 00 00	 call	 ?GetAtUNK@CDataBlockListUNK@@QAEPAXH@Z ; CDataBlockListUNK::GetAtUNK
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 1625 : 			m_pIReturn = pblDRIfDTI->GetAt( nDTI);

  000ec	89 46 60	 mov	 DWORD PTR [esi+96], eax

; 1626 : 			if( m_pIReturn) nDRI_Cur = *m_pIReturn;

  000ef	85 c0		 test	 eax, eax
  000f1	74 04		 je	 SHORT $LN43@GetAREAfRQ
  000f3	8b 00		 mov	 eax, DWORD PTR [eax]
  000f5	eb 03		 jmp	 SHORT $LN52@GetAREAfRQ
$LN43@GetAREAfRQ:
  000f7	8b 45 10	 mov	 eax, DWORD PTR _nDRI_Cur$[ebp]
$LN52@GetAREAfRQ:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 215  : 	T*	GetAt( int nIndex)	{	return ( T*)GetAtUNK( nIndex);	}

  000fa	8b 4d 14	 mov	 ecx, DWORD PTR _pblDRIfDTI$1$[ebp]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 1627 : 			m_pIReturn = pblDRIfDTI->GetAt( nDTI + 1);

  000fd	89 45 0c	 mov	 DWORD PTR _nDRI_Cur$1$[ebp], eax
  00100	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 215  : 	T*	GetAt( int nIndex)	{	return ( T*)GetAtUNK( nIndex);	}

  00103	50		 push	 eax
  00104	e8 00 00 00 00	 call	 ?GetAtUNK@CDataBlockListUNK@@QAEPAXH@Z ; CDataBlockListUNK::GetAtUNK
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 1627 : 			m_pIReturn = pblDRIfDTI->GetAt( nDTI + 1);

  00109	89 46 60	 mov	 DWORD PTR [esi+96], eax

; 1628 : 			if( m_pIReturn) nDRI_Next = *m_pIReturn;

  0010c	85 c0		 test	 eax, eax
  0010e	74 04		 je	 SHORT $LN44@GetAREAfRQ
  00110	8b 38		 mov	 edi, DWORD PTR [eax]
  00112	eb 03		 jmp	 SHORT $LN12@GetAREAfRQ
$LN44@GetAREAfRQ:
  00114	8b 7d 10	 mov	 edi, DWORD PTR _nDRI_Next$[ebp]
$LN12@GetAREAfRQ:

; 1629 : 
; 1630 : 			if(nDRI_Cur < 0 && nDRI_Next < 0)

  00117	8b 4d 0c	 mov	 ecx, DWORD PTR _nDRI_Cur$1$[ebp]
  0011a	85 c9		 test	 ecx, ecx
  0011c	79 08		 jns	 SHORT $LN13@GetAREAfRQ
  0011e	85 ff		 test	 edi, edi
  00120	0f 88 6c 01 00
	00		 js	 $LN32@GetAREAfRQ
$LN13@GetAREAfRQ:

; 1631 : 				return FALSE;
; 1632 : 
; 1633 : 			PAREA parea_Cur = NULL, parea_Next = NULL;
; 1634 : 			GetAreaFromDRI( nBlockColumn, nDRI_Cur, &parea_Cur);

  00126	8b 06		 mov	 eax, DWORD PTR [esi]
  00128	8d 55 f0	 lea	 edx, DWORD PTR _parea_Cur$3[ebp]
  0012b	52		 push	 edx
  0012c	51		 push	 ecx
  0012d	8b 4d 10	 mov	 ecx, DWORD PTR _nBlockColumn$[ebp]
  00130	51		 push	 ecx
  00131	8b ce		 mov	 ecx, esi
  00133	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _parea_Cur$3[ebp], 0
  0013a	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _parea_Next$2[ebp], 0
  00141	ff 90 44 01 00
	00		 call	 DWORD PTR [eax+324]

; 1635 : 			GetAreaFromDRI( nBlockColumn, nDRI_Next, &parea_Next);

  00147	8b 06		 mov	 eax, DWORD PTR [esi]
  00149	8d 4d ec	 lea	 ecx, DWORD PTR _parea_Next$2[ebp]
  0014c	51		 push	 ecx
  0014d	57		 push	 edi
  0014e	ff 75 10	 push	 DWORD PTR _nBlockColumn$[ebp]
  00151	8b ce		 mov	 ecx, esi
  00153	ff 90 44 01 00
	00		 call	 DWORD PTR [eax+324]

; 1636 : 			if( !parea_Cur) return FALSE;

  00159	8b 4d f0	 mov	 ecx, DWORD PTR _parea_Cur$3[ebp]
  0015c	85 c9		 test	 ecx, ecx
  0015e	0f 84 2e 01 00
	00		 je	 $LN32@GetAREAfRQ

; 1637 : 
; 1638 : 			if(m_bReverse == TRUE)

  00164	83 7e 0c 01	 cmp	 DWORD PTR [esi+12], 1
  00168	75 3e		 jne	 SHORT $LN15@GetAREAfRQ

; 1639 : 			{
; 1640 : 				//parea->left = parea_Next->right;
; 1641 : 				if(parea_Next)

  0016a	8b 45 ec	 mov	 eax, DWORD PTR _parea_Next$2[ebp]
  0016d	85 c0		 test	 eax, eax
  0016f	74 03		 je	 SHORT $LN18@GetAREAfRQ

; 1642 : 					parea->left = parea_Next->right;

  00171	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
$LN18@GetAREAfRQ:

; 1643 : 				else
; 1644 : 					parea->left = parea_Cur->left;
; 1645 : 				parea->right = parea_Cur->right;

  00174	66 8b 01	 mov	 ax, WORD PTR [ecx]

; 1646 : 				parea->center = ( parea->left + parea->right) / 2;
; 1647 : 				ItemIntervalApply( nBlockColumn, *parea, nDRI_Next - nDRI_Cur);

  00177	2b 7d 0c	 sub	 edi, DWORD PTR _nDRI_Cur$1$[ebp]
  0017a	66 89 03	 mov	 WORD PTR [ebx], ax
  0017d	8b 45 f0	 mov	 eax, DWORD PTR _parea_Cur$3[ebp]
  00180	0f bf 0b	 movsx	 ecx, WORD PTR [ebx]
  00183	57		 push	 edi
  00184	53		 push	 ebx
  00185	0f b7 40 04	 movzx	 eax, WORD PTR [eax+4]
  00189	ff 75 10	 push	 DWORD PTR _nBlockColumn$[ebp]
  0018c	66 89 43 04	 mov	 WORD PTR [ebx+4], ax
  00190	98		 cwde
  00191	03 c1		 add	 eax, ecx
  00193	8b ce		 mov	 ecx, esi
  00195	99		 cdq
  00196	2b c2		 sub	 eax, edx
  00198	d1 f8		 sar	 eax, 1
  0019a	66 89 43 02	 mov	 WORD PTR [ebx+2], ax
  0019e	e8 00 00 00 00	 call	 ?ItemIntervalApply@CXScaleManagerImp@@IAEXHAAUtagAREA@CXScaleManager@@H@Z ; CXScaleManagerImp::ItemIntervalApply

; 1648 : 			}

  001a3	e9 88 00 00 00	 jmp	 $LN22@GetAREAfRQ
$LN15@GetAREAfRQ:

; 1649 : 			else
; 1650 : 			{
; 1651 : 				parea->left = parea_Cur->left;

  001a8	0f b7 01	 movzx	 eax, WORD PTR [ecx]
  001ab	8b d0		 mov	 edx, eax
  001ad	66 89 03	 mov	 WORD PTR [ebx], ax

; 1652 : 				//parea->right = parea_Next->left;
; 1653 : 				if(parea_Next)

  001b0	8b 45 ec	 mov	 eax, DWORD PTR _parea_Next$2[ebp]
  001b3	85 c0		 test	 eax, eax
  001b5	74 05		 je	 SHORT $LN19@GetAREAfRQ

; 1654 : 					parea->right = parea_Next->left;

  001b7	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  001ba	eb 04		 jmp	 SHORT $LN20@GetAREAfRQ
$LN19@GetAREAfRQ:

; 1655 : 				else
; 1656 : 					parea->right = parea_Cur->right;

  001bc	0f b7 49 04	 movzx	 ecx, WORD PTR [ecx+4]
$LN20@GetAREAfRQ:

; 1657 : 				parea->center = ( parea->left + parea->right) / 2;
; 1658 : 				ItemIntervalApply_Reverse( nBlockColumn, *parea, nDRI_Next - nDRI_Cur);

  001c0	2b 7d 0c	 sub	 edi, DWORD PTR _nDRI_Cur$1$[ebp]
  001c3	66 89 4b 04	 mov	 WORD PTR [ebx+4], cx
  001c7	0f bf c2	 movsx	 eax, dx
  001ca	0f bf c9	 movsx	 ecx, cx
  001cd	03 c1		 add	 eax, ecx
  001cf	8b ce		 mov	 ecx, esi
  001d1	99		 cdq
  001d2	57		 push	 edi
  001d3	2b c2		 sub	 eax, edx
  001d5	53		 push	 ebx
  001d6	ff 75 10	 push	 DWORD PTR _nBlockColumn$[ebp]
  001d9	d1 f8		 sar	 eax, 1
  001db	66 89 43 02	 mov	 WORD PTR [ebx+2], ax
  001df	e8 00 00 00 00	 call	 ?ItemIntervalApply_Reverse@CXScaleManagerImp@@IAEXHAAUtagAREA@CXScaleManager@@H@Z ; CXScaleManagerImp::ItemIntervalApply_Reverse

; 1659 : 			}
; 1660 : 		}
; 1661 : 	}

  001e4	eb 4a		 jmp	 SHORT $LN22@GetAREAfRQ
$LN4@GetAREAfRQ:

; 1662 : 	// (2009/2/20 - Seung-Won, Bae) for out-side.
; 1663 : 	else if( nDTI < 0)

  001e6	85 ff		 test	 edi, edi
  001e8	79 6a		 jns	 SHORT $LN21@GetAREAfRQ
$LN50@GetAREAfRQ:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 215  : 	T*	GetAt( int nIndex)	{	return ( T*)GetAtUNK( nIndex);	}

  001ea	8b 4d 14	 mov	 ecx, DWORD PTR _pblDRIfDTI$1$[ebp]
  001ed	6a 00		 push	 0
  001ef	e8 00 00 00 00	 call	 ?GetAtUNK@CDataBlockListUNK@@QAEPAXH@Z ; CDataBlockListUNK::GetAtUNK
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 1665 : 		m_pIReturn = pblDRIfDTI->GetAt( 0);

  001f4	89 46 60	 mov	 DWORD PTR [esi+96], eax

; 1666 : 		if( m_pIReturn) nDRI_Cur = *m_pIReturn;

  001f7	85 c0		 test	 eax, eax
  001f9	74 04		 je	 SHORT $LN45@GetAREAfRQ
  001fb	8b 00		 mov	 eax, DWORD PTR [eax]
  001fd	eb 03		 jmp	 SHORT $LN23@GetAREAfRQ
$LN45@GetAREAfRQ:
  001ff	8b 45 10	 mov	 eax, DWORD PTR _nDRI_Cur$[ebp]
$LN23@GetAREAfRQ:

; 1667 : 		nDRI_Cur += nDTI;
; 1668 : 
; 1669 : 		PAREA parea_Cur = NULL;
; 1670 : 		GetAreaFromDRI( nBlockColumn, nDRI_Cur, &parea_Cur);

  00202	8b 16		 mov	 edx, DWORD PTR [esi]
  00204	8d 4d 14	 lea	 ecx, DWORD PTR _parea_Cur$5[ebp]
  00207	51		 push	 ecx
  00208	03 c7		 add	 eax, edi
  0020a	c7 45 14 00 00
	00 00		 mov	 DWORD PTR _parea_Cur$5[ebp], 0
  00211	50		 push	 eax
  00212	ff 75 10	 push	 DWORD PTR _nBlockColumn$[ebp]
  00215	8b ce		 mov	 ecx, esi
  00217	ff 92 44 01 00
	00		 call	 DWORD PTR [edx+324]

; 1671 : 		if( !parea_Cur) return FALSE;

  0021d	8b 4d 14	 mov	 ecx, DWORD PTR _parea_Cur$5[ebp]
  00220	85 c9		 test	 ecx, ecx
  00222	74 6e		 je	 SHORT $LN32@GetAREAfRQ
$LN26@GetAREAfRQ:

; 1683 : 		*parea = *parea_Cur;
; 1684 : 	}
; 1685 : 
; 1686 : 	return TRUE;

  00224	8b 01		 mov	 eax, DWORD PTR [ecx]
  00226	89 03		 mov	 DWORD PTR [ebx], eax
  00228	66 8b 41 04	 mov	 ax, WORD PTR [ecx+4]
$LN51@GetAREAfRQ:
  0022c	66 89 43 04	 mov	 WORD PTR [ebx+4], ax
$LN22@GetAREAfRQ:
  00230	be 01 00 00 00	 mov	 esi, 1
$LN33@GetAREAfRQ:
  00235	8d 4d 08	 lea	 ecx, DWORD PTR _strRQ$[ebp]
  00238	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0023e	8b c6		 mov	 eax, esi

; 1687 : }

  00240	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00243	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0024a	59		 pop	 ecx
  0024b	5f		 pop	 edi
  0024c	5e		 pop	 esi
  0024d	5b		 pop	 ebx
  0024e	8b e5		 mov	 esp, ebp
  00250	5d		 pop	 ebp
  00251	c2 10 00	 ret	 16			; 00000010H
$LN21@GetAREAfRQ:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 215  : 	T*	GetAt( int nIndex)	{	return ( T*)GetAtUNK( nIndex);	}

  00254	8b 4d 14	 mov	 ecx, DWORD PTR _pblDRIfDTI$1$[ebp]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 1676 : 		m_pIReturn = pblDRIfDTI->GetAt( nDTI_Total - 1);

  00257	48		 dec	 eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 215  : 	T*	GetAt( int nIndex)	{	return ( T*)GetAtUNK( nIndex);	}

  00258	50		 push	 eax
  00259	e8 00 00 00 00	 call	 ?GetAtUNK@CDataBlockListUNK@@QAEPAXH@Z ; CDataBlockListUNK::GetAtUNK
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 1676 : 		m_pIReturn = pblDRIfDTI->GetAt( nDTI_Total - 1);

  0025e	89 46 60	 mov	 DWORD PTR [esi+96], eax

; 1677 : 		if( m_pIReturn) nDRI_Cur = *m_pIReturn;

  00261	85 c0		 test	 eax, eax
  00263	74 04		 je	 SHORT $LN46@GetAREAfRQ
  00265	8b 00		 mov	 eax, DWORD PTR [eax]
  00267	eb 03		 jmp	 SHORT $LN25@GetAREAfRQ
$LN46@GetAREAfRQ:
  00269	8b 45 10	 mov	 eax, DWORD PTR _nDRI_Cur$[ebp]
$LN25@GetAREAfRQ:

; 1678 : 		nDRI_Cur += nDTI - nDTI_Total + 1;
; 1679 : 
; 1680 : 		PAREA parea_Cur = NULL;
; 1681 : 		GetAreaFromDRI( nBlockColumn, nDRI_Cur, &parea_Cur);

  0026c	2b 45 e8	 sub	 eax, DWORD PTR _nDTI_Total$1$[ebp]
  0026f	8d 4d 14	 lea	 ecx, DWORD PTR _parea_Cur$4[ebp]
  00272	8b 16		 mov	 edx, DWORD PTR [esi]
  00274	40		 inc	 eax
  00275	51		 push	 ecx
  00276	03 c7		 add	 eax, edi
  00278	c7 45 14 00 00
	00 00		 mov	 DWORD PTR _parea_Cur$4[ebp], 0
  0027f	50		 push	 eax
  00280	ff 75 10	 push	 DWORD PTR _nBlockColumn$[ebp]
  00283	8b ce		 mov	 ecx, esi
  00285	ff 92 44 01 00
	00		 call	 DWORD PTR [edx+324]

; 1682 : 		if( !parea_Cur) return FALSE;

  0028b	8b 4d 14	 mov	 ecx, DWORD PTR _parea_Cur$4[ebp]
  0028e	85 c9		 test	 ecx, ecx
  00290	75 92		 jne	 SHORT $LN26@GetAREAfRQ
$LN32@GetAREAfRQ:
  00292	33 f6		 xor	 esi, esi
  00294	eb 9f		 jmp	 SHORT $LN33@GetAREAfRQ
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetAREAfRQnDTI@CXScaleManagerImp@@MAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HHPAUtagAREA@CXScaleManager@@@Z$0:
  00000	8d 4d 08	 lea	 ecx, DWORD PTR _strRQ$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
  0000d	cc		 int	 3
__ehhandler$?GetAREAfRQnDTI@CXScaleManagerImp@@MAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HHPAUtagAREA@CXScaleManager@@@Z:
  0000e	90		 npad	 1
  0000f	90		 npad	 1
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?GetAREAfRQnDTI@CXScaleManagerImp@@MAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HHPAUtagAREA@CXScaleManager@@@Z
  00026	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?GetAREAfRQnDTI@CXScaleManagerImp@@MAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HHPAUtagAREA@CXScaleManager@@@Z ENDP ; CXScaleManagerImp::GetAREAfRQnDTI
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?GetAt_ScaleTime@CXScaleManagerImp@@MAEXHPA_JPAPAUtagAREA@CXScaleManager@@@Z
_TEXT	SEGMENT
_nDRI$ = 8						; size = 4
_ptimeScale$ = 12					; size = 4
_pparea$ = 16						; size = 4
?GetAt_ScaleTime@CXScaleManagerImp@@MAEXHPA_JPAPAUtagAREA@CXScaleManager@@@Z PROC ; CXScaleManagerImp::GetAt_ScaleTime, COMDAT
; _this$ = ecx

; 1545 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 215  : 	T*	GetAt( int nIndex)	{	return ( T*)GetAtUNK( nIndex);	}

  00004	ff 75 08	 push	 DWORD PTR _nDRI$[ebp]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 1545 : {

  00007	8b f1		 mov	 esi, ecx

; 1546 : 	m_pTReturn = m_blTimefDRI.GetAt( nDRI);

  00009	8d 8e ac 00 00
	00		 lea	 ecx, DWORD PTR [esi+172]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 215  : 	T*	GetAt( int nIndex)	{	return ( T*)GetAtUNK( nIndex);	}

  0000f	e8 00 00 00 00	 call	 ?GetAtUNK@CDataBlockListUNK@@QAEPAXH@Z ; CDataBlockListUNK::GetAtUNK
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 1546 : 	m_pTReturn = m_blTimefDRI.GetAt( nDRI);

  00014	89 46 5c	 mov	 DWORD PTR [esi+92], eax

; 1547 : 	if( m_pTReturn) *ptimeScale = *m_pTReturn;

  00017	85 c0		 test	 eax, eax
  00019	74 0d		 je	 SHORT $LN2@GetAt_Scal
  0001b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001d	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00020	8b 45 0c	 mov	 eax, DWORD PTR _ptimeScale$[ebp]
  00023	89 08		 mov	 DWORD PTR [eax], ecx
  00025	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN2@GetAt_Scal:

; 1548 : 	*pparea = (PAREA)m_blAreafDRI[ 0].GetAtUNK(nDRI);

  00028	ff 75 08	 push	 DWORD PTR _nDRI$[ebp]
  0002b	8d 8e 88 03 00
	00		 lea	 ecx, DWORD PTR [esi+904]
  00031	e8 00 00 00 00	 call	 ?GetAtUNK@CDataBlockListUNK@@QAEPAXH@Z ; CDataBlockListUNK::GetAtUNK
  00036	8b 4d 10	 mov	 ecx, DWORD PTR _pparea$[ebp]
  00039	5e		 pop	 esi
  0003a	89 01		 mov	 DWORD PTR [ecx], eax

; 1549 : }

  0003c	5d		 pop	 ebp
  0003d	c2 0c 00	 ret	 12			; 0000000cH
?GetAt_ScaleTime@CXScaleManagerImp@@MAEXHPA_JPAPAUtagAREA@CXScaleManager@@@Z ENDP ; CXScaleManagerImp::GetAt_ScaleTime
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?PrevScaleTime@CXScaleManagerImp@@MAEXPA_JPAPAUtagAREA@CXScaleManager@@@Z
_TEXT	SEGMENT
_ptimeScale$ = 8					; size = 4
_pparea$ = 12						; size = 4
?PrevScaleTime@CXScaleManagerImp@@MAEXPA_JPAPAUtagAREA@CXScaleManager@@@Z PROC ; CXScaleManagerImp::PrevScaleTime, COMDAT
; _this$ = ecx

; 1538 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 1539 : 	m_pTReturn = m_blTimefDRI.GetPrev();

  00006	8d 8e ac 00 00
	00		 lea	 ecx, DWORD PTR [esi+172]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 203  : 	T* GetPrev()	{	return (T*)GetPrevUNK();	}

  0000c	e8 00 00 00 00	 call	 ?GetPrevUNK@CDataBlockListUNK@@QAEPAXXZ ; CDataBlockListUNK::GetPrevUNK
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 1539 : 	m_pTReturn = m_blTimefDRI.GetPrev();

  00011	89 46 5c	 mov	 DWORD PTR [esi+92], eax

; 1540 : 	if( m_pTReturn) *ptimeScale = *m_pTReturn;

  00014	85 c0		 test	 eax, eax
  00016	74 0d		 je	 SHORT $LN2@PrevScaleT
  00018	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001a	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0001d	8b 45 08	 mov	 eax, DWORD PTR _ptimeScale$[ebp]
  00020	89 08		 mov	 DWORD PTR [eax], ecx
  00022	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN2@PrevScaleT:

; 1541 : 	*pparea = (PAREA)m_blAreafDRI[ 0].GetPrevUNK();

  00025	8d 8e 88 03 00
	00		 lea	 ecx, DWORD PTR [esi+904]
  0002b	e8 00 00 00 00	 call	 ?GetPrevUNK@CDataBlockListUNK@@QAEPAXXZ ; CDataBlockListUNK::GetPrevUNK
  00030	8b 4d 0c	 mov	 ecx, DWORD PTR _pparea$[ebp]
  00033	5e		 pop	 esi
  00034	89 01		 mov	 DWORD PTR [ecx], eax

; 1542 : }

  00036	5d		 pop	 ebp
  00037	c2 08 00	 ret	 8
?PrevScaleTime@CXScaleManagerImp@@MAEXPA_JPAPAUtagAREA@CXScaleManager@@@Z ENDP ; CXScaleManagerImp::PrevScaleTime
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?NextScaleTime@CXScaleManagerImp@@MAEHPA_JPAPAUtagAREA@CXScaleManager@@@Z
_TEXT	SEGMENT
_ptimeScale$ = 8					; size = 4
_pparea$ = 12						; size = 4
?NextScaleTime@CXScaleManagerImp@@MAEHPA_JPAPAUtagAREA@CXScaleManager@@@Z PROC ; CXScaleManagerImp::NextScaleTime, COMDAT
; _this$ = ecx

; 1518 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b f9		 mov	 edi, ecx

; 1519 : 	int nItemCount = m_blTimefDRI.GetItemCount();

  00008	8d 8f ac 00 00
	00		 lea	 ecx, DWORD PTR [edi+172]
  0000e	e8 00 00 00 00	 call	 ?GetItemCount@CDataBlockListUNK@@QAEHXZ ; CDataBlockListUNK::GetItemCount
  00013	8b d8		 mov	 ebx, eax

; 1520 : 	if( 0 == nItemCount) return FALSE;

  00015	85 db		 test	 ebx, ebx
  00017	75 07		 jne	 SHORT $LN2@NextScaleT

; 1533 : 	return TRUE;
; 1534 : }

  00019	5f		 pop	 edi
  0001a	5e		 pop	 esi
  0001b	5b		 pop	 ebx
  0001c	5d		 pop	 ebp
  0001d	c2 08 00	 ret	 8
$LN2@NextScaleT:

; 1521 : 
; 1522 : 	if( m_blTimefDRI.GetIndex() < nItemCount)

  00020	8d 8f ac 00 00
	00		 lea	 ecx, DWORD PTR [edi+172]
  00026	e8 00 00 00 00	 call	 ?GetIndex@CDataBlockListUNK@@QAEHXZ ; CDataBlockListUNK::GetIndex
  0002b	8d 8f ac 00 00
	00		 lea	 ecx, DWORD PTR [edi+172]
  00031	3b c3		 cmp	 eax, ebx
  00033	7d 35		 jge	 SHORT $LN3@NextScaleT
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 227  : 	T* GetNext()	{	return ( T*)GetNextUNK();	}

  00035	e8 00 00 00 00	 call	 ?GetNextUNK@CDataBlockListUNK@@QAEPAXXZ ; CDataBlockListUNK::GetNextUNK
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 1524 : 		m_pTReturn = m_blTimefDRI.GetNext();

  0003a	89 47 5c	 mov	 DWORD PTR [edi+92], eax

; 1525 : 		if( m_pTReturn) *ptimeScale = *m_pTReturn;

  0003d	85 c0		 test	 eax, eax
  0003f	74 0d		 je	 SHORT $LN4@NextScaleT
  00041	8b 08		 mov	 ecx, DWORD PTR [eax]
  00043	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00046	8b 45 08	 mov	 eax, DWORD PTR _ptimeScale$[ebp]
  00049	89 08		 mov	 DWORD PTR [eax], ecx
  0004b	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN4@NextScaleT:

; 1526 : 		*pparea = (PAREA)m_blAreafDRI[ 0].GetNextUNK();

  0004e	8d 8f 88 03 00
	00		 lea	 ecx, DWORD PTR [edi+904]
  00054	e8 00 00 00 00	 call	 ?GetNextUNK@CDataBlockListUNK@@QAEPAXXZ ; CDataBlockListUNK::GetNextUNK

; 1533 : 	return TRUE;
; 1534 : }

  00059	8b 4d 0c	 mov	 ecx, DWORD PTR _pparea$[ebp]
  0005c	5f		 pop	 edi
  0005d	5e		 pop	 esi
  0005e	5b		 pop	 ebx
  0005f	89 01		 mov	 DWORD PTR [ecx], eax
  00061	b8 01 00 00 00	 mov	 eax, 1
  00066	5d		 pop	 ebp
  00067	c2 08 00	 ret	 8
$LN3@NextScaleT:

; 1530 : 	m_pTReturn = m_blTimefDRI.GetAt(m_blTimefDRI.GetItemCount() - 1);

  0006a	e8 00 00 00 00	 call	 ?GetItemCount@CDataBlockListUNK@@QAEHXZ ; CDataBlockListUNK::GetItemCount
  0006f	48		 dec	 eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 215  : 	T*	GetAt( int nIndex)	{	return ( T*)GetAtUNK( nIndex);	}

  00070	8d 8f ac 00 00
	00		 lea	 ecx, DWORD PTR [edi+172]
  00076	50		 push	 eax
  00077	e8 00 00 00 00	 call	 ?GetAtUNK@CDataBlockListUNK@@QAEPAXH@Z ; CDataBlockListUNK::GetAtUNK
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 1530 : 	m_pTReturn = m_blTimefDRI.GetAt(m_blTimefDRI.GetItemCount() - 1);

  0007c	89 47 5c	 mov	 DWORD PTR [edi+92], eax

; 1531 : 	if( m_pTReturn) *ptimeScale = *m_pTReturn;

  0007f	85 c0		 test	 eax, eax
  00081	74 0d		 je	 SHORT $LN5@NextScaleT
  00083	8b 08		 mov	 ecx, DWORD PTR [eax]
  00085	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00088	8b 45 08	 mov	 eax, DWORD PTR _ptimeScale$[ebp]
  0008b	89 08		 mov	 DWORD PTR [eax], ecx
  0008d	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN5@NextScaleT:

; 1532 : 	*pparea = (PAREA)m_blAreafDRI[ 0].GetAtUNK( m_blAreafDRI[ 0].GetItemCount() - 1 - 1);	// (2009/3/2 - Seung-Won, Bae) +1 for right of Last Candle

  00090	8d 8f 88 03 00
	00		 lea	 ecx, DWORD PTR [edi+904]
  00096	e8 00 00 00 00	 call	 ?GetItemCount@CDataBlockListUNK@@QAEHXZ ; CDataBlockListUNK::GetItemCount
  0009b	83 e8 02	 sub	 eax, 2
  0009e	8d 8f 88 03 00
	00		 lea	 ecx, DWORD PTR [edi+904]
  000a4	50		 push	 eax
  000a5	e8 00 00 00 00	 call	 ?GetAtUNK@CDataBlockListUNK@@QAEPAXH@Z ; CDataBlockListUNK::GetAtUNK

; 1533 : 	return TRUE;
; 1534 : }

  000aa	8b 4d 0c	 mov	 ecx, DWORD PTR _pparea$[ebp]
  000ad	5f		 pop	 edi
  000ae	5e		 pop	 esi
  000af	5b		 pop	 ebx
  000b0	89 01		 mov	 DWORD PTR [ecx], eax
  000b2	b8 01 00 00 00	 mov	 eax, 1
  000b7	5d		 pop	 ebp
  000b8	c2 08 00	 ret	 8
?NextScaleTime@CXScaleManagerImp@@MAEHPA_JPAPAUtagAREA@CXScaleManager@@@Z ENDP ; CXScaleManagerImp::NextScaleTime
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?SetBlockColumn_Cur@CXScaleManagerImp@@MAEXH@Z
_TEXT	SEGMENT
_nBlockColumn$ = 8					; size = 4
?SetBlockColumn_Cur@CXScaleManagerImp@@MAEXH@Z PROC	; CXScaleManagerImp::SetBlockColumn_Cur, COMDAT
; _this$ = ecx

; 1179 : //	m_pbcinfo_cur = m_vBCInfo.at(nBlockColumn);
; 1180 : }

  00000	c2 04 00	 ret	 4
?SetBlockColumn_Cur@CXScaleManagerImp@@MAEXH@Z ENDP	; CXScaleManagerImp::SetBlockColumn_Cur
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?SetBlockColumnCount@CXScaleManagerImp@@MAEXH@Z
_TEXT	SEGMENT
_nBlockColumn_Count$ = 8				; size = 4
?SetBlockColumnCount@CXScaleManagerImp@@MAEXH@Z PROC	; CXScaleManagerImp::SetBlockColumnCount, COMDAT
; _this$ = ecx

; 1143 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1144 : 	m_nCountOfBlockColumn = nBlockColumn_Count;

  00003	8b 45 08	 mov	 eax, DWORD PTR _nBlockColumn_Count$[ebp]
  00006	89 81 2c 01 00
	00		 mov	 DWORD PTR [ecx+300], eax

; 1145 : 
; 1146 : //	int nBC, nCountOfBC;
; 1147 : /*
; 1148 : 	VECTOR_BC_INFO::iterator itBC = m_vBCInfo.begin();
; 1149 : 	while(itBC != m_vBCInfo.end())
; 1150 : 	{
; 1151 : 		delete *itBC;
; 1152 : 	}
; 1153 : 
; 1154 : 	m_vBCInfo.clear();
; 1155 : 
; 1156 : 
; 1157 : 	nCountOfBC = nBlockColumn_Count;
; 1158 : 	for(nBC = 0; nBC < nCountOfBC; nBC++)
; 1159 : 	{
; 1160 : 		PBC_INFO pbc_info = new BC_INFO;
; 1161 : 		m_vBCInfo.push_back(pbc_info);
; 1162 : 	}
; 1163 : 
; 1164 : 	if(m_nCountOfBlockColumn > 1) m_rmtype = RMAT_RIGHT_MARGIN_FIX;
; 1165 : */
; 1166 : }

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
?SetBlockColumnCount@CXScaleManagerImp@@MAEXH@Z ENDP	; CXScaleManagerImp::SetBlockColumnCount
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?GetTimeFromXWithRightMargin@CXScaleManagerImp@@IAE_JHPAHPAPAUtagAREA@CXScaleManager@@@Z
_TEXT	SEGMENT
_timeResult$ = -8					; size = 8
_nCursor_x$ = 8						; size = 4
_pnBlockColumn$ = 12					; size = 4
_pparea$ = 16						; size = 4
?GetTimeFromXWithRightMargin@CXScaleManagerImp@@IAE_JHPAHPAPAUtagAREA@CXScaleManager@@@Z PROC ; CXScaleManagerImp::GetTimeFromXWithRightMargin, COMDAT
; _this$ = ecx

; 1736 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi

; 1737 : 	time_t timeResult;
; 1738 : 
; 1739 : 	int nDRI = GetDRInFromPt(nCursor_x, pnBlockColumn, pparea, TRUE);

  00007	6a 00		 push	 0
  00009	6a 01		 push	 1
  0000b	ff 75 10	 push	 DWORD PTR _pparea$[ebp]
  0000e	8b f1		 mov	 esi, ecx
  00010	ff 75 0c	 push	 DWORD PTR _pnBlockColumn$[ebp]
  00013	ff 75 08	 push	 DWORD PTR _nCursor_x$[ebp]
  00016	8b 06		 mov	 eax, DWORD PTR [esi]
  00018	ff 90 14 01 00
	00		 call	 DWORD PTR [eax+276]

; 1740 : 	GetTimeFromDRI(nDRI, &timeResult);

  0001e	8b 16		 mov	 edx, DWORD PTR [esi]
  00020	8d 4d f8	 lea	 ecx, DWORD PTR _timeResult$[ebp]
  00023	51		 push	 ecx
  00024	50		 push	 eax
  00025	8b ce		 mov	 ecx, esi
  00027	ff 92 ec 00 00
	00		 call	 DWORD PTR [edx+236]

; 1741 : 
; 1742 : 	return timeResult;

  0002d	8b 45 f8	 mov	 eax, DWORD PTR _timeResult$[ebp]
  00030	8b 55 fc	 mov	 edx, DWORD PTR _timeResult$[ebp+4]
  00033	5e		 pop	 esi

; 1743 : }

  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c2 0c 00	 ret	 12			; 0000000cH
?GetTimeFromXWithRightMargin@CXScaleManagerImp@@IAE_JHPAHPAPAUtagAREA@CXScaleManager@@@Z ENDP ; CXScaleManagerImp::GetTimeFromXWithRightMargin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?GetDTIArea@CXScaleManagerImp@@MAEPAV?$CDataBlockList@UtagAREA@CXScaleManager@@$0CAA@@@HPBDAAH@Z
_TEXT	SEGMENT
_p_nColumn$ = 8						; size = 4
_p_szRQ$ = 12						; size = 4
_p_nZeroDTI$ = 16					; size = 4
?GetDTIArea@CXScaleManagerImp@@MAEPAV?$CDataBlockList@UtagAREA@CXScaleManager@@$0CAA@@@HPBDAAH@Z PROC ; CXScaleManagerImp::GetDTIArea, COMDAT
; _this$ = ecx

; 3959 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 3960 : 	int nRQ = GetRQIndexFromString( p_szRQ);

  00006	51		 push	 ecx
  00007	8b f1		 mov	 esi, ecx
  00009	8b cc		 mov	 ecx, esp
  0000b	ff 75 0c	 push	 DWORD PTR _p_szRQ$[ebp]
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  00014	8b 06		 mov	 eax, DWORD PTR [esi]
  00016	8b ce		 mov	 ecx, esi
  00018	ff 50 04	 call	 DWORD PTR [eax+4]
  0001b	8b f8		 mov	 edi, eax

; 3961 : 	if( nRQ < 0) return NULL;

  0001d	85 ff		 test	 edi, edi
  0001f	78 2a		 js	 SHORT $LN6@GetDTIArea

; 3962 : 	p_nZeroDTI = m_pifaRQ[ nRQ]->nDTI_Start_Data;

  00021	8b 8e 8c 00 00
	00		 mov	 ecx, DWORD PTR [esi+140]
  00027	8b 0c b9	 mov	 ecx, DWORD PTR [ecx+edi*4]
  0002a	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0002d	8b 4d 10	 mov	 ecx, DWORD PTR _p_nZeroDTI$[ebp]
  00030	89 11		 mov	 DWORD PTR [ecx], edx

; 3963 : 	if( !m_pblaAreafDTI[ p_nColumn]) return NULL;

  00032	8b 4d 08	 mov	 ecx, DWORD PTR _p_nColumn$[ebp]
  00035	8b 84 8e 90 05
	00 00		 mov	 eax, DWORD PTR [esi+ecx*4+1424]
  0003c	85 c0		 test	 eax, eax
  0003e	74 0b		 je	 SHORT $LN6@GetDTIArea

; 3964 : 	return m_pblaAreafDTI[ p_nColumn][ nRQ];

  00040	8b 04 b8	 mov	 eax, DWORD PTR [eax+edi*4]

; 3965 : }

  00043	5f		 pop	 edi
  00044	5e		 pop	 esi
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c2 0c 00	 ret	 12			; 0000000cH
$LN6@GetDTIArea:
  0004b	5f		 pop	 edi
  0004c	33 c0		 xor	 eax, eax
  0004e	5e		 pop	 esi
  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c2 0c 00	 ret	 12			; 0000000cH
?GetDTIArea@CXScaleManagerImp@@MAEPAV?$CDataBlockList@UtagAREA@CXScaleManager@@$0CAA@@@HPBDAAH@Z ENDP ; CXScaleManagerImp::GetDTIArea
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?SetScreenRegion@CXScaleManagerImp@@MAEXHHHH@Z
_TEXT	SEGMENT
_rctClient$ = -20					; size = 16
__$ArrayPad$ = -4					; size = 4
_p_nColumn$ = 8						; size = 4
_nLeft$ = 12						; size = 4
_nWidth$ = 16						; size = 4
_p_bReCalc$ = 20					; size = 4
?SetScreenRegion@CXScaleManagerImp@@MAEXHHHH@Z PROC	; CXScaleManagerImp::SetScreenRegion, COMDAT
; _this$ = ecx

; 3883 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	57		 push	 edi
  00012	8b 7d 08	 mov	 edi, DWORD PTR _p_nColumn$[ebp]
  00015	8b f1		 mov	 esi, ecx

; 3884 : 	if( p_nColumn < 0 || m_nCountOfBlockColumn <= p_nColumn) return;

  00017	85 ff		 test	 edi, edi
  00019	0f 88 fb 01 00
	00		 js	 $LN3@SetScreenR
  0001f	39 be 2c 01 00
	00		 cmp	 DWORD PTR [esi+300], edi
  00025	0f 8e ef 01 00
	00		 jle	 $LN3@SetScreenR

; 3885 : 
; 3886 : 	// (2009/1/8 - Seung-Won, Bae) Do not calculate again with same environment.
; 3887 : 	if( m_naScreenRegionLeft[ p_nColumn] == nLeft && m_naScreenRegionWidth[ p_nColumn] == nWidth && !p_bReCalc) return;

  0002b	8b 55 0c	 mov	 edx, DWORD PTR _nLeft$[ebp]
  0002e	8b 4d 10	 mov	 ecx, DWORD PTR _nWidth$[ebp]
  00031	39 94 be 58 01
	00 00		 cmp	 DWORD PTR [esi+edi*4+344], edx
  00038	75 13		 jne	 SHORT $LN4@SetScreenR
  0003a	39 8c be 80 01
	00 00		 cmp	 DWORD PTR [esi+edi*4+384], ecx
  00041	75 0a		 jne	 SHORT $LN4@SetScreenR
  00043	83 7d 14 00	 cmp	 DWORD PTR _p_bReCalc$[ebp], 0
  00047	0f 84 cd 01 00
	00		 je	 $LN3@SetScreenR
$LN4@SetScreenR:

; 3888 : 
; 3889 : 	// (2009/1/8 - Seung-Won, Bae) Manage the Screen Region Info
; 3890 : 	m_naScreenRegionLeft[ p_nColumn]		= nLeft;
; 3891 : 	m_naScreenRegionWidth[ p_nColumn]	= nWidth;

  0004d	89 8c be 80 01
	00 00		 mov	 DWORD PTR [esi+edi*4+384], ecx

; 3892 : 
; 3893 : 	// Left : 1, Right : 2
; 3894 : 	nLeft += 1;	nWidth -=2;

  00054	83 e9 02	 sub	 ecx, 2
  00057	89 94 be 58 01
	00 00		 mov	 DWORD PTR [esi+edi*4+344], edx
  0005e	42		 inc	 edx

; 3895 : 	if( nWidth > MARGIN * 5)

  0005f	83 f9 14	 cmp	 ecx, 20			; 00000014H
  00062	7e 0c		 jle	 SHORT $LN6@SetScreenR

; 3896 : 	{
; 3897 : 		nWidth -= MARGIN * 2 + 2;

  00064	83 e9 0a	 sub	 ecx, 10			; 0000000aH

; 3898 : 		if(m_bReverse) nLeft += MARGIN * 2 + 2;

  00067	83 7e 0c 00	 cmp	 DWORD PTR [esi+12], 0
  0006b	74 03		 je	 SHORT $LN6@SetScreenR
  0006d	83 c2 0a	 add	 edx, 10			; 0000000aH
$LN6@SetScreenR:

; 3899 : 	}
; 3900 : 
; 3901 : 	m_nScreenLeftiM_Cur[ p_nColumn] = nLeft;
; 3902 : 	m_nScreenRightiM_Cur[ p_nColumn] = nLeft + nWidth;

  00070	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
  00073	89 94 be 48 02
	00 00		 mov	 DWORD PTR [esi+edi*4+584], edx
  0007a	89 84 be 70 02
	00 00		 mov	 DWORD PTR [esi+edi*4+624], eax

; 3903 : 
; 3904 : 	m_nScreenLeft_Cur[ p_nColumn] = nLeft;

  00081	89 94 be f8 01
	00 00		 mov	 DWORD PTR [esi+edi*4+504], edx

; 3905 : 	m_nScreenWidth_Cur[ p_nColumn] = nWidth;

  00088	89 8c be 38 03
	00 00		 mov	 DWORD PTR [esi+edi*4+824], ecx

; 3906 : 
; 3907 : 	if( !m_pIChartCtrl->IsRunningOneChart())

  0008f	8b 4e 50	 mov	 ecx, DWORD PTR [esi+80]
  00092	8b 01		 mov	 eax, DWORD PTR [ecx]
  00094	ff 90 38 01 00
	00		 call	 DWORD PTR [eax+312]
  0009a	85 c0		 test	 eax, eax
  0009c	75 19		 jne	 SHORT $LN7@SetScreenR

; 3908 : 	{
; 3909 : 		if( m_bReverse) m_nScreenLeft_Cur[ p_nColumn] += m_nRightMarginWidth;

  0009e	39 46 0c	 cmp	 DWORD PTR [esi+12], eax
  000a1	74 0a		 je	 SHORT $LN8@SetScreenR
  000a3	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  000a6	01 84 be f8 01
	00 00		 add	 DWORD PTR [esi+edi*4+504], eax
$LN8@SetScreenR:

; 3910 : 		m_nScreenWidth_Cur[ p_nColumn] -= m_nRightMarginWidth;

  000ad	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  000b0	29 84 be 38 03
	00 00		 sub	 DWORD PTR [esi+edi*4+824], eax
$LN7@SetScreenR:

; 3911 : 	}
; 3912 : 
; 3913 : 	CRect rctClient = m_pIChartCtrl->GetAllBlockRegion();

  000b7	8b 4e 50	 mov	 ecx, DWORD PTR [esi+80]
  000ba	8d 55 ec	 lea	 edx, DWORD PTR _rctClient$[ebp]
  000bd	52		 push	 edx
  000be	8b 01		 mov	 eax, DWORD PTR [ecx]
  000c0	ff 90 64 03 00
	00		 call	 DWORD PTR [eax+868]

; 3914 : 	if( m_nItemCount_Total == 0)

  000c6	83 7e 58 00	 cmp	 DWORD PTR [esi+88], 0
  000ca	75 1d		 jne	 SHORT $LN9@SetScreenR

; 3915 : 	{
; 3916 : 		m_rctClient = rctClient;

  000cc	0f 10 45 ec	 movups	 xmm0, XMMWORD PTR _rctClient$[ebp]
  000d0	5f		 pop	 edi
  000d1	0f 11 86 b8 05
	00 00		 movups	 XMMWORD PTR [esi+1464], xmm0

; 3953 : 	}
; 3954 : }

  000d8	5e		 pop	 esi
  000d9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000dc	33 cd		 xor	 ecx, ebp
  000de	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e3	8b e5		 mov	 esp, ebp
  000e5	5d		 pop	 ebp
  000e6	c2 10 00	 ret	 16			; 00000010H
$LN9@SetScreenR:

; 3917 : 		return;
; 3918 : 	}
; 3919 : 
; 3920 : 	// (2009/5/12 - Seung-Won, Bae) for Fixed Item Width
; 3921 : 	BOOL bItemWidthFix = ( m_rstype == RSAT_ITEM_WIDTH_FIX && !m_pIChartCtrl->IsWholeView());

  000e9	83 7e 20 01	 cmp	 DWORD PTR [esi+32], 1
  000ed	53		 push	 ebx
  000ee	0f 85 cb 00 00
	00		 jne	 $LN32@SetScreenR
  000f4	8b 4e 50	 mov	 ecx, DWORD PTR [esi+80]
  000f7	8b 01		 mov	 eax, DWORD PTR [ecx]
  000f9	8b 40 50	 mov	 eax, DWORD PTR [eax+80]
  000fc	ff d0		 call	 eax
  000fe	84 c0		 test	 al, al
  00100	0f 85 b9 00 00
	00		 jne	 $LN32@SetScreenR

; 3922 : 	if( bItemWidthFix) bItemWidthFix = ( !m_rctClient.IsRectEmpty() && m_rctClient != rctClient);

  00106	8d 9e b8 05 00
	00		 lea	 ebx, DWORD PTR [esi+1464]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h

; 638  : 	return ::IsRectEmpty(this);

  0010c	53		 push	 ebx
  0010d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsRectEmpty@4
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 3922 : 	if( bItemWidthFix) bItemWidthFix = ( !m_rctClient.IsRectEmpty() && m_rctClient != rctClient);

  00113	85 c0		 test	 eax, eax
  00115	0f 85 a4 00 00
	00		 jne	 $LN32@SetScreenR
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h

; 775  : 	return !::EqualRect(this, &rect);

  0011b	8d 45 ec	 lea	 eax, DWORD PTR _rctClient$[ebp]
  0011e	50		 push	 eax
  0011f	53		 push	 ebx
  00120	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EqualRect@8
  00126	85 c0		 test	 eax, eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 3922 : 	if( bItemWidthFix) bItemWidthFix = ( !m_rctClient.IsRectEmpty() && m_rctClient != rctClient);

  00128	0f 85 91 00 00
	00		 jne	 $LN32@SetScreenR
  0012e	0f 10 45 ec	 movups	 xmm0, XMMWORD PTR _rctClient$[ebp]

; 3923 : 	m_rctClient = rctClient;
; 3924 : 	if( bItemWidthFix && 0 < m_dLastItemWidth)

  00132	f2 0f 10 8e d0
	05 00 00	 movsd	 xmm1, QWORD PTR [esi+1488]
  0013a	66 0f 2f 0d 00
	00 00 00	 comisd	 xmm1, QWORD PTR __real@0000000000000000
  00142	0f 11 86 b8 05
	00 00		 movups	 XMMWORD PTR [esi+1464], xmm0
  00149	76 7f		 jbe	 SHORT $LN11@SetScreenR

; 3925 : 	{
; 3926 : 		m_bOnResizing = TRUE;

  0014b	c7 86 c8 05 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+1480], 1
  00155	66 0f 6e 86 38
	03 00 00	 movd	 xmm0, DWORD PTR [esi+824]

; 3927 : 		double dDrawCount = m_nScreenWidth_Cur[ 0] / m_dLastItemWidth;

  0015d	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0

; 3928 : 		m_pIChartCtrl->ZoomTo( dDrawCount, FALSE);

  00161	8b 4e 50	 mov	 ecx, DWORD PTR [esi+80]
  00164	50		 push	 eax
  00165	8b 11		 mov	 edx, DWORD PTR [ecx]
  00167	f2 0f 5e c1	 divsd	 xmm0, xmm1
  0016b	f2 0f 2c c0	 cvttsd2si eax, xmm0
  0016f	50		 push	 eax
  00170	ff 92 a4 02 00
	00		 call	 DWORD PTR [edx+676]

; 3929 : 		if( m_nMinDataCountOnOnePage == m_nDrawCount_Cur || m_nItemCount_Total == m_nDrawCount_Cur)

  00176	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00179	39 46 34	 cmp	 DWORD PTR [esi+52], eax
  0017c	74 05		 je	 SHORT $LN33@SetScreenR
  0017e	39 46 58	 cmp	 DWORD PTR [esi+88], eax
  00181	75 1f		 jne	 SHORT $LN13@SetScreenR
$LN33@SetScreenR:

; 3930 : 		{
; 3931 : 			// (2009/1/11 - Seung-Won, Bae) Use Calc_ItemWidth();
; 3932 : 			Calc_ItemWidth( p_nColumn, m_nDrawCount_Cur);

  00183	6a 00		 push	 0
  00185	50		 push	 eax
  00186	57		 push	 edi
  00187	8b ce		 mov	 ecx, esi
  00189	e8 00 00 00 00	 call	 ?Calc_ItemWidth@CXScaleManagerImp@@IAEXHHH@Z ; CXScaleManagerImp::Calc_ItemWidth

; 3933 : 
; 3934 : 			// 3. Update ScrollBar and Zoom SliderBar
; 3935 : 			// (2009/1/14 - Seung-Won, Bae) Do not call on No-Recalc for avoding the deadlock.
; 3936 : 			m_pIChartCtrl->UpdateZoomAndScrollInfo( m_nItemCount_Total, m_nDRI_Start_Cur, m_nDrawCount_Cur);

  0018e	8b 4e 50	 mov	 ecx, DWORD PTR [esi+80]
  00191	ff 76 30	 push	 DWORD PTR [esi+48]
  00194	ff 76 28	 push	 DWORD PTR [esi+40]
  00197	8b 01		 mov	 eax, DWORD PTR [ecx]
  00199	ff 76 58	 push	 DWORD PTR [esi+88]
  0019c	ff 90 10 08 00
	00		 call	 DWORD PTR [eax+2064]
$LN13@SetScreenR:

; 3937 : 		}
; 3938 : 		m_bOnResizing = FALSE;

  001a2	5b		 pop	 ebx
  001a3	5f		 pop	 edi
  001a4	c7 86 c8 05 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+1480], 0

; 3953 : 	}
; 3954 : }

  001ae	5e		 pop	 esi
  001af	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001b2	33 cd		 xor	 ecx, ebp
  001b4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001b9	8b e5		 mov	 esp, ebp
  001bb	5d		 pop	 ebp
  001bc	c2 10 00	 ret	 16			; 00000010H
$LN32@SetScreenR:

; 3939 : 	}
; 3940 : 	else
; 3941 : 	{
; 3942 : 		int nZoomValue = m_pIChartCtrl->GetOnePageDataCount();

  001bf	0f 10 45 ec	 movups	 xmm0, XMMWORD PTR _rctClient$[ebp]
  001c3	0f 11 86 b8 05
	00 00		 movups	 XMMWORD PTR [esi+1464], xmm0
$LN11@SetScreenR:
  001ca	8b 4e 50	 mov	 ecx, DWORD PTR [esi+80]
  001cd	8b 01		 mov	 eax, DWORD PTR [ecx]
  001cf	ff 90 24 04 00
	00		 call	 DWORD PTR [eax+1060]

; 3943 : 		if( m_pIChartCtrl->IsWholeView())					nZoomValue = m_nDrawCount_Cur;

  001d5	8b 4e 50	 mov	 ecx, DWORD PTR [esi+80]
  001d8	8b d8		 mov	 ebx, eax
  001da	8b 11		 mov	 edx, DWORD PTR [ecx]
  001dc	8b 52 50	 mov	 edx, DWORD PTR [edx+80]
  001df	ff d2		 call	 edx
  001e1	84 c0		 test	 al, al
  001e3	74 05		 je	 SHORT $LN15@SetScreenR
  001e5	8b 4e 30	 mov	 ecx, DWORD PTR [esi+48]
  001e8	eb 10		 jmp	 SHORT $LN19@SetScreenR
$LN15@SetScreenR:

; 3944 : 		else if( nZoomValue < m_nMinDataCountOnOnePage)	nZoomValue = m_nMinDataCountOnOnePage;

  001ea	8b 4e 34	 mov	 ecx, DWORD PTR [esi+52]
  001ed	3b d9		 cmp	 ebx, ecx
  001ef	7c 09		 jl	 SHORT $LN19@SetScreenR

; 3945 : 		else if( m_nItemCount_Total < nZoomValue)		nZoomValue = m_nItemCount_Total;

  001f1	39 5e 58	 cmp	 DWORD PTR [esi+88], ebx
  001f4	8b cb		 mov	 ecx, ebx
  001f6	0f 4c 4e 58	 cmovl	 ecx, DWORD PTR [esi+88]
$LN19@SetScreenR:

; 3946 : 
; 3947 : 		// (2009/1/11 - Seung-Won, Bae) Use Calc_ItemWidth();
; 3948 : 		Calc_ItemWidth( p_nColumn, nZoomValue);

  001fa	6a 00		 push	 0
  001fc	51		 push	 ecx
  001fd	57		 push	 edi
  001fe	8b ce		 mov	 ecx, esi
  00200	e8 00 00 00 00	 call	 ?Calc_ItemWidth@CXScaleManagerImp@@IAEXHHH@Z ; CXScaleManagerImp::Calc_ItemWidth

; 3949 : 
; 3950 : 		// 3. Update ScrollBar and Zoom SliderBar
; 3951 : 		// (2009/1/14 - Seung-Won, Bae) Do not call on No-Recalc for avoding the deadlock.
; 3952 : 		m_pIChartCtrl->UpdateZoomAndScrollInfo( m_nItemCount_Total, m_nDRI_Start_Cur, m_nDrawCount_Cur);

  00205	8b 4e 50	 mov	 ecx, DWORD PTR [esi+80]
  00208	ff 76 30	 push	 DWORD PTR [esi+48]
  0020b	ff 76 28	 push	 DWORD PTR [esi+40]
  0020e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00210	ff 76 58	 push	 DWORD PTR [esi+88]
  00213	ff 90 10 08 00
	00		 call	 DWORD PTR [eax+2064]
  00219	5b		 pop	 ebx
$LN3@SetScreenR:

; 3953 : 	}
; 3954 : }

  0021a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0021d	5f		 pop	 edi
  0021e	33 cd		 xor	 ecx, ebp
  00220	5e		 pop	 esi
  00221	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00226	8b e5		 mov	 esp, ebp
  00228	5d		 pop	 ebp
  00229	c2 10 00	 ret	 16			; 00000010H
?SetScreenRegion@CXScaleManagerImp@@MAEXHHHH@Z ENDP	; CXScaleManagerImp::SetScreenRegion
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.h
;	COMDAT ?SetColumnWidth@CXScaleManagerImp@@MAEXHH@Z
_TEXT	SEGMENT
_p_nColumn$ = 8						; size = 4
_p_nColumnWidth$ = 12					; size = 4
?SetColumnWidth@CXScaleManagerImp@@MAEXHH@Z PROC	; CXScaleManagerImp::SetColumnWidth, COMDAT
; _this$ = ecx

; 499  : 	virtual void					SetColumnWidth( int p_nColumn, int p_nColumnWidth)		{	m_nColumnWidth[ p_nColumn] = p_nColumnWidth;	}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _p_nColumn$[ebp]
  00006	8b 55 0c	 mov	 edx, DWORD PTR _p_nColumnWidth$[ebp]
  00009	89 94 81 30 01
	00 00		 mov	 DWORD PTR [ecx+eax*4+304], edx
  00010	5d		 pop	 ebp
  00011	c2 08 00	 ret	 8
?SetColumnWidth@CXScaleManagerImp@@MAEXHH@Z ENDP	; CXScaleManagerImp::SetColumnWidth
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?GetGraphXAreaSE@CXScaleManagerImp@@MAEXHAAH0H@Z
_TEXT	SEGMENT
_p_nColumn$ = 8						; size = 4
_nStart$ = 12						; size = 4
_nEnd$ = 16						; size = 4
_bIncludeMargin$ = 20					; size = 4
?GetGraphXAreaSE@CXScaleManagerImp@@MAEXHAAH0H@Z PROC	; CXScaleManagerImp::GetGraphXAreaSE, COMDAT
; _this$ = ecx

; 3867 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3868 : 	if(bIncludeMargin == FALSE)

  00003	83 7d 14 00	 cmp	 DWORD PTR _bIncludeMargin$[ebp], 0
  00007	8b 45 0c	 mov	 eax, DWORD PTR _nStart$[ebp]
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	75 1d		 jne	 SHORT $LN2@GetGraphXA

; 3869 : 	{
; 3870 : 		nStart = m_naScreenStart_Cur[ p_nColumn];

  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _p_nColumn$[ebp]
  00012	8b 94 8e 98 02
	00 00		 mov	 edx, DWORD PTR [esi+ecx*4+664]
  00019	89 10		 mov	 DWORD PTR [eax], edx

; 3876 : 		nEnd = m_nScreenEndiM_Cur[ p_nColumn];
; 3877 : 	}
; 3878 : }

  0001b	8b 45 10	 mov	 eax, DWORD PTR _nEnd$[ebp]
  0001e	8b 8c 8e c0 02
	00 00		 mov	 ecx, DWORD PTR [esi+ecx*4+704]
  00025	5e		 pop	 esi
  00026	89 08		 mov	 DWORD PTR [eax], ecx
  00028	5d		 pop	 ebp
  00029	c2 10 00	 ret	 16			; 00000010H
$LN2@GetGraphXA:

; 3871 : 		nEnd = m_naScreenEnd_Cur[ p_nColumn];
; 3872 : 	}
; 3873 : 	else
; 3874 : 	{
; 3875 : 		nStart = m_nScreenStartiM_Cur[ p_nColumn];

  0002c	8b 55 08	 mov	 edx, DWORD PTR _p_nColumn$[ebp]
  0002f	8b 8c 96 e8 02
	00 00		 mov	 ecx, DWORD PTR [esi+edx*4+744]
  00036	89 08		 mov	 DWORD PTR [eax], ecx

; 3876 : 		nEnd = m_nScreenEndiM_Cur[ p_nColumn];
; 3877 : 	}
; 3878 : }

  00038	8b 45 10	 mov	 eax, DWORD PTR _nEnd$[ebp]
  0003b	8b 8c 96 10 03
	00 00		 mov	 ecx, DWORD PTR [esi+edx*4+784]
  00042	5e		 pop	 esi
  00043	89 08		 mov	 DWORD PTR [eax], ecx
  00045	5d		 pop	 ebp
  00046	c2 10 00	 ret	 16			; 00000010H
?GetGraphXAreaSE@CXScaleManagerImp@@MAEXHAAH0H@Z ENDP	; CXScaleManagerImp::GetGraphXAreaSE
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?GetGraphXAreaLR@CXScaleManagerImp@@MAEXHAAH0H@Z
_TEXT	SEGMENT
_p_nColumn$ = 8						; size = 4
_nLeft$ = 12						; size = 4
_nRight$ = 16						; size = 4
_bIncludeMargin$ = 20					; size = 4
?GetGraphXAreaLR@CXScaleManagerImp@@MAEXHAAH0H@Z PROC	; CXScaleManagerImp::GetGraphXAreaLR, COMDAT
; _this$ = ecx

; 3852 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3853 : 	if(bIncludeMargin == FALSE)

  00003	83 7d 14 00	 cmp	 DWORD PTR _bIncludeMargin$[ebp], 0
  00007	8b 45 0c	 mov	 eax, DWORD PTR _nLeft$[ebp]
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	75 1d		 jne	 SHORT $LN2@GetGraphXA

; 3854 : 	{
; 3855 : 		nLeft = m_nScreenLeft_Cur[ p_nColumn];

  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _p_nColumn$[ebp]
  00012	8b 94 8e f8 01
	00 00		 mov	 edx, DWORD PTR [esi+ecx*4+504]
  00019	89 10		 mov	 DWORD PTR [eax], edx

; 3861 : 		nRight = m_nScreenRightiM_Cur[ p_nColumn];
; 3862 : 	}
; 3863 : }

  0001b	8b 45 10	 mov	 eax, DWORD PTR _nRight$[ebp]
  0001e	8b 8c 8e 20 02
	00 00		 mov	 ecx, DWORD PTR [esi+ecx*4+544]
  00025	5e		 pop	 esi
  00026	89 08		 mov	 DWORD PTR [eax], ecx
  00028	5d		 pop	 ebp
  00029	c2 10 00	 ret	 16			; 00000010H
$LN2@GetGraphXA:

; 3856 : 		nRight = m_nScreenRight_Cur[ p_nColumn];
; 3857 : 	}
; 3858 : 	else
; 3859 : 	{
; 3860 : 		nLeft = m_nScreenLeftiM_Cur[ p_nColumn];

  0002c	8b 55 08	 mov	 edx, DWORD PTR _p_nColumn$[ebp]
  0002f	8b 8c 96 48 02
	00 00		 mov	 ecx, DWORD PTR [esi+edx*4+584]
  00036	89 08		 mov	 DWORD PTR [eax], ecx

; 3861 : 		nRight = m_nScreenRightiM_Cur[ p_nColumn];
; 3862 : 	}
; 3863 : }

  00038	8b 45 10	 mov	 eax, DWORD PTR _nRight$[ebp]
  0003b	8b 8c 96 70 02
	00 00		 mov	 ecx, DWORD PTR [esi+edx*4+624]
  00042	5e		 pop	 esi
  00043	89 08		 mov	 DWORD PTR [eax], ecx
  00045	5d		 pop	 ebp
  00046	c2 10 00	 ret	 16			; 00000010H
?GetGraphXAreaLR@CXScaleManagerImp@@MAEXHAAH0H@Z ENDP	; CXScaleManagerImp::GetGraphXAreaLR
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\Dll_Load\XScaleManager.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\Dll_Load\XScaleManager.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\Dll_Load\XScaleManager.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?GetAreaFromDRI@CXScaleManagerImp@@MAEXHHPAPAUtagAREA@CXScaleManager@@@Z
_TEXT	SEGMENT
_p_nColumn$ = 8						; size = 4
_nDRI$ = 12						; size = 4
_pparea$ = 16						; size = 4
?GetAreaFromDRI@CXScaleManagerImp@@MAEXHHPAPAUtagAREA@CXScaleManager@@@Z PROC ; CXScaleManagerImp::GetAreaFromDRI, COMDAT
; _this$ = ecx

; 3813 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b d9		 mov	 ebx, ecx

; 3814 : 	if( !pparea) return;

  00006	8b 4d 10	 mov	 ecx, DWORD PTR _pparea$[ebp]
  00009	85 c9		 test	 ecx, ecx
  0000b	0f 84 14 01 00
	00		 je	 $LN22@GetAreaFro

; 3815 : 	*pparea = NULL;

  00011	56		 push	 esi

; 3816 : 	if( nDRI < 0) return;

  00012	8b 75 0c	 mov	 esi, DWORD PTR _nDRI$[ebp]
  00015	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  0001b	85 f6		 test	 esi, esi
  0001d	0f 88 01 01 00
	00		 js	 $LN27@GetAreaFro

; 3817 : 
; 3818 : 	// on View
; 3819 : 	if( m_nDRI_Start_Cur <= nDRI && nDRI <= m_nDRI_End_Cur + 1)		// (2009/3/2 - Seung-Won, Bae) +1 for right of Last Candle

  00023	8b 53 28	 mov	 edx, DWORD PTR [ebx+40]
  00026	3b d6		 cmp	 edx, esi
  00028	7f 27		 jg	 SHORT $LN26@GetAreaFro
  0002a	8b 43 2c	 mov	 eax, DWORD PTR [ebx+44]
  0002d	40		 inc	 eax
  0002e	3b f0		 cmp	 esi, eax
  00030	7f 1f		 jg	 SHORT $LN26@GetAreaFro

; 3821 : 		*pparea = m_blAreafDRI[ p_nColumn].GetAt( nDRI - m_nDRI_Start_Cur);

  00032	6b 4d 08 34	 imul	 ecx, DWORD PTR _p_nColumn$[ebp], 52
  00036	2b f2		 sub	 esi, edx
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 215  : 	T*	GetAt( int nIndex)	{	return ( T*)GetAtUNK( nIndex);	}

  00038	56		 push	 esi
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 3821 : 		*pparea = m_blAreafDRI[ p_nColumn].GetAt( nDRI - m_nDRI_Start_Cur);

  00039	81 c1 88 03 00
	00		 add	 ecx, 904		; 00000388H
  0003f	03 cb		 add	 ecx, ebx
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 215  : 	T*	GetAt( int nIndex)	{	return ( T*)GetAtUNK( nIndex);	}

  00041	e8 00 00 00 00	 call	 ?GetAtUNK@CDataBlockListUNK@@QAEPAXH@Z ; CDataBlockListUNK::GetAtUNK
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 3821 : 		*pparea = m_blAreafDRI[ p_nColumn].GetAt( nDRI - m_nDRI_Start_Cur);

  00046	8b 4d 10	 mov	 ecx, DWORD PTR _pparea$[ebp]
  00049	5e		 pop	 esi
  0004a	5b		 pop	 ebx
  0004b	89 01		 mov	 DWORD PTR [ecx], eax

; 3848 : }

  0004d	5d		 pop	 ebp
  0004e	c2 0c 00	 ret	 12			; 0000000cH
$LN26@GetAreaFro:
  00051	57		 push	 edi

; 3822 : 		return;
; 3823 : 	}
; 3824 : 
; 3825 : 	*pparea = &m_areaTEMP;

  00052	8d 7b 42	 lea	 edi, DWORD PTR [ebx+66]
  00055	89 39		 mov	 DWORD PTR [ecx], edi

; 3826 : 
; 3827 : 	// left on view.
; 3828 : 	int nDRI_Gap = 0;
; 3829 : 	if( nDRI < m_nDRI_Start_Cur)

  00057	6b 4d 08 34	 imul	 ecx, DWORD PTR _p_nColumn$[ebp], 52
  0005b	81 c1 88 03 00
	00		 add	 ecx, 904		; 00000388H
  00061	03 cb		 add	 ecx, ebx
  00063	3b 73 28	 cmp	 esi, DWORD PTR [ebx+40]
  00066	7d 2b		 jge	 SHORT $LN5@GetAreaFro
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 215  : 	T*	GetAt( int nIndex)	{	return ( T*)GetAtUNK( nIndex);	}

  00068	6a 00		 push	 0
  0006a	e8 00 00 00 00	 call	 ?GetAtUNK@CDataBlockListUNK@@QAEPAXH@Z ; CDataBlockListUNK::GetAtUNK
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 3831 : 		m_pAReturn = m_blAreafDRI[ p_nColumn].GetAt( 0);

  0006f	89 43 64	 mov	 DWORD PTR [ebx+100], eax

; 3832 : 		if( m_pAReturn) m_areaTEMP = *m_pAReturn;

  00072	85 c0		 test	 eax, eax
  00074	74 0c		 je	 SHORT $LN7@GetAreaFro
  00076	8b 08		 mov	 ecx, DWORD PTR [eax]
  00078	89 0f		 mov	 DWORD PTR [edi], ecx
  0007a	66 8b 40 04	 mov	 ax, WORD PTR [eax+4]
  0007e	66 89 47 04	 mov	 WORD PTR [edi+4], ax
$LN7@GetAreaFro:

; 3833 : 
; 3834 : 		nDRI_Gap = m_nDRI_Start_Cur - nDRI;

  00082	8b 4b 28	 mov	 ecx, DWORD PTR [ebx+40]
  00085	2b ce		 sub	 ecx, esi

; 3835 : 		if( !m_bReverse) nDRI_Gap = -nDRI_Gap;
; 3836 : 	}

  00087	2b 73 28	 sub	 esi, DWORD PTR [ebx+40]
  0008a	83 7b 0c 00	 cmp	 DWORD PTR [ebx+12], 0
  0008e	0f 45 f1	 cmovne	 esi, ecx
  00091	eb 28		 jmp	 SHORT $LN10@GetAreaFro
$LN5@GetAreaFro:

; 3840 : 		m_pAReturn = m_blAreafDRI[ p_nColumn].GetAt( m_nDrawCount_Cur - 1);

  00093	8b 43 30	 mov	 eax, DWORD PTR [ebx+48]
  00096	48		 dec	 eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 215  : 	T*	GetAt( int nIndex)	{	return ( T*)GetAtUNK( nIndex);	}

  00097	50		 push	 eax
  00098	e8 00 00 00 00	 call	 ?GetAtUNK@CDataBlockListUNK@@QAEPAXH@Z ; CDataBlockListUNK::GetAtUNK
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 3840 : 		m_pAReturn = m_blAreafDRI[ p_nColumn].GetAt( m_nDrawCount_Cur - 1);

  0009d	89 43 64	 mov	 DWORD PTR [ebx+100], eax

; 3841 : 		if( m_pAReturn) m_areaTEMP = *m_pAReturn;

  000a0	85 c0		 test	 eax, eax
  000a2	74 0c		 je	 SHORT $LN9@GetAreaFro
  000a4	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a6	89 0f		 mov	 DWORD PTR [edi], ecx
  000a8	66 8b 40 04	 mov	 ax, WORD PTR [eax+4]
  000ac	66 89 47 04	 mov	 WORD PTR [edi+4], ax
$LN9@GetAreaFro:

; 3842 : 
; 3843 : 		nDRI_Gap = nDRI - m_nDRI_End_Cur;

  000b0	2b 73 2c	 sub	 esi, DWORD PTR [ebx+44]

; 3844 : 		if( m_bReverse) nDRI_Gap = -nDRI_Gap;

  000b3	83 7b 0c 00	 cmp	 DWORD PTR [ebx+12], 0
  000b7	74 02		 je	 SHORT $LN10@GetAreaFro
  000b9	f7 de		 neg	 esi
$LN10@GetAreaFro:

; 3847 : 	m_areaTEMP.Offset( ROUND( nDRI_Gap * m_daItemWidth[ p_nColumn]));

  000bb	8b 45 08	 mov	 eax, DWORD PTR _p_nColumn$[ebp]
  000be	66 0f 6e c6	 movd	 xmm0, esi
  000c2	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  000c6	f2 0f 59 84 c3
	a8 01 00 00	 mulsd	 xmm0, QWORD PTR [ebx+eax*8+424]
  000cf	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@0000000000000000
  000d7	76 0a		 jbe	 SHORT $LN12@GetAreaFro
  000d9	f2 0f 58 05 00
	00 00 00	 addsd	 xmm0, QWORD PTR __real@3fe0000000000000
  000e1	eb 08		 jmp	 SHORT $LN13@GetAreaFro
$LN12@GetAreaFro:
  000e3	f2 0f 5c 05 00
	00 00 00	 subsd	 xmm0, QWORD PTR __real@3fe0000000000000
$LN13@GetAreaFro:
  000eb	f2 0f 2c c0	 cvttsd2si eax, xmm0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\Dll_Load\XScaleManager.h

; 79   : 			if( nX == SHRT_MIN || nX == SHRT_MAX)

  000ef	b9 00 80 ff ff	 mov	 ecx, -32768		; ffff8000H
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 3847 : 	m_areaTEMP.Offset( ROUND( nDRI_Gap * m_daItemWidth[ p_nColumn]));

  000f4	0f b7 c0	 movzx	 eax, ax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\Dll_Load\XScaleManager.h

; 79   : 			if( nX == SHRT_MIN || nX == SHRT_MAX)

  000f7	66 3b c1	 cmp	 ax, cx
  000fa	74 1c		 je	 SHORT $LN23@GetAreaFro
  000fc	b9 ff 7f 00 00	 mov	 ecx, 32767		; 00007fffH
  00101	66 3b c1	 cmp	 ax, cx
  00104	74 12		 je	 SHORT $LN23@GetAreaFro

; 81   : 			else
; 82   : 			{
; 83   : 				left += nX;

  00106	66 01 07	 add	 WORD PTR [edi], ax

; 84   : 				center += nX;

  00109	66 01 47 02	 add	 WORD PTR [edi+2], ax

; 85   : 				right += nX;

  0010d	66 01 47 04	 add	 WORD PTR [edi+4], ax
  00111	5f		 pop	 edi
  00112	5e		 pop	 esi
  00113	5b		 pop	 ebx
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 3848 : }

  00114	5d		 pop	 ebp
  00115	c2 0c 00	 ret	 12			; 0000000cH
$LN23@GetAreaFro:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\Dll_Load\XScaleManager.h

; 80   : 				left = center = right = nX;

  00118	66 89 47 04	 mov	 WORD PTR [edi+4], ax
  0011c	66 89 47 02	 mov	 WORD PTR [edi+2], ax
  00120	66 89 07	 mov	 WORD PTR [edi], ax
  00123	5f		 pop	 edi
$LN27@GetAreaFro:
  00124	5e		 pop	 esi
$LN22@GetAreaFro:
  00125	5b		 pop	 ebx
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 3848 : }

  00126	5d		 pop	 ebp
  00127	c2 0c 00	 ret	 12			; 0000000cH
?GetAreaFromDRI@CXScaleManagerImp@@MAEXHHPAPAUtagAREA@CXScaleManager@@@Z ENDP ; CXScaleManagerImp::GetAreaFromDRI
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?IsInGraphXArea@CXScaleManagerImp@@MAEHHHH@Z
_TEXT	SEGMENT
_p_nColumn$ = 8						; size = 4
_nX$ = 12						; size = 4
_bIncludeEqual$ = 16					; size = 4
?IsInGraphXArea@CXScaleManagerImp@@MAEHHHH@Z PROC	; CXScaleManagerImp::IsInGraphXArea, COMDAT
; _this$ = ecx

; 3806 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3807 : 	if( bIncludeEqual == FALSE)	return ( m_nScreenLeft_Cur[ p_nColumn] < nX && m_nScreenRight_Cur[ p_nColumn] > nX);

  00003	83 7d 10 00	 cmp	 DWORD PTR _bIncludeEqual$[ebp], 0
  00007	8b 45 08	 mov	 eax, DWORD PTR _p_nColumn$[ebp]
  0000a	8b 55 0c	 mov	 edx, DWORD PTR _nX$[ebp]
  0000d	75 18		 jne	 SHORT $LN2@IsInGraphX
  0000f	39 94 81 f8 01
	00 00		 cmp	 DWORD PTR [ecx+eax*4+504], edx
  00016	7d 09		 jge	 SHORT $LN7@IsInGraphX
  00018	39 94 81 20 02
	00 00		 cmp	 DWORD PTR [ecx+eax*4+544], edx
  0001f	7f 18		 jg	 SHORT $LN9@IsInGraphX
$LN7@IsInGraphX:

; 3809 : }

  00021	33 c0		 xor	 eax, eax
  00023	5d		 pop	 ebp
  00024	c2 0c 00	 ret	 12			; 0000000cH
$LN2@IsInGraphX:

; 3808 : 	else						return ( m_nScreenLeft_Cur[ p_nColumn] <= nX && m_nScreenRight_Cur[ p_nColumn] >= nX);

  00027	39 94 81 f8 01
	00 00		 cmp	 DWORD PTR [ecx+eax*4+504], edx
  0002e	7f f1		 jg	 SHORT $LN7@IsInGraphX
  00030	39 94 81 20 02
	00 00		 cmp	 DWORD PTR [ecx+eax*4+544], edx
  00037	7c e8		 jl	 SHORT $LN7@IsInGraphX
$LN9@IsInGraphX:

; 3809 : }

  00039	b8 01 00 00 00	 mov	 eax, 1
  0003e	5d		 pop	 ebp
  0003f	c2 0c 00	 ret	 12			; 0000000cH
?IsInGraphXArea@CXScaleManagerImp@@MAEHHHH@Z ENDP	; CXScaleManagerImp::IsInGraphXArea
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?IsAllOnePixel@CXScaleManagerImp@@MAEHHPBD@Z
_TEXT	SEGMENT
_p_nColumn$ = 8						; size = 4
_p_szRQ$ = 12						; size = 4
?IsAllOnePixel@CXScaleManagerImp@@MAEHHPBD@Z PROC	; CXScaleManagerImp::IsAllOnePixel, COMDAT
; _this$ = ecx

; 3792 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	57		 push	 edi

; 3793 : 	if( m_nCountOfBlockColumn < 0) return FALSE;

  00007	8b 86 2c 01 00
	00		 mov	 eax, DWORD PTR [esi+300]
  0000d	85 c0		 test	 eax, eax
  0000f	78 65		 js	 SHORT $LN4@IsAllOnePi

; 3794 : 	if( p_nColumn < 0 || m_nCountOfBlockColumn <= p_nColumn) return FALSE;

  00011	8b 7d 08	 mov	 edi, DWORD PTR _p_nColumn$[ebp]
  00014	85 ff		 test	 edi, edi
  00016	78 5e		 js	 SHORT $LN4@IsAllOnePi
  00018	3b c7		 cmp	 eax, edi
  0001a	7e 5a		 jle	 SHORT $LN4@IsAllOnePi

; 3795 : 
; 3796 : 	int nRQ = GetRQIndexFromString( p_szRQ);

  0001c	51		 push	 ecx
  0001d	8b cc		 mov	 ecx, esp
  0001f	ff 75 0c	 push	 DWORD PTR _p_szRQ$[ebp]
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  00028	8b 06		 mov	 eax, DWORD PTR [esi]
  0002a	8b ce		 mov	 ecx, esi
  0002c	ff 50 04	 call	 DWORD PTR [eax+4]

; 3797 : 	if( nRQ < 0) return FALSE;

  0002f	85 c0		 test	 eax, eax
  00031	78 43		 js	 SHORT $LN4@IsAllOnePi

; 3798 : 	if( m_minScaleInterval_eType != m_pifaRQ[ nRQ]->eScaleUnit
; 3799 : 		|| m_minScaleInterval_nUnit != m_pifaRQ[ nRQ]->nScaleInterval_Unit) return FALSE;

  00033	8b 8e 8c 00 00
	00		 mov	 ecx, DWORD PTR [esi+140]
  00039	8b 0c 81	 mov	 ecx, DWORD PTR [ecx+eax*4]
  0003c	8b 86 f0 00 00
	00		 mov	 eax, DWORD PTR [esi+240]
  00042	3b 41 14	 cmp	 eax, DWORD PTR [ecx+20]
  00045	75 2f		 jne	 SHORT $LN4@IsAllOnePi
  00047	8b 86 f4 00 00
	00		 mov	 eax, DWORD PTR [esi+244]
  0004d	3b 41 18	 cmp	 eax, DWORD PTR [ecx+24]
  00050	75 24		 jne	 SHORT $LN4@IsAllOnePi

; 3800 : 	
; 3801 : 	return m_daItemWidth[ p_nColumn] < 1 && !m_bWeightedVolume;

  00052	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@3ff0000000000000
  0005a	66 0f 2f 84 fe
	a8 01 00 00	 comisd	 xmm0, QWORD PTR [esi+edi*8+424]
  00063	76 11		 jbe	 SHORT $LN4@IsAllOnePi
  00065	83 7e 10 00	 cmp	 DWORD PTR [esi+16], 0
  00069	75 0b		 jne	 SHORT $LN4@IsAllOnePi
  0006b	b8 01 00 00 00	 mov	 eax, 1

; 3802 : }

  00070	5f		 pop	 edi
  00071	5e		 pop	 esi
  00072	5d		 pop	 ebp
  00073	c2 08 00	 ret	 8
$LN4@IsAllOnePi:
  00076	5f		 pop	 edi
  00077	33 c0		 xor	 eax, eax
  00079	5e		 pop	 esi
  0007a	5d		 pop	 ebp
  0007b	c2 08 00	 ret	 8
?IsAllOnePixel@CXScaleManagerImp@@MAEHHPBD@Z ENDP	; CXScaleManagerImp::IsAllOnePixel
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?GetDTInAREAfRQnPt@CXScaleManagerImp@@MAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HAAHPAHPAUtagAREA@CXScaleManager@@H@Z
_TEXT	SEGMENT
_pifRQ$1$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_strRQ$ = 8						; size = 4
_nRQ$1$ = 12						; size = 4
_nCursor_x$ = 12					; size = 4
_nBlockColumn$ = 16					; size = 4
_pnDTI$ = 20						; size = 4
_parea$ = 24						; size = 4
_pblAreafDTI$1$ = 28					; size = 4
_p_bWithBoundCheck$ = 28				; size = 4
?GetDTInAREAfRQnPt@CXScaleManagerImp@@MAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HAAHPAHPAUtagAREA@CXScaleManager@@H@Z PROC ; CXScaleManagerImp::GetDTInAREAfRQnPt, COMDAT
; _this$ = ecx

; 3729 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?GetDTInAREAfRQnPt@CXScaleManagerImp@@MAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HAAHPAHPAUtagAREA@CXScaleManager@@H@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	53		 push	 ebx
  00013	56		 push	 esi
  00014	57		 push	 edi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8b f1		 mov	 esi, ecx

; 3730 : 	*pnDTI = -1;

  00028	8b 45 14	 mov	 eax, DWORD PTR _pnDTI$[ebp]
  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00032	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1

; 3733 : 	if(!IsUseable() || strRQ.IsEmpty()) return FALSE;

  00038	8b 06		 mov	 eax, DWORD PTR [esi]
  0003a	ff 90 e8 00 00
	00		 call	 DWORD PTR [eax+232]
  00040	85 c0		 test	 eax, eax
  00042	0f 84 08 01 00
	00		 je	 $LN3@GetDTInARE
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h

; 533  : 		return( GetLength() == 0 );

  00048	8b 45 08	 mov	 eax, DWORD PTR _strRQ$[ebp]
  0004b	83 78 f4 00	 cmp	 DWORD PTR [eax-12], 0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 3733 : 	if(!IsUseable() || strRQ.IsEmpty()) return FALSE;

  0004f	0f 84 fb 00 00
	00		 je	 $LN3@GetDTInARE

; 3734 : 
; 3735 : 	//	string stringRQ((LPSTR)(LPCSTR)strRQ);
; 3736 : 
; 3737 : 	int nDTI_Org, nDRI;
; 3738 : 
; 3739 : 	nDRI = GetDRInFromPt( nCursor_x, &nBlockColumn, NULL, FALSE, p_bWithBoundCheck);

  00055	ff 75 1c	 push	 DWORD PTR _p_bWithBoundCheck$[ebp]
  00058	8b 06		 mov	 eax, DWORD PTR [esi]
  0005a	8b ce		 mov	 ecx, esi
  0005c	6a 00		 push	 0
  0005e	6a 00		 push	 0
  00060	ff 75 10	 push	 DWORD PTR _nBlockColumn$[ebp]
  00063	ff 75 0c	 push	 DWORD PTR _nCursor_x$[ebp]
  00066	ff 90 14 01 00
	00		 call	 DWORD PTR [eax+276]
  0006c	8b f8		 mov	 edi, eax

; 3740 : 
; 3741 : 	// (2008/8/14 - Seung-Won, Bae) Support Checking of DRI Bound
; 3742 : 	if( nDRI < 0) return FALSE;

  0006e	85 ff		 test	 edi, edi
  00070	0f 88 da 00 00
	00		 js	 $LN3@GetDTInARE

; 3743 : 	
; 3744 : 	RQ_INFO* pifRQ = NULL;
; 3745 : 	int nRQ = GetRQIndexFromString( strRQ);

  00076	51		 push	 ecx
  00077	8d 45 08	 lea	 eax, DWORD PTR _strRQ$[ebp]
  0007a	8b cc		 mov	 ecx, esp
  0007c	50		 push	 eax
  0007d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z
  00083	8b 06		 mov	 eax, DWORD PTR [esi]
  00085	8b ce		 mov	 ecx, esi
  00087	ff 50 04	 call	 DWORD PTR [eax+4]
  0008a	8b c8		 mov	 ecx, eax
  0008c	89 4d 0c	 mov	 DWORD PTR _nRQ$1$[ebp], ecx

; 3746 : 	if( nRQ < 0) return FALSE;

  0008f	85 c9		 test	 ecx, ecx
  00091	0f 88 b9 00 00
	00		 js	 $LN3@GetDTInARE

; 3747 : 	pifRQ = m_pifaRQ[ nRQ];

  00097	8b 86 8c 00 00
	00		 mov	 eax, DWORD PTR [esi+140]
  0009d	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
  000a0	89 45 f0	 mov	 DWORD PTR _pifRQ$1$[ebp], eax

; 3748 : 
; 3749 : 	CDataBlockList<int>* pblDTIfDRI = m_pblaDTIfDRI[ nRQ];

  000a3	8b 86 a8 00 00
	00		 mov	 eax, DWORD PTR [esi+168]
  000a9	8b 1c 88	 mov	 ebx, DWORD PTR [eax+ecx*4]

; 3750 : 	if( !pblDTIfDRI) return FALSE;

  000ac	85 db		 test	 ebx, ebx
  000ae	0f 84 9c 00 00
	00		 je	 $LN3@GetDTInARE

; 3751 : 
; 3752 : 	int nCountOfDRI_RQ = pblDTIfDRI->GetItemCount();

  000b4	8b cb		 mov	 ecx, ebx
  000b6	e8 00 00 00 00	 call	 ?GetItemCount@CDataBlockListUNK@@QAEHXZ ; CDataBlockListUNK::GetItemCount

; 3753 : 	if(nCountOfDRI_RQ <= nDRI) nDRI = nCountOfDRI_RQ - 1;

  000bb	3b c7		 cmp	 eax, edi
  000bd	7f 03		 jg	 SHORT $LN7@GetDTInARE
  000bf	8d 78 ff	 lea	 edi, DWORD PTR [eax-1]
$LN7@GetDTInARE:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 215  : 	T*	GetAt( int nIndex)	{	return ( T*)GetAtUNK( nIndex);	}

  000c2	57		 push	 edi
  000c3	8b cb		 mov	 ecx, ebx
  000c5	e8 00 00 00 00	 call	 ?GetAtUNK@CDataBlockListUNK@@QAEPAXH@Z ; CDataBlockListUNK::GetAtUNK
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 3756 : 	if( m_pIReturn) *pnDTI = nDTI_Org = *m_pIReturn;

  000ca	8b 4d 14	 mov	 ecx, DWORD PTR _pnDTI$[ebp]
  000cd	89 46 60	 mov	 DWORD PTR [esi+96], eax
  000d0	85 c0		 test	 eax, eax
  000d2	74 04		 je	 SHORT $LN30@GetDTInARE
  000d4	8b 00		 mov	 eax, DWORD PTR [eax]
  000d6	89 01		 mov	 DWORD PTR [ecx], eax
$LN30@GetDTInARE:

; 3757 : 
; 3758 : 	TRACE("\nx:%d, DRI:%d, DTI:%d", nCursor_x, nDRI, *pnDTI);
; 3759 : 
; 3760 : 	if(parea != NULL)

  000d8	8b 5d 18	 mov	 ebx, DWORD PTR _parea$[ebp]
  000db	85 db		 test	 ebx, ebx
  000dd	74 65		 je	 SHORT $LN13@GetDTInARE

; 3761 : 	{
; 3762 : 		*parea = m_areaNONE;

  000df	8b 46 3c	 mov	 eax, DWORD PTR [esi+60]
  000e2	89 03		 mov	 DWORD PTR [ebx], eax
  000e4	66 8b 46 40	 mov	 ax, WORD PTR [esi+64]
  000e8	66 89 43 04	 mov	 WORD PTR [ebx+4], ax

; 3763 : 
; 3764 : 		if(*pnDTI >= 0)

  000ec	8b 39		 mov	 edi, DWORD PTR [ecx]
  000ee	85 ff		 test	 edi, edi
  000f0	78 52		 js	 SHORT $LN13@GetDTInARE

; 3765 : 		{
; 3766 : 			CDataBlockList< AREA> *pblAreafDTI = NULL;
; 3767 : 			if( 0 <= nRQ && m_pblaAreafDTI[ nBlockColumn] && m_nCountOfRQ_Area == m_nCountOfRQ)

  000f2	8b 45 10	 mov	 eax, DWORD PTR _nBlockColumn$[ebp]
  000f5	33 c9		 xor	 ecx, ecx
  000f7	89 4d 1c	 mov	 DWORD PTR _pblAreafDTI$1$[ebp], ecx
  000fa	8b 00		 mov	 eax, DWORD PTR [eax]
  000fc	8b 94 86 90 05
	00 00		 mov	 edx, DWORD PTR [esi+eax*4+1424]
  00103	85 d2		 test	 edx, edx
  00105	74 11		 je	 SHORT $LN11@GetDTInARE
  00107	8b 46 54	 mov	 eax, DWORD PTR [esi+84]
  0010a	3b 46 6c	 cmp	 eax, DWORD PTR [esi+108]
  0010d	75 09		 jne	 SHORT $LN11@GetDTInARE

; 3768 : 				pblAreafDTI = m_pblaAreafDTI[ nBlockColumn][ nRQ];

  0010f	8b 4d 0c	 mov	 ecx, DWORD PTR _nRQ$1$[ebp]
  00112	8b 0c 8a	 mov	 ecx, DWORD PTR [edx+ecx*4]
  00115	89 4d 1c	 mov	 DWORD PTR _pblAreafDTI$1$[ebp], ecx
$LN11@GetDTInARE:

; 3769 : 
; 3770 : 			int nDTI_View = *pnDTI - pifRQ->nDTI_Start_Data;

  00118	8b 45 f0	 mov	 eax, DWORD PTR _pifRQ$1$[ebp]
  0011b	2b 78 0c	 sub	 edi, DWORD PTR [eax+12]

; 3771 : 
; 3772 : 			if( pblAreafDTI) if( nDTI_View >= 0 && nDTI_View < pblAreafDTI->GetItemCount())

  0011e	85 c9		 test	 ecx, ecx
  00120	74 22		 je	 SHORT $LN13@GetDTInARE
  00122	85 ff		 test	 edi, edi
  00124	78 1e		 js	 SHORT $LN13@GetDTInARE
  00126	e8 00 00 00 00	 call	 ?GetItemCount@CDataBlockListUNK@@QAEHXZ ; CDataBlockListUNK::GetItemCount
  0012b	3b f8		 cmp	 edi, eax
  0012d	7d 15		 jge	 SHORT $LN13@GetDTInARE

; 3773 : 				*parea = *((PAREA)pblAreafDTI->GetAtUNK(nDTI_View));

  0012f	8b 4d 1c	 mov	 ecx, DWORD PTR _pblAreafDTI$1$[ebp]
  00132	57		 push	 edi
  00133	e8 00 00 00 00	 call	 ?GetAtUNK@CDataBlockListUNK@@QAEPAXH@Z ; CDataBlockListUNK::GetAtUNK
  00138	8b 08		 mov	 ecx, DWORD PTR [eax]
  0013a	89 0b		 mov	 DWORD PTR [ebx], ecx
  0013c	66 8b 40 04	 mov	 ax, WORD PTR [eax+4]
  00140	66 89 43 04	 mov	 WORD PTR [ebx+4], ax
$LN13@GetDTInARE:

; 3774 : 			// (2009/1/10 - Seung-Won, Bae) why do you check the m_drawinfo ? 
; 3775 : 			//	{
; 3776 : 			//		if(m_drawinfo.pAreafDTI != NULL)
; 3777 : 			//		{
; 3778 : 			//			*parea = *((PAREA)pblAreafDTI->GetAtUNK(nDTI_View));
; 3779 : 			//			TRACE(" AREA:(%d,%d,%d)", parea->left, parea->center, parea->right);
; 3780 : 			//		}	
; 3781 : 			//	}
; 3782 : 		}
; 3783 : 	}
; 3784 : 
; 3785 : 	TRACE("\n");
; 3786 : 	
; 3787 : 	return (*pnDTI >= 0);

  00144	8b 45 14	 mov	 eax, DWORD PTR _pnDTI$[ebp]
  00147	8b 30		 mov	 esi, DWORD PTR [eax]
  00149	f7 d6		 not	 esi
  0014b	c1 ee 1f	 shr	 esi, 31			; 0000001fH
  0014e	eb 02		 jmp	 SHORT $LN20@GetDTInARE
$LN3@GetDTInARE:
  00150	33 f6		 xor	 esi, esi
$LN20@GetDTInARE:
  00152	8d 4d 08	 lea	 ecx, DWORD PTR _strRQ$[ebp]
  00155	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0015b	8b c6		 mov	 eax, esi

; 3788 : }

  0015d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00160	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00167	59		 pop	 ecx
  00168	5f		 pop	 edi
  00169	5e		 pop	 esi
  0016a	5b		 pop	 ebx
  0016b	8b e5		 mov	 esp, ebp
  0016d	5d		 pop	 ebp
  0016e	c2 18 00	 ret	 24			; 00000018H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetDTInAREAfRQnPt@CXScaleManagerImp@@MAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HAAHPAHPAUtagAREA@CXScaleManager@@H@Z$0:
  00000	8d 4d 08	 lea	 ecx, DWORD PTR _strRQ$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
  0000d	cc		 int	 3
__ehhandler$?GetDTInAREAfRQnPt@CXScaleManagerImp@@MAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HAAHPAHPAUtagAREA@CXScaleManager@@H@Z:
  0000e	90		 npad	 1
  0000f	90		 npad	 1
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?GetDTInAREAfRQnPt@CXScaleManagerImp@@MAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HAAHPAHPAUtagAREA@CXScaleManager@@H@Z
  00026	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?GetDTInAREAfRQnPt@CXScaleManagerImp@@MAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HAAHPAHPAUtagAREA@CXScaleManager@@H@Z ENDP ; CXScaleManagerImp::GetDTInAREAfRQnPt
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?GetDTInAREAfRQnPt@CXScaleManagerImp@@MAEHHAAHPAHPAUtagAREA@CXScaleManager@@@Z
_TEXT	SEGMENT
_nCursor_x$ = 8						; size = 4
_nBlockColumn$ = 12					; size = 4
_pnDTI$ = 16						; size = 4
_parea$ = 20						; size = 4
?GetDTInAREAfRQnPt@CXScaleManagerImp@@MAEHHAAHPAHPAUtagAREA@CXScaleManager@@@Z PROC ; CXScaleManagerImp::GetDTInAREAfRQnPt, COMDAT
; _this$ = ecx

; 3719 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 3720 : 	if(m_ppacketListManager)

  00005	6a 00		 push	 0
  00007	ff 75 14	 push	 DWORD PTR _parea$[ebp]
  0000a	8b f9		 mov	 edi, ecx
  0000c	ff 75 10	 push	 DWORD PTR _pnDTI$[ebp]
  0000f	ff 75 0c	 push	 DWORD PTR _nBlockColumn$[ebp]
  00012	83 7f 48 00	 cmp	 DWORD PTR [edi+72], 0
  00016	ff 75 08	 push	 DWORD PTR _nCursor_x$[ebp]
  00019	74 13		 je	 SHORT $LN2@GetDTInARE

; 3721 : 		return GetDTInAREAfRQnPt( m_pIChartCtrl->GetCurrentRQ(), nCursor_x, nBlockColumn, pnDTI, parea);

  0001b	8b 4f 50	 mov	 ecx, DWORD PTR [edi+80]
  0001e	51		 push	 ecx
  0001f	8b f4		 mov	 esi, esp
  00021	8b 01		 mov	 eax, DWORD PTR [ecx]
  00023	ff 90 d8 02 00
	00		 call	 DWORD PTR [eax+728]
  00029	50		 push	 eax
  0002a	8b ce		 mov	 ecx, esi
  0002c	eb 08		 jmp	 SHORT $LN7@GetDTInARE
$LN2@GetDTInARE:

; 3722 : 	else
; 3723 : 		return GetDTInAREAfRQnPt(_T("DEFAULT"), nCursor_x, nBlockColumn, pnDTI, parea);

  0002e	51		 push	 ecx
  0002f	8b cc		 mov	 ecx, esp
  00031	68 00 00 00 00	 push	 OFFSET ??_C@_07MGCPDNLD@DEFAULT@
$LN7@GetDTInARE:

; 3724 : }

  00036	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  0003c	8b 07		 mov	 eax, DWORD PTR [edi]
  0003e	8b cf		 mov	 ecx, edi
  00040	ff 90 34 01 00
	00		 call	 DWORD PTR [eax+308]
  00046	5f		 pop	 edi
  00047	5e		 pop	 esi
  00048	5d		 pop	 ebp
  00049	c2 10 00	 ret	 16			; 00000010H
?GetDTInAREAfRQnPt@CXScaleManagerImp@@MAEHHAAHPAHPAUtagAREA@CXScaleManager@@@Z ENDP ; CXScaleManagerImp::GetDTInAREAfRQnPt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\stdlib.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\stdlib.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\stdlib.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\stdlib.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\stdlib.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\stdlib.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?GetXFromTime@CXScaleManagerImp@@MAEHH_JPAPAUtagAREA@CXScaleManager@@H@Z
_TEXT	SEGMENT
_dTimeSpan_Item$1$ = -40				; size = 8
_timeLast$ = -40					; size = 8
_timeFirst$ = -40					; size = 8
_parea$ = -32						; size = 4
_timePrev$2$ = -28					; size = 4
_timeTemp$3$ = -28					; size = 4
_timeLast$1$ = -28					; size = 4
_nDRI_Prev$1$ = -28					; size = 4
_timeEnd$1 = -24					; size = 8
_timePrev$4$ = -20					; size = 4
tv518 = -20						; size = 4
tv800 = -16						; size = 8
tv794 = -16						; size = 8
_timePrev$1$ = -12					; size = 4
_timeTemp$5$ = -12					; size = 4
_timeTemp$1$ = -12					; size = 4
_timeDRI_Start$1$ = -12					; size = 4
_timeFirst$1$ = -12					; size = 4
_nDRI_Prev$2$ = -12					; size = 4
_timePrev$3$ = -8					; size = 4
_timeTemp$2$ = -8					; size = 4
_timeDRI_Start$2$ = -8					; size = 4
_nCountOfDRI$1$ = -4					; size = 4
_p_nColumn$ = 8						; size = 4
tv693 = 12						; size = 8
tv687 = 12						; size = 8
_timeNext$ = 12						; size = 8
_timePrev$ = 12						; size = 8
_timeTemp$ = 12						; size = 8
_timeDRI_Start$ = 12					; size = 8
_timeFind$ = 12						; size = 8
_pparea$ = 20						; size = 4
_timeNext$4$ = 24					; size = 4
_timeNext$3$ = 24					; size = 4
_timeTemp$6$ = 24					; size = 4
_timeTemp$4$ = 24					; size = 4
_nDRI$ = 24						; size = 4
_bIncludeRightMargin$ = 24				; size = 4
?GetXFromTime@CXScaleManagerImp@@MAEHH_JPAPAUtagAREA@CXScaleManager@@H@Z PROC ; CXScaleManagerImp::GetXFromTime, COMDAT
; _this$ = ecx

; 3583 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	53		 push	 ebx
  00007	8b d9		 mov	 ebx, ecx
  00009	56		 push	 esi
  0000a	57		 push	 edi

; 3589 : 	int nCountOfDRI = m_blTimefDRI.GetItemCount();

  0000b	8d b3 ac 00 00
	00		 lea	 esi, DWORD PTR [ebx+172]
  00011	8b ce		 mov	 ecx, esi
  00013	e8 00 00 00 00	 call	 ?GetItemCount@CDataBlockListUNK@@QAEHXZ ; CDataBlockListUNK::GetItemCount
  00018	8b f8		 mov	 edi, eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 215  : 	T*	GetAt( int nIndex)	{	return ( T*)GetAtUNK( nIndex);	}

  0001a	8b ce		 mov	 ecx, esi
  0001c	6a 00		 push	 0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 3589 : 	int nCountOfDRI = m_blTimefDRI.GetItemCount();

  0001e	89 7d fc	 mov	 DWORD PTR _nCountOfDRI$1$[ebp], edi
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 215  : 	T*	GetAt( int nIndex)	{	return ( T*)GetAtUNK( nIndex);	}

  00021	e8 00 00 00 00	 call	 ?GetAtUNK@CDataBlockListUNK@@QAEPAXH@Z ; CDataBlockListUNK::GetAtUNK
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 3592 : 	m_pTReturn = m_blTimefDRI.GetAt( 0);

  00026	89 43 5c	 mov	 DWORD PTR [ebx+92], eax

; 3593 : 	if( m_pTReturn) timeFirst = *m_pTReturn;

  00029	85 c0		 test	 eax, eax
  0002b	74 0d		 je	 SHORT $LN100@GetXFromTi
  0002d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00032	89 4d f4	 mov	 DWORD PTR _timeFirst$1$[ebp], ecx
  00035	89 45 dc	 mov	 DWORD PTR _timeFirst$[ebp+4], eax
  00038	eb 06		 jmp	 SHORT $LN11@GetXFromTi
$LN100@GetXFromTi:
  0003a	8b 45 d8	 mov	 eax, DWORD PTR _timeFirst$[ebp]
  0003d	89 45 f4	 mov	 DWORD PTR _timeFirst$1$[ebp], eax
$LN11@GetXFromTi:

; 3594 : 	m_pTReturn = m_blTimefDRI.GetAt( nCountOfDRI - 1);

  00040	8d 47 ff	 lea	 eax, DWORD PTR [edi-1]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 215  : 	T*	GetAt( int nIndex)	{	return ( T*)GetAtUNK( nIndex);	}

  00043	8b ce		 mov	 ecx, esi
  00045	50		 push	 eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 3594 : 	m_pTReturn = m_blTimefDRI.GetAt( nCountOfDRI - 1);

  00046	89 45 ec	 mov	 DWORD PTR tv518[ebp], eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 215  : 	T*	GetAt( int nIndex)	{	return ( T*)GetAtUNK( nIndex);	}

  00049	e8 00 00 00 00	 call	 ?GetAtUNK@CDataBlockListUNK@@QAEPAXH@Z ; CDataBlockListUNK::GetAtUNK
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 3598 : 	int nTimeSpan_Find = timeFind - timeFirst;

  0004e	8b 55 0c	 mov	 edx, DWORD PTR _timeFind$[ebp]
  00051	2b 55 f4	 sub	 edx, DWORD PTR _timeFirst$1$[ebp]
  00054	89 43 5c	 mov	 DWORD PTR [ebx+92], eax
  00057	8b 08		 mov	 ecx, DWORD PTR [eax]
  00059	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0005c	89 45 dc	 mov	 DWORD PTR _timeLast$[ebp+4], eax
  0005f	8b c1		 mov	 eax, ecx
  00061	2b 45 f4	 sub	 eax, DWORD PTR _timeFirst$1$[ebp]
  00064	89 4d e4	 mov	 DWORD PTR _timeLast$1$[ebp], ecx
  00067	66 0f 6e c8	 movd	 xmm1, eax

; 3599 : 	double dTimeSpan_Item = (double)nTimeSpan;

  0006b	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1
  0006f	f2 0f 11 4d d8	 movsd	 QWORD PTR _dTimeSpan_Item$1$[ebp], xmm1

; 3600 : 	if( 0 < nCountOfDRI) dTimeSpan_Item /= (double)nCountOfDRI;

  00074	85 ff		 test	 edi, edi
  00076	7e 11		 jle	 SHORT $LN12@GetXFromTi
  00078	66 0f 6e c7	 movd	 xmm0, edi
  0007c	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00080	f2 0f 5e c8	 divsd	 xmm1, xmm0
  00084	f2 0f 11 4d d8	 movsd	 QWORD PTR _dTimeSpan_Item$1$[ebp], xmm1
$LN12@GetXFromTi:

; 3601 : 
; 3602 : 	if( 0 < dTimeSpan_Item) nDRI = ceil((double)nTimeSpan_Find / dTimeSpan_Item);

  00089	0f 57 c0	 xorps	 xmm0, xmm0
  0008c	66 0f 2f c8	 comisd	 xmm1, xmm0
  00090	76 2c		 jbe	 SHORT $LN101@GetXFromTi
  00092	66 0f 6e c2	 movd	 xmm0, edx
  00096	83 ec 08	 sub	 esp, 8
  00099	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  0009d	f2 0f 5e c1	 divsd	 xmm0, xmm1
  000a1	f2 0f 11 45 f0	 movsd	 QWORD PTR tv800[ebp], xmm0
  000a6	dd 45 f0	 fld	 QWORD PTR tv800[ebp]
  000a9	dd 1c 24	 fstp	 QWORD PTR [esp]
  000ac	e8 00 00 00 00	 call	 _ceil
  000b1	dd 5d f0	 fstp	 QWORD PTR tv794[ebp]
  000b4	f2 0f 2c 45 f0	 cvttsd2si eax, QWORD PTR tv794[ebp]
  000b9	83 c4 08	 add	 esp, 8
  000bc	eb 03		 jmp	 SHORT $LN13@GetXFromTi
$LN101@GetXFromTi:
  000be	8b 45 18	 mov	 eax, DWORD PTR _nDRI$[ebp]
$LN13@GetXFromTi:

; 3605 : 	if(nDRI >= nCountOfDRI)		nDRI = nCountOfDRI - 1;

  000c1	33 ff		 xor	 edi, edi
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 215  : 	T*	GetAt( int nIndex)	{	return ( T*)GetAtUNK( nIndex);	}

  000c3	8b ce		 mov	 ecx, esi
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 3605 : 	if(nDRI >= nCountOfDRI)		nDRI = nCountOfDRI - 1;

  000c5	85 c0		 test	 eax, eax
  000c7	0f 49 f8	 cmovns	 edi, eax
  000ca	3b 7d fc	 cmp	 edi, DWORD PTR _nCountOfDRI$1$[ebp]
  000cd	0f 4d 7d ec	 cmovge	 edi, DWORD PTR tv518[ebp]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 215  : 	T*	GetAt( int nIndex)	{	return ( T*)GetAtUNK( nIndex);	}

  000d1	57		 push	 edi
  000d2	e8 00 00 00 00	 call	 ?GetAtUNK@CDataBlockListUNK@@QAEPAXH@Z ; CDataBlockListUNK::GetAtUNK
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 3607 : 	m_pTReturn = m_blTimefDRI.GetAt( nDRI);

  000d7	89 43 5c	 mov	 DWORD PTR [ebx+92], eax

; 3608 : 	if( m_pTReturn) timeDRI_Start = *m_pTReturn;

  000da	85 c0		 test	 eax, eax
  000dc	74 07		 je	 SHORT $LN102@GetXFromTi
  000de	8b 08		 mov	 ecx, DWORD PTR [eax]
  000e0	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000e3	eb 06		 jmp	 SHORT $LN111@GetXFromTi
$LN102@GetXFromTi:
  000e5	8b 45 10	 mov	 eax, DWORD PTR _timeDRI_Start$[ebp+4]
  000e8	8b 4d 0c	 mov	 ecx, DWORD PTR _timeDRI_Start$[ebp]
$LN111@GetXFromTi:

; 3609 : 
; 3610 : 	m_blTimefDRI.SetIndex(nDRI);

  000eb	89 4d f4	 mov	 DWORD PTR _timeDRI_Start$1$[ebp], ecx
  000ee	8b ce		 mov	 ecx, esi
  000f0	57		 push	 edi
  000f1	89 45 f8	 mov	 DWORD PTR _timeDRI_Start$2$[ebp], eax
  000f4	e8 00 00 00 00	 call	 ?SetIndex@CDataBlockListUNK@@QAEXH@Z ; CDataBlockListUNK::SetIndex

; 3611 : 
; 3612 : 	if(timeDRI_Start > timeFind)

  000f9	8b 4d 10	 mov	 ecx, DWORD PTR _timeFind$[ebp+4]
  000fc	39 4d f8	 cmp	 DWORD PTR _timeDRI_Start$2$[ebp], ecx
  000ff	0f 8c ec 00 00
	00		 jl	 $LN107@GetXFromTi
  00105	7f 0e		 jg	 SHORT $LN97@GetXFromTi
  00107	8b 45 0c	 mov	 eax, DWORD PTR _timeFind$[ebp]
  0010a	8b 55 f4	 mov	 edx, DWORD PTR _timeDRI_Start$1$[ebp]
  0010d	3b d0		 cmp	 edx, eax
  0010f	0f 86 e2 00 00
	00		 jbe	 $LN17@GetXFromTi
$LN97@GetXFromTi:
  00115	8b 45 10	 mov	 eax, DWORD PTR _timeTemp$[ebp+4]
  00118	8b 7d 0c	 mov	 edi, DWORD PTR _timeFind$[ebp]
  0011b	89 45 18	 mov	 DWORD PTR _timeTemp$4$[ebp], eax
  0011e	8b 45 0c	 mov	 eax, DWORD PTR _timeTemp$[ebp]
  00121	89 45 f4	 mov	 DWORD PTR _timeTemp$1$[ebp], eax
$LL4@GetXFromTi:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 203  : 	T* GetPrev()	{	return (T*)GetPrevUNK();	}

  00124	8b ce		 mov	 ecx, esi
  00126	e8 00 00 00 00	 call	 ?GetPrevUNK@CDataBlockListUNK@@QAEPAXXZ ; CDataBlockListUNK::GetPrevUNK
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 3616 : 			m_pTReturn = m_blTimefDRI.GetPrev();

  0012b	89 43 5c	 mov	 DWORD PTR [ebx+92], eax

; 3617 : 			if( m_pTReturn) timeTemp = *m_pTReturn;

  0012e	85 c0		 test	 eax, eax
  00130	74 0d		 je	 SHORT $LN108@GetXFromTi
  00132	8b 08		 mov	 ecx, DWORD PTR [eax]
  00134	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00137	89 4d f4	 mov	 DWORD PTR _timeTemp$1$[ebp], ecx
  0013a	89 45 18	 mov	 DWORD PTR _timeTemp$4$[ebp], eax
  0013d	eb 06		 jmp	 SHORT $LN2@GetXFromTi
$LN108@GetXFromTi:
  0013f	8b 45 18	 mov	 eax, DWORD PTR _timeTemp$4$[ebp]
  00142	8b 4d f4	 mov	 ecx, DWORD PTR _timeTemp$1$[ebp]
$LN2@GetXFromTi:

; 3618 : 		} while( timeTemp >= timeFind && m_blTimefDRI.GetIndex() >= 0);

  00145	3b 45 10	 cmp	 eax, DWORD PTR _timeFind$[ebp+4]
  00148	7c 23		 jl	 SHORT $LN21@GetXFromTi
  0014a	7f 04		 jg	 SHORT $LN90@GetXFromTi
  0014c	3b cf		 cmp	 ecx, edi
  0014e	72 1d		 jb	 SHORT $LN21@GetXFromTi
$LN90@GetXFromTi:
  00150	8b ce		 mov	 ecx, esi
  00152	e8 00 00 00 00	 call	 ?GetIndex@CDataBlockListUNK@@QAEHXZ ; CDataBlockListUNK::GetIndex
  00157	85 c0		 test	 eax, eax
  00159	79 c9		 jns	 SHORT $LL4@GetXFromTi

; 3619 : 		
; 3620 : 		if(timeTemp >= timeFind && m_blTimefDRI.GetIndex() < 0)

  0015b	8b ce		 mov	 ecx, esi
  0015d	e8 00 00 00 00	 call	 ?GetIndex@CDataBlockListUNK@@QAEHXZ ; CDataBlockListUNK::GetIndex
  00162	85 c0		 test	 eax, eax
  00164	79 07		 jns	 SHORT $LN21@GetXFromTi

; 3621 : 		{
; 3622 : 			nDRI = 0;

  00166	33 ff		 xor	 edi, edi

; 3623 : 		}

  00168	e9 83 02 00 00	 jmp	 $LN45@GetXFromTi
$LN21@GetXFromTi:

; 3627 : 			nDRI_Prev = m_blTimefDRI.GetIndex() + 1;

  0016d	8b ce		 mov	 ecx, esi
  0016f	e8 00 00 00 00	 call	 ?GetIndex@CDataBlockListUNK@@QAEHXZ ; CDataBlockListUNK::GetIndex
  00174	40		 inc	 eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 215  : 	T*	GetAt( int nIndex)	{	return ( T*)GetAtUNK( nIndex);	}

  00175	8b ce		 mov	 ecx, esi
  00177	50		 push	 eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 3627 : 			nDRI_Prev = m_blTimefDRI.GetIndex() + 1;

  00178	89 45 e4	 mov	 DWORD PTR _nDRI_Prev$1$[ebp], eax

; 3628 : 			nDRI_Next = nDRI_Prev + 1;

  0017b	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 215  : 	T*	GetAt( int nIndex)	{	return ( T*)GetAtUNK( nIndex);	}

  0017e	e8 00 00 00 00	 call	 ?GetAtUNK@CDataBlockListUNK@@QAEPAXH@Z ; CDataBlockListUNK::GetAtUNK
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 3631 : 			m_pTReturn = m_blTimefDRI.GetAt(nDRI_Prev);

  00183	89 43 5c	 mov	 DWORD PTR [ebx+92], eax

; 3632 : 			if( m_pTReturn) timePrev = *m_pTReturn;

  00186	85 c0		 test	 eax, eax
  00188	74 0d		 je	 SHORT $LN103@GetXFromTi
  0018a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0018c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0018f	89 4d f4	 mov	 DWORD PTR _timePrev$1$[ebp], ecx
  00192	89 45 f8	 mov	 DWORD PTR _timePrev$3$[ebp], eax
  00195	eb 0c		 jmp	 SHORT $LN23@GetXFromTi
$LN103@GetXFromTi:
  00197	8b 45 10	 mov	 eax, DWORD PTR _timePrev$[ebp+4]
  0019a	89 45 f8	 mov	 DWORD PTR _timePrev$3$[ebp], eax
  0019d	8b 45 0c	 mov	 eax, DWORD PTR _timePrev$[ebp]
  001a0	89 45 f4	 mov	 DWORD PTR _timePrev$1$[ebp], eax
$LN23@GetXFromTi:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 215  : 	T*	GetAt( int nIndex)	{	return ( T*)GetAtUNK( nIndex);	}

  001a3	57		 push	 edi
  001a4	8b ce		 mov	 ecx, esi
  001a6	e8 00 00 00 00	 call	 ?GetAtUNK@CDataBlockListUNK@@QAEPAXH@Z ; CDataBlockListUNK::GetAtUNK
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 3633 : 			m_pTReturn = m_blTimefDRI.GetAt(nDRI_Next);

  001ab	89 43 5c	 mov	 DWORD PTR [ebx+92], eax

; 3634 : 			if( m_pTReturn) timeNext = *m_pTReturn;

  001ae	85 c0		 test	 eax, eax
  001b0	74 07		 je	 SHORT $LN104@GetXFromTi
  001b2	8b 10		 mov	 edx, DWORD PTR [eax]
  001b4	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001b7	eb 06		 jmp	 SHORT $LN112@GetXFromTi
$LN104@GetXFromTi:
  001b9	8b 45 10	 mov	 eax, DWORD PTR _timeNext$[ebp+4]
  001bc	8b 55 0c	 mov	 edx, DWORD PTR _timeNext$[ebp]
$LN112@GetXFromTi:

; 3637 : 			nTimeSpan_Next = abs(timeFind - timeNext);

  001bf	8b 75 0c	 mov	 esi, DWORD PTR _timeFind$[ebp]
  001c2	8b ce		 mov	 ecx, esi
  001c4	2b ca		 sub	 ecx, edx
  001c6	89 45 18	 mov	 DWORD PTR _timeNext$3$[ebp], eax
  001c9	8b 45 10	 mov	 eax, DWORD PTR _timeFind$[ebp+4]
  001cc	1b 45 18	 sbb	 eax, DWORD PTR _timeNext$3$[ebp]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\stdlib.h

; 370  :         return llabs(_X);

  001cf	99		 cdq
  001d0	33 c2		 xor	 eax, edx
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 3636 : 			nTimeSpan_Prev = abs(timeFind - timePrev);

  001d2	8b 45 10	 mov	 eax, DWORD PTR _timeFind$[ebp+4]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\stdlib.h

; 370  :         return llabs(_X);

  001d5	33 ca		 xor	 ecx, edx
  001d7	2b ca		 sub	 ecx, edx
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 3636 : 			nTimeSpan_Prev = abs(timeFind - timePrev);

  001d9	2b 75 f4	 sub	 esi, DWORD PTR _timePrev$1$[ebp]
  001dc	1b 45 f8	 sbb	 eax, DWORD PTR _timePrev$3$[ebp]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\stdlib.h

; 370  :         return llabs(_X);

  001df	99		 cdq
  001e0	33 c2		 xor	 eax, edx
  001e2	33 f2		 xor	 esi, edx
  001e4	2b f2		 sub	 esi, edx
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 3639 : 			if(nTimeSpan_Prev < nTimeSpan_Next)	nDRI = nDRI_Prev;

  001e6	3b f1		 cmp	 esi, ecx
  001e8	0f 4c 7d e4	 cmovl	 edi, DWORD PTR _nDRI_Prev$1$[ebp]

; 3640 : 			else								nDRI = nDRI_Next;
; 3641 : 		}
; 3642 : 	}

  001ec	e9 ff 01 00 00	 jmp	 $LN45@GetXFromTi
$LN107@GetXFromTi:

; 3611 : 
; 3612 : 	if(timeDRI_Start > timeFind)

  001f1	8b 45 0c	 mov	 eax, DWORD PTR _timeFind$[ebp]
  001f4	8b 55 f4	 mov	 edx, DWORD PTR _timeDRI_Start$1$[ebp]
$LN17@GetXFromTi:

; 3643 : 	else if(timeDRI_Start < timeFind)

  001f7	39 4d f8	 cmp	 DWORD PTR _timeDRI_Start$2$[ebp], ecx
  001fa	0f 8f 88 01 00
	00		 jg	 $LN27@GetXFromTi
  00200	7c 08		 jl	 SHORT $LN98@GetXFromTi
  00202	3b d0		 cmp	 edx, eax
  00204	0f 83 80 01 00
	00		 jae	 $LN113@GetXFromTi
$LN98@GetXFromTi:
  0020a	8b 45 10	 mov	 eax, DWORD PTR _timeTemp$[ebp+4]
  0020d	8b 7d 0c	 mov	 edi, DWORD PTR _timeFind$[ebp]
  00210	89 45 f4	 mov	 DWORD PTR _timeTemp$5$[ebp], eax
  00213	8b 45 0c	 mov	 eax, DWORD PTR _timeTemp$[ebp]
  00216	89 45 f8	 mov	 DWORD PTR _timeTemp$2$[ebp], eax
  00219	0f 1f 80 00 00
	00 00		 npad	 7
$LL7@GetXFromTi:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 227  : 	T* GetNext()	{	return ( T*)GetNextUNK();	}

  00220	8b ce		 mov	 ecx, esi
  00222	e8 00 00 00 00	 call	 ?GetNextUNK@CDataBlockListUNK@@QAEPAXXZ ; CDataBlockListUNK::GetNextUNK
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 3647 : 			m_pTReturn = m_blTimefDRI.GetNext();

  00227	89 43 5c	 mov	 DWORD PTR [ebx+92], eax

; 3648 : 			if( m_pTReturn) timeTemp = *m_pTReturn;

  0022a	85 c0		 test	 eax, eax
  0022c	74 0d		 je	 SHORT $LN110@GetXFromTi
  0022e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00230	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00233	89 4d f8	 mov	 DWORD PTR _timeTemp$2$[ebp], ecx
  00236	89 45 f4	 mov	 DWORD PTR _timeTemp$5$[ebp], eax
  00239	eb 06		 jmp	 SHORT $LN5@GetXFromTi
$LN110@GetXFromTi:
  0023b	8b 45 f4	 mov	 eax, DWORD PTR _timeTemp$5$[ebp]
  0023e	8b 4d f8	 mov	 ecx, DWORD PTR _timeTemp$2$[ebp]
$LN5@GetXFromTi:

; 3649 : 		} while(timeTemp < timeFind && m_blTimefDRI.GetIndex() < nCountOfDRI);

  00241	3b 45 10	 cmp	 eax, DWORD PTR _timeFind$[ebp+4]
  00244	0f 8f bb 00 00
	00		 jg	 $LN31@GetXFromTi
  0024a	7c 08		 jl	 SHORT $LN92@GetXFromTi
  0024c	3b cf		 cmp	 ecx, edi
  0024e	0f 83 b1 00 00
	00		 jae	 $LN31@GetXFromTi
$LN92@GetXFromTi:
  00254	8b ce		 mov	 ecx, esi
  00256	e8 00 00 00 00	 call	 ?GetIndex@CDataBlockListUNK@@QAEHXZ ; CDataBlockListUNK::GetIndex
  0025b	3b 45 fc	 cmp	 eax, DWORD PTR _nCountOfDRI$1$[ebp]
  0025e	7c c0		 jl	 SHORT $LL7@GetXFromTi

; 3650 : 
; 3651 : 		if(timeTemp < timeFind && m_blTimefDRI.GetIndex() >= nCountOfDRI)

  00260	8b ce		 mov	 ecx, esi
  00262	e8 00 00 00 00	 call	 ?GetIndex@CDataBlockListUNK@@QAEHXZ ; CDataBlockListUNK::GetIndex
  00267	3b 45 fc	 cmp	 eax, DWORD PTR _nCountOfDRI$1$[ebp]
  0026a	0f 8c 95 00 00
	00		 jl	 $LN31@GetXFromTi

; 3652 : 		{
; 3653 : 			nDRI = nCountOfDRI - 1;
; 3654 : 
; 3655 : 			//    : xScaleManager - ojtaso (20070611)
; 3656 : 			if( bIncludeRightMargin && !m_pIChartCtrl->IsRunningOneChart() && m_nRightMarginWidth)

  00270	83 7d 18 00	 cmp	 DWORD PTR _bIncludeRightMargin$[ebp], 0
  00274	8b 7d ec	 mov	 edi, DWORD PTR tv518[ebp]
  00277	0f 84 73 01 00
	00		 je	 $LN45@GetXFromTi
  0027d	8b 4b 50	 mov	 ecx, DWORD PTR [ebx+80]
  00280	8b 01		 mov	 eax, DWORD PTR [ecx]
  00282	ff 90 38 01 00
	00		 call	 DWORD PTR [eax+312]
  00288	85 c0		 test	 eax, eax
  0028a	0f 85 60 01 00
	00		 jne	 $LN45@GetXFromTi
  00290	39 43 1c	 cmp	 DWORD PTR [ebx+28], eax
  00293	0f 84 57 01 00
	00		 je	 $LN45@GetXFromTi

; 3657 : 			{
; 3658 : 				int nDRI_End = -1;
; 3659 : 				if( 0 < m_daItemWidth[ p_nColumn]) ceil( ( double)m_nRightMarginWidth / m_daItemWidth[ p_nColumn]);
; 3660 : 				time_t timeEnd;
; 3661 : 				GetTimeFromDRI(nCountOfDRI + nDRI_End - 1, &timeEnd);

  00299	8b 13		 mov	 edx, DWORD PTR [ebx]
  0029b	8d 45 e8	 lea	 eax, DWORD PTR _timeEnd$1[ebp]
  0029e	50		 push	 eax
  0029f	8b 45 fc	 mov	 eax, DWORD PTR _nCountOfDRI$1$[ebp]
  002a2	8b cb		 mov	 ecx, ebx
  002a4	83 c0 fe	 add	 eax, -2			; fffffffeH
  002a7	50		 push	 eax
  002a8	ff 92 ec 00 00
	00		 call	 DWORD PTR [edx+236]

; 3662 : 
; 3663 : 				nTimeSpan = timeEnd - timeLast;
; 3664 : 				nTimeSpan_Find = timeFind - timeLast;

  002ae	8b 45 0c	 mov	 eax, DWORD PTR _timeFind$[ebp]
  002b1	0f 57 c0	 xorps	 xmm0, xmm0

; 3665 : 				if( 0 < nDRI_End) dTimeSpan_Item = (double)nTimeSpan / (double)nDRI_End;
; 3666 : 
; 3667 : 				if( 0 < dTimeSpan_Item) nDRI += ceil((double)nTimeSpan_Find / dTimeSpan_Item);

  002b4	f2 0f 10 4d d8	 movsd	 xmm1, QWORD PTR _dTimeSpan_Item$1$[ebp]
  002b9	2b 45 e4	 sub	 eax, DWORD PTR _timeLast$1$[ebp]
  002bc	66 0f 2f c8	 comisd	 xmm1, xmm0
  002c0	0f 86 2a 01 00
	00		 jbe	 $LN45@GetXFromTi
  002c6	66 0f 6e c0	 movd	 xmm0, eax
  002ca	83 ec 08	 sub	 esp, 8
  002cd	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  002d1	f2 0f 5e c1	 divsd	 xmm0, xmm1
  002d5	f2 0f 11 45 0c	 movsd	 QWORD PTR tv693[ebp], xmm0
  002da	dd 45 0c	 fld	 QWORD PTR tv693[ebp]
  002dd	dd 1c 24	 fstp	 QWORD PTR [esp]
  002e0	e8 00 00 00 00	 call	 _ceil
  002e5	66 0f 6e c7	 movd	 xmm0, edi
  002e9	83 c4 08	 add	 esp, 8
  002ec	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  002f0	dd 5d 0c	 fstp	 QWORD PTR tv687[ebp]
  002f3	f2 0f 10 4d 0c	 movsd	 xmm1, QWORD PTR tv687[ebp]
  002f8	f2 0f 58 c8	 addsd	 xmm1, xmm0
  002fc	f2 0f 2c f9	 cvttsd2si edi, xmm1

; 3668 : 			}
; 3669 : 		}

  00300	e9 eb 00 00 00	 jmp	 $LN45@GetXFromTi
$LN31@GetXFromTi:

; 3673 : 			nDRI_Next = m_blTimefDRI.GetIndex() - 1;

  00305	8b ce		 mov	 ecx, esi
  00307	e8 00 00 00 00	 call	 ?GetIndex@CDataBlockListUNK@@QAEHXZ ; CDataBlockListUNK::GetIndex
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 215  : 	T*	GetAt( int nIndex)	{	return ( T*)GetAtUNK( nIndex);	}

  0030c	8b ce		 mov	 ecx, esi
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 3673 : 			nDRI_Next = m_blTimefDRI.GetIndex() - 1;

  0030e	8d 78 ff	 lea	 edi, DWORD PTR [eax-1]

; 3674 : 			nDRI_Prev = nDRI_Next - 1;

  00311	8d 47 ff	 lea	 eax, DWORD PTR [edi-1]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 215  : 	T*	GetAt( int nIndex)	{	return ( T*)GetAtUNK( nIndex);	}

  00314	50		 push	 eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 3674 : 			nDRI_Prev = nDRI_Next - 1;

  00315	89 45 f4	 mov	 DWORD PTR _nDRI_Prev$2$[ebp], eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 215  : 	T*	GetAt( int nIndex)	{	return ( T*)GetAtUNK( nIndex);	}

  00318	e8 00 00 00 00	 call	 ?GetAtUNK@CDataBlockListUNK@@QAEPAXH@Z ; CDataBlockListUNK::GetAtUNK
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 3677 : 			m_pTReturn = m_blTimefDRI.GetAt(nDRI_Prev);

  0031d	89 43 5c	 mov	 DWORD PTR [ebx+92], eax

; 3678 : 			if( m_pTReturn) timePrev = *m_pTReturn;

  00320	85 c0		 test	 eax, eax
  00322	74 0d		 je	 SHORT $LN105@GetXFromTi
  00324	8b 08		 mov	 ecx, DWORD PTR [eax]
  00326	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00329	89 4d e4	 mov	 DWORD PTR _timePrev$2$[ebp], ecx
  0032c	89 45 ec	 mov	 DWORD PTR _timePrev$4$[ebp], eax
  0032f	eb 0c		 jmp	 SHORT $LN37@GetXFromTi
$LN105@GetXFromTi:
  00331	8b 45 10	 mov	 eax, DWORD PTR _timePrev$[ebp+4]
  00334	89 45 ec	 mov	 DWORD PTR _timePrev$4$[ebp], eax
  00337	8b 45 0c	 mov	 eax, DWORD PTR _timePrev$[ebp]
  0033a	89 45 e4	 mov	 DWORD PTR _timePrev$2$[ebp], eax
$LN37@GetXFromTi:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 215  : 	T*	GetAt( int nIndex)	{	return ( T*)GetAtUNK( nIndex);	}

  0033d	57		 push	 edi
  0033e	8b ce		 mov	 ecx, esi
  00340	e8 00 00 00 00	 call	 ?GetAtUNK@CDataBlockListUNK@@QAEPAXH@Z ; CDataBlockListUNK::GetAtUNK
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 3679 : 			m_pTReturn = m_blTimefDRI.GetAt(nDRI_Next);

  00345	89 43 5c	 mov	 DWORD PTR [ebx+92], eax

; 3680 : 			if( m_pTReturn) timeNext = *m_pTReturn;

  00348	85 c0		 test	 eax, eax
  0034a	74 07		 je	 SHORT $LN106@GetXFromTi
  0034c	8b 10		 mov	 edx, DWORD PTR [eax]
  0034e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00351	eb 06		 jmp	 SHORT $LN114@GetXFromTi
$LN106@GetXFromTi:
  00353	8b 45 10	 mov	 eax, DWORD PTR _timeNext$[ebp+4]
  00356	8b 55 0c	 mov	 edx, DWORD PTR _timeNext$[ebp]
$LN114@GetXFromTi:

; 3683 : 			nTimeSpan_Next = abs(timeFind - timeNext);

  00359	8b 75 0c	 mov	 esi, DWORD PTR _timeFind$[ebp]
  0035c	8b ce		 mov	 ecx, esi
  0035e	2b ca		 sub	 ecx, edx
  00360	89 45 18	 mov	 DWORD PTR _timeNext$4$[ebp], eax
  00363	8b 45 10	 mov	 eax, DWORD PTR _timeFind$[ebp+4]
  00366	1b 45 18	 sbb	 eax, DWORD PTR _timeNext$4$[ebp]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\stdlib.h

; 370  :         return llabs(_X);

  00369	99		 cdq
  0036a	33 c2		 xor	 eax, edx
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 3682 : 			nTimeSpan_Prev = abs(timeFind - timePrev);

  0036c	8b 45 10	 mov	 eax, DWORD PTR _timeFind$[ebp+4]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\stdlib.h

; 370  :         return llabs(_X);

  0036f	33 ca		 xor	 ecx, edx
  00371	2b ca		 sub	 ecx, edx
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 3682 : 			nTimeSpan_Prev = abs(timeFind - timePrev);

  00373	2b 75 e4	 sub	 esi, DWORD PTR _timePrev$2$[ebp]
  00376	1b 45 ec	 sbb	 eax, DWORD PTR _timePrev$4$[ebp]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\stdlib.h

; 370  :         return llabs(_X);

  00379	99		 cdq
  0037a	33 c2		 xor	 eax, edx
  0037c	33 f2		 xor	 esi, edx
  0037e	2b f2		 sub	 esi, edx
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 3685 : 			if(nTimeSpan_Prev < nTimeSpan_Next)	nDRI = nDRI_Prev;

  00380	3b f1		 cmp	 esi, ecx
  00382	0f 4c 7d f4	 cmovl	 edi, DWORD PTR _nDRI_Prev$2$[ebp]

; 3686 : 			else								nDRI = nDRI_Next;
; 3687 : 		}
; 3688 : 	}

  00386	eb 68		 jmp	 SHORT $LN45@GetXFromTi
$LN27@GetXFromTi:

; 3689 : 	else if(timeDRI_Start == timeFind)

  00388	3b d0		 cmp	 edx, eax
$LN113@GetXFromTi:
  0038a	75 64		 jne	 SHORT $LN45@GetXFromTi
  0038c	39 4d f8	 cmp	 DWORD PTR _timeDRI_Start$2$[ebp], ecx
  0038f	75 5f		 jne	 SHORT $LN45@GetXFromTi
  00391	8b 45 10	 mov	 eax, DWORD PTR _timeTemp$[ebp+4]
  00394	8b 7d 0c	 mov	 edi, DWORD PTR _timeFind$[ebp]
  00397	89 45 18	 mov	 DWORD PTR _timeTemp$6$[ebp], eax
  0039a	8b 45 0c	 mov	 eax, DWORD PTR _timeTemp$[ebp]
  0039d	89 45 e4	 mov	 DWORD PTR _timeTemp$3$[ebp], eax
$LL10@GetXFromTi:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 203  : 	T* GetPrev()	{	return (T*)GetPrevUNK();	}

  003a0	8b ce		 mov	 ecx, esi
  003a2	e8 00 00 00 00	 call	 ?GetPrevUNK@CDataBlockListUNK@@QAEPAXXZ ; CDataBlockListUNK::GetPrevUNK
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 3693 : 			m_pTReturn = m_blTimefDRI.GetPrev();

  003a7	89 43 5c	 mov	 DWORD PTR [ebx+92], eax

; 3694 : 			if( m_pTReturn) timeTemp = *m_pTReturn;

  003aa	85 c0		 test	 eax, eax
  003ac	74 0d		 je	 SHORT $LN109@GetXFromTi
  003ae	8b 08		 mov	 ecx, DWORD PTR [eax]
  003b0	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  003b3	89 4d e4	 mov	 DWORD PTR _timeTemp$3$[ebp], ecx
  003b6	89 45 18	 mov	 DWORD PTR _timeTemp$6$[ebp], eax
  003b9	eb 06		 jmp	 SHORT $LN8@GetXFromTi
$LN109@GetXFromTi:
  003bb	8b 45 18	 mov	 eax, DWORD PTR _timeTemp$6$[ebp]
  003be	8b 4d e4	 mov	 ecx, DWORD PTR _timeTemp$3$[ebp]
$LN8@GetXFromTi:

; 3695 : 		} while( timeTemp >= timeFind && m_blTimefDRI.GetIndex() >= 0);

  003c1	3b 45 10	 cmp	 eax, DWORD PTR _timeFind$[ebp+4]
  003c4	7c 20		 jl	 SHORT $LN44@GetXFromTi
  003c6	7f 04		 jg	 SHORT $LN93@GetXFromTi
  003c8	3b cf		 cmp	 ecx, edi
  003ca	72 1a		 jb	 SHORT $LN44@GetXFromTi
$LN93@GetXFromTi:
  003cc	8b ce		 mov	 ecx, esi
  003ce	e8 00 00 00 00	 call	 ?GetIndex@CDataBlockListUNK@@QAEHXZ ; CDataBlockListUNK::GetIndex
  003d3	85 c0		 test	 eax, eax
  003d5	79 c9		 jns	 SHORT $LL10@GetXFromTi

; 3696 : 		
; 3697 : 		if(timeTemp >= timeFind && m_blTimefDRI.GetIndex() < 0)

  003d7	8b ce		 mov	 ecx, esi
  003d9	e8 00 00 00 00	 call	 ?GetIndex@CDataBlockListUNK@@QAEHXZ ; CDataBlockListUNK::GetIndex
  003de	85 c0		 test	 eax, eax
  003e0	79 04		 jns	 SHORT $LN44@GetXFromTi

; 3698 : 		{
; 3699 : 			nDRI = 0;

  003e2	33 ff		 xor	 edi, edi

; 3700 : 		}

  003e4	eb 0a		 jmp	 SHORT $LN45@GetXFromTi
$LN44@GetXFromTi:

; 3701 : 		else
; 3702 : 		{
; 3703 : 			// timeFind   + 1         .
; 3704 : 			nDRI = m_blTimefDRI.GetIndex() + 1 + 1;

  003e6	8b ce		 mov	 ecx, esi
  003e8	e8 00 00 00 00	 call	 ?GetIndex@CDataBlockListUNK@@QAEHXZ ; CDataBlockListUNK::GetIndex
  003ed	8d 78 02	 lea	 edi, DWORD PTR [eax+2]
$LN45@GetXFromTi:

; 3705 : 		}
; 3706 : 	}
; 3707 : 
; 3708 : 	PAREA parea = NULL;
; 3709 : 	GetAreaFromDRI( p_nColumn, nDRI, &parea);

  003f0	8b 03		 mov	 eax, DWORD PTR [ebx]
  003f2	8d 4d e0	 lea	 ecx, DWORD PTR _parea$[ebp]
  003f5	51		 push	 ecx
  003f6	57		 push	 edi
  003f7	ff 75 08	 push	 DWORD PTR _p_nColumn$[ebp]
  003fa	8b cb		 mov	 ecx, ebx
  003fc	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _parea$[ebp], 0
  00403	ff 90 44 01 00
	00		 call	 DWORD PTR [eax+324]

; 3710 : 	if(pparea != NULL) *pparea = parea;

  00409	8b 4d 14	 mov	 ecx, DWORD PTR _pparea$[ebp]
  0040c	8b 45 e0	 mov	 eax, DWORD PTR _parea$[ebp]
  0040f	5f		 pop	 edi
  00410	5e		 pop	 esi
  00411	5b		 pop	 ebx
  00412	85 c9		 test	 ecx, ecx
  00414	74 02		 je	 SHORT $LN46@GetXFromTi
  00416	89 01		 mov	 DWORD PTR [ecx], eax
$LN46@GetXFromTi:

; 3711 : 
; 3712 : 	if( !parea) return -1;

  00418	85 c0		 test	 eax, eax
  0041a	75 09		 jne	 SHORT $LN47@GetXFromTi
  0041c	83 c8 ff	 or	 eax, -1

; 3714 : }

  0041f	8b e5		 mov	 esp, ebp
  00421	5d		 pop	 ebp
  00422	c2 14 00	 ret	 20			; 00000014H
$LN47@GetXFromTi:

; 3713 : 	return parea->center;

  00425	0f bf 40 02	 movsx	 eax, WORD PTR [eax+2]

; 3714 : }

  00429	8b e5		 mov	 esp, ebp
  0042b	5d		 pop	 ebp
  0042c	c2 14 00	 ret	 20			; 00000014H
?GetXFromTime@CXScaleManagerImp@@MAEHH_JPAPAUtagAREA@CXScaleManager@@H@Z ENDP ; CXScaleManagerImp::GetXFromTime
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?GetScreenWidth@CXScaleManagerImp@@MAEHH@Z
_TEXT	SEGMENT
_p_nColumn$ = 8						; size = 4
?GetScreenWidth@CXScaleManagerImp@@MAEHH@Z PROC		; CXScaleManagerImp::GetScreenWidth, COMDAT
; _this$ = ecx

; 3575 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3576 : 	if( p_nColumn < 0 && m_nCountOfBlockColumn <= p_nColumn) return 0;

  00003	8b 45 08	 mov	 eax, DWORD PTR _p_nColumn$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	79 0e		 jns	 SHORT $LN2@GetScreenW
  0000a	39 81 2c 01 00
	00		 cmp	 DWORD PTR [ecx+300], eax
  00010	7f 06		 jg	 SHORT $LN2@GetScreenW
  00012	33 c0		 xor	 eax, eax

; 3578 : }

  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
$LN2@GetScreenW:

; 3577 : 	return m_nScreenWidth_Cur[ p_nColumn];

  00018	8b 84 81 38 03
	00 00		 mov	 eax, DWORD PTR [ecx+eax*4+824]

; 3578 : }

  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?GetScreenWidth@CXScaleManagerImp@@MAEHH@Z ENDP		; CXScaleManagerImp::GetScreenWidth
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?GetScaleDRIandTime@CXScaleManagerImp@@MAEHHAAPAV?$CDataBlockList@H$0CAA@@@AAPAV?$CDataBlockList@Utm@@$0CAA@@@HW4HORZSCALEDRAWERTYPE@CScaleBaseData@@HPBDAAHABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
_TEXT	SEGMENT
tv329 = -8						; size = 4
_pXScaleGridTime$ = -4					; size = 4
_p_nColumn$ = 8						; size = 4
tv327 = 12						; size = 4
_p_pblScaleDRI$ = 12					; size = 4
_p_pblScaleTime$ = 16					; size = 4
_p_nScaleRegionWidth$ = 20				; size = 4
_p_eScaleDrawType$ = 24					; size = 4
_p_nTimeInterval$ = 28					; size = 4
_p_szRQ$ = 32						; size = 4
_p_nSkipFactor$ = 36					; size = 4
_p_strPacketType$ = 40					; size = 4
?GetScaleDRIandTime@CXScaleManagerImp@@MAEHHAAPAV?$CDataBlockList@H$0CAA@@@AAPAV?$CDataBlockList@Utm@@$0CAA@@@HW4HORZSCALEDRAWERTYPE@CScaleBaseData@@HPBDAAHABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z PROC ; CXScaleManagerImp::GetScaleDRIandTime, COMDAT
; _this$ = ecx

; 3527 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 3528 : 	// 1. Get X Scale Grid Object.
; 3529 : 	CXScaleGridTime *pXScaleGridTime = NULL;
; 3530 : 	int nTimeDiff = GetTimeDiffWithCurrentRQ( p_szRQ);

  00008	8b 75 20	 mov	 esi, DWORD PTR _p_szRQ$[ebp]
  0000b	8b d9		 mov	 ebx, ecx
  0000d	57		 push	 edi
  0000e	51		 push	 ecx
  0000f	8b cc		 mov	 ecx, esp
  00011	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pXScaleGridTime$[ebp], 0
  00018	56		 push	 esi
  00019	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  0001f	8b cb		 mov	 ecx, ebx
  00021	e8 00 00 00 00	 call	 ?GetTimeDiffWithCurrentRQ@CXScaleManagerImp@@IAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ; CXScaleManagerImp::GetTimeDiffWithCurrentRQ
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 2052 : 		{ return BASE_CLASS::Lookup(key, (typename BASE_CLASS::BASE_VALUE&)rValue); }

  00026	8d 4d fc	 lea	 ecx, DWORD PTR _pXScaleGridTime$[ebp]
  00029	51		 push	 ecx
  0002a	50		 push	 eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 3531 : 	if( !m_mapXGridTime.Lookup( nTimeDiff, pXScaleGridTime)) return -1;

  0002b	8d 8b 18 06 00
	00		 lea	 ecx, DWORD PTR [ebx+1560]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 2052 : 		{ return BASE_CLASS::Lookup(key, (typename BASE_CLASS::BASE_VALUE&)rValue); }

  00031	e8 00 00 00 00	 call	 ?Lookup@CMapWordToPtr@@QBEHGAAPAX@Z ; CMapWordToPtr::Lookup
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 3531 : 	if( !m_mapXGridTime.Lookup( nTimeDiff, pXScaleGridTime)) return -1;

  00036	85 c0		 test	 eax, eax
  00038	0f 84 10 01 00
	00		 je	 $LN16@GetScaleDR

; 3532 : 
; 3533 : 	p_pblScaleDRI = &m_blScaleDRI[ p_nColumn];			// DRI value for scale of YYYY/MM/DD/HH/mm/SS

  0003e	6b 4d 08 34	 imul	 ecx, DWORD PTR _p_nColumn$[ebp], 52
  00042	8b 45 0c	 mov	 eax, DWORD PTR _p_pblScaleDRI$[ebp]
  00045	03 cb		 add	 ecx, ebx
  00047	8d b9 64 08 00
	00		 lea	 edi, DWORD PTR [ecx+2148]

; 3534 : 	p_pblScaleTime = &m_blScaleTime[ p_nColumn];		// Time value for scale of YYYY/MM/DD/HH/mm/SS

  0004d	81 c1 5c 06 00
	00		 add	 ecx, 1628		; 0000065cH
  00053	89 38		 mov	 DWORD PTR [eax], edi
  00055	8b 45 10	 mov	 eax, DWORD PTR _p_pblScaleTime$[ebp]

; 3535 : 
; 3536 : 	int nRQ = GetRQIndexFromString( p_szRQ);

  00058	51		 push	 ecx
  00059	89 4d 0c	 mov	 DWORD PTR tv327[ebp], ecx
  0005c	89 7d f8	 mov	 DWORD PTR tv329[ebp], edi
  0005f	89 08		 mov	 DWORD PTR [eax], ecx
  00061	8b cc		 mov	 ecx, esp
  00063	56		 push	 esi
  00064	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  0006a	8b 03		 mov	 eax, DWORD PTR [ebx]
  0006c	8b cb		 mov	 ecx, ebx
  0006e	ff 50 04	 call	 DWORD PTR [eax+4]
  00071	8b f0		 mov	 esi, eax

; 3537 : 	if( nRQ < 0) return -1;

  00073	85 f6		 test	 esi, esi
  00075	0f 88 d3 00 00
	00		 js	 $LN16@GetScaleDR

; 3538 : 
; 3539 : //#ifndef _DEBUG
; 3540 : //	if( 0 < m_blScaleDRI[ p_nColumn].GetItemCount()
; 3541 : //		&& p_eScaleDrawType == m_eScaleDrawType
; 3542 : //		&& p_szRQ == m_strScaleRQ)
; 3543 : //	{
; 3544 : //		p_nSkipFactor = m_nSkipFactor;
; 3545 : //		return m_naScaleType[ p_nColumn];
; 3546 : //	}
; 3547 : //#endif
; 3548 : 
; 3549 : 	m_blScaleDRI[ p_nColumn].Clear();		// DRI value for scale of YYYY/MM/DD/HH/mm/SS

  0007b	8b cf		 mov	 ecx, edi
  0007d	e8 00 00 00 00	 call	 ?Clear@CDataBlockListUNK@@QAEXXZ ; CDataBlockListUNK::Clear

; 3550 : 	m_blScaleTime[ p_nColumn].Clear();		// Time value for scale of YYYY/MM/DD/HH/mm/SS

  00082	8b 4d 0c	 mov	 ecx, DWORD PTR tv327[ebp]
  00085	e8 00 00 00 00	 call	 ?Clear@CDataBlockListUNK@@QAEXXZ ; CDataBlockListUNK::Clear

; 3551 : 
; 3552 : 	// (2009/5/28 - Seung-Won, Bae) Do not draw scale on no data.
; 3553 : 	if( IsEmptyData()) return -1;

  0008a	8b 13		 mov	 edx, DWORD PTR [ebx]
  0008c	8b cb		 mov	 ecx, ebx
  0008e	ff 92 68 01 00
	00		 call	 DWORD PTR [edx+360]
  00094	85 c0		 test	 eax, eax
  00096	0f 85 b2 00 00
	00		 jne	 $LN16@GetScaleDR

; 3556 : 	m_pIReturn = m_pblaDRIfDTI[ nRQ]->GetAt( m_pifaRQ[ nRQ]->nDTI_Start_Data);

  0009c	8b 83 8c 00 00
	00		 mov	 eax, DWORD PTR [ebx+140]
  000a2	8b 04 b0	 mov	 eax, DWORD PTR [eax+esi*4]
  000a5	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  000a8	8b 83 a0 00 00
	00		 mov	 eax, DWORD PTR [ebx+160]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 215  : 	T*	GetAt( int nIndex)	{	return ( T*)GetAtUNK( nIndex);	}

  000ae	51		 push	 ecx
  000af	8b 0c b0	 mov	 ecx, DWORD PTR [eax+esi*4]
  000b2	e8 00 00 00 00	 call	 ?GetAtUNK@CDataBlockListUNK@@QAEPAXH@Z ; CDataBlockListUNK::GetAtUNK
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 3556 : 	m_pIReturn = m_pblaDRIfDTI[ nRQ]->GetAt( m_pifaRQ[ nRQ]->nDTI_Start_Data);

  000b7	89 43 60	 mov	 DWORD PTR [ebx+96], eax

; 3557 : 	if( m_pIReturn) nStartDRIofRQ = *m_pIReturn;
; 3558 : 	int nEndDRIofRQ = -1;
; 3559 : 	m_pIReturn = m_pblaDRIfDTI[ nRQ]->GetAt( m_pifaRQ[ nRQ]->nDTI_End_Data);

  000ba	8b 83 8c 00 00
	00		 mov	 eax, DWORD PTR [ebx+140]
  000c0	8b 04 b0	 mov	 eax, DWORD PTR [eax+esi*4]
  000c3	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  000c6	8b 83 a0 00 00
	00		 mov	 eax, DWORD PTR [ebx+160]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 215  : 	T*	GetAt( int nIndex)	{	return ( T*)GetAtUNK( nIndex);	}

  000cc	51		 push	 ecx
  000cd	8b 0c b0	 mov	 ecx, DWORD PTR [eax+esi*4]
  000d0	e8 00 00 00 00	 call	 ?GetAtUNK@CDataBlockListUNK@@QAEPAXH@Z ; CDataBlockListUNK::GetAtUNK
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 3562 : 	p_nSkipFactor = 1;	// p_nSkipFactor    

  000d5	8b 7d 24	 mov	 edi, DWORD PTR _p_nSkipFactor$[ebp]

; 3563 : 	m_naScaleType[ p_nColumn] = pXScaleGridTime->RecalculateScaleType( p_strPacketType, p_eScaleDrawType, p_nScaleRegionWidth, p_nSkipFactor, p_nTimeInterval, m_eChartMode);

  000d8	8b 75 18	 mov	 esi, DWORD PTR _p_eScaleDrawType$[ebp]
  000db	8b 4d fc	 mov	 ecx, DWORD PTR _pXScaleGridTime$[ebp]
  000de	89 43 60	 mov	 DWORD PTR [ebx+96], eax
  000e1	c7 07 01 00 00
	00		 mov	 DWORD PTR [edi], 1
  000e7	ff b3 e8 05 00
	00		 push	 DWORD PTR [ebx+1512]
  000ed	ff 75 1c	 push	 DWORD PTR _p_nTimeInterval$[ebp]
  000f0	57		 push	 edi
  000f1	ff 75 14	 push	 DWORD PTR _p_nScaleRegionWidth$[ebp]
  000f4	56		 push	 esi
  000f5	ff 75 28	 push	 DWORD PTR _p_strPacketType$[ebp]
  000f8	e8 00 00 00 00	 call	 ?RecalculateScaleType@CXScaleGridTime@@QAEHABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@W4HORZSCALEDRAWERTYPE@CScaleBaseData@@HAAHHW4CHART_MODE@CChartInfo@@@Z ; CXScaleGridTime::RecalculateScaleType
  000fd	8b 4d 08	 mov	 ecx, DWORD PTR _p_nColumn$[ebp]
  00100	89 84 8b 34 06
	00 00		 mov	 DWORD PTR [ebx+ecx*4+1588], eax

; 3564 : 	pXScaleGridTime->MakeScaleData( m_naScaleType[ p_nColumn], m_blScaleTime[ p_nColumn], m_blScaleDRI[ p_nColumn], p_nSkipFactor, m_eChartMode);

  00107	ff b3 e8 05 00
	00		 push	 DWORD PTR [ebx+1512]
  0010d	8b 4d fc	 mov	 ecx, DWORD PTR _pXScaleGridTime$[ebp]
  00110	ff 37		 push	 DWORD PTR [edi]
  00112	ff 75 f8	 push	 DWORD PTR tv329[ebp]
  00115	ff 75 0c	 push	 DWORD PTR tv327[ebp]
  00118	50		 push	 eax
  00119	e8 00 00 00 00	 call	 ?MakeScaleData@CXScaleGridTime@@QAEXHAAV?$CDataBlockList@Utm@@$0CAA@@@AAV?$CDataBlockList@H$0CAA@@@HW4CHART_MODE@CChartInfo@@@Z ; CXScaleGridTime::MakeScaleData

; 3565 : 
; 3566 : 	m_nSkipFactor = p_nSkipFactor;

  0011e	8b 0f		 mov	 ecx, DWORD PTR [edi]

; 3567 : 	m_eScaleDrawType = p_eScaleDrawType;
; 3568 : 	m_strScaleRQ = p_szRQ;

  00120	ff 75 20	 push	 DWORD PTR _p_szRQ$[ebp]
  00123	89 8b 6c 0a 00
	00		 mov	 DWORD PTR [ebx+2668], ecx
  00129	8d 8b 74 0a 00
	00		 lea	 ecx, DWORD PTR [ebx+2676]
  0012f	89 b3 70 0a 00
	00		 mov	 DWORD PTR [ebx+2672], esi
  00135	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z

; 3569 : 
; 3570 : 	return m_naScaleType[ p_nColumn];

  0013b	8b 45 08	 mov	 eax, DWORD PTR _p_nColumn$[ebp]
  0013e	8b 84 83 34 06
	00 00		 mov	 eax, DWORD PTR [ebx+eax*4+1588]

; 3571 : }

  00145	5f		 pop	 edi
  00146	5e		 pop	 esi
  00147	5b		 pop	 ebx
  00148	8b e5		 mov	 esp, ebp
  0014a	5d		 pop	 ebp
  0014b	c2 24 00	 ret	 36			; 00000024H
$LN16@GetScaleDR:
  0014e	5f		 pop	 edi
  0014f	5e		 pop	 esi
  00150	83 c8 ff	 or	 eax, -1
  00153	5b		 pop	 ebx
  00154	8b e5		 mov	 esp, ebp
  00156	5d		 pop	 ebp
  00157	c2 24 00	 ret	 36			; 00000024H
?GetScaleDRIandTime@CXScaleManagerImp@@MAEHHAAPAV?$CDataBlockList@H$0CAA@@@AAPAV?$CDataBlockList@Utm@@$0CAA@@@HW4HORZSCALEDRAWERTYPE@CScaleBaseData@@HPBDAAHABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ENDP ; CXScaleManagerImp::GetScaleDRIandTime
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?GetGraphXArea_Start@CXScaleManagerImp@@MAEHHH@Z
_TEXT	SEGMENT
_p_nColumn$ = 8						; size = 4
_bIncludeMargin$ = 12					; size = 4
?GetGraphXArea_Start@CXScaleManagerImp@@MAEHHH@Z PROC	; CXScaleManagerImp::GetGraphXArea_Start, COMDAT
; _this$ = ecx

; 3518 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3519 : 	if(bIncludeMargin == FALSE) return m_naScreenStart_Cur[ p_nColumn];

  00003	83 7d 0c 00	 cmp	 DWORD PTR _bIncludeMargin$[ebp], 0
  00007	8b 45 08	 mov	 eax, DWORD PTR _p_nColumn$[ebp]
  0000a	75 0b		 jne	 SHORT $LN2@GetGraphXA
  0000c	8b 84 81 98 02
	00 00		 mov	 eax, DWORD PTR [ecx+eax*4+664]

; 3521 : }

  00013	5d		 pop	 ebp
  00014	c2 08 00	 ret	 8
$LN2@GetGraphXA:

; 3520 : 	else						return m_nScreenStartiM_Cur[ p_nColumn];

  00017	8b 84 81 e8 02
	00 00		 mov	 eax, DWORD PTR [ecx+eax*4+744]

; 3521 : }

  0001e	5d		 pop	 ebp
  0001f	c2 08 00	 ret	 8
?GetGraphXArea_Start@CXScaleManagerImp@@MAEHHH@Z ENDP	; CXScaleManagerImp::GetGraphXArea_Start
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?GetGraphXArea_Right@CXScaleManagerImp@@MAEHHH@Z
_TEXT	SEGMENT
_p_nColumn$ = 8						; size = 4
_bIncludeMargin$ = 12					; size = 4
?GetGraphXArea_Right@CXScaleManagerImp@@MAEHHH@Z PROC	; CXScaleManagerImp::GetGraphXArea_Right, COMDAT
; _this$ = ecx

; 3511 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3512 : 	if(bIncludeMargin == FALSE)	return m_nScreenRight_Cur[ p_nColumn];

  00003	83 7d 0c 00	 cmp	 DWORD PTR _bIncludeMargin$[ebp], 0
  00007	8b 45 08	 mov	 eax, DWORD PTR _p_nColumn$[ebp]
  0000a	75 0b		 jne	 SHORT $LN2@GetGraphXA
  0000c	8b 84 81 20 02
	00 00		 mov	 eax, DWORD PTR [ecx+eax*4+544]

; 3514 : }

  00013	5d		 pop	 ebp
  00014	c2 08 00	 ret	 8
$LN2@GetGraphXA:

; 3513 : 	else						return m_nScreenRightiM_Cur[ p_nColumn];

  00017	8b 84 81 70 02
	00 00		 mov	 eax, DWORD PTR [ecx+eax*4+624]

; 3514 : }

  0001e	5d		 pop	 ebp
  0001f	c2 08 00	 ret	 8
?GetGraphXArea_Right@CXScaleManagerImp@@MAEHHH@Z ENDP	; CXScaleManagerImp::GetGraphXArea_Right
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?GetGraphXArea_Left@CXScaleManagerImp@@MAEHHH@Z
_TEXT	SEGMENT
_p_nColumn$ = 8						; size = 4
_bIncludeMargin$ = 12					; size = 4
?GetGraphXArea_Left@CXScaleManagerImp@@MAEHHH@Z PROC	; CXScaleManagerImp::GetGraphXArea_Left, COMDAT
; _this$ = ecx

; 3504 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3505 : 	if(bIncludeMargin == FALSE)	return m_nScreenLeft_Cur[ p_nColumn];

  00003	83 7d 0c 00	 cmp	 DWORD PTR _bIncludeMargin$[ebp], 0
  00007	8b 45 08	 mov	 eax, DWORD PTR _p_nColumn$[ebp]
  0000a	75 0b		 jne	 SHORT $LN2@GetGraphXA
  0000c	8b 84 81 f8 01
	00 00		 mov	 eax, DWORD PTR [ecx+eax*4+504]

; 3507 : }

  00013	5d		 pop	 ebp
  00014	c2 08 00	 ret	 8
$LN2@GetGraphXA:

; 3506 : 	else						return m_nScreenLeftiM_Cur[ p_nColumn];

  00017	8b 84 81 48 02
	00 00		 mov	 eax, DWORD PTR [ecx+eax*4+584]

; 3507 : }

  0001e	5d		 pop	 ebp
  0001f	c2 08 00	 ret	 8
?GetGraphXArea_Left@CXScaleManagerImp@@MAEHHH@Z ENDP	; CXScaleManagerImp::GetGraphXArea_Left
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?GetGraphXArea_End@CXScaleManagerImp@@MAEHHH@Z
_TEXT	SEGMENT
_p_nColumn$ = 8						; size = 4
_bIncludeMargin$ = 12					; size = 4
?GetGraphXArea_End@CXScaleManagerImp@@MAEHHH@Z PROC	; CXScaleManagerImp::GetGraphXArea_End, COMDAT
; _this$ = ecx

; 3498 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3499 : 	if(bIncludeMargin == FALSE)	return m_naScreenEnd_Cur[ p_nColumn];

  00003	83 7d 0c 00	 cmp	 DWORD PTR _bIncludeMargin$[ebp], 0
  00007	8b 45 08	 mov	 eax, DWORD PTR _p_nColumn$[ebp]
  0000a	75 0b		 jne	 SHORT $LN2@GetGraphXA
  0000c	8b 84 81 c0 02
	00 00		 mov	 eax, DWORD PTR [ecx+eax*4+704]

; 3501 : }

  00013	5d		 pop	 ebp
  00014	c2 08 00	 ret	 8
$LN2@GetGraphXA:

; 3500 : 	else						return m_nScreenEndiM_Cur[ p_nColumn];

  00017	8b 84 81 10 03
	00 00		 mov	 eax, DWORD PTR [ecx+eax*4+784]

; 3501 : }

  0001e	5d		 pop	 ebp
  0001f	c2 08 00	 ret	 8
?GetGraphXArea_End@CXScaleManagerImp@@MAEHHH@Z ENDP	; CXScaleManagerImp::GetGraphXArea_End
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?GetDRInFromPt@CXScaleManagerImp@@MAEHHPAHPAPAUtagAREA@CXScaleManager@@HH@Z
_TEXT	SEGMENT
tv753 = -24						; size = 8
tv747 = -24						; size = 8
tv774 = -16						; size = 8
tv768 = -16						; size = 8
tv765 = -16						; size = 8
tv759 = -16						; size = 8
_nDRI$2$ = -12						; size = 4
_nColumn$1$ = -8					; size = 4
_nDRI_End$1$ = -4					; size = 4
_parea$ = 8						; size = 4
_nCursor_x$ = 8						; size = 4
_pnBlockColumn$ = 12					; size = 4
_pparea$ = 16						; size = 4
_bIncludeRightMargin$ = 20				; size = 4
tv683 = 24						; size = 4
tv681 = 24						; size = 4
_nDRI$ = 24						; size = 4
_p_bWithBoundCheck$ = 24				; size = 4
?GetDRInFromPt@CXScaleManagerImp@@MAEHHPAHPAPAUtagAREA@CXScaleManager@@HH@Z PROC ; CXScaleManagerImp::GetDRInFromPt, COMDAT
; _this$ = ecx

; 3407 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	53		 push	 ebx

; 3408 : 	int nColumn = 0;
; 3409 : 	for( int i = 0; i < m_nCountOfBlockColumn; i++)

  00007	8b 5d 08	 mov	 ebx, DWORD PTR _nCursor_x$[ebp]
  0000a	33 d2		 xor	 edx, edx
  0000c	56		 push	 esi
  0000d	57		 push	 edi
  0000e	8b f9		 mov	 edi, ecx
  00010	33 f6		 xor	 esi, esi
  00012	89 75 f8	 mov	 DWORD PTR _nColumn$1$[ebp], esi
  00015	8b 87 2c 01 00
	00		 mov	 eax, DWORD PTR [edi+300]
  0001b	85 c0		 test	 eax, eax
  0001d	7e 29		 jle	 SHORT $LN58@GetDRInFro
  0001f	8d 8f 80 01 00
	00		 lea	 ecx, DWORD PTR [edi+384]
$LL4@GetDRInFro:

; 3410 : 		if( m_naScreenRegionLeft[ i] < nCursor_x && nCursor_x < m_naScreenRegionLeft[ i] + m_naScreenRegionWidth[ i])

  00025	39 59 d8	 cmp	 DWORD PTR [ecx-40], ebx
  00028	7d 0f		 jge	 SHORT $LN2@GetDRInFro
  0002a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0002c	03 41 d8	 add	 eax, DWORD PTR [ecx-40]
  0002f	3b d8		 cmp	 ebx, eax
  00031	7c 10		 jl	 SHORT $LN42@GetDRInFro
  00033	8b 87 2c 01 00
	00		 mov	 eax, DWORD PTR [edi+300]
$LN2@GetDRInFro:

; 3408 : 	int nColumn = 0;
; 3409 : 	for( int i = 0; i < m_nCountOfBlockColumn; i++)

  00039	42		 inc	 edx
  0003a	83 c1 04	 add	 ecx, 4
  0003d	3b d0		 cmp	 edx, eax
  0003f	7c e4		 jl	 SHORT $LL4@GetDRInFro
  00041	eb 05		 jmp	 SHORT $LN58@GetDRInFro
$LN42@GetDRInFro:

; 3411 : 	{
; 3412 : 		nColumn = i;

  00043	8b f2		 mov	 esi, edx
  00045	89 55 f8	 mov	 DWORD PTR _nColumn$1$[ebp], edx
$LN58@GetDRInFro:

; 3413 : 		break;
; 3414 : 	}
; 3415 : 
; 3416 : 	int nDRI;
; 3417 : 	int nDRI_End = m_nItemCount_Total - 1;

  00048	8b 47 58	 mov	 eax, DWORD PTR [edi+88]
  0004b	0f 57 c0	 xorps	 xmm0, xmm0

; 3418 : 	int nDRI_EndiM = nDRI_End;
; 3419 : 
; 3420 : 	PAREA parea = &m_areaNONE;
; 3421 : 
; 3422 : 	if(m_bReverse == FALSE)

  0004e	f2 0f 10 8c f7
	a8 01 00 00	 movsd	 xmm1, QWORD PTR [edi+esi*8+424]
  00057	48		 dec	 eax

; 3425 : 		if( 0 < m_daItemWidth[ nColumn]) nDRI = ceil((double)nX / m_daItemWidth[ nColumn]) - 1;

  00058	66 0f 2f c8	 comisd	 xmm1, xmm0
  0005c	89 45 fc	 mov	 DWORD PTR _nDRI_End$1$[ebp], eax
  0005f	8d 47 3c	 lea	 eax, DWORD PTR [edi+60]
  00062	89 45 08	 mov	 DWORD PTR _parea$[ebp], eax
  00065	0f 86 85 00 00
	00		 jbe	 $LN59@GetDRInFro

; 3418 : 	int nDRI_EndiM = nDRI_End;
; 3419 : 
; 3420 : 	PAREA parea = &m_areaNONE;
; 3421 : 
; 3422 : 	if(m_bReverse == FALSE)

  0006b	83 ec 08	 sub	 esp, 8
  0006e	83 7f 0c 00	 cmp	 DWORD PTR [edi+12], 0
  00072	75 3e		 jne	 SHORT $LN14@GetDRInFro

; 3423 : 	{
; 3424 : 		int nX = nCursor_x - m_naScreenStart_Cur[ nColumn];

  00074	8b c3		 mov	 eax, ebx
  00076	2b 84 b7 98 02
	00 00		 sub	 eax, DWORD PTR [edi+esi*4+664]
  0007d	66 0f 6e c0	 movd	 xmm0, eax

; 3425 : 		if( 0 < m_daItemWidth[ nColumn]) nDRI = ceil((double)nX / m_daItemWidth[ nColumn]) - 1;

  00081	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00085	f2 0f 5e c1	 divsd	 xmm0, xmm1
  00089	f2 0f 11 45 f0	 movsd	 QWORD PTR tv774[ebp], xmm0
  0008e	dd 45 f0	 fld	 QWORD PTR tv774[ebp]
  00091	dd 1c 24	 fstp	 QWORD PTR [esp]
  00094	e8 00 00 00 00	 call	 _ceil
  00099	dd 5d f0	 fstp	 QWORD PTR tv768[ebp]
  0009c	f2 0f 10 45 f0	 movsd	 xmm0, QWORD PTR tv768[ebp]
  000a1	83 c4 08	 add	 esp, 8
  000a4	f2 0f 5c 05 00
	00 00 00	 subsd	 xmm0, QWORD PTR __real@3ff0000000000000
  000ac	f2 0f 2c c0	 cvttsd2si eax, xmm0

; 3426 : 	}

  000b0	eb 41		 jmp	 SHORT $LN72@GetDRInFro
$LN14@GetDRInFro:

; 3427 : 	else
; 3428 : 	{
; 3429 : 		int nX = m_naScreenStart_Cur[ nColumn] - nCursor_x;

  000b2	8b 84 b7 98 02
	00 00		 mov	 eax, DWORD PTR [edi+esi*4+664]
  000b9	2b c3		 sub	 eax, ebx
  000bb	66 0f 6e c0	 movd	 xmm0, eax

; 3430 : 		if( 0 < m_daItemWidth[ nColumn]) nDRI = ceil((double)nX / m_daItemWidth[ nColumn]) - 1;

  000bf	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  000c3	f2 0f 5e c1	 divsd	 xmm0, xmm1
  000c7	f2 0f 11 45 f0	 movsd	 QWORD PTR tv765[ebp], xmm0
  000cc	dd 45 f0	 fld	 QWORD PTR tv765[ebp]
  000cf	dd 1c 24	 fstp	 QWORD PTR [esp]
  000d2	e8 00 00 00 00	 call	 _ceil
  000d7	dd 5d f0	 fstp	 QWORD PTR tv759[ebp]
  000da	f2 0f 10 45 f0	 movsd	 xmm0, QWORD PTR tv759[ebp]
  000df	83 c4 08	 add	 esp, 8
  000e2	f2 0f 5c 05 00
	00 00 00	 subsd	 xmm0, QWORD PTR __real@3ff0000000000000
  000ea	f2 0f 2c c0	 cvttsd2si eax, xmm0
  000ee	eb 03		 jmp	 SHORT $LN72@GetDRInFro
$LN59@GetDRInFro:

; 3425 : 		if( 0 < m_daItemWidth[ nColumn]) nDRI = ceil((double)nX / m_daItemWidth[ nColumn]) - 1;

  000f0	8b 45 18	 mov	 eax, DWORD PTR _nDRI$[ebp]
$LN72@GetDRInFro:

; 3431 : 	}
; 3432 : 	
; 3433 : 	//    : xScaleManager - ojtaso (20070611)
; 3434 : 	if( bIncludeRightMargin && !m_pIChartCtrl->IsRunningOneChart() && m_nRightMarginWidth && 0 < m_daItemWidth[ nColumn])

  000f3	83 7d 14 00	 cmp	 DWORD PTR _bIncludeRightMargin$[ebp], 0
  000f7	89 45 f4	 mov	 DWORD PTR _nDRI$2$[ebp], eax
  000fa	74 68		 je	 SHORT $LN71@GetDRInFro
  000fc	8b 4f 50	 mov	 ecx, DWORD PTR [edi+80]
  000ff	8b 01		 mov	 eax, DWORD PTR [ecx]
  00101	ff 90 38 01 00
	00		 call	 DWORD PTR [eax+312]
  00107	85 c0		 test	 eax, eax
  00109	75 59		 jne	 SHORT $LN71@GetDRInFro
  0010b	8b 47 1c	 mov	 eax, DWORD PTR [edi+28]
  0010e	85 c0		 test	 eax, eax
  00110	74 52		 je	 SHORT $LN71@GetDRInFro
  00112	f2 0f 10 8c f7
	a8 01 00 00	 movsd	 xmm1, QWORD PTR [edi+esi*8+424]
  0011b	0f 57 c0	 xorps	 xmm0, xmm0
  0011e	66 0f 2f c8	 comisd	 xmm1, xmm0
  00122	76 40		 jbe	 SHORT $LN71@GetDRInFro

; 3435 : 		nDRI_End += ceil((double)m_nRightMarginWidth / m_daItemWidth[ nColumn]);

  00124	66 0f 6e c0	 movd	 xmm0, eax
  00128	83 ec 08	 sub	 esp, 8
  0012b	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  0012f	f2 0f 5e c1	 divsd	 xmm0, xmm1
  00133	f2 0f 11 45 e8	 movsd	 QWORD PTR tv753[ebp], xmm0
  00138	dd 45 e8	 fld	 QWORD PTR tv753[ebp]
  0013b	dd 1c 24	 fstp	 QWORD PTR [esp]
  0013e	e8 00 00 00 00	 call	 _ceil
  00143	66 0f 6e 45 fc	 movd	 xmm0, DWORD PTR _nDRI_End$1$[ebp]
  00148	83 c4 08	 add	 esp, 8
  0014b	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  0014f	dd 5d e8	 fstp	 QWORD PTR tv747[ebp]
  00152	f2 0f 10 4d e8	 movsd	 xmm1, QWORD PTR tv747[ebp]
  00157	f2 0f 58 c8	 addsd	 xmm1, xmm0
  0015b	f2 0f 2c c9	 cvttsd2si ecx, xmm1
  0015f	89 4d fc	 mov	 DWORD PTR _nDRI_End$1$[ebp], ecx
  00162	eb 03		 jmp	 SHORT $LN18@GetDRInFro
$LN71@GetDRInFro:

; 3436 : 
; 3437 : 	if(m_bReverse == FALSE)

  00164	8b 4d fc	 mov	 ecx, DWORD PTR _nDRI_End$1$[ebp]
$LN18@GetDRInFro:
  00167	83 7f 0c 00	 cmp	 DWORD PTR [edi+12], 0
  0016b	0f 85 b7 00 00
	00		 jne	 $LN19@GetDRInFro

; 3438 : 	{
; 3439 : 		nDRI = m_nDRI_Start_Cur + nDRI;	// DRI   .

  00171	8b 55 f4	 mov	 edx, DWORD PTR _nDRI$2$[ebp]
  00174	03 57 28	 add	 edx, DWORD PTR [edi+40]

; 3440 : 
; 3441 : 		// (2008/8/14 - Seung-Won, Bae) Support Checking of DRI Bound
; 3442 : 		if( p_bWithBoundCheck && ( nDRI < 0 || nDRI > nDRI_End)) return -1;

  00177	83 7d 18 00	 cmp	 DWORD PTR _p_bWithBoundCheck$[ebp], 0
  0017b	74 10		 je	 SHORT $LN21@GetDRInFro
  0017d	85 d2		 test	 edx, edx
  0017f	0f 88 b7 00 00
	00		 js	 $LN30@GetDRInFro
  00185	3b d1		 cmp	 edx, ecx
  00187	0f 8f af 00 00
	00		 jg	 $LN30@GetDRInFro
$LN21@GetDRInFro:

; 3443 : 
; 3444 : 		if(nDRI < 0)		nDRI = 0;
; 3445 : 		if(nDRI > nDRI_End)	nDRI = nDRI_End;

  0018d	33 c0		 xor	 eax, eax
  0018f	85 d2		 test	 edx, edx
  00191	0f 49 c2	 cmovns	 eax, edx

; 3446 : 
; 3447 : 		GetAreaFromDRI( nColumn, nDRI, &parea);

  00194	8b d1		 mov	 edx, ecx
  00196	3b c1		 cmp	 eax, ecx
  00198	8d 4d 08	 lea	 ecx, DWORD PTR _parea$[ebp]
  0019b	51		 push	 ecx
  0019c	0f 4e d0	 cmovle	 edx, eax
  0019f	8b cf		 mov	 ecx, edi
  001a1	8b 07		 mov	 eax, DWORD PTR [edi]
  001a3	52		 push	 edx
  001a4	56		 push	 esi
  001a5	89 55 18	 mov	 DWORD PTR tv683[ebp], edx
  001a8	ff 90 44 01 00
	00		 call	 DWORD PTR [eax+324]

; 3448 : 
; 3449 : 		// (2008/9/8 - Seung-Won, Bae) Check first for nDRI of bound.
; 3450 : 		if(parea) while(nDRI > 0 && nCursor_x < parea->left)

  001ae	8b 4d 08	 mov	 ecx, DWORD PTR _parea$[ebp]
  001b1	8b 45 18	 mov	 eax, DWORD PTR tv683[ebp]
  001b4	8b f0		 mov	 esi, eax
  001b6	85 c9		 test	 ecx, ecx
  001b8	0f 84 0a 01 00
	00		 je	 $LN12@GetDRInFro
  001be	85 c0		 test	 eax, eax
  001c0	7e 29		 jle	 SHORT $LN43@GetDRInFro
$LL5@GetDRInFro:
  001c2	0f bf 01	 movsx	 eax, WORD PTR [ecx]
  001c5	3b d8		 cmp	 ebx, eax
  001c7	7d 22		 jge	 SHORT $LN43@GetDRInFro

; 3451 : 		{
; 3452 : 			nDRI--;
; 3453 : 			GetAreaFromDRI( nColumn, nDRI, &parea);

  001c9	8b 07		 mov	 eax, DWORD PTR [edi]
  001cb	8d 4d 08	 lea	 ecx, DWORD PTR _parea$[ebp]
  001ce	51		 push	 ecx
  001cf	4e		 dec	 esi
  001d0	8b cf		 mov	 ecx, edi
  001d2	56		 push	 esi
  001d3	ff 75 f8	 push	 DWORD PTR _nColumn$1$[ebp]
  001d6	ff 90 44 01 00
	00		 call	 DWORD PTR [eax+324]

; 3454 : 			if( !parea) break;

  001dc	8b 4d 08	 mov	 ecx, DWORD PTR _parea$[ebp]
  001df	85 c9		 test	 ecx, ecx
  001e1	0f 84 e1 00 00
	00		 je	 $LN12@GetDRInFro

; 3448 : 
; 3449 : 		// (2008/9/8 - Seung-Won, Bae) Check first for nDRI of bound.
; 3450 : 		if(parea) while(nDRI > 0 && nCursor_x < parea->left)

  001e7	85 f6		 test	 esi, esi
  001e9	7f d7		 jg	 SHORT $LL5@GetDRInFro
$LN43@GetDRInFro:

; 3455 : 		}
; 3456 : 		if(parea) while(nDRI < nDRI_End && nCursor_x >= parea->right)

  001eb	3b 75 fc	 cmp	 esi, DWORD PTR _nDRI_End$1$[ebp]
  001ee	0f 8d d4 00 00
	00		 jge	 $LN12@GetDRInFro
$LL7@GetDRInFro:
  001f4	0f bf 41 04	 movsx	 eax, WORD PTR [ecx+4]
  001f8	3b d8		 cmp	 ebx, eax
  001fa	0f 8c c8 00 00
	00		 jl	 $LN12@GetDRInFro

; 3457 : 		{
; 3458 : 			nDRI++;
; 3459 : 			GetAreaFromDRI( nColumn, nDRI, &parea);

  00200	8b 07		 mov	 eax, DWORD PTR [edi]
  00202	8d 4d 08	 lea	 ecx, DWORD PTR _parea$[ebp]
  00205	51		 push	 ecx
  00206	46		 inc	 esi
  00207	8b cf		 mov	 ecx, edi
  00209	56		 push	 esi
  0020a	ff 75 f8	 push	 DWORD PTR _nColumn$1$[ebp]
  0020d	ff 90 44 01 00
	00		 call	 DWORD PTR [eax+324]

; 3460 : 			if( !parea) break;

  00213	8b 4d 08	 mov	 ecx, DWORD PTR _parea$[ebp]
  00216	85 c9		 test	 ecx, ecx
  00218	0f 84 aa 00 00
	00		 je	 $LN12@GetDRInFro

; 3455 : 		}
; 3456 : 		if(parea) while(nDRI < nDRI_End && nCursor_x >= parea->right)

  0021e	3b 75 fc	 cmp	 esi, DWORD PTR _nDRI_End$1$[ebp]
  00221	7c d1		 jl	 SHORT $LL7@GetDRInFro

; 3461 : 		}
; 3462 : 	}

  00223	e9 a0 00 00 00	 jmp	 $LN12@GetDRInFro
$LN19@GetDRInFro:

; 3463 : 	else
; 3464 : 	{
; 3465 : 		nDRI = m_nDRI_End_Cur - nDRI;	// DRI   .

  00228	8b 57 2c	 mov	 edx, DWORD PTR [edi+44]
  0022b	2b 55 f4	 sub	 edx, DWORD PTR _nDRI$2$[ebp]

; 3466 : 
; 3467 : 		// (2008/8/14 - Seung-Won, Bae) Support Checking of DRI Bound
; 3468 : 		if( p_bWithBoundCheck && ( nDRI < 0 || nDRI > nDRI_End)) return -1;

  0022e	83 7d 18 00	 cmp	 DWORD PTR _p_bWithBoundCheck$[ebp], 0
  00232	74 14		 je	 SHORT $LN29@GetDRInFro
  00234	85 d2		 test	 edx, edx
  00236	78 04		 js	 SHORT $LN30@GetDRInFro
  00238	3b d1		 cmp	 edx, ecx
  0023a	7e 0c		 jle	 SHORT $LN29@GetDRInFro
$LN30@GetDRInFro:
  0023c	5f		 pop	 edi

; 3494 : }

  0023d	5e		 pop	 esi
  0023e	83 c8 ff	 or	 eax, -1
  00241	5b		 pop	 ebx
  00242	8b e5		 mov	 esp, ebp
  00244	5d		 pop	 ebp
  00245	c2 14 00	 ret	 20			; 00000014H
$LN29@GetDRInFro:

; 3469 : 		
; 3470 : 		if(nDRI < 0)		nDRI = 0;
; 3471 : 		if(nDRI > nDRI_End)	nDRI = nDRI_End;

  00248	33 c0		 xor	 eax, eax

; 3472 : 
; 3473 : 		GetAreaFromDRI( nColumn, nDRI, &parea);

  0024a	8b f1		 mov	 esi, ecx
  0024c	85 d2		 test	 edx, edx
  0024e	0f 49 c2	 cmovns	 eax, edx
  00251	3b c1		 cmp	 eax, ecx
  00253	8d 4d 08	 lea	 ecx, DWORD PTR _parea$[ebp]
  00256	51		 push	 ecx
  00257	0f 4e f0	 cmovle	 esi, eax
  0025a	8b cf		 mov	 ecx, edi
  0025c	8b 07		 mov	 eax, DWORD PTR [edi]
  0025e	56		 push	 esi
  0025f	ff 75 f8	 push	 DWORD PTR _nColumn$1$[ebp]
  00262	89 75 18	 mov	 DWORD PTR tv681[ebp], esi
  00265	ff 90 44 01 00
	00		 call	 DWORD PTR [eax+324]

; 3474 : 
; 3475 : 		if(parea)

  0026b	8b 4d 08	 mov	 ecx, DWORD PTR _parea$[ebp]
  0026e	85 c9		 test	 ecx, ecx
  00270	74 56		 je	 SHORT $LN12@GetDRInFro

; 3476 : 		{
; 3477 : 			// (2008/9/8 - Seung-Won, Bae) Check first for nDRI of bound.
; 3478 : 			while(nDRI < nDRI_End && nCursor_x < parea->left)

  00272	8b c6		 mov	 eax, esi
  00274	3b 45 fc	 cmp	 eax, DWORD PTR _nDRI_End$1$[ebp]
  00277	7d 29		 jge	 SHORT $LN41@GetDRInFro
  00279	0f 1f 80 00 00
	00 00		 npad	 7
$LL9@GetDRInFro:
  00280	0f bf 01	 movsx	 eax, WORD PTR [ecx]
  00283	3b d8		 cmp	 ebx, eax
  00285	7d 1b		 jge	 SHORT $LN41@GetDRInFro

; 3479 : 			{
; 3480 : 				nDRI++;
; 3481 : 				GetAreaFromDRI( nColumn, nDRI, &parea);

  00287	8b 07		 mov	 eax, DWORD PTR [edi]
  00289	8d 4d 08	 lea	 ecx, DWORD PTR _parea$[ebp]
  0028c	51		 push	 ecx
  0028d	46		 inc	 esi
  0028e	8b cf		 mov	 ecx, edi
  00290	56		 push	 esi
  00291	ff 75 f8	 push	 DWORD PTR _nColumn$1$[ebp]
  00294	ff 90 44 01 00
	00		 call	 DWORD PTR [eax+324]
  0029a	8b 4d 08	 mov	 ecx, DWORD PTR _parea$[ebp]
  0029d	3b 75 fc	 cmp	 esi, DWORD PTR _nDRI_End$1$[ebp]
  002a0	7c de		 jl	 SHORT $LL9@GetDRInFro
$LN41@GetDRInFro:

; 3482 : 			}
; 3483 : 			while(nDRI > 0 && nCursor_x >= parea->right)

  002a2	85 f6		 test	 esi, esi
  002a4	7e 22		 jle	 SHORT $LN12@GetDRInFro
$LL11@GetDRInFro:
  002a6	0f bf 41 04	 movsx	 eax, WORD PTR [ecx+4]
  002aa	3b d8		 cmp	 ebx, eax
  002ac	7c 1a		 jl	 SHORT $LN12@GetDRInFro

; 3484 : 			{
; 3485 : 				nDRI--;
; 3486 : 				GetAreaFromDRI( nColumn, nDRI, &parea);

  002ae	8b 07		 mov	 eax, DWORD PTR [edi]
  002b0	8d 4d 08	 lea	 ecx, DWORD PTR _parea$[ebp]
  002b3	51		 push	 ecx
  002b4	4e		 dec	 esi
  002b5	8b cf		 mov	 ecx, edi
  002b7	56		 push	 esi
  002b8	ff 75 f8	 push	 DWORD PTR _nColumn$1$[ebp]
  002bb	ff 90 44 01 00
	00		 call	 DWORD PTR [eax+324]
  002c1	8b 4d 08	 mov	 ecx, DWORD PTR _parea$[ebp]
  002c4	85 f6		 test	 esi, esi
  002c6	7f de		 jg	 SHORT $LL11@GetDRInFro
$LN12@GetDRInFro:

; 3487 : 			} 
; 3488 : 		}
; 3489 : 	}
; 3490 : 
; 3491 : 	if( pnBlockColumn) *pnBlockColumn = nColumn;

  002c8	8b 55 0c	 mov	 edx, DWORD PTR _pnBlockColumn$[ebp]
  002cb	85 d2		 test	 edx, edx
  002cd	74 05		 je	 SHORT $LN34@GetDRInFro
  002cf	8b 45 f8	 mov	 eax, DWORD PTR _nColumn$1$[ebp]
  002d2	89 02		 mov	 DWORD PTR [edx], eax
$LN34@GetDRInFro:

; 3492 : 	if( pparea != NULL) *pparea = parea;

  002d4	8b 45 10	 mov	 eax, DWORD PTR _pparea$[ebp]
  002d7	85 c0		 test	 eax, eax
  002d9	74 02		 je	 SHORT $LN35@GetDRInFro
  002db	89 08		 mov	 DWORD PTR [eax], ecx
$LN35@GetDRInFro:
  002dd	5f		 pop	 edi

; 3493 : 	return nDRI;

  002de	8b c6		 mov	 eax, esi

; 3494 : }

  002e0	5e		 pop	 esi
  002e1	5b		 pop	 ebx
  002e2	8b e5		 mov	 esp, ebp
  002e4	5d		 pop	 ebp
  002e5	c2 14 00	 ret	 20			; 00000014H
?GetDRInFromPt@CXScaleManagerImp@@MAEHHPAHPAPAUtagAREA@CXScaleManager@@HH@Z ENDP ; CXScaleManagerImp::GetDRInFromPt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.h
;	COMDAT ?GetColumnWidth@CXScaleManagerImp@@MAEHH@Z
_TEXT	SEGMENT
_p_nColumn$ = 8						; size = 4
?GetColumnWidth@CXScaleManagerImp@@MAEHH@Z PROC		; CXScaleManagerImp::GetColumnWidth, COMDAT
; _this$ = ecx

; 481  : 	virtual int						GetColumnWidth( int p_nColumn)							{	return m_nColumnWidth[ p_nColumn];	}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _p_nColumn$[ebp]
  00006	8b 84 81 30 01
	00 00		 mov	 eax, DWORD PTR [ecx+eax*4+304]
  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
?GetColumnWidth@CXScaleManagerImp@@MAEHH@Z ENDP		; CXScaleManagerImp::GetColumnWidth
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?ItemIntervalApply_Reverse@CXScaleManagerImp@@IAEXHAAUtagAREA@CXScaleManager@@H@Z
_TEXT	SEGMENT
_p_nColumn$ = 8						; size = 4
_area$ = 12						; size = 4
_nDRI_Count$ = 16					; size = 4
?ItemIntervalApply_Reverse@CXScaleManagerImp@@IAEXHAAUtagAREA@CXScaleManager@@H@Z PROC ; CXScaleManagerImp::ItemIntervalApply_Reverse, COMDAT
; _this$ = ecx

; 3352 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 3353 : 	int nItemWidth_Cur = area.right - area.left;

  00005	8b 75 0c	 mov	 esi, DWORD PTR _area$[ebp]
  00008	57		 push	 edi
  00009	0f b7 7e 04	 movzx	 edi, WORD PTR [esi+4]
  0000d	0f b7 1e	 movzx	 ebx, WORD PTR [esi]
  00010	0f bf c3	 movsx	 eax, bx
  00013	0f bf d7	 movsx	 edx, di
  00016	2b d0		 sub	 edx, eax

; 3354 : 
; 3355 : 	if( m_bWeightedVolume == FALSE && nDRI_Count == 1)

  00018	83 79 10 00	 cmp	 DWORD PTR [ecx+16], 0
  0001c	0f 85 be 00 00
	00		 jne	 $LN4@ItemInterv
  00022	83 7d 10 01	 cmp	 DWORD PTR _nDRI_Count$[ebp], 1
  00026	0f 85 b4 00 00
	00		 jne	 $LN4@ItemInterv

; 3356 : 	{
; 3357 : 		switch( m_naItemWidth[ p_nColumn])

  0002c	8b 45 08	 mov	 eax, DWORD PTR _p_nColumn$[ebp]
  0002f	8b 8c 81 60 03
	00 00		 mov	 ecx, DWORD PTR [ecx+eax*4+864]
  00036	8b c1		 mov	 eax, ecx
  00038	83 e8 01	 sub	 eax, 1
  0003b	0f 84 8c 00 00
	00		 je	 $LN6@ItemInterv
  00041	83 e8 01	 sub	 eax, 1
  00044	74 75		 je	 SHORT $LN8@ItemInterv
  00046	83 e8 01	 sub	 eax, 1
  00049	74 5d		 je	 SHORT $LN10@ItemInterv

; 3374 : 			}
; 3375 : 			break;
; 3376 : 
; 3377 : 		default:
; 3378 : 			{
; 3379 : 				if( ( m_naItemWidth[ p_nColumn] % 2) == 1)

  0004b	81 e2 01 00 00
	80		 and	 edx, -2147483647	; 80000001H
  00051	79 05		 jns	 SHORT $LN24@ItemInterv
  00053	4a		 dec	 edx
  00054	83 ca fe	 or	 edx, -2			; fffffffeH
  00057	42		 inc	 edx
$LN24@ItemInterv:
  00058	81 e1 01 00 00
	80		 and	 ecx, -2147483647	; 80000001H
  0005e	79 05		 jns	 SHORT $LN25@ItemInterv
  00060	49		 dec	 ecx
  00061	83 c9 fe	 or	 ecx, -2			; fffffffeH
  00064	41		 inc	 ecx
$LN25@ItemInterv:
  00065	83 f9 01	 cmp	 ecx, 1
  00068	75 18		 jne	 SHORT $LN13@ItemInterv

; 3380 : 				{
; 3381 : 					if( ( nItemWidth_Cur % 2) == 1)	area.right-=2;
; 3382 : 					else							area.right-=3;
; 3383 : 				}

  0006a	33 c0		 xor	 eax, eax
  0006c	3b d1		 cmp	 edx, ecx
  0006e	0f 95 c0	 setne	 al
  00071	83 c0 02	 add	 eax, 2
  00074	66 2b f8	 sub	 di, ax
  00077	66 89 7e 04	 mov	 WORD PTR [esi+4], di
  0007b	5f		 pop	 edi

; 3399 : 			else							area.right-=1;
; 3400 : 		}
; 3401 : 	}
; 3402 : }

  0007c	5e		 pop	 esi
  0007d	5b		 pop	 ebx
  0007e	5d		 pop	 ebp
  0007f	c2 0c 00	 ret	 12			; 0000000cH
$LN13@ItemInterv:

; 3384 : 				else
; 3385 : 				{
; 3386 : 					if( ( nItemWidth_Cur % 2) == 1)	area.right-=2;
; 3387 : 					else							area.right-=1;
; 3388 : 					if( area.right < area.left)		area.left = area.right = area.center;

  00082	4a		 dec	 edx
  00083	f7 da		 neg	 edx
  00085	1b d2		 sbb	 edx, edx
  00087	83 c2 02	 add	 edx, 2
  0008a	66 2b fa	 sub	 di, dx
  0008d	66 89 7e 04	 mov	 WORD PTR [esi+4], di
  00091	66 3b fb	 cmp	 di, bx
  00094	7d 6b		 jge	 SHORT $LN22@ItemInterv
  00096	0f b7 46 02	 movzx	 eax, WORD PTR [esi+2]
  0009a	5f		 pop	 edi
  0009b	66 89 06	 mov	 WORD PTR [esi], ax

; 3399 : 			else							area.right-=1;
; 3400 : 		}
; 3401 : 	}
; 3402 : }

  0009e	66 89 46 04	 mov	 WORD PTR [esi+4], ax
  000a2	5e		 pop	 esi
  000a3	5b		 pop	 ebx
  000a4	5d		 pop	 ebp
  000a5	c2 0c 00	 ret	 12			; 0000000cH
$LN10@ItemInterv:

; 3368 : 			}
; 3369 : 			break;
; 3370 : 
; 3371 : 		case 3:
; 3372 : 			{
; 3373 : 				if(nItemWidth_Cur == 4) area.right--;

  000a8	83 fa 04	 cmp	 edx, 4
  000ab	75 54		 jne	 SHORT $LN22@ItemInterv

; 3399 : 			else							area.right-=1;
; 3400 : 		}
; 3401 : 	}
; 3402 : }

  000ad	8d 47 ff	 lea	 eax, DWORD PTR [edi-1]
  000b0	5f		 pop	 edi
  000b1	66 89 46 04	 mov	 WORD PTR [esi+4], ax
  000b5	5e		 pop	 esi
  000b6	5b		 pop	 ebx
  000b7	5d		 pop	 ebp
  000b8	c2 0c 00	 ret	 12			; 0000000cH
$LN8@ItemInterv:

; 3362 : 			}
; 3363 : 			break;
; 3364 : 
; 3365 : 		case 2:
; 3366 : 			{
; 3367 : 				if(nItemWidth_Cur == 2) area.left--;

  000bb	83 fa 02	 cmp	 edx, 2
  000be	75 41		 jne	 SHORT $LN22@ItemInterv
  000c0	8d 43 ff	 lea	 eax, DWORD PTR [ebx-1]
  000c3	5f		 pop	 edi
  000c4	66 89 06	 mov	 WORD PTR [esi], ax

; 3399 : 			else							area.right-=1;
; 3400 : 		}
; 3401 : 	}
; 3402 : }

  000c7	5e		 pop	 esi
  000c8	5b		 pop	 ebx
  000c9	5d		 pop	 ebp
  000ca	c2 0c 00	 ret	 12			; 0000000cH
$LN6@ItemInterv:

; 3358 : 		{ 
; 3359 : 		case 1:
; 3360 : 			{
; 3361 : 				if(nItemWidth_Cur == 2) area.right--;

  000cd	83 fa 02	 cmp	 edx, 2
  000d0	75 2f		 jne	 SHORT $LN22@ItemInterv

; 3399 : 			else							area.right-=1;
; 3400 : 		}
; 3401 : 	}
; 3402 : }

  000d2	8d 47 ff	 lea	 eax, DWORD PTR [edi-1]
  000d5	5f		 pop	 edi
  000d6	66 89 46 04	 mov	 WORD PTR [esi+4], ax
  000da	5e		 pop	 esi
  000db	5b		 pop	 ebx
  000dc	5d		 pop	 ebp
  000dd	c2 0c 00	 ret	 12			; 0000000cH
$LN4@ItemInterv:

; 3389 : 				}
; 3390 : 			}
; 3391 : 			break;
; 3392 : 		}
; 3393 : 	}
; 3394 : 	else
; 3395 : 	{
; 3396 : 		if( nItemWidth_Cur > 1)

  000e0	83 fa 01	 cmp	 edx, 1
  000e3	7e 1c		 jle	 SHORT $LN22@ItemInterv

; 3397 : 		{
; 3398 : 			if( ( nItemWidth_Cur % 2) == 1)	area.right-=2;

  000e5	81 e2 01 00 00
	80		 and	 edx, -2147483647	; 80000001H
  000eb	79 05		 jns	 SHORT $LN26@ItemInterv
  000ed	4a		 dec	 edx
  000ee	83 ca fe	 or	 edx, -2			; fffffffeH
  000f1	42		 inc	 edx
$LN26@ItemInterv:
  000f2	8d 47 fe	 lea	 eax, DWORD PTR [edi-2]
  000f5	83 fa 01	 cmp	 edx, 1
  000f8	74 03		 je	 SHORT $LN27@ItemInterv

; 3399 : 			else							area.right-=1;
; 3400 : 		}
; 3401 : 	}
; 3402 : }

  000fa	8d 47 ff	 lea	 eax, DWORD PTR [edi-1]
$LN27@ItemInterv:
  000fd	66 89 46 04	 mov	 WORD PTR [esi+4], ax
$LN22@ItemInterv:
  00101	5f		 pop	 edi
  00102	5e		 pop	 esi
  00103	5b		 pop	 ebx
  00104	5d		 pop	 ebp
  00105	c2 0c 00	 ret	 12			; 0000000cH
?ItemIntervalApply_Reverse@CXScaleManagerImp@@IAEXHAAUtagAREA@CXScaleManager@@H@Z ENDP ; CXScaleManagerImp::ItemIntervalApply_Reverse
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?ItemIntervalApply@CXScaleManagerImp@@IAEXHAAUtagAREA@CXScaleManager@@H@Z
_TEXT	SEGMENT
_p_nColumn$ = 8						; size = 4
_area$ = 12						; size = 4
_nDRI_Count$ = 16					; size = 4
?ItemIntervalApply@CXScaleManagerImp@@IAEXHAAUtagAREA@CXScaleManager@@H@Z PROC ; CXScaleManagerImp::ItemIntervalApply, COMDAT
; _this$ = ecx

; 3298 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 3299 : 	int nItemWidth_Cur = area.right - area.left;

  00005	8b 75 0c	 mov	 esi, DWORD PTR _area$[ebp]
  00008	57		 push	 edi
  00009	0f b7 5e 04	 movzx	 ebx, WORD PTR [esi+4]
  0000d	0f b7 3e	 movzx	 edi, WORD PTR [esi]
  00010	0f bf c7	 movsx	 eax, di
  00013	0f bf d3	 movsx	 edx, bx
  00016	2b d0		 sub	 edx, eax

; 3300 : 
; 3301 : 	if( m_bWeightedVolume == FALSE && nDRI_Count == 1)

  00018	83 79 10 00	 cmp	 DWORD PTR [ecx+16], 0
  0001c	0f 85 bb 00 00
	00		 jne	 $LN4@ItemInterv
  00022	83 7d 10 01	 cmp	 DWORD PTR _nDRI_Count$[ebp], 1
  00026	0f 85 b1 00 00
	00		 jne	 $LN4@ItemInterv

; 3302 : 	{
; 3303 : 		switch( m_naItemWidth[ p_nColumn])

  0002c	8b 45 08	 mov	 eax, DWORD PTR _p_nColumn$[ebp]
  0002f	8b 8c 81 60 03
	00 00		 mov	 ecx, DWORD PTR [ecx+eax*4+864]
  00036	8b c1		 mov	 eax, ecx
  00038	83 e8 01	 sub	 eax, 1
  0003b	0f 84 8a 00 00
	00		 je	 $LN6@ItemInterv
  00041	83 e8 01	 sub	 eax, 1
  00044	74 72		 je	 SHORT $LN8@ItemInterv
  00046	83 e8 01	 sub	 eax, 1
  00049	74 5b		 je	 SHORT $LN10@ItemInterv

; 3320 : 			}
; 3321 : 			break;
; 3322 : 
; 3323 : 		default:
; 3324 : 			{
; 3325 : 				if( ( m_naItemWidth[ p_nColumn] % 2) == 1)

  0004b	81 e2 01 00 00
	80		 and	 edx, -2147483647	; 80000001H
  00051	79 05		 jns	 SHORT $LN24@ItemInterv
  00053	4a		 dec	 edx
  00054	83 ca fe	 or	 edx, -2			; fffffffeH
  00057	42		 inc	 edx
$LN24@ItemInterv:
  00058	81 e1 01 00 00
	80		 and	 ecx, -2147483647	; 80000001H
  0005e	79 05		 jns	 SHORT $LN25@ItemInterv
  00060	49		 dec	 ecx
  00061	83 c9 fe	 or	 ecx, -2			; fffffffeH
  00064	41		 inc	 ecx
$LN25@ItemInterv:
  00065	83 f9 01	 cmp	 ecx, 1
  00068	75 17		 jne	 SHORT $LN13@ItemInterv

; 3326 : 				{
; 3327 : 					if( ( nItemWidth_Cur % 2) == 1)	area.left+=2;
; 3328 : 					else							area.left+=3;
; 3329 : 				}

  0006a	33 c0		 xor	 eax, eax
  0006c	3b d1		 cmp	 edx, ecx
  0006e	0f 95 c0	 setne	 al
  00071	83 c0 02	 add	 eax, 2
  00074	66 03 c7	 add	 ax, di
  00077	5f		 pop	 edi

; 3345 : 			else							area.left+=1;
; 3346 : 		}
; 3347 : 	}
; 3348 : }

  00078	66 89 06	 mov	 WORD PTR [esi], ax
  0007b	5e		 pop	 esi
  0007c	5b		 pop	 ebx
  0007d	5d		 pop	 ebp
  0007e	c2 0c 00	 ret	 12			; 0000000cH
$LN13@ItemInterv:

; 3330 : 				else
; 3331 : 				{
; 3332 : 					if( ( nItemWidth_Cur % 2) == 1)	area.left+=2;
; 3333 : 					else							area.left+=1;
; 3334 : 					if( area.right < area.left)		area.left = area.right = area.center;

  00081	4a		 dec	 edx
  00082	f7 da		 neg	 edx
  00084	1b d2		 sbb	 edx, edx
  00086	83 c2 02	 add	 edx, 2
  00089	66 03 d7	 add	 dx, di
  0008c	66 89 16	 mov	 WORD PTR [esi], dx
  0008f	66 3b da	 cmp	 bx, dx
  00092	7d 69		 jge	 SHORT $LN22@ItemInterv
  00094	0f b7 46 02	 movzx	 eax, WORD PTR [esi+2]
  00098	5f		 pop	 edi
  00099	66 89 46 04	 mov	 WORD PTR [esi+4], ax

; 3345 : 			else							area.left+=1;
; 3346 : 		}
; 3347 : 	}
; 3348 : }

  0009d	66 89 06	 mov	 WORD PTR [esi], ax
  000a0	5e		 pop	 esi
  000a1	5b		 pop	 ebx
  000a2	5d		 pop	 ebp
  000a3	c2 0c 00	 ret	 12			; 0000000cH
$LN10@ItemInterv:

; 3314 : 			}
; 3315 : 			break;
; 3316 : 
; 3317 : 		case 3:
; 3318 : 			{
; 3319 : 				if(nItemWidth_Cur == 4) area.left++;

  000a6	83 fa 04	 cmp	 edx, 4
  000a9	75 52		 jne	 SHORT $LN22@ItemInterv

; 3345 : 			else							area.left+=1;
; 3346 : 		}
; 3347 : 	}
; 3348 : }

  000ab	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  000ae	5f		 pop	 edi
  000af	66 89 06	 mov	 WORD PTR [esi], ax
  000b2	5e		 pop	 esi
  000b3	5b		 pop	 ebx
  000b4	5d		 pop	 ebp
  000b5	c2 0c 00	 ret	 12			; 0000000cH
$LN8@ItemInterv:

; 3308 : 			}
; 3309 : 			break;
; 3310 : 
; 3311 : 		case 2:
; 3312 : 			{
; 3313 : 				if(nItemWidth_Cur == 2) area.right++;

  000b8	83 fa 02	 cmp	 edx, 2
  000bb	75 40		 jne	 SHORT $LN22@ItemInterv
  000bd	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
  000c0	5f		 pop	 edi
  000c1	66 89 46 04	 mov	 WORD PTR [esi+4], ax

; 3345 : 			else							area.left+=1;
; 3346 : 		}
; 3347 : 	}
; 3348 : }

  000c5	5e		 pop	 esi
  000c6	5b		 pop	 ebx
  000c7	5d		 pop	 ebp
  000c8	c2 0c 00	 ret	 12			; 0000000cH
$LN6@ItemInterv:

; 3304 : 		{
; 3305 : 		case 1:
; 3306 : 			{
; 3307 : 				if(nItemWidth_Cur == 2) area.left++;

  000cb	83 fa 02	 cmp	 edx, 2
  000ce	75 2d		 jne	 SHORT $LN22@ItemInterv

; 3345 : 			else							area.left+=1;
; 3346 : 		}
; 3347 : 	}
; 3348 : }

  000d0	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  000d3	5f		 pop	 edi
  000d4	66 89 06	 mov	 WORD PTR [esi], ax
  000d7	5e		 pop	 esi
  000d8	5b		 pop	 ebx
  000d9	5d		 pop	 ebp
  000da	c2 0c 00	 ret	 12			; 0000000cH
$LN4@ItemInterv:

; 3335 : 				}
; 3336 : 			}
; 3337 : 			break;
; 3338 : 		}
; 3339 : 	}
; 3340 : 	else
; 3341 : 	{
; 3342 : 		if( nItemWidth_Cur > 1)

  000dd	83 fa 01	 cmp	 edx, 1
  000e0	7e 1b		 jle	 SHORT $LN22@ItemInterv

; 3343 : 		{
; 3344 : 			if( ( nItemWidth_Cur % 2) == 1)	area.left+=2;

  000e2	81 e2 01 00 00
	80		 and	 edx, -2147483647	; 80000001H
  000e8	79 05		 jns	 SHORT $LN26@ItemInterv
  000ea	4a		 dec	 edx
  000eb	83 ca fe	 or	 edx, -2			; fffffffeH
  000ee	42		 inc	 edx
$LN26@ItemInterv:
  000ef	8d 47 02	 lea	 eax, DWORD PTR [edi+2]
  000f2	83 fa 01	 cmp	 edx, 1
  000f5	74 03		 je	 SHORT $LN27@ItemInterv

; 3345 : 			else							area.left+=1;
; 3346 : 		}
; 3347 : 	}
; 3348 : }

  000f7	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
$LN27@ItemInterv:
  000fa	66 89 06	 mov	 WORD PTR [esi], ax
$LN22@ItemInterv:
  000fd	5f		 pop	 edi
  000fe	5e		 pop	 esi
  000ff	5b		 pop	 ebx
  00100	5d		 pop	 ebp
  00101	c2 0c 00	 ret	 12			; 0000000cH
?ItemIntervalApply@CXScaleManagerImp@@IAEXHAAUtagAREA@CXScaleManager@@H@Z ENDP ; CXScaleManagerImp::ItemIntervalApply
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\Dll_Load\XScaleManager.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\Dll_Load\XScaleManager.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\Dll_Load\XScaleManager.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\Dll_Load\XScaleManager.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\Dll_Load\XScaleManager.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?GetAreaFromDRI_Copy@CXScaleManagerImp@@IAEXHHAAUtagAREA@CXScaleManager@@@Z
_TEXT	SEGMENT
_p_nColumn$ = 8						; size = 4
_nDRI$ = 12						; size = 4
tv455 = 16						; size = 4
_area$ = 16						; size = 4
?GetAreaFromDRI_Copy@CXScaleManagerImp@@IAEXHHAAUtagAREA@CXScaleManager@@@Z PROC ; CXScaleManagerImp::GetAreaFromDRI_Copy, COMDAT
; _this$ = ecx

; 3254 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b 75 10	 mov	 esi, DWORD PTR _area$[ebp]
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx

; 3255 : 	// on View
; 3256 : 	if( m_nDRI_Start_Cur <= nDRI && nDRI <= m_nDRI_End_Cur + 1)		// (2009/3/2 - Seung-Won, Bae) +1 for right of Last Candle

  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR _nDRI$[ebp]
  0000d	8b 57 28	 mov	 edx, DWORD PTR [edi+40]
  00010	3b d1		 cmp	 edx, ecx
  00012	7f 39		 jg	 SHORT $LN37@GetAreaFro
  00014	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  00017	40		 inc	 eax
  00018	3b c8		 cmp	 ecx, eax
  0001a	7f 31		 jg	 SHORT $LN37@GetAreaFro

; 3258 : 		m_pAReturn = m_blAreafDRI[ p_nColumn].GetAt(nDRI - m_nDRI_Start_Cur);

  0001c	2b ca		 sub	 ecx, edx
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 215  : 	T*	GetAt( int nIndex)	{	return ( T*)GetAtUNK( nIndex);	}

  0001e	51		 push	 ecx
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 3258 : 		m_pAReturn = m_blAreafDRI[ p_nColumn].GetAt(nDRI - m_nDRI_Start_Cur);

  0001f	6b 4d 08 34	 imul	 ecx, DWORD PTR _p_nColumn$[ebp], 52
  00023	81 c1 88 03 00
	00		 add	 ecx, 904		; 00000388H
  00029	03 cf		 add	 ecx, edi
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 215  : 	T*	GetAt( int nIndex)	{	return ( T*)GetAtUNK( nIndex);	}

  0002b	e8 00 00 00 00	 call	 ?GetAtUNK@CDataBlockListUNK@@QAEPAXH@Z ; CDataBlockListUNK::GetAtUNK
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 3258 : 		m_pAReturn = m_blAreafDRI[ p_nColumn].GetAt(nDRI - m_nDRI_Start_Cur);

  00030	89 47 64	 mov	 DWORD PTR [edi+100], eax

; 3259 : 		if( m_pAReturn) area = *m_pAReturn;

  00033	85 c0		 test	 eax, eax
  00035	0f 84 b9 01 00
	00		 je	 $LN32@GetAreaFro
  0003b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003d	89 0e		 mov	 DWORD PTR [esi], ecx
  0003f	66 8b 40 04	 mov	 ax, WORD PTR [eax+4]
  00043	5f		 pop	 edi
  00044	66 89 46 04	 mov	 WORD PTR [esi+4], ax

; 3294 : }

  00048	5e		 pop	 esi
  00049	5d		 pop	 ebp
  0004a	c2 0c 00	 ret	 12			; 0000000cH
$LN37@GetAreaFro:

; 3260 : 		return;
; 3261 : 	}
; 3262 : 
; 3263 : 	// left on view.
; 3264 : 	int nDRI_Gap = 0;
; 3265 : 	if( nDRI < m_nDRI_Start_Cur)

  0004d	6b 45 08 34	 imul	 eax, DWORD PTR _p_nColumn$[ebp], 52
  00051	05 88 03 00 00	 add	 eax, 904		; 00000388H
  00056	03 c7		 add	 eax, edi
  00058	89 45 10	 mov	 DWORD PTR tv455[ebp], eax
  0005b	3b ca		 cmp	 ecx, edx
  0005d	7d 28		 jge	 SHORT $LN4@GetAreaFro
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 215  : 	T*	GetAt( int nIndex)	{	return ( T*)GetAtUNK( nIndex);	}

  0005f	6a 00		 push	 0
  00061	8b c8		 mov	 ecx, eax
  00063	e8 00 00 00 00	 call	 ?GetAtUNK@CDataBlockListUNK@@QAEPAXH@Z ; CDataBlockListUNK::GetAtUNK
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 3267 : 		m_pAReturn = m_blAreafDRI[ p_nColumn].GetAt( 0);

  00068	89 47 64	 mov	 DWORD PTR [edi+100], eax

; 3268 : 		if( m_pAReturn) area = *m_pAReturn;

  0006b	85 c0		 test	 eax, eax
  0006d	74 0c		 je	 SHORT $LN6@GetAreaFro
  0006f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00071	89 0e		 mov	 DWORD PTR [esi], ecx
  00073	66 8b 40 04	 mov	 ax, WORD PTR [eax+4]
  00077	66 89 46 04	 mov	 WORD PTR [esi+4], ax
$LN6@GetAreaFro:

; 3269 : 
; 3270 : 		nDRI_Gap = m_nDRI_Start_Cur - nDRI;

  0007b	8b 57 28	 mov	 edx, DWORD PTR [edi+40]
  0007e	8b ca		 mov	 ecx, edx
  00080	8b 45 0c	 mov	 eax, DWORD PTR _nDRI$[ebp]
  00083	2b c8		 sub	 ecx, eax

; 3271 : 	}

  00085	eb 2b		 jmp	 SHORT $LN5@GetAreaFro
$LN4@GetAreaFro:

; 3275 : 		m_pAReturn = m_blAreafDRI[ p_nColumn].GetAt( m_nDrawCount_Cur - 1);

  00087	8b 47 30	 mov	 eax, DWORD PTR [edi+48]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 215  : 	T*	GetAt( int nIndex)	{	return ( T*)GetAtUNK( nIndex);	}

  0008a	8b 4d 10	 mov	 ecx, DWORD PTR tv455[ebp]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 3275 : 		m_pAReturn = m_blAreafDRI[ p_nColumn].GetAt( m_nDrawCount_Cur - 1);

  0008d	48		 dec	 eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 215  : 	T*	GetAt( int nIndex)	{	return ( T*)GetAtUNK( nIndex);	}

  0008e	50		 push	 eax
  0008f	e8 00 00 00 00	 call	 ?GetAtUNK@CDataBlockListUNK@@QAEPAXH@Z ; CDataBlockListUNK::GetAtUNK
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 3275 : 		m_pAReturn = m_blAreafDRI[ p_nColumn].GetAt( m_nDrawCount_Cur - 1);

  00094	89 47 64	 mov	 DWORD PTR [edi+100], eax

; 3276 : 		if( m_pAReturn) area = *m_pAReturn;

  00097	85 c0		 test	 eax, eax
  00099	74 0c		 je	 SHORT $LN7@GetAreaFro
  0009b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0009d	89 0e		 mov	 DWORD PTR [esi], ecx
  0009f	66 8b 40 04	 mov	 ax, WORD PTR [eax+4]
  000a3	66 89 46 04	 mov	 WORD PTR [esi+4], ax
$LN7@GetAreaFro:

; 3277 : 
; 3278 : 		nDRI_Gap = nDRI - m_nDRI_End_Cur;

  000a7	8b 45 0c	 mov	 eax, DWORD PTR _nDRI$[ebp]
  000aa	8b c8		 mov	 ecx, eax
  000ac	2b 4f 2c	 sub	 ecx, DWORD PTR [edi+44]
  000af	8b 57 28	 mov	 edx, DWORD PTR [edi+40]
$LN5@GetAreaFro:

; 3279 : 	}
; 3280 : 
; 3281 : 	double dGap = nDRI_Gap * m_daItemWidth[ p_nColumn];
; 3282 : 	if( dGap < SHRT_MIN) dGap = SHRT_MIN;

  000b2	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@c0e0000000000000
  000ba	66 0f 6e c1	 movd	 xmm0, ecx
  000be	8b 4d 08	 mov	 ecx, DWORD PTR _p_nColumn$[ebp]
  000c1	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  000c5	f2 0f 59 84 cf
	a8 01 00 00	 mulsd	 xmm0, QWORD PTR [edi+ecx*8+424]
  000ce	f2 0f 5f c8	 maxsd	 xmm1, xmm0

; 3283 : 	if( SHRT_MAX < dGap) dGap = SHRT_MAX;

  000d2	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@40dfffc000000000
  000da	f2 0f 5d c1	 minsd	 xmm0, xmm1

; 3284 : 	if( ( nDRI < m_nDRI_Start_Cur && !m_bReverse) || ( m_nDRI_End_Cur < nDRI && m_bReverse))

  000de	3b c2		 cmp	 eax, edx
  000e0	7d 06		 jge	 SHORT $LN38@GetAreaFro
  000e2	83 7f 0c 00	 cmp	 DWORD PTR [edi+12], 0
  000e6	74 13		 je	 SHORT $LN12@GetAreaFro
$LN38@GetAreaFro:
  000e8	39 47 2c	 cmp	 DWORD PTR [edi+44], eax
  000eb	0f 8d 98 00 00
	00		 jge	 $LN10@GetAreaFro
  000f1	83 7f 0c 00	 cmp	 DWORD PTR [edi+12], 0
  000f5	0f 84 8e 00 00
	00		 je	 $LN10@GetAreaFro
$LN12@GetAreaFro:

; 3285 : 	{
; 3286 : 		area.right = area.left + m_naItemWidth[ p_nColumn];

  000fb	0f b7 16	 movzx	 edx, WORD PTR [esi]

; 3287 : 		area.Offset( ROUND( -dGap));

  000fe	0f 28 c8	 movaps	 xmm1, xmm0
  00101	66 8b 84 8f 60
	03 00 00	 mov	 ax, WORD PTR [edi+ecx*4+864]
  00109	0f 57 0d 00 00
	00 00		 xorps	 xmm1, QWORD PTR __xmm@80000000000000008000000000000000
  00110	66 03 c2	 add	 ax, dx
  00113	66 0f 2f 0d 00
	00 00 00	 comisd	 xmm1, QWORD PTR __real@0000000000000000
  0011b	0f b7 d0	 movzx	 edx, ax
  0011e	66 89 46 04	 mov	 WORD PTR [esi+4], ax
  00122	76 0e		 jbe	 SHORT $LN15@GetAreaFro
  00124	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@3fe0000000000000
  0012c	f2 0f 5c c8	 subsd	 xmm1, xmm0
  00130	eb 08		 jmp	 SHORT $LN16@GetAreaFro
$LN15@GetAreaFro:
  00132	f2 0f 5c 0d 00
	00 00 00	 subsd	 xmm1, QWORD PTR __real@3fe0000000000000
$LN16@GetAreaFro:
  0013a	f2 0f 2c c1	 cvttsd2si eax, xmm1
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\Dll_Load\XScaleManager.h

; 79   : 			if( nX == SHRT_MIN || nX == SHRT_MAX)

  0013e	bf 00 80 ff ff	 mov	 edi, -32768		; ffff8000H
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 3287 : 		area.Offset( ROUND( -dGap));

  00143	0f b7 c8	 movzx	 ecx, ax
  00146	8b c1		 mov	 eax, ecx
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\Dll_Load\XScaleManager.h

; 79   : 			if( nX == SHRT_MIN || nX == SHRT_MAX)

  00148	66 3b cf	 cmp	 cx, di
  0014b	74 29		 je	 SHORT $LN28@GetAreaFro
  0014d	bf ff 7f 00 00	 mov	 edi, 32767		; 00007fffH
  00152	66 3b cf	 cmp	 cx, di
  00155	74 1f		 je	 SHORT $LN28@GetAreaFro

; 81   : 			else
; 82   : 			{
; 83   : 				left += nX;
; 84   : 				center += nX;

  00157	66 01 4e 02	 add	 WORD PTR [esi+2], cx

; 85   : 				right += nX;

  0015b	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
  0015e	0f b7 d0	 movzx	 edx, ax
  00161	0f b7 06	 movzx	 eax, WORD PTR [esi]
  00164	03 c1		 add	 eax, ecx
  00166	0f b7 c0	 movzx	 eax, ax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 3288 : 	}

  00169	66 89 06	 mov	 WORD PTR [esi], ax
  0016c	5f		 pop	 edi
  0016d	66 89 56 04	 mov	 WORD PTR [esi+4], dx

; 3294 : }

  00171	5e		 pop	 esi
  00172	5d		 pop	 ebp
  00173	c2 0c 00	 ret	 12			; 0000000cH
$LN28@GetAreaFro:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\Dll_Load\XScaleManager.h

; 80   : 				left = center = right = nX;

  00176	66 89 4e 02	 mov	 WORD PTR [esi+2], cx
  0017a	8b d0		 mov	 edx, eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 3288 : 	}

  0017c	66 89 06	 mov	 WORD PTR [esi], ax
  0017f	5f		 pop	 edi
  00180	66 89 56 04	 mov	 WORD PTR [esi+4], dx

; 3294 : }

  00184	5e		 pop	 esi
  00185	5d		 pop	 ebp
  00186	c2 0c 00	 ret	 12			; 0000000cH
$LN10@GetAreaFro:

; 3289 : 	else
; 3290 : 	{
; 3291 : 		area.left = area.right - m_naItemWidth[ p_nColumn];

  00189	0f b7 56 04	 movzx	 edx, WORD PTR [esi+4]
  0018d	66 8b c2	 mov	 ax, dx
  00190	66 2b 84 8f 60
	03 00 00	 sub	 ax, WORD PTR [edi+ecx*4+864]

; 3292 : 		area.Offset( ROUND( dGap));

  00198	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@0000000000000000
  001a0	0f b7 f8	 movzx	 edi, ax
  001a3	76 0a		 jbe	 SHORT $LN17@GetAreaFro
  001a5	f2 0f 58 05 00
	00 00 00	 addsd	 xmm0, QWORD PTR __real@3fe0000000000000
  001ad	eb 08		 jmp	 SHORT $LN18@GetAreaFro
$LN17@GetAreaFro:
  001af	f2 0f 5c 05 00
	00 00 00	 subsd	 xmm0, QWORD PTR __real@3fe0000000000000
$LN18@GetAreaFro:
  001b7	f2 0f 2c c0	 cvttsd2si eax, xmm0
  001bb	0f b7 c8	 movzx	 ecx, ax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\Dll_Load\XScaleManager.h

; 79   : 			if( nX == SHRT_MIN || nX == SHRT_MAX)

  001be	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H
  001c3	66 3b c8	 cmp	 cx, ax
  001c6	74 21		 je	 SHORT $LN33@GetAreaFro
  001c8	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  001cd	66 3b c8	 cmp	 cx, ax
  001d0	74 17		 je	 SHORT $LN33@GetAreaFro

; 81   : 			else
; 82   : 			{
; 83   : 				left += nX;
; 84   : 				center += nX;

  001d2	66 01 4e 02	 add	 WORD PTR [esi+2], cx
  001d6	8d 04 0f	 lea	 eax, DWORD PTR [edi+ecx]
  001d9	66 89 06	 mov	 WORD PTR [esi], ax

; 85   : 				right += nX;

  001dc	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
  001df	5f		 pop	 edi
  001e0	66 89 46 04	 mov	 WORD PTR [esi+4], ax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 3294 : }

  001e4	5e		 pop	 esi
  001e5	5d		 pop	 ebp
  001e6	c2 0c 00	 ret	 12			; 0000000cH
$LN33@GetAreaFro:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\Dll_Load\XScaleManager.h

; 80   : 				left = center = right = nX;

  001e9	66 89 4e 04	 mov	 WORD PTR [esi+4], cx
  001ed	66 89 4e 02	 mov	 WORD PTR [esi+2], cx
  001f1	66 89 0e	 mov	 WORD PTR [esi], cx
$LN32@GetAreaFro:
  001f4	5f		 pop	 edi
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 3294 : }

  001f5	5e		 pop	 esi
  001f6	5d		 pop	 ebp
  001f7	c2 0c 00	 ret	 12			; 0000000cH
?GetAreaFromDRI_Copy@CXScaleManagerImp@@IAEXHHAAUtagAREA@CXScaleManager@@@Z ENDP ; CXScaleManagerImp::GetAreaFromDRI_Copy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?Calc_ItemWidth@CXScaleManagerImp@@IAEXHHH@Z
_TEXT	SEGMENT
tv1599 = -36						; size = 8
tv1592 = -36						; size = 8
tv1579 = -36						; size = 8
tv1573 = -36						; size = 8
tv1551 = -36						; size = 8
tv1545 = -36						; size = 8
_nPreDrawCount$1$ = -32					; size = 4
__real@3ff0000000000000$1$ = -28			; size = 8
_nDrawCount$2$ = -24					; size = 4
_this$1$ = -20						; size = 4
__real@0000000000000000$1$ = -16			; size = 8
_nLeftDataOnRealArea$1$ = -12				; size = 4
tv1616 = -8						; size = 8
tv1610 = -8						; size = 8
_p_nColumn$ = 8						; size = 4
tv1464 = 12						; size = 4
$T1 = 12						; size = 4
_nOnOnePixel$1$ = 12					; size = 4
_nDrawCount$ = 12					; size = 4
_p_bMoreZoomIn$ = 16					; size = 4
?Calc_ItemWidth@CXScaleManagerImp@@IAEXHHH@Z PROC	; CXScaleManagerImp::Calc_ItemWidth, COMDAT
; _this$ = ecx

; 1273 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	53		 push	 ebx

; 1274 : 	int nPreDrawCount = m_nDrawCount_Cur;
; 1275 : 	if( nDrawCount < m_nMinDataCountOnOnePage) nDrawCount = m_nMinDataCountOnOnePage;
; 1276 : 	m_nDrawCount_Cur = nDrawCount;
; 1277 : 
; 1278 : 	// (2009/1/19 - Seung-Won, Bae) Do you know why do check after setting the draw count.
; 1279 : 	if( m_nScreenWidth_Cur[ p_nColumn] < 5) return;

  00007	8b 5d 08	 mov	 ebx, DWORD PTR _p_nColumn$[ebp]
  0000a	56		 push	 esi
  0000b	8b 75 0c	 mov	 esi, DWORD PTR _nDrawCount$[ebp]
  0000e	57		 push	 edi
  0000f	8b f9		 mov	 edi, ecx
  00011	89 7d ec	 mov	 DWORD PTR _this$1$[ebp], edi
  00014	8b 57 34	 mov	 edx, DWORD PTR [edi+52]
  00017	3b f2		 cmp	 esi, edx
  00019	8b 47 30	 mov	 eax, DWORD PTR [edi+48]
  0001c	0f 4c f2	 cmovl	 esi, edx
  0001f	89 45 e0	 mov	 DWORD PTR _nPreDrawCount$1$[ebp], eax
  00022	89 77 30	 mov	 DWORD PTR [edi+48], esi
  00025	8b 8c 9f 38 03
	00 00		 mov	 ecx, DWORD PTR [edi+ebx*4+824]
  0002c	89 75 e8	 mov	 DWORD PTR _nDrawCount$2$[ebp], esi
  0002f	83 f9 05	 cmp	 ecx, 5
  00032	0f 8c a4 03 00
	00		 jl	 $LN1@Calc_ItemW

; 1280 : 
; 1281 : 	// (2009/1/14 - Seung-Won, Bae) Support Pixel Arranging.
; 1282 : 	int nLeftDataOnRealArea = -1;
; 1283 : 	if( 1 == m_nCountOfBlockColumn && 1 < m_nScreenWidth_Cur[ p_nColumn] && m_nScreenWidth_Cur[ p_nColumn] < m_nDrawCount_Cur && !m_bWeightedVolume)

  00038	83 bf 2c 01 00
	00 01		 cmp	 DWORD PTR [edi+300], 1
  0003f	8b c6		 mov	 eax, esi
  00041	c7 45 f4 ff ff
	ff ff		 mov	 DWORD PTR _nLeftDataOnRealArea$1$[ebp], -1
  00048	89 55 0c	 mov	 DWORD PTR $T1[ebp], edx
  0004b	75 53		 jne	 SHORT $LN37@Calc_ItemW
  0004d	89 55 0c	 mov	 DWORD PTR $T1[ebp], edx
  00050	3b ce		 cmp	 ecx, esi
  00052	7d 4c		 jge	 SHORT $LN37@Calc_ItemW
  00054	83 7f 10 00	 cmp	 DWORD PTR [edi+16], 0
  00058	89 55 0c	 mov	 DWORD PTR $T1[ebp], edx
  0005b	8b d1		 mov	 edx, ecx
  0005d	75 43		 jne	 SHORT $LN4@Calc_ItemW

; 1284 : 	{
; 1285 : 		m_nScreenWidth_Cur[ p_nColumn]--;	// leave the one pixel for real area.

  0005f	8d 71 ff	 lea	 esi, DWORD PTR [ecx-1]
  00062	89 b4 9f 38 03
	00 00		 mov	 DWORD PTR [edi+ebx*4+824], esi

; 1286 : 		int nOnOnePixel = m_nDrawCount_Cur;

  00069	8b 47 30	 mov	 eax, DWORD PTR [edi+48]
  0006c	89 45 0c	 mov	 DWORD PTR _nOnOnePixel$1$[ebp], eax

; 1287 : 		if( 0 < m_nScreenWidth_Cur[ p_nColumn]) nOnOnePixel /= m_nScreenWidth_Cur[ p_nColumn];

  0006f	99		 cdq
  00070	f7 fe		 idiv	 esi

; 1288 : 		nOnOnePixel++;			// the number of max data count for one pixel.

  00072	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]

; 1289 : 		int nLeftDataCountOverAverage = m_nDrawCount_Cur % m_nScreenWidth_Cur[ p_nColumn];

  00075	8b 45 0c	 mov	 eax, DWORD PTR _nOnOnePixel$1$[ebp]
  00078	99		 cdq
  00079	f7 fe		 idiv	 esi
  0007b	8b 75 e8	 mov	 esi, DWORD PTR _nDrawCount$2$[ebp]

; 1290 : 		nLeftDataOnRealArea = nLeftDataCountOverAverage % nOnOnePixel + 1;

  0007e	8b c2		 mov	 eax, edx
  00080	99		 cdq
  00081	f7 f9		 idiv	 ecx

; 1291 : 		m_nDrawCount_Cur -= nLeftDataOnRealArea;

  00083	8b 45 0c	 mov	 eax, DWORD PTR _nOnOnePixel$1$[ebp]
  00086	8d 4a 01	 lea	 ecx, DWORD PTR [edx+1]
  00089	8b 57 34	 mov	 edx, DWORD PTR [edi+52]
  0008c	2b c1		 sub	 eax, ecx
  0008e	89 55 0c	 mov	 DWORD PTR $T1[ebp], edx
  00091	89 47 30	 mov	 DWORD PTR [edi+48], eax
  00094	8b 94 9f 38 03
	00 00		 mov	 edx, DWORD PTR [edi+ebx*4+824]
  0009b	89 4d f4	 mov	 DWORD PTR _nLeftDataOnRealArea$1$[ebp], ecx
  0009e	eb 02		 jmp	 SHORT $LN4@Calc_ItemW
$LN37@Calc_ItemW:

; 1292 : 	}
; 1293 : 
; 1294 : 	m_daItemWidth[ p_nColumn] = ( double)m_nScreenWidth_Cur[ p_nColumn] / ( double)max( m_nDrawCount_Cur, m_nMinDataCountOnOnePage);

  000a0	8b d1		 mov	 edx, ecx
$LN4@Calc_ItemW:
  000a2	3b 45 0c	 cmp	 eax, DWORD PTR $T1[ebp]
  000a5	66 0f 6e ca	 movd	 xmm1, edx
  000a9	0f 4e 45 0c	 cmovle	 eax, DWORD PTR $T1[ebp]
  000ad	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1

; 1295 : 
; 1296 : 	// (2009/1/14 - Seung-Won, Bae) Support Pixel Arranging.
; 1297 : 	if( 0 <= nLeftDataOnRealArea)

  000b1	8b 4d f4	 mov	 ecx, DWORD PTR _nLeftDataOnRealArea$1$[ebp]
  000b4	66 0f 6e c0	 movd	 xmm0, eax
  000b8	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  000bc	f2 0f 5e c8	 divsd	 xmm1, xmm0
  000c0	f2 0f 11 8c df
	a8 01 00 00	 movsd	 QWORD PTR [edi+ebx*8+424], xmm1
  000c9	85 c9		 test	 ecx, ecx
  000cb	78 12		 js	 SHORT $LN6@Calc_ItemW

; 1298 : 	{
; 1299 : 		m_nScreenWidth_Cur[ p_nColumn]++;

  000cd	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  000d0	89 84 9f 38 03
	00 00		 mov	 DWORD PTR [edi+ebx*4+824], eax

; 1300 : 		m_nDrawCount_Cur += nLeftDataOnRealArea;

  000d7	01 4f 30	 add	 DWORD PTR [edi+48], ecx

; 1301 : 	}

  000da	e9 55 02 00 00	 jmp	 $LN25@Calc_ItemW
$LN6@Calc_ItemW:

; 1302 : 	else	// Do not support fixed interval for small size then one pixel.
; 1303 : 	//    
; 1304 : 	if( 1 == m_nCountOfBlockColumn && m_bFixedInterval && !m_pIChartCtrl->IsWholeView())

  000df	83 bf 2c 01 00
	00 01		 cmp	 DWORD PTR [edi+300], 1
  000e6	0f 85 48 02 00
	00		 jne	 $LN25@Calc_ItemW
  000ec	83 7f 24 00	 cmp	 DWORD PTR [edi+36], 0
  000f0	0f 84 3e 02 00
	00		 je	 $LN25@Calc_ItemW
  000f6	8b 4f 50	 mov	 ecx, DWORD PTR [edi+80]
  000f9	8b 01		 mov	 eax, DWORD PTR [ecx]
  000fb	8b 40 50	 mov	 eax, DWORD PTR [eax+80]
  000fe	ff d0		 call	 eax
  00100	84 c0		 test	 al, al
  00102	0f 85 2c 02 00
	00		 jne	 $LN25@Calc_ItemW

; 1305 : 	{
; 1306 : 		if( 0 < m_daItemWidth[ p_nColumn] && m_daItemWidth[ p_nColumn] < 1)

  00108	f2 0f 10 8c df
	a8 01 00 00	 movsd	 xmm1, QWORD PTR [edi+ebx*8+424]
  00111	0f 57 db	 xorps	 xmm3, xmm3
  00114	66 0f 2f cb	 comisd	 xmm1, xmm3
  00118	f2 0f 10 15 00
	00 00 00	 movsd	 xmm2, QWORD PTR __real@3ff0000000000000
  00120	f2 0f 11 5d f0	 movsd	 QWORD PTR __real@0000000000000000$1$[ebp], xmm3
  00125	f2 0f 11 55 e4	 movsd	 QWORD PTR __real@3ff0000000000000$1$[ebp], xmm2
  0012a	76 3a		 jbe	 SHORT $LN9@Calc_ItemW
  0012c	66 0f 2f d1	 comisd	 xmm2, xmm1
  00130	76 34		 jbe	 SHORT $LN9@Calc_ItemW

; 1307 : 				m_daItemWidth[ p_nColumn] = 1.0 / ceil( 1 / m_daItemWidth[ p_nColumn]);

  00132	0f 28 c2	 movaps	 xmm0, xmm2
  00135	83 ec 08	 sub	 esp, 8
  00138	f2 0f 5e c1	 divsd	 xmm0, xmm1
  0013c	f2 0f 11 45 f8	 movsd	 QWORD PTR tv1616[ebp], xmm0
  00141	dd 45 f8	 fld	 QWORD PTR tv1616[ebp]
  00144	dd 1c 24	 fstp	 QWORD PTR [esp]
  00147	e8 00 00 00 00	 call	 _ceil
  0014c	f2 0f 10 55 e4	 movsd	 xmm2, QWORD PTR __real@3ff0000000000000$1$[ebp]
  00151	83 c4 08	 add	 esp, 8
  00154	f2 0f 10 5d f0	 movsd	 xmm3, QWORD PTR __real@0000000000000000$1$[ebp]
  00159	0f 28 ca	 movaps	 xmm1, xmm2
  0015c	dd 5d f8	 fstp	 QWORD PTR tv1610[ebp]
  0015f	f2 0f 5e 4d f8	 divsd	 xmm1, QWORD PTR tv1610[ebp]
  00164	eb 0c		 jmp	 SHORT $LN10@Calc_ItemW
$LN9@Calc_ItemW:

; 1308 : 		else	m_daItemWidth[ p_nColumn] = ( int)m_daItemWidth[ p_nColumn];

  00166	f2 0f 2c c1	 cvttsd2si eax, xmm1
  0016a	66 0f 6e c8	 movd	 xmm1, eax
  0016e	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1
$LN10@Calc_ItemW:

; 1309 : 		// (2009/1/8 - Seung-Won, Bae) Update Count and Start to avoid the right indent too large.
; 1310 : 		if( 0 < m_daItemWidth[ p_nColumn]) m_nDrawCount_Cur = ( int)( ( double)m_nScreenWidth_Cur[ p_nColumn] / m_daItemWidth[ p_nColumn]);

  00172	66 0f 2f cb	 comisd	 xmm1, xmm3
  00176	f2 0f 11 8c df
	a8 01 00 00	 movsd	 QWORD PTR [edi+ebx*8+424], xmm1
  0017f	76 18		 jbe	 SHORT $LN35@Calc_ItemW
  00181	66 0f 6e 84 9f
	38 03 00 00	 movd	 xmm0, DWORD PTR [edi+ebx*4+824]
  0018a	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  0018e	f2 0f 5e c1	 divsd	 xmm0, xmm1
  00192	f2 0f 2c c0	 cvttsd2si eax, xmm0
  00196	89 47 30	 mov	 DWORD PTR [edi+48], eax
$LN35@Calc_ItemW:

; 1311 : 
; 1312 : 		// (2009/1/8 - Seung-Won, Bae) Zoom More !
; 1313 : 		if( p_bMoreZoomIn && m_nDrawCount_Cur == nPreDrawCount && m_nDrawCount_Cur != nDrawCount)

  00199	83 7d 10 00	 cmp	 DWORD PTR _p_bMoreZoomIn$[ebp], 0
  0019d	0f 84 e0 00 00
	00		 je	 $LN21@Calc_ItemW
  001a3	8b 47 30	 mov	 eax, DWORD PTR [edi+48]
  001a6	3b 45 e0	 cmp	 eax, DWORD PTR _nPreDrawCount$1$[ebp]
  001a9	0f 85 d4 00 00
	00		 jne	 $LN21@Calc_ItemW
  001af	3b c6		 cmp	 eax, esi
  001b1	0f 84 cc 00 00
	00		 je	 $LN21@Calc_ItemW

; 1314 : 		{
; 1315 : 			if( m_nDrawCount_Cur < nDrawCount)

  001b7	f2 0f 10 8c df
	a8 01 00 00	 movsd	 xmm1, QWORD PTR [edi+ebx*8+424]
  001c0	7d 4e		 jge	 SHORT $LN13@Calc_ItemW

; 1316 : 			{
; 1317 : 				if( m_daItemWidth[ p_nColumn] < 2)		m_daItemWidth[ p_nColumn]--;

  001c2	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@4000000000000000
  001ca	66 0f 2f c1	 comisd	 xmm0, xmm1
  001ce	76 09		 jbe	 SHORT $LN15@Calc_ItemW
  001d0	f2 0f 5c ca	 subsd	 xmm1, xmm2
  001d4	e9 83 00 00 00	 jmp	 $LN17@Calc_ItemW
$LN15@Calc_ItemW:

; 1318 : 				else if( 0 < m_daItemWidth[ p_nColumn])	m_daItemWidth[ p_nColumn] = 1.0 / ( ceil( 1 / m_daItemWidth[ p_nColumn]) + 1);

  001d9	66 0f 2f cb	 comisd	 xmm1, xmm3
  001dd	0f 86 a0 00 00
	00		 jbe	 $LN21@Calc_ItemW
  001e3	0f 28 c2	 movaps	 xmm0, xmm2
  001e6	83 ec 08	 sub	 esp, 8
  001e9	f2 0f 5e c1	 divsd	 xmm0, xmm1
  001ed	f2 0f 11 45 dc	 movsd	 QWORD PTR tv1599[ebp], xmm0
  001f2	dd 45 dc	 fld	 QWORD PTR tv1599[ebp]
  001f5	dd 1c 24	 fstp	 QWORD PTR [esp]
  001f8	e8 00 00 00 00	 call	 _ceil
  001fd	f2 0f 10 55 e4	 movsd	 xmm2, QWORD PTR __real@3ff0000000000000$1$[ebp]
  00202	dd 5d dc	 fstp	 QWORD PTR tv1592[ebp]
  00205	f2 0f 10 45 dc	 movsd	 xmm0, QWORD PTR tv1592[ebp]
  0020a	f2 0f 58 c2	 addsd	 xmm0, xmm2

; 1319 : 			}

  0020e	eb 3d		 jmp	 SHORT $LN38@Calc_ItemW
$LN13@Calc_ItemW:

; 1320 : 			else
; 1321 : 			{
; 1322 : 				if( 1 <= m_daItemWidth[ p_nColumn])		m_daItemWidth[ p_nColumn]++;

  00210	66 0f 2f ca	 comisd	 xmm1, xmm2
  00214	72 06		 jb	 SHORT $LN18@Calc_ItemW
  00216	f2 0f 58 ca	 addsd	 xmm1, xmm2
  0021a	eb 40		 jmp	 SHORT $LN17@Calc_ItemW
$LN18@Calc_ItemW:

; 1323 : 				else if( 0 < m_daItemWidth[ p_nColumn])	m_daItemWidth[ p_nColumn] = 1.0 / ( ceil( 1 / m_daItemWidth[ p_nColumn]) - 1);

  0021c	66 0f 2f cb	 comisd	 xmm1, xmm3
  00220	76 61		 jbe	 SHORT $LN21@Calc_ItemW
  00222	0f 28 c2	 movaps	 xmm0, xmm2
  00225	83 ec 08	 sub	 esp, 8
  00228	f2 0f 5e c1	 divsd	 xmm0, xmm1
  0022c	f2 0f 11 45 dc	 movsd	 QWORD PTR tv1579[ebp], xmm0
  00231	dd 45 dc	 fld	 QWORD PTR tv1579[ebp]
  00234	dd 1c 24	 fstp	 QWORD PTR [esp]
  00237	e8 00 00 00 00	 call	 _ceil
  0023c	f2 0f 10 55 e4	 movsd	 xmm2, QWORD PTR __real@3ff0000000000000$1$[ebp]
  00241	dd 5d dc	 fstp	 QWORD PTR tv1573[ebp]
  00244	f2 0f 10 45 dc	 movsd	 xmm0, QWORD PTR tv1573[ebp]
  00249	f2 0f 5c c2	 subsd	 xmm0, xmm2
$LN38@Calc_ItemW:

; 1324 : 			}
; 1325 : 			// (2009/1/8 - Seung-Won, Bae) Update Count and Start to avoid the right indent too large.
; 1326 : 			if( 0 < m_daItemWidth[ p_nColumn]) m_nDrawCount_Cur = ( int)( ( double)m_nScreenWidth_Cur[ p_nColumn] / m_daItemWidth[ p_nColumn]);

  0024d	f2 0f 10 5d f0	 movsd	 xmm3, QWORD PTR __real@0000000000000000$1$[ebp]
  00252	0f 28 ca	 movaps	 xmm1, xmm2
  00255	83 c4 08	 add	 esp, 8
  00258	f2 0f 5e c8	 divsd	 xmm1, xmm0
$LN17@Calc_ItemW:
  0025c	66 0f 2f cb	 comisd	 xmm1, xmm3
  00260	f2 0f 11 8c df
	a8 01 00 00	 movsd	 QWORD PTR [edi+ebx*8+424], xmm1
  00269	76 18		 jbe	 SHORT $LN21@Calc_ItemW
  0026b	66 0f 6e 84 9f
	38 03 00 00	 movd	 xmm0, DWORD PTR [edi+ebx*4+824]
  00274	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00278	f2 0f 5e c1	 divsd	 xmm0, xmm1
  0027c	f2 0f 2c c0	 cvttsd2si eax, xmm0
  00280	89 47 30	 mov	 DWORD PTR [edi+48], eax
$LN21@Calc_ItemW:

; 1327 : 		}
; 1328 : 
; 1329 : 		if( m_nItemCount_Total < m_nDrawCount_Cur)

  00283	8b 4f 58	 mov	 ecx, DWORD PTR [edi+88]
  00286	3b 4f 30	 cmp	 ecx, DWORD PTR [edi+48]
  00289	0f 8d a5 00 00
	00		 jge	 $LN25@Calc_ItemW

; 1330 : 		{
; 1331 : 			m_nDrawCount_Cur = m_nItemCount_Total;
; 1332 : 			m_daItemWidth[ p_nColumn] = ( double)m_nScreenWidth_Cur[ p_nColumn] / ( double)max( m_nDrawCount_Cur, m_nMinDataCountOnOnePage);

  0028f	3b 4f 34	 cmp	 ecx, DWORD PTR [edi+52]
  00292	89 4f 30	 mov	 DWORD PTR [edi+48], ecx
  00295	0f 4e 4f 34	 cmovle	 ecx, DWORD PTR [edi+52]
  00299	66 0f 6e 8c 9f
	38 03 00 00	 movd	 xmm1, DWORD PTR [edi+ebx*4+824]
  002a2	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1
  002a6	66 0f 6e c1	 movd	 xmm0, ecx
  002aa	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  002ae	f2 0f 5e c8	 divsd	 xmm1, xmm0

; 1333 : 			if( 0 < m_daItemWidth[ p_nColumn] && m_daItemWidth[ p_nColumn] < 1)

  002b2	66 0f 2f cb	 comisd	 xmm1, xmm3
  002b6	f2 0f 11 8c df
	a8 01 00 00	 movsd	 QWORD PTR [edi+ebx*8+424], xmm1
  002bf	76 3f		 jbe	 SHORT $LN23@Calc_ItemW
  002c1	66 0f 2f d1	 comisd	 xmm2, xmm1
  002c5	76 39		 jbe	 SHORT $LN23@Calc_ItemW

; 1334 : 					m_daItemWidth[ p_nColumn] = 1.0 / ( ceil( 1 / m_daItemWidth[ p_nColumn]) - 1);

  002c7	0f 28 c2	 movaps	 xmm0, xmm2
  002ca	83 ec 08	 sub	 esp, 8
  002cd	f2 0f 5e c1	 divsd	 xmm0, xmm1
  002d1	f2 0f 11 45 dc	 movsd	 QWORD PTR tv1551[ebp], xmm0
  002d6	dd 45 dc	 fld	 QWORD PTR tv1551[ebp]
  002d9	dd 1c 24	 fstp	 QWORD PTR [esp]
  002dc	e8 00 00 00 00	 call	 _ceil
  002e1	f2 0f 10 4d e4	 movsd	 xmm1, QWORD PTR __real@3ff0000000000000$1$[ebp]
  002e6	83 c4 08	 add	 esp, 8
  002e9	f2 0f 10 5d f0	 movsd	 xmm3, QWORD PTR __real@0000000000000000$1$[ebp]
  002ee	dd 5d dc	 fstp	 QWORD PTR tv1545[ebp]
  002f1	f2 0f 10 45 dc	 movsd	 xmm0, QWORD PTR tv1545[ebp]
  002f6	f2 0f 5c c1	 subsd	 xmm0, xmm1
  002fa	f2 0f 5e c8	 divsd	 xmm1, xmm0
  002fe	eb 0d		 jmp	 SHORT $LN24@Calc_ItemW
$LN23@Calc_ItemW:

; 1335 : 			else	m_daItemWidth[ p_nColumn] = int( m_daItemWidth[ p_nColumn]) + 1;

  00300	f2 0f 2c c1	 cvttsd2si eax, xmm1
  00304	40		 inc	 eax
  00305	66 0f 6e c0	 movd	 xmm0, eax
  00309	f3 0f e6 c8	 cvtdq2pd xmm1, xmm0
$LN24@Calc_ItemW:

; 1336 : 			if( 0 < m_daItemWidth[ p_nColumn]) m_nDrawCount_Cur = ( int)( ( double)m_nScreenWidth_Cur[ p_nColumn] / m_daItemWidth[ p_nColumn]);

  0030d	66 0f 2f cb	 comisd	 xmm1, xmm3
  00311	f2 0f 11 8c df
	a8 01 00 00	 movsd	 QWORD PTR [edi+ebx*8+424], xmm1
  0031a	76 18		 jbe	 SHORT $LN25@Calc_ItemW
  0031c	66 0f 6e 84 9f
	38 03 00 00	 movd	 xmm0, DWORD PTR [edi+ebx*4+824]
  00325	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00329	f2 0f 5e c1	 divsd	 xmm0, xmm1
  0032d	f2 0f 2c c0	 cvttsd2si eax, xmm0
  00331	89 47 30	 mov	 DWORD PTR [edi+48], eax
$LN25@Calc_ItemW:

; 1337 : 		}
; 1338 : 	}
; 1339 : 
; 1340 : 	m_naItemWidth[ p_nColumn] = (int)m_daItemWidth[ p_nColumn];

  00334	f2 0f 2c 84 df
	a8 01 00 00	 cvttsd2si eax, QWORD PTR [edi+ebx*8+424]

; 1341 : 	m_nScreenRight_Cur[ p_nColumn] = m_nScreenLeft_Cur[ p_nColumn] + m_nScreenWidth_Cur[ p_nColumn];

  0033d	8b 8c 9f f8 01
	00 00		 mov	 ecx, DWORD PTR [edi+ebx*4+504]
  00344	8b 55 08	 mov	 edx, DWORD PTR _p_nColumn$[ebp]
  00347	89 4d 0c	 mov	 DWORD PTR tv1464[ebp], ecx
  0034a	89 84 9f 60 03
	00 00		 mov	 DWORD PTR [edi+ebx*4+864], eax
  00351	8b 9c 9f 38 03
	00 00		 mov	 ebx, DWORD PTR [edi+ebx*4+824]

; 1342 : 	if(m_bReverse == FALSE)

  00358	8b 45 ec	 mov	 eax, DWORD PTR _this$1$[ebp]
  0035b	03 d9		 add	 ebx, ecx
  0035d	89 9c 97 20 02
	00 00		 mov	 DWORD PTR [edi+edx*4+544], ebx
  00364	8b 77 0c	 mov	 esi, DWORD PTR [edi+12]

; 1343 : 	{
; 1344 : 		m_naScreenStart_Cur[ p_nColumn] = m_nScreenLeft_Cur[ p_nColumn];
; 1345 : 		m_naScreenEnd_Cur[ p_nColumn] = m_nScreenRight_Cur[ p_nColumn];
; 1346 : 
; 1347 : 		m_nScreenStartiM_Cur[ p_nColumn] = m_nScreenLeftiM_Cur[ p_nColumn];
; 1348 : 		m_nScreenEndiM_Cur[ p_nColumn] = m_nScreenRightiM_Cur[ p_nColumn];
; 1349 : 	}
; 1350 : 	else
; 1351 : 	{
; 1352 : 		m_naScreenStart_Cur[ p_nColumn] = m_nScreenRight_Cur[ p_nColumn];
; 1353 : 		m_naScreenEnd_Cur[ p_nColumn] = m_nScreenLeft_Cur[ p_nColumn];
; 1354 : 
; 1355 : 		m_nScreenStartiM_Cur[ p_nColumn] = m_nScreenRightiM_Cur[ p_nColumn];
; 1356 : 		m_nScreenEndiM_Cur[ p_nColumn] = m_nScreenLeftiM_Cur[ p_nColumn];
; 1357 : 	}
; 1358 : 
; 1359 : 	m_nDRI_Start_Cur =  m_nDRI_End_Cur - m_nDrawCount_Cur + 1;

  00367	85 f6		 test	 esi, esi
  00369	8b bc 97 70 02
	00 00		 mov	 edi, DWORD PTR [edi+edx*4+624]
  00370	8b 84 90 48 02
	00 00		 mov	 eax, DWORD PTR [eax+edx*4+584]
  00377	8b d3		 mov	 edx, ebx
  00379	8b 75 08	 mov	 esi, DWORD PTR _p_nColumn$[ebp]
  0037c	0f 45 d1	 cmovne	 edx, ecx
  0037f	8b c8		 mov	 ecx, eax
  00381	0f 45 cf	 cmovne	 ecx, edi
  00384	0f 45 f8	 cmovne	 edi, eax
  00387	8b 45 0c	 mov	 eax, DWORD PTR tv1464[ebp]
  0038a	0f 45 c3	 cmovne	 eax, ebx
  0038d	8b 5d ec	 mov	 ebx, DWORD PTR _this$1$[ebp]
  00390	89 84 b3 98 02
	00 00		 mov	 DWORD PTR [ebx+esi*4+664], eax
  00397	89 94 b3 c0 02
	00 00		 mov	 DWORD PTR [ebx+esi*4+704], edx
  0039e	89 8c b3 e8 02
	00 00		 mov	 DWORD PTR [ebx+esi*4+744], ecx
  003a5	89 bc b3 10 03
	00 00		 mov	 DWORD PTR [ebx+esi*4+784], edi
  003ac	8b 43 2c	 mov	 eax, DWORD PTR [ebx+44]
  003af	8b 4b 30	 mov	 ecx, DWORD PTR [ebx+48]
  003b2	2b c1		 sub	 eax, ecx
  003b4	83 c0 01	 add	 eax, 1
  003b7	89 43 28	 mov	 DWORD PTR [ebx+40], eax

; 1360 : 	if( m_nDRI_Start_Cur < 0)

  003ba	79 0d		 jns	 SHORT $LN28@Calc_ItemW

; 1361 : 	{
; 1362 : 		m_nDRI_Start_Cur = 0;
; 1363 : 		m_nDRI_End_Cur = m_nDRI_Start_Cur + m_nDrawCount_Cur - 1;

  003bc	8d 41 ff	 lea	 eax, DWORD PTR [ecx-1]
  003bf	c7 43 28 00 00
	00 00		 mov	 DWORD PTR [ebx+40], 0
  003c6	89 43 2c	 mov	 DWORD PTR [ebx+44], eax
$LN28@Calc_ItemW:

; 1364 : 	}
; 1365 : 
; 1366 : 	m_bWholeViewPre = m_pIChartCtrl->IsWholeView();

  003c9	8b 4b 50	 mov	 ecx, DWORD PTR [ebx+80]
  003cc	8b 01		 mov	 eax, DWORD PTR [ecx]
  003ce	8b 40 50	 mov	 eax, DWORD PTR [eax+80]
  003d1	ff d0		 call	 eax
  003d3	0f b6 c0	 movzx	 eax, al
  003d6	89 83 f8 00 00
	00		 mov	 DWORD PTR [ebx+248], eax
$LN1@Calc_ItemW:

; 1367 : }

  003dc	5f		 pop	 edi
  003dd	5e		 pop	 esi
  003de	5b		 pop	 ebx
  003df	8b e5		 mov	 esp, ebp
  003e1	5d		 pop	 ebp
  003e2	c2 0c 00	 ret	 12			; 0000000cH
?Calc_ItemWidth@CXScaleManagerImp@@IAEXHHH@Z ENDP	; CXScaleManagerImp::Calc_ItemWidth
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\Dll_Load\XScaleManager.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\Dll_Load\XScaleManager.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\Dll_Load\XScaleManager.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\Dll_Load\XScaleManager.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\Dll_Load\XScaleManager.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\Dll_Load\XScaleManager.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\Dll_Load\XScaleManager.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\Dll_Load\XScaleManager.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?Calc_AREAofColumn@CXScaleManagerImp@@IAEXH@Z
_TEXT	SEGMENT
_dLeft_Cur$1$ = -84					; size = 8
_dLeft_Cur$1$ = -84					; size = 8
_dLeft_Cur$1$ = -76					; size = 8
_dLeft_Cur$1$ = -76					; size = 8
_dVolumeFactor$1$ = -76					; size = 8
_dVolume$1$ = -68					; size = 8
_dVolume_Total$1$ = -60					; size = 8
_Item$ = -60						; size = 6
_Item$ = -60						; size = 6
_Item$ = -60						; size = 6
_Item$ = -60						; size = 6
_Item$ = -60						; size = 6
_nDRI$1$ = -52						; size = 4
tv2969 = -52						; size = 4
tv2968 = -52						; size = 4
tv2967 = -52						; size = 4
tv2966 = -52						; size = 4
_area$4$sroa$1659$1$ = -48				; size = 4
_area$3$sroa$1658$1$ = -48				; size = 4
_pblDTIfDRI$1$ = -48					; size = 4
_nDRI$1$ = -48						; size = 4
_nDRI_Next$1$ = -48					; size = 4
_nDTI_Start_Cur$1$ = -48				; size = 4
_nPreAreaCount$1$ = -48					; size = 4
_nRealDRIEnd$1$ = -48					; size = 4
tv2937 = -48						; size = 4
_pXScaleGridTime$5 = -48				; size = 4
_nDTI_End_Cur$1$ = -44					; size = 4
_nRealDRIEnd$1$ = -44					; size = 4
_nRealDRIEnd$1$ = -44					; size = 4
_nVolumeCount$1$ = -44					; size = 4
_nDRICount$1$ = -40					; size = 4
_area$6 = -40						; size = 6
_area$2$sroa$1657$1$ = -32				; size = 4
_nRealDRIEnd$1$ = -32					; size = 4
_area_Next$7 = -32					; size = 6
_area$1$sroa$1656$1$ = -24				; size = 4
_nNoVolumeCount$1$ = -24				; size = 4
tv2939 = -24						; size = 4
_nDRI$1$ = -20						; size = 4
_bNoVolume$1$ = -20					; size = 4
_nDTI_End_Cur$1$ = -20					; size = 4
_nDRI$1$ = -16						; size = 4
_nDRI$1$ = -16						; size = 4
_pblDRIfDTI$1$ = -16					; size = 4
_nPreDTI$1$ = -12					; size = 4
_nDRI_Start$2$ = -12					; size = 4
_nDTI_Start_Cur$1$ = -12				; size = 4
_pListVolume$1$ = -8					; size = 4
_nRQ$1$ = -4						; size = 4
_pblDTIfDRI$1$ = -4					; size = 4
_p_nColumn$ = 8						; size = 4
?Calc_AREAofColumn@CXScaleManagerImp@@IAEXH@Z PROC	; CXScaleManagerImp::Calc_AREAofColumn, COMDAT
; _this$ = ecx

; 2942 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 2943 : 	// (2009/2/19 - Seung-Won, Bae) Check No area.
; 2944 : 	if( m_nScreenWidth_Cur[ p_nColumn] < 1) return;

  00008	8b 75 08	 mov	 esi, DWORD PTR _p_nColumn$[ebp]
  0000b	57		 push	 edi
  0000c	8b f9		 mov	 edi, ecx
  0000e	83 bc b7 38 03
	00 00 01	 cmp	 DWORD PTR [edi+esi*4+824], 1
  00016	0f 8c e1 0b 00
	00		 jl	 $LN21@Calc_AREAo

; 2945 : 
; 2946 : 	//	Calc_Area_AreafDRI();
; 2947 : 	//  DRI     .
; 2948 : 	// (2009/6/24 - Seung-Won, Bae) Support volume weighted x scale for whole view. (not special chart)
; 2949 : 	if( ( m_bWeightedVolume && 0 <= m_minScaleInterval_nRQ && !m_pIChartCtrl->IsRunningOneChart()))

  0001c	83 7f 10 00	 cmp	 DWORD PTR [edi+16], 0
  00020	0f 84 ce 05 00
	00		 je	 $LN27@Calc_AREAo
  00026	83 bf ec 00 00
	00 00		 cmp	 DWORD PTR [edi+236], 0
  0002d	0f 8c c1 05 00
	00		 jl	 $LN27@Calc_AREAo
  00033	8b 4f 50	 mov	 ecx, DWORD PTR [edi+80]
  00036	8b 01		 mov	 eax, DWORD PTR [ecx]
  00038	ff 90 38 01 00
	00		 call	 DWORD PTR [eax+312]
  0003e	85 c0		 test	 eax, eax
  00040	0f 85 ae 05 00
	00		 jne	 $LN27@Calc_AREAo

; 2950 : 	{
; 2951 : 		CPacket* pVolumePacket = m_pifaRQ[ m_minScaleInterval_nRQ]->pPacketRQ->GetPacketList()->GetBaseData( _MTEXT( C0_VOLUME));

  00046	a1 54 00 00 00	 mov	 eax, DWORD PTR ?g_iMetaTable@@3VIMetaTable@@A+84
  0004b	6a 01		 push	 1
  0004d	51		 push	 ecx
  0004e	8b cc		 mov	 ecx, esp
  00050	ff 70 1c	 push	 DWORD PTR [eax+28]
  00053	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  00059	8b 8f ec 00 00
	00		 mov	 ecx, DWORD PTR [edi+236]
  0005f	8b 87 8c 00 00
	00		 mov	 eax, DWORD PTR [edi+140]
  00065	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
  00068	8b 08		 mov	 ecx, DWORD PTR [eax]
  0006a	8b 49 14	 mov	 ecx, DWORD PTR [ecx+20]
  0006d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetBaseData@CPacketList@@QAEPAVCPacket@@V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@_N@Z

; 2952 : 		if( !pVolumePacket) return;

  00073	85 c0		 test	 eax, eax
  00075	0f 84 82 0b 00
	00		 je	 $LN21@Calc_AREAo

; 2953 : 		CList< double, double>* pListVolume = pVolumePacket->GetnumericDataList();

  0007b	8b c8		 mov	 ecx, eax
  0007d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetnumericDataList@CPacket@@QAEPAV?$CList@NN@@XZ
  00083	89 45 f8	 mov	 DWORD PTR _pListVolume$1$[ebp], eax

; 2954 : 		if( !pListVolume) return;

  00086	85 c0		 test	 eax, eax
  00088	0f 84 6f 0b 00
	00		 je	 $LN21@Calc_AREAo

; 2955 : 		CDataBlockList<int> *pblDTIfDRI = m_pblaDTIfDRI[ m_minScaleInterval_nRQ];

  0008e	8b 97 ec 00 00
	00		 mov	 edx, DWORD PTR [edi+236]
  00094	8b 8f a8 00 00
	00		 mov	 ecx, DWORD PTR [edi+168]

; 2956 : 		CDataBlockList<int> *pblDRIfDTI = m_pblaDRIfDTI[ m_minScaleInterval_nRQ];
; 2957 : 		int nDTI_Start_Cur_Org = 0, nDTI_End_Cur_Org = 0;
; 2958 : 		int nDTI_Start_Cur	= GetDTIFromDRI_AbleRange( pblDTIfDRI, m_nDRI_Start_Cur, &nDTI_Start_Cur_Org);

  0009a	8b 5f 28	 mov	 ebx, DWORD PTR [edi+40]
  0009d	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  000a0	8b 8f a0 00 00
	00		 mov	 ecx, DWORD PTR [edi+160]
  000a6	89 45 fc	 mov	 DWORD PTR _pblDTIfDRI$1$[ebp], eax
  000a9	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  000ac	89 45 f0	 mov	 DWORD PTR _pblDRIfDTI$1$[ebp], eax

; 1435 : 	if( !pblDTIfDRI) return -1;

  000af	8b 45 fc	 mov	 eax, DWORD PTR _pblDTIfDRI$1$[ebp]
  000b2	85 c0		 test	 eax, eax
  000b4	74 2f		 je	 SHORT $LN109@Calc_AREAo

; 1436 : 
; 1437 : 	int nItemCount = pblDTIfDRI->GetItemCount();

  000b6	8b c8		 mov	 ecx, eax
  000b8	e8 00 00 00 00	 call	 ?GetItemCount@CDataBlockListUNK@@QAEHXZ ; CDataBlockListUNK::GetItemCount

; 1438 : 	if( nItemCount == 0) return -1;

  000bd	85 c0		 test	 eax, eax
  000bf	74 24		 je	 SHORT $LN109@Calc_AREAo

; 1439 : 
; 1440 : 	if( 0 <= nDRI && nDRI < nItemCount)

  000c1	85 db		 test	 ebx, ebx
  000c3	0f 88 e7 00 00
	00		 js	 $LN106@Calc_AREAo
  000c9	3b d8		 cmp	 ebx, eax
  000cb	0f 8d e7 00 00
	00		 jge	 $LN282@Calc_AREAo
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 215  : 	T*	GetAt( int nIndex)	{	return ( T*)GetAtUNK( nIndex);	}

  000d1	8b 4d fc	 mov	 ecx, DWORD PTR _pblDTIfDRI$1$[ebp]
  000d4	53		 push	 ebx
  000d5	e8 00 00 00 00	 call	 ?GetAtUNK@CDataBlockListUNK@@QAEPAXH@Z ; CDataBlockListUNK::GetAtUNK
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 1442 : 		m_pIReturn = pblDTIfDRI->GetAt(nDRI);

  000da	89 47 60	 mov	 DWORD PTR [edi+96], eax

; 1443 : 		if( m_pIReturn) return *m_pIReturn;

  000dd	85 c0		 test	 eax, eax
  000df	0f 85 e8 00 00
	00		 jne	 $LN101@Calc_AREAo
$LN109@Calc_AREAo:

; 1470 : 	if( nDTI == -1)	nDTI = 0;

  000e5	83 cb ff	 or	 ebx, -1
$LN283@Calc_AREAo:
  000e8	33 c9		 xor	 ecx, ecx
$LN98@Calc_AREAo:

; 2956 : 		CDataBlockList<int> *pblDRIfDTI = m_pblaDRIfDTI[ m_minScaleInterval_nRQ];
; 2957 : 		int nDTI_Start_Cur_Org = 0, nDTI_End_Cur_Org = 0;
; 2958 : 		int nDTI_Start_Cur	= GetDTIFromDRI_AbleRange( pblDTIfDRI, m_nDRI_Start_Cur, &nDTI_Start_Cur_Org);

  000ea	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH
  000ef	2b c1		 sub	 eax, ecx
  000f1	83 f9 ff	 cmp	 ecx, -1
  000f4	0f 4d c1	 cmovge	 eax, ecx
  000f7	89 45 f4	 mov	 DWORD PTR _nDTI_Start_Cur$1$[ebp], eax

; 2959 : 		int nDTI_End_Cur	= GetDTIFromDRI_AbleRange( pblDTIfDRI, m_nDRI_End_Cur, &nDTI_End_Cur_Org);

  000fa	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  000fd	89 45 d0	 mov	 DWORD PTR _nDRI$1$[ebp], eax

; 1435 : 	if( !pblDTIfDRI) return -1;

  00100	8b 45 fc	 mov	 eax, DWORD PTR _pblDTIfDRI$1$[ebp]
  00103	85 c0		 test	 eax, eax
  00105	74 34		 je	 SHORT $LN128@Calc_AREAo

; 1436 : 
; 1437 : 	int nItemCount = pblDTIfDRI->GetItemCount();

  00107	8b c8		 mov	 ecx, eax
  00109	e8 00 00 00 00	 call	 ?GetItemCount@CDataBlockListUNK@@QAEHXZ ; CDataBlockListUNK::GetItemCount
  0010e	8b c8		 mov	 ecx, eax

; 1438 : 	if( nItemCount == 0) return -1;

  00110	85 c9		 test	 ecx, ecx
  00112	74 27		 je	 SHORT $LN128@Calc_AREAo

; 1439 : 
; 1440 : 	if( 0 <= nDRI && nDRI < nItemCount)

  00114	8b 45 d0	 mov	 eax, DWORD PTR _nDRI$1$[ebp]
  00117	85 c0		 test	 eax, eax
  00119	0f 88 c0 00 00
	00		 js	 $LN125@Calc_AREAo
  0011f	3b c1		 cmp	 eax, ecx
  00121	0f 8d c0 00 00
	00		 jge	 $LN281@Calc_AREAo
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 215  : 	T*	GetAt( int nIndex)	{	return ( T*)GetAtUNK( nIndex);	}

  00127	8b 4d fc	 mov	 ecx, DWORD PTR _pblDTIfDRI$1$[ebp]
  0012a	50		 push	 eax
  0012b	e8 00 00 00 00	 call	 ?GetAtUNK@CDataBlockListUNK@@QAEPAXH@Z ; CDataBlockListUNK::GetAtUNK
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 1442 : 		m_pIReturn = pblDTIfDRI->GetAt(nDRI);

  00130	89 47 60	 mov	 DWORD PTR [edi+96], eax

; 1443 : 		if( m_pIReturn) return *m_pIReturn;

  00133	85 c0		 test	 eax, eax
  00135	0f 85 c3 00 00
	00		 jne	 $LN120@Calc_AREAo
$LN128@Calc_AREAo:

; 1470 : 	if( nDTI == -1)	nDTI = 0;

  0013b	83 c8 ff	 or	 eax, -1
$LN284@Calc_AREAo:
  0013e	33 d2		 xor	 edx, edx
$LN117@Calc_AREAo:

; 2959 : 		int nDTI_End_Cur	= GetDTIFromDRI_AbleRange( pblDTIfDRI, m_nDRI_End_Cur, &nDTI_End_Cur_Org);

  00140	b9 fd ff ff ff	 mov	 ecx, -3			; fffffffdH
  00145	0f 57 c0	 xorps	 xmm0, xmm0
  00148	2b ca		 sub	 ecx, edx

; 2960 : 		double dVolumeFactor = 0.;

  0014a	f2 0f 11 45 bc	 movsd	 QWORD PTR _dVolume$1$[ebp], xmm0
  0014f	83 fa ff	 cmp	 edx, -1
  00152	f2 0f 11 45 b4	 movsd	 QWORD PTR _dVolumeFactor$1$[ebp], xmm0
  00157	0f 4d ca	 cmovge	 ecx, edx
  0015a	89 4d ec	 mov	 DWORD PTR _nDTI_End_Cur$1$[ebp], ecx

; 2961 : 
; 2962 : 		// Check there is any DTI in view.
; 2963 : 		POSITION posVolume = NULL;
; 2964 : 		if( !( nDTI_Start_Cur_Org < -1			// Graph is gone to left.

  0015d	83 fb ff	 cmp	 ebx, -1
  00160	0f 8c 28 01 00
	00		 jl	 $LN38@Calc_AREAo
  00166	83 f8 ff	 cmp	 eax, -1
  00169	0f 84 1f 01 00
	00		 je	 $LN38@Calc_AREAo

; 2969 : 
; 2970 : 			// Sum of all volume in view.
; 2971 : 			posVolume = pListVolume->FindIndex( nDTI_Start_Cur);

  0016f	ff 75 f4	 push	 DWORD PTR _nDTI_Start_Cur$1$[ebp]
  00172	8b 4d f8	 mov	 ecx, DWORD PTR _pListVolume$1$[ebp]
  00175	33 db		 xor	 ebx, ebx
  00177	f2 0f 11 45 c4	 movsd	 QWORD PTR _dVolume_Total$1$[ebp], xmm0
  0017c	89 5d e8	 mov	 DWORD PTR _nNoVolumeCount$1$[ebp], ebx
  0017f	e8 00 00 00 00	 call	 ?FindIndex@?$CList@NN@@QBEPAU__POSITION@@H@Z ; CList<double,double>::FindIndex

; 2972 : 			for( int nDTI = nDTI_Start_Cur; nDTI <= nDTI_End_Cur; nDTI++)

  00184	8b 55 ec	 mov	 edx, DWORD PTR _nDTI_End_Cur$1$[ebp]
  00187	8b c8		 mov	 ecx, eax
  00189	8b 45 f4	 mov	 eax, DWORD PTR _nDTI_Start_Cur$1$[ebp]
  0018c	3b c2		 cmp	 eax, edx
  0018e	0f 8f 88 00 00
	00		 jg	 $LN3@Calc_AREAo

; 2965 : 				|| -1 == nDTI_End_Cur_Org))		// Graph is gone to right.
; 2966 : 		{
; 2967 : 			double dWidth_Total = 0, dVolume_Total = 0;
; 2968 : 			int nNoVolumeCount = 0;

  00194	2b d0		 sub	 edx, eax
  00196	42		 inc	 edx
$LL4@Calc_AREAo:

; 2974 : 				if( posVolume)	dVolume_Total += pListVolume->GetNext( posVolume);

  00197	85 c9		 test	 ecx, ecx
  00199	74 75		 je	 SHORT $LN32@Calc_AREAo
  0019b	f2 0f 10 45 c4	 movsd	 xmm0, QWORD PTR _dVolume_Total$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 811  : 	{ CNode* pNode = (CNode*) rPosition;

  001a0	8b c1		 mov	 eax, ecx

; 812  : 		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 813  : 		rPosition = (POSITION) pNode->pNext;

  001a2	8b 09		 mov	 ecx, DWORD PTR [ecx]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 2974 : 				if( posVolume)	dVolume_Total += pListVolume->GetNext( posVolume);

  001a4	f2 0f 58 40 08	 addsd	 xmm0, QWORD PTR [eax+8]
  001a9	f2 0f 11 45 c4	 movsd	 QWORD PTR _dVolume_Total$1$[ebp], xmm0
  001ae	eb 61		 jmp	 SHORT $LN2@Calc_AREAo
$LN106@Calc_AREAo:

; 1446 : 	if( nItemCount <= nDRI)

  001b0	3b c3		 cmp	 eax, ebx
  001b2	0f 8f 2d ff ff
	ff		 jg	 $LN109@Calc_AREAo
$LN282@Calc_AREAo:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 215  : 	T*	GetAt( int nIndex)	{	return ( T*)GetAtUNK( nIndex);	}

  001b8	8b 4d fc	 mov	 ecx, DWORD PTR _pblDTIfDRI$1$[ebp]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 1448 : 		m_pIReturn = pblDTIfDRI->GetAt( nItemCount - 1);	// end mark.

  001bb	48		 dec	 eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 215  : 	T*	GetAt( int nIndex)	{	return ( T*)GetAtUNK( nIndex);	}

  001bc	50		 push	 eax
  001bd	e8 00 00 00 00	 call	 ?GetAtUNK@CDataBlockListUNK@@QAEPAXH@Z ; CDataBlockListUNK::GetAtUNK
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 1448 : 		m_pIReturn = pblDTIfDRI->GetAt( nItemCount - 1);	// end mark.

  001c2	89 47 60	 mov	 DWORD PTR [edi+96], eax

; 1449 : 		if( m_pIReturn) return *m_pIReturn;

  001c5	85 c0		 test	 eax, eax
  001c7	0f 84 18 ff ff
	ff		 je	 $LN109@Calc_AREAo
$LN101@Calc_AREAo:

; 1469 : 	if( pnDTI_Org != NULL) *pnDTI_Org = nDTI;

  001cd	8b 18		 mov	 ebx, DWORD PTR [eax]
  001cf	8b cb		 mov	 ecx, ebx

; 1470 : 	if( nDTI == -1)	nDTI = 0;

  001d1	83 fb ff	 cmp	 ebx, -1
  001d4	0f 85 10 ff ff
	ff		 jne	 $LN98@Calc_AREAo
  001da	e9 09 ff ff ff	 jmp	 $LN283@Calc_AREAo
$LN125@Calc_AREAo:

; 1446 : 	if( nItemCount <= nDRI)

  001df	3b c8		 cmp	 ecx, eax
  001e1	0f 8f 54 ff ff
	ff		 jg	 $LN128@Calc_AREAo
$LN281@Calc_AREAo:

; 1448 : 		m_pIReturn = pblDTIfDRI->GetAt( nItemCount - 1);	// end mark.

  001e7	8d 41 ff	 lea	 eax, DWORD PTR [ecx-1]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 215  : 	T*	GetAt( int nIndex)	{	return ( T*)GetAtUNK( nIndex);	}

  001ea	8b 4d fc	 mov	 ecx, DWORD PTR _pblDTIfDRI$1$[ebp]
  001ed	50		 push	 eax
  001ee	e8 00 00 00 00	 call	 ?GetAtUNK@CDataBlockListUNK@@QAEPAXH@Z ; CDataBlockListUNK::GetAtUNK
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 1448 : 		m_pIReturn = pblDTIfDRI->GetAt( nItemCount - 1);	// end mark.

  001f3	89 47 60	 mov	 DWORD PTR [edi+96], eax

; 1449 : 		if( m_pIReturn) return *m_pIReturn;

  001f6	85 c0		 test	 eax, eax
  001f8	0f 84 3d ff ff
	ff		 je	 $LN128@Calc_AREAo
$LN120@Calc_AREAo:

; 1469 : 	if( pnDTI_Org != NULL) *pnDTI_Org = nDTI;

  001fe	8b 00		 mov	 eax, DWORD PTR [eax]
  00200	8b d0		 mov	 edx, eax

; 1470 : 	if( nDTI == -1)	nDTI = 0;

  00202	83 f8 ff	 cmp	 eax, -1
  00205	0f 85 35 ff ff
	ff		 jne	 $LN117@Calc_AREAo
  0020b	e9 2e ff ff ff	 jmp	 $LN284@Calc_AREAo
$LN32@Calc_AREAo:

; 2975 : 				else			nNoVolumeCount++;

  00210	43		 inc	 ebx
$LN2@Calc_AREAo:

; 2972 : 			for( int nDTI = nDTI_Start_Cur; nDTI <= nDTI_End_Cur; nDTI++)

  00211	83 ea 01	 sub	 edx, 1
  00214	75 81		 jne	 SHORT $LL4@Calc_AREAo
  00216	8b 45 f4	 mov	 eax, DWORD PTR _nDTI_Start_Cur$1$[ebp]
  00219	89 5d e8	 mov	 DWORD PTR _nNoVolumeCount$1$[ebp], ebx
$LN3@Calc_AREAo:

; 2976 : 			}
; 2977 : 
; 2978 : 			// Graph Drawing Area ?
; 2979 : 			int nDRI_Start	= -1;

  0021c	83 c9 ff	 or	 ecx, -1
  0021f	89 4d f4	 mov	 DWORD PTR _nDRI_Start$2$[ebp], ecx
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 215  : 	T*	GetAt( int nIndex)	{	return ( T*)GetAtUNK( nIndex);	}

  00222	8b 4d f0	 mov	 ecx, DWORD PTR _pblDRIfDTI$1$[ebp]
  00225	50		 push	 eax
  00226	e8 00 00 00 00	 call	 ?GetAtUNK@CDataBlockListUNK@@QAEPAXH@Z ; CDataBlockListUNK::GetAtUNK
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 2980 : 			m_pIReturn = pblDRIfDTI->GetAt( nDTI_Start_Cur);

  0022b	89 47 60	 mov	 DWORD PTR [edi+96], eax

; 2981 : 
; 2982 : 			if (m_pIReturn)	//tour2k

  0022e	85 c0		 test	 eax, eax
  00230	74 05		 je	 SHORT $LN34@Calc_AREAo

; 2983 : 			nDRI_Start = *m_pIReturn;

  00232	8b 08		 mov	 ecx, DWORD PTR [eax]
  00234	89 4d f4	 mov	 DWORD PTR _nDRI_Start$2$[ebp], ecx
$LN34@Calc_AREAo:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 215  : 	T*	GetAt( int nIndex)	{	return ( T*)GetAtUNK( nIndex);	}

  00237	ff 75 ec	 push	 DWORD PTR _nDTI_End_Cur$1$[ebp]
  0023a	8b 4d f0	 mov	 ecx, DWORD PTR _pblDRIfDTI$1$[ebp]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 2984 : 			int nDRI_End	= -1;

  0023d	83 cb ff	 or	 ebx, -1
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 215  : 	T*	GetAt( int nIndex)	{	return ( T*)GetAtUNK( nIndex);	}

  00240	e8 00 00 00 00	 call	 ?GetAtUNK@CDataBlockListUNK@@QAEPAXH@Z ; CDataBlockListUNK::GetAtUNK
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 2985 : 			m_pIReturn = pblDRIfDTI->GetAt( nDTI_End_Cur);

  00245	89 47 60	 mov	 DWORD PTR [edi+96], eax

; 2986 : 
; 2987 : 			if (m_pIReturn)//tour2k

  00248	85 c0		 test	 eax, eax
  0024a	74 02		 je	 SHORT $LN35@Calc_AREAo

; 2988 : 			nDRI_End = *m_pIReturn;

  0024c	8b 18		 mov	 ebx, DWORD PTR [eax]
$LN35@Calc_AREAo:

; 2989 : 			if( nDRI_Start < m_nDRI_Start_Cur)	nDRI_Start	= m_nDRI_Start_Cur;

  0024e	8b 4d f4	 mov	 ecx, DWORD PTR _nDRI_Start$2$[ebp]
  00251	3b 4f 28	 cmp	 ecx, DWORD PTR [edi+40]

; 2992 : 
; 2993 : 			if( 0 < dVolume_Total) dVolumeFactor = dWidth_Total / dVolume_Total;

  00254	f2 0f 10 45 c4	 movsd	 xmm0, QWORD PTR _dVolume_Total$1$[ebp]
  00259	0f 4c 4f 28	 cmovl	 ecx, DWORD PTR [edi+40]
  0025d	39 5f 2c	 cmp	 DWORD PTR [edi+44], ebx
  00260	0f 4c 5f 2c	 cmovl	 ebx, DWORD PTR [edi+44]
  00264	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@0000000000000000
  0026c	76 20		 jbe	 SHORT $LN38@Calc_AREAo

; 2990 : 			if( m_nDRI_End_Cur < nDRI_End)		nDRI_End	= m_nDRI_End_Cur;
; 2991 : 			dWidth_Total = ( nDRI_End - nDRI_Start + 1 - nNoVolumeCount) * m_daItemWidth[ p_nColumn];

  0026e	2b d9		 sub	 ebx, ecx
  00270	2b 5d e8	 sub	 ebx, DWORD PTR _nNoVolumeCount$1$[ebp]
  00273	43		 inc	 ebx
  00274	66 0f 6e cb	 movd	 xmm1, ebx
  00278	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1
  0027c	f2 0f 59 8c f7
	a8 01 00 00	 mulsd	 xmm1, QWORD PTR [edi+esi*8+424]

; 2992 : 
; 2993 : 			if( 0 < dVolume_Total) dVolumeFactor = dWidth_Total / dVolume_Total;

  00285	f2 0f 5e c8	 divsd	 xmm1, xmm0
  00289	f2 0f 11 4d b4	 movsd	 QWORD PTR _dVolumeFactor$1$[ebp], xmm1
$LN38@Calc_AREAo:

; 2994 : 		}
; 2995 : 
; 2996 : 		int nDTI = 0;
; 2997 : 		double dItemWidth_Cur = 0;
; 2998 : 		int nDRICount = pblDTIfDRI->GetItemCount();

  0028e	8b 4d fc	 mov	 ecx, DWORD PTR _pblDTIfDRI$1$[ebp]
  00291	e8 00 00 00 00	 call	 ?GetItemCount@CDataBlockListUNK@@QAEHXZ ; CDataBlockListUNK::GetItemCount
  00296	89 45 d8	 mov	 DWORD PTR _nDRICount$1$[ebp], eax

; 2999 : 		BOOL bNoVolume = ( nDRICount == 0 || dVolumeFactor == 0.0);

  00299	85 c0		 test	 eax, eax
  0029b	74 1a		 je	 SHORT $LN83@Calc_AREAo
  0029d	f2 0f 10 45 b4	 movsd	 xmm0, QWORD PTR _dVolumeFactor$1$[ebp]
  002a2	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@0000000000000000
  002aa	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _bNoVolume$1$[ebp], 0
  002b1	9f		 lahf
  002b2	f6 c4 44	 test	 ah, 68			; 00000044H
  002b5	7a 07		 jp	 SHORT $LN84@Calc_AREAo
$LN83@Calc_AREAo:
  002b7	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _bNoVolume$1$[ebp], 1
$LN84@Calc_AREAo:

; 3000 : 		int nVolumeCount = pListVolume->GetCount();

  002be	8b 45 f8	 mov	 eax, DWORD PTR _pListVolume$1$[ebp]

; 3001 : 		posVolume = NULL;
; 3002 : 		double dVolume = 0.0;
; 3003 : 		int nPreDTI = -2;		// do you know why -2 ?
; 3004 : 		if( !m_bReverse)

  002c1	8d 8f ac 00 00
	00		 lea	 ecx, DWORD PTR [edi+172]
  002c7	ff 77 28	 push	 DWORD PTR [edi+40]
  002ca	33 db		 xor	 ebx, ebx
  002cc	c7 45 f4 fe ff
	ff ff		 mov	 DWORD PTR _nPreDTI$1$[ebp], -2 ; fffffffeH
  002d3	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  002d6	89 45 d4	 mov	 DWORD PTR _nVolumeCount$1$[ebp], eax
  002d9	39 5f 0c	 cmp	 DWORD PTR [edi+12], ebx
  002dc	0f 85 82 01 00
	00		 jne	 $LN39@Calc_AREAo
  002e2	66 0f 6e 84 b7
	f8 01 00 00	 movd	 xmm0, DWORD PTR [edi+esi*4+504]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\Dll_Load\XScaleManager.h

; 74   : 			right = right_p;

  002eb	0f b7 84 b7 f8
	01 00 00	 movzx	 eax, WORD PTR [edi+esi*4+504]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 3007 : 			double dLeft_Cur = m_nScreenLeft_Cur[ p_nColumn];

  002f3	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\Dll_Load\XScaleManager.h

; 74   : 			right = right_p;

  002f7	89 45 e8	 mov	 DWORD PTR _area$1$sroa$1656$1$[ebp], eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 3007 : 			double dLeft_Cur = m_nScreenLeft_Cur[ p_nColumn];

  002fa	f2 0f 11 45 ac	 movsd	 QWORD PTR _dLeft_Cur$1$[ebp], xmm0

; 3008 : 			m_blTimefDRI.SetIndex( m_nDRI_Start_Cur);

  002ff	e8 00 00 00 00	 call	 ?SetIndex@CDataBlockListUNK@@QAEXH@Z ; CDataBlockListUNK::SetIndex

; 3009 : 			int nRealDRIEnd = min( m_blTimefDRI.GetItemCount() - 1, m_nDRI_End_Cur);	// for scroll to pass or future

  00304	8d 8f ac 00 00
	00		 lea	 ecx, DWORD PTR [edi+172]
  0030a	e8 00 00 00 00	 call	 ?GetItemCount@CDataBlockListUNK@@QAEHXZ ; CDataBlockListUNK::GetItemCount
  0030f	8b 57 2c	 mov	 edx, DWORD PTR [edi+44]
  00312	48		 dec	 eax
  00313	89 55 e0	 mov	 DWORD PTR _nRealDRIEnd$1$[ebp], edx
  00316	3b c2		 cmp	 eax, edx
  00318	7d 14		 jge	 SHORT $LN85@Calc_AREAo
  0031a	8d 8f ac 00 00
	00		 lea	 ecx, DWORD PTR [edi+172]
  00320	e8 00 00 00 00	 call	 ?GetItemCount@CDataBlockListUNK@@QAEHXZ ; CDataBlockListUNK::GetItemCount
  00325	48		 dec	 eax
  00326	89 45 e0	 mov	 DWORD PTR _nRealDRIEnd$1$[ebp], eax
  00329	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  0032c	eb 02		 jmp	 SHORT $LN86@Calc_AREAo
$LN85@Calc_AREAo:
  0032e	8b c2		 mov	 eax, edx
$LN86@Calc_AREAo:

; 3010 : 			for( int nDRI = m_nDRI_Start_Cur; nDRI <= m_nDRI_End_Cur + 1; nDRI++)	// (2009/3/2 - Seung-Won, Bae) +1 for right of Last Candle

  00330	8b 4f 28	 mov	 ecx, DWORD PTR [edi+40]
  00333	40		 inc	 eax
  00334	89 4d f0	 mov	 DWORD PTR _nDRI$1$[ebp], ecx
  00337	3b c8		 cmp	 ecx, eax
  00339	0f 8f 34 06 00
	00		 jg	 $LN28@Calc_AREAo
  0033f	6b c6 34	 imul	 eax, esi, 52
  00342	05 88 03 00 00	 add	 eax, 904		; 00000388H
  00347	03 c7		 add	 eax, edi
  00349	89 45 cc	 mov	 DWORD PTR tv2969[ebp], eax
  0034c	0f 1f 40 00	 npad	 4
$LL7@Calc_AREAo:

; 3011 : 			{
; 3012 : 				nDTI = -1;
; 3013 : 				if( !bNoVolume && 0 <= nDRI && nDRI < nDRICount)

  00350	83 7d ec 00	 cmp	 DWORD PTR _bNoVolume$1$[ebp], 0
  00354	8b 45 e8	 mov	 eax, DWORD PTR _area$1$sroa$1656$1$[ebp]
  00357	0f b7 c0	 movzx	 eax, ax
  0035a	89 45 d0	 mov	 DWORD PTR tv2937[ebp], eax
  0035d	75 70		 jne	 SHORT $LN45@Calc_AREAo
  0035f	85 c9		 test	 ecx, ecx
  00361	78 6c		 js	 SHORT $LN45@Calc_AREAo
  00363	3b 4d d8	 cmp	 ecx, DWORD PTR _nDRICount$1$[ebp]
  00366	7d 67		 jge	 SHORT $LN45@Calc_AREAo
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 215  : 	T*	GetAt( int nIndex)	{	return ( T*)GetAtUNK( nIndex);	}

  00368	51		 push	 ecx
  00369	8b 4d fc	 mov	 ecx, DWORD PTR _pblDTIfDRI$1$[ebp]
  0036c	e8 00 00 00 00	 call	 ?GetAtUNK@CDataBlockListUNK@@QAEPAXH@Z ; CDataBlockListUNK::GetAtUNK
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 3015 : 					m_pIReturn = pblDTIfDRI->GetAt( nDRI);

  00371	89 47 60	 mov	 DWORD PTR [edi+96], eax

; 3016 : 					if( m_pIReturn) nDTI = *m_pIReturn;

  00374	85 c0		 test	 eax, eax
  00376	74 57		 je	 SHORT $LN45@Calc_AREAo
  00378	8b 08		 mov	 ecx, DWORD PTR [eax]

; 3017 : 				}
; 3018 : 
; 3019 : 				if( bNoVolume || nDTI < 0 || nVolumeCount <= nDTI)

  0037a	85 c9		 test	 ecx, ecx
  0037c	78 51		 js	 SHORT $LN45@Calc_AREAo
  0037e	39 4d d4	 cmp	 DWORD PTR _nVolumeCount$1$[ebp], ecx
  00381	7e 4c		 jle	 SHORT $LN45@Calc_AREAo

; 3021 : 				else
; 3022 : 				{
; 3023 : 					if( nPreDTI != nDTI)

  00383	8b 45 f4	 mov	 eax, DWORD PTR _nPreDTI$1$[ebp]
  00386	3b c1		 cmp	 eax, ecx
  00388	74 39		 je	 SHORT $LN290@Calc_AREAo

; 3025 : 						if( nPreDTI + 1 != nDTI) posVolume = pListVolume->FindIndex( nDTI);

  0038a	40		 inc	 eax
  0038b	3b c1		 cmp	 eax, ecx
  0038d	74 1c		 je	 SHORT $LN144@Calc_AREAo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 1133 : 	if (nIndex >= m_nCount || nIndex < 0)

  0038f	8b 55 f8	 mov	 edx, DWORD PTR _pListVolume$1$[ebp]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 3025 : 						if( nPreDTI + 1 != nDTI) posVolume = pListVolume->FindIndex( nDTI);

  00392	8b c1		 mov	 eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 1133 : 	if (nIndex >= m_nCount || nIndex < 0)

  00394	3b 4a 0c	 cmp	 ecx, DWORD PTR [edx+12]
  00397	7d 10		 jge	 SHORT $LN148@Calc_AREAo

; 1135 : 
; 1136 : 	CNode* pNode = m_pNodeHead;

  00399	8b 5a 04	 mov	 ebx, DWORD PTR [edx+4]

; 1137 : 	while (nIndex--)

  0039c	85 c9		 test	 ecx, ecx
  0039e	74 0b		 je	 SHORT $LN144@Calc_AREAo
$LL145@Calc_AREAo:

; 1138 : 	{
; 1139 : 		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 1140 : 		pNode = pNode->pNext;

  003a0	8b 1b		 mov	 ebx, DWORD PTR [ebx]
  003a2	83 e8 01	 sub	 eax, 1
  003a5	75 f9		 jne	 SHORT $LL145@Calc_AREAo

; 1141 : 	}
; 1142 : 	return (POSITION) pNode;

  003a7	eb 02		 jmp	 SHORT $LN144@Calc_AREAo
$LN148@Calc_AREAo:

; 1134 : 		return NULL;  // went too far

  003a9	33 db		 xor	 ebx, ebx
$LN144@Calc_AREAo:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 3026 : 						dVolume = pListVolume->GetNext( posVolume);

  003ab	f2 0f 10 43 08	 movsd	 xmm0, QWORD PTR [ebx+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 811  : 	{ CNode* pNode = (CNode*) rPosition;

  003b0	8d 03		 lea	 eax, DWORD PTR [ebx]

; 812  : 		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 813  : 		rPosition = (POSITION) pNode->pNext;

  003b2	8b 1b		 mov	 ebx, DWORD PTR [ebx]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 3026 : 						dVolume = pListVolume->GetNext( posVolume);

  003b4	f2 0f 11 45 bc	 movsd	 QWORD PTR _dVolume$1$[ebp], xmm0

; 3027 : 						nPreDTI = nDTI;
; 3028 : 					}
; 3029 : 					dItemWidth_Cur = dVolume * dVolumeFactor;

  003b9	f2 0f 59 45 b4	 mulsd	 xmm0, QWORD PTR _dVolumeFactor$1$[ebp]
  003be	89 4d f4	 mov	 DWORD PTR _nPreDTI$1$[ebp], ecx
  003c1	eb 15		 jmp	 SHORT $LN44@Calc_AREAo
$LN290@Calc_AREAo:

; 3021 : 				else
; 3022 : 				{
; 3023 : 					if( nPreDTI != nDTI)

  003c3	f2 0f 10 45 bc	 movsd	 xmm0, QWORD PTR _dVolume$1$[ebp]

; 3027 : 						nPreDTI = nDTI;
; 3028 : 					}
; 3029 : 					dItemWidth_Cur = dVolume * dVolumeFactor;

  003c8	f2 0f 59 45 b4	 mulsd	 xmm0, QWORD PTR _dVolumeFactor$1$[ebp]
  003cd	eb 09		 jmp	 SHORT $LN44@Calc_AREAo
$LN45@Calc_AREAo:

; 3020 : 						dItemWidth_Cur = m_daItemWidth[ p_nColumn];

  003cf	f2 0f 10 84 f7
	a8 01 00 00	 movsd	 xmm0, QWORD PTR [edi+esi*8+424]
$LN44@Calc_AREAo:

; 3030 : 				}
; 3031 : 
; 3032 : 				area.left = area.right;
; 3033 : 				dLeft_Cur += dItemWidth_Cur;

  003d8	f2 0f 10 4d ac	 movsd	 xmm1, QWORD PTR _dLeft_Cur$1$[ebp]

; 3036 : 
; 3037 : 				m_blAreafDRI[ p_nColumn].PushBack(area);

  003dd	8b 4d d0	 mov	 ecx, DWORD PTR tv2937[ebp]
  003e0	f2 0f 58 c8	 addsd	 xmm1, xmm0
  003e4	66 89 4d c4	 mov	 WORD PTR _Item$[ebp], cx
  003e8	0f bf c9	 movsx	 ecx, cx
  003eb	f2 0f 2c c1	 cvttsd2si eax, xmm1
  003ef	f2 0f 11 4d ac	 movsd	 QWORD PTR _dLeft_Cur$1$[ebp], xmm1
  003f4	0f b7 f0	 movzx	 esi, ax
  003f7	8b c6		 mov	 eax, esi
  003f9	66 89 75 c8	 mov	 WORD PTR _Item$[ebp+4], si
  003fd	89 45 e8	 mov	 DWORD PTR _area$1$sroa$1656$1$[ebp], eax
  00400	0f bf c6	 movsx	 eax, si
  00403	03 c1		 add	 eax, ecx
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 173  : 		PushBackUNK(&Item);

  00405	8b 4d cc	 mov	 ecx, DWORD PTR tv2969[ebp]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 3035 : 				area.center = (area.left + area.right) / 2;

  00408	99		 cdq
  00409	2b c2		 sub	 eax, edx
  0040b	d1 f8		 sar	 eax, 1

; 3036 : 
; 3037 : 				m_blAreafDRI[ p_nColumn].PushBack(area);

  0040d	66 89 45 c6	 mov	 WORD PTR _Item$[ebp+2], ax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 173  : 		PushBackUNK(&Item);

  00411	8d 45 c4	 lea	 eax, DWORD PTR _Item$[ebp]
  00414	50		 push	 eax
  00415	e8 00 00 00 00	 call	 ?PushBackUNK@CDataBlockListUNK@@QAEXPAX@Z ; CDataBlockListUNK::PushBackUNK
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 3040 : 				if( 0 == p_nColumn)

  0041a	8b 75 08	 mov	 esi, DWORD PTR _p_nColumn$[ebp]
  0041d	85 f6		 test	 esi, esi
  0041f	75 2b		 jne	 SHORT $LN5@Calc_AREAo
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 227  : 	T* GetNext()	{	return ( T*)GetNextUNK();	}

  00421	8d 8f ac 00 00
	00		 lea	 ecx, DWORD PTR [edi+172]
  00427	e8 00 00 00 00	 call	 ?GetNextUNK@CDataBlockListUNK@@QAEPAXXZ ; CDataBlockListUNK::GetNextUNK
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 3042 : 					m_pTReturn = m_blTimefDRI.GetNext();

  0042c	89 47 5c	 mov	 DWORD PTR [edi+92], eax

; 3043 : 					if( m_pTReturn) PushScaleDataTime( nDRI, *m_pTReturn, nDRI == nRealDRIEnd);

  0042f	85 c0		 test	 eax, eax
  00431	74 19		 je	 SHORT $LN5@Calc_AREAo
  00433	8b 55 f0	 mov	 edx, DWORD PTR _nDRI$1$[ebp]
  00436	33 c9		 xor	 ecx, ecx
  00438	3b 55 e0	 cmp	 edx, DWORD PTR _nRealDRIEnd$1$[ebp]
  0043b	0f 94 c1	 sete	 cl
  0043e	51		 push	 ecx
  0043f	ff 70 04	 push	 DWORD PTR [eax+4]
  00442	8b cf		 mov	 ecx, edi
  00444	ff 30		 push	 DWORD PTR [eax]
  00446	52		 push	 edx
  00447	e8 00 00 00 00	 call	 ?PushScaleDataTime@CXScaleManagerImp@@IAEXH_JH@Z ; CXScaleManagerImp::PushScaleDataTime
$LN5@Calc_AREAo:

; 3010 : 			for( int nDRI = m_nDRI_Start_Cur; nDRI <= m_nDRI_End_Cur + 1; nDRI++)	// (2009/3/2 - Seung-Won, Bae) +1 for right of Last Candle

  0044c	8b 4d f0	 mov	 ecx, DWORD PTR _nDRI$1$[ebp]
  0044f	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  00452	41		 inc	 ecx
  00453	40		 inc	 eax
  00454	89 4d f0	 mov	 DWORD PTR _nDRI$1$[ebp], ecx
  00457	3b c8		 cmp	 ecx, eax
  00459	0f 8e f1 fe ff
	ff		 jle	 $LL7@Calc_AREAo
  0045f	e9 0f 05 00 00	 jmp	 $LN28@Calc_AREAo
$LN39@Calc_AREAo:

; 3044 : 				}
; 3045 : 			}
; 3046 : 		}
; 3047 : 		else
; 3048 : 		{
; 3049 : 			AREA area( m_nScreenLeft_Cur[ p_nColumn] + m_nScreenWidth_Cur[ p_nColumn], 0, 0);

  00464	66 8b 84 b7 38
	03 00 00	 mov	 ax, WORD PTR [edi+esi*4+824]
  0046c	66 03 84 b7 f8
	01 00 00	 add	 ax, WORD PTR [edi+esi*4+504]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\Dll_Load\XScaleManager.h

; 72   : 			left = left_p;

  00474	0f b7 c0	 movzx	 eax, ax
  00477	89 45 e0	 mov	 DWORD PTR _area$2$sroa$1657$1$[ebp], eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 3050 : 			double dLeft_Cur = m_nScreenLeft_Cur[ p_nColumn] + m_nScreenWidth_Cur[ p_nColumn];

  0047a	8b 84 b7 38 03
	00 00		 mov	 eax, DWORD PTR [edi+esi*4+824]
  00481	03 84 b7 f8 01
	00 00		 add	 eax, DWORD PTR [edi+esi*4+504]
  00488	66 0f 6e c0	 movd	 xmm0, eax
  0048c	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00490	f2 0f 11 45 ac	 movsd	 QWORD PTR _dLeft_Cur$1$[ebp], xmm0

; 3051 : 			m_blTimefDRI.SetIndex( m_nDRI_Start_Cur);

  00495	e8 00 00 00 00	 call	 ?SetIndex@CDataBlockListUNK@@QAEXH@Z ; CDataBlockListUNK::SetIndex

; 3052 : 			int nRealDRIEnd = min( m_blTimefDRI.GetItemCount() - 1, m_nDRI_End_Cur);	// for scroll to pass or future

  0049a	8d 8f ac 00 00
	00		 lea	 ecx, DWORD PTR [edi+172]
  004a0	e8 00 00 00 00	 call	 ?GetItemCount@CDataBlockListUNK@@QAEHXZ ; CDataBlockListUNK::GetItemCount
  004a5	8b 57 2c	 mov	 edx, DWORD PTR [edi+44]
  004a8	48		 dec	 eax
  004a9	89 55 d0	 mov	 DWORD PTR _nRealDRIEnd$1$[ebp], edx
  004ac	3b c2		 cmp	 eax, edx
  004ae	7d 14		 jge	 SHORT $LN87@Calc_AREAo
  004b0	8d 8f ac 00 00
	00		 lea	 ecx, DWORD PTR [edi+172]
  004b6	e8 00 00 00 00	 call	 ?GetItemCount@CDataBlockListUNK@@QAEHXZ ; CDataBlockListUNK::GetItemCount
  004bb	48		 dec	 eax
  004bc	89 45 d0	 mov	 DWORD PTR _nRealDRIEnd$1$[ebp], eax
  004bf	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  004c2	eb 02		 jmp	 SHORT $LN88@Calc_AREAo
$LN87@Calc_AREAo:
  004c4	8b c2		 mov	 eax, edx
$LN88@Calc_AREAo:

; 3053 : 			for( int nDRI = m_nDRI_Start_Cur; nDRI <= m_nDRI_End_Cur + 1; nDRI++)	// (2009/3/2 - Seung-Won, Bae) +1 for right of Last Candle

  004c6	8b 4f 28	 mov	 ecx, DWORD PTR [edi+40]
  004c9	40		 inc	 eax
  004ca	89 4d f0	 mov	 DWORD PTR _nDRI$1$[ebp], ecx
  004cd	3b c8		 cmp	 ecx, eax
  004cf	0f 8f 9e 04 00
	00		 jg	 $LN28@Calc_AREAo
  004d5	6b c6 34	 imul	 eax, esi, 52
  004d8	05 88 03 00 00	 add	 eax, 904		; 00000388H
  004dd	03 c7		 add	 eax, edi
  004df	89 45 cc	 mov	 DWORD PTR tv2968[ebp], eax
$LL10@Calc_AREAo:

; 3054 : 			{
; 3055 : 				nDTI = -1;
; 3056 : 				if( !bNoVolume && 0 <= nDRI && nDRI < nDRICount)

  004e2	83 7d ec 00	 cmp	 DWORD PTR _bNoVolume$1$[ebp], 0
  004e6	8b 45 e0	 mov	 eax, DWORD PTR _area$2$sroa$1657$1$[ebp]
  004e9	0f b7 c0	 movzx	 eax, ax
  004ec	89 45 e8	 mov	 DWORD PTR tv2939[ebp], eax
  004ef	75 70		 jne	 SHORT $LN54@Calc_AREAo
  004f1	85 c9		 test	 ecx, ecx
  004f3	78 6c		 js	 SHORT $LN54@Calc_AREAo
  004f5	3b 4d d8	 cmp	 ecx, DWORD PTR _nDRICount$1$[ebp]
  004f8	7d 67		 jge	 SHORT $LN54@Calc_AREAo
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 215  : 	T*	GetAt( int nIndex)	{	return ( T*)GetAtUNK( nIndex);	}

  004fa	51		 push	 ecx
  004fb	8b 4d fc	 mov	 ecx, DWORD PTR _pblDTIfDRI$1$[ebp]
  004fe	e8 00 00 00 00	 call	 ?GetAtUNK@CDataBlockListUNK@@QAEPAXH@Z ; CDataBlockListUNK::GetAtUNK
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 3058 : 					m_pIReturn = pblDTIfDRI->GetAt( nDRI);

  00503	89 47 60	 mov	 DWORD PTR [edi+96], eax

; 3059 : 					if( m_pIReturn) nDTI = *m_pIReturn;

  00506	85 c0		 test	 eax, eax
  00508	74 57		 je	 SHORT $LN54@Calc_AREAo
  0050a	8b 08		 mov	 ecx, DWORD PTR [eax]

; 3060 : 				}
; 3061 : 
; 3062 : 				if( bNoVolume || nDTI < 0 || nVolumeCount <= nDTI)

  0050c	85 c9		 test	 ecx, ecx
  0050e	78 51		 js	 SHORT $LN54@Calc_AREAo
  00510	39 4d d4	 cmp	 DWORD PTR _nVolumeCount$1$[ebp], ecx
  00513	7e 4c		 jle	 SHORT $LN54@Calc_AREAo

; 3064 : 				else
; 3065 : 				{
; 3066 : 					if( nPreDTI != nDTI)

  00515	8b 45 f4	 mov	 eax, DWORD PTR _nPreDTI$1$[ebp]
  00518	3b c1		 cmp	 eax, ecx
  0051a	74 39		 je	 SHORT $LN291@Calc_AREAo

; 3068 : 						if( nPreDTI + 1 != nDTI) posVolume = pListVolume->FindIndex( nDTI);

  0051c	40		 inc	 eax
  0051d	3b c1		 cmp	 eax, ecx
  0051f	74 1c		 je	 SHORT $LN160@Calc_AREAo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 1133 : 	if (nIndex >= m_nCount || nIndex < 0)

  00521	8b 55 f8	 mov	 edx, DWORD PTR _pListVolume$1$[ebp]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 3068 : 						if( nPreDTI + 1 != nDTI) posVolume = pListVolume->FindIndex( nDTI);

  00524	8b c1		 mov	 eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 1133 : 	if (nIndex >= m_nCount || nIndex < 0)

  00526	3b 4a 0c	 cmp	 ecx, DWORD PTR [edx+12]
  00529	7d 10		 jge	 SHORT $LN164@Calc_AREAo

; 1135 : 
; 1136 : 	CNode* pNode = m_pNodeHead;

  0052b	8b 5a 04	 mov	 ebx, DWORD PTR [edx+4]

; 1137 : 	while (nIndex--)

  0052e	85 c9		 test	 ecx, ecx
  00530	74 0b		 je	 SHORT $LN160@Calc_AREAo
$LL161@Calc_AREAo:

; 1138 : 	{
; 1139 : 		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 1140 : 		pNode = pNode->pNext;

  00532	8b 1b		 mov	 ebx, DWORD PTR [ebx]
  00534	83 e8 01	 sub	 eax, 1
  00537	75 f9		 jne	 SHORT $LL161@Calc_AREAo

; 1141 : 	}
; 1142 : 	return (POSITION) pNode;

  00539	eb 02		 jmp	 SHORT $LN160@Calc_AREAo
$LN164@Calc_AREAo:

; 1134 : 		return NULL;  // went too far

  0053b	33 db		 xor	 ebx, ebx
$LN160@Calc_AREAo:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 3069 : 						dVolume = pListVolume->GetNext( posVolume);

  0053d	f2 0f 10 43 08	 movsd	 xmm0, QWORD PTR [ebx+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 811  : 	{ CNode* pNode = (CNode*) rPosition;

  00542	8d 03		 lea	 eax, DWORD PTR [ebx]

; 812  : 		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 813  : 		rPosition = (POSITION) pNode->pNext;

  00544	8b 1b		 mov	 ebx, DWORD PTR [ebx]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 3069 : 						dVolume = pListVolume->GetNext( posVolume);

  00546	f2 0f 11 45 bc	 movsd	 QWORD PTR _dVolume$1$[ebp], xmm0

; 3070 : 						nPreDTI = nDTI;
; 3071 : 					}
; 3072 : 					dItemWidth_Cur = dVolume * dVolumeFactor;

  0054b	f2 0f 59 45 b4	 mulsd	 xmm0, QWORD PTR _dVolumeFactor$1$[ebp]
  00550	89 4d f4	 mov	 DWORD PTR _nPreDTI$1$[ebp], ecx
  00553	eb 15		 jmp	 SHORT $LN53@Calc_AREAo
$LN291@Calc_AREAo:

; 3064 : 				else
; 3065 : 				{
; 3066 : 					if( nPreDTI != nDTI)

  00555	f2 0f 10 45 bc	 movsd	 xmm0, QWORD PTR _dVolume$1$[ebp]

; 3070 : 						nPreDTI = nDTI;
; 3071 : 					}
; 3072 : 					dItemWidth_Cur = dVolume * dVolumeFactor;

  0055a	f2 0f 59 45 b4	 mulsd	 xmm0, QWORD PTR _dVolumeFactor$1$[ebp]
  0055f	eb 09		 jmp	 SHORT $LN53@Calc_AREAo
$LN54@Calc_AREAo:

; 3063 : 						dItemWidth_Cur = m_daItemWidth[ p_nColumn];

  00561	f2 0f 10 84 f7
	a8 01 00 00	 movsd	 xmm0, QWORD PTR [edi+esi*8+424]
$LN53@Calc_AREAo:

; 3073 : 				}
; 3074 : 
; 3075 : 				area.right = area.left;
; 3076 : 				dLeft_Cur -= dItemWidth_Cur;

  0056a	f2 0f 10 4d ac	 movsd	 xmm1, QWORD PTR _dLeft_Cur$1$[ebp]
  0056f	f2 0f 5c c8	 subsd	 xmm1, xmm0

; 3077 : 				area.left = int(dLeft_Cur);

  00573	f2 0f 2c c1	 cvttsd2si eax, xmm1
  00577	f2 0f 11 4d ac	 movsd	 QWORD PTR _dLeft_Cur$1$[ebp], xmm1
  0057c	0f b7 c0	 movzx	 eax, ax
  0057f	8b c8		 mov	 ecx, eax

; 3079 : 
; 3080 : 				m_blAreafDRI[ p_nColumn].PushBack(area);

  00581	66 89 45 c4	 mov	 WORD PTR _Item$[ebp], ax
  00585	89 4d e0	 mov	 DWORD PTR _area$2$sroa$1657$1$[ebp], ecx
  00588	8b 4d e8	 mov	 ecx, DWORD PTR tv2939[ebp]
  0058b	98		 cwde
  0058c	0f bf c9	 movsx	 ecx, cx
  0058f	03 c1		 add	 eax, ecx
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 173  : 		PushBackUNK(&Item);

  00591	8b 4d cc	 mov	 ecx, DWORD PTR tv2968[ebp]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 3078 : 				area.center = (area.left + area.right) / 2;

  00594	99		 cdq
  00595	2b c2		 sub	 eax, edx
  00597	d1 f8		 sar	 eax, 1

; 3079 : 
; 3080 : 				m_blAreafDRI[ p_nColumn].PushBack(area);

  00599	66 89 45 c6	 mov	 WORD PTR _Item$[ebp+2], ax
  0059d	8b 45 e8	 mov	 eax, DWORD PTR tv2939[ebp]
  005a0	66 89 45 c8	 mov	 WORD PTR _Item$[ebp+4], ax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 173  : 		PushBackUNK(&Item);

  005a4	8d 45 c4	 lea	 eax, DWORD PTR _Item$[ebp]
  005a7	50		 push	 eax
  005a8	e8 00 00 00 00	 call	 ?PushBackUNK@CDataBlockListUNK@@QAEXPAX@Z ; CDataBlockListUNK::PushBackUNK
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 3083 : 				if( 0 == p_nColumn)

  005ad	85 f6		 test	 esi, esi
  005af	75 2b		 jne	 SHORT $LN8@Calc_AREAo
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 227  : 	T* GetNext()	{	return ( T*)GetNextUNK();	}

  005b1	8d 8f ac 00 00
	00		 lea	 ecx, DWORD PTR [edi+172]
  005b7	e8 00 00 00 00	 call	 ?GetNextUNK@CDataBlockListUNK@@QAEPAXXZ ; CDataBlockListUNK::GetNextUNK
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 3085 : 					m_pTReturn = m_blTimefDRI.GetNext();

  005bc	89 47 5c	 mov	 DWORD PTR [edi+92], eax

; 3086 : 					if( m_pTReturn) PushScaleDataTime( nDRI, *m_pTReturn, nDRI == nRealDRIEnd);

  005bf	85 c0		 test	 eax, eax
  005c1	74 19		 je	 SHORT $LN8@Calc_AREAo
  005c3	8b 55 f0	 mov	 edx, DWORD PTR _nDRI$1$[ebp]
  005c6	33 c9		 xor	 ecx, ecx
  005c8	3b 55 d0	 cmp	 edx, DWORD PTR _nRealDRIEnd$1$[ebp]
  005cb	0f 94 c1	 sete	 cl
  005ce	51		 push	 ecx
  005cf	ff 70 04	 push	 DWORD PTR [eax+4]
  005d2	8b cf		 mov	 ecx, edi
  005d4	ff 30		 push	 DWORD PTR [eax]
  005d6	52		 push	 edx
  005d7	e8 00 00 00 00	 call	 ?PushScaleDataTime@CXScaleManagerImp@@IAEXH_JH@Z ; CXScaleManagerImp::PushScaleDataTime
$LN8@Calc_AREAo:

; 3053 : 			for( int nDRI = m_nDRI_Start_Cur; nDRI <= m_nDRI_End_Cur + 1; nDRI++)	// (2009/3/2 - Seung-Won, Bae) +1 for right of Last Candle

  005dc	8b 4d f0	 mov	 ecx, DWORD PTR _nDRI$1$[ebp]
  005df	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  005e2	41		 inc	 ecx
  005e3	40		 inc	 eax
  005e4	89 4d f0	 mov	 DWORD PTR _nDRI$1$[ebp], ecx
  005e7	3b c8		 cmp	 ecx, eax
  005e9	0f 8e f3 fe ff
	ff		 jle	 $LL10@Calc_AREAo

; 3087 : 				}
; 3088 : 			}
; 3089 : 		}
; 3090 : 	}

  005ef	e9 7f 03 00 00	 jmp	 $LN28@Calc_AREAo
$LN27@Calc_AREAo:

; 3091 : 	else
; 3092 : 	{
; 3093 : 		// (2009/2/12 - Seung-Won, Bae) Support default data space.
; 3094 : 		int nPreAreaCount = m_blAreafDRI[ 0].GetItemCount();

  005f4	8d 8f 88 03 00
	00		 lea	 ecx, DWORD PTR [edi+904]
  005fa	e8 00 00 00 00	 call	 ?GetItemCount@CDataBlockListUNK@@QAEHXZ ; CDataBlockListUNK::GetItemCount

; 3095 : 		if( 1 == m_nCalculationMode
; 3096 : 			&& m_blTimefDRI.GetItemCount() <= m_nDRI_End_Cur + 1
; 3097 : 			&& m_nDRI_End_Cur - m_nDRI_Start_Cur + 1 + 1 == nPreAreaCount) // (2009/3/2 - Seung-Won, Bae) +1 for right of Last Candle

  005ff	83 bf 20 01 00
	00 01		 cmp	 DWORD PTR [edi+288], 1
  00606	8b c8		 mov	 ecx, eax
  00608	89 4d d0	 mov	 DWORD PTR _nPreAreaCount$1$[ebp], ecx
  0060b	0f 85 c4 00 00
	00		 jne	 $LN59@Calc_AREAo
  00611	8d 8f ac 00 00
	00		 lea	 ecx, DWORD PTR [edi+172]
  00617	e8 00 00 00 00	 call	 ?GetItemCount@CDataBlockListUNK@@QAEHXZ ; CDataBlockListUNK::GetItemCount
  0061c	8b 57 2c	 mov	 edx, DWORD PTR [edi+44]
  0061f	8d 4a 01	 lea	 ecx, DWORD PTR [edx+1]
  00622	3b c1		 cmp	 eax, ecx
  00624	8b 4d d0	 mov	 ecx, DWORD PTR _nPreAreaCount$1$[ebp]
  00627	0f 8f a8 00 00
	00		 jg	 $LN59@Calc_AREAo
  0062d	2b 57 28	 sub	 edx, DWORD PTR [edi+40]
  00630	83 c2 02	 add	 edx, 2
  00633	3b d1		 cmp	 edx, ecx
  00635	0f 85 9a 00 00
	00		 jne	 $LN59@Calc_AREAo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 2052 : 		{ return BASE_CLASS::Lookup(key, (typename BASE_CLASS::BASE_VALUE&)rValue); }

  0063b	8d 45 d0	 lea	 eax, DWORD PTR _pXScaleGridTime$5[ebp]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 3099 : 			int nDRI_Start_Cur = 0;

  0063e	33 f6		 xor	 esi, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 2052 : 		{ return BASE_CLASS::Lookup(key, (typename BASE_CLASS::BASE_VALUE&)rValue); }

  00640	50		 push	 eax
  00641	56		 push	 esi
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 3101 : 			if( m_mapXGridTime.Lookup( 0, pXScaleGridTime)) nDRI_Start_Cur = pXScaleGridTime->GetLastDRI();

  00642	8d 8f 18 06 00
	00		 lea	 ecx, DWORD PTR [edi+1560]
  00648	89 75 d0	 mov	 DWORD PTR _pXScaleGridTime$5[ebp], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 2052 : 		{ return BASE_CLASS::Lookup(key, (typename BASE_CLASS::BASE_VALUE&)rValue); }

  0064b	e8 00 00 00 00	 call	 ?Lookup@CMapWordToPtr@@QBEHGAAPAX@Z ; CMapWordToPtr::Lookup
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 3101 : 			if( m_mapXGridTime.Lookup( 0, pXScaleGridTime)) nDRI_Start_Cur = pXScaleGridTime->GetLastDRI();

  00650	85 c0		 test	 eax, eax
  00652	74 0a		 je	 SHORT $LN61@Calc_AREAo
  00654	8b 4d d0	 mov	 ecx, DWORD PTR _pXScaleGridTime$5[ebp]
  00657	e8 00 00 00 00	 call	 ?GetLastDRI@CXScaleGridTime@@QAEHXZ ; CXScaleGridTime::GetLastDRI
  0065c	8b f0		 mov	 esi, eax
$LN61@Calc_AREAo:

; 3102 : 			PopLastScaleDataTime();

  0065e	8b cf		 mov	 ecx, edi
  00660	e8 00 00 00 00	 call	 ?PopLastScaleDataTime@CXScaleManagerImp@@IAEXXZ ; CXScaleManagerImp::PopLastScaleDataTime

; 3103 : 			m_blTimefDRI.SetIndex( nDRI_Start_Cur);

  00665	56		 push	 esi
  00666	8d 8f ac 00 00
	00		 lea	 ecx, DWORD PTR [edi+172]
  0066c	e8 00 00 00 00	 call	 ?SetIndex@CDataBlockListUNK@@QAEXH@Z ; CDataBlockListUNK::SetIndex

; 3104 : 			int nRealDRIEnd = min( m_blTimefDRI.GetItemCount() - 1, m_nDRI_End_Cur);	// for scroll to pass or future

  00671	8d 8f ac 00 00
	00		 lea	 ecx, DWORD PTR [edi+172]
  00677	e8 00 00 00 00	 call	 ?GetItemCount@CDataBlockListUNK@@QAEHXZ ; CDataBlockListUNK::GetItemCount
  0067c	8b 5f 2c	 mov	 ebx, DWORD PTR [edi+44]
  0067f	48		 dec	 eax
  00680	3b c3		 cmp	 eax, ebx
  00682	7d 13		 jge	 SHORT $LN89@Calc_AREAo
  00684	8d 8f ac 00 00
	00		 lea	 ecx, DWORD PTR [edi+172]
  0068a	e8 00 00 00 00	 call	 ?GetItemCount@CDataBlockListUNK@@QAEHXZ ; CDataBlockListUNK::GetItemCount
  0068f	8b 4f 2c	 mov	 ecx, DWORD PTR [edi+44]
  00692	8d 58 ff	 lea	 ebx, DWORD PTR [eax-1]
  00695	eb 02		 jmp	 SHORT $LN90@Calc_AREAo
$LN89@Calc_AREAo:
  00697	8b cb		 mov	 ecx, ebx
$LN90@Calc_AREAo:

; 3105 : 			for( int nDRI = nDRI_Start_Cur; nDRI <= m_nDRI_End_Cur; nDRI++)

  00699	3b f1		 cmp	 esi, ecx
  0069b	0f 8f cc 02 00
	00		 jg	 $LN18@Calc_AREAo
$LL13@Calc_AREAo:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 227  : 	T* GetNext()	{	return ( T*)GetNextUNK();	}

  006a1	8d 8f ac 00 00
	00		 lea	 ecx, DWORD PTR [edi+172]
  006a7	e8 00 00 00 00	 call	 ?GetNextUNK@CDataBlockListUNK@@QAEPAXXZ ; CDataBlockListUNK::GetNextUNK
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 3108 : 				m_pTReturn = m_blTimefDRI.GetNext();

  006ac	89 47 5c	 mov	 DWORD PTR [edi+92], eax

; 3109 : 				if( m_pTReturn) PushScaleDataTime( nDRI, *m_pTReturn, nDRI == nRealDRIEnd);

  006af	85 c0		 test	 eax, eax
  006b1	74 15		 je	 SHORT $LN11@Calc_AREAo
  006b3	33 c9		 xor	 ecx, ecx
  006b5	3b f3		 cmp	 esi, ebx
  006b7	0f 94 c1	 sete	 cl
  006ba	51		 push	 ecx
  006bb	ff 70 04	 push	 DWORD PTR [eax+4]
  006be	8b cf		 mov	 ecx, edi
  006c0	ff 30		 push	 DWORD PTR [eax]
  006c2	56		 push	 esi
  006c3	e8 00 00 00 00	 call	 ?PushScaleDataTime@CXScaleManagerImp@@IAEXH_JH@Z ; CXScaleManagerImp::PushScaleDataTime
$LN11@Calc_AREAo:

; 3105 : 			for( int nDRI = nDRI_Start_Cur; nDRI <= m_nDRI_End_Cur; nDRI++)

  006c8	8b 4f 2c	 mov	 ecx, DWORD PTR [edi+44]
  006cb	46		 inc	 esi
  006cc	3b f1		 cmp	 esi, ecx
  006ce	7e d1		 jle	 SHORT $LL13@Calc_AREAo

; 3110 : 			}
; 3111 : 		}

  006d0	e9 98 02 00 00	 jmp	 $LN18@Calc_AREAo
$LN59@Calc_AREAo:

; 3112 : 		else if( !m_bReverse)

  006d5	83 7f 0c 00	 cmp	 DWORD PTR [edi+12], 0
  006d9	8b 5f 28	 mov	 ebx, DWORD PTR [edi+40]
  006dc	0f 85 40 01 00
	00		 jne	 $LN63@Calc_AREAo

; 3113 : 		{
; 3114 : 			double dLeft_Cur = m_nScreenLeft_Cur[ p_nColumn];
; 3115 : 			// (2009/1/14 - Seung-Won, Bae) Support Pixel Arranging.
; 3116 : 			int nDRI_Start_Cur = m_nDRI_Start_Cur;
; 3117 : 			if( 1 == m_nCalculationMode)		// 0:No-Calc, 1:CalcByReal, 2:CalcAll

  006e2	83 bf 20 01 00
	00 01		 cmp	 DWORD PTR [edi+288], 1
  006e9	66 0f 6e 8c b7
	f8 01 00 00	 movd	 xmm1, DWORD PTR [edi+esi*4+504]
  006f2	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1
  006f6	f2 0f 11 4d b4	 movsd	 QWORD PTR _dLeft_Cur$1$[ebp], xmm1
  006fb	75 3b		 jne	 SHORT $LN65@Calc_AREAo

; 3118 : 			{
; 3119 : 				// (2009/2/11 - Seung-Won, Bae) Recalc pre-last one for updated new time.
; 3120 : 				dLeft_Cur += m_daItemWidth[ 0] * ( nPreAreaCount - 1 - 1);	// (2009/3/2 - Seung-Won, Bae) -1 for right of Last Candle
; 3121 : 				nDRI_Start_Cur = m_nDRI_End_Pre;

  006fd	8b 9f 24 01 00
	00		 mov	 ebx, DWORD PTR [edi+292]
  00703	8d 41 fe	 lea	 eax, DWORD PTR [ecx-2]
  00706	66 0f 6e c0	 movd	 xmm0, eax

; 3122 : 				m_blAreafDRI[ 0].DeleteBack( 1 + 1);						// (2009/3/2 - Seung-Won, Bae) +1 for right of Last Candle

  0070a	8d 8f 88 03 00
	00		 lea	 ecx, DWORD PTR [edi+904]
  00710	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00714	6a 02		 push	 2
  00716	f2 0f 59 87 a8
	01 00 00	 mulsd	 xmm0, QWORD PTR [edi+424]
  0071e	f2 0f 58 c8	 addsd	 xmm1, xmm0
  00722	f2 0f 11 4d b4	 movsd	 QWORD PTR _dLeft_Cur$1$[ebp], xmm1
  00727	e8 00 00 00 00	 call	 ?DeleteBack@CDataBlockListUNK@@QAEXH@Z ; CDataBlockListUNK::DeleteBack

; 3123 : 
; 3124 : 				// (2009/1/19 - Seung-Won, Bae) for Scale Time List
; 3125 : 				PopLastScaleDataTime();

  0072c	8b cf		 mov	 ecx, edi
  0072e	e8 00 00 00 00	 call	 ?PopLastScaleDataTime@CXScaleManagerImp@@IAEXXZ ; CXScaleManagerImp::PopLastScaleDataTime
  00733	f2 0f 10 4d b4	 movsd	 xmm1, QWORD PTR _dLeft_Cur$1$[ebp]
$LN65@Calc_AREAo:

; 3126 : 			}
; 3127 : 			AREA area( 0, 0, dLeft_Cur);

  00738	f2 0f 2c c1	 cvttsd2si eax, xmm1

; 3128 : 			m_blTimefDRI.SetIndex( nDRI_Start_Cur);

  0073c	8d 8f ac 00 00
	00		 lea	 ecx, DWORD PTR [edi+172]
  00742	53		 push	 ebx
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\Dll_Load\XScaleManager.h

; 74   : 			right = right_p;

  00743	0f b7 c0	 movzx	 eax, ax
  00746	89 45 d0	 mov	 DWORD PTR _area$3$sroa$1658$1$[ebp], eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 3128 : 			m_blTimefDRI.SetIndex( nDRI_Start_Cur);

  00749	e8 00 00 00 00	 call	 ?SetIndex@CDataBlockListUNK@@QAEXH@Z ; CDataBlockListUNK::SetIndex

; 3129 : 			int nRealDRIEnd = min( m_blTimefDRI.GetItemCount() - 1, m_nDRI_End_Cur);	// for scroll to pass or future

  0074e	8d 8f ac 00 00
	00		 lea	 ecx, DWORD PTR [edi+172]
  00754	e8 00 00 00 00	 call	 ?GetItemCount@CDataBlockListUNK@@QAEHXZ ; CDataBlockListUNK::GetItemCount
  00759	8b 4f 2c	 mov	 ecx, DWORD PTR [edi+44]
  0075c	48		 dec	 eax
  0075d	3b c1		 cmp	 eax, ecx
  0075f	7d 14		 jge	 SHORT $LN91@Calc_AREAo
  00761	8d 8f ac 00 00
	00		 lea	 ecx, DWORD PTR [edi+172]
  00767	e8 00 00 00 00	 call	 ?GetItemCount@CDataBlockListUNK@@QAEHXZ ; CDataBlockListUNK::GetItemCount
  0076c	8b 4f 2c	 mov	 ecx, DWORD PTR [edi+44]
  0076f	48		 dec	 eax
  00770	89 45 d4	 mov	 DWORD PTR _nRealDRIEnd$1$[ebp], eax
  00773	eb 03		 jmp	 SHORT $LN92@Calc_AREAo
$LN91@Calc_AREAo:
  00775	89 4d d4	 mov	 DWORD PTR _nRealDRIEnd$1$[ebp], ecx
$LN92@Calc_AREAo:

; 3130 : 			for( int nDRI = nDRI_Start_Cur; nDRI <= m_nDRI_End_Cur + 1; nDRI++)		// (2009/3/2 - Seung-Won, Bae) +1 for right of Last Candle

  00778	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  0077b	3b d8		 cmp	 ebx, eax
  0077d	0f 8f ea 01 00
	00		 jg	 $LN18@Calc_AREAo
  00783	6b c6 34	 imul	 eax, esi, 52
  00786	05 88 03 00 00	 add	 eax, 904		; 00000388H
  0078b	03 c7		 add	 eax, edi
  0078d	89 45 cc	 mov	 DWORD PTR tv2967[ebp], eax
$LL16@Calc_AREAo:

; 3131 : 			{
; 3132 : 				area.left = area.right;
; 3133 : 				dLeft_Cur += m_daItemWidth[ p_nColumn];

  00790	f2 0f 10 45 b4	 movsd	 xmm0, QWORD PTR _dLeft_Cur$1$[ebp]
  00795	f2 0f 58 84 f7
	a8 01 00 00	 addsd	 xmm0, QWORD PTR [edi+esi*8+424]
  0079e	8b 45 d0	 mov	 eax, DWORD PTR _area$3$sroa$1658$1$[ebp]
  007a1	0f b7 c8	 movzx	 ecx, ax

; 3136 : 				m_blAreafDRI[ p_nColumn].PushBack(area);

  007a4	66 89 4d c4	 mov	 WORD PTR _Item$[ebp], cx
  007a8	0f bf c9	 movsx	 ecx, cx
  007ab	f2 0f 2c c0	 cvttsd2si eax, xmm0
  007af	f2 0f 11 45 b4	 movsd	 QWORD PTR _dLeft_Cur$1$[ebp], xmm0
  007b4	0f b7 f0	 movzx	 esi, ax
  007b7	8b c6		 mov	 eax, esi
  007b9	66 89 75 c8	 mov	 WORD PTR _Item$[ebp+4], si
  007bd	89 45 d0	 mov	 DWORD PTR _area$3$sroa$1658$1$[ebp], eax
  007c0	0f bf c6	 movsx	 eax, si
  007c3	03 c1		 add	 eax, ecx
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 173  : 		PushBackUNK(&Item);

  007c5	8b 4d cc	 mov	 ecx, DWORD PTR tv2967[ebp]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 3135 : 				area.center = (area.left + area.right) / 2;

  007c8	99		 cdq
  007c9	2b c2		 sub	 eax, edx
  007cb	d1 f8		 sar	 eax, 1

; 3136 : 				m_blAreafDRI[ p_nColumn].PushBack(area);

  007cd	66 89 45 c6	 mov	 WORD PTR _Item$[ebp+2], ax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 173  : 		PushBackUNK(&Item);

  007d1	8d 45 c4	 lea	 eax, DWORD PTR _Item$[ebp]
  007d4	50		 push	 eax
  007d5	e8 00 00 00 00	 call	 ?PushBackUNK@CDataBlockListUNK@@QAEXPAX@Z ; CDataBlockListUNK::PushBackUNK
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 3139 : 				if( 0 == p_nColumn && nDRI <= m_nDRI_End_Cur)

  007da	8b 75 08	 mov	 esi, DWORD PTR _p_nColumn$[ebp]
  007dd	85 f6		 test	 esi, esi
  007df	75 2d		 jne	 SHORT $LN14@Calc_AREAo
  007e1	3b 5f 2c	 cmp	 ebx, DWORD PTR [edi+44]
  007e4	7f 28		 jg	 SHORT $LN14@Calc_AREAo
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 227  : 	T* GetNext()	{	return ( T*)GetNextUNK();	}

  007e6	8d 8f ac 00 00
	00		 lea	 ecx, DWORD PTR [edi+172]
  007ec	e8 00 00 00 00	 call	 ?GetNextUNK@CDataBlockListUNK@@QAEPAXXZ ; CDataBlockListUNK::GetNextUNK
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 3141 : 					m_pTReturn = m_blTimefDRI.GetNext();

  007f1	89 47 5c	 mov	 DWORD PTR [edi+92], eax

; 3142 : 					if( m_pTReturn) PushScaleDataTime( nDRI, *m_pTReturn, nDRI == nRealDRIEnd);

  007f4	85 c0		 test	 eax, eax
  007f6	74 16		 je	 SHORT $LN14@Calc_AREAo
  007f8	33 c9		 xor	 ecx, ecx
  007fa	3b 5d d4	 cmp	 ebx, DWORD PTR _nRealDRIEnd$1$[ebp]
  007fd	0f 94 c1	 sete	 cl
  00800	51		 push	 ecx
  00801	ff 70 04	 push	 DWORD PTR [eax+4]
  00804	8b cf		 mov	 ecx, edi
  00806	ff 30		 push	 DWORD PTR [eax]
  00808	53		 push	 ebx
  00809	e8 00 00 00 00	 call	 ?PushScaleDataTime@CXScaleManagerImp@@IAEXH_JH@Z ; CXScaleManagerImp::PushScaleDataTime
$LN14@Calc_AREAo:

; 3130 : 			for( int nDRI = nDRI_Start_Cur; nDRI <= m_nDRI_End_Cur + 1; nDRI++)		// (2009/3/2 - Seung-Won, Bae) +1 for right of Last Candle

  0080e	8b 4f 2c	 mov	 ecx, DWORD PTR [edi+44]
  00811	43		 inc	 ebx
  00812	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  00815	3b d8		 cmp	 ebx, eax
  00817	0f 8e 73 ff ff
	ff		 jle	 $LL16@Calc_AREAo

; 3143 : 				}
; 3144 : 			}
; 3145 : 		}

  0081d	e9 4b 01 00 00	 jmp	 $LN18@Calc_AREAo
$LN63@Calc_AREAo:

; 3146 : 		else
; 3147 : 		{
; 3148 : 			double dLeft_Cur = m_nScreenLeft_Cur[ p_nColumn] + m_nScreenWidth_Cur[ p_nColumn];

  00822	8b 84 b7 38 03
	00 00		 mov	 eax, DWORD PTR [edi+esi*4+824]
  00829	03 84 b7 f8 01
	00 00		 add	 eax, DWORD PTR [edi+esi*4+504]

; 3149 : 			// (2009/1/14 - Seung-Won, Bae) Support Pixel Arranging.
; 3150 : 			int nDRI_Start_Cur = m_nDRI_Start_Cur;
; 3151 : 			if( 1 == m_nCalculationMode)		// 0:No-Calc, 1:CalcByReal, 2:CalcAll

  00830	83 bf 20 01 00
	00 01		 cmp	 DWORD PTR [edi+288], 1
  00837	66 0f 6e c8	 movd	 xmm1, eax
  0083b	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1
  0083f	f2 0f 11 4d b4	 movsd	 QWORD PTR _dLeft_Cur$1$[ebp], xmm1
  00844	75 3b		 jne	 SHORT $LN68@Calc_AREAo

; 3152 : 			{
; 3153 : 				// (2009/2/11 - Seung-Won, Bae) Recalc pre-last one for updated new time.
; 3154 : 				dLeft_Cur -= m_daItemWidth[ 0] * ( nPreAreaCount - 1 - 1);	// (2009/3/2 - Seung-Won, Bae) -1 for right of Last Candle
; 3155 : 				nDRI_Start_Cur = m_nDRI_End_Pre;

  00846	8b 9f 24 01 00
	00		 mov	 ebx, DWORD PTR [edi+292]
  0084c	8d 41 fe	 lea	 eax, DWORD PTR [ecx-2]
  0084f	66 0f 6e c0	 movd	 xmm0, eax

; 3156 : 				m_blAreafDRI[ 0].DeleteBack( 1 + 1);						// (2009/3/2 - Seung-Won, Bae) +1 for right of Last Candle

  00853	8d 8f 88 03 00
	00		 lea	 ecx, DWORD PTR [edi+904]
  00859	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  0085d	6a 02		 push	 2
  0085f	f2 0f 59 87 a8
	01 00 00	 mulsd	 xmm0, QWORD PTR [edi+424]
  00867	f2 0f 5c c8	 subsd	 xmm1, xmm0
  0086b	f2 0f 11 4d b4	 movsd	 QWORD PTR _dLeft_Cur$1$[ebp], xmm1
  00870	e8 00 00 00 00	 call	 ?DeleteBack@CDataBlockListUNK@@QAEXH@Z ; CDataBlockListUNK::DeleteBack

; 3157 : 
; 3158 : 				// (2009/1/19 - Seung-Won, Bae) for Scale Time List
; 3159 : 				PopLastScaleDataTime();

  00875	8b cf		 mov	 ecx, edi
  00877	e8 00 00 00 00	 call	 ?PopLastScaleDataTime@CXScaleManagerImp@@IAEXXZ ; CXScaleManagerImp::PopLastScaleDataTime
  0087c	f2 0f 10 4d b4	 movsd	 xmm1, QWORD PTR _dLeft_Cur$1$[ebp]
$LN68@Calc_AREAo:

; 3160 : 			}
; 3161 : 			AREA area( dLeft_Cur, 0, 0);

  00881	f2 0f 2c c1	 cvttsd2si eax, xmm1

; 3162 : 			m_blTimefDRI.SetIndex( nDRI_Start_Cur);

  00885	8d 8f ac 00 00
	00		 lea	 ecx, DWORD PTR [edi+172]
  0088b	53		 push	 ebx
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\Dll_Load\XScaleManager.h

; 72   : 			left = left_p;

  0088c	0f b7 c0	 movzx	 eax, ax
  0088f	89 45 d0	 mov	 DWORD PTR _area$4$sroa$1659$1$[ebp], eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 3162 : 			m_blTimefDRI.SetIndex( nDRI_Start_Cur);

  00892	e8 00 00 00 00	 call	 ?SetIndex@CDataBlockListUNK@@QAEXH@Z ; CDataBlockListUNK::SetIndex

; 3163 : 			int nRealDRIEnd = min( m_blTimefDRI.GetItemCount() - 1, m_nDRI_End_Cur);	// for scroll to pass or future

  00897	8d 8f ac 00 00
	00		 lea	 ecx, DWORD PTR [edi+172]
  0089d	e8 00 00 00 00	 call	 ?GetItemCount@CDataBlockListUNK@@QAEHXZ ; CDataBlockListUNK::GetItemCount
  008a2	8b 4f 2c	 mov	 ecx, DWORD PTR [edi+44]
  008a5	48		 dec	 eax
  008a6	3b c1		 cmp	 eax, ecx
  008a8	7d 14		 jge	 SHORT $LN93@Calc_AREAo
  008aa	8d 8f ac 00 00
	00		 lea	 ecx, DWORD PTR [edi+172]
  008b0	e8 00 00 00 00	 call	 ?GetItemCount@CDataBlockListUNK@@QAEHXZ ; CDataBlockListUNK::GetItemCount
  008b5	8b 4f 2c	 mov	 ecx, DWORD PTR [edi+44]
  008b8	48		 dec	 eax
  008b9	89 45 d4	 mov	 DWORD PTR _nRealDRIEnd$1$[ebp], eax
  008bc	eb 03		 jmp	 SHORT $LN94@Calc_AREAo
$LN93@Calc_AREAo:
  008be	89 4d d4	 mov	 DWORD PTR _nRealDRIEnd$1$[ebp], ecx
$LN94@Calc_AREAo:

; 3164 : 			for( int nDRI = nDRI_Start_Cur; nDRI <= m_nDRI_End_Cur + 1; nDRI++)		// (2009/3/2 - Seung-Won, Bae) +1 for right of Last Candle

  008c1	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  008c4	3b d8		 cmp	 ebx, eax
  008c6	0f 8f a1 00 00
	00		 jg	 $LN18@Calc_AREAo
  008cc	6b c6 34	 imul	 eax, esi, 52
  008cf	05 88 03 00 00	 add	 eax, 904		; 00000388H
  008d4	03 c7		 add	 eax, edi
  008d6	89 45 cc	 mov	 DWORD PTR tv2966[ebp], eax
  008d9	0f 1f 80 00 00
	00 00		 npad	 7
$LL19@Calc_AREAo:

; 3165 : 			{
; 3166 : 				area.right = area.left;

  008e0	8b 45 d0	 mov	 eax, DWORD PTR _area$4$sroa$1659$1$[ebp]

; 3167 : 				dLeft_Cur -= m_daItemWidth[ p_nColumn];

  008e3	f2 0f 10 45 b4	 movsd	 xmm0, QWORD PTR _dLeft_Cur$1$[ebp]
  008e8	0f b7 f0	 movzx	 esi, ax
  008eb	8b 45 08	 mov	 eax, DWORD PTR _p_nColumn$[ebp]

; 3170 : 				m_blAreafDRI[ p_nColumn].PushBack(area);

  008ee	66 89 75 c8	 mov	 WORD PTR _Item$[ebp+4], si
  008f2	f2 0f 5c 84 c7
	a8 01 00 00	 subsd	 xmm0, QWORD PTR [edi+eax*8+424]
  008fb	f2 0f 2c c0	 cvttsd2si eax, xmm0
  008ff	f2 0f 11 45 b4	 movsd	 QWORD PTR _dLeft_Cur$1$[ebp], xmm0
  00904	0f b7 c0	 movzx	 eax, ax
  00907	8b c8		 mov	 ecx, eax
  00909	66 89 45 c4	 mov	 WORD PTR _Item$[ebp], ax
  0090d	98		 cwde
  0090e	89 4d d0	 mov	 DWORD PTR _area$4$sroa$1659$1$[ebp], ecx
  00911	0f bf ce	 movsx	 ecx, si
  00914	03 c1		 add	 eax, ecx
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 173  : 		PushBackUNK(&Item);

  00916	8b 4d cc	 mov	 ecx, DWORD PTR tv2966[ebp]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 3169 : 				area.center = (area.left + area.right) / 2;

  00919	99		 cdq
  0091a	2b c2		 sub	 eax, edx
  0091c	d1 f8		 sar	 eax, 1

; 3170 : 				m_blAreafDRI[ p_nColumn].PushBack(area);

  0091e	66 89 45 c6	 mov	 WORD PTR _Item$[ebp+2], ax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 173  : 		PushBackUNK(&Item);

  00922	8d 45 c4	 lea	 eax, DWORD PTR _Item$[ebp]
  00925	50		 push	 eax
  00926	e8 00 00 00 00	 call	 ?PushBackUNK@CDataBlockListUNK@@QAEXPAX@Z ; CDataBlockListUNK::PushBackUNK
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 3173 : 				if( 0 == p_nColumn && nDRI <= m_nDRI_End_Cur)

  0092b	83 7d 08 00	 cmp	 DWORD PTR _p_nColumn$[ebp], 0
  0092f	75 2d		 jne	 SHORT $LN17@Calc_AREAo
  00931	3b 5f 2c	 cmp	 ebx, DWORD PTR [edi+44]
  00934	7f 28		 jg	 SHORT $LN17@Calc_AREAo
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 227  : 	T* GetNext()	{	return ( T*)GetNextUNK();	}

  00936	8d 8f ac 00 00
	00		 lea	 ecx, DWORD PTR [edi+172]
  0093c	e8 00 00 00 00	 call	 ?GetNextUNK@CDataBlockListUNK@@QAEPAXXZ ; CDataBlockListUNK::GetNextUNK
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 3175 : 					m_pTReturn = m_blTimefDRI.GetNext();

  00941	89 47 5c	 mov	 DWORD PTR [edi+92], eax

; 3176 : 					if( m_pTReturn) PushScaleDataTime( nDRI, *m_pTReturn, nDRI == nRealDRIEnd);

  00944	85 c0		 test	 eax, eax
  00946	74 16		 je	 SHORT $LN17@Calc_AREAo
  00948	33 c9		 xor	 ecx, ecx
  0094a	3b 5d d4	 cmp	 ebx, DWORD PTR _nRealDRIEnd$1$[ebp]
  0094d	0f 94 c1	 sete	 cl
  00950	51		 push	 ecx
  00951	ff 70 04	 push	 DWORD PTR [eax+4]
  00954	8b cf		 mov	 ecx, edi
  00956	ff 30		 push	 DWORD PTR [eax]
  00958	53		 push	 ebx
  00959	e8 00 00 00 00	 call	 ?PushScaleDataTime@CXScaleManagerImp@@IAEXH_JH@Z ; CXScaleManagerImp::PushScaleDataTime
$LN17@Calc_AREAo:

; 3164 : 			for( int nDRI = nDRI_Start_Cur; nDRI <= m_nDRI_End_Cur + 1; nDRI++)		// (2009/3/2 - Seung-Won, Bae) +1 for right of Last Candle

  0095e	8b 4f 2c	 mov	 ecx, DWORD PTR [edi+44]
  00961	43		 inc	 ebx
  00962	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  00965	3b d8		 cmp	 ebx, eax
  00967	0f 8e 73 ff ff
	ff		 jle	 $LL19@Calc_AREAo
$LN18@Calc_AREAo:

; 3177 : 				}
; 3178 : 			}
; 3179 : 		}
; 3180 : 		m_nDRI_End_Pre = m_nDRI_End_Cur;

  0096d	89 8f 24 01 00
	00		 mov	 DWORD PTR [edi+292], ecx
$LN28@Calc_AREAo:

; 3181 : 	}
; 3182 : 	
; 3183 : 	for( int nRQ = 0; nRQ < m_nCountOfRQ; nRQ++)

  00973	33 c9		 xor	 ecx, ecx
  00975	89 4d fc	 mov	 DWORD PTR _nRQ$1$[ebp], ecx
  00978	39 4f 6c	 cmp	 DWORD PTR [edi+108], ecx
  0097b	0f 8e 7c 02 00
	00		 jle	 $LN21@Calc_AREAo
$LL22@Calc_AREAo:

; 3184 : 	{
; 3185 : 		int nDTI_Start_Cur_Org = 0, nDTI_End_Cur_Org = 0;
; 3186 : 		int nDTI_Start_Cur	= GetDTIFromDRI_AbleRange( m_pblaDTIfDRI[nRQ], m_nDRI_Start_Cur,	&nDTI_Start_Cur_Org);

  00981	8b 87 a8 00 00
	00		 mov	 eax, DWORD PTR [edi+168]
  00987	8b 77 28	 mov	 esi, DWORD PTR [edi+40]
  0098a	8b 1c 88	 mov	 ebx, DWORD PTR [eax+ecx*4]

; 1435 : 	if( !pblDTIfDRI) return -1;

  0098d	85 db		 test	 ebx, ebx
  0098f	74 2e		 je	 SHORT $LN201@Calc_AREAo

; 1436 : 
; 1437 : 	int nItemCount = pblDTIfDRI->GetItemCount();

  00991	8b cb		 mov	 ecx, ebx
  00993	e8 00 00 00 00	 call	 ?GetItemCount@CDataBlockListUNK@@QAEHXZ ; CDataBlockListUNK::GetItemCount

; 1438 : 	if( nItemCount == 0) return -1;

  00998	85 c0		 test	 eax, eax
  0099a	74 23		 je	 SHORT $LN201@Calc_AREAo

; 1439 : 
; 1440 : 	if( 0 <= nDRI && nDRI < nItemCount)

  0099c	85 f6		 test	 esi, esi
  0099e	0f 88 9e 00 00
	00		 js	 $LN198@Calc_AREAo
  009a4	3b f0		 cmp	 esi, eax
  009a6	0f 8d 9e 00 00
	00		 jge	 $LN280@Calc_AREAo
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 215  : 	T*	GetAt( int nIndex)	{	return ( T*)GetAtUNK( nIndex);	}

  009ac	56		 push	 esi
  009ad	8b cb		 mov	 ecx, ebx
  009af	e8 00 00 00 00	 call	 ?GetAtUNK@CDataBlockListUNK@@QAEPAXH@Z ; CDataBlockListUNK::GetAtUNK
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 1442 : 		m_pIReturn = pblDTIfDRI->GetAt(nDRI);

  009b4	89 47 60	 mov	 DWORD PTR [edi+96], eax

; 1443 : 		if( m_pIReturn) return *m_pIReturn;

  009b7	85 c0		 test	 eax, eax
  009b9	0f 85 9f 00 00
	00		 jne	 $LN193@Calc_AREAo
$LN201@Calc_AREAo:

; 1470 : 	if( nDTI == -1)	nDTI = 0;

  009bf	83 ce ff	 or	 esi, -1
$LN287@Calc_AREAo:
  009c2	33 c0		 xor	 eax, eax
$LN190@Calc_AREAo:

; 3187 : 		int nDTI_End_Cur	= GetDTIFromDRI_AbleRange( m_pblaDTIfDRI[nRQ], m_nDRI_End_Cur,		&nDTI_End_Cur_Org);

  009c4	8b 4d fc	 mov	 ecx, DWORD PTR _nRQ$1$[ebp]
  009c7	bb fd ff ff ff	 mov	 ebx, -3			; fffffffdH
  009cc	2b d8		 sub	 ebx, eax
  009ce	83 f8 ff	 cmp	 eax, -1
  009d1	0f 4d d8	 cmovge	 ebx, eax
  009d4	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  009d7	89 45 cc	 mov	 DWORD PTR _nDRI$1$[ebp], eax
  009da	8b 87 a8 00 00
	00		 mov	 eax, DWORD PTR [edi+168]
  009e0	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
  009e3	89 45 d0	 mov	 DWORD PTR _pblDTIfDRI$1$[ebp], eax

; 1435 : 	if( !pblDTIfDRI) return -1;

  009e6	85 c0		 test	 eax, eax
  009e8	74 28		 je	 SHORT $LN220@Calc_AREAo

; 1436 : 
; 1437 : 	int nItemCount = pblDTIfDRI->GetItemCount();

  009ea	8b c8		 mov	 ecx, eax
  009ec	e8 00 00 00 00	 call	 ?GetItemCount@CDataBlockListUNK@@QAEHXZ ; CDataBlockListUNK::GetItemCount
  009f1	8b c8		 mov	 ecx, eax

; 1438 : 	if( nItemCount == 0) return -1;

  009f3	85 c9		 test	 ecx, ecx
  009f5	74 1b		 je	 SHORT $LN220@Calc_AREAo

; 1439 : 
; 1440 : 	if( 0 <= nDRI && nDRI < nItemCount)

  009f7	8b 45 cc	 mov	 eax, DWORD PTR _nDRI$1$[ebp]
  009fa	85 c0		 test	 eax, eax
  009fc	78 72		 js	 SHORT $LN217@Calc_AREAo
  009fe	3b c1		 cmp	 eax, ecx
  00a00	7d 72		 jge	 SHORT $LN279@Calc_AREAo
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 215  : 	T*	GetAt( int nIndex)	{	return ( T*)GetAtUNK( nIndex);	}

  00a02	8b 4d d0	 mov	 ecx, DWORD PTR _pblDTIfDRI$1$[ebp]
  00a05	50		 push	 eax
  00a06	e8 00 00 00 00	 call	 ?GetAtUNK@CDataBlockListUNK@@QAEPAXH@Z ; CDataBlockListUNK::GetAtUNK
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 1442 : 		m_pIReturn = pblDTIfDRI->GetAt(nDRI);

  00a0b	89 47 60	 mov	 DWORD PTR [edi+96], eax

; 1443 : 		if( m_pIReturn) return *m_pIReturn;

  00a0e	85 c0		 test	 eax, eax
  00a10	75 75		 jne	 SHORT $LN212@Calc_AREAo
$LN220@Calc_AREAo:

; 1470 : 	if( nDTI == -1)	nDTI = 0;

  00a12	83 c8 ff	 or	 eax, -1
$LN288@Calc_AREAo:
  00a15	33 c9		 xor	 ecx, ecx
$LN209@Calc_AREAo:

; 3187 : 		int nDTI_End_Cur	= GetDTIFromDRI_AbleRange( m_pblaDTIfDRI[nRQ], m_nDRI_End_Cur,		&nDTI_End_Cur_Org);

  00a17	ba fd ff ff ff	 mov	 edx, -3			; fffffffdH
  00a1c	2b d1		 sub	 edx, ecx
  00a1e	83 f9 ff	 cmp	 ecx, -1
  00a21	0f 4d d1	 cmovge	 edx, ecx
  00a24	89 55 d4	 mov	 DWORD PTR _nDTI_End_Cur$1$[ebp], edx

; 3188 : 		
; 3189 : 		if( nDTI_Start_Cur_Org < -1		// Graph is gone to left.
; 3190 : 			|| -1 == nDTI_End_Cur_Org)	// Graph is gone to right.

  00a27	83 fe ff	 cmp	 esi, -1
  00a2a	0f 8c bd 01 00
	00		 jl	 $LN20@Calc_AREAo
  00a30	83 f8 ff	 cmp	 eax, -1
  00a33	0f 84 b4 01 00
	00		 je	 $LN20@Calc_AREAo

; 3191 : 				continue;
; 3192 : 
; 3193 : 		if(nDTI_Start_Cur < 1) nDTI_Start_Cur = 0;

  00a39	83 fb 01	 cmp	 ebx, 1
  00a3c	7d 54		 jge	 SHORT $LN73@Calc_AREAo
  00a3e	33 db		 xor	 ebx, ebx
  00a40	eb 51		 jmp	 SHORT $LN293@Calc_AREAo
$LN198@Calc_AREAo:

; 1446 : 	if( nItemCount <= nDRI)

  00a42	3b c6		 cmp	 eax, esi
  00a44	0f 8f 75 ff ff
	ff		 jg	 $LN201@Calc_AREAo
$LN280@Calc_AREAo:

; 1448 : 		m_pIReturn = pblDTIfDRI->GetAt( nItemCount - 1);	// end mark.

  00a4a	48		 dec	 eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 215  : 	T*	GetAt( int nIndex)	{	return ( T*)GetAtUNK( nIndex);	}

  00a4b	8b cb		 mov	 ecx, ebx
  00a4d	50		 push	 eax
  00a4e	e8 00 00 00 00	 call	 ?GetAtUNK@CDataBlockListUNK@@QAEPAXH@Z ; CDataBlockListUNK::GetAtUNK
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 1448 : 		m_pIReturn = pblDTIfDRI->GetAt( nItemCount - 1);	// end mark.

  00a53	89 47 60	 mov	 DWORD PTR [edi+96], eax

; 1449 : 		if( m_pIReturn) return *m_pIReturn;

  00a56	85 c0		 test	 eax, eax
  00a58	0f 84 61 ff ff
	ff		 je	 $LN201@Calc_AREAo
$LN193@Calc_AREAo:

; 1469 : 	if( pnDTI_Org != NULL) *pnDTI_Org = nDTI;

  00a5e	8b 30		 mov	 esi, DWORD PTR [eax]
  00a60	8b c6		 mov	 eax, esi

; 1470 : 	if( nDTI == -1)	nDTI = 0;

  00a62	83 fe ff	 cmp	 esi, -1
  00a65	0f 85 59 ff ff
	ff		 jne	 $LN190@Calc_AREAo
  00a6b	e9 52 ff ff ff	 jmp	 $LN287@Calc_AREAo
$LN217@Calc_AREAo:

; 1446 : 	if( nItemCount <= nDRI)

  00a70	3b c8		 cmp	 ecx, eax
  00a72	7f 9e		 jg	 SHORT $LN220@Calc_AREAo
$LN279@Calc_AREAo:

; 1448 : 		m_pIReturn = pblDTIfDRI->GetAt( nItemCount - 1);	// end mark.

  00a74	8d 41 ff	 lea	 eax, DWORD PTR [ecx-1]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 215  : 	T*	GetAt( int nIndex)	{	return ( T*)GetAtUNK( nIndex);	}

  00a77	8b 4d d0	 mov	 ecx, DWORD PTR _pblDTIfDRI$1$[ebp]
  00a7a	50		 push	 eax
  00a7b	e8 00 00 00 00	 call	 ?GetAtUNK@CDataBlockListUNK@@QAEPAXH@Z ; CDataBlockListUNK::GetAtUNK
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 1448 : 		m_pIReturn = pblDTIfDRI->GetAt( nItemCount - 1);	// end mark.

  00a80	89 47 60	 mov	 DWORD PTR [edi+96], eax

; 1449 : 		if( m_pIReturn) return *m_pIReturn;

  00a83	85 c0		 test	 eax, eax
  00a85	74 8b		 je	 SHORT $LN220@Calc_AREAo
$LN212@Calc_AREAo:

; 1469 : 	if( pnDTI_Org != NULL) *pnDTI_Org = nDTI;

  00a87	8b 00		 mov	 eax, DWORD PTR [eax]
  00a89	8b c8		 mov	 ecx, eax

; 1470 : 	if( nDTI == -1)	nDTI = 0;

  00a8b	83 f8 ff	 cmp	 eax, -1
  00a8e	75 87		 jne	 SHORT $LN209@Calc_AREAo
  00a90	eb 83		 jmp	 SHORT $LN288@Calc_AREAo
$LN73@Calc_AREAo:

; 3194 : 		else				   nDTI_Start_Cur--;

  00a92	4b		 dec	 ebx
$LN293@Calc_AREAo:

; 3195 : 
; 3196 : 		// (2009/1/14 - Seung-Won, Bae) Support Pixel Arranging.
; 3197 : 		int nDTI_End_Pre	= m_pifaRQ[nRQ]->nDTI_End_Data;

  00a93	8b 87 8c 00 00
	00		 mov	 eax, DWORD PTR [edi+140]
  00a99	8b 75 fc	 mov	 esi, DWORD PTR _nRQ$1$[ebp]

; 3198 : 		if( 2 == m_nCalculationMode)		// 0:No-Calc, 1:CalcByReal, 2:CalcAll
; 3199 : 			nDTI_End_Pre	= nDTI_Start_Cur;
; 3200 : 
; 3201 : 		m_pifaRQ[nRQ]->nDTI_Start_Data = nDTI_Start_Cur;

  00a9c	83 bf 20 01 00
	00 02		 cmp	 DWORD PTR [edi+288], 2
  00aa3	89 5d d0	 mov	 DWORD PTR _nDTI_Start_Cur$1$[ebp], ebx
  00aa6	8b 4d d0	 mov	 ecx, DWORD PTR _nDTI_Start_Cur$1$[ebp]
  00aa9	8b 04 b0	 mov	 eax, DWORD PTR [eax+esi*4]
  00aac	0f 45 58 10	 cmovne	 ebx, DWORD PTR [eax+16]
  00ab0	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 3202 : 		m_pifaRQ[nRQ]->nDTI_End_Data = nDTI_End_Cur;

  00ab3	8b 87 8c 00 00
	00		 mov	 eax, DWORD PTR [edi+140]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 215  : 	T*	GetAt( int nIndex)	{	return ( T*)GetAtUNK( nIndex);	}

  00ab9	53		 push	 ebx
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 3202 : 		m_pifaRQ[nRQ]->nDTI_End_Data = nDTI_End_Cur;

  00aba	8b 04 b0	 mov	 eax, DWORD PTR [eax+esi*4]
  00abd	89 50 10	 mov	 DWORD PTR [eax+16], edx

; 3205 : 		m_pIReturn = m_pblaDRIfDTI[ nRQ]->GetAt( nDTI_End_Pre);

  00ac0	8b 87 a0 00 00
	00		 mov	 eax, DWORD PTR [edi+160]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 215  : 	T*	GetAt( int nIndex)	{	return ( T*)GetAtUNK( nIndex);	}

  00ac6	8b 0c b0	 mov	 ecx, DWORD PTR [eax+esi*4]
  00ac9	e8 00 00 00 00	 call	 ?GetAtUNK@CDataBlockListUNK@@QAEPAXH@Z ; CDataBlockListUNK::GetAtUNK
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 3205 : 		m_pIReturn = m_pblaDRIfDTI[ nRQ]->GetAt( nDTI_End_Pre);

  00ace	89 47 60	 mov	 DWORD PTR [edi+96], eax

; 3206 : 		if( m_pIReturn) nDRI = *m_pIReturn;

  00ad1	85 c0		 test	 eax, eax
  00ad3	0f 84 14 01 00
	00		 je	 $LN20@Calc_AREAo
  00ad9	8b 00		 mov	 eax, DWORD PTR [eax]
  00adb	89 45 ec	 mov	 DWORD PTR _nDRI$1$[ebp], eax

; 3207 : 
; 3208 : 		// (2009/1/3 - Seung-Won, Bae) for Exception. (no data?)
; 3209 : 		if( nDRI < 0) continue;

  00ade	85 c0		 test	 eax, eax
  00ae0	0f 88 07 01 00
	00		 js	 $LN20@Calc_AREAo

; 3210 : 
; 3211 : 		// (2009/1/14 - Seung-Won, Bae) Support Pixel Arranging.
; 3212 : 		if( 1 == m_nCalculationMode)		// 0:No-Calc, 1:CalcByReal, 2:CalcAll

  00ae6	83 bf 20 01 00
	00 01		 cmp	 DWORD PTR [edi+288], 1
  00aed	75 13		 jne	 SHORT $LN78@Calc_AREAo

; 3213 : 			m_pblaAreafDTI[ 0][ nRQ]->DeleteBack( 1);		// for update last DTI AREA.

  00aef	8b 8f 90 05 00
	00		 mov	 ecx, DWORD PTR [edi+1424]
  00af5	6a 01		 push	 1
  00af7	8b 0c b1	 mov	 ecx, DWORD PTR [ecx+esi*4]
  00afa	e8 00 00 00 00	 call	 ?DeleteBack@CDataBlockListUNK@@QAEXH@Z ; CDataBlockListUNK::DeleteBack
  00aff	8b 45 ec	 mov	 eax, DWORD PTR _nDRI$1$[ebp]
$LN78@Calc_AREAo:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\Dll_Load\XScaleManager.h

; 72   : 			left = left_p;

  00b02	33 c9		 xor	 ecx, ecx
  00b04	89 4d d8	 mov	 DWORD PTR _area$6[ebp], ecx

; 74   : 			right = right_p;

  00b07	66 89 4d dc	 mov	 WORD PTR _area$6[ebp+4], cx
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 3216 : 		GetAreaFromDRI_Copy( p_nColumn, nDRI, area);

  00b0b	8d 4d d8	 lea	 ecx, DWORD PTR _area$6[ebp]
  00b0e	51		 push	 ecx
  00b0f	50		 push	 eax
  00b10	ff 75 08	 push	 DWORD PTR _p_nColumn$[ebp]
  00b13	8b cf		 mov	 ecx, edi
  00b15	e8 00 00 00 00	 call	 ?GetAreaFromDRI_Copy@CXScaleManagerImp@@IAEXHHAAUtagAREA@CXScaleManager@@@Z ; CXScaleManagerImp::GetAreaFromDRI_Copy
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\Dll_Load\XScaleManager.h

; 72   : 			left = left_p;

  00b1a	33 c0		 xor	 eax, eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 3218 : 		int nDRI_Next = 0;

  00b1c	33 f6		 xor	 esi, esi
  00b1e	89 75 d0	 mov	 DWORD PTR _nDRI_Next$1$[ebp], esi
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\Dll_Load\XScaleManager.h

; 72   : 			left = left_p;

  00b21	89 45 e0	 mov	 DWORD PTR _area_Next$7[ebp], eax

; 74   : 			right = right_p;

  00b24	66 89 45 e4	 mov	 WORD PTR _area_Next$7[ebp+4], ax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 3220 : 		for( int nDTI = nDTI_End_Pre; nDTI <= nDTI_End_Cur; nDTI++)

  00b28	3b 5d d4	 cmp	 ebx, DWORD PTR _nDTI_End_Cur$1$[ebp]
  00b2b	0f 8f bc 00 00
	00		 jg	 $LN20@Calc_AREAo
$LL25@Calc_AREAo:

; 3222 : 			m_pIReturn = m_pblaDRIfDTI[ nRQ]->GetAt( nDTI + 1);

  00b31	8b 87 a0 00 00
	00		 mov	 eax, DWORD PTR [edi+160]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 215  : 	T*	GetAt( int nIndex)	{	return ( T*)GetAtUNK( nIndex);	}

  00b37	43		 inc	 ebx
  00b38	8b 4d fc	 mov	 ecx, DWORD PTR _nRQ$1$[ebp]
  00b3b	53		 push	 ebx
  00b3c	8b 0c 88	 mov	 ecx, DWORD PTR [eax+ecx*4]
  00b3f	e8 00 00 00 00	 call	 ?GetAtUNK@CDataBlockListUNK@@QAEPAXH@Z ; CDataBlockListUNK::GetAtUNK
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 3222 : 			m_pIReturn = m_pblaDRIfDTI[ nRQ]->GetAt( nDTI + 1);

  00b44	89 47 60	 mov	 DWORD PTR [edi+96], eax

; 3223 : 			if( m_pIReturn) nDRI_Next = *m_pIReturn;

  00b47	85 c0		 test	 eax, eax
  00b49	74 05		 je	 SHORT $LN268@Calc_AREAo
  00b4b	8b 30		 mov	 esi, DWORD PTR [eax]
  00b4d	89 75 d0	 mov	 DWORD PTR _nDRI_Next$1$[ebp], esi
$LN268@Calc_AREAo:

; 3224 : 
; 3225 : 			GetAreaFromDRI_Copy( p_nColumn, nDRI_Next, area_Next);

  00b50	8d 45 e0	 lea	 eax, DWORD PTR _area_Next$7[ebp]
  00b53	8b cf		 mov	 ecx, edi
  00b55	50		 push	 eax
  00b56	56		 push	 esi
  00b57	ff 75 08	 push	 DWORD PTR _p_nColumn$[ebp]
  00b5a	e8 00 00 00 00	 call	 ?GetAreaFromDRI_Copy@CXScaleManagerImp@@IAEXHHAAUtagAREA@CXScaleManager@@@Z ; CXScaleManagerImp::GetAreaFromDRI_Copy

; 3226 : 
; 3227 : 			if( !m_bReverse)

  00b5f	8b ce		 mov	 ecx, esi
  00b61	2b 4d ec	 sub	 ecx, DWORD PTR _nDRI$1$[ebp]
  00b64	83 7f 0c 00	 cmp	 DWORD PTR [edi+12], 0
  00b68	51		 push	 ecx
  00b69	8b cf		 mov	 ecx, edi
  00b6b	75 16		 jne	 SHORT $LN80@Calc_AREAo

; 3228 : 			{
; 3229 : 				area.right = area_Next.left;

  00b6d	66 8b 45 e0	 mov	 ax, WORD PTR _area_Next$7[ebp]
  00b71	66 89 45 dc	 mov	 WORD PTR _area$6[ebp+4], ax

; 3230 : 				ItemIntervalApply( p_nColumn, area, nDRI_Next - nDRI);

  00b75	8d 45 d8	 lea	 eax, DWORD PTR _area$6[ebp]
  00b78	50		 push	 eax
  00b79	ff 75 08	 push	 DWORD PTR _p_nColumn$[ebp]
  00b7c	e8 00 00 00 00	 call	 ?ItemIntervalApply@CXScaleManagerImp@@IAEXHAAUtagAREA@CXScaleManager@@H@Z ; CXScaleManagerImp::ItemIntervalApply

; 3231 : 			}

  00b81	eb 14		 jmp	 SHORT $LN81@Calc_AREAo
$LN80@Calc_AREAo:

; 3232 : 			else
; 3233 : 			{
; 3234 : 				area.left = area_Next.right;

  00b83	66 8b 45 e4	 mov	 ax, WORD PTR _area_Next$7[ebp+4]
  00b87	66 89 45 d8	 mov	 WORD PTR _area$6[ebp], ax

; 3235 : 				ItemIntervalApply_Reverse( p_nColumn, area, nDRI_Next - nDRI);

  00b8b	8d 45 d8	 lea	 eax, DWORD PTR _area$6[ebp]
  00b8e	50		 push	 eax
  00b8f	ff 75 08	 push	 DWORD PTR _p_nColumn$[ebp]
  00b92	e8 00 00 00 00	 call	 ?ItemIntervalApply_Reverse@CXScaleManagerImp@@IAEXHAAUtagAREA@CXScaleManager@@H@Z ; CXScaleManagerImp::ItemIntervalApply_Reverse
$LN81@Calc_AREAo:

; 3236 : 			}
; 3237 : 
; 3238 : 			area.center = (area.left + area.right) / 2;

  00b97	66 8b 75 dc	 mov	 si, WORD PTR _area$6[ebp+4]
  00b9b	0f bf 45 d8	 movsx	 eax, WORD PTR _area$6[ebp]
  00b9f	0f bf ce	 movsx	 ecx, si
  00ba2	03 c1		 add	 eax, ecx

; 3239 : 
; 3240 : 			m_pblaAreafDTI[ p_nColumn][ nRQ]->PushBack(area);

  00ba4	66 89 75 c8	 mov	 WORD PTR _Item$[ebp+4], si
  00ba8	99		 cdq
  00ba9	2b c2		 sub	 eax, edx
  00bab	d1 f8		 sar	 eax, 1
  00bad	66 89 45 da	 mov	 WORD PTR _area$6[ebp+2], ax
  00bb1	8b 45 d8	 mov	 eax, DWORD PTR _area$6[ebp]
  00bb4	89 45 c4	 mov	 DWORD PTR _Item$[ebp], eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 173  : 		PushBackUNK(&Item);

  00bb7	8d 45 c4	 lea	 eax, DWORD PTR _Item$[ebp]
  00bba	50		 push	 eax
  00bbb	8b 45 08	 mov	 eax, DWORD PTR _p_nColumn$[ebp]
  00bbe	8b 8c 87 90 05
	00 00		 mov	 ecx, DWORD PTR [edi+eax*4+1424]
  00bc5	8b 45 fc	 mov	 eax, DWORD PTR _nRQ$1$[ebp]
  00bc8	8b 0c 81	 mov	 ecx, DWORD PTR [ecx+eax*4]
  00bcb	e8 00 00 00 00	 call	 ?PushBackUNK@CDataBlockListUNK@@QAEXPAX@Z ; CDataBlockListUNK::PushBackUNK
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 3242 : 			area = area_Next;

  00bd0	8b 45 e0	 mov	 eax, DWORD PTR _area_Next$7[ebp]

; 3243 : 			nDRI = nDRI_Next;

  00bd3	8b 75 d0	 mov	 esi, DWORD PTR _nDRI_Next$1$[ebp]
  00bd6	89 45 d8	 mov	 DWORD PTR _area$6[ebp], eax
  00bd9	66 8b 45 e4	 mov	 ax, WORD PTR _area_Next$7[ebp+4]
  00bdd	66 89 45 dc	 mov	 WORD PTR _area$6[ebp+4], ax
  00be1	89 75 ec	 mov	 DWORD PTR _nDRI$1$[ebp], esi
  00be4	3b 5d d4	 cmp	 ebx, DWORD PTR _nDTI_End_Cur$1$[ebp]
  00be7	0f 8e 44 ff ff
	ff		 jle	 $LL25@Calc_AREAo
$LN20@Calc_AREAo:

; 3181 : 	}
; 3182 : 	
; 3183 : 	for( int nRQ = 0; nRQ < m_nCountOfRQ; nRQ++)

  00bed	8b 4d fc	 mov	 ecx, DWORD PTR _nRQ$1$[ebp]
  00bf0	41		 inc	 ecx
  00bf1	89 4d fc	 mov	 DWORD PTR _nRQ$1$[ebp], ecx
  00bf4	3b 4f 6c	 cmp	 ecx, DWORD PTR [edi+108]
  00bf7	0f 8c 84 fd ff
	ff		 jl	 $LL22@Calc_AREAo
$LN21@Calc_AREAo:

; 3244 : 		}
; 3245 : 	}
; 3246 : }

  00bfd	5f		 pop	 edi
  00bfe	5e		 pop	 esi
  00bff	5b		 pop	 ebx
  00c00	8b e5		 mov	 esp, ebp
  00c02	5d		 pop	 ebp
  00c03	c2 04 00	 ret	 4
?Calc_AREAofColumn@CXScaleManagerImp@@IAEXH@Z ENDP	; CXScaleManagerImp::Calc_AREAofColumn
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?Calc_AREA@CXScaleManagerImp@@MAEXH@Z
_TEXT	SEGMENT
$T2 = -36						; size = 4
_wTimeDiff$1$ = -32					; size = 4
$T3 = -32						; size = 4
$T4 = -32						; size = 4
_nTimeDiff$5 = -28					; size = 2
_psnXGridTime$6 = -24					; size = 4
tv1157 = -20						; size = 4
_pPacketListMain$1$ = -20				; size = 4
_i$1$ = -16						; size = 4
_strRQ$7 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_pXScaleGridTime$8 = 8					; size = 4
_p_nColumnCount$ = 8					; size = 4
?Calc_AREA@CXScaleManagerImp@@MAEXH@Z PROC		; CXScaleManagerImp::Calc_AREA, COMDAT
; _this$ = ecx

; 2828 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Calc_AREA@CXScaleManagerImp@@MAEXH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 18	 sub	 esp, 24			; 00000018H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b f9		 mov	 edi, ecx

; 2829 : 	m_nCountOfBlockColumn = p_nColumnCount;
; 2830 : 
; 2831 : 	// (2009/5/12 - Seung-Won, Bae) for Fixed Item Width
; 2832 : 	if( m_bOnUserZoomChanged)

  0002a	83 bf cc 05 00
	00 00		 cmp	 DWORD PTR [edi+1484], 0
  00031	8b 4d 08	 mov	 ecx, DWORD PTR _p_nColumnCount$[ebp]
  00034	89 8f 2c 01 00
	00		 mov	 DWORD PTR [edi+300], ecx
  0003a	74 1a		 je	 SHORT $LN131@Calc_AREA

; 2833 : 	{
; 2834 : 		m_dLastItemWidth = m_daItemWidth[ 0];

  0003c	f2 0f 10 87 a8
	01 00 00	 movsd	 xmm0, QWORD PTR [edi+424]
  00044	f2 0f 11 87 d0
	05 00 00	 movsd	 QWORD PTR [edi+1488], xmm0

; 2835 : 		m_bOnUserZoomChanged = FALSE;

  0004c	c7 87 cc 05 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+1484], 0
$LN131@Calc_AREA:

; 2836 : 	}
; 2837 : 
; 2838 : 	// (2009/1/13 - Seung-Won, Bae) for ReCalc AREA
; 2839 : 	// (2009/1/16 - Seung-Won, Bae) Support the Re-Calculation Mode on OCX OnDrawing
; 2840 : 	m_nCalculationMode = 2;					// 0:No-Calc, 1:CalcByReal, 2:CalcAll

  00056	c7 87 20 01 00
	00 02 00 00 00	 mov	 DWORD PTR [edi+288], 2

; 2841 : 	if( 1 == m_nCountOfBlockColumn && 1 == m_nCountOfRQ)

  00060	b8 02 00 00 00	 mov	 eax, 2
  00065	83 f9 01	 cmp	 ecx, 1
  00068	0f 85 21 01 00
	00		 jne	 $LN23@Calc_AREA
  0006e	39 4f 6c	 cmp	 DWORD PTR [edi+108], ecx
  00071	0f 85 18 01 00
	00		 jne	 $LN23@Calc_AREA

; 2842 : 	{
; 2843 : 		if( m_nDRI_Start_Pre == m_nDRI_Start_Cur
; 2844 : 			&& m_nScreenLeft_Pre == m_nScreenLeft_Cur[ 0]
; 2845 : 			&& m_nScreenWidth_Pre == m_nScreenWidth_Cur[ 0]
; 2846 : 			&& m_daItemWidth_Pre == m_daItemWidth[ 0]
; 2847 : 			&& ( m_bReverse_Pre && m_bReverse

  00077	8b 87 04 01 00
	00		 mov	 eax, DWORD PTR [edi+260]
  0007d	3b 47 28	 cmp	 eax, DWORD PTR [edi+40]
  00080	0f 85 b7 00 00
	00		 jne	 $LN31@Calc_AREA
  00086	8b 87 10 01 00
	00		 mov	 eax, DWORD PTR [edi+272]
  0008c	3b 87 f8 01 00
	00		 cmp	 eax, DWORD PTR [edi+504]
  00092	0f 85 a5 00 00
	00		 jne	 $LN31@Calc_AREA
  00098	8b 87 14 01 00
	00		 mov	 eax, DWORD PTR [edi+276]
  0009e	3b 87 38 03 00
	00		 cmp	 eax, DWORD PTR [edi+824]
  000a4	0f 85 93 00 00
	00		 jne	 $LN31@Calc_AREA
  000aa	f2 0f 10 87 18
	01 00 00	 movsd	 xmm0, QWORD PTR [edi+280]
  000b2	66 0f 2e 87 a8
	01 00 00	 ucomisd xmm0, QWORD PTR [edi+424]
  000ba	9f		 lahf
  000bb	f6 c4 44	 test	 ah, 68			; 00000044H
  000be	7a 7d		 jp	 SHORT $LN31@Calc_AREA
  000c0	8b 87 0c 01 00
	00		 mov	 eax, DWORD PTR [edi+268]
  000c6	85 c0		 test	 eax, eax
  000c8	74 0a		 je	 SHORT $LN140@Calc_AREA
  000ca	83 7f 0c 00	 cmp	 DWORD PTR [edi+12], 0
  000ce	75 0a		 jne	 SHORT $LN25@Calc_AREA
  000d0	85 c0		 test	 eax, eax
  000d2	75 69		 jne	 SHORT $LN31@Calc_AREA
$LN140@Calc_AREA:
  000d4	83 7f 0c 00	 cmp	 DWORD PTR [edi+12], 0
  000d8	75 63		 jne	 SHORT $LN31@Calc_AREA
$LN25@Calc_AREA:

; 2848 : 				|| !m_bReverse_Pre && !m_bReverse))
; 2849 : 				m_nCalculationMode = 1;			// 0:No-Calc, 1:CalcByReal, 2:CalcAll
; 2850 : 		if( 1 == m_nCalculationMode				// 0:No-Calc, 1:CalcByReal, 2:CalcAll
; 2851 : 			&& m_nDrawCount_Pre == m_nDrawCount_Cur
; 2852 : 			&& 0 == m_nNeedCalcArea
; 2853 : 			&& ( m_bWeightedVolume_Pre && m_bWeightedVolume

  000da	8b 87 00 01 00
	00		 mov	 eax, DWORD PTR [edi+256]
  000e0	c7 87 20 01 00
	00 01 00 00 00	 mov	 DWORD PTR [edi+288], 1
  000ea	3b 47 30	 cmp	 eax, DWORD PTR [edi+48]
  000ed	75 20		 jne	 SHORT $LN129@Calc_AREA
  000ef	83 bf fc 00 00
	00 00		 cmp	 DWORD PTR [edi+252], 0
  000f6	75 17		 jne	 SHORT $LN129@Calc_AREA
  000f8	83 bf 08 01 00
	00 00		 cmp	 DWORD PTR [edi+264], 0
  000ff	0f 84 8f 01 00
	00		 je	 $LN128@Calc_AREA
  00105	83 7f 10 00	 cmp	 DWORD PTR [edi+16], 0
  00109	0f 85 8f 01 00
	00		 jne	 $LN28@Calc_AREA
$LN129@Calc_AREA:

; 2857 : 			return;
; 2858 : 		}
; 2859 : 		if( 1 == m_nCalculationMode)			// 0:No-Calc, 1:CalcByReal, 2:CalcAll
; 2860 : 			if( 1 != m_nNeedCalcArea
; 2861 : 				|| m_bWeightedVolume
; 2862 : 				|| m_pblaDRIfDTI[ 0]->GetItemCount() < m_nDefaultDataSpace)

  0010f	83 bf fc 00 00
	00 01		 cmp	 DWORD PTR [edi+252], 1
  00116	75 1b		 jne	 SHORT $LN32@Calc_AREA
  00118	83 7f 10 00	 cmp	 DWORD PTR [edi+16], 0
  0011c	75 15		 jne	 SHORT $LN32@Calc_AREA
  0011e	8b 8f a0 00 00
	00		 mov	 ecx, DWORD PTR [edi+160]
  00124	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00126	e8 00 00 00 00	 call	 ?GetItemCount@CDataBlockListUNK@@QAEHXZ ; CDataBlockListUNK::GetItemCount
  0012b	3b 87 28 01 00
	00		 cmp	 eax, DWORD PTR [edi+296]
  00131	7d 0a		 jge	 SHORT $LN31@Calc_AREA
$LN32@Calc_AREA:

; 2863 : 					m_nCalculationMode = 2;			// 0:No-Calc, 1:CalcByReal, 2:CalcAll

  00133	c7 87 20 01 00
	00 02 00 00 00	 mov	 DWORD PTR [edi+288], 2
$LN31@Calc_AREA:

; 2864 : 		m_nDrawCount_Pre		= m_nDrawCount_Cur;		// the data count on view

  0013d	8b 47 30	 mov	 eax, DWORD PTR [edi+48]

; 2865 : 		m_nDRI_Start_Pre		= m_nDRI_Start_Cur;		// the first data index on view
; 2866 : 		m_nScreenLeft_Pre		= m_nScreenLeft_Cur[ 0];	// the graph area left position on view
; 2867 : 		m_nScreenWidth_Pre		= m_nScreenWidth_Cur[ 0];	// the graph area width on view
; 2868 : 		m_daItemWidth_Pre		= m_daItemWidth[ 0];			// the one data width on view

  00140	f2 0f 10 87 a8
	01 00 00	 movsd	 xmm0, QWORD PTR [edi+424]
  00148	89 87 00 01 00
	00		 mov	 DWORD PTR [edi+256], eax
  0014e	8b 47 28	 mov	 eax, DWORD PTR [edi+40]
  00151	89 87 04 01 00
	00		 mov	 DWORD PTR [edi+260], eax
  00157	8b 87 f8 01 00
	00		 mov	 eax, DWORD PTR [edi+504]
  0015d	89 87 10 01 00
	00		 mov	 DWORD PTR [edi+272], eax
  00163	8b 87 38 03 00
	00		 mov	 eax, DWORD PTR [edi+824]
  00169	89 87 14 01 00
	00		 mov	 DWORD PTR [edi+276], eax

; 2869 : 		m_bWeightedVolume_Pre	= m_bWeightedVolume;	// the Weighted Volume option.

  0016f	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00172	89 87 08 01 00
	00		 mov	 DWORD PTR [edi+264], eax

; 2870 : 		m_bReverse_Pre			= m_bReverse;			// the Reverse X option.

  00178	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  0017b	89 87 0c 01 00
	00		 mov	 DWORD PTR [edi+268], eax
  00181	8b 87 20 01 00
	00		 mov	 eax, DWORD PTR [edi+288]
  00187	f2 0f 11 87 18
	01 00 00	 movsd	 QWORD PTR [edi+280], xmm0
$LN23@Calc_AREA:

; 2871 : 	}
; 2872 : 	m_nNeedCalcArea			= 0;					// the Flag on by DRI() with full(2) or partial(1)

  0018f	c7 87 fc 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+252], 0

; 2873 : 
; 2874 : 	int i = 0;
; 2875 : 	// 1.3 Clear full Area Info.
; 2876 : 	if( 1 != m_nCalculationMode)			// 0:No-Calc, 1:CalcByReal, 2:CalcAll

  00199	83 f8 01	 cmp	 eax, 1
  0019c	0f 84 f1 02 00
	00		 je	 $LN14@Calc_AREA

; 2877 : 	{
; 2878 : 		// 1. Recreate Area Info of all RQs
; 2879 : 		// 1.1 Destroy old data.
; 2880 : 		//  
; 2881 : 		for(  i = 0; i < m_nCountOfBlockColumn; i++)

  001a2	83 bf 2c 01 00
	00 00		 cmp	 DWORD PTR [edi+300], 0
  001a9	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$1$[ebp], 0
  001b0	0f 8e 3d 01 00
	00		 jle	 $LN3@Calc_AREA
  001b6	8d 87 88 03 00
	00		 lea	 eax, DWORD PTR [edi+904]
  001bc	89 45 ec	 mov	 DWORD PTR tv1157[ebp], eax
  001bf	8d 9f 90 05 00
	00		 lea	 ebx, DWORD PTR [edi+1424]
$LL4@Calc_AREA:

; 2882 : 		{
; 2883 : 			if( m_pblaAreafDTI[ i])

  001c5	8b 03		 mov	 eax, DWORD PTR [ebx]
  001c7	85 c0		 test	 eax, eax
  001c9	74 2d		 je	 SHORT $LN133@Calc_AREA

; 2884 : 			{
; 2885 : 				for( int nRQ = 0; nRQ < m_nCountOfRQ_Area; nRQ++) delete m_pblaAreafDTI[ i][ nRQ];

  001cb	33 f6		 xor	 esi, esi
  001cd	39 77 54	 cmp	 DWORD PTR [edi+84], esi
  001d0	7e 17		 jle	 SHORT $LN134@Calc_AREA
$LL7@Calc_AREA:
  001d2	8b 03		 mov	 eax, DWORD PTR [ebx]
  001d4	8b 0c b0	 mov	 ecx, DWORD PTR [eax+esi*4]
  001d7	85 c9		 test	 ecx, ecx
  001d9	74 08		 je	 SHORT $LN5@Calc_AREA
  001db	8b 01		 mov	 eax, DWORD PTR [ecx]
  001dd	6a 01		 push	 1
  001df	ff 10		 call	 DWORD PTR [eax]
  001e1	8b 03		 mov	 eax, DWORD PTR [ebx]
$LN5@Calc_AREA:
  001e3	46		 inc	 esi
  001e4	3b 77 54	 cmp	 esi, DWORD PTR [edi+84]
  001e7	7c e9		 jl	 SHORT $LL7@Calc_AREA
$LN134@Calc_AREA:

; 2886 : 				delete [] m_pblaAreafDTI[ i];

  001e9	50		 push	 eax
  001ea	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  001ef	83 c4 04	 add	 esp, 4

; 2887 : 				m_pblaAreafDTI[ i] = NULL;

  001f2	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], 0
$LN133@Calc_AREA:

; 2888 : 			}
; 2889 : 			// 1.2 Create new data.
; 2890 : 			m_pblaAreafDTI[ i] = ( CDataBlockList<AREA>**)(new LPVOID[ m_nCountOfRQ]);

  001f8	8b 47 6c	 mov	 eax, DWORD PTR [edi+108]
  001fb	33 c9		 xor	 ecx, ecx
  001fd	ba 04 00 00 00	 mov	 edx, 4
  00202	f7 e2		 mul	 edx
  00204	0f 90 c1	 seto	 cl
  00207	f7 d9		 neg	 ecx
  00209	0b c8		 or	 ecx, eax
  0020b	51		 push	 ecx
  0020c	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]

; 2891 : 			for( int nRQ = 0; nRQ < m_nCountOfRQ; nRQ++)

  00211	33 f6		 xor	 esi, esi
  00213	89 03		 mov	 DWORD PTR [ebx], eax
  00215	83 c4 04	 add	 esp, 4
  00218	39 77 6c	 cmp	 DWORD PTR [edi+108], esi
  0021b	0f 8e ac 00 00
	00		 jle	 $LN135@Calc_AREA
$LL10@Calc_AREA:

; 2892 : 				m_pblaAreafDTI[ i][ nRQ] = new CDataBlockList<AREA>;

  00221	6a 34		 push	 52			; 00000034H
  00223	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00228	8b c8		 mov	 ecx, eax
  0022a	83 c4 04	 add	 esp, 4
  0022d	89 4d e0	 mov	 DWORD PTR $T4[ebp], ecx
  00230	85 c9		 test	 ecx, ecx
  00232	0f 84 84 00 00
	00		 je	 $LN46@Calc_AREA
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00238	c7 41 28 00 00
	00 00		 mov	 DWORD PTR [ecx+40], 0
  0023f	c7 41 2c 00 00
	00 00		 mov	 DWORD PTR [ecx+44], 0
  00246	c7 41 30 00 00
	00 00		 mov	 DWORD PTR [ecx+48], 0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 24   : 		m_nItemSize = nItemSize;

  0024d	c7 41 04 06 00
	00 00		 mov	 DWORD PTR [ecx+4], 6

; 25   : 		m_nBlockSize = nBlockSize;

  00254	c7 41 08 00 02
	00 00		 mov	 DWORD PTR [ecx+8], 512	; 00000200H

; 26   : 
; 27   : 		m_nItemCount = 0;

  0025b	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 28   : 		m_nFirstBlockStartIndex = 0;

  00262	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 29   : 		m_nLastBlockEndIndex = 0;

  00269	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 30   : 
; 31   : 		m_nIndex = 0;

  00270	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0

; 32   : 		m_nBlockIndex = 0;

  00277	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 33   : 		m_nIndexInBlock = 0;

  0027e	c7 41 24 00 00
	00 00		 mov	 DWORD PTR [ecx+36], 0

; 34   : 		m_lpBlockIndex = NULL;

  00285	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0

; 158  : 	{

  0028c	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CDataBlockList@UtagAREA@CXScaleManager@@$0CAA@@@6B@
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 2892 : 				m_pblaAreafDTI[ i][ nRQ] = new CDataBlockList<AREA>;

  00292	eb 2a		 jmp	 SHORT $LN47@Calc_AREA
$LN128@Calc_AREA:

; 2848 : 				|| !m_bReverse_Pre && !m_bReverse))
; 2849 : 				m_nCalculationMode = 1;			// 0:No-Calc, 1:CalcByReal, 2:CalcAll
; 2850 : 		if( 1 == m_nCalculationMode				// 0:No-Calc, 1:CalcByReal, 2:CalcAll
; 2851 : 			&& m_nDrawCount_Pre == m_nDrawCount_Cur
; 2852 : 			&& 0 == m_nNeedCalcArea
; 2853 : 			&& ( m_bWeightedVolume_Pre && m_bWeightedVolume

  00294	83 7f 10 00	 cmp	 DWORD PTR [edi+16], 0
  00298	0f 85 71 fe ff
	ff		 jne	 $LN129@Calc_AREA
$LN28@Calc_AREA:

; 2854 : 				|| !m_bWeightedVolume_Pre && !m_bWeightedVolume))
; 2855 : 		{
; 2856 : 			m_nCalculationMode = 0;				// 0:No-Calc, 1:CalcByReal, 2:CalcAll

  0029e	c7 87 20 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+288], 0

; 2938 : }

  002a8	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  002ab	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  002b2	59		 pop	 ecx
  002b3	5f		 pop	 edi
  002b4	5e		 pop	 esi
  002b5	5b		 pop	 ebx
  002b6	8b e5		 mov	 esp, ebp
  002b8	5d		 pop	 ebp
  002b9	c2 04 00	 ret	 4
$LN46@Calc_AREA:

; 2892 : 				m_pblaAreafDTI[ i][ nRQ] = new CDataBlockList<AREA>;

  002bc	33 c9		 xor	 ecx, ecx
$LN47@Calc_AREA:
  002be	8b 03		 mov	 eax, DWORD PTR [ebx]
  002c0	89 0c b0	 mov	 DWORD PTR [eax+esi*4], ecx
  002c3	46		 inc	 esi
  002c4	3b 77 6c	 cmp	 esi, DWORD PTR [edi+108]
  002c7	0f 8c 54 ff ff
	ff		 jl	 $LL10@Calc_AREA
$LN135@Calc_AREA:

; 2893 : 
; 2894 : 			m_blAreafDRI[ i].Clear();

  002cd	8b 75 ec	 mov	 esi, DWORD PTR tv1157[ebp]
  002d0	8b ce		 mov	 ecx, esi
  002d2	e8 00 00 00 00	 call	 ?Clear@CDataBlockListUNK@@QAEXXZ ; CDataBlockListUNK::Clear
  002d7	8b 4d f0	 mov	 ecx, DWORD PTR _i$1$[ebp]
  002da	83 c6 34	 add	 esi, 52			; 00000034H
  002dd	41		 inc	 ecx
  002de	89 75 ec	 mov	 DWORD PTR tv1157[ebp], esi
  002e1	83 c3 04	 add	 ebx, 4
  002e4	89 4d f0	 mov	 DWORD PTR _i$1$[ebp], ecx
  002e7	3b 8f 2c 01 00
	00		 cmp	 ecx, DWORD PTR [edi+300]
  002ed	0f 8c d2 fe ff
	ff		 jl	 $LL4@Calc_AREA
$LN3@Calc_AREA:

; 2896 : 		m_nCountOfRQ_Area = m_nCountOfRQ;

  002f3	8b 47 6c	 mov	 eax, DWORD PTR [edi+108]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl

; 567  : 	{ return (m_nCount == 0) ? NULL : BEFORE_START_POSITION; }

  002f6	8b 8f 24 06 00
	00		 mov	 ecx, DWORD PTR [edi+1572]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 2896 : 		m_nCountOfRQ_Area = m_nCountOfRQ;

  002fc	89 47 54	 mov	 DWORD PTR [edi+84], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl

; 567  : 	{ return (m_nCount == 0) ? NULL : BEFORE_START_POSITION; }

  002ff	8b c1		 mov	 eax, ecx
  00301	f7 d8		 neg	 eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 2899 : 		signed short nTimeDiff = 0;

  00303	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _nTimeDiff$5[ebp], 0

; 2900 : 		CXScaleGridTime *pXScaleGridTime = NULL;

  0030a	c7 45 08 00 00
	00 00		 mov	 DWORD PTR _pXScaleGridTime$8[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl

; 567  : 	{ return (m_nCount == 0) ? NULL : BEFORE_START_POSITION; }

  00311	1b c0		 sbb	 eax, eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 2901 : 		POSITION psnXGridTime = m_mapXGridTime.GetStartPosition();

  00313	89 45 e8	 mov	 DWORD PTR _psnXGridTime$6[ebp], eax
  00316	85 c9		 test	 ecx, ecx

; 2902 : 		while( psnXGridTime)

  00318	74 30		 je	 SHORT $LN120@Calc_AREA
  0031a	66 0f 1f 44 00
	00		 npad	 6
$LL11@Calc_AREA:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 2068 : 		{ BASE_CLASS::GetNextAssoc(rPosition, (typename BASE_CLASS::BASE_KEY&)rKey,

  00320	8d 45 08	 lea	 eax, DWORD PTR _pXScaleGridTime$8[ebp]
  00323	50		 push	 eax
  00324	8d 45 e4	 lea	 eax, DWORD PTR _nTimeDiff$5[ebp]
  00327	50		 push	 eax
  00328	8d 45 e8	 lea	 eax, DWORD PTR _psnXGridTime$6[ebp]
  0032b	50		 push	 eax
  0032c	8d 8f 18 06 00
	00		 lea	 ecx, DWORD PTR [edi+1560]
  00332	e8 00 00 00 00	 call	 ?GetNextAssoc@CMapWordToPtr@@QBEXAAPAU__POSITION@@AAGAAPAX@Z ; CMapWordToPtr::GetNextAssoc
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 2905 : 			if( !pXScaleGridTime) continue;

  00337	8b 4d 08	 mov	 ecx, DWORD PTR _pXScaleGridTime$8[ebp]
  0033a	85 c9		 test	 ecx, ecx
  0033c	74 06		 je	 SHORT $LN48@Calc_AREA

; 2906 : 			delete pXScaleGridTime;

  0033e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00340	6a 01		 push	 1
  00342	ff 10		 call	 DWORD PTR [eax]
$LN48@Calc_AREA:

; 2902 : 		while( psnXGridTime)

  00344	83 7d e8 00	 cmp	 DWORD PTR _psnXGridTime$6[ebp], 0
  00348	75 d6		 jne	 SHORT $LL11@Calc_AREA
$LN120@Calc_AREA:

; 2907 : 		}
; 2908 : 		m_mapXGridTime.RemoveAll();

  0034a	8d 8f 18 06 00
	00		 lea	 ecx, DWORD PTR [edi+1560]
  00350	e8 00 00 00 00	 call	 ?RemoveAll@CMapWordToPtr@@QAEXXZ ; CMapWordToPtr::RemoveAll

; 2909 : 		m_mapXGridTime.SetAt( 0, new CXScaleGridTime);

  00355	68 54 03 00 00	 push	 852			; 00000354H
  0035a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0035f	83 c4 04	 add	 esp, 4
  00362	89 45 e0	 mov	 DWORD PTR $T3[ebp], eax
  00365	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0036c	85 c0		 test	 eax, eax
  0036e	74 0b		 je	 SHORT $LN50@Calc_AREA
  00370	8b c8		 mov	 ecx, eax
  00372	e8 00 00 00 00	 call	 ??0CXScaleGridTime@@QAE@XZ ; CXScaleGridTime::CXScaleGridTime
  00377	8b f0		 mov	 esi, eax
  00379	eb 02		 jmp	 SHORT $LN51@Calc_AREA
$LN50@Calc_AREA:
  0037b	33 f6		 xor	 esi, esi
$LN51@Calc_AREA:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl

; 565  : 	{ (*this)[key] = newValue; }

  0037d	6a 00		 push	 0
  0037f	8d 8f 18 06 00
	00		 lea	 ecx, DWORD PTR [edi+1560]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 2909 : 		m_mapXGridTime.SetAt( 0, new CXScaleGridTime);

  00385	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl

; 565  : 	{ (*this)[key] = newValue; }

  0038c	e8 00 00 00 00	 call	 ??ACMapWordToPtr@@QAEAAPAXG@Z ; CMapWordToPtr::operator[]
  00391	89 30		 mov	 DWORD PTR [eax], esi
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 2910 : 		const char *szCurrentRQ = m_pIChartCtrl->GetCurrentRQ();

  00393	8b 4f 50	 mov	 ecx, DWORD PTR [edi+80]
  00396	8b 01		 mov	 eax, DWORD PTR [ecx]
  00398	ff 90 d8 02 00
	00		 call	 DWORD PTR [eax+728]

; 2911 : 		if( szCurrentRQ) if( *szCurrentRQ)

  0039e	85 c0		 test	 eax, eax
  003a0	0f 84 ed 00 00
	00		 je	 $LN14@Calc_AREA
  003a6	80 38 00	 cmp	 BYTE PTR [eax], 0
  003a9	0f 84 e4 00 00
	00		 je	 $LN14@Calc_AREA

; 2912 : 		{
; 2913 : 			CPacketList *pPacketListMain = m_ppacketListManager->GetPacketList( szCurrentRQ);

  003af	8b 4f 48	 mov	 ecx, DWORD PTR [edi+72]
  003b2	50		 push	 eax
  003b3	8b 11		 mov	 edx, DWORD PTR [ecx]
  003b5	ff 52 1c	 call	 DWORD PTR [edx+28]
  003b8	89 45 ec	 mov	 DWORD PTR _pPacketListMain$1$[ebp], eax

; 2914 : 			if( pPacketListMain) for( int nRQ = 0; nRQ < m_nCountOfRQ; nRQ++)

  003bb	85 c0		 test	 eax, eax
  003bd	0f 84 d0 00 00
	00		 je	 $LN14@Calc_AREA
  003c3	33 db		 xor	 ebx, ebx
  003c5	39 5f 6c	 cmp	 DWORD PTR [edi+108], ebx
  003c8	0f 8e c5 00 00
	00		 jle	 $LN14@Calc_AREA
  003ce	66 90		 npad	 2
$LL15@Calc_AREA:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl

; 289  : 		if( nIndex < 0 || nIndex >= m_nSize )

  003d0	85 db		 test	 ebx, ebx
  003d2	0f 88 1e 01 00
	00		 js	 $LN103@Calc_AREA
  003d8	3b 9f 80 00 00
	00		 cmp	 ebx, DWORD PTR [edi+128]
  003de	0f 8d 12 01 00
	00		 jge	 $LN103@Calc_AREA

; 291  : 		return m_pData[nIndex]; }

  003e4	8b 47 7c	 mov	 eax, DWORD PTR [edi+124]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 2916 : 				CString strRQ = m_saRQ.GetAt( nRQ);

  003e7	8d 4d f0	 lea	 ecx, DWORD PTR _strRQ$7[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl

; 291  : 		return m_pData[nIndex]; }

  003ea	8d 04 98	 lea	 eax, DWORD PTR [eax+ebx*4]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 2916 : 				CString strRQ = m_saRQ.GetAt( nRQ);

  003ed	50		 push	 eax
  003ee	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h

; 519  : 		return( GetData()->nDataLength );

  003f4	8b 45 f0	 mov	 eax, DWORD PTR _strRQ$7[ebp]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 2916 : 				CString strRQ = m_saRQ.GetAt( nRQ);

  003f7	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h

; 533  : 		return( GetLength() == 0 );

  003fe	83 78 f4 00	 cmp	 DWORD PTR [eax-12], 0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 2917 : 				if( strRQ.IsEmpty()) continue;

  00402	74 75		 je	 SHORT $LN136@Calc_AREA

; 2918 : 				CPacketList *pPacketList = m_ppacketListManager->GetPacketList( strRQ);

  00404	8b 4f 48	 mov	 ecx, DWORD PTR [edi+72]
  00407	50		 push	 eax
  00408	8b 11		 mov	 edx, DWORD PTR [ecx]
  0040a	ff 52 1c	 call	 DWORD PTR [edx+28]

; 2919 : 				if( !pPacketList) continue;

  0040d	85 c0		 test	 eax, eax
  0040f	74 68		 je	 SHORT $LN136@Calc_AREA

; 2920 : 				WORD wTimeDiff = pPacketList->GetBaseTimeDifference() - pPacketListMain->GetBaseTimeDifference();

  00411	8b c8		 mov	 ecx, eax
  00413	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetBaseTimeDifference@CPacketList@@QAEHXZ
  00419	8b 4d ec	 mov	 ecx, DWORD PTR _pPacketListMain$1$[ebp]
  0041c	8b f0		 mov	 esi, eax
  0041e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetBaseTimeDifference@CPacketList@@QAEHXZ
  00424	2b f0		 sub	 esi, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 2052 : 		{ return BASE_CLASS::Lookup(key, (typename BASE_CLASS::BASE_VALUE&)rValue); }

  00426	8d 4d 08	 lea	 ecx, DWORD PTR _pXScaleGridTime$8[ebp]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 2920 : 				WORD wTimeDiff = pPacketList->GetBaseTimeDifference() - pPacketListMain->GetBaseTimeDifference();

  00429	0f b7 c6	 movzx	 eax, si
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 2052 : 		{ return BASE_CLASS::Lookup(key, (typename BASE_CLASS::BASE_VALUE&)rValue); }

  0042c	51		 push	 ecx
  0042d	50		 push	 eax
  0042e	8d 8f 18 06 00
	00		 lea	 ecx, DWORD PTR [edi+1560]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 2920 : 				WORD wTimeDiff = pPacketList->GetBaseTimeDifference() - pPacketListMain->GetBaseTimeDifference();

  00434	89 45 e0	 mov	 DWORD PTR _wTimeDiff$1$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 2052 : 		{ return BASE_CLASS::Lookup(key, (typename BASE_CLASS::BASE_VALUE&)rValue); }

  00437	e8 00 00 00 00	 call	 ?Lookup@CMapWordToPtr@@QBEHGAAPAX@Z ; CMapWordToPtr::Lookup
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 2921 : 				if( m_mapXGridTime.Lookup( wTimeDiff, pXScaleGridTime)) continue;

  0043c	85 c0		 test	 eax, eax
  0043e	75 39		 jne	 SHORT $LN136@Calc_AREA

; 2922 : 				m_mapXGridTime.SetAt( wTimeDiff, new CXScaleGridTime);

  00440	68 54 03 00 00	 push	 852			; 00000354H
  00445	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0044a	83 c4 04	 add	 esp, 4
  0044d	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax
  00450	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00454	85 c0		 test	 eax, eax
  00456	74 0b		 je	 SHORT $LN52@Calc_AREA
  00458	8b c8		 mov	 ecx, eax
  0045a	e8 00 00 00 00	 call	 ??0CXScaleGridTime@@QAE@XZ ; CXScaleGridTime::CXScaleGridTime
  0045f	8b f0		 mov	 esi, eax
  00461	eb 02		 jmp	 SHORT $LN53@Calc_AREA
$LN52@Calc_AREA:
  00463	33 f6		 xor	 esi, esi
$LN53@Calc_AREA:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl

; 565  : 	{ (*this)[key] = newValue; }

  00465	ff 75 e0	 push	 DWORD PTR _wTimeDiff$1$[ebp]
  00468	8d 8f 18 06 00
	00		 lea	 ecx, DWORD PTR [edi+1560]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 2922 : 				m_mapXGridTime.SetAt( wTimeDiff, new CXScaleGridTime);

  0046e	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl

; 565  : 	{ (*this)[key] = newValue; }

  00472	e8 00 00 00 00	 call	 ??ACMapWordToPtr@@QAEAAPAXG@Z ; CMapWordToPtr::operator[]
  00477	89 30		 mov	 DWORD PTR [eax], esi
$LN136@Calc_AREA:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 2914 : 			if( pPacketListMain) for( int nRQ = 0; nRQ < m_nCountOfRQ; nRQ++)

  00479	8d 4d f0	 lea	 ecx, DWORD PTR _strRQ$7[ebp]
  0047c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00483	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00489	43		 inc	 ebx
  0048a	3b 5f 6c	 cmp	 ebx, DWORD PTR [edi+108]
  0048d	0f 8c 3d ff ff
	ff		 jl	 $LL15@Calc_AREA
$LN14@Calc_AREA:

; 2923 : 			}
; 2924 : 		}
; 2925 : 	}
; 2926 : 
; 2927 : 	// (2009/2/8 - Seung-Won, Bae) Clear Scale Draw Info for Mode 1 and 2.
; 2928 : 	for(  i = 0; i < m_nCountOfBlockColumn; i++)

  00493	8b 87 2c 01 00
	00		 mov	 eax, DWORD PTR [edi+300]
  00499	33 db		 xor	 ebx, ebx
  0049b	85 c0		 test	 eax, eax
  0049d	7e 26		 jle	 SHORT $LN17@Calc_AREA
  0049f	8d b7 64 08 00
	00		 lea	 esi, DWORD PTR [edi+2148]
$LL18@Calc_AREA:

; 2929 : 	{
; 2930 : 		m_blScaleTime[ i].Clear();

  004a5	8d 8e f8 fd ff
	ff		 lea	 ecx, DWORD PTR [esi-520]
  004ab	e8 00 00 00 00	 call	 ?Clear@CDataBlockListUNK@@QAEXXZ ; CDataBlockListUNK::Clear

; 2931 : 		m_blScaleDRI[ i].Clear();

  004b0	8b ce		 mov	 ecx, esi
  004b2	e8 00 00 00 00	 call	 ?Clear@CDataBlockListUNK@@QAEXXZ ; CDataBlockListUNK::Clear
  004b7	8b 87 2c 01 00
	00		 mov	 eax, DWORD PTR [edi+300]
  004bd	43		 inc	 ebx
  004be	83 c6 34	 add	 esi, 52			; 00000034H
  004c1	3b d8		 cmp	 ebx, eax
  004c3	7c e0		 jl	 SHORT $LL18@Calc_AREA
$LN17@Calc_AREA:

; 2932 : 	}
; 2933 : 
; 2934 : 	if( m_nItemCount_Total == 0) return;

  004c5	83 7f 58 00	 cmp	 DWORD PTR [edi+88], 0
  004c9	74 17		 je	 SHORT $LN20@Calc_AREA

; 2935 : 
; 2936 : 	// (2009/2/13 - Seung-Won, Bae) for Multi-Column.
; 2937 : 	for( i = 0; i < m_nCountOfBlockColumn; i++) Calc_AREAofColumn( i);

  004cb	33 f6		 xor	 esi, esi
  004cd	85 c0		 test	 eax, eax
  004cf	7e 11		 jle	 SHORT $LN20@Calc_AREA
$LL21@Calc_AREA:
  004d1	56		 push	 esi
  004d2	8b cf		 mov	 ecx, edi
  004d4	e8 00 00 00 00	 call	 ?Calc_AREAofColumn@CXScaleManagerImp@@IAEXH@Z ; CXScaleManagerImp::Calc_AREAofColumn
  004d9	46		 inc	 esi
  004da	3b b7 2c 01 00
	00		 cmp	 esi, DWORD PTR [edi+300]
  004e0	7c ef		 jl	 SHORT $LL21@Calc_AREA
$LN20@Calc_AREA:

; 2938 : }

  004e2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  004e5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  004ec	59		 pop	 ecx
  004ed	5f		 pop	 edi
  004ee	5e		 pop	 esi
  004ef	5b		 pop	 ebx
  004f0	8b e5		 mov	 esp, ebp
  004f2	5d		 pop	 ebp
  004f3	c2 04 00	 ret	 4
$LN103@Calc_AREA:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl

; 290  : 			AfxThrowInvalidArgException();

  004f6	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN138@Calc_AREA:
  004fb	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Calc_AREA@CXScaleManagerImp@@MAEXH@Z$1:
  00000	68 54 03 00 00	 push	 852			; 00000354H
  00005	8b 45 e0	 mov	 eax, DWORD PTR $T3[ebp]
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000e	83 c4 08	 add	 esp, 8
  00011	c3		 ret	 0
__unwindfunclet$?Calc_AREA@CXScaleManagerImp@@MAEXH@Z$2:
  00012	8d 4d f0	 lea	 ecx, DWORD PTR _strRQ$7[ebp]
  00015	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?Calc_AREA@CXScaleManagerImp@@MAEXH@Z$3:
  0001b	68 54 03 00 00	 push	 852			; 00000354H
  00020	8b 45 dc	 mov	 eax, DWORD PTR $T2[ebp]
  00023	50		 push	 eax
  00024	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00029	83 c4 08	 add	 esp, 8
  0002c	c3		 ret	 0
  0002d	cc		 int	 3
  0002e	cc		 int	 3
  0002f	cc		 int	 3
  00030	cc		 int	 3
  00031	cc		 int	 3
__ehhandler$?Calc_AREA@CXScaleManagerImp@@MAEXH@Z:
  00032	90		 npad	 1
  00033	90		 npad	 1
  00034	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00038	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0003b	8b 4a d8	 mov	 ecx, DWORD PTR [edx-40]
  0003e	33 c8		 xor	 ecx, eax
  00040	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00045	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Calc_AREA@CXScaleManagerImp@@MAEXH@Z
  0004a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Calc_AREA@CXScaleManagerImp@@MAEXH@Z ENDP		; CXScaleManagerImp::Calc_AREA
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?SetDefaultDataSpace@CXScaleManagerImp@@MAEXHH@Z
_TEXT	SEGMENT
_p_nDefaultDataSpace$ = 8				; size = 4
_p_nMinDataCountOnOnePage$ = 12				; size = 4
?SetDefaultDataSpace@CXScaleManagerImp@@MAEXHH@Z PROC	; CXScaleManagerImp::SetDefaultDataSpace, COMDAT
; _this$ = ecx

; 2816 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2817 : 	m_nDefaultDataSpace = p_nDefaultDataSpace;

  00003	8b 45 08	 mov	 eax, DWORD PTR _p_nDefaultDataSpace$[ebp]
  00006	89 81 28 01 00
	00		 mov	 DWORD PTR [ecx+296], eax

; 2818 : 	m_nMinDataCountOnOnePage = p_nMinDataCountOnOnePage;

  0000c	8b 45 0c	 mov	 eax, DWORD PTR _p_nMinDataCountOnOnePage$[ebp]
  0000f	89 41 34	 mov	 DWORD PTR [ecx+52], eax

; 2819 : }

  00012	5d		 pop	 ebp
  00013	c2 08 00	 ret	 8
?SetDefaultDataSpace@CXScaleManagerImp@@MAEXHH@Z ENDP	; CXScaleManagerImp::SetDefaultDataSpace
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.h
;	COMDAT ?SetNeedCalcAreaFlag@CXScaleManagerImp@@MAEXH@Z
_TEXT	SEGMENT
_p_nNeedCalcArea$ = 8					; size = 4
?SetNeedCalcAreaFlag@CXScaleManagerImp@@MAEXH@Z PROC	; CXScaleManagerImp::SetNeedCalcAreaFlag, COMDAT
; _this$ = ecx

; 425  : 						{	if( m_nNeedCalcArea < p_nNeedCalcArea) m_nNeedCalcArea = p_nNeedCalcArea;	}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _p_nNeedCalcArea$[ebp]
  00006	39 81 fc 00 00
	00		 cmp	 DWORD PTR [ecx+252], eax
  0000c	7d 06		 jge	 SHORT $LN2@SetNeedCal
  0000e	89 81 fc 00 00
	00		 mov	 DWORD PTR [ecx+252], eax
$LN2@SetNeedCal:
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
?SetNeedCalcAreaFlag@CXScaleManagerImp@@MAEXH@Z ENDP	; CXScaleManagerImp::SetNeedCalcAreaFlag
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.h
;	COMDAT ?GetCalculationMode@CXScaleManagerImp@@MAEHXZ
_TEXT	SEGMENT
?GetCalculationMode@CXScaleManagerImp@@MAEHXZ PROC	; CXScaleManagerImp::GetCalculationMode, COMDAT
; _this$ = ecx

; 423  : 	virtual int		GetCalculationMode( void)	{	return m_nCalculationMode;	}

  00000	8b 81 20 01 00
	00		 mov	 eax, DWORD PTR [ecx+288]
  00006	c3		 ret	 0
?GetCalculationMode@CXScaleManagerImp@@MAEHXZ ENDP	; CXScaleManagerImp::GetCalculationMode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\Dll_Load\XScaleManager.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\Dll_Load\XScaleManager.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\time.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\time.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\Dll_Load\XScaleManager.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\time.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\time.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\time.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\time.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?Calc_DRI_Merge@CXScaleManagerImp@@MAEXXZ
_TEXT	SEGMENT
_Item$ = -148						; size = 8
_Item$ = -140						; size = 8
_timeTemp$2 = -132					; size = 8
_Item$ = -132						; size = 8
_Item$ = -124						; size = 8
_Item$ = -124						; size = 8
_nItemCount_Prev$1$ = -116				; size = 4
_this$GSCopy$1$ = -112					; size = 4
_nAddedFutureTimeCount$1$ = -108			; size = 4
_timeTemp$1$ = -104					; size = 4
_nDrawCount_Pre$1$ = -104				; size = 4
_nDTI_Count$1$ = -104					; size = 4
_strTime$3 = -104					; size = 4
_nScaleInterval_Sec$2$ = -100				; size = 4
_timeCur$1$ = -100					; size = 4
_nRQ$3$ = -100						; size = 4
_Item$ = -100						; size = 4
_timeTemp$2$ = -96					; size = 4
_nDRI_Start_Pre$1$ = -96				; size = 4
_nCount$1$ = -96					; size = 4
_nRQ$4$ = -96						; size = 4
tv4504 = -96						; size = 4
_strTimeType$4 = -96					; size = 4
_timeResult$1$ = -92					; size = 4
_timeCur$2$ = -92					; size = 4
$T5 = -92						; size = 4
_posTime$1$ = -92					; size = 4
tv4518 = -92						; size = 4
tv4461 = -92						; size = 4
_key$ = -88						; size = 8
_key$ = -88						; size = 8
_timeCur$6 = -88					; size = 8
_timeCur$7 = -88					; size = 8
_timeCur$8 = -88					; size = 8
_timeNext$1$ = -84					; size = 4
_ScaleUnit$1$ = -84					; size = 4
tv4519 = -84						; size = 4
tv4291 = -84						; size = 4
_Item$ = -84						; size = 4
_Item$ = -84						; size = 4
_Item$ = -84						; size = 4
_Item$ = -84						; size = 4
_Item$ = -84						; size = 4
_Item$ = -84						; size = 4
_Item$ = -84						; size = 4
_nDRI$5$ = -80						; size = 4
_nDRI$1$ = -80						; size = 4
_nRQ$1$ = -80						; size = 4
_timeNext$2$ = -76					; size = 4
_nCount$1$ = -76					; size = 4
_nItemCount_Pre$1$ = -76				; size = 4
tv4402 = -76						; size = 4
_Item$ = -76						; size = 4
_Item$ = -76						; size = 4
_Item$ = -76						; size = 4
_Item$ = -76						; size = 4
_Item$ = -76						; size = 4
_pValue$9 = -76						; size = 4
_dTimeCur$1$ = -72					; size = 8
_timeCur$10 = -72					; size = 8
_timeResult$2$ = -68					; size = 4
_timeCur$2$ = -68					; size = 4
_nDTI$1$ = -68						; size = 4
_nRQi$2$ = -68						; size = 4
_nCount$1$ = -68					; size = 4
_plTime$1$ = -68					; size = 4
tv4516 = -68						; size = 4
tv4481 = -68						; size = 4
_naDTI_Cur$1$ = -64					; size = 4
_posTime$1$ = -64					; size = 4
tv4524 = -64						; size = 4
_nScaleInterval_Sec$1$ = -60				; size = 4
_nDRI$3$ = -60						; size = 4
_naIRQ$1$ = -60						; size = 4
_timeCur$1$ = -56					; size = 4
_nScaleInterval_Unit$1$ = -56				; size = 4
_nRQ$1$ = -56						; size = 4
_nDRI$6$ = -56						; size = 4
_i$1$ = -56						; size = 4
_tmResult$11 = -52					; size = 36
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?Calc_DRI_Merge@CXScaleManagerImp@@MAEXXZ PROC		; CXScaleManagerImp::Calc_DRI_Merge, COMDAT
; _this$ = ecx

; 525  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Calc_DRI_Merge@CXScaleManagerImp@@MAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 88 00 00
	00		 sub	 esp, 136		; 00000088H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	56		 push	 esi
  00022	57		 push	 edi
  00023	50		 push	 eax
  00024	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00027	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002d	8b f9		 mov	 edi, ecx
  0002f	89 7d 90	 mov	 DWORD PTR _this$GSCopy$1$[ebp], edi

; 526  : 	// (2009/5/10 - Seung-Won, Bae) Scroll with added and trucated by Real
; 527  : 	int nItemCount_Prev = m_nItemCount_Total;
; 528  : 	if( m_bTruncatedByReal) Calc_DRI();

  00032	83 bf dc 05 00
	00 00		 cmp	 DWORD PTR [edi+1500], 0
  00039	8b 47 58	 mov	 eax, DWORD PTR [edi+88]
  0003c	89 45 8c	 mov	 DWORD PTR _nItemCount_Prev$1$[ebp], eax
  0003f	74 07		 je	 SHORT $LN67@Calc_DRI_M
  00041	8b 07		 mov	 eax, DWORD PTR [edi]
  00043	6a 01		 push	 1
  00045	ff 50 6c	 call	 DWORD PTR [eax+108]
$LN67@Calc_DRI_M:

; 529  : 
; 530  : 	// (2009/5/17 - Seung-Won, Bae) for Future Time Count of Compare Chart with OEBT.
; 531  : 	int nAddedFutureTimeCount = 0;
; 532  : 
; 533  : 	// 2. Make the time line for All RQs.
; 534  : 	int nLastRealDRI = INT_MAX;
; 535  : 	int nRQ = 0;
; 536  : 	for( nRQ = 0; nRQ < m_nCountOfRQ; nRQ++)

  00048	33 c0		 xor	 eax, eax
  0004a	33 d2		 xor	 edx, edx
  0004c	89 55 94	 mov	 DWORD PTR _nAddedFutureTimeCount$1$[ebp], edx
  0004f	89 45 b0	 mov	 DWORD PTR _nRQ$1$[ebp], eax
  00052	39 47 6c	 cmp	 DWORD PTR [edi+108], eax
  00055	0f 8e 80 06 00
	00		 jle	 $LN442@Calc_DRI_M
  0005b	0f 1f 44 00 00	 npad	 5
$LL4@Calc_DRI_M:

; 537  : 	{
; 538  : 		if( !m_pifaRQ[ nRQ]->pTimePacket) continue;

  00060	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00067	8b 87 8c 00 00
	00		 mov	 eax, DWORD PTR [edi+140]
  0006d	8b 04 06	 mov	 eax, DWORD PTR [esi+eax]
  00070	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00073	85 c9		 test	 ecx, ecx
  00075	0f 84 50 06 00
	00		 je	 $LN2@Calc_DRI_M

; 539  : 		// (2009/2/16 - Seung-Won, Bae) Support Non-Time X Scale Manager.
; 540  : 		if( m_pifaRQ[ nRQ]->m_bStringDataType)

  0007b	83 78 34 00	 cmp	 DWORD PTR [eax+52], 0
  0007f	0f 84 d1 00 00
	00		 je	 $LN69@Calc_DRI_M

; 541  : 		{
; 542  : 			if( !m_pifaRQ[ nRQ]->bRealReceived) continue;

  00085	83 78 2c 00	 cmp	 DWORD PTR [eax+44], 0
  00089	0f 84 3c 06 00
	00		 je	 $LN2@Calc_DRI_M

; 543  : 			// Clear Old DRI/DTI Info.
; 544  : 			m_pblaDRIfDTI[ nRQ]->DeleteBack( m_pblaDRIfDTI[ nRQ]->GetItemCount());

  0008f	8b 8f a0 00 00
	00		 mov	 ecx, DWORD PTR [edi+160]
  00095	8b 0c 31	 mov	 ecx, DWORD PTR [ecx+esi]
  00098	e8 00 00 00 00	 call	 ?GetItemCount@CDataBlockListUNK@@QAEHXZ ; CDataBlockListUNK::GetItemCount
  0009d	8b 8f a0 00 00
	00		 mov	 ecx, DWORD PTR [edi+160]
  000a3	50		 push	 eax
  000a4	8b 0c 31	 mov	 ecx, DWORD PTR [ecx+esi]
  000a7	e8 00 00 00 00	 call	 ?DeleteBack@CDataBlockListUNK@@QAEXH@Z ; CDataBlockListUNK::DeleteBack

; 545  : 
; 546  : 			CString strTime;

  000ac	8d 4d 98	 lea	 ecx, DWORD PTR _strTime$3[ebp]
  000af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 547  : 			time_t timeCur = 0;
; 548  : 			CList<CString, CString>* plTime = m_pifaRQ[ nRQ]->pTimePacket->GetstrDataList();

  000b5	8b 87 8c 00 00
	00		 mov	 eax, DWORD PTR [edi+140]
  000bb	0f 57 c0	 xorps	 xmm0, xmm0
  000be	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  000c5	66 0f 13 45 a8	 movlpd	 QWORD PTR _timeCur$8[ebp], xmm0
  000ca	8b 0c 06	 mov	 ecx, DWORD PTR [esi+eax]
  000cd	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  000d0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetstrDataList@CPacket@@QAEPAV?$CList@V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@XZ

; 549  : 			POSITION posTime = plTime->GetHeadPosition();

  000d6	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 550  : 			while( posTime)

  000d9	85 c9		 test	 ecx, ecx
  000db	74 61		 je	 SHORT $LN6@Calc_DRI_M
  000dd	8b 45 ac	 mov	 eax, DWORD PTR _timeCur$8[ebp+4]
  000e0	89 45 bc	 mov	 DWORD PTR _timeCur$2$[ebp], eax
  000e3	8b 45 a8	 mov	 eax, DWORD PTR _timeCur$8[ebp]
  000e6	89 45 9c	 mov	 DWORD PTR _timeCur$1$[ebp], eax
  000e9	0f 1f 80 00 00
	00 00		 npad	 7
$LL5@Calc_DRI_M:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 811  : 	{ CNode* pNode = (CNode*) rPosition;

  000f0	8b c1		 mov	 eax, ecx

; 813  : 		rPosition = (POSITION) pNode->pNext;

  000f2	8b 09		 mov	 ecx, DWORD PTR [ecx]

; 814  : 		return pNode->data; }

  000f4	83 c0 08	 add	 eax, 8
  000f7	89 4d a4	 mov	 DWORD PTR _posTime$1$[ebp], ecx
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 552  : 				strTime = plTime->GetNext( posTime);

  000fa	50		 push	 eax
  000fb	8d 4d 98	 lea	 ecx, DWORD PTR _strTime$3[ebp]
  000fe	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z

; 553  : 				timeCur++;

  00104	8b 4d 9c	 mov	 ecx, DWORD PTR _timeCur$1$[ebp]
  00107	8b 45 bc	 mov	 eax, DWORD PTR _timeCur$2$[ebp]
  0010a	83 c1 01	 add	 ecx, 1
  0010d	89 4d 9c	 mov	 DWORD PTR _timeCur$1$[ebp], ecx
  00110	83 d0 00	 adc	 eax, 0

; 554  : 				m_pblaRQTime[ nRQ]->PushBack( timeCur);

  00113	89 8d 74 ff ff
	ff		 mov	 DWORD PTR _Item$[ebp], ecx
  00119	89 45 bc	 mov	 DWORD PTR _timeCur$2$[ebp], eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 173  : 		PushBackUNK(&Item);

  0011c	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR _Item$[ebp]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 554  : 				m_pblaRQTime[ nRQ]->PushBack( timeCur);

  00122	89 85 78 ff ff
	ff		 mov	 DWORD PTR _Item$[ebp+4], eax
  00128	8b 87 9c 00 00
	00		 mov	 eax, DWORD PTR [edi+156]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 173  : 		PushBackUNK(&Item);

  0012e	51		 push	 ecx
  0012f	8b 0c 06	 mov	 ecx, DWORD PTR [esi+eax]
  00132	e8 00 00 00 00	 call	 ?PushBackUNK@CDataBlockListUNK@@QAEXPAX@Z ; CDataBlockListUNK::PushBackUNK
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 550  : 			while( posTime)

  00137	8b 4d a4	 mov	 ecx, DWORD PTR _posTime$1$[ebp]
  0013a	85 c9		 test	 ecx, ecx
  0013c	75 b2		 jne	 SHORT $LL5@Calc_DRI_M
$LN6@Calc_DRI_M:

; 555  : 			}
; 556  : 
; 557  : 			m_pifaRQ[ nRQ]->bRealReceived = FALSE;

  0013e	8b 87 8c 00 00
	00		 mov	 eax, DWORD PTR [edi+140]

; 558  : 		}

  00144	8d 4d 98	 lea	 ecx, DWORD PTR _strTime$3[ebp]
  00147	8b 04 06	 mov	 eax, DWORD PTR [esi+eax]
  0014a	c7 40 2c 00 00
	00 00		 mov	 DWORD PTR [eax+44], 0
  00151	e9 68 05 00 00	 jmp	 $LN494@Calc_DRI_M
$LN69@Calc_DRI_M:

; 559  : 		else
; 560  : 		{
; 561  : 			//    .
; 562  : 			CList<double, double>* plTime = m_pifaRQ[ nRQ]->pTimePacket->GetnumericDataList();

  00156	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetnumericDataList@CPacket@@QAEPAV?$CList@NN@@XZ
  0015c	89 45 bc	 mov	 DWORD PTR _plTime$1$[ebp], eax

; 563  : 			if( !plTime) return;

  0015f	85 c0		 test	 eax, eax
  00161	0f 84 99 0e 00
	00		 je	 $LN138@Calc_DRI_M

; 564  : 			CString strTimeType = m_pifaRQ[ nRQ]->pTimePacket->GetType();

  00167	8b 8f 8c 00 00
	00		 mov	 ecx, DWORD PTR [edi+140]
  0016d	8d 45 a0	 lea	 eax, DWORD PTR _strTimeType$4[ebp]
  00170	6a 01		 push	 1
  00172	50		 push	 eax
  00173	8b 0c 0e	 mov	 ecx, DWORD PTR [esi+ecx]
  00176	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00179	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetType@CPacket@@QAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@_N@Z

; 565  : 
; 566  : 			// (2009/5/17 - Seung-Won, Bae) for Future Time Count of Compare Chart with OEBT.
; 567  : 			// 1. Get Time Interval to add the future time.
; 568  : 			
; 569  : 			// 2011.01.24 by SYS >>  YYYY()  : / 14Byte  (YYYYMMDDhhmmss)
; 570  : 			//int nScaleInterval_Sec = m_pifaRQ[ nRQ]->nScaleInterval_Sec;
; 571  : 			__int64 nScaleInterval_Sec = m_pifaRQ[ nRQ]->nScaleInterval_Sec;

  0017f	8b 97 8c 00 00
	00		 mov	 edx, DWORD PTR [edi+140]
  00185	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  0018c	8b 0c 16	 mov	 ecx, DWORD PTR [esi+edx]

; 572  : 			// 2011.01.24 by SYS <<
; 573  : 
; 574  : 			if( m_pifaRQ[ nRQ]->eScaleUnit == CScaleBaseData::HORZ_TICK && 0 < m_minScaleInterval_nUnit)

  0018f	83 79 14 05	 cmp	 DWORD PTR [ecx+20], 5
  00193	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00196	89 45 c4	 mov	 DWORD PTR _nScaleInterval_Sec$1$[ebp], eax
  00199	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  0019c	89 45 9c	 mov	 DWORD PTR _nScaleInterval_Sec$2$[ebp], eax
  0019f	75 21		 jne	 SHORT $LN73@Calc_DRI_M
  001a1	8b 87 f4 00 00
	00		 mov	 eax, DWORD PTR [edi+244]
  001a7	89 45 a4	 mov	 DWORD PTR tv4461[ebp], eax
  001aa	85 c0		 test	 eax, eax
  001ac	7e 14		 jle	 SHORT $LN73@Calc_DRI_M

; 575  : 				nScaleInterval_Sec = m_pifaRQ[ nRQ]->nScaleInterval_Unit / m_minScaleInterval_nUnit;

  001ae	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  001b1	99		 cdq
  001b2	f7 7d a4	 idiv	 DWORD PTR tv4461[ebp]
  001b5	99		 cdq
  001b6	89 55 9c	 mov	 DWORD PTR _nScaleInterval_Sec$2$[ebp], edx
  001b9	8b 97 8c 00 00
	00		 mov	 edx, DWORD PTR [edi+140]
  001bf	89 45 c4	 mov	 DWORD PTR _nScaleInterval_Sec$1$[ebp], eax
$LN73@Calc_DRI_M:

; 576  : 
; 577  : 			// 2011.01.27 by SYS >>  YYYY()  : / 14Byte  (YYYYMMDDhhmmss)
; 578  : 			CScaleBaseData::HORZSCALEDRAWERTYPE eDateUnit = m_pifaRQ[ nRQ]->eScaleUnit;
; 579  : 			// 2011.01.27 by SYS <<
; 580  : 
; 581  : 			if( m_pifaRQ[ nRQ]->bRealReceived)

  001c2	83 79 2c 00	 cmp	 DWORD PTR [ecx+44], 0
  001c6	0f 84 9d 03 00
	00		 je	 $LN13@Calc_DRI_M

; 582  : 			{
; 583  : // (2009/3/10 - Seung-Won, Bae) Special Chart X Scale Error TEST
; 584  : #ifdef _DEBUG
; 585  : //				CString strLog;
; 586  : //				CString strValue;
; 587  : //
; 588  : //				strValue.Format( "nPacketDataCount : %d\r\n", plTime->GetCount());
; 589  : //				strLog += strValue;
; 590  : //
; 591  : //				strValue.Format( "nPreLastRealDTI : %d\r\n", m_pifaRQ[ nRQ]->nLastRealDTI);
; 592  : //				strLog += strValue;
; 593  : //
; 594  : //				strValue.Format( "nPreRQTimeCount : %d\r\n", m_pblaRQTime[ nRQ]->GetItemCount());
; 595  : //				strLog += strValue;
; 596  : //
; 597  : //				strValue.Format( "Added Time :\r\n");
; 598  : //				strLog += strValue;
; 599  : //
; 600  : //				CStringList slValues;
; 601  : #endif
; 602  : 
; 603  : 				// (2009/3/11 - Seung-Won, Bae) Check exception for new small data of special chart.
; 604  : 				if( plTime->GetCount() <= m_pifaRQ[ nRQ]->nLastRealDTI)

  001cc	8b 45 bc	 mov	 eax, DWORD PTR _plTime$1$[ebp]
  001cf	89 55 a4	 mov	 DWORD PTR $T5[ebp], edx
  001d2	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  001d5	3b 41 28	 cmp	 eax, DWORD PTR [ecx+40]
  001d8	7f 3f		 jg	 SHORT $LN491@Calc_DRI_M

; 605  : 				{
; 606  : 					m_pifaRQ[ nRQ]->nLastRealDTI = -1;

  001da	c7 41 28 ff ff
	ff ff		 mov	 DWORD PTR [ecx+40], -1

; 607  : 					m_pblaRQTime[ nRQ]->DeleteBack( m_pblaRQTime[ nRQ]->GetItemCount());

  001e1	8b 8f 9c 00 00
	00		 mov	 ecx, DWORD PTR [edi+156]
  001e7	8b 0c 31	 mov	 ecx, DWORD PTR [ecx+esi]
  001ea	e8 00 00 00 00	 call	 ?GetItemCount@CDataBlockListUNK@@QAEHXZ ; CDataBlockListUNK::GetItemCount
  001ef	8b 8f 9c 00 00
	00		 mov	 ecx, DWORD PTR [edi+156]
  001f5	50		 push	 eax
  001f6	8b 0c 31	 mov	 ecx, DWORD PTR [ecx+esi]
  001f9	e8 00 00 00 00	 call	 ?DeleteBack@CDataBlockListUNK@@QAEXH@Z ; CDataBlockListUNK::DeleteBack

; 608  : 					m_pamapSpecialTime[ nRQ]->RemoveAll();

  001fe	8b 8f a4 00 00
	00		 mov	 ecx, DWORD PTR [edi+164]
  00204	8b 0c 31	 mov	 ecx, DWORD PTR [ecx+esi]
  00207	e8 00 00 00 00	 call	 ?RemoveAll@CMapPtrToPtr@@QAEXXZ ; CMapPtrToPtr::RemoveAll
  0020c	8b 97 8c 00 00
	00		 mov	 edx, DWORD PTR [edi+140]
  00212	8b ca		 mov	 ecx, edx
  00214	89 4d a4	 mov	 DWORD PTR $T5[ebp], ecx
  00217	eb 02		 jmp	 SHORT $LN75@Calc_DRI_M
$LN491@Calc_DRI_M:

; 582  : 			{
; 583  : // (2009/3/10 - Seung-Won, Bae) Special Chart X Scale Error TEST
; 584  : #ifdef _DEBUG
; 585  : //				CString strLog;
; 586  : //				CString strValue;
; 587  : //
; 588  : //				strValue.Format( "nPacketDataCount : %d\r\n", plTime->GetCount());
; 589  : //				strLog += strValue;
; 590  : //
; 591  : //				strValue.Format( "nPreLastRealDTI : %d\r\n", m_pifaRQ[ nRQ]->nLastRealDTI);
; 592  : //				strLog += strValue;
; 593  : //
; 594  : //				strValue.Format( "nPreRQTimeCount : %d\r\n", m_pblaRQTime[ nRQ]->GetItemCount());
; 595  : //				strLog += strValue;
; 596  : //
; 597  : //				strValue.Format( "Added Time :\r\n");
; 598  : //				strLog += strValue;
; 599  : //
; 600  : //				CStringList slValues;
; 601  : #endif
; 602  : 
; 603  : 				// (2009/3/11 - Seung-Won, Bae) Check exception for new small data of special chart.
; 604  : 				if( plTime->GetCount() <= m_pifaRQ[ nRQ]->nLastRealDTI)

  00219	8b ca		 mov	 ecx, edx
$LN75@Calc_DRI_M:

; 609  : 				}
; 610  : 
; 611  : 				// Get the minimum DRI for update.
; 612  : 				// and delete last real time data (it maybe changed with new time)
; 613  : 				int nDRI = INT_MAX;
; 614  : 				if( 0 <= m_pifaRQ[ nRQ]->nLastRealDTI)

  0021b	8b 04 16	 mov	 eax, DWORD PTR [esi+edx]
  0021e	8b 50 28	 mov	 edx, DWORD PTR [eax+40]
  00221	85 d2		 test	 edx, edx
  00223	0f 88 af 00 00
	00		 js	 $LN76@Calc_DRI_M

; 615  : 				{
; 616  : 					m_pIReturn = m_pblaDRIfDTI[ nRQ]->GetAt( m_pifaRQ[ nRQ]->nLastRealDTI);

  00229	8b 87 a0 00 00
	00		 mov	 eax, DWORD PTR [edi+160]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 215  : 	T*	GetAt( int nIndex)	{	return ( T*)GetAtUNK( nIndex);	}

  0022f	52		 push	 edx
  00230	8b 0c 06	 mov	 ecx, DWORD PTR [esi+eax]
  00233	e8 00 00 00 00	 call	 ?GetAtUNK@CDataBlockListUNK@@QAEPAXH@Z ; CDataBlockListUNK::GetAtUNK
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 618  : 					for( int i = m_pifaRQ[ nRQ]->nLastRealDTI; i < m_pblaRQTime[ nRQ]->GetItemCount(); i++)

  00238	8b 8f 9c 00 00
	00		 mov	 ecx, DWORD PTR [edi+156]
  0023e	89 47 60	 mov	 DWORD PTR [edi+96], eax
  00241	8b 87 8c 00 00
	00		 mov	 eax, DWORD PTR [edi+140]
  00247	8b 0c 31	 mov	 ecx, DWORD PTR [ecx+esi]
  0024a	8b 04 06	 mov	 eax, DWORD PTR [esi+eax]
  0024d	8b 40 28	 mov	 eax, DWORD PTR [eax+40]
  00250	89 45 c8	 mov	 DWORD PTR _i$1$[ebp], eax
  00253	e8 00 00 00 00	 call	 ?GetItemCount@CDataBlockListUNK@@QAEHXZ ; CDataBlockListUNK::GetItemCount
  00258	8b 4d c8	 mov	 ecx, DWORD PTR _i$1$[ebp]
  0025b	3b c8		 cmp	 ecx, eax
  0025d	7d 47		 jge	 SHORT $LN8@Calc_DRI_M
  0025f	90		 npad	 1
$LL9@Calc_DRI_M:

; 620  : 						m_pTReturn = m_pblaRQTime[ nRQ]->GetAt( i);

  00260	8b 87 9c 00 00
	00		 mov	 eax, DWORD PTR [edi+156]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 215  : 	T*	GetAt( int nIndex)	{	return ( T*)GetAtUNK( nIndex);	}

  00266	51		 push	 ecx
  00267	8b 0c 06	 mov	 ecx, DWORD PTR [esi+eax]
  0026a	e8 00 00 00 00	 call	 ?GetAtUNK@CDataBlockListUNK@@QAEPAXH@Z ; CDataBlockListUNK::GetAtUNK
  0026f	8b c8		 mov	 ecx, eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 620  : 						m_pTReturn = m_pblaRQTime[ nRQ]->GetAt( i);

  00271	89 4f 5c	 mov	 DWORD PTR [edi+92], ecx

; 621  : 						if( m_pTReturn) m_pamapSpecialTime[ nRQ]->RemoveKey( *m_pTReturn);

  00274	85 c9		 test	 ecx, ecx
  00276	74 16		 je	 SHORT $LN7@Calc_DRI_M
  00278	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\Dll_Load\XScaleManager.h

; 34   : 			{	return CMapPtrToPtr::RemoveKey( ( void *)key);	}

  0027b	ff 31		 push	 DWORD PTR [ecx]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 621  : 						if( m_pTReturn) m_pamapSpecialTime[ nRQ]->RemoveKey( *m_pTReturn);

  0027d	89 45 ac	 mov	 DWORD PTR _key$[ebp+4], eax
  00280	8b 87 a4 00 00
	00		 mov	 eax, DWORD PTR [edi+164]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\Dll_Load\XScaleManager.h

; 34   : 			{	return CMapPtrToPtr::RemoveKey( ( void *)key);	}

  00286	8b 0c 06	 mov	 ecx, DWORD PTR [esi+eax]
  00289	e8 00 00 00 00	 call	 ?RemoveKey@CMapPtrToPtr@@QAEHPAX@Z ; CMapPtrToPtr::RemoveKey
$LN7@Calc_DRI_M:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 618  : 					for( int i = m_pifaRQ[ nRQ]->nLastRealDTI; i < m_pblaRQTime[ nRQ]->GetItemCount(); i++)

  0028e	8b 8f 9c 00 00
	00		 mov	 ecx, DWORD PTR [edi+156]
  00294	ff 45 c8	 inc	 DWORD PTR _i$1$[ebp]
  00297	8b 0c 31	 mov	 ecx, DWORD PTR [ecx+esi]
  0029a	e8 00 00 00 00	 call	 ?GetItemCount@CDataBlockListUNK@@QAEHXZ ; CDataBlockListUNK::GetItemCount
  0029f	8b 4d c8	 mov	 ecx, DWORD PTR _i$1$[ebp]
  002a2	3b c8		 cmp	 ecx, eax
  002a4	7c ba		 jl	 SHORT $LL9@Calc_DRI_M
$LN8@Calc_DRI_M:

; 622  : 					}
; 623  : 					// Delete time of Last Real DTI and after
; 624  : 					m_pblaRQTime[ nRQ]->DeleteBack( m_pblaRQTime[ nRQ]->GetItemCount() - m_pifaRQ[ nRQ]->nLastRealDTI);

  002a6	8b 8f 9c 00 00
	00		 mov	 ecx, DWORD PTR [edi+156]
  002ac	8b 0c 31	 mov	 ecx, DWORD PTR [ecx+esi]
  002af	e8 00 00 00 00	 call	 ?GetItemCount@CDataBlockListUNK@@QAEHXZ ; CDataBlockListUNK::GetItemCount
  002b4	8b 8f 8c 00 00
	00		 mov	 ecx, DWORD PTR [edi+140]
  002ba	8b 0c 0e	 mov	 ecx, DWORD PTR [esi+ecx]
  002bd	2b 41 28	 sub	 eax, DWORD PTR [ecx+40]
  002c0	8b 8f 9c 00 00
	00		 mov	 ecx, DWORD PTR [edi+156]
  002c6	50		 push	 eax
  002c7	8b 0c 31	 mov	 ecx, DWORD PTR [ecx+esi]
  002ca	e8 00 00 00 00	 call	 ?DeleteBack@CDataBlockListUNK@@QAEXH@Z ; CDataBlockListUNK::DeleteBack
  002cf	8b 8f 8c 00 00
	00		 mov	 ecx, DWORD PTR [edi+140]
  002d5	89 4d a4	 mov	 DWORD PTR $T5[ebp], ecx
$LN76@Calc_DRI_M:

; 630  : 				if( 0 <= m_pifaRQ[ nRQ]->nLastRealDTI)	posTime = plTime->FindIndex( m_pifaRQ[ nRQ]->nLastRealDTI);

  002d8	8b 04 31	 mov	 eax, DWORD PTR [ecx+esi]
  002db	8b 40 28	 mov	 eax, DWORD PTR [eax+40]
  002de	85 c0		 test	 eax, eax
  002e0	78 1f		 js	 SHORT $LN80@Calc_DRI_M
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 1133 : 	if (nIndex >= m_nCount || nIndex < 0)

  002e2	8b 4d bc	 mov	 ecx, DWORD PTR _plTime$1$[ebp]
  002e5	3b 41 0c	 cmp	 eax, DWORD PTR [ecx+12]
  002e8	7d 13		 jge	 SHORT $LN160@Calc_DRI_M

; 1135 : 
; 1136 : 	CNode* pNode = m_pNodeHead;

  002ea	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  002ed	89 4d c0	 mov	 DWORD PTR _posTime$1$[ebp], ecx

; 1137 : 	while (nIndex--)

  002f0	85 c0		 test	 eax, eax
  002f2	74 16		 je	 SHORT $LN81@Calc_DRI_M
$LL157@Calc_DRI_M:

; 1138 : 	{
; 1139 : 		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 1140 : 		pNode = pNode->pNext;

  002f4	8b 09		 mov	 ecx, DWORD PTR [ecx]
  002f6	83 e8 01	 sub	 eax, 1
  002f9	75 f9		 jne	 SHORT $LL157@Calc_DRI_M

; 1141 : 	}
; 1142 : 	return (POSITION) pNode;

  002fb	eb 0a		 jmp	 SHORT $LN495@Calc_DRI_M
$LN160@Calc_DRI_M:

; 1134 : 		return NULL;  // went too far

  002fd	33 c9		 xor	 ecx, ecx
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 630  : 				if( 0 <= m_pifaRQ[ nRQ]->nLastRealDTI)	posTime = plTime->FindIndex( m_pifaRQ[ nRQ]->nLastRealDTI);

  002ff	eb 06		 jmp	 SHORT $LN495@Calc_DRI_M
$LN80@Calc_DRI_M:

; 631  : 				else									posTime = plTime->GetHeadPosition();

  00301	8b 45 bc	 mov	 eax, DWORD PTR _plTime$1$[ebp]
  00304	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
$LN495@Calc_DRI_M:

; 632  : 				time_t timeCur = 0;

  00307	89 4d c0	 mov	 DWORD PTR _posTime$1$[ebp], ecx
$LN81@Calc_DRI_M:

; 633  : 				double dTimeCur = 0.0;
; 634  : 				tm tmResult = { 0, 0, 0, 0, 0, 0, 0, 0, -1};	//[A00000554]alzioyes:20110530  .
; 635  : 				if( 0 < m_pifaRQ[ nRQ]->nLastRealDTI)

  0030a	8b 45 a4	 mov	 eax, DWORD PTR $T5[ebp]
  0030d	0f 57 c0	 xorps	 xmm0, xmm0
  00310	0f 11 45 cc	 movups	 XMMWORD PTR _tmResult$11[ebp], xmm0
  00314	c7 45 ec ff ff
	ff ff		 mov	 DWORD PTR _tmResult$11[ebp+32], -1
  0031b	0f 11 45 dc	 movups	 XMMWORD PTR _tmResult$11[ebp+16], xmm0
  0031f	8b 04 30	 mov	 eax, DWORD PTR [eax+esi]
  00322	66 0f 13 45 a8	 movlpd	 QWORD PTR _timeCur$7[ebp], xmm0
  00327	8b 40 28	 mov	 eax, DWORD PTR [eax+40]
  0032a	85 c0		 test	 eax, eax
  0032c	7e 44		 jle	 SHORT $LN283@Calc_DRI_M

; 637  : 					m_pTReturn = m_pblaRQTime[ nRQ]->GetAt( m_pifaRQ[ nRQ]->nLastRealDTI - 1);

  0032e	8d 48 ff	 lea	 ecx, DWORD PTR [eax-1]
  00331	8b 87 9c 00 00
	00		 mov	 eax, DWORD PTR [edi+156]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 215  : 	T*	GetAt( int nIndex)	{	return ( T*)GetAtUNK( nIndex);	}

  00337	51		 push	 ecx
  00338	8b 0c 06	 mov	 ecx, DWORD PTR [esi+eax]
  0033b	e8 00 00 00 00	 call	 ?GetAtUNK@CDataBlockListUNK@@QAEPAXH@Z ; CDataBlockListUNK::GetAtUNK
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 637  : 					m_pTReturn = m_pblaRQTime[ nRQ]->GetAt( m_pifaRQ[ nRQ]->nLastRealDTI - 1);

  00340	89 47 5c	 mov	 DWORD PTR [edi+92], eax

; 638  : 					if( m_pTReturn)

  00343	85 c0		 test	 eax, eax
  00345	74 28		 je	 SHORT $LN487@Calc_DRI_M
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\time.h

; 499  :             return _localtime64(_Time);

  00347	50		 push	 eax
  00348	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___localtime64
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 641  : 						if( ptm) tmResult = *ptm;

  0034e	8b 4d c0	 mov	 ecx, DWORD PTR _posTime$1$[ebp]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\time.h

; 499  :             return _localtime64(_Time);

  00351	83 c4 04	 add	 esp, 4
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 641  : 						if( ptm) tmResult = *ptm;

  00354	85 c0		 test	 eax, eax
  00356	74 1a		 je	 SHORT $LN283@Calc_DRI_M
  00358	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  0035b	0f 11 45 cc	 movups	 XMMWORD PTR _tmResult$11[ebp], xmm0
  0035f	0f 10 40 10	 movups	 xmm0, XMMWORD PTR [eax+16]
  00363	0f 11 45 dc	 movups	 XMMWORD PTR _tmResult$11[ebp+16], xmm0
  00367	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  0036a	89 45 ec	 mov	 DWORD PTR _tmResult$11[ebp+32], eax
  0036d	eb 03		 jmp	 SHORT $LN283@Calc_DRI_M
$LN487@Calc_DRI_M:

; 638  : 					if( m_pTReturn)

  0036f	8b 4d c0	 mov	 ecx, DWORD PTR _posTime$1$[ebp]
$LN283@Calc_DRI_M:

; 645  : 				while( posTime)

  00372	85 c9		 test	 ecx, ecx
  00374	0f 84 a2 00 00
	00		 je	 $LN455@Calc_DRI_M
  0037a	66 0f 1f 44 00
	00		 npad	 6
$LL10@Calc_DRI_M:

; 647  : 					dTimeCur = plTime->GetNext( posTime);

  00380	f2 0f 10 41 08	 movsd	 xmm0, QWORD PTR [ecx+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 811  : 	{ CNode* pNode = (CNode*) rPosition;

  00385	8d 01		 lea	 eax, DWORD PTR [ecx]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 658  : 					timeCur = GetTimeFromTimeValue( ( __int64)dTimeCur, strTimeType, m_pifaRQ[ nRQ], tmResult, m_saRQ.GetAt( nRQ), m_pamapSpecialTime[ nRQ]);

  00387	8b 87 a4 00 00
	00		 mov	 eax, DWORD PTR [edi+164]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 813  : 		rPosition = (POSITION) pNode->pNext;

  0038d	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0038f	89 4d c0	 mov	 DWORD PTR _posTime$1$[ebp], ecx
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 647  : 					dTimeCur = plTime->GetNext( posTime);

  00392	f2 0f 11 45 b8	 movsd	 QWORD PTR _dTimeCur$1$[ebp], xmm0

; 658  : 					timeCur = GetTimeFromTimeValue( ( __int64)dTimeCur, strTimeType, m_pifaRQ[ nRQ], tmResult, m_saRQ.GetAt( nRQ), m_pamapSpecialTime[ nRQ]);

  00397	ff 34 30	 push	 DWORD PTR [eax+esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl

; 289  : 		if( nIndex < 0 || nIndex >= m_nSize )

  0039a	8b 45 b0	 mov	 eax, DWORD PTR _nRQ$1$[ebp]
  0039d	85 c0		 test	 eax, eax
  0039f	0f 88 76 0c 00
	00		 js	 $LN305@Calc_DRI_M
  003a5	3b 87 80 00 00
	00		 cmp	 eax, DWORD PTR [edi+128]
  003ab	0f 8d 6a 0c 00
	00		 jge	 $LN305@Calc_DRI_M

; 291  : 		return m_pData[nIndex]; }

  003b1	8b 47 7c	 mov	 eax, DWORD PTR [edi+124]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 658  : 					timeCur = GetTimeFromTimeValue( ( __int64)dTimeCur, strTimeType, m_pifaRQ[ nRQ], tmResult, m_saRQ.GetAt( nRQ), m_pamapSpecialTime[ nRQ]);

  003b4	ff 34 30	 push	 DWORD PTR [eax+esi]
  003b7	8d 45 cc	 lea	 eax, DWORD PTR _tmResult$11[ebp]
  003ba	50		 push	 eax
  003bb	8b 87 8c 00 00
	00		 mov	 eax, DWORD PTR [edi+140]
  003c1	ff 34 06	 push	 DWORD PTR [esi+eax]
  003c4	8d 45 a0	 lea	 eax, DWORD PTR _strTimeType$4[ebp]
  003c7	51		 push	 ecx
  003c8	8b cc		 mov	 ecx, esp
  003ca	50		 push	 eax
  003cb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z
  003d1	f2 0f 10 45 b8	 movsd	 xmm0, QWORD PTR _dTimeCur$1$[ebp]
  003d6	e8 00 00 00 00	 call	 __dtol3
  003db	52		 push	 edx
  003dc	50		 push	 eax
  003dd	8b cf		 mov	 ecx, edi
  003df	e8 00 00 00 00	 call	 ?GetTimeFromTimeValue@CXScaleManagerImp@@IAE_J_KV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAUtagRQ_INFO@1@AAUtm@@PBDPAVCMapTimeToLong@@@Z ; CXScaleManagerImp::GetTimeFromTimeValue
  003e4	8b c8		 mov	 ecx, eax
  003e6	89 45 c8	 mov	 DWORD PTR _timeCur$1$[ebp], eax
  003e9	8b c2		 mov	 eax, edx

; 661  : 					m_pblaRQTime[ nRQ]->PushBack( timeCur);

  003eb	89 8d 6c ff ff
	ff		 mov	 DWORD PTR _Item$[ebp], ecx
  003f1	89 85 70 ff ff
	ff		 mov	 DWORD PTR _Item$[ebp+4], eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 173  : 		PushBackUNK(&Item);

  003f7	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _Item$[ebp]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 661  : 					m_pblaRQTime[ nRQ]->PushBack( timeCur);

  003fd	8b 87 9c 00 00
	00		 mov	 eax, DWORD PTR [edi+156]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 173  : 		PushBackUNK(&Item);

  00403	51		 push	 ecx
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 658  : 					timeCur = GetTimeFromTimeValue( ( __int64)dTimeCur, strTimeType, m_pifaRQ[ nRQ], tmResult, m_saRQ.GetAt( nRQ), m_pamapSpecialTime[ nRQ]);

  00404	89 55 a4	 mov	 DWORD PTR _timeCur$2$[ebp], edx
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 173  : 		PushBackUNK(&Item);

  00407	8b 0c 06	 mov	 ecx, DWORD PTR [esi+eax]
  0040a	e8 00 00 00 00	 call	 ?PushBackUNK@CDataBlockListUNK@@QAEXPAX@Z ; CDataBlockListUNK::PushBackUNK
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 645  : 				while( posTime)

  0040f	8b 4d c0	 mov	 ecx, DWORD PTR _posTime$1$[ebp]
  00412	85 c9		 test	 ecx, ecx
  00414	0f 85 66 ff ff
	ff		 jne	 $LL10@Calc_DRI_M
  0041a	eb 0c		 jmp	 SHORT $LN11@Calc_DRI_M
$LN455@Calc_DRI_M:
  0041c	8b 45 ac	 mov	 eax, DWORD PTR _timeCur$7[ebp+4]
  0041f	8b 4d a8	 mov	 ecx, DWORD PTR _timeCur$7[ebp]
  00422	89 45 a4	 mov	 DWORD PTR _timeCur$2$[ebp], eax
  00425	89 4d c8	 mov	 DWORD PTR _timeCur$1$[ebp], ecx
$LN11@Calc_DRI_M:

; 662  : 				}
; 663  : 				m_pifaRQ[ nRQ]->bRealReceived = FALSE;

  00428	8b 75 b0	 mov	 esi, DWORD PTR _nRQ$1$[ebp]
  0042b	8b 87 8c 00 00
	00		 mov	 eax, DWORD PTR [edi+140]
  00431	c1 e6 02	 shl	 esi, 2
  00434	89 75 bc	 mov	 DWORD PTR tv4481[ebp], esi
  00437	8b 04 06	 mov	 eax, DWORD PTR [esi+eax]
  0043a	c7 40 2c 00 00
	00 00		 mov	 DWORD PTR [eax+44], 0

; 664  : 				m_pifaRQ[ nRQ]->nLastRealDTI = m_pblaRQTime[ nRQ]->GetItemCount() - 1;

  00441	8b 8f 9c 00 00
	00		 mov	 ecx, DWORD PTR [edi+156]
  00447	8b 0c 31	 mov	 ecx, DWORD PTR [ecx+esi]
  0044a	e8 00 00 00 00	 call	 ?GetItemCount@CDataBlockListUNK@@QAEHXZ ; CDataBlockListUNK::GetItemCount
  0044f	8d 48 ff	 lea	 ecx, DWORD PTR [eax-1]
  00452	8b 87 8c 00 00
	00		 mov	 eax, DWORD PTR [edi+140]
  00458	8b 04 06	 mov	 eax, DWORD PTR [esi+eax]
  0045b	89 48 28	 mov	 DWORD PTR [eax+40], ecx

; 665  : 
; 666  : 
; 667  : 				// (2009/5/28 - Seung-Won, Bae) the future can be steady special time.
; 668  : 				m_pifaRQ[ nRQ]->m_lEndSpecialTimeCode = 0;

  0045e	8b 87 8c 00 00
	00		 mov	 eax, DWORD PTR [edi+140]
  00464	8b 04 06	 mov	 eax, DWORD PTR [esi+eax]
  00467	c7 40 38 00 00
	00 00		 mov	 DWORD PTR [eax+56], 0

; 669  : 				if( 0 <= m_pifaRQ[ nRQ]->nLastRealDTI)

  0046e	8b 87 8c 00 00
	00		 mov	 eax, DWORD PTR [edi+140]
  00474	8b 04 06	 mov	 eax, DWORD PTR [esi+eax]
  00477	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  0047a	85 c9		 test	 ecx, ecx
  0047c	78 5b		 js	 SHORT $LN87@Calc_DRI_M

; 671  : 					m_pTReturn = m_pblaRQTime[ nRQ]->GetAt( m_pifaRQ[ nRQ]->nLastRealDTI);

  0047e	8b 87 9c 00 00
	00		 mov	 eax, DWORD PTR [edi+156]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 215  : 	T*	GetAt( int nIndex)	{	return ( T*)GetAtUNK( nIndex);	}

  00484	51		 push	 ecx
  00485	8b 0c 06	 mov	 ecx, DWORD PTR [esi+eax]
  00488	e8 00 00 00 00	 call	 ?GetAtUNK@CDataBlockListUNK@@QAEPAXH@Z ; CDataBlockListUNK::GetAtUNK
  0048d	8b d0		 mov	 edx, eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 671  : 					m_pTReturn = m_pblaRQTime[ nRQ]->GetAt( m_pifaRQ[ nRQ]->nLastRealDTI);

  0048f	89 57 5c	 mov	 DWORD PTR [edi+92], edx

; 672  : 					if( m_pTReturn) if( !m_pamapSpecialTime[ nRQ]->Lookup( *m_pTReturn, m_pifaRQ[ nRQ]->m_lEndSpecialTimeCode))

  00492	85 d2		 test	 edx, edx
  00494	74 43		 je	 SHORT $LN87@Calc_DRI_M
  00496	8b 8f 8c 00 00
	00		 mov	 ecx, DWORD PTR [edi+140]
  0049c	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0049f	89 45 ac	 mov	 DWORD PTR _key$[ebp+4], eax
  004a2	8b 87 a4 00 00
	00		 mov	 eax, DWORD PTR [edi+164]
  004a8	8b 34 0e	 mov	 esi, DWORD PTR [esi+ecx]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\Dll_Load\XScaleManager.h

; 38   : 				BOOL bResult = CMapPtrToPtr::Lookup( ( void *)key, pValue);

  004ab	8d 4d b4	 lea	 ecx, DWORD PTR _pValue$9[ebp]
  004ae	51		 push	 ecx
  004af	8b 4d bc	 mov	 ecx, DWORD PTR tv4481[ebp]
  004b2	ff 32		 push	 DWORD PTR [edx]
  004b4	8b 0c 01	 mov	 ecx, DWORD PTR [ecx+eax]
  004b7	e8 00 00 00 00	 call	 ?Lookup@CMapPtrToPtr@@QBEHPAXAAPAX@Z ; CMapPtrToPtr::Lookup

; 39   : 				rValue = ( long)pValue;

  004bc	8b 4d b4	 mov	 ecx, DWORD PTR _pValue$9[ebp]
  004bf	89 4e 38	 mov	 DWORD PTR [esi+56], ecx
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 672  : 					if( m_pTReturn) if( !m_pamapSpecialTime[ nRQ]->Lookup( *m_pTReturn, m_pifaRQ[ nRQ]->m_lEndSpecialTimeCode))

  004c2	8b 75 bc	 mov	 esi, DWORD PTR tv4481[ebp]
  004c5	85 c0		 test	 eax, eax
  004c7	75 10		 jne	 SHORT $LN87@Calc_DRI_M

; 673  : 						m_pifaRQ[ nRQ]->m_lEndSpecialTimeCode = 0;

  004c9	8b 87 8c 00 00
	00		 mov	 eax, DWORD PTR [edi+140]
  004cf	8b 04 06	 mov	 eax, DWORD PTR [esi+eax]
  004d2	c7 40 38 00 00
	00 00		 mov	 DWORD PTR [eax+56], 0
$LN87@Calc_DRI_M:

; 674  : 				}
; 675  : 
; 676  : 				// (2009/5/17 - Seung-Won, Bae) for Future Time Count of Compare Chart with OEBT.
; 677  : 				// 2. Get the future time count of OEBT.
; 678  : 				if( m_pifaOEBT[ nRQ])

  004d9	8b 87 90 00 00
	00		 mov	 eax, DWORD PTR [edi+144]
  004df	8b 04 06	 mov	 eax, DWORD PTR [esi+eax]
  004e2	85 c0		 test	 eax, eax
  004e4	0f 84 7f 00 00
	00		 je	 $LN13@Calc_DRI_M

; 680  : 					for( int nCount = 0; nCount < m_pifaOEBT[ nRQ]->nFutureCount; nCount++)

  004ea	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  004ee	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _nCount$1$[ebp], 0
  004f5	7e 72		 jle	 SHORT $LN13@Calc_DRI_M
$LL14@Calc_DRI_M:

; 681  : 					{
; 682  : 						timeCur += nScaleInterval_Sec;

  004f7	8b 45 c8	 mov	 eax, DWORD PTR _timeCur$1$[ebp]
  004fa	03 45 c4	 add	 eax, DWORD PTR _nScaleInterval_Sec$1$[ebp]
  004fd	8b 4d a4	 mov	 ecx, DWORD PTR _timeCur$2$[ebp]
  00500	13 4d 9c	 adc	 ecx, DWORD PTR _nScaleInterval_Sec$2$[ebp]
  00503	89 45 c8	 mov	 DWORD PTR _timeCur$1$[ebp], eax

; 683  : 						m_pblaRQTime[ nRQ]->PushBack( timeCur);

  00506	89 45 84	 mov	 DWORD PTR _Item$[ebp], eax
  00509	8b 87 9c 00 00
	00		 mov	 eax, DWORD PTR [edi+156]
  0050f	89 4d a4	 mov	 DWORD PTR _timeCur$2$[ebp], ecx
  00512	89 4d 88	 mov	 DWORD PTR _Item$[ebp+4], ecx
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 173  : 		PushBackUNK(&Item);

  00515	8d 4d 84	 lea	 ecx, DWORD PTR _Item$[ebp]
  00518	51		 push	 ecx
  00519	8b 0c 06	 mov	 ecx, DWORD PTR [esi+eax]
  0051c	e8 00 00 00 00	 call	 ?PushBackUNK@CDataBlockListUNK@@QAEXPAX@Z ; CDataBlockListUNK::PushBackUNK
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 687  : 						if( m_pifaRQ[ nRQ]->m_lEndSpecialTimeCode && CChartInfo::WORLD_ON != m_eChartMode)

  00521	8b 87 8c 00 00
	00		 mov	 eax, DWORD PTR [edi+140]
  00527	8b 04 06	 mov	 eax, DWORD PTR [esi+eax]
  0052a	8b 40 38	 mov	 eax, DWORD PTR [eax+56]
  0052d	89 45 c0	 mov	 DWORD PTR tv4524[ebp], eax
  00530	85 c0		 test	 eax, eax
  00532	74 20		 je	 SHORT $LN12@Calc_DRI_M
  00534	83 bf e8 05 00
	00 03		 cmp	 DWORD PTR [edi+1512], 3
  0053b	74 17		 je	 SHORT $LN12@Calc_DRI_M

; 688  : 							m_pamapSpecialTime[ nRQ]->SetAt( timeCur, m_pifaRQ[ nRQ]->m_lEndSpecialTimeCode);

  0053d	8b 87 a4 00 00
	00		 mov	 eax, DWORD PTR [edi+164]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl

; 597  : 	{ (*this)[key] = newValue; }

  00543	8b 4d c8	 mov	 ecx, DWORD PTR _timeCur$1$[ebp]
  00546	51		 push	 ecx
  00547	8b 0c 06	 mov	 ecx, DWORD PTR [esi+eax]
  0054a	e8 00 00 00 00	 call	 ??ACMapPtrToPtr@@QAEAAPAXPAX@Z ; CMapPtrToPtr::operator[]
  0054f	8b 4d c0	 mov	 ecx, DWORD PTR tv4524[ebp]
  00552	89 08		 mov	 DWORD PTR [eax], ecx
$LN12@Calc_DRI_M:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 680  : 					for( int nCount = 0; nCount < m_pifaOEBT[ nRQ]->nFutureCount; nCount++)

  00554	8b 87 90 00 00
	00		 mov	 eax, DWORD PTR [edi+144]
  0055a	8b 4d bc	 mov	 ecx, DWORD PTR _nCount$1$[ebp]
  0055d	41		 inc	 ecx
  0055e	89 4d bc	 mov	 DWORD PTR _nCount$1$[ebp], ecx
  00561	8b 04 06	 mov	 eax, DWORD PTR [esi+eax]
  00564	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00567	7c 8e		 jl	 SHORT $LL14@Calc_DRI_M
$LN13@Calc_DRI_M:

; 689  : 					}
; 690  : 				}
; 691  : 			}
; 692  : 
; 693  : // (2009/3/10 - Seung-Won, Bae) Special Chart X Scale Error TEST
; 694  : #ifdef _DEBUG
; 695  : //			int nLen = 0;
; 696  : //			POSITION psn = slValues.GetHeadPosition();
; 697  : //			while( psn)
; 698  : //			{
; 699  : //				CString &strValues2 = slValues.GetNext( psn);
; 700  : //				nLen += strValues2.GetLength();
; 701  : //			}
; 702  : //			char *szValues = strValue.GetBuffer( nLen);
; 703  : //			psn = slValues.GetHeadPosition();
; 704  : //			while( psn)
; 705  : //			{
; 706  : //				CString &strValues2 = slValues.GetNext( psn);
; 707  : //				strcpy( szValues, strValues2);
; 708  : //				szValues += strValues2.GetLength();
; 709  : //			}
; 710  : //			strValue.ReleaseBuffer();
; 711  : //			strLog += strValue;
; 712  : //
; 713  : //			strValue.Format( "nNewLastRealDTI : %d\r\n", m_pifaRQ[ nRQ]->nLastRealDTI);
; 714  : //			strLog += strValue;
; 715  : //
; 716  : //			strValue.Format( "nNewRQTimeCount : %d\r\n", m_pblaRQTime[ nRQ]->GetItemCount());
; 717  : //			strLog += strValue;
; 718  : //
; 719  : //			CString strLogKey;
; 720  : //			strLogKey.Format( "XScale[%08X]", ( long)this);
; 721  : //
; 722  : //			CDumpLogger dLogger( strLogKey);
; 723  : //			dLogger.WriteToStringLog( "Calc_DRI_Merge", strLog, strLog.GetLength());
; 724  : #endif
; 725  : 
; 726  : 			// (2009/5/17 - Seung-Won, Bae) for Future Time Count of Compare Chart with OEBT.
; 727  : 			// 3. Get the future time count with user setting.
; 728  : 			if( nRQ == m_maxScaleInterval_nRQ && !m_pIChartCtrl->IsRunningOneChart())

  00569	8b 45 b0	 mov	 eax, DWORD PTR _nRQ$1$[ebp]
  0056c	3b 87 e0 00 00
	00		 cmp	 eax, DWORD PTR [edi+224]
  00572	0f 85 43 01 00
	00		 jne	 $LN480@Calc_DRI_M
  00578	8b 4f 50	 mov	 ecx, DWORD PTR [edi+80]
  0057b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0057d	8b 80 38 01 00
	00		 mov	 eax, DWORD PTR [eax+312]
  00583	ff d0		 call	 eax
  00585	85 c0		 test	 eax, eax
  00587	0f 85 2e 01 00
	00		 jne	 $LN480@Calc_DRI_M

; 729  : 			{
; 730  : 				nAddedFutureTimeCount = m_nFutureTimeCount;
; 731  : 				if( m_pifaOEBT[ nRQ])

  0058d	8b 87 90 00 00
	00		 mov	 eax, DWORD PTR [edi+144]
  00593	8b 8f e0 05 00
	00		 mov	 ecx, DWORD PTR [edi+1504]
  00599	89 4d 94	 mov	 DWORD PTR _nAddedFutureTimeCount$1$[ebp], ecx
  0059c	8b 04 06	 mov	 eax, DWORD PTR [esi+eax]
  0059f	85 c0		 test	 eax, eax
  005a1	74 13		 je	 SHORT $LN93@Calc_DRI_M

; 732  : 				{
; 733  : 					if( nAddedFutureTimeCount < m_pifaOEBT[ nRQ]->nFutureCount)

  005a3	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  005a6	3b c8		 cmp	 ecx, eax
  005a8	7d 07		 jge	 SHORT $LN92@Calc_DRI_M

; 734  : 							nAddedFutureTimeCount = 0;

  005aa	33 d2		 xor	 edx, edx
  005ac	89 55 94	 mov	 DWORD PTR _nAddedFutureTimeCount$1$[ebp], edx
  005af	eb 05		 jmp	 SHORT $LN93@Calc_DRI_M
$LN92@Calc_DRI_M:

; 735  : 					else	nAddedFutureTimeCount -= m_pifaOEBT[ nRQ]->nFutureCount;

  005b1	2b c8		 sub	 ecx, eax
  005b3	89 4d 94	 mov	 DWORD PTR _nAddedFutureTimeCount$1$[ebp], ecx
$LN93@Calc_DRI_M:

; 736  : 				}
; 737  : 				if( m_pblaRQTime[ nRQ]->GetItemCount() + nAddedFutureTimeCount < m_nDefaultDataSpace)

  005b6	8b 8f 9c 00 00
	00		 mov	 ecx, DWORD PTR [edi+156]
  005bc	8b 0c 31	 mov	 ecx, DWORD PTR [ecx+esi]
  005bf	e8 00 00 00 00	 call	 ?GetItemCount@CDataBlockListUNK@@QAEHXZ ; CDataBlockListUNK::GetItemCount
  005c4	8b 4d 94	 mov	 ecx, DWORD PTR _nAddedFutureTimeCount$1$[ebp]
  005c7	03 c1		 add	 eax, ecx
  005c9	3b 87 28 01 00
	00		 cmp	 eax, DWORD PTR [edi+296]
  005cf	7d 19		 jge	 SHORT $LN94@Calc_DRI_M

; 738  : 					nAddedFutureTimeCount = m_nDefaultDataSpace - m_pblaRQTime[ nRQ]->GetItemCount();

  005d1	8b 8f 9c 00 00
	00		 mov	 ecx, DWORD PTR [edi+156]
  005d7	8b 0c 31	 mov	 ecx, DWORD PTR [ecx+esi]
  005da	e8 00 00 00 00	 call	 ?GetItemCount@CDataBlockListUNK@@QAEHXZ ; CDataBlockListUNK::GetItemCount
  005df	8b 8f 28 01 00
	00		 mov	 ecx, DWORD PTR [edi+296]
  005e5	2b c8		 sub	 ecx, eax
  005e7	89 4d 94	 mov	 DWORD PTR _nAddedFutureTimeCount$1$[ebp], ecx
$LN94@Calc_DRI_M:

; 739  : 				// 4. Add Future Time.
; 740  : 				if( 0 < nAddedFutureTimeCount)

  005ea	85 c9		 test	 ecx, ecx
  005ec	0f 8e c9 00 00
	00		 jle	 $LN480@Calc_DRI_M

; 741  : 				{
; 742  : 					time_t timeCur = 0;
; 743  : 					if( 0 < m_pblaRQTime[ nRQ]->GetItemCount())

  005f2	8b 8f 9c 00 00
	00		 mov	 ecx, DWORD PTR [edi+156]
  005f8	0f 57 c0	 xorps	 xmm0, xmm0
  005fb	66 0f 13 45 a8	 movlpd	 QWORD PTR _timeCur$6[ebp], xmm0
  00600	8b 0c 31	 mov	 ecx, DWORD PTR [ecx+esi]
  00603	e8 00 00 00 00	 call	 ?GetItemCount@CDataBlockListUNK@@QAEHXZ ; CDataBlockListUNK::GetItemCount
  00608	85 c0		 test	 eax, eax
  0060a	7e 2c		 jle	 SHORT $LN96@Calc_DRI_M

; 745  : 						m_pTReturn = m_pblaRQTime[ nRQ]->GetAt( m_pblaRQTime[ nRQ]->GetItemCount() - 1);

  0060c	8b 8f 9c 00 00
	00		 mov	 ecx, DWORD PTR [edi+156]
  00612	8b 0c 31	 mov	 ecx, DWORD PTR [ecx+esi]
  00615	e8 00 00 00 00	 call	 ?GetItemCount@CDataBlockListUNK@@QAEHXZ ; CDataBlockListUNK::GetItemCount
  0061a	8b 8f 9c 00 00
	00		 mov	 ecx, DWORD PTR [edi+156]
  00620	48		 dec	 eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 215  : 	T*	GetAt( int nIndex)	{	return ( T*)GetAtUNK( nIndex);	}

  00621	50		 push	 eax
  00622	8b 0c 0e	 mov	 ecx, DWORD PTR [esi+ecx]
  00625	e8 00 00 00 00	 call	 ?GetAtUNK@CDataBlockListUNK@@QAEPAXH@Z ; CDataBlockListUNK::GetAtUNK
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 745  : 						m_pTReturn = m_pblaRQTime[ nRQ]->GetAt( m_pblaRQTime[ nRQ]->GetItemCount() - 1);

  0062a	89 47 5c	 mov	 DWORD PTR [edi+92], eax

; 746  : 						if( m_pTReturn) timeCur = *m_pTReturn;

  0062d	85 c0		 test	 eax, eax
  0062f	74 14		 je	 SHORT $LN456@Calc_DRI_M
  00631	8b 08		 mov	 ecx, DWORD PTR [eax]
  00633	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 747  : 					}

  00636	eb 13		 jmp	 SHORT $LN97@Calc_DRI_M
$LN96@Calc_DRI_M:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\time.h

; 522  :             return _time64(_Time);

  00638	8d 45 a8	 lea	 eax, DWORD PTR _timeCur$6[ebp]
  0063b	50		 push	 eax
  0063c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___time64
  00642	83 c4 04	 add	 esp, 4
$LN456@Calc_DRI_M:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 752  : 					for( int nCount = 0; nCount < nAddedFutureTimeCount; nCount++)

  00645	8b 4d a8	 mov	 ecx, DWORD PTR _timeCur$6[ebp]
  00648	8b 45 ac	 mov	 eax, DWORD PTR _timeCur$6[ebp+4]
$LN97@Calc_DRI_M:
  0064b	8b 55 94	 mov	 edx, DWORD PTR _nAddedFutureTimeCount$1$[ebp]
  0064e	89 55 bc	 mov	 DWORD PTR tv4516[ebp], edx
$LL17@Calc_DRI_M:

; 753  : 					{
; 754  : 						timeCur += nScaleInterval_Sec;

  00651	03 4d c4	 add	 ecx, DWORD PTR _nScaleInterval_Sec$1$[ebp]
  00654	89 4d a8	 mov	 DWORD PTR _timeCur$6[ebp], ecx
  00657	13 45 9c	 adc	 eax, DWORD PTR _nScaleInterval_Sec$2$[ebp]
  0065a	89 45 ac	 mov	 DWORD PTR _timeCur$6[ebp+4], eax

; 755  : #ifdef _DEBUG
; 756  : //tm *pTM = localtime( &timeCur);
; 757  : #endif
; 758  : 						m_pblaRQTime[ nRQ]->PushBack( timeCur);

  0065d	89 45 80	 mov	 DWORD PTR _Item$[ebp+4], eax
  00660	8b 87 9c 00 00
	00		 mov	 eax, DWORD PTR [edi+156]
  00666	89 8d 7c ff ff
	ff		 mov	 DWORD PTR _Item$[ebp], ecx
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 173  : 		PushBackUNK(&Item);

  0066c	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR _Item$[ebp]
  00672	51		 push	 ecx
  00673	8b 0c 06	 mov	 ecx, DWORD PTR [esi+eax]
  00676	e8 00 00 00 00	 call	 ?PushBackUNK@CDataBlockListUNK@@QAEXPAX@Z ; CDataBlockListUNK::PushBackUNK
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 762  : 						if( m_pifaRQ[ nRQ]->m_lEndSpecialTimeCode && CChartInfo::WORLD_ON != m_eChartMode)

  0067b	8b 87 8c 00 00
	00		 mov	 eax, DWORD PTR [edi+140]
  00681	8b 04 06	 mov	 eax, DWORD PTR [esi+eax]
  00684	8b 40 38	 mov	 eax, DWORD PTR [eax+56]
  00687	89 45 a4	 mov	 DWORD PTR tv4518[ebp], eax
  0068a	85 c0		 test	 eax, eax
  0068c	74 1f		 je	 SHORT $LN15@Calc_DRI_M
  0068e	83 bf e8 05 00
	00 03		 cmp	 DWORD PTR [edi+1512], 3
  00695	74 16		 je	 SHORT $LN15@Calc_DRI_M

; 763  : 							m_pamapSpecialTime[ nRQ]->SetAt( timeCur, m_pifaRQ[ nRQ]->m_lEndSpecialTimeCode);

  00697	8b 87 a4 00 00
	00		 mov	 eax, DWORD PTR [edi+164]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl

; 597  : 	{ (*this)[key] = newValue; }

  0069d	ff 75 a8	 push	 DWORD PTR _timeCur$6[ebp]
  006a0	8b 0c 06	 mov	 ecx, DWORD PTR [esi+eax]
  006a3	e8 00 00 00 00	 call	 ??ACMapPtrToPtr@@QAEAAPAXPAX@Z ; CMapPtrToPtr::operator[]
  006a8	8b 4d a4	 mov	 ecx, DWORD PTR tv4518[ebp]
  006ab	89 08		 mov	 DWORD PTR [eax], ecx
$LN15@Calc_DRI_M:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 752  : 					for( int nCount = 0; nCount < nAddedFutureTimeCount; nCount++)

  006ad	83 6d bc 01	 sub	 DWORD PTR tv4516[ebp], 1
  006b1	74 08		 je	 SHORT $LN480@Calc_DRI_M
  006b3	8b 45 ac	 mov	 eax, DWORD PTR _timeCur$6[ebp+4]
  006b6	8b 4d a8	 mov	 ecx, DWORD PTR _timeCur$6[ebp]
  006b9	eb 96		 jmp	 SHORT $LL17@Calc_DRI_M
$LN480@Calc_DRI_M:

; 764  : 					}
; 765  : 				}
; 766  : 			}
; 767  : 		}

  006bb	8d 4d a0	 lea	 ecx, DWORD PTR _strTimeType$4[ebp]
$LN494@Calc_DRI_M:

; 529  : 
; 530  : 	// (2009/5/17 - Seung-Won, Bae) for Future Time Count of Compare Chart with OEBT.
; 531  : 	int nAddedFutureTimeCount = 0;
; 532  : 
; 533  : 	// 2. Make the time line for All RQs.
; 534  : 	int nLastRealDRI = INT_MAX;
; 535  : 	int nRQ = 0;
; 536  : 	for( nRQ = 0; nRQ < m_nCountOfRQ; nRQ++)

  006be	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  006c5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$LN2@Calc_DRI_M:
  006cb	8b 45 b0	 mov	 eax, DWORD PTR _nRQ$1$[ebp]
  006ce	40		 inc	 eax
  006cf	89 45 b0	 mov	 DWORD PTR _nRQ$1$[ebp], eax
  006d2	3b 47 6c	 cmp	 eax, DWORD PTR [edi+108]
  006d5	0f 8c 85 f9 ff
	ff		 jl	 $LL4@Calc_DRI_M
$LN442@Calc_DRI_M:

; 768  : 	}
; 769  : 
; 770  : 	// (2010/4/4 - Seung-Won, Bae) for Ceiling Minute Merge Mode.
; 771  : 	nLastRealDRI = INT_MAX;
; 772  : 
; 773  : 	// Delete main time DRI for last real DRI.
; 774  : 	if( nLastRealDRI == INT_MAX) nLastRealDRI = 0;
; 775  : 	else if( m_blTimefDRI.GetItemCount() <= nLastRealDRI) return;
; 776  : 	m_blTimefDRI.DeleteBack( m_blTimefDRI.GetItemCount() - nLastRealDRI);

  006db	8d 8f ac 00 00
	00		 lea	 ecx, DWORD PTR [edi+172]
  006e1	e8 00 00 00 00	 call	 ?GetItemCount@CDataBlockListUNK@@QAEHXZ ; CDataBlockListUNK::GetItemCount
  006e6	50		 push	 eax
  006e7	8d 8f ac 00 00
	00		 lea	 ecx, DWORD PTR [edi+172]
  006ed	e8 00 00 00 00	 call	 ?DeleteBack@CDataBlockListUNK@@QAEXH@Z ; CDataBlockListUNK::DeleteBack

; 777  : 
; 778  : 	int *naDTI_Cur = new int[ m_nCountOfRQ];

  006f2	8b 47 6c	 mov	 eax, DWORD PTR [edi+108]
  006f5	33 c9		 xor	 ecx, ecx
  006f7	ba 04 00 00 00	 mov	 edx, 4
  006fc	f7 e2		 mul	 edx
  006fe	0f 90 c1	 seto	 cl
  00701	f7 d9		 neg	 ecx
  00703	0b c8		 or	 ecx, eax
  00705	51		 push	 ecx
  00706	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]

; 779  : 	for( nRQ = 0; nRQ < m_nCountOfRQ; nRQ++)

  0070b	8b 57 6c	 mov	 edx, DWORD PTR [edi+108]
  0070e	83 c4 04	 add	 esp, 4
  00711	33 f6		 xor	 esi, esi
  00713	89 45 c0	 mov	 DWORD PTR _naDTI_Cur$1$[ebp], eax
  00716	85 d2		 test	 edx, edx
  00718	7e 52		 jle	 SHORT $LN19@Calc_DRI_M
  0071a	66 0f 1f 44 00
	00		 npad	 6
$LL20@Calc_DRI_M:

; 780  : 	{
; 781  : 		// naDTI_Cur is the Index array of the DTI that merged completly.
; 782  : 		if( 0 <= nLastRealDRI - 1 && nLastRealDRI - 1 < m_pblaDTIfDRI[ nRQ]->GetItemCount())
; 783  : 		{
; 784  : 				m_pIReturn = m_pblaDTIfDRI[ nRQ]->GetAt( nLastRealDRI - 1);
; 785  : 				if( m_pIReturn)
; 786  : 				{
; 787  : 					naDTI_Cur[ nRQ] = *m_pIReturn;
; 788  : 
; 789  : 					// Delete ALL DTItoDRI with LastRealDRI.
; 790  : 					if( -1 <= naDTI_Cur[ nRQ])
; 791  : 						m_pblaDRIfDTI[ nRQ]->DeleteBack( m_pblaDRIfDTI[ nRQ]->GetItemCount() - ( naDTI_Cur[ nRQ] + 1));
; 792  : 				}
; 793  : 		}
; 794  : 		else
; 795  : 		{
; 796  : 			naDTI_Cur[ nRQ] = -1;

  00720	c7 04 b0 ff ff
	ff ff		 mov	 DWORD PTR [eax+esi*4], -1

; 797  : 			// (2009/3/4 - Seung-Won, Bae) Delete End Mark.
; 798  : 			m_pblaDRIfDTI[ nRQ]->DeleteBack( m_pblaDRIfDTI[ nRQ]->GetItemCount());

  00727	8b 8f a0 00 00
	00		 mov	 ecx, DWORD PTR [edi+160]
  0072d	8b 0c b1	 mov	 ecx, DWORD PTR [ecx+esi*4]
  00730	e8 00 00 00 00	 call	 ?GetItemCount@CDataBlockListUNK@@QAEHXZ ; CDataBlockListUNK::GetItemCount
  00735	8b 8f a0 00 00
	00		 mov	 ecx, DWORD PTR [edi+160]
  0073b	50		 push	 eax
  0073c	8b 0c b1	 mov	 ecx, DWORD PTR [ecx+esi*4]
  0073f	e8 00 00 00 00	 call	 ?DeleteBack@CDataBlockListUNK@@QAEXH@Z ; CDataBlockListUNK::DeleteBack

; 799  : 		}
; 800  : 
; 801  : 		m_pblaDTIfDRI[ nRQ]->DeleteBack( m_pblaDTIfDRI[ nRQ]->GetItemCount() - nLastRealDRI);

  00744	8b 8f a8 00 00
	00		 mov	 ecx, DWORD PTR [edi+168]
  0074a	8b 0c b1	 mov	 ecx, DWORD PTR [ecx+esi*4]
  0074d	e8 00 00 00 00	 call	 ?GetItemCount@CDataBlockListUNK@@QAEHXZ ; CDataBlockListUNK::GetItemCount
  00752	8b 8f a8 00 00
	00		 mov	 ecx, DWORD PTR [edi+168]
  00758	50		 push	 eax
  00759	8b 0c b1	 mov	 ecx, DWORD PTR [ecx+esi*4]
  0075c	e8 00 00 00 00	 call	 ?DeleteBack@CDataBlockListUNK@@QAEXH@Z ; CDataBlockListUNK::DeleteBack
  00761	8b 57 6c	 mov	 edx, DWORD PTR [edi+108]
  00764	46		 inc	 esi
  00765	8b 45 c0	 mov	 eax, DWORD PTR _naDTI_Cur$1$[ebp]
  00768	3b f2		 cmp	 esi, edx
  0076a	7c b4		 jl	 SHORT $LL20@Calc_DRI_M
$LN19@Calc_DRI_M:

; 802  : 	}
; 803  : 
; 804  : 	BOOL bNewTime = FALSE;
; 805  : 	time_t timeCur = 0;
; 806  : 	// 3. Do merge to the full time line.
; 807  : 	int nIRQ_Count = 0;
; 808  : 	int* naIRQ	= new int[ m_nCountOfRQ];	//   ( ) RQ  .

  0076c	33 c9		 xor	 ecx, ecx
  0076e	8b c2		 mov	 eax, edx
  00770	ba 04 00 00 00	 mov	 edx, 4
  00775	f7 e2		 mul	 edx
  00777	0f 90 c1	 seto	 cl
  0077a	f7 d9		 neg	 ecx
  0077c	0b c8		 or	 ecx, eax
  0077e	51		 push	 ecx
  0077f	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]

; 809  : 	memset( naIRQ, 0, sizeof( int) * m_nCountOfRQ);

  00784	8b 4f 6c	 mov	 ecx, DWORD PTR [edi+108]
  00787	c1 e1 02	 shl	 ecx, 2
  0078a	51		 push	 ecx
  0078b	6a 00		 push	 0
  0078d	50		 push	 eax
  0078e	89 45 c4	 mov	 DWORD PTR _naIRQ$1$[ebp], eax
  00791	e8 00 00 00 00	 call	 _memset
  00796	83 c4 10	 add	 esp, 16			; 00000010H

; 810  : 	int nRQi = 0;
; 811  : 	int nDRI = 0;
; 812  : 	// 3.1 Loop with increasing DRI until the Index(naDTI_Cur) of All RQs is end.
; 813  : 	for(  nDRI = nLastRealDRI; !EndOfRQs( naDTI_Cur); nDRI++)

  00799	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _nDRI$1$[ebp], 0
  007a0	c7 45 ac 01 00
	00 00		 mov	 DWORD PTR tv4291[ebp], 1
$LL23@Calc_DRI_M:

; 1058 : 	for( int nRQ = 0; nRQ < m_nCountOfRQ; nRQ++)

  007a7	33 f6		 xor	 esi, esi
  007a9	39 77 6c	 cmp	 DWORD PTR [edi+108], esi
  007ac	7e 2c		 jle	 SHORT $LN438@Calc_DRI_M
  007ae	66 90		 npad	 2
$LL202@Calc_DRI_M:

; 1059 : 		if( m_pblaRQTime[ nRQ]->GetItemCount() != ( naDTI_Cur[ nRQ] + 1)
; 1060 : 			&& -1 <= naDTI_Cur[ nRQ])

  007b0	8b 8f 9c 00 00
	00		 mov	 ecx, DWORD PTR [edi+156]
  007b6	8b 0c b1	 mov	 ecx, DWORD PTR [ecx+esi*4]
  007b9	e8 00 00 00 00	 call	 ?GetItemCount@CDataBlockListUNK@@QAEHXZ ; CDataBlockListUNK::GetItemCount
  007be	8b 4d c0	 mov	 ecx, DWORD PTR _naDTI_Cur$1$[ebp]
  007c1	8b 14 b1	 mov	 edx, DWORD PTR [ecx+esi*4]
  007c4	8d 4a 01	 lea	 ecx, DWORD PTR [edx+1]
  007c7	3b c1		 cmp	 eax, ecx
  007c9	74 09		 je	 SHORT $LN200@Calc_DRI_M
  007cb	83 fa ff	 cmp	 edx, -1
  007ce	0f 8d 71 01 00
	00		 jge	 $LN307@Calc_DRI_M
$LN200@Calc_DRI_M:

; 1008 : 
; 1009 : // (2009/1/19 - Seung-Won, Bae) for Scale Time List
; 1010 : inline void CXScaleManagerImp::PopLastScaleDataTime( void)
; 1011 : {
; 1012 : 	signed short nTimeDiff = 0;
; 1013 : 	CXScaleGridTime *pXScaleGridTime = NULL;
; 1014 : 	POSITION psnXGridTime = m_mapXGridTime.GetStartPosition();
; 1015 : 	while( psnXGridTime)
; 1016 : 	{
; 1017 : 		m_mapXGridTime.GetNextAssoc( psnXGridTime, nTimeDiff, pXScaleGridTime);
; 1018 : 		if( !pXScaleGridTime) continue;
; 1019 : 		pXScaleGridTime->PopLastScaleDataTime();
; 1020 : 	}
; 1021 : }
; 1022 : 
; 1023 : inline void CXScaleManagerImp::PushScaleDataTime( int p_nDRI, time_t p_timeDRI, BOOL p_bEndDRI)
; 1024 : {
; 1025 : 	if( p_timeDRI < 0)
; 1026 : 	{
; 1027 : //		ASSERT( 0 <= p_timeDRI);
; 1028 : 		return;
; 1029 : 	}
; 1030 : 
; 1031 : 	// (2009/1/19 - Seung-Won, Bae) for Scale Time List
; 1032 : 	tm* ptmCur = localtime( &p_timeDRI);
; 1033 : 	if( !ptmCur) return;
; 1034 : 	tm tmDRI = *ptmCur;
; 1035 : 
; 1036 : 	// (2009/6/4 - Seung-Won, Bae) for ceiled Minute Scale with second time data.
; 1037 : 	if( m_bCeiling && 0 < tmDRI.tm_sec)
; 1038 : 	{
; 1039 : 		tmDRI.tm_sec += 60 - tmDRI.tm_sec;
; 1040 : 		mktime( &tmDRI);
; 1041 : 	}
; 1042 : 
; 1043 : 	signed short nTimeDiff = 0;
; 1044 : 	CXScaleGridTime *pXScaleGridTime = NULL;
; 1045 : 	POSITION psnXGridTime = m_mapXGridTime.GetStartPosition();
; 1046 : 	while( psnXGridTime)
; 1047 : 	{
; 1048 : 		m_mapXGridTime.GetNextAssoc( psnXGridTime, nTimeDiff, pXScaleGridTime);
; 1049 : 		if( !pXScaleGridTime) continue;
; 1050 : 		pXScaleGridTime->PushScaleDataTime( nTimeDiff, p_nDRI, tmDRI, p_bEndDRI);
; 1051 : 	}
; 1052 : }
; 1053 : 
; 1054 : // (2008/12/28 - Seung-Won, Bae) Comment
; 1055 : //	Check current DTI of All RQ's are end.
; 1056 : BOOL CXScaleManagerImp::EndOfRQs( int* naDTI_Cur)
; 1057 : {
; 1058 : 	for( int nRQ = 0; nRQ < m_nCountOfRQ; nRQ++)

  007d4	46		 inc	 esi
  007d5	3b 77 6c	 cmp	 esi, DWORD PTR [edi+108]
  007d8	7c d6		 jl	 SHORT $LL202@Calc_DRI_M
$LN438@Calc_DRI_M:

; 876  : 						break;
; 877  : 		}
; 878  : 	}
; 879  : 	delete [] naIRQ;

  007da	ff 75 c4	 push	 DWORD PTR _naIRQ$1$[ebp]
  007dd	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  007e2	83 c4 04	 add	 esp, 4

; 880  : 
; 881  : 	// 3.3 Set time item count of the full time line. (DRI counts)
; 882  : 	m_nItemCount_Total = m_blTimefDRI.GetItemCount();

  007e5	8d 8f ac 00 00
	00		 lea	 ecx, DWORD PTR [edi+172]
  007eb	e8 00 00 00 00	 call	 ?GetItemCount@CDataBlockListUNK@@QAEHXZ ; CDataBlockListUNK::GetItemCount
  007f0	89 47 58	 mov	 DWORD PTR [edi+88], eax

; 883  : 
; 884  : 	// (2009/8/15 - Seung-Won, Bae) After Calc_DRI, we need to calculate the Item Width.
; 885  : 	for( int i = 0; i < _MAX_COL; i++) m_naScreenRegionWidth[ i] = 0;
; 886  : 
; 887  : 	// 3.4 Add End Mark DTI for Calc_AREA()
; 888  : 	//			Cacl_Area() calculate the Area from start DTI to end DTI of view with next DTI.
; 889  : 	//		and Set DTI or none-DTI mark for future DRI
; 890  : 	//		but Do not add time item to a time line of RQs.
; 891  : 	// DTI  ()     DTI   .
; 892  : 	for( nRQ = 0; nRQ < m_nCountOfRQ; nRQ++)

  007f3	33 f6		 xor	 esi, esi
  007f5	c7 87 80 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+384], 0
  007ff	c7 87 84 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+388], 0
  00809	c7 87 88 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+392], 0
  00813	c7 87 8c 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+396], 0
  0081d	c7 87 90 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+400], 0
  00827	c7 87 94 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+404], 0
  00831	c7 87 98 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+408], 0
  0083b	c7 87 9c 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+412], 0
  00845	c7 87 a0 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+416], 0
  0084f	c7 87 a4 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+420], 0
  00859	89 75 a0	 mov	 DWORD PTR _nRQ$4$[ebp], esi
  0085c	39 77 6c	 cmp	 DWORD PTR [edi+108], esi
  0085f	0f 8e 30 06 00
	00		 jle	 $LN44@Calc_DRI_M
$LL45@Calc_DRI_M:

; 893  : 	{
; 894  : 		// (2009/5/17 - Seung-Won, Bae) for Future Time Count of Compare Chart with OEBT.
; 895  : 		//		Remove future time count data.
; 896  : 		if( nRQ == m_maxScaleInterval_nRQ && 0 < nAddedFutureTimeCount)

  00865	3b b7 e0 00 00
	00		 cmp	 esi, DWORD PTR [edi+224]
  0086b	75 3d		 jne	 SHORT $LN120@Calc_DRI_M
  0086d	8b 45 94	 mov	 eax, DWORD PTR _nAddedFutureTimeCount$1$[ebp]
  00870	85 c0		 test	 eax, eax
  00872	7e 36		 jle	 SHORT $LN120@Calc_DRI_M

; 897  : 		{
; 898  : 			m_pblaRQTime[ nRQ]->DeleteBack( nAddedFutureTimeCount);

  00874	8b 8f 9c 00 00
	00		 mov	 ecx, DWORD PTR [edi+156]
  0087a	50		 push	 eax
  0087b	8b 0c b1	 mov	 ecx, DWORD PTR [ecx+esi*4]
  0087e	e8 00 00 00 00	 call	 ?DeleteBack@CDataBlockListUNK@@QAEXH@Z ; CDataBlockListUNK::DeleteBack

; 899  : 			m_pblaDRIfDTI[ nRQ]->DeleteBack( nAddedFutureTimeCount);

  00883	8b 8f a0 00 00
	00		 mov	 ecx, DWORD PTR [edi+160]
  00889	8b 55 94	 mov	 edx, DWORD PTR _nAddedFutureTimeCount$1$[ebp]
  0088c	52		 push	 edx
  0088d	8b 0c b1	 mov	 ecx, DWORD PTR [ecx+esi*4]
  00890	e8 00 00 00 00	 call	 ?DeleteBack@CDataBlockListUNK@@QAEXH@Z ; CDataBlockListUNK::DeleteBack

; 900  : 			naDTI_Cur[ nRQ] = m_pblaDRIfDTI[ nRQ]->GetItemCount() - 1;

  00895	8b 8f a0 00 00
	00		 mov	 ecx, DWORD PTR [edi+160]
  0089b	8b 0c b1	 mov	 ecx, DWORD PTR [ecx+esi*4]
  0089e	e8 00 00 00 00	 call	 ?GetItemCount@CDataBlockListUNK@@QAEHXZ ; CDataBlockListUNK::GetItemCount
  008a3	8b 4d c0	 mov	 ecx, DWORD PTR _naDTI_Cur$1$[ebp]
  008a6	48		 dec	 eax
  008a7	89 04 b1	 mov	 DWORD PTR [ecx+esi*4], eax
$LN120@Calc_DRI_M:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 173  : 		PushBackUNK(&Item);

  008aa	8b 8f a0 00 00
	00		 mov	 ecx, DWORD PTR [edi+160]
  008b0	8d 45 ac	 lea	 eax, DWORD PTR _Item$[ebp]
  008b3	50		 push	 eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 904  : 		m_pblaDRIfDTI[ nRQ]->PushBack( -1);

  008b4	c7 45 ac ff ff
	ff ff		 mov	 DWORD PTR _Item$[ebp], -1
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 173  : 		PushBackUNK(&Item);

  008bb	8b 0c b1	 mov	 ecx, DWORD PTR [ecx+esi*4]
  008be	e8 00 00 00 00	 call	 ?PushBackUNK@CDataBlockListUNK@@QAEXPAX@Z ; CDataBlockListUNK::PushBackUNK
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 907  : 		int nDTI_Count = m_pblaDRIfDTI[ nRQ]->GetItemCount();

  008c3	8b 8f a0 00 00
	00		 mov	 ecx, DWORD PTR [edi+160]
  008c9	8b 0c b1	 mov	 ecx, DWORD PTR [ecx+esi*4]
  008cc	e8 00 00 00 00	 call	 ?GetItemCount@CDataBlockListUNK@@QAEHXZ ; CDataBlockListUNK::GetItemCount
  008d1	89 45 98	 mov	 DWORD PTR _nDTI_Count$1$[ebp], eax

; 908  : 		if( nDTI_Count == 1) continue;

  008d4	83 f8 01	 cmp	 eax, 1
  008d7	0f 84 ab 05 00
	00		 je	 $LN43@Calc_DRI_M

; 910  : 		m_pIReturn = m_pblaDRIfDTI[ nRQ]->GetAt( nDTI_Count - 2);

  008dd	8b 8f a0 00 00
	00		 mov	 ecx, DWORD PTR [edi+160]
  008e3	8d 50 fe	 lea	 edx, DWORD PTR [eax-2]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 215  : 	T*	GetAt( int nIndex)	{	return ( T*)GetAtUNK( nIndex);	}

  008e6	52		 push	 edx
  008e7	8b 0c b1	 mov	 ecx, DWORD PTR [ecx+esi*4]
  008ea	e8 00 00 00 00	 call	 ?GetAtUNK@CDataBlockListUNK@@QAEPAXH@Z ; CDataBlockListUNK::GetAtUNK
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 910  : 		m_pIReturn = m_pblaDRIfDTI[ nRQ]->GetAt( nDTI_Count - 2);

  008ef	89 47 60	 mov	 DWORD PTR [edi+96], eax

; 911  : 		if( m_pIReturn) nDRI_Last = *m_pIReturn;

  008f2	85 c0		 test	 eax, eax
  008f4	0f 84 8e 05 00
	00		 je	 $LN43@Calc_DRI_M
  008fa	8b 10		 mov	 edx, DWORD PTR [eax]
  008fc	89 55 b0	 mov	 DWORD PTR _nDRI$5$[ebp], edx

; 912  : 		if( nDRI_Last == -1) continue;

  008ff	83 fa ff	 cmp	 edx, -1
  00902	0f 84 80 05 00
	00		 je	 $LN43@Calc_DRI_M

; 913  : 		int nDRI_Next = GetNextDRI_ByScaleInterval( m_pifaRQ[ nRQ]->eScaleUnit, m_pifaRQ[ nRQ]->nScaleInterval_Unit, nDRI_Last);

  00908	8b 87 8c 00 00
	00		 mov	 eax, DWORD PTR [edi+140]
  0090e	8b 0c b0	 mov	 ecx, DWORD PTR [eax+esi*4]
  00911	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  00914	8b 49 14	 mov	 ecx, DWORD PTR [ecx+20]
  00917	89 45 c8	 mov	 DWORD PTR _nScaleInterval_Unit$1$[ebp], eax
  0091a	89 4d ac	 mov	 DWORD PTR _ScaleUnit$1$[ebp], ecx

; 1843 : 	if( ScaleUnit == CScaleBaseData::HORZ_TICK)

  0091d	83 f9 05	 cmp	 ecx, 5
  00920	0f 85 ec 02 00
	00		 jne	 $LN243@Calc_DRI_M

; 1844 : 	{
; 1845 : 		// ? what is m_minScaleInterval_nUnit ?
; 1846 : 		int nDRI_Next = nDRI_Cur;
; 1847 : 		if( 0 < m_minScaleInterval_nUnit) nDRI_Next += int( nScaleInterval_Unit / m_minScaleInterval_nUnit);

  00926	8b 8f f4 00 00
	00		 mov	 ecx, DWORD PTR [edi+244]
  0092c	85 c9		 test	 ecx, ecx
  0092e	7e 08		 jle	 SHORT $LN244@Calc_DRI_M
  00930	99		 cdq
  00931	f7 f9		 idiv	 ecx
  00933	8b d0		 mov	 edx, eax
  00935	03 55 b0	 add	 edx, DWORD PTR _nDRI$5$[ebp]
$LN244@Calc_DRI_M:

; 1848 : 		if( nDRI_Next > m_nItemCount_Total) nDRI_Next = m_nItemCount_Total;

  00938	8b 47 58	 mov	 eax, DWORD PTR [edi+88]

; 1849 : 		return nDRI_Next;

  0093b	3b d0		 cmp	 edx, eax
  0093d	0f 4e c2	 cmovle	 eax, edx
  00940	e9 c0 03 00 00	 jmp	 $LN498@Calc_DRI_M
$LN307@Calc_DRI_M:

; 1075 : 	for( int nRQ = 0; nRQ < m_nCountOfRQ; nRQ++)

  00945	33 d2		 xor	 edx, edx
  00947	c7 45 a4 ff ff
	ff 7f		 mov	 DWORD PTR _timeResult$1$[ebp], 2147483647 ; 7fffffffH
  0094e	83 ce ff	 or	 esi, -1
  00951	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _timeResult$2$[ebp], 0
  00958	0f 57 c0	 xorps	 xmm0, xmm0
  0095b	89 55 c8	 mov	 DWORD PTR _nRQ$1$[ebp], edx
  0095e	66 0f 13 85 7c
	ff ff ff	 movlpd	 QWORD PTR _timeTemp$2[ebp], xmm0
  00966	39 57 6c	 cmp	 DWORD PTR [edi+108], edx
  00969	0f 8e a2 00 00
	00		 jle	 $LN207@Calc_DRI_M
  0096f	8b 45 80	 mov	 eax, DWORD PTR _timeTemp$2[ebp+4]
  00972	89 45 a0	 mov	 DWORD PTR _timeTemp$2$[ebp], eax
  00975	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _timeTemp$2[ebp]
  0097b	89 45 98	 mov	 DWORD PTR _timeTemp$1$[ebp], eax
  0097e	66 90		 npad	 2
$LL208@Calc_DRI_M:

; 1076 : 	{
; 1077 : 		// 1.1 Check current DTI is on end.
; 1078 : 		if( m_pblaRQTime[ nRQ]->GetItemCount() == ( naDTI_Cur[ nRQ] + 1)
; 1079 : 			|| naDTI_Cur[ nRQ] < -1)

  00980	8b 8f 9c 00 00
	00		 mov	 ecx, DWORD PTR [edi+156]
  00986	8b 0c 91	 mov	 ecx, DWORD PTR [ecx+edx*4]
  00989	e8 00 00 00 00	 call	 ?GetItemCount@CDataBlockListUNK@@QAEHXZ ; CDataBlockListUNK::GetItemCount
  0098e	8b 55 c8	 mov	 edx, DWORD PTR _nRQ$1$[ebp]
  00991	8b 4d c0	 mov	 ecx, DWORD PTR _naDTI_Cur$1$[ebp]
  00994	8b 0c 91	 mov	 ecx, DWORD PTR [ecx+edx*4]
  00997	8d 79 01	 lea	 edi, DWORD PTR [ecx+1]
  0099a	89 7d b4	 mov	 DWORD PTR tv4402[ebp], edi
  0099d	3b c7		 cmp	 eax, edi
  0099f	8b 7d 90	 mov	 edi, DWORD PTR _this$GSCopy$1$[ebp]
  009a2	74 60		 je	 SHORT $LN206@Calc_DRI_M
  009a4	83 f9 ff	 cmp	 ecx, -1
  009a7	7c 5b		 jl	 SHORT $LN206@Calc_DRI_M

; 1083 : 		m_pTReturn = m_pblaRQTime[ nRQ]->GetAt( naDTI_Cur[ nRQ] + 1);

  009a9	8b 87 9c 00 00
	00		 mov	 eax, DWORD PTR [edi+156]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 215  : 	T*	GetAt( int nIndex)	{	return ( T*)GetAtUNK( nIndex);	}

  009af	ff 75 b4	 push	 DWORD PTR tv4402[ebp]
  009b2	8b 0c 90	 mov	 ecx, DWORD PTR [eax+edx*4]
  009b5	e8 00 00 00 00	 call	 ?GetAtUNK@CDataBlockListUNK@@QAEPAXH@Z ; CDataBlockListUNK::GetAtUNK
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 1083 : 		m_pTReturn = m_pblaRQTime[ nRQ]->GetAt( naDTI_Cur[ nRQ] + 1);

  009ba	89 47 5c	 mov	 DWORD PTR [edi+92], eax

; 1084 : 		if( m_pTReturn) timeTemp = *m_pTReturn;

  009bd	85 c0		 test	 eax, eax
  009bf	74 0d		 je	 SHORT $LN489@Calc_DRI_M
  009c1	8b 08		 mov	 ecx, DWORD PTR [eax]
  009c3	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  009c6	89 4d 98	 mov	 DWORD PTR _timeTemp$1$[ebp], ecx
  009c9	89 45 a0	 mov	 DWORD PTR _timeTemp$2$[ebp], eax
  009cc	eb 06		 jmp	 SHORT $LN408@Calc_DRI_M
$LN489@Calc_DRI_M:
  009ce	8b 45 a0	 mov	 eax, DWORD PTR _timeTemp$2$[ebp]
  009d1	8b 4d 98	 mov	 ecx, DWORD PTR _timeTemp$1$[ebp]
$LN408@Calc_DRI_M:

; 1085 : 
; 1086 : 		// 1.3 Get the minimum time value.
; 1087 : 		if( timeResult < timeTemp) continue;

  009d4	39 45 bc	 cmp	 DWORD PTR _timeResult$2$[ebp], eax
  009d7	7c 28		 jl	 SHORT $LN485@Calc_DRI_M
  009d9	8b 55 a4	 mov	 edx, DWORD PTR _timeResult$1$[ebp]
  009dc	7f 04		 jg	 SHORT $LN444@Calc_DRI_M
  009de	3b d1		 cmp	 edx, ecx
  009e0	72 1f		 jb	 SHORT $LN485@Calc_DRI_M
$LN444@Calc_DRI_M:

; 1088 : 		if( timeTemp < timeResult)

  009e2	3b 45 bc	 cmp	 eax, DWORD PTR _timeResult$2$[ebp]
  009e5	7f 0e		 jg	 SHORT $LN216@Calc_DRI_M
  009e7	7c 04		 jl	 SHORT $LN445@Calc_DRI_M
  009e9	3b ca		 cmp	 ecx, edx
  009eb	73 08		 jae	 SHORT $LN216@Calc_DRI_M
$LN445@Calc_DRI_M:

; 1089 : 		{
; 1090 : 			timeResult = timeTemp;

  009ed	89 4d a4	 mov	 DWORD PTR _timeResult$1$[ebp], ecx

; 1091 : 			*pnIRQ_Count = 0;

  009f0	33 f6		 xor	 esi, esi
  009f2	89 45 bc	 mov	 DWORD PTR _timeResult$2$[ebp], eax
$LN216@Calc_DRI_M:

; 1092 : 		}
; 1093 : 
; 1094 : 		// 1.4 Get the RQs that have the time value with same to the minimum time value.
; 1095 : 		naIRQ[ *pnIRQ_Count] = nRQ;

  009f5	8b 45 c4	 mov	 eax, DWORD PTR _naIRQ$1$[ebp]
  009f8	8b 55 c8	 mov	 edx, DWORD PTR _nRQ$1$[ebp]
  009fb	89 14 b0	 mov	 DWORD PTR [eax+esi*4], edx

; 1096 : 		( *pnIRQ_Count)++;

  009fe	46		 inc	 esi
  009ff	eb 03		 jmp	 SHORT $LN206@Calc_DRI_M
$LN485@Calc_DRI_M:

; 1061 : 			return FALSE;
; 1062 : 
; 1063 : 	return TRUE;
; 1064 : }
; 1065 : 
; 1066 : // (2008/12/28 - Seung-Won, Bae) Comment.
; 1067 : //	1. Get the minimum time value between the next time value of all RQs.
; 1068 : //	2. Increase the DTI of RQs that have the minimum time value.
; 1069 : time_t CXScaleManagerImp::GetLeastTime( int* naDTI_Cur, int* naIRQ, int* pnIRQ_Count)
; 1070 : {
; 1071 : 	*pnIRQ_Count = -1;
; 1072 : 	time_t timeTemp = 0;
; 1073 : 	time_t timeResult = INT_MAX;
; 1074 : 	// 1. Search the minimum time value and RQ that has it.
; 1075 : 	for( int nRQ = 0; nRQ < m_nCountOfRQ; nRQ++)

  00a01	8b 55 c8	 mov	 edx, DWORD PTR _nRQ$1$[ebp]
$LN206@Calc_DRI_M:
  00a04	42		 inc	 edx
  00a05	89 55 c8	 mov	 DWORD PTR _nRQ$1$[ebp], edx
  00a08	3b 57 6c	 cmp	 edx, DWORD PTR [edi+108]
  00a0b	0f 8c 6f ff ff
	ff		 jl	 $LL208@Calc_DRI_M
$LN207@Calc_DRI_M:

; 1097 : 	}
; 1098 : 
; 1099 : 	//    RQ
; 1100 : 	for( int nCount = 0; nCount < *pnIRQ_Count; nCount++)

  00a11	8b 4d c4	 mov	 ecx, DWORD PTR _naIRQ$1$[ebp]
  00a14	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _nCount$1$[ebp], 0
  00a1b	85 f6		 test	 esi, esi
  00a1d	7e 14		 jle	 SHORT $LN210@Calc_DRI_M
  00a1f	8b 55 c0	 mov	 edx, DWORD PTR _naDTI_Cur$1$[ebp]
  00a22	8b 7d b4	 mov	 edi, DWORD PTR _nCount$1$[ebp]
$LL211@Calc_DRI_M:

; 1101 : 		naDTI_Cur[ naIRQ[ nCount]]++;

  00a25	8b 04 b9	 mov	 eax, DWORD PTR [ecx+edi*4]
  00a28	47		 inc	 edi
  00a29	ff 04 82	 inc	 DWORD PTR [edx+eax*4]
  00a2c	3b fe		 cmp	 edi, esi
  00a2e	7c f5		 jl	 SHORT $LL211@Calc_DRI_M
  00a30	8b 7d 90	 mov	 edi, DWORD PTR _this$GSCopy$1$[ebp]
$LN210@Calc_DRI_M:

; 814  : 	{
; 815  : 		// 3.1.1 Get the minimum time value between the next time value of all RQs.
; 816  : 		//		and Increase the DTI of RQs that have the minimum time value.
; 817  : 		//		and naIRQ has the RQ Index that have the minimum time value.
; 818  : 		//		and nIRQ_Count is number of RQs that have the minimum time value.
; 819  : 		timeCur = GetLeastTime( naDTI_Cur, naIRQ, &nIRQ_Count);
; 820  : 
; 821  : 		// 3.1.2 Skip Left Hide.
; 822  : 		//    
; 823  : 		if( nDRI < m_nLeftDataHideCount)

  00a33	8b 45 b0	 mov	 eax, DWORD PTR _nDRI$1$[ebp]
  00a36	3b 47 18	 cmp	 eax, DWORD PTR [edi+24]
  00a39	7d 47		 jge	 SHORT $LN107@Calc_DRI_M

; 826  : 			for( int nCount = 0; nCount < nIRQ_Count; nCount++)

  00a3b	33 c0		 xor	 eax, eax
  00a3d	89 45 a0	 mov	 DWORD PTR _nCount$1$[ebp], eax
  00a40	85 f6		 test	 esi, esi
  00a42	0f 8e c2 01 00
	00		 jle	 $LN21@Calc_DRI_M
  00a48	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL26@Calc_DRI_M:

; 827  : 				m_pblaDRIfDTI[ naIRQ[ nCount]]->PushBack( -1);

  00a50	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 173  : 		PushBackUNK(&Item);

  00a53	8d 55 b4	 lea	 edx, DWORD PTR _Item$[ebp]
  00a56	8b 8f a0 00 00
	00		 mov	 ecx, DWORD PTR [edi+160]
  00a5c	52		 push	 edx
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 827  : 				m_pblaDRIfDTI[ naIRQ[ nCount]]->PushBack( -1);

  00a5d	c7 45 b4 ff ff
	ff ff		 mov	 DWORD PTR _Item$[ebp], -1
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 173  : 		PushBackUNK(&Item);

  00a64	8b 0c 81	 mov	 ecx, DWORD PTR [ecx+eax*4]
  00a67	e8 00 00 00 00	 call	 ?PushBackUNK@CDataBlockListUNK@@QAEXPAX@Z ; CDataBlockListUNK::PushBackUNK
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 826  : 			for( int nCount = 0; nCount < nIRQ_Count; nCount++)

  00a6c	8b 45 a0	 mov	 eax, DWORD PTR _nCount$1$[ebp]
  00a6f	8b 4d c4	 mov	 ecx, DWORD PTR _naIRQ$1$[ebp]
  00a72	40		 inc	 eax
  00a73	89 45 a0	 mov	 DWORD PTR _nCount$1$[ebp], eax
  00a76	3b c6		 cmp	 eax, esi
  00a78	7c d6		 jl	 SHORT $LL26@Calc_DRI_M

; 752  : 					for( int nCount = 0; nCount < nAddedFutureTimeCount; nCount++)

  00a7a	ff 45 b0	 inc	 DWORD PTR _nDRI$1$[ebp]
  00a7d	e9 25 fd ff ff	 jmp	 $LL23@Calc_DRI_M
$LN107@Calc_DRI_M:

; 828  : 			continue;
; 829  : 		}
; 830  : 
; 831  : 		// 3.1.3 Add data to the full time line for new DRI
; 832  : 		m_blTimefDRI.PushBack( timeCur);

  00a82	8b 45 a4	 mov	 eax, DWORD PTR _timeResult$1$[ebp]
  00a85	8d 8f ac 00 00
	00		 lea	 ecx, DWORD PTR [edi+172]
  00a8b	89 45 84	 mov	 DWORD PTR _Item$[ebp], eax
  00a8e	8b 45 bc	 mov	 eax, DWORD PTR _timeResult$2$[ebp]
  00a91	89 45 88	 mov	 DWORD PTR _Item$[ebp+4], eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 173  : 		PushBackUNK(&Item);

  00a94	8d 45 84	 lea	 eax, DWORD PTR _Item$[ebp]
  00a97	50		 push	 eax
  00a98	e8 00 00 00 00	 call	 ?PushBackUNK@CDataBlockListUNK@@QAEXPAX@Z ; CDataBlockListUNK::PushBackUNK
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 836  : 		for( nRQ = 0; nRQ < m_nCountOfRQ; nRQ++)

  00a9d	33 d2		 xor	 edx, edx
  00a9f	89 55 9c	 mov	 DWORD PTR _nRQ$3$[ebp], edx
  00aa2	39 57 6c	 cmp	 DWORD PTR [edi+108], edx
  00aa5	0f 8e a6 00 00
	00		 jle	 $LN28@Calc_DRI_M
  00aab	0f 1f 44 00 00	 npad	 5
$LL29@Calc_DRI_M:

; 837  : 			// (2010/4/4 - Seung-Won, Bae) for Ceiling Minute Merge Mode.
; 838  : 			// 1. Check Minute
; 839  : 			switch( m_pifaRQ[ nRQ]->eScaleUnit)

  00ab0	8b 87 8c 00 00
	00		 mov	 eax, DWORD PTR [edi+140]
  00ab6	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]
  00ab9	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00abc	83 c0 fc	 add	 eax, -4			; fffffffcH
  00abf	83 f8 08	 cmp	 eax, 8
  00ac2	77 62		 ja	 SHORT $LN113@Calc_DRI_M
  00ac4	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN446@Calc_DRI_M[eax]
  00acb	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN447@Calc_DRI_M[eax*4]
$LN108@Calc_DRI_M:

; 840  : 		{
; 841  : 			case CScaleBaseData::HORZ_TIME_ONE:			// -
; 842  : 			case CScaleBaseData::HORZ_TICK:				// 
; 843  : 			case CScaleBaseData::HORZ_TIME_TWO:			// -
; 844  : 			case CScaleBaseData::HORZ_TIME_SECOND:		// 
; 845  : 			{
; 846  : 						// if it is matched. naDTI_Cur[ nRQ] was increased already.
; 847  : 						BOOL bMatched = FALSE;

  00ad2	33 c0		 xor	 eax, eax
  00ad4	33 c9		 xor	 ecx, ecx

; 848  : 						for( nRQi = 0; nRQi < nIRQ_Count; nRQi++) if( nRQ == naIRQ[ nRQi]) bMatched = TRUE;

  00ad6	85 f6		 test	 esi, esi
  00ad8	7e 19		 jle	 SHORT $LN436@Calc_DRI_M
  00ada	8b 7d c4	 mov	 edi, DWORD PTR _naIRQ$1$[ebp]
  00add	0f 1f 00	 npad	 3
$LL366@Calc_DRI_M:
  00ae0	3b 14 8f	 cmp	 edx, DWORD PTR [edi+ecx*4]
  00ae3	0f 44 45 ac	 cmove	 eax, DWORD PTR tv4291[ebp]
  00ae7	41		 inc	 ecx
  00ae8	3b ce		 cmp	 ecx, esi
  00aea	7c f4		 jl	 SHORT $LL366@Calc_DRI_M

; 849  : 						m_pblaDTIfDRI[ nRQ]->PushBack( naDTI_Cur[ nRQ] + ( bMatched || m_pblaRQTime[ nRQ]->GetItemCount() == 0 ? 0 : 1));

  00aec	8b 7d 90	 mov	 edi, DWORD PTR _this$GSCopy$1$[ebp]
  00aef	85 c0		 test	 eax, eax
  00af1	75 24		 jne	 SHORT $LN141@Calc_DRI_M
$LN436@Calc_DRI_M:
  00af3	8b 8f 9c 00 00
	00		 mov	 ecx, DWORD PTR [edi+156]
  00af9	8b 0c 91	 mov	 ecx, DWORD PTR [ecx+edx*4]
  00afc	e8 00 00 00 00	 call	 ?GetItemCount@CDataBlockListUNK@@QAEHXZ ; CDataBlockListUNK::GetItemCount
  00b01	85 c0		 test	 eax, eax
  00b03	74 12		 je	 SHORT $LN141@Calc_DRI_M
  00b05	8b 55 9c	 mov	 edx, DWORD PTR _nRQ$3$[ebp]
  00b08	b9 01 00 00 00	 mov	 ecx, 1
  00b0d	8b 45 c0	 mov	 eax, DWORD PTR _naDTI_Cur$1$[ebp]
  00b10	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]
  00b13	03 c1		 add	 eax, ecx

; 850  : 						break;

  00b15	eb 15		 jmp	 SHORT $LN496@Calc_DRI_M
$LN141@Calc_DRI_M:

; 849  : 						m_pblaDTIfDRI[ nRQ]->PushBack( naDTI_Cur[ nRQ] + ( bMatched || m_pblaRQTime[ nRQ]->GetItemCount() == 0 ? 0 : 1));

  00b17	8b 55 9c	 mov	 edx, DWORD PTR _nRQ$3$[ebp]
  00b1a	33 c9		 xor	 ecx, ecx
  00b1c	8b 45 c0	 mov	 eax, DWORD PTR _naDTI_Cur$1$[ebp]
  00b1f	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]
  00b22	03 c1		 add	 eax, ecx

; 850  : 						break;

  00b24	eb 06		 jmp	 SHORT $LN496@Calc_DRI_M
$LN113@Calc_DRI_M:

; 851  : 			}
; 852  : 			default:	// 3.1.4 Add DTI for new DRI
; 853  : 						// DTI From DRI 
; 854  : 						m_pblaDTIfDRI[ nRQ]->PushBack( naDTI_Cur[ nRQ]);

  00b26	8b 45 c0	 mov	 eax, DWORD PTR _naDTI_Cur$1$[ebp]
  00b29	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]
$LN496@Calc_DRI_M:

; 836  : 		for( nRQ = 0; nRQ < m_nCountOfRQ; nRQ++)

  00b2c	8b 8f a8 00 00
	00		 mov	 ecx, DWORD PTR [edi+168]
  00b32	89 45 b4	 mov	 DWORD PTR _Item$[ebp], eax
  00b35	8d 45 b4	 lea	 eax, DWORD PTR _Item$[ebp]
  00b38	50		 push	 eax
  00b39	8b 0c 91	 mov	 ecx, DWORD PTR [ecx+edx*4]
  00b3c	e8 00 00 00 00	 call	 ?PushBackUNK@CDataBlockListUNK@@QAEXPAX@Z ; CDataBlockListUNK::PushBackUNK
  00b41	8b 55 9c	 mov	 edx, DWORD PTR _nRQ$3$[ebp]
  00b44	42		 inc	 edx
  00b45	89 55 9c	 mov	 DWORD PTR _nRQ$3$[ebp], edx
  00b48	3b 57 6c	 cmp	 edx, DWORD PTR [edi+108]
  00b4b	0f 8c 5f ff ff
	ff		 jl	 $LL29@Calc_DRI_M
$LN28@Calc_DRI_M:

; 861  : 		for( nRQi = 0; nRQi < nIRQ_Count; nRQi++)

  00b51	33 c9		 xor	 ecx, ecx
  00b53	89 4d bc	 mov	 DWORD PTR _nRQi$2$[ebp], ecx
  00b56	85 f6		 test	 esi, esi
  00b58	0f 8e ac 00 00
	00		 jle	 $LN21@Calc_DRI_M
  00b5e	66 90		 npad	 2
$LL37@Calc_DRI_M:

; 862  : 			// (2010/4/4 - Seung-Won, Bae) for Ceiling Minute Merge Mode.
; 863  : 			// 1. Check Minute
; 864  : 			switch( m_pifaRQ[ naIRQ[ nRQi]]->eScaleUnit)

  00b60	8b 45 c4	 mov	 eax, DWORD PTR _naIRQ$1$[ebp]
  00b63	8b 14 88	 mov	 edx, DWORD PTR [eax+ecx*4]
  00b66	8b 87 8c 00 00
	00		 mov	 eax, DWORD PTR [edi+140]
  00b6c	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]
  00b6f	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00b72	83 c0 fc	 add	 eax, -4			; fffffffcH
  00b75	83 f8 08	 cmp	 eax, 8
  00b78	77 66		 ja	 SHORT $LN119@Calc_DRI_M
  00b7a	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN448@Calc_DRI_M[eax]
  00b81	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN449@Calc_DRI_M[eax*4]
$LN114@Calc_DRI_M:

; 865  : 		{
; 866  : 			case CScaleBaseData::HORZ_TIME_ONE:			// -
; 867  : 			case CScaleBaseData::HORZ_TICK:				// 
; 868  : 			case CScaleBaseData::HORZ_TIME_TWO:			// -
; 869  : 			case CScaleBaseData::HORZ_TIME_SECOND:		// 
; 870  : 						// if it is matched. push the next DRI for next DTI.
; 871  : 						if( m_pblaDRIfDTI[ naIRQ[ nRQi]]->GetItemCount() == 0)

  00b88	8b 8f a0 00 00
	00		 mov	 ecx, DWORD PTR [edi+160]
  00b8e	8b 0c 91	 mov	 ecx, DWORD PTR [ecx+edx*4]
  00b91	e8 00 00 00 00	 call	 ?GetItemCount@CDataBlockListUNK@@QAEHXZ ; CDataBlockListUNK::GetItemCount
  00b96	85 c0		 test	 eax, eax
  00b98	75 24		 jne	 SHORT $LN118@Calc_DRI_M

; 872  : 							m_pblaDRIfDTI[ naIRQ[ nRQi]]->PushBack( nDRI - m_nLeftDataHideCount);

  00b9a	8b 45 b0	 mov	 eax, DWORD PTR _nDRI$1$[ebp]
  00b9d	2b 47 18	 sub	 eax, DWORD PTR [edi+24]
  00ba0	8b 4d bc	 mov	 ecx, DWORD PTR _nRQi$2$[ebp]
  00ba3	89 45 b4	 mov	 DWORD PTR _Item$[ebp], eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 173  : 		PushBackUNK(&Item);

  00ba6	8d 45 b4	 lea	 eax, DWORD PTR _Item$[ebp]
  00ba9	50		 push	 eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 872  : 							m_pblaDRIfDTI[ naIRQ[ nRQi]]->PushBack( nDRI - m_nLeftDataHideCount);

  00baa	8b 45 c4	 mov	 eax, DWORD PTR _naIRQ$1$[ebp]
  00bad	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 173  : 		PushBackUNK(&Item);

  00bb0	8b 8f a0 00 00
	00		 mov	 ecx, DWORD PTR [edi+160]
  00bb6	8b 0c 81	 mov	 ecx, DWORD PTR [ecx+eax*4]
  00bb9	e8 00 00 00 00	 call	 ?PushBackUNK@CDataBlockListUNK@@QAEXPAX@Z ; CDataBlockListUNK::PushBackUNK
$LN118@Calc_DRI_M:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 873  : 						m_pblaDRIfDTI[ naIRQ[ nRQi]]->PushBack( nDRI - m_nLeftDataHideCount + 1);

  00bbe	8b 45 b0	 mov	 eax, DWORD PTR _nDRI$1$[ebp]
  00bc1	2b 47 18	 sub	 eax, DWORD PTR [edi+24]
  00bc4	8b 4d bc	 mov	 ecx, DWORD PTR _nRQi$2$[ebp]
  00bc7	40		 inc	 eax
  00bc8	89 45 b4	 mov	 DWORD PTR _Item$[ebp], eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 173  : 		PushBackUNK(&Item);

  00bcb	8d 45 b4	 lea	 eax, DWORD PTR _Item$[ebp]
  00bce	50		 push	 eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 873  : 						m_pblaDRIfDTI[ naIRQ[ nRQi]]->PushBack( nDRI - m_nLeftDataHideCount + 1);

  00bcf	8b 45 c4	 mov	 eax, DWORD PTR _naIRQ$1$[ebp]
  00bd2	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 173  : 		PushBackUNK(&Item);

  00bd5	8b 8f a0 00 00
	00		 mov	 ecx, DWORD PTR [edi+160]
  00bdb	8b 0c 81	 mov	 ecx, DWORD PTR [ecx+eax*4]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 874  : 						break;

  00bde	eb 16		 jmp	 SHORT $LN497@Calc_DRI_M
$LN119@Calc_DRI_M:

; 875  : 			default:	m_pblaDRIfDTI[ naIRQ[ nRQi]]->PushBack( nDRI - m_nLeftDataHideCount);

  00be0	8b 45 b0	 mov	 eax, DWORD PTR _nDRI$1$[ebp]
  00be3	2b 47 18	 sub	 eax, DWORD PTR [edi+24]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 173  : 		PushBackUNK(&Item);

  00be6	8b 8f a0 00 00
	00		 mov	 ecx, DWORD PTR [edi+160]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 875  : 			default:	m_pblaDRIfDTI[ naIRQ[ nRQi]]->PushBack( nDRI - m_nLeftDataHideCount);

  00bec	89 45 b4	 mov	 DWORD PTR _Item$[ebp], eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 173  : 		PushBackUNK(&Item);

  00bef	8d 45 b4	 lea	 eax, DWORD PTR _Item$[ebp]
  00bf2	50		 push	 eax
  00bf3	8b 0c 91	 mov	 ecx, DWORD PTR [ecx+edx*4]
$LN497@Calc_DRI_M:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 861  : 		for( nRQi = 0; nRQi < nIRQ_Count; nRQi++)

  00bf6	e8 00 00 00 00	 call	 ?PushBackUNK@CDataBlockListUNK@@QAEXPAX@Z ; CDataBlockListUNK::PushBackUNK
  00bfb	8b 4d bc	 mov	 ecx, DWORD PTR _nRQi$2$[ebp]
  00bfe	41		 inc	 ecx
  00bff	89 4d bc	 mov	 DWORD PTR _nRQi$2$[ebp], ecx
  00c02	3b ce		 cmp	 ecx, esi
  00c04	0f 8c 56 ff ff
	ff		 jl	 $LL37@Calc_DRI_M
$LN21@Calc_DRI_M:

; 810  : 	int nRQi = 0;
; 811  : 	int nDRI = 0;
; 812  : 	// 3.1 Loop with increasing DRI until the Index(naDTI_Cur) of All RQs is end.
; 813  : 	for(  nDRI = nLastRealDRI; !EndOfRQs( naDTI_Cur); nDRI++)

  00c0a	ff 45 b0	 inc	 DWORD PTR _nDRI$1$[ebp]
  00c0d	e9 95 fb ff ff	 jmp	 $LL23@Calc_DRI_M
$LN243@Calc_DRI_M:

; 1854 : 	int nDRI_Next = nDRI_Cur + 1;

  00c12	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  00c15	0f 57 c0	 xorps	 xmm0, xmm0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 215  : 	T*	GetAt( int nIndex)	{	return ( T*)GetAtUNK( nIndex);	}

  00c18	52		 push	 edx
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 1856 : 	m_pTReturn = m_blTimefDRI.GetAt( nDRI_Cur);

  00c19	8d 8f ac 00 00
	00		 lea	 ecx, DWORD PTR [edi+172]
  00c1f	89 45 c4	 mov	 DWORD PTR _nDRI$3$[ebp], eax
  00c22	66 0f 13 45 b8	 movlpd	 QWORD PTR _timeCur$10[ebp], xmm0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 215  : 	T*	GetAt( int nIndex)	{	return ( T*)GetAtUNK( nIndex);	}

  00c27	e8 00 00 00 00	 call	 ?GetAtUNK@CDataBlockListUNK@@QAEPAXH@Z ; CDataBlockListUNK::GetAtUNK
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 1856 : 	m_pTReturn = m_blTimefDRI.GetAt( nDRI_Cur);

  00c2c	89 47 5c	 mov	 DWORD PTR [edi+92], eax

; 1857 : 	if( m_pTReturn) timeCur = *m_pTReturn;

  00c2f	85 c0		 test	 eax, eax
  00c31	74 0d		 je	 SHORT $LN458@Calc_DRI_M
  00c33	8b 08		 mov	 ecx, DWORD PTR [eax]
  00c35	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00c38	89 4d b8	 mov	 DWORD PTR _timeCur$10[ebp], ecx
  00c3b	89 45 bc	 mov	 DWORD PTR _timeCur$10[ebp+4], eax
  00c3e	eb 06		 jmp	 SHORT $LN246@Calc_DRI_M
$LN458@Calc_DRI_M:
  00c40	8b 45 bc	 mov	 eax, DWORD PTR _timeCur$10[ebp+4]
  00c43	8b 4d b8	 mov	 ecx, DWORD PTR _timeCur$10[ebp]
$LN246@Calc_DRI_M:

; 1858 : 	// (2009/6/4 - Seung-Won, Bae) Check Exception.
; 1859 : 	if( timeCur < 0) return nDRI_Next;

  00c46	85 c0		 test	 eax, eax
  00c48	7f 0e		 jg	 SHORT $LN247@Calc_DRI_M
  00c4a	7c 04		 jl	 SHORT $LN450@Calc_DRI_M
  00c4c	85 c9		 test	 ecx, ecx
  00c4e	73 08		 jae	 SHORT $LN247@Calc_DRI_M
$LN450@Calc_DRI_M:
  00c50	8b 45 c4	 mov	 eax, DWORD PTR _nDRI$3$[ebp]
  00c53	e9 b0 00 00 00	 jmp	 $LN238@Calc_DRI_M
$LN247@Calc_DRI_M:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\time.h

; 499  :             return _localtime64(_Time);

  00c58	8d 45 b8	 lea	 eax, DWORD PTR _timeCur$10[ebp]
  00c5b	50		 push	 eax
  00c5c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___localtime64
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 1861 : 	tm* ptmCur = localtime( &timeCur);

  00c62	8b c8		 mov	 ecx, eax
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\time.h

; 499  :             return _localtime64(_Time);

  00c64	83 c4 04	 add	 esp, 4
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 1865 : 	if(ptmCur == NULL)

  00c67	85 c9		 test	 ecx, ecx
  00c69	75 0a		 jne	 SHORT $LN248@Calc_DRI_M

; 1866 : 	{
; 1867 : 		return INT_MIN;

  00c6b	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  00c70	e9 90 00 00 00	 jmp	 $LN498@Calc_DRI_M
$LN248@Calc_DRI_M:

; 1868 : 	}
; 1869 : 	// 2011.01.06 by SYS <<
; 1870 : 
; 1871 : 
; 1872 : 	switch( ScaleUnit)

  00c75	8b 45 ac	 mov	 eax, DWORD PTR _ScaleUnit$1$[ebp]
  00c78	48		 dec	 eax
  00c79	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  00c7c	0f 87 80 00 00
	00		 ja	 $LN249@Calc_DRI_M
  00c82	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN451@Calc_DRI_M[eax*4]
$LN250@Calc_DRI_M:

; 1873 : 	{
; 1874 : 		default: return nDRI_Next;
; 1875 : 
; 1876 : 		case CScaleBaseData::HORZ_MONTHLY:		ptmCur->tm_mon	+= nScaleInterval_Unit;			break;

  00c89	8b 55 c8	 mov	 edx, DWORD PTR _nScaleInterval_Unit$1$[ebp]
  00c8c	01 51 10	 add	 DWORD PTR [ecx+16], edx
  00c8f	eb 1e		 jmp	 SHORT $LN239@Calc_DRI_M
$LN251@Calc_DRI_M:

; 1877 : 		case CScaleBaseData::HORZ_WEEKLEY:		ptmCur->tm_mday += (nScaleInterval_Unit * 7);	break;

  00c91	8b 55 c8	 mov	 edx, DWORD PTR _nScaleInterval_Unit$1$[ebp]
  00c94	8d 04 d5 00 00
	00 00		 lea	 eax, DWORD PTR [edx*8]
  00c9b	2b c2		 sub	 eax, edx
  00c9d	01 41 0c	 add	 DWORD PTR [ecx+12], eax
  00ca0	eb 0d		 jmp	 SHORT $LN239@Calc_DRI_M
$LN252@Calc_DRI_M:

; 1878 : 		case CScaleBaseData::HORZ_DAILY:		ptmCur->tm_mday += nScaleInterval_Unit;			break;

  00ca2	8b 55 c8	 mov	 edx, DWORD PTR _nScaleInterval_Unit$1$[ebp]
  00ca5	01 51 0c	 add	 DWORD PTR [ecx+12], edx

; 1879 : 		case CScaleBaseData::HORZ_TIME_ONE:		ptmCur->tm_sec	+= nScaleInterval_Unit;			break;

  00ca8	eb 05		 jmp	 SHORT $LN239@Calc_DRI_M
$LN255@Calc_DRI_M:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\time.h

; 515  :             return _mktime64(_Tm);

  00caa	8b 55 c8	 mov	 edx, DWORD PTR _nScaleInterval_Unit$1$[ebp]
  00cad	01 11		 add	 DWORD PTR [ecx], edx
$LN239@Calc_DRI_M:
  00caf	51		 push	 ecx
  00cb0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___mktime64
  00cb6	83 c4 04	 add	 esp, 4
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 1883 : 	time_t timeNext = mktime( ptmCur);

  00cb9	89 45 b4	 mov	 DWORD PTR _timeNext$2$[ebp], eax
  00cbc	8b ca		 mov	 ecx, edx
  00cbe	89 4d ac	 mov	 DWORD PTR _timeNext$1$[ebp], ecx

; 1884 : 	// 2.3 Search the DRI for next time in full time line.
; 1885 : 	if( timeCur != timeNext) while( m_nItemCount_Total > nDRI_Next)

  00cc1	39 45 b8	 cmp	 DWORD PTR _timeCur$10[ebp], eax
  00cc4	75 05		 jne	 SHORT $LN452@Calc_DRI_M
  00cc6	39 4d bc	 cmp	 DWORD PTR _timeCur$10[ebp+4], ecx
  00cc9	74 37		 je	 SHORT $LN249@Calc_DRI_M
$LN452@Calc_DRI_M:
  00ccb	8b 45 c4	 mov	 eax, DWORD PTR _nDRI$3$[ebp]
  00cce	39 47 58	 cmp	 DWORD PTR [edi+88], eax
  00cd1	7e 32		 jle	 SHORT $LN498@Calc_DRI_M
  00cd3	8b f0		 mov	 esi, eax
$LL241@Calc_DRI_M:

; 1886 : 	{
; 1887 : 		GetTimeFromDRI( nDRI_Next, &timeCur);

  00cd5	8b 07		 mov	 eax, DWORD PTR [edi]
  00cd7	8d 4d b8	 lea	 ecx, DWORD PTR _timeCur$10[ebp]
  00cda	51		 push	 ecx
  00cdb	56		 push	 esi
  00cdc	8b cf		 mov	 ecx, edi
  00cde	ff 90 ec 00 00
	00		 call	 DWORD PTR [eax+236]

; 1888 : 		if( timeNext <= timeCur) break;

  00ce4	8b 45 ac	 mov	 eax, DWORD PTR _timeNext$1$[ebp]
  00ce7	3b 45 bc	 cmp	 eax, DWORD PTR _timeCur$10[ebp+4]
  00cea	7c 10		 jl	 SHORT $LN481@Calc_DRI_M
  00cec	7f 08		 jg	 SHORT $LN453@Calc_DRI_M
  00cee	8b 45 b4	 mov	 eax, DWORD PTR _timeNext$2$[ebp]
  00cf1	3b 45 b8	 cmp	 eax, DWORD PTR _timeCur$10[ebp]
  00cf4	76 06		 jbe	 SHORT $LN481@Calc_DRI_M
$LN453@Calc_DRI_M:

; 1889 : 		nDRI_Next++;

  00cf6	46		 inc	 esi
  00cf7	39 77 58	 cmp	 DWORD PTR [edi+88], esi
  00cfa	7f d9		 jg	 SHORT $LL241@Calc_DRI_M
$LN481@Calc_DRI_M:
  00cfc	89 75 c4	 mov	 DWORD PTR _nDRI$3$[ebp], esi
  00cff	8b 75 a0	 mov	 esi, DWORD PTR _nRQ$4$[ebp]
$LN249@Calc_DRI_M:

; 917  : 		m_pblaDRIfDTI[ nRQ]->SetAt( nDTI_Count - 1, nDRI_Next);

  00d02	8b 45 c4	 mov	 eax, DWORD PTR _nDRI$3$[ebp]
$LN498@Calc_DRI_M:
  00d05	89 45 c4	 mov	 DWORD PTR _nDRI$3$[ebp], eax
$LN238@Calc_DRI_M:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 183  : 		return SetAtUNK(nIndex, &Item);

  00d08	8b 8f a0 00 00
	00		 mov	 ecx, DWORD PTR [edi+160]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 917  : 		m_pblaDRIfDTI[ nRQ]->SetAt( nDTI_Count - 1, nDRI_Next);

  00d0e	89 45 ac	 mov	 DWORD PTR _Item$[ebp], eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 183  : 		return SetAtUNK(nIndex, &Item);

  00d11	8d 45 ac	 lea	 eax, DWORD PTR _Item$[ebp]
  00d14	50		 push	 eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 917  : 		m_pblaDRIfDTI[ nRQ]->SetAt( nDTI_Count - 1, nDRI_Next);

  00d15	8b 45 98	 mov	 eax, DWORD PTR _nDTI_Count$1$[ebp]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 183  : 		return SetAtUNK(nIndex, &Item);

  00d18	8b 0c b1	 mov	 ecx, DWORD PTR [ecx+esi*4]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 917  : 		m_pblaDRIfDTI[ nRQ]->SetAt( nDTI_Count - 1, nDRI_Next);

  00d1b	48		 dec	 eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 183  : 		return SetAtUNK(nIndex, &Item);

  00d1c	50		 push	 eax
  00d1d	e8 00 00 00 00	 call	 ?SetAtUNK@CDataBlockListUNK@@QAEHHPAX@Z ; CDataBlockListUNK::SetAtUNK
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 921  : 		int nDTIfDRICount = m_pblaDTIfDRI[ nRQ]->GetItemCount();

  00d22	8b 8f a8 00 00
	00		 mov	 ecx, DWORD PTR [edi+168]
  00d28	8b 0c b1	 mov	 ecx, DWORD PTR [ecx+esi*4]
  00d2b	e8 00 00 00 00	 call	 ?GetItemCount@CDataBlockListUNK@@QAEHXZ ; CDataBlockListUNK::GetItemCount

; 922  : 		if( 0 <= naDTI_Cur[ nRQ])

  00d30	8b 55 b0	 mov	 edx, DWORD PTR _nDRI$5$[ebp]
  00d33	8b c8		 mov	 ecx, eax
  00d35	8b 45 c0	 mov	 eax, DWORD PTR _naDTI_Cur$1$[ebp]
  00d38	89 4d c8	 mov	 DWORD PTR _nDRI$6$[ebp], ecx
  00d3b	83 3c b0 00	 cmp	 DWORD PTR [eax+esi*4], 0
  00d3f	0f 8c e2 00 00
	00		 jl	 $LN124@Calc_DRI_M

; 925  : 			for( nDRI = nDRI_Last; nDRI < nDTIfDRICount; nDRI++)

  00d45	3b d1		 cmp	 edx, ecx
  00d47	7d 31		 jge	 SHORT $LN47@Calc_DRI_M
  00d49	0f 1f 80 00 00
	00 00		 npad	 7
$LL48@Calc_DRI_M:

; 926  : 				m_pblaDTIfDRI[ nRQ]->SetAt( nDRI, naDTI_Cur[ nRQ]);

  00d50	8b 04 b0	 mov	 eax, DWORD PTR [eax+esi*4]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 183  : 		return SetAtUNK(nIndex, &Item);

  00d53	8b 8f a8 00 00
	00		 mov	 ecx, DWORD PTR [edi+168]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 926  : 				m_pblaDTIfDRI[ nRQ]->SetAt( nDRI, naDTI_Cur[ nRQ]);

  00d59	89 45 ac	 mov	 DWORD PTR _Item$[ebp], eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 183  : 		return SetAtUNK(nIndex, &Item);

  00d5c	8d 45 ac	 lea	 eax, DWORD PTR _Item$[ebp]
  00d5f	50		 push	 eax
  00d60	52		 push	 edx
  00d61	8b 0c b1	 mov	 ecx, DWORD PTR [ecx+esi*4]
  00d64	e8 00 00 00 00	 call	 ?SetAtUNK@CDataBlockListUNK@@QAEHHPAX@Z ; CDataBlockListUNK::SetAtUNK
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 925  : 			for( nDRI = nDRI_Last; nDRI < nDTIfDRICount; nDRI++)

  00d69	8b 55 b0	 mov	 edx, DWORD PTR _nDRI$5$[ebp]
  00d6c	8b 4d c8	 mov	 ecx, DWORD PTR _nDRI$6$[ebp]
  00d6f	42		 inc	 edx
  00d70	8b 45 c0	 mov	 eax, DWORD PTR _naDTI_Cur$1$[ebp]
  00d73	89 55 b0	 mov	 DWORD PTR _nDRI$5$[ebp], edx
  00d76	3b d1		 cmp	 edx, ecx
  00d78	7c d6		 jl	 SHORT $LL48@Calc_DRI_M
$LN47@Calc_DRI_M:

; 927  : 			for( nDRI = nDTIfDRICount; nDRI < nDRI_Next; nDRI++)

  00d7a	8b 45 c4	 mov	 eax, DWORD PTR _nDRI$3$[ebp]
  00d7d	3b c8		 cmp	 ecx, eax
  00d7f	7d 36		 jge	 SHORT $LN50@Calc_DRI_M
  00d81	2b c1		 sub	 eax, ecx
  00d83	89 45 a0	 mov	 DWORD PTR tv4504[ebp], eax
  00d86	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL51@Calc_DRI_M:

; 928  : 				m_pblaDTIfDRI[ nRQ]->PushBack( naDTI_Cur[ nRQ]);

  00d90	8b 45 c0	 mov	 eax, DWORD PTR _naDTI_Cur$1$[ebp]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 173  : 		PushBackUNK(&Item);

  00d93	8b 8f a8 00 00
	00		 mov	 ecx, DWORD PTR [edi+168]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 928  : 				m_pblaDTIfDRI[ nRQ]->PushBack( naDTI_Cur[ nRQ]);

  00d99	8b 04 b0	 mov	 eax, DWORD PTR [eax+esi*4]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 173  : 		PushBackUNK(&Item);

  00d9c	8b 0c b1	 mov	 ecx, DWORD PTR [ecx+esi*4]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 928  : 				m_pblaDTIfDRI[ nRQ]->PushBack( naDTI_Cur[ nRQ]);

  00d9f	89 45 ac	 mov	 DWORD PTR _Item$[ebp], eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 173  : 		PushBackUNK(&Item);

  00da2	8d 45 ac	 lea	 eax, DWORD PTR _Item$[ebp]
  00da5	50		 push	 eax
  00da6	e8 00 00 00 00	 call	 ?PushBackUNK@CDataBlockListUNK@@QAEXPAX@Z ; CDataBlockListUNK::PushBackUNK
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 927  : 			for( nDRI = nDTIfDRICount; nDRI < nDRI_Next; nDRI++)

  00dab	83 6d a0 01	 sub	 DWORD PTR tv4504[ebp], 1
  00daf	75 df		 jne	 SHORT $LL51@Calc_DRI_M
  00db1	8b 4d c8	 mov	 ecx, DWORD PTR _nDRI$6$[ebp]
  00db4	8b 45 c4	 mov	 eax, DWORD PTR _nDRI$3$[ebp]
$LN50@Calc_DRI_M:

; 929  : 
; 930  : 			// 3.4.5 Reset DTI for end-mark DTI for added new future.
; 931  : 			int nDTI = ( ( naDTI_Cur[ nRQ]) + 3) * -1;

  00db7	8b 55 c0	 mov	 edx, DWORD PTR _naDTI_Cur$1$[ebp]
  00dba	c7 45 bc fd ff
	ff ff		 mov	 DWORD PTR _nDTI$1$[ebp], -3 ; fffffffdH
  00dc1	8b 7d bc	 mov	 edi, DWORD PTR _nDTI$1$[ebp]
  00dc4	2b 3c b2	 sub	 edi, DWORD PTR [edx+esi*4]
  00dc7	89 7d bc	 mov	 DWORD PTR _nDTI$1$[ebp], edi

; 932  : 			for( nDRI = nDRI_Next; nDRI < nDTIfDRICount; nDRI++)	// do you know why? (nDRI <= m_nItemCount_Total)

  00dca	8b 7d 90	 mov	 edi, DWORD PTR _this$GSCopy$1$[ebp]
  00dcd	3b c1		 cmp	 eax, ecx
  00dcf	7d 27		 jge	 SHORT $LN53@Calc_DRI_M
$LL54@Calc_DRI_M:

; 933  : 				m_pblaDTIfDRI[ nRQ]->SetAt( nDRI, nDTI);

  00dd1	8b 4d bc	 mov	 ecx, DWORD PTR _nDTI$1$[ebp]
  00dd4	89 4d ac	 mov	 DWORD PTR _Item$[ebp], ecx
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 183  : 		return SetAtUNK(nIndex, &Item);

  00dd7	8d 4d ac	 lea	 ecx, DWORD PTR _Item$[ebp]
  00dda	51		 push	 ecx
  00ddb	8b 8f a8 00 00
	00		 mov	 ecx, DWORD PTR [edi+168]
  00de1	50		 push	 eax
  00de2	8b 0c b1	 mov	 ecx, DWORD PTR [ecx+esi*4]
  00de5	e8 00 00 00 00	 call	 ?SetAtUNK@CDataBlockListUNK@@QAEHHPAX@Z ; CDataBlockListUNK::SetAtUNK
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 932  : 			for( nDRI = nDRI_Next; nDRI < nDTIfDRICount; nDRI++)	// do you know why? (nDRI <= m_nItemCount_Total)

  00dea	8b 45 c4	 mov	 eax, DWORD PTR _nDRI$3$[ebp]
  00ded	8b 4d c8	 mov	 ecx, DWORD PTR _nDRI$6$[ebp]
  00df0	40		 inc	 eax
  00df1	89 45 c4	 mov	 DWORD PTR _nDRI$3$[ebp], eax
  00df4	3b c1		 cmp	 eax, ecx
  00df6	7c d9		 jl	 SHORT $LL54@Calc_DRI_M
$LN53@Calc_DRI_M:

; 934  : 			for( nDRI = nDTIfDRICount; nDRI <= m_nItemCount_Total; nDRI++)	// do you know why? (nDRI <= m_nItemCount_Total)

  00df8	3b 4f 58	 cmp	 ecx, DWORD PTR [edi+88]
  00dfb	0f 8f 87 00 00
	00		 jg	 $LN43@Calc_DRI_M
$LL57@Calc_DRI_M:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 173  : 		PushBackUNK(&Item);

  00e01	8b 8f a8 00 00
	00		 mov	 ecx, DWORD PTR [edi+168]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 935  : 				m_pblaDTIfDRI[ nRQ]->PushBack( nDTI);

  00e07	8b 45 bc	 mov	 eax, DWORD PTR _nDTI$1$[ebp]
  00e0a	89 45 ac	 mov	 DWORD PTR _Item$[ebp], eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 173  : 		PushBackUNK(&Item);

  00e0d	8d 45 ac	 lea	 eax, DWORD PTR _Item$[ebp]
  00e10	50		 push	 eax
  00e11	8b 0c b1	 mov	 ecx, DWORD PTR [ecx+esi*4]
  00e14	e8 00 00 00 00	 call	 ?PushBackUNK@CDataBlockListUNK@@QAEXPAX@Z ; CDataBlockListUNK::PushBackUNK
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 934  : 			for( nDRI = nDTIfDRICount; nDRI <= m_nItemCount_Total; nDRI++)	// do you know why? (nDRI <= m_nItemCount_Total)

  00e19	8b 45 c8	 mov	 eax, DWORD PTR _nDRI$6$[ebp]
  00e1c	40		 inc	 eax
  00e1d	89 45 c8	 mov	 DWORD PTR _nDRI$6$[ebp], eax
  00e20	3b 47 58	 cmp	 eax, DWORD PTR [edi+88]
  00e23	7e dc		 jle	 SHORT $LL57@Calc_DRI_M

; 936  : 		}

  00e25	eb 61		 jmp	 SHORT $LN43@Calc_DRI_M
$LN124@Calc_DRI_M:

; 940  : 			for( nDRI = nDRI_Last; nDRI < nDTIfDRICount; nDRI++)	// do you know why? (nDRI <= m_nItemCount_Total)

  00e27	3b d1		 cmp	 edx, ecx
  00e29	7d 2f		 jge	 SHORT $LN59@Calc_DRI_M
  00e2b	0f 1f 44 00 00	 npad	 5
$LL60@Calc_DRI_M:

; 941  : 				m_pblaDTIfDRI[ nRQ]->SetAt( nDRI, naDTI_Cur[ nRQ]);

  00e30	8b 04 b0	 mov	 eax, DWORD PTR [eax+esi*4]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 183  : 		return SetAtUNK(nIndex, &Item);

  00e33	8b 8f a8 00 00
	00		 mov	 ecx, DWORD PTR [edi+168]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 941  : 				m_pblaDTIfDRI[ nRQ]->SetAt( nDRI, naDTI_Cur[ nRQ]);

  00e39	89 45 ac	 mov	 DWORD PTR _Item$[ebp], eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 183  : 		return SetAtUNK(nIndex, &Item);

  00e3c	8d 45 ac	 lea	 eax, DWORD PTR _Item$[ebp]
  00e3f	50		 push	 eax
  00e40	52		 push	 edx
  00e41	8b 0c b1	 mov	 ecx, DWORD PTR [ecx+esi*4]
  00e44	e8 00 00 00 00	 call	 ?SetAtUNK@CDataBlockListUNK@@QAEHHPAX@Z ; CDataBlockListUNK::SetAtUNK
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 940  : 			for( nDRI = nDRI_Last; nDRI < nDTIfDRICount; nDRI++)	// do you know why? (nDRI <= m_nItemCount_Total)

  00e49	8b 55 b0	 mov	 edx, DWORD PTR _nDRI$5$[ebp]
  00e4c	8b 4d c8	 mov	 ecx, DWORD PTR _nDRI$6$[ebp]
  00e4f	42		 inc	 edx
  00e50	8b 45 c0	 mov	 eax, DWORD PTR _naDTI_Cur$1$[ebp]
  00e53	89 55 b0	 mov	 DWORD PTR _nDRI$5$[ebp], edx
  00e56	3b d1		 cmp	 edx, ecx
  00e58	7c d6		 jl	 SHORT $LL60@Calc_DRI_M
$LN59@Calc_DRI_M:

; 942  : 			for( nDRI = nDTIfDRICount; nDRI <= m_nItemCount_Total; nDRI++)	// do you know why? (nDRI <= m_nItemCount_Total)

  00e5a	3b 4f 58	 cmp	 ecx, DWORD PTR [edi+88]
  00e5d	7f 29		 jg	 SHORT $LN43@Calc_DRI_M
  00e5f	90		 npad	 1
$LL63@Calc_DRI_M:

; 943  : 				m_pblaDTIfDRI[ nRQ]->SetAt( nDRI, naDTI_Cur[ nRQ]);

  00e60	8b 04 b0	 mov	 eax, DWORD PTR [eax+esi*4]
  00e63	89 45 9c	 mov	 DWORD PTR _Item$[ebp], eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 183  : 		return SetAtUNK(nIndex, &Item);

  00e66	8d 45 9c	 lea	 eax, DWORD PTR _Item$[ebp]
  00e69	50		 push	 eax
  00e6a	51		 push	 ecx
  00e6b	8b 8f a8 00 00
	00		 mov	 ecx, DWORD PTR [edi+168]
  00e71	8b 0c b1	 mov	 ecx, DWORD PTR [ecx+esi*4]
  00e74	e8 00 00 00 00	 call	 ?SetAtUNK@CDataBlockListUNK@@QAEHHPAX@Z ; CDataBlockListUNK::SetAtUNK
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 942  : 			for( nDRI = nDTIfDRICount; nDRI <= m_nItemCount_Total; nDRI++)	// do you know why? (nDRI <= m_nItemCount_Total)

  00e79	8b 4d c8	 mov	 ecx, DWORD PTR _nDRI$6$[ebp]
  00e7c	8b 45 c0	 mov	 eax, DWORD PTR _naDTI_Cur$1$[ebp]
  00e7f	41		 inc	 ecx
  00e80	89 4d c8	 mov	 DWORD PTR _nDRI$6$[ebp], ecx
  00e83	3b 4f 58	 cmp	 ecx, DWORD PTR [edi+88]
  00e86	7e d8		 jle	 SHORT $LL63@Calc_DRI_M
$LN43@Calc_DRI_M:

; 883  : 
; 884  : 	// (2009/8/15 - Seung-Won, Bae) After Calc_DRI, we need to calculate the Item Width.
; 885  : 	for( int i = 0; i < _MAX_COL; i++) m_naScreenRegionWidth[ i] = 0;
; 886  : 
; 887  : 	// 3.4 Add End Mark DTI for Calc_AREA()
; 888  : 	//			Cacl_Area() calculate the Area from start DTI to end DTI of view with next DTI.
; 889  : 	//		and Set DTI or none-DTI mark for future DRI
; 890  : 	//		but Do not add time item to a time line of RQs.
; 891  : 	// DTI  ()     DTI   .
; 892  : 	for( nRQ = 0; nRQ < m_nCountOfRQ; nRQ++)

  00e88	46		 inc	 esi
  00e89	89 75 a0	 mov	 DWORD PTR _nRQ$4$[ebp], esi
  00e8c	3b 77 6c	 cmp	 esi, DWORD PTR [edi+108]
  00e8f	0f 8c d0 f9 ff
	ff		 jl	 $LL45@Calc_DRI_M
$LN44@Calc_DRI_M:

; 944  : 		}
; 945  : 	}
; 946  : 	delete [] naDTI_Cur;

  00e95	ff 75 c0	 push	 DWORD PTR _naDTI_Cur$1$[ebp]
  00e98	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00e9d	83 c4 04	 add	 esp, 4

; 947  : 
; 948  : 	// (2009/5/10 - Seung-Won, Bae) Scroll with added and trucated by Real
; 949  : 	if( m_bScrollByReal)

  00ea0	83 bf d8 05 00
	00 00		 cmp	 DWORD PTR [edi+1496], 0
  00ea7	0f 84 53 01 00
	00		 je	 $LN138@Calc_DRI_M

; 950  : 	{
; 951  : 		int nItemCount_Pre = m_nItemCount_Total;

  00ead	8b 47 58	 mov	 eax, DWORD PTR [edi+88]

; 952  : 		int nDRI_Start_Pre = m_nDRI_Start_Cur;
; 953  : 		int nDrawCount_Pre = m_nDrawCount_Cur;
; 954  : 
; 955  : 		m_bScrollByReal = FALSE;
; 956  : 		if( m_pIChartCtrl->IsWholeView())

  00eb0	8b 4f 50	 mov	 ecx, DWORD PTR [edi+80]
  00eb3	89 45 b4	 mov	 DWORD PTR _nItemCount_Pre$1$[ebp], eax
  00eb6	8b 47 28	 mov	 eax, DWORD PTR [edi+40]
  00eb9	89 45 a0	 mov	 DWORD PTR _nDRI_Start_Pre$1$[ebp], eax
  00ebc	8b 47 30	 mov	 eax, DWORD PTR [edi+48]
  00ebf	89 45 98	 mov	 DWORD PTR _nDrawCount_Pre$1$[ebp], eax
  00ec2	c7 87 d8 05 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+1496], 0
  00ecc	8b 01		 mov	 eax, DWORD PTR [ecx]
  00ece	8b 40 50	 mov	 eax, DWORD PTR [eax+80]
  00ed1	ff d0		 call	 eax
  00ed3	84 c0		 test	 al, al
  00ed5	74 0d		 je	 SHORT $LN127@Calc_DRI_M

; 957  : 		{
; 958  : 			m_nDrawCount_Cur = m_nItemCount_Total;

  00ed7	8b 4f 58	 mov	 ecx, DWORD PTR [edi+88]

; 959  : 			m_nDRI_End_Cur = m_nDrawCount_Cur - 1;

  00eda	8b d1		 mov	 edx, ecx
  00edc	89 4f 30	 mov	 DWORD PTR [edi+48], ecx
  00edf	8d 41 ff	 lea	 eax, DWORD PTR [ecx-1]

; 960  : 		}

  00ee2	eb 69		 jmp	 SHORT $LN128@Calc_DRI_M
$LN127@Calc_DRI_M:

; 961  : 		else
; 962  : 		{
; 963  : 			// (2009/1/14 - Seung-Won, Bae) Support Pixel Arranging.
; 964  : 			if( m_nCountOfBlockColumn == 1) if( 1 < m_nScreenWidth_Cur[ 0] && m_nScreenWidth_Cur[ 0] < m_nDrawCount_Cur && !m_bWeightedVolume)

  00ee4	83 bf 2c 01 00
	00 01		 cmp	 DWORD PTR [edi+300], 1
  00eeb	75 52		 jne	 SHORT $LN130@Calc_DRI_M
  00eed	8b 87 38 03 00
	00		 mov	 eax, DWORD PTR [edi+824]
  00ef3	83 f8 01	 cmp	 eax, 1
  00ef6	7e 47		 jle	 SHORT $LN130@Calc_DRI_M
  00ef8	8b 57 30	 mov	 edx, DWORD PTR [edi+48]
  00efb	3b c2		 cmp	 eax, edx
  00efd	7d 40		 jge	 SHORT $LN130@Calc_DRI_M
  00eff	83 7f 10 00	 cmp	 DWORD PTR [edi+16], 0
  00f03	75 3a		 jne	 SHORT $LN130@Calc_DRI_M

; 965  : 			{
; 966  : 				m_nScreenWidth_Cur[ 0]--;	// leave the one pixel for real area.

  00f05	8d 48 ff	 lea	 ecx, DWORD PTR [eax-1]

; 967  : 				int nOnOnePixel = m_nDrawCount_Cur;
; 968  : 				if( 0 < m_nScreenWidth_Cur[ 0]) nOnOnePixel /= m_nScreenWidth_Cur[ 0];

  00f08	8b c2		 mov	 eax, edx
  00f0a	99		 cdq
  00f0b	f7 f9		 idiv	 ecx

; 969  : 				nOnOnePixel++;			// the number of max data count for one pixel.

  00f0d	8d 70 01	 lea	 esi, DWORD PTR [eax+1]

; 970  : 				int nLeftDataCountOverAverage = m_nDrawCount_Cur % m_nScreenWidth_Cur[ 0];

  00f10	8b 47 30	 mov	 eax, DWORD PTR [edi+48]
  00f13	99		 cdq
  00f14	f7 f9		 idiv	 ecx

; 971  : 				int nLeftDataOnRealArea = nLeftDataCountOverAverage % nOnOnePixel + 1;

  00f16	8b c2		 mov	 eax, edx
  00f18	99		 cdq
  00f19	f7 fe		 idiv	 esi
  00f1b	8d 4a 01	 lea	 ecx, DWORD PTR [edx+1]

; 972  : 				int nNewLeftDataOnRealArea = ( nLeftDataOnRealArea + m_nItemCount_Total - nItemCount_Prev) % nOnOnePixel;

  00f1e	8b c1		 mov	 eax, ecx
  00f20	2b 45 8c	 sub	 eax, DWORD PTR _nItemCount_Prev$1$[ebp]
  00f23	03 47 58	 add	 eax, DWORD PTR [edi+88]
  00f26	99		 cdq
  00f27	f7 fe		 idiv	 esi

; 973  : 				if( 0 == nNewLeftDataOnRealArea) nNewLeftDataOnRealArea = nOnOnePixel;
; 974  : 				m_nDrawCount_Cur += ( nNewLeftDataOnRealArea - nLeftDataOnRealArea);

  00f29	85 d2		 test	 edx, edx
  00f2b	0f 45 f2	 cmovne	 esi, edx
  00f2e	2b f1		 sub	 esi, ecx
  00f30	01 77 30	 add	 DWORD PTR [edi+48], esi

; 975  : 				m_nScreenWidth_Cur[ 0]++;	// leave the one pixel for real area.

  00f33	8b 87 38 03 00
	00		 mov	 eax, DWORD PTR [edi+824]
  00f39	89 87 38 03 00
	00		 mov	 DWORD PTR [edi+824], eax
$LN130@Calc_DRI_M:

; 976  : 			}
; 977  : 			
; 978  : 			m_nDRI_End_Cur += m_nItemCount_Total - nItemCount_Prev;

  00f3f	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  00f42	2b 45 8c	 sub	 eax, DWORD PTR _nItemCount_Prev$1$[ebp]
  00f45	8b 57 58	 mov	 edx, DWORD PTR [edi+88]
  00f48	03 c2		 add	 eax, edx
  00f4a	8b 4f 30	 mov	 ecx, DWORD PTR [edi+48]
$LN128@Calc_DRI_M:

; 979  : 		}
; 980  : 		
; 981  : 		m_nDRI_Start_Cur = m_nDRI_End_Cur - m_nDrawCount_Cur + 1;

  00f4d	89 47 2c	 mov	 DWORD PTR [edi+44], eax
  00f50	2b c1		 sub	 eax, ecx
  00f52	83 c0 01	 add	 eax, 1
  00f55	89 47 28	 mov	 DWORD PTR [edi+40], eax

; 982  : 		if( m_nDRI_Start_Cur < 0)

  00f58	79 0d		 jns	 SHORT $LN439@Calc_DRI_M

; 983  : 		{
; 984  : 			m_nDRI_End_Cur = m_nDrawCount_Cur - 1;

  00f5a	8d 41 ff	 lea	 eax, DWORD PTR [ecx-1]

; 985  : 			m_nDRI_Start_Cur = 0;

  00f5d	c7 47 28 00 00
	00 00		 mov	 DWORD PTR [edi+40], 0
  00f64	89 47 2c	 mov	 DWORD PTR [edi+44], eax
$LN439@Calc_DRI_M:

; 986  : 		}
; 987  : 
; 988  : 		// (2009/1/8 - Seung-Won, Bae) Update Count and Start to avoid the right indent too large.
; 989  : 		if( m_nItemCount_Total <= m_nDRI_End_Cur)

  00f67	3b 57 2c	 cmp	 edx, DWORD PTR [edi+44]
  00f6a	7f 12		 jg	 SHORT $LN134@Calc_DRI_M

; 990  : 		{
; 991  : 			m_nDrawCount_Cur = m_nItemCount_Total;

  00f6c	8b ca		 mov	 ecx, edx

; 992  : 			m_nDRI_End_Cur = m_nDrawCount_Cur - 1;
; 993  : 			m_nDRI_Start_Cur = m_nDRI_End_Cur - m_nDrawCount_Cur + 1;

  00f6e	c7 47 28 00 00
	00 00		 mov	 DWORD PTR [edi+40], 0
  00f75	89 4f 30	 mov	 DWORD PTR [edi+48], ecx
  00f78	8d 41 ff	 lea	 eax, DWORD PTR [ecx-1]
  00f7b	89 47 2c	 mov	 DWORD PTR [edi+44], eax
$LN134@Calc_DRI_M:

; 994  : 		}
; 995  : 		
; 996  : 		if( m_nDrawCount_Cur != m_nDrawCount_Pre
; 997  : 			|| m_pIChartCtrl->IsWholeView() && !m_bWholeViewPre
; 998  : 			|| !m_pIChartCtrl->IsWholeView() && m_bWholeViewPre)

  00f7e	3b 8f 00 01 00
	00		 cmp	 ecx, DWORD PTR [edi+256]
  00f84	75 2e		 jne	 SHORT $LN136@Calc_DRI_M
  00f86	8b 4f 50	 mov	 ecx, DWORD PTR [edi+80]
  00f89	8b 01		 mov	 eax, DWORD PTR [ecx]
  00f8b	8b 40 50	 mov	 eax, DWORD PTR [eax+80]
  00f8e	ff d0		 call	 eax
  00f90	84 c0		 test	 al, al
  00f92	74 09		 je	 SHORT $LN440@Calc_DRI_M
  00f94	83 bf f8 00 00
	00 00		 cmp	 DWORD PTR [edi+248], 0
  00f9b	74 17		 je	 SHORT $LN136@Calc_DRI_M
$LN440@Calc_DRI_M:
  00f9d	8b 4f 50	 mov	 ecx, DWORD PTR [edi+80]
  00fa0	8b 01		 mov	 eax, DWORD PTR [ecx]
  00fa2	8b 40 50	 mov	 eax, DWORD PTR [eax+80]
  00fa5	ff d0		 call	 eax
  00fa7	84 c0		 test	 al, al
  00fa9	75 2b		 jne	 SHORT $LN65@Calc_DRI_M
  00fab	83 bf f8 00 00
	00 00		 cmp	 DWORD PTR [edi+248], 0
  00fb2	74 22		 je	 SHORT $LN65@Calc_DRI_M
$LN136@Calc_DRI_M:

; 999  : 			for( int i = 0; i < m_nCountOfBlockColumn; i++) Calc_ItemWidth( i, m_nDrawCount_Cur);

  00fb4	33 f6		 xor	 esi, esi
  00fb6	39 b7 2c 01 00
	00		 cmp	 DWORD PTR [edi+300], esi
  00fbc	7e 18		 jle	 SHORT $LN65@Calc_DRI_M
  00fbe	66 90		 npad	 2
$LL66@Calc_DRI_M:
  00fc0	6a 00		 push	 0
  00fc2	ff 77 30	 push	 DWORD PTR [edi+48]
  00fc5	8b cf		 mov	 ecx, edi
  00fc7	56		 push	 esi
  00fc8	e8 00 00 00 00	 call	 ?Calc_ItemWidth@CXScaleManagerImp@@IAEXHHH@Z ; CXScaleManagerImp::Calc_ItemWidth
  00fcd	46		 inc	 esi
  00fce	3b b7 2c 01 00
	00		 cmp	 esi, DWORD PTR [edi+300]
  00fd4	7c ea		 jl	 SHORT $LL66@Calc_DRI_M
$LN65@Calc_DRI_M:

; 1000 : 
; 1001 : 		// 3. Update ScrollBar and Zoom SliderBar
; 1002 : 		if( nItemCount_Pre != m_nItemCount_Total
; 1003 : 			|| nDRI_Start_Pre != m_nDRI_Start_Cur
; 1004 : 			|| nDrawCount_Pre != m_nDrawCount_Cur)

  00fd6	8b 57 58	 mov	 edx, DWORD PTR [edi+88]
  00fd9	39 55 b4	 cmp	 DWORD PTR _nItemCount_Pre$1$[ebp], edx
  00fdc	75 10		 jne	 SHORT $LN139@Calc_DRI_M
  00fde	8b 45 a0	 mov	 eax, DWORD PTR _nDRI_Start_Pre$1$[ebp]
  00fe1	3b 47 28	 cmp	 eax, DWORD PTR [edi+40]
  00fe4	75 08		 jne	 SHORT $LN139@Calc_DRI_M
  00fe6	8b 45 98	 mov	 eax, DWORD PTR _nDrawCount_Pre$1$[ebp]
  00fe9	3b 47 30	 cmp	 eax, DWORD PTR [edi+48]
  00fec	74 12		 je	 SHORT $LN138@Calc_DRI_M
$LN139@Calc_DRI_M:

; 1005 : 			m_pIChartCtrl->UpdateZoomAndScrollInfo( m_nItemCount_Total, m_nDRI_Start_Cur, m_nDrawCount_Cur);

  00fee	8b 4f 50	 mov	 ecx, DWORD PTR [edi+80]
  00ff1	ff 77 30	 push	 DWORD PTR [edi+48]
  00ff4	ff 77 28	 push	 DWORD PTR [edi+40]
  00ff7	8b 01		 mov	 eax, DWORD PTR [ecx]
  00ff9	52		 push	 edx
  00ffa	ff 90 10 08 00
	00		 call	 DWORD PTR [eax+2064]
$LN138@Calc_DRI_M:

; 1007 : }

  01000	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  01003	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0100a	59		 pop	 ecx
  0100b	5f		 pop	 edi
  0100c	5e		 pop	 esi
  0100d	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01010	33 cd		 xor	 ecx, ebp
  01012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01017	8b e5		 mov	 esp, ebp
  01019	5d		 pop	 ebp
  0101a	c3		 ret	 0
$LN305@Calc_DRI_M:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl

; 290  : 			AfxThrowInvalidArgException();

  0101b	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN493@Calc_DRI_M:
$LN447@Calc_DRI_M:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 1007 : }

  01020	00 00 00 00	 DD	 $LN108@Calc_DRI_M
  01024	00 00 00 00	 DD	 $LN113@Calc_DRI_M
$LN446@Calc_DRI_M:
  01028	00		 DB	 0
  01029	00		 DB	 0
  0102a	00		 DB	 0
  0102b	01		 DB	 1
  0102c	01		 DB	 1
  0102d	01		 DB	 1
  0102e	01		 DB	 1
  0102f	01		 DB	 1
  01030	00		 DB	 0
  01031	0f 1f 00	 npad	 3
$LN449@Calc_DRI_M:
  01034	00 00 00 00	 DD	 $LN114@Calc_DRI_M
  01038	00 00 00 00	 DD	 $LN119@Calc_DRI_M
$LN448@Calc_DRI_M:
  0103c	00		 DB	 0
  0103d	00		 DB	 0
  0103e	00		 DB	 0
  0103f	01		 DB	 1
  01040	01		 DB	 1
  01041	01		 DB	 1
  01042	01		 DB	 1
  01043	01		 DB	 1
  01044	00		 DB	 0
  01045	0f 1f 00	 npad	 3
$LN451@Calc_DRI_M:
  01048	00 00 00 00	 DD	 $LN252@Calc_DRI_M
  0104c	00 00 00 00	 DD	 $LN251@Calc_DRI_M
  01050	00 00 00 00	 DD	 $LN250@Calc_DRI_M
  01054	00 00 00 00	 DD	 $LN255@Calc_DRI_M
  01058	00 00 00 00	 DD	 $LN249@Calc_DRI_M
  0105c	00 00 00 00	 DD	 $LN255@Calc_DRI_M
  01060	00 00 00 00	 DD	 $LN249@Calc_DRI_M
  01064	00 00 00 00	 DD	 $LN249@Calc_DRI_M
  01068	00 00 00 00	 DD	 $LN249@Calc_DRI_M
  0106c	00 00 00 00	 DD	 $LN249@Calc_DRI_M
  01070	00 00 00 00	 DD	 $LN249@Calc_DRI_M
  01074	00 00 00 00	 DD	 $LN255@Calc_DRI_M
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Calc_DRI_Merge@CXScaleManagerImp@@MAEXXZ$0:
  00000	8d 4d 98	 lea	 ecx, DWORD PTR _strTime$3[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?Calc_DRI_Merge@CXScaleManagerImp@@MAEXXZ$1:
  00009	8d 4d a0	 lea	 ecx, DWORD PTR _strTimeType$4[ebp]
  0000c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
  00015	cc		 int	 3
  00016	cc		 int	 3
__ehhandler$?Calc_DRI_Merge@CXScaleManagerImp@@MAEXXZ:
  00017	90		 npad	 1
  00018	90		 npad	 1
  00019	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00020	8b 8a 6c ff ff
	ff		 mov	 ecx, DWORD PTR [edx-148]
  00026	33 c8		 xor	 ecx, eax
  00028	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002d	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00030	33 c8		 xor	 ecx, eax
  00032	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00037	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Calc_DRI_Merge@CXScaleManagerImp@@MAEXXZ
  0003c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Calc_DRI_Merge@CXScaleManagerImp@@MAEXXZ ENDP		; CXScaleManagerImp::Calc_DRI_Merge
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?Calc_DRI@CXScaleManagerImp@@MAEXH@Z
_TEXT	SEGMENT
$T2 = -184						; size = 12
$T3 = -172						; size = 16
__Loc$4 = -156						; size = 12
$T5 = -144						; size = 8
_nMarketStartTime$ = -136				; size = 4
_nMarketEndTime$ = -132					; size = 4
$T6 = -128						; size = 4
$T7 = -124						; size = 4
$T8 = -120						; size = 4
_saRQ$ = -116						; size = 20
_strType$9 = -96					; size = 4
_pifaOEBT$1$ = -92					; size = 4
$T10 = -92						; size = 4
$T11 = -88						; size = 4
$T12 = -88						; size = 4
_nRQ$2$ = -84						; size = 4
$T13 = -84						; size = 4
_pmapPacketList$1$ = -84				; size = 4
__Myhead$1$ = -80					; size = 4
tv4324 = -80						; size = 4
tv4317 = -80						; size = 4
__Right_size$1$ = -76					; size = 4
tv4314 = -76						; size = 4
tv4171 = -76						; size = 4
$T14 = -72						; size = 4
tv4257 = -72						; size = 4
_this$GSCopy$1$ = -68					; size = 4
__Ptr$1$ = -64						; size = 4
_pPacketList$1$ = -64					; size = 4
__Result$1$ = -60					; size = 4
tv4335 = -60						; size = 4
tv4224 = -60						; size = 4
tv4172 = -60						; size = 4
$T15 = -60						; size = 4
$T16 = -60						; size = 4
$T17 = -60						; size = 4
$T18 = -60						; size = 4
_nRQ$1$ = -56						; size = 4
__Result$1$ = -52					; size = 4
tv4318 = -52						; size = 4
$T19 = -48						; size = 4
tv4322 = -48						; size = 4
tv4250 = -48						; size = 4
$T20 = -44						; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_p_bWithMerge$ = 8					; size = 4
?Calc_DRI@CXScaleManagerImp@@MAEXH@Z PROC		; CXScaleManagerImp::Calc_DRI, COMDAT
; _this$ = ecx

; 306  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Calc_DRI@CXScaleManagerImp@@MAEXH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec ac 00 00
	00		 sub	 esp, 172		; 000000acH
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	56		 push	 esi
  00022	57		 push	 edi
  00023	50		 push	 eax
  00024	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00027	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002d	8b f9		 mov	 edi, ecx
  0002f	89 7d bc	 mov	 DWORD PTR _this$GSCopy$1$[ebp], edi
  00032	33 c0		 xor	 eax, eax
  00034	89 45 c4	 mov	 DWORD PTR $T15[ebp], eax
  00037	89 45 b8	 mov	 DWORD PTR $T14[ebp], eax

; 307  : 	// (2009/5/10 - Seung-Won, Bae) Scroll with added and trucated by Real
; 308  : 	if( m_bTruncatedByReal) m_bTruncatedByReal = FALSE;

  0003a	39 87 dc 05 00
	00		 cmp	 DWORD PTR [edi+1500], eax
  00040	74 06		 je	 SHORT $LN34@Calc_DRI
  00042	89 87 dc 05 00
	00		 mov	 DWORD PTR [edi+1500], eax
$LN34@Calc_DRI:

; 309  : 
; 310  : 	// 20080925 JS.Kim	   Scale .  <<
; 311  : 	int nMarketStartTime, nMarketEndTime;
; 312  : 	m_TimeDiffManager.InitRQDiffTime();

  00048	8d 8f ec 05 00
	00		 lea	 ecx, DWORD PTR [edi+1516]
  0004e	e8 00 00 00 00	 call	 ?InitRQDiffTime@CXScaleTimeDiffManager@@QAEXXZ ; CXScaleTimeDiffManager::InitRQDiffTime

; 313  : 	m_TimeDiffManager.InitRQMarketTime();

  00053	8d 8f ec 05 00
	00		 lea	 ecx, DWORD PTR [edi+1516]
  00059	e8 00 00 00 00	 call	 ?InitRQMarketTime@CXScaleTimeDiffManager@@QAEXXZ ; CXScaleTimeDiffManager::InitRQMarketTime

; 314  : 	m_bTimeScale = false;
; 315  : 	//>>
; 316  : 
; 317  : 	// (2009/1/13 - Seung-Won, Bae) for ReCalc AREA
; 318  : 	m_nNeedCalcArea = 2;
; 319  : 
; 320  : 	// 1. Destroy and Rebuild RQ Infos.
; 321  : 	// 1.1 Destroy All Data
; 322  : 	// 1.1.1 Destroy All RQ Data.
; 323  : 	m_midxRQ.clear();

  0005e	8d 47 70	 lea	 eax, DWORD PTR [edi+112]
  00061	c6 87 14 06 00
	00 00		 mov	 BYTE PTR [edi+1556], 0
  00068	c7 87 fc 00 00
	00 02 00 00 00	 mov	 DWORD PTR [edi+252], 2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1343 :         _Scary->_Erase_tree(_Getal(), _Head->_Parent);

  00072	8b c8		 mov	 ecx, eax
  00074	8b 30		 mov	 esi, DWORD PTR [eax]
  00076	ff 76 04	 push	 DWORD PTR [esi+4]
  00079	50		 push	 eax
  0007a	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> > >

; 1344 :         _Head->_Parent  = _Head;

  0007f	89 76 04	 mov	 DWORD PTR [esi+4], esi

; 1345 :         _Head->_Left    = _Head;

  00082	89 36		 mov	 DWORD PTR [esi], esi

; 1346 :         _Head->_Right   = _Head;

  00084	89 76 08	 mov	 DWORD PTR [esi+8], esi

; 1347 :         _Scary->_Mysize = 0;

  00087	c7 47 74 00 00
	00 00		 mov	 DWORD PTR [edi+116], 0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 324  : 	if(m_pifaRQ != NULL)

  0008e	8b 87 8c 00 00
	00		 mov	 eax, DWORD PTR [edi+140]
  00094	85 c0		 test	 eax, eax
  00096	74 3a		 je	 SHORT $LN35@Calc_DRI

; 325  : 	{
; 326  : 		for( int nRQ = 0; nRQ < m_nCountOfRQ; nRQ++) delete m_pifaRQ[ nRQ];

  00098	33 f6		 xor	 esi, esi
  0009a	39 77 6c	 cmp	 DWORD PTR [edi+108], esi
  0009d	7e 20		 jle	 SHORT $LN3@Calc_DRI
  0009f	90		 npad	 1
$LL4@Calc_DRI:
  000a0	8b 87 8c 00 00
	00		 mov	 eax, DWORD PTR [edi+140]
  000a6	6a 40		 push	 64			; 00000040H
  000a8	ff 34 b0	 push	 DWORD PTR [eax+esi*4]
  000ab	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  000b0	46		 inc	 esi
  000b1	83 c4 08	 add	 esp, 8
  000b4	3b 77 6c	 cmp	 esi, DWORD PTR [edi+108]
  000b7	7c e7		 jl	 SHORT $LL4@Calc_DRI
  000b9	8b 87 8c 00 00
	00		 mov	 eax, DWORD PTR [edi+140]
$LN3@Calc_DRI:

; 327  : 		delete [] m_pifaRQ;

  000bf	50		 push	 eax
  000c0	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  000c5	83 c4 04	 add	 esp, 4

; 328  : 		m_pifaRQ = NULL;

  000c8	c7 87 8c 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+140], 0
$LN35@Calc_DRI:

; 329  : 	}
; 330  : 	// 1.1.2 Destroy Data indexed DTI
; 331  : 	if( m_pblaRQTime != NULL)

  000d2	8b 87 9c 00 00
	00		 mov	 eax, DWORD PTR [edi+156]
  000d8	85 c0		 test	 eax, eax
  000da	74 39		 je	 SHORT $LN36@Calc_DRI

; 332  : 	{
; 333  : 		for( int nRQ = 0; nRQ < m_nCountOfRQ; nRQ++) delete m_pblaRQTime[ nRQ];

  000dc	33 f6		 xor	 esi, esi
  000de	39 77 6c	 cmp	 DWORD PTR [edi+108], esi
  000e1	7e 1f		 jle	 SHORT $LN6@Calc_DRI
$LL7@Calc_DRI:
  000e3	8b 87 9c 00 00
	00		 mov	 eax, DWORD PTR [edi+156]
  000e9	8b 0c b0	 mov	 ecx, DWORD PTR [eax+esi*4]
  000ec	85 c9		 test	 ecx, ecx
  000ee	74 0c		 je	 SHORT $LN5@Calc_DRI
  000f0	8b 01		 mov	 eax, DWORD PTR [ecx]
  000f2	6a 01		 push	 1
  000f4	ff 10		 call	 DWORD PTR [eax]
  000f6	8b 87 9c 00 00
	00		 mov	 eax, DWORD PTR [edi+156]
$LN5@Calc_DRI:
  000fc	46		 inc	 esi
  000fd	3b 77 6c	 cmp	 esi, DWORD PTR [edi+108]
  00100	7c e1		 jl	 SHORT $LL7@Calc_DRI
$LN6@Calc_DRI:

; 334  : 		delete [] m_pblaRQTime;

  00102	50		 push	 eax
  00103	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00108	83 c4 04	 add	 esp, 4

; 335  : 		m_pblaRQTime = NULL;

  0010b	c7 87 9c 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+156], 0
$LN36@Calc_DRI:

; 336  : 	}
; 337  : 	if( m_pblaDRIfDTI != NULL)

  00115	8b 87 a0 00 00
	00		 mov	 eax, DWORD PTR [edi+160]
  0011b	85 c0		 test	 eax, eax
  0011d	74 43		 je	 SHORT $LN37@Calc_DRI

; 338  : 	{
; 339  : 		for( int nRQ = 0; nRQ < m_nCountOfRQ; nRQ++) delete m_pblaDRIfDTI[ nRQ];

  0011f	33 f6		 xor	 esi, esi
  00121	39 77 6c	 cmp	 DWORD PTR [edi+108], esi
  00124	7e 29		 jle	 SHORT $LN9@Calc_DRI
  00126	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL10@Calc_DRI:
  00130	8b 87 a0 00 00
	00		 mov	 eax, DWORD PTR [edi+160]
  00136	8b 0c b0	 mov	 ecx, DWORD PTR [eax+esi*4]
  00139	85 c9		 test	 ecx, ecx
  0013b	74 0c		 je	 SHORT $LN8@Calc_DRI
  0013d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0013f	6a 01		 push	 1
  00141	ff 10		 call	 DWORD PTR [eax]
  00143	8b 87 a0 00 00
	00		 mov	 eax, DWORD PTR [edi+160]
$LN8@Calc_DRI:
  00149	46		 inc	 esi
  0014a	3b 77 6c	 cmp	 esi, DWORD PTR [edi+108]
  0014d	7c e1		 jl	 SHORT $LL10@Calc_DRI
$LN9@Calc_DRI:

; 340  : 		delete [] m_pblaDRIfDTI;

  0014f	50		 push	 eax
  00150	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00155	83 c4 04	 add	 esp, 4

; 341  : 		m_pblaDRIfDTI = NULL;

  00158	c7 87 a0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+160], 0
$LN37@Calc_DRI:

; 342  : 	}
; 343  : 	// 1.1.3 Destroy Data indexed DRI
; 344  : 	if( m_pblaDTIfDRI != NULL)

  00162	8b 87 a8 00 00
	00		 mov	 eax, DWORD PTR [edi+168]
  00168	85 c0		 test	 eax, eax
  0016a	74 39		 je	 SHORT $LN38@Calc_DRI

; 345  : 	{
; 346  : 		for( int nRQ = 0; nRQ < m_nCountOfRQ; nRQ++) delete m_pblaDTIfDRI[ nRQ];

  0016c	33 f6		 xor	 esi, esi
  0016e	39 77 6c	 cmp	 DWORD PTR [edi+108], esi
  00171	7e 1f		 jle	 SHORT $LN12@Calc_DRI
$LL13@Calc_DRI:
  00173	8b 87 a8 00 00
	00		 mov	 eax, DWORD PTR [edi+168]
  00179	8b 0c b0	 mov	 ecx, DWORD PTR [eax+esi*4]
  0017c	85 c9		 test	 ecx, ecx
  0017e	74 0c		 je	 SHORT $LN11@Calc_DRI
  00180	8b 01		 mov	 eax, DWORD PTR [ecx]
  00182	6a 01		 push	 1
  00184	ff 10		 call	 DWORD PTR [eax]
  00186	8b 87 a8 00 00
	00		 mov	 eax, DWORD PTR [edi+168]
$LN11@Calc_DRI:
  0018c	46		 inc	 esi
  0018d	3b 77 6c	 cmp	 esi, DWORD PTR [edi+108]
  00190	7c e1		 jl	 SHORT $LL13@Calc_DRI
$LN12@Calc_DRI:

; 347  : 		delete [] m_pblaDTIfDRI;

  00192	50		 push	 eax
  00193	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00198	83 c4 04	 add	 esp, 4

; 348  : 		m_pblaDTIfDRI = NULL;

  0019b	c7 87 a8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+168], 0
$LN38@Calc_DRI:

; 349  : 	}
; 350  : 	// 1.1.4 Destroy Data special time.
; 351  : 	if( m_pamapSpecialTime != NULL)

  001a5	8b 87 a4 00 00
	00		 mov	 eax, DWORD PTR [edi+164]
  001ab	85 c0		 test	 eax, eax
  001ad	74 44		 je	 SHORT $LN39@Calc_DRI

; 352  : 	{
; 353  : 		for( int nRQ = 0; nRQ < m_nCountOfRQ; nRQ++) delete m_pamapSpecialTime[ nRQ];

  001af	33 f6		 xor	 esi, esi
  001b1	39 77 6c	 cmp	 DWORD PTR [edi+108], esi
  001b4	7e 2a		 jle	 SHORT $LN15@Calc_DRI
  001b6	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL16@Calc_DRI:
  001c0	8b 87 a4 00 00
	00		 mov	 eax, DWORD PTR [edi+164]
  001c6	8b 0c b0	 mov	 ecx, DWORD PTR [eax+esi*4]
  001c9	85 c9		 test	 ecx, ecx
  001cb	74 0d		 je	 SHORT $LN14@Calc_DRI
  001cd	8b 01		 mov	 eax, DWORD PTR [ecx]
  001cf	6a 01		 push	 1
  001d1	ff 50 04	 call	 DWORD PTR [eax+4]
  001d4	8b 87 a4 00 00
	00		 mov	 eax, DWORD PTR [edi+164]
$LN14@Calc_DRI:
  001da	46		 inc	 esi
  001db	3b 77 6c	 cmp	 esi, DWORD PTR [edi+108]
  001de	7c e0		 jl	 SHORT $LL16@Calc_DRI
$LN15@Calc_DRI:

; 354  : 		delete [] m_pamapSpecialTime;

  001e0	50		 push	 eax
  001e1	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  001e6	83 c4 04	 add	 esp, 4

; 355  : 		m_pamapSpecialTime = NULL;

  001e9	c7 87 a4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+164], 0
$LN39@Calc_DRI:

; 356  : 	}
; 357  : 	// 1.2 Clear Data.
; 358  : 	// 1.2.1 Clear main time line.
; 359  : 	// X   
; 360  : 	m_blTimefDRI.Clear();

  001f3	8d 8f ac 00 00
	00		 lea	 ecx, DWORD PTR [edi+172]
  001f9	e8 00 00 00 00	 call	 ?Clear@CDataBlockListUNK@@QAEXXZ ; CDataBlockListUNK::Clear

; 361  : 	// 1.2.2 Init min/max Scale Interval Info.
; 362  : 	m_minScaleInterval_nRQ = 0;
; 363  : 	m_maxScaleInterval_nRQ = 0;
; 364  : 	// 1.4 Create All Data (reverse order)
; 365  : 	// 1.4.0 Check no RQs.
; 366  : 	MAP_RQ_PACKETLIST* pmapPacketList = ( MAP_RQ_PACKETLIST*)m_ppacketListManager->GetMapPacketList();

  001fe	8b 4f 48	 mov	 ecx, DWORD PTR [edi+72]
  00201	c7 87 ec 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+236], 0
  0020b	c7 87 e0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+224], 0
  00215	8b 01		 mov	 eax, DWORD PTR [ecx]
  00217	8b 40 28	 mov	 eax, DWORD PTR [eax+40]
  0021a	ff d0		 call	 eax
  0021c	8b f0		 mov	 esi, eax
  0021e	89 75 ac	 mov	 DWORD PTR _pmapPacketList$1$[ebp], esi

; 367  : 	m_nCountOfRQ = pmapPacketList->size();

  00221	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00224	89 47 6c	 mov	 DWORD PTR [edi+108], eax

; 368  : 	if( 0 == m_nCountOfRQ)

  00227	85 c0		 test	 eax, eax
  00229	75 6c		 jne	 SHORT $LN40@Calc_DRI

; 369  : 	{
; 370  : 		for( int nRQ = 0; nRQ < m_saRQ.GetSize(); nRQ++)

  0022b	33 f6		 xor	 esi, esi
  0022d	39 b7 80 00 00
	00		 cmp	 DWORD PTR [edi+128], esi
  00233	7e 39		 jle	 SHORT $LN18@Calc_DRI
  00235	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL19@Calc_DRI:

; 371  : 			if( m_pifaOEBT[ nRQ]) delete m_pifaOEBT[ nRQ];

  00240	8b 87 90 00 00
	00		 mov	 eax, DWORD PTR [edi+144]
  00246	8b 04 b0	 mov	 eax, DWORD PTR [eax+esi*4]
  00249	89 45 ac	 mov	 DWORD PTR $T13[ebp], eax
  0024c	85 c0		 test	 eax, eax
  0024e	74 15		 je	 SHORT $LN17@Calc_DRI
  00250	8b c8		 mov	 ecx, eax
  00252	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00258	6a 08		 push	 8
  0025a	ff 75 ac	 push	 DWORD PTR $T13[ebp]
  0025d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00262	83 c4 08	 add	 esp, 8
$LN17@Calc_DRI:

; 369  : 	{
; 370  : 		for( int nRQ = 0; nRQ < m_saRQ.GetSize(); nRQ++)

  00265	46		 inc	 esi
  00266	3b b7 80 00 00
	00		 cmp	 esi, DWORD PTR [edi+128]
  0026c	7c d2		 jl	 SHORT $LL19@Calc_DRI
$LN18@Calc_DRI:

; 372  : 		delete [] m_pifaOEBT;

  0026e	ff b7 90 00 00
	00		 push	 DWORD PTR [edi+144]
  00274	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00279	83 c4 04	 add	 esp, 4

; 373  : 		m_pifaOEBT = NULL;

  0027c	c7 87 90 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+144], 0

; 374  : 		m_saRQ.RemoveAll();

  00286	8d 4f 78	 lea	 ecx, DWORD PTR [edi+120]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl

; 286  : 	{ SetSize(0); }

  00289	6a ff		 push	 -1
  0028b	6a 00		 push	 0
  0028d	e8 00 00 00 00	 call	 ?SetSize@CStringArray@@QAEXHH@Z ; CStringArray::SetSize
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 375  : 		return;

  00292	e9 4b 0b 00 00	 jmp	 $LN1@Calc_DRI
$LN40@Calc_DRI:

; 376  : 	}
; 377  : 	// 1.4.1 Create Data indexed DRI
; 378  : 	m_pblaDTIfDRI = (CDataBlockList<int>**)(new LPVOID[m_nCountOfRQ]);

  00297	33 c9		 xor	 ecx, ecx
  00299	ba 04 00 00 00	 mov	 edx, 4
  0029e	f7 e2		 mul	 edx
  002a0	0f 90 c1	 seto	 cl
  002a3	f7 d9		 neg	 ecx
  002a5	0b c8		 or	 ecx, eax
  002a7	51		 push	 ecx
  002a8	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  002ad	89 87 a8 00 00
	00		 mov	 DWORD PTR [edi+168], eax

; 379  : 	// 1.4.2 Create Data indexed DTI
; 380  : 	m_pblaRQTime = (CDataBlockList<time_t>**)(new LPVOID[m_nCountOfRQ]);

  002b3	33 c9		 xor	 ecx, ecx
  002b5	8b 47 6c	 mov	 eax, DWORD PTR [edi+108]
  002b8	ba 04 00 00 00	 mov	 edx, 4
  002bd	f7 e2		 mul	 edx
  002bf	0f 90 c1	 seto	 cl
  002c2	f7 d9		 neg	 ecx
  002c4	0b c8		 or	 ecx, eax
  002c6	51		 push	 ecx
  002c7	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  002cc	89 87 9c 00 00
	00		 mov	 DWORD PTR [edi+156], eax

; 381  : 	m_pblaDRIfDTI = (CDataBlockList<int>**)(new LPVOID[m_nCountOfRQ]);

  002d2	33 c9		 xor	 ecx, ecx
  002d4	8b 47 6c	 mov	 eax, DWORD PTR [edi+108]
  002d7	ba 04 00 00 00	 mov	 edx, 4
  002dc	f7 e2		 mul	 edx
  002de	0f 90 c1	 seto	 cl
  002e1	f7 d9		 neg	 ecx
  002e3	0b c8		 or	 ecx, eax
  002e5	51		 push	 ecx
  002e6	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  002eb	89 87 a0 00 00
	00		 mov	 DWORD PTR [edi+160], eax

; 382  : 	m_pamapSpecialTime = ( CMapTimeToLong **)( new LPVOID[ m_nCountOfRQ]);

  002f1	33 c9		 xor	 ecx, ecx
  002f3	8b 47 6c	 mov	 eax, DWORD PTR [edi+108]
  002f6	ba 04 00 00 00	 mov	 edx, 4
  002fb	f7 e2		 mul	 edx
  002fd	0f 90 c1	 seto	 cl
  00300	f7 d9		 neg	 ecx
  00302	0b c8		 or	 ecx, eax
  00304	51		 push	 ecx
  00305	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  0030a	89 87 a4 00 00
	00		 mov	 DWORD PTR [edi+164], eax

; 384  : 	m_pifaRQ = (RQ_INFO**)(new LPVOID[m_nCountOfRQ]);

  00310	33 c9		 xor	 ecx, ecx
  00312	8b 47 6c	 mov	 eax, DWORD PTR [edi+108]
  00315	ba 04 00 00 00	 mov	 edx, 4
  0031a	f7 e2		 mul	 edx
  0031c	0f 90 c1	 seto	 cl
  0031f	f7 d9		 neg	 ecx
  00321	0b c8		 or	 ecx, eax
  00323	51		 push	 ecx
  00324	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00329	89 87 8c 00 00
	00		 mov	 DWORD PTR [edi+140], eax

; 386  : 	CStringArray saRQ;

  0032f	8d 4d 8c	 lea	 ecx, DWORD PTR _saRQ$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1135 :         return iterator(_Scary->_Myhead->_Left, _Scary);

  00332	8b 36		 mov	 esi, DWORD PTR [esi]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 384  : 	m_pifaRQ = (RQ_INFO**)(new LPVOID[m_nCountOfRQ]);

  00334	83 c4 14	 add	 esp, 20			; 00000014H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 38   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  00337	8b 36		 mov	 esi, DWORD PTR [esi]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 386  : 	CStringArray saRQ;

  00339	e8 00 00 00 00	 call	 ??0CStringArray@@QAE@XZ	; CStringArray::CStringArray

; 388  : 	for( nRQ = 0; it_packetRQ != pmapPacketList->end(); nRQ++)

  0033e	8b 45 ac	 mov	 eax, DWORD PTR _pmapPacketList$1$[ebp]
  00341	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00348	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _nRQ$1$[ebp], 0
  0034f	3b 30		 cmp	 esi, DWORD PTR [eax]
  00351	0f 84 e4 08 00
	00		 je	 $LN21@Calc_DRI
  00357	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL22@Calc_DRI:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2273 :         if (_Large_string_engaged()) {

  00360	83 7e 24 10	 cmp	 DWORD PTR [esi+36], 16	; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 186  :         return this->_Ptr->_Myval;

  00364	8d 46 10	 lea	 eax, DWORD PTR [esi+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2887 :         const size_type _Right_size   = _Right_data._Mysize;

  00367	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]

; 2272 :         const value_type* _Result = _Bx._Buf;

  0036a	8b d0		 mov	 edx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 186  :         return this->_Ptr->_Myval;

  0036c	89 45 c4	 mov	 DWORD PTR __Result$1$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2313 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  0036f	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T20[ebp], 0

; 2322 :     size_type _Mysize = 0; // current length of string

  00376	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR $T20[ebp+16], 0

; 2323 :     size_type _Myres  = 0; // current storage reserved for string

  0037d	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T20[ebp+20], 0

; 2887 :         const size_type _Right_size   = _Right_data._Mysize;

  00384	89 4d b4	 mov	 DWORD PTR __Right_size$1$[ebp], ecx

; 2272 :         const value_type* _Result = _Bx._Buf;

  00387	89 45 cc	 mov	 DWORD PTR __Result$1$[ebp], eax

; 2273 :         if (_Large_string_engaged()) {

  0038a	72 05		 jb	 SHORT $LN585@Calc_DRI

; 2274 :             _Result = _Unfancy(_Bx._Ptr);

  0038c	8b 10		 mov	 edx, DWORD PTR [eax]
  0038e	89 55 cc	 mov	 DWORD PTR __Result$1$[ebp], edx
$LN585@Calc_DRI:

; 2899 :         if (_Stay_small) { // stay small, don't allocate

  00391	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00394	73 1d		 jae	 SHORT $LN159@Calc_DRI

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00396	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]

; 2902 :             _My_data._Myres  = _BUF_SIZE - 1;

  00399	b8 0f 00 00 00	 mov	 eax, 15			; 0000000fH
  0039e	89 4d e4	 mov	 DWORD PTR $T20[ebp+16], ecx
  003a1	89 45 d0	 mov	 DWORD PTR $T19[ebp], eax

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  003a4	0f 11 45 d4	 movups	 XMMWORD PTR $T20[ebp], xmm0

; 2903 :             return;

  003a8	8b 4d d4	 mov	 ecx, DWORD PTR $T20[ebp]
  003ab	89 45 e8	 mov	 DWORD PTR $T20[ebp+20], eax
  003ae	89 4d c0	 mov	 DWORD PTR __Ptr$1$[ebp], ecx
  003b1	eb 7e		 jmp	 SHORT $LN598@Calc_DRI
$LN159@Calc_DRI:

; 2904 :         }
; 2905 : 
; 2906 :         auto& _Al                     = _Getal();
; 2907 :         const size_type _New_capacity = (_STD min)(_Right_size | _ALLOC_MASK, max_size());

  003b3	8b c1		 mov	 eax, ecx
  003b5	b9 ff ff ff 7f	 mov	 ecx, 2147483647		; 7fffffffH
  003ba	83 c8 0f	 or	 eax, 15			; 0000000fH
  003bd	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  003c2	0f 47 c1	 cmova	 eax, ecx
  003c5	89 45 d0	 mov	 DWORD PTR $T19[ebp], eax

; 2908 :         const pointer _New_array      = _Al.allocate(_New_capacity + 1); // throws

  003c8	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 228  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  003c9	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  003ce	72 27		 jb	 SHORT $LN173@Calc_DRI

; 129  :     const size_t _Block_size = _Non_user_size + _Bytes;

  003d0	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]

; 130  :     if (_Block_size <= _Bytes) {

  003d3	3b c8		 cmp	 ecx, eax
  003d5	0f 86 24 0a 00
	00		 jbe	 $LN529@Calc_DRI

; 79   :         return ::operator new(_Bytes);

  003db	51		 push	 ecx
  003dc	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  003e1	83 c4 04	 add	 esp, 4

; 135  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  003e4	85 c0		 test	 eax, eax
  003e6	0f 84 e0 09 00
	00		 je	 $LN392@Calc_DRI

; 136  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  003ec	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]
  003ef	83 e1 e0	 and	 ecx, -32		; ffffffe0H

; 137  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  003f2	89 41 fc	 mov	 DWORD PTR [ecx-4], eax

; 229  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  003f5	eb 13		 jmp	 SHORT $LN599@Calc_DRI
$LN173@Calc_DRI:

; 230  :         }
; 231  :     }
; 232  : #endif // defined(_M_IX86) || defined(_M_X64)
; 233  : 
; 234  :     if (_Bytes != 0) {

  003f7	85 c0		 test	 eax, eax
  003f9	74 0d		 je	 SHORT $LN174@Calc_DRI

; 79   :         return ::operator new(_Bytes);

  003fb	50		 push	 eax
  003fc	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00401	83 c4 04	 add	 esp, 4

; 235  :         return _Traits::_Allocate(_Bytes);

  00404	8b c8		 mov	 ecx, eax
  00406	eb 02		 jmp	 SHORT $LN599@Calc_DRI
$LN174@Calc_DRI:

; 236  :     }
; 237  : 
; 238  :     return nullptr;

  00408	33 c9		 xor	 ecx, ecx
$LN599@Calc_DRI:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2916 :         _Traits::copy(_Unfancy(_New_array), _Right_ptr, _Right_size + 1);

  0040a	8b 45 b4	 mov	 eax, DWORD PTR __Right_size$1$[ebp]
  0040d	40		 inc	 eax
  0040e	89 4d c0	 mov	 DWORD PTR __Ptr$1$[ebp], ecx

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00411	50		 push	 eax
  00412	ff 75 cc	 push	 DWORD PTR __Result$1$[ebp]

; 2909 :         _Construct_in_place(_My_data._Bx._Ptr, _New_array);

  00415	89 4d d4	 mov	 DWORD PTR $T20[ebp], ecx

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00418	51		 push	 ecx
  00419	e8 00 00 00 00	 call	 _memcpy

; 2917 :         _My_data._Mysize = _Right_size;

  0041e	8b 45 b4	 mov	 eax, DWORD PTR __Right_size$1$[ebp]

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00421	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2918 :         _My_data._Myres  = _New_capacity;

  00424	8b 4d d0	 mov	 ecx, DWORD PTR $T19[ebp]
  00427	0f 10 45 d4	 movups	 xmm0, XMMWORD PTR $T20[ebp]
  0042b	89 45 e4	 mov	 DWORD PTR $T20[ebp+16], eax
  0042e	89 4d e8	 mov	 DWORD PTR $T20[ebp+20], ecx
$LN598@Calc_DRI:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 186  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00431	8b 45 c8	 mov	 eax, DWORD PTR _nRQ$1$[ebp]
  00434	0f 11 85 54 ff
	ff ff		 movups	 XMMWORD PTR $T3[ebp], xmm0
  0043b	89 45 ec	 mov	 DWORD PTR $T20[ebp+24], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1006 :             _Loc                = _Find_lower_bound(_Keyval);

  0043e	8d 45 d4	 lea	 eax, DWORD PTR $T20[ebp]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 390  : 		m_midxRQ.insert( PAIR_RQ_INDEX( it_packetRQ->first, nRQ));

  00441	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1006 :             _Loc                = _Find_lower_bound(_Keyval);

  00445	50		 push	 eax
  00446	8d 85 48 ff ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  0044c	50		 push	 eax
  0044d	8d 4f 70	 lea	 ecx, DWORD PTR [edi+112]
  00450	e8 00 00 00 00	 call	 ??$_Find_lower_bound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Find_lower_bound<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
  00455	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  00459	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0045c	66 0f d6 85 64
	ff ff ff	 movq	 QWORD PTR __Loc$4[ebp], xmm0

; 1591 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  00464	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00468	75 18		 jne	 SHORT $LN209@Calc_DRI
  0046a	83 c0 10	 add	 eax, 16			; 00000010H
  0046d	8d 4f 70	 lea	 ecx, DWORD PTR [edi+112]
  00470	50		 push	 eax
  00471	8d 45 d4	 lea	 eax, DWORD PTR $T20[ebp]
  00474	50		 push	 eax
  00475	e8 00 00 00 00	 call	 ??R?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0@Z ; std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator()
  0047a	84 c0		 test	 al, al
  0047c	0f 84 9d 00 00
	00		 je	 $LN594@Calc_DRI
$LN209@Calc_DRI:

; 1615 :         if (max_size() == _Get_scary()->_Mysize) {

  00482	81 7f 74 5d 74
	d1 05		 cmp	 DWORD PTR [edi+116], 97612893 ; 05d1745dH
  00489	8d 4f 70	 lea	 ecx, DWORD PTR [edi+112]
  0048c	0f 84 77 09 00
	00		 je	 $LN530@Calc_DRI

; 1012 :             _Inserted = _Tree_temp_node<_Alnode>(_Getal(), _Scary->_Myhead, _STD forward<_Valtys>(_Vals)...)._Release();

  00492	8b 01		 mov	 eax, DWORD PTR [ecx]
  00494	89 45 b0	 mov	 DWORD PTR __Myhead$1$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 958  :     _CONSTEXPR20_DYNALLOC explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

  00497	89 8d 70 ff ff
	ff		 mov	 DWORD PTR $T5[ebp], ecx

; 79   :         return ::operator new(_Bytes);

  0049d	6a 2c		 push	 44			; 0000002cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 783  :     explicit _Tree_temp_node_alloc(_Alnode& _Al_) : _Alloc_construct_ptr<_Alnode>(_Al_) {

  0049f	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 965  :         _Ptr = nullptr; // if allocate throws, prevents double-free

  004a3	c7 85 74 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T5[ebp+4], 0

; 79   :         return ::operator new(_Bytes);

  004ad	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2835 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  004b2	0f 10 85 54 ff
	ff ff		 movups	 xmm0, XMMWORD PTR $T3[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 79   :         return ::operator new(_Bytes);

  004b9	83 c4 04	 add	 esp, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4578 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  004bc	c6 45 d4 00	 mov	 BYTE PTR $T20[ebp], 0
  004c0	b9 0f 00 00 00	 mov	 ecx, 15			; 0000000fH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 603  :     _Val         = static_cast<_Other&&>(_New_val);

  004c5	c7 85 74 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T5[ebp+4], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2322 :     size_type _Mysize = 0; // current length of string

  004cf	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], 0

; 2323 :     size_type _Myres  = 0; // current storage reserved for string

  004d6	c7 40 24 00 00
	00 00		 mov	 DWORD PTR [eax+36], 0

; 2835 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  004dd	0f 11 40 10	 movups	 XMMWORD PTR [eax+16], xmm0

; 4576 :             _My_data._Myres = _BUF_SIZE - 1;

  004e1	89 4d d0	 mov	 DWORD PTR $T19[ebp], ecx

; 2835 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  004e4	f3 0f 7e 45 e4	 movq	 xmm0, QWORD PTR $T20[ebp+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 242  :         : first(_STD forward<_Other1>(_Right.first)), second(_STD forward<_Other2>(_Right.second)) {}

  004e9	8b 4d c8	 mov	 ecx, DWORD PTR _nRQ$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2835 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  004ec	66 0f d6 40 20	 movq	 QWORD PTR [eax+32], xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 242  :         : first(_STD forward<_Other1>(_Right.first)), second(_STD forward<_Other2>(_Right.second)) {}

  004f1	89 48 28	 mov	 DWORD PTR [eax+40], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 806  :         _Construct_in_place(this->_Ptr->_Left, _Myhead);

  004f4	8b 4d b0	 mov	 ecx, DWORD PTR __Myhead$1$[ebp]

; 1031 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  004f7	50		 push	 eax
  004f8	ff b5 68 ff ff
	ff		 push	 DWORD PTR __Loc$4[ebp+4]

; 806  :         _Construct_in_place(this->_Ptr->_Left, _Myhead);

  004fe	89 08		 mov	 DWORD PTR [eax], ecx

; 1031 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  00500	ff b5 64 ff ff
	ff		 push	 DWORD PTR __Loc$4[ebp]

; 807  :         _Construct_in_place(this->_Ptr->_Parent, _Myhead);

  00506	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 808  :         _Construct_in_place(this->_Ptr->_Right, _Myhead);

  00509	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 1031 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  0050c	8d 4f 70	 lea	 ecx, DWORD PTR [edi+112]

; 809  :         this->_Ptr->_Color = _Red;

  0050f	66 c7 40 0c 00
	00		 mov	 WORD PTR [eax+12], 0

; 1031 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  00515	e8 00 00 00 00	 call	 ?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@2@QAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Insert_node
  0051a	8b 4d d4	 mov	 ecx, DWORD PTR $T20[ebp]

; 1591 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  0051d	eb 03		 jmp	 SHORT $LN359@Calc_DRI
$LN594@Calc_DRI:
  0051f	8b 4d c0	 mov	 ecx, DWORD PTR __Ptr$1$[ebp]
$LN359@Calc_DRI:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4584 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00522	8b 45 d0	 mov	 eax, DWORD PTR $T19[ebp]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 390  : 		m_midxRQ.insert( PAIR_RQ_INDEX( it_packetRQ->first, nRQ));

  00525	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4584 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00529	83 f8 10	 cmp	 eax, 16			; 00000010H
  0052c	72 2b		 jb	 SHORT $LN385@Calc_DRI

; 4585 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;
; 4586 :             auto& _Al          = _Getal();
; 4587 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);
; 4588 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0052e	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00531	8b c1		 mov	 eax, ecx

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00533	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00539	72 14		 jb	 SHORT $LN395@Calc_DRI

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0053b	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  0053e	83 c2 23	 add	 edx, 35			; 00000023H
  00541	2b c1		 sub	 eax, ecx

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00543	83 c0 fc	 add	 eax, -4			; fffffffcH
  00546	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00549	0f 87 7d 08 00
	00		 ja	 $LN392@Calc_DRI
$LN395@Calc_DRI:

; 255  :         ::operator delete(_Ptr, _Bytes);

  0054f	52		 push	 edx
  00550	51		 push	 ecx
  00551	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00556	83 c4 08	 add	 esp, 8
$LN385@Calc_DRI:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2273 :         if (_Large_string_engaged()) {

  00559	8b 45 c4	 mov	 eax, DWORD PTR __Result$1$[ebp]
  0055c	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00560	72 02		 jb	 SHORT $LN410@Calc_DRI

; 2274 :             _Result = _Unfancy(_Bx._Ptr);

  00562	8b 00		 mov	 eax, DWORD PTR [eax]
$LN410@Calc_DRI:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 391  : 		saRQ.Add( CString( it_packetRQ->first.c_str()));

  00564	50		 push	 eax
  00565	8d 4d 88	 lea	 ecx, DWORD PTR $T8[ebp]
  00568	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl

; 321  : 		SetAtGrow(nIndex, newElement);

  0056e	50		 push	 eax
  0056f	ff 75 94	 push	 DWORD PTR _saRQ$[ebp+8]
  00572	8d 4d 8c	 lea	 ecx, DWORD PTR _saRQ$[ebp]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 391  : 		saRQ.Add( CString( it_packetRQ->first.c_str()));

  00575	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl

; 321  : 		SetAtGrow(nIndex, newElement);

  00579	e8 00 00 00 00	 call	 ?SetAtGrow@CStringArray@@QAEXHABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ; CStringArray::SetAtGrow
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 391  : 		saRQ.Add( CString( it_packetRQ->first.c_str()));

  0057e	8d 4d 88	 lea	 ecx, DWORD PTR $T8[ebp]
  00581	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00585	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 393  : 		m_pblaRQTime[nRQ] = new CDataBlockList<time_t>;

  0058b	6a 34		 push	 52			; 00000034H
  0058d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00592	8b c8		 mov	 ecx, eax
  00594	83 c4 04	 add	 esp, 4
  00597	89 4d c4	 mov	 DWORD PTR $T18[ebp], ecx
  0059a	85 c9		 test	 ecx, ecx
  0059c	74 5c		 je	 SHORT $LN78@Calc_DRI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  0059e	c7 41 28 00 00
	00 00		 mov	 DWORD PTR [ecx+40], 0
  005a5	c7 41 2c 00 00
	00 00		 mov	 DWORD PTR [ecx+44], 0
  005ac	c7 41 30 00 00
	00 00		 mov	 DWORD PTR [ecx+48], 0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 24   : 		m_nItemSize = nItemSize;

  005b3	c7 41 04 08 00
	00 00		 mov	 DWORD PTR [ecx+4], 8

; 25   : 		m_nBlockSize = nBlockSize;

  005ba	c7 41 08 00 02
	00 00		 mov	 DWORD PTR [ecx+8], 512	; 00000200H

; 26   : 
; 27   : 		m_nItemCount = 0;

  005c1	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 28   : 		m_nFirstBlockStartIndex = 0;

  005c8	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 29   : 		m_nLastBlockEndIndex = 0;

  005cf	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 30   : 
; 31   : 		m_nIndex = 0;

  005d6	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0

; 32   : 		m_nBlockIndex = 0;

  005dd	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 33   : 		m_nIndexInBlock = 0;

  005e4	c7 41 24 00 00
	00 00		 mov	 DWORD PTR [ecx+36], 0

; 34   : 		m_lpBlockIndex = NULL;

  005eb	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0

; 158  : 	{

  005f2	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CDataBlockList@_J$0CAA@@@6B@
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 393  : 		m_pblaRQTime[nRQ] = new CDataBlockList<time_t>;

  005f8	eb 02		 jmp	 SHORT $LN79@Calc_DRI
$LN78@Calc_DRI:
  005fa	33 c9		 xor	 ecx, ecx
$LN79@Calc_DRI:
  005fc	8b 45 c8	 mov	 eax, DWORD PTR _nRQ$1$[ebp]

; 394  : 		m_pblaDRIfDTI[nRQ] = new CDataBlockList<int>;

  005ff	6a 34		 push	 52			; 00000034H
  00601	8d 14 85 00 00
	00 00		 lea	 edx, DWORD PTR [eax*4]
  00608	8b 87 9c 00 00
	00		 mov	 eax, DWORD PTR [edi+156]
  0060e	89 55 cc	 mov	 DWORD PTR tv4318[ebp], edx
  00611	89 0c 02	 mov	 DWORD PTR [edx+eax], ecx
  00614	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00619	8b c8		 mov	 ecx, eax
  0061b	83 c4 04	 add	 esp, 4
  0061e	89 4d c4	 mov	 DWORD PTR $T17[ebp], ecx
  00621	85 c9		 test	 ecx, ecx
  00623	74 5c		 je	 SHORT $LN80@Calc_DRI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00625	c7 41 28 00 00
	00 00		 mov	 DWORD PTR [ecx+40], 0
  0062c	c7 41 2c 00 00
	00 00		 mov	 DWORD PTR [ecx+44], 0
  00633	c7 41 30 00 00
	00 00		 mov	 DWORD PTR [ecx+48], 0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 24   : 		m_nItemSize = nItemSize;

  0063a	c7 41 04 04 00
	00 00		 mov	 DWORD PTR [ecx+4], 4

; 25   : 		m_nBlockSize = nBlockSize;

  00641	c7 41 08 00 02
	00 00		 mov	 DWORD PTR [ecx+8], 512	; 00000200H

; 26   : 
; 27   : 		m_nItemCount = 0;

  00648	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 28   : 		m_nFirstBlockStartIndex = 0;

  0064f	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 29   : 		m_nLastBlockEndIndex = 0;

  00656	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 30   : 
; 31   : 		m_nIndex = 0;

  0065d	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0

; 32   : 		m_nBlockIndex = 0;

  00664	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 33   : 		m_nIndexInBlock = 0;

  0066b	c7 41 24 00 00
	00 00		 mov	 DWORD PTR [ecx+36], 0

; 34   : 		m_lpBlockIndex = NULL;

  00672	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0

; 158  : 	{

  00679	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CDataBlockList@H$0CAA@@@6B@
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 394  : 		m_pblaDRIfDTI[nRQ] = new CDataBlockList<int>;

  0067f	eb 02		 jmp	 SHORT $LN81@Calc_DRI
$LN80@Calc_DRI:
  00681	33 c9		 xor	 ecx, ecx
$LN81@Calc_DRI:
  00683	8b 87 a0 00 00
	00		 mov	 eax, DWORD PTR [edi+160]
  00689	8b 55 c8	 mov	 edx, DWORD PTR _nRQ$1$[ebp]

; 395  : 		m_pblaDTIfDRI[nRQ] = new CDataBlockList<int>;

  0068c	6a 34		 push	 52			; 00000034H
  0068e	89 0c 90	 mov	 DWORD PTR [eax+edx*4], ecx
  00691	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00696	8b c8		 mov	 ecx, eax
  00698	83 c4 04	 add	 esp, 4
  0069b	89 4d c4	 mov	 DWORD PTR $T16[ebp], ecx
  0069e	85 c9		 test	 ecx, ecx
  006a0	74 5c		 je	 SHORT $LN82@Calc_DRI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  006a2	c7 41 28 00 00
	00 00		 mov	 DWORD PTR [ecx+40], 0
  006a9	c7 41 2c 00 00
	00 00		 mov	 DWORD PTR [ecx+44], 0
  006b0	c7 41 30 00 00
	00 00		 mov	 DWORD PTR [ecx+48], 0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 24   : 		m_nItemSize = nItemSize;

  006b7	c7 41 04 04 00
	00 00		 mov	 DWORD PTR [ecx+4], 4

; 25   : 		m_nBlockSize = nBlockSize;

  006be	c7 41 08 00 02
	00 00		 mov	 DWORD PTR [ecx+8], 512	; 00000200H

; 26   : 
; 27   : 		m_nItemCount = 0;

  006c5	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 28   : 		m_nFirstBlockStartIndex = 0;

  006cc	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 29   : 		m_nLastBlockEndIndex = 0;

  006d3	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 30   : 
; 31   : 		m_nIndex = 0;

  006da	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0

; 32   : 		m_nBlockIndex = 0;

  006e1	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 33   : 		m_nIndexInBlock = 0;

  006e8	c7 41 24 00 00
	00 00		 mov	 DWORD PTR [ecx+36], 0

; 34   : 		m_lpBlockIndex = NULL;

  006ef	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0

; 158  : 	{

  006f6	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CDataBlockList@H$0CAA@@@6B@
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 395  : 		m_pblaDTIfDRI[nRQ] = new CDataBlockList<int>;

  006fc	eb 02		 jmp	 SHORT $LN83@Calc_DRI
$LN82@Calc_DRI:
  006fe	33 c9		 xor	 ecx, ecx
$LN83@Calc_DRI:
  00700	8b 87 a8 00 00
	00		 mov	 eax, DWORD PTR [edi+168]
  00706	8b 55 c8	 mov	 edx, DWORD PTR _nRQ$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 116  : 	{ return ::operator new(nSize); }

  00709	6a 1c		 push	 28			; 0000001cH
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 395  : 		m_pblaDTIfDRI[nRQ] = new CDataBlockList<int>;

  0070b	89 0c 90	 mov	 DWORD PTR [eax+edx*4], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 116  : 	{ return ::operator new(nSize); }

  0070e	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00713	83 c4 04	 add	 esp, 4
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 396  : 		m_pamapSpecialTime[ nRQ] = new CMapTimeToLong;

  00716	89 45 84	 mov	 DWORD PTR $T7[ebp], eax
  00719	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  0071d	85 c0		 test	 eax, eax
  0071f	74 14		 je	 SHORT $LN84@Calc_DRI
  00721	6a 0a		 push	 10			; 0000000aH
  00723	8b c8		 mov	 ecx, eax
  00725	e8 00 00 00 00	 call	 ??0CMapPtrToPtr@@QAE@H@Z ; CMapPtrToPtr::CMapPtrToPtr
  0072a	8b 4d 84	 mov	 ecx, DWORD PTR $T7[ebp]
  0072d	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CMapTimeToLong@@6B@
  00733	eb 02		 jmp	 SHORT $LN85@Calc_DRI
$LN84@Calc_DRI:
  00735	33 c9		 xor	 ecx, ecx
$LN85@Calc_DRI:
  00737	8b 87 a4 00 00
	00		 mov	 eax, DWORD PTR [edi+164]
  0073d	8b 55 c8	 mov	 edx, DWORD PTR _nRQ$1$[ebp]

; 397  : 
; 398  : 		m_pifaRQ[ nRQ] = new RQ_INFO;

  00740	6a 40		 push	 64			; 00000040H
  00742	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00746	89 0c 90	 mov	 DWORD PTR [eax+edx*4], ecx
  00749	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0074e	8b 8f 8c 00 00
	00		 mov	 ecx, DWORD PTR [edi+140]
  00754	83 c4 04	 add	 esp, 4
  00757	8b 55 cc	 mov	 edx, DWORD PTR tv4318[ebp]

; 399  : 		m_pifaRQ[ nRQ]->pPacketRQ = it_packetRQ->second;
; 400  : 		CPacketList *pPacketList = it_packetRQ->second->GetPacketList();
; 401  : 		m_pifaRQ[ nRQ]->pPacketList = pPacketList;
; 402  : 		m_pifaRQ[ nRQ]->pTimePacket = pPacketList->GetBaseData( it_packetRQ->second->GetPacketName());

  0075a	6a 01		 push	 1
  0075c	89 04 0a	 mov	 DWORD PTR [edx+ecx], eax
  0075f	8b 87 8c 00 00
	00		 mov	 eax, DWORD PTR [edi+140]
  00765	8b 0c 02	 mov	 ecx, DWORD PTR [edx+eax]
  00768	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  0076b	89 01		 mov	 DWORD PTR [ecx], eax
  0076d	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  00770	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00773	8b 87 8c 00 00
	00		 mov	 eax, DWORD PTR [edi+140]
  00779	51		 push	 ecx
  0077a	89 4d c0	 mov	 DWORD PTR _pPacketList$1$[ebp], ecx
  0077d	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  00780	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00783	8b cc		 mov	 ecx, esp
  00785	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  00788	ff 70 10	 push	 DWORD PTR [eax+16]
  0078b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  00791	8b 4d c0	 mov	 ecx, DWORD PTR _pPacketList$1$[ebp]
  00794	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetBaseData@CPacketList@@QAEPAVCPacket@@V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@_N@Z
  0079a	8b 8f 8c 00 00
	00		 mov	 ecx, DWORD PTR [edi+140]
  007a0	8b 55 cc	 mov	 edx, DWORD PTR tv4318[ebp]
  007a3	8b 0c 0a	 mov	 ecx, DWORD PTR [edx+ecx]
  007a6	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 403  : 		m_pifaRQ[ nRQ]->bRealReceived = TRUE;		// for Full calculation with Real Processing Logic.

  007a9	8b 87 8c 00 00
	00		 mov	 eax, DWORD PTR [edi+140]

; 404  : 		m_pifaRQ[ nRQ]->nLastRealDTI = -1;
; 405  : 		m_pifaRQ[ nRQ]->nUpdatedRealDRI = -1;
; 406  : 		m_pifaRQ[ nRQ]->eScaleUnit = pPacketList->GetDateUnitType();

  007af	8b 4d c0	 mov	 ecx, DWORD PTR _pPacketList$1$[ebp]
  007b2	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  007b5	c7 40 2c 01 00
	00 00		 mov	 DWORD PTR [eax+44], 1
  007bc	8b 87 8c 00 00
	00		 mov	 eax, DWORD PTR [edi+140]
  007c2	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  007c5	c7 40 28 ff ff
	ff ff		 mov	 DWORD PTR [eax+40], -1
  007cc	8b 87 8c 00 00
	00		 mov	 eax, DWORD PTR [edi+140]
  007d2	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  007d5	c7 40 30 ff ff
	ff ff		 mov	 DWORD PTR [eax+48], -1
  007dc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetDateUnitType@CPacketList@@QAE?AW4HORZSCALEDRAWERTYPE@CScaleBaseData@@XZ
  007e2	8b 8f 8c 00 00
	00		 mov	 ecx, DWORD PTR [edi+140]
  007e8	8b 55 c8	 mov	 edx, DWORD PTR _nRQ$1$[ebp]
  007eb	8b 0c 91	 mov	 ecx, DWORD PTR [ecx+edx*4]
  007ee	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 407  : 		m_pifaRQ[ nRQ]->nScaleInterval_Unit = pPacketList->GetTimeInterval();

  007f1	8b 4d c0	 mov	 ecx, DWORD PTR _pPacketList$1$[ebp]
  007f4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetTimeInterval@CPacketList@@QAEHXZ
  007fa	8b 8f 8c 00 00
	00		 mov	 ecx, DWORD PTR [edi+140]
  00800	8b 55 cc	 mov	 edx, DWORD PTR tv4318[ebp]
  00803	8b 0c 0a	 mov	 ecx, DWORD PTR [edx+ecx]
  00806	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 408  : 		// (2009/2/16 - Seung-Won, Bae) Support Non-Time X Scale Manager.
; 409  : 		m_pifaRQ[ nRQ]->m_bStringDataType = TRUE;

  00809	8b 87 8c 00 00
	00		 mov	 eax, DWORD PTR [edi+140]
  0080f	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  00812	c7 40 34 01 00
	00 00		 mov	 DWORD PTR [eax+52], 1

; 410  : 		if( m_pifaRQ[ nRQ]->pTimePacket)

  00819	8b 87 8c 00 00
	00		 mov	 eax, DWORD PTR [edi+140]
  0081f	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  00822	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00825	85 c9		 test	 ecx, ecx
  00827	0f 84 83 00 00
	00		 je	 $LN102@Calc_DRI

; 411  : 			m_pifaRQ[ nRQ]->m_bStringDataType = ( !m_pifaRQ[ nRQ]->pTimePacket->GetnumericDataList()

  0082d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetnumericDataList@CPacket@@QAEPAV?$CList@NN@@XZ
  00833	85 c0		 test	 eax, eax
  00835	75 48		 jne	 SHORT $LN86@Calc_DRI
  00837	8b 4d c8	 mov	 ecx, DWORD PTR _nRQ$1$[ebp]
  0083a	8d 45 80	 lea	 eax, DWORD PTR $T6[ebp]
  0083d	6a 01		 push	 1
  0083f	50		 push	 eax
  00840	8b 87 8c 00 00
	00		 mov	 eax, DWORD PTR [edi+140]
  00846	8b 0c 88	 mov	 ecx, DWORD PTR [eax+ecx*4]
  00849	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  0084c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetType@CPacket@@QAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@_N@Z
  00852	8b 4d b8	 mov	 ecx, DWORD PTR $T14[ebp]
  00855	83 c9 01	 or	 ecx, 1
  00858	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  0085c	89 4d b8	 mov	 DWORD PTR $T14[ebp], ecx
  0085f	89 4d c4	 mov	 DWORD PTR $T15[ebp], ecx
  00862	8b 0d 54 00 00
	00		 mov	 ecx, DWORD PTR ?g_iMetaTable@@3VIMetaTable@@A+84
  00868	ff b1 60 09 00
	00		 push	 DWORD PTR [ecx+2400]
  0086e	8b c8		 mov	 ecx, eax
  00870	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Compare@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEHPBD@Z
  00876	85 c0		 test	 eax, eax
  00878	75 05		 jne	 SHORT $LN86@Calc_DRI
  0087a	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  0087d	eb 02		 jmp	 SHORT $LN87@Calc_DRI
$LN86@Calc_DRI:
  0087f	33 c9		 xor	 ecx, ecx
$LN87@Calc_DRI:
  00881	8b 87 8c 00 00
	00		 mov	 eax, DWORD PTR [edi+140]
  00887	8b 55 cc	 mov	 edx, DWORD PTR tv4318[ebp]
  0088a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00891	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  00894	89 48 34	 mov	 DWORD PTR [eax+52], ecx
  00897	8b 45 b8	 mov	 eax, DWORD PTR $T14[ebp]
  0089a	a8 01		 test	 al, 1
  0089c	74 12		 je	 SHORT $LN102@Calc_DRI
  0089e	83 e0 fe	 and	 eax, -2			; fffffffeH
  008a1	8d 4d 80	 lea	 ecx, DWORD PTR $T6[ebp]
  008a4	89 45 b8	 mov	 DWORD PTR $T14[ebp], eax
  008a7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  008ad	8b 55 cc	 mov	 edx, DWORD PTR tv4318[ebp]
$LN102@Calc_DRI:

; 412  : 													&& !m_pifaRQ[ nRQ]->pTimePacket->GetType().Compare( _MTEXT( C6_CHARACTER)));
; 413  : 		if( m_pifaRQ[ nRQ]->nScaleInterval_Unit <= 0) m_pifaRQ[ nRQ]->nScaleInterval_Unit = 1;	//  0 1  : xScaleManager - ojtaso (20070709)

  008b0	8b 87 8c 00 00
	00		 mov	 eax, DWORD PTR [edi+140]
  008b6	8b 0c 02	 mov	 ecx, DWORD PTR [edx+eax]
  008b9	83 79 18 00	 cmp	 DWORD PTR [ecx+24], 0
  008bd	7f 0d		 jg	 SHORT $LN43@Calc_DRI
  008bf	c7 41 18 01 00
	00 00		 mov	 DWORD PTR [ecx+24], 1
  008c6	8b 87 8c 00 00
	00		 mov	 eax, DWORD PTR [edi+140]
$LN43@Calc_DRI:

; 414  : 		m_pifaRQ[ nRQ]->nScaleInterval_Sec = 1;		// for Tick or ETC

  008cc	8b 04 10	 mov	 eax, DWORD PTR [eax+edx]

; 415  : 
; 416  : 		// 2011.01.24 by SYS >>  YYYY()  : / 14Byte  (YYYYMMDDhhmmss)
; 417  : 		CString strType;

  008cf	8d 4d a0	 lea	 ecx, DWORD PTR _strType$9[ebp]
  008d2	c7 40 20 01 00
	00 00		 mov	 DWORD PTR [eax+32], 1
  008d9	c7 40 24 00 00
	00 00		 mov	 DWORD PTR [eax+36], 0
  008e0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 418  : 		if (m_pifaRQ[ nRQ]->pTimePacket)

  008e6	8b 97 8c 00 00
	00		 mov	 edx, DWORD PTR [edi+140]
  008ec	8b 4d cc	 mov	 ecx, DWORD PTR tv4318[ebp]
  008ef	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  008f3	8b 04 11	 mov	 eax, DWORD PTR [ecx+edx]
  008f6	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  008f9	85 c0		 test	 eax, eax
  008fb	74 32		 je	 SHORT $LN44@Calc_DRI

; 419  : 			strType = m_pifaRQ[ nRQ]->pTimePacket->GetType();

  008fd	6a 01		 push	 1
  008ff	8d 4d a4	 lea	 ecx, DWORD PTR $T10[ebp]
  00902	51		 push	 ecx
  00903	8b c8		 mov	 ecx, eax
  00905	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetType@CPacket@@QAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@_N@Z
  0090b	50		 push	 eax
  0090c	8d 4d a0	 lea	 ecx, DWORD PTR _strType$9[ebp]
  0090f	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
  00913	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
  00919	8d 4d a4	 lea	 ecx, DWORD PTR $T10[ebp]
  0091c	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  00920	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00926	8b 97 8c 00 00
	00		 mov	 edx, DWORD PTR [edi+140]
  0092c	8b 4d cc	 mov	 ecx, DWORD PTR tv4318[ebp]
$LN44@Calc_DRI:

; 420  : 		// 2011.01.24 by SYS <<
; 421  : 
; 422  : 		switch( m_pifaRQ[ nRQ]->eScaleUnit)

  0092f	8b 14 0a	 mov	 edx, DWORD PTR [edx+ecx]
  00932	89 55 d0	 mov	 DWORD PTR tv4250[ebp], edx
  00935	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00938	48		 dec	 eax
  00939	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  0093c	0f 87 d8 00 00
	00		 ja	 $LN23@Calc_DRI
  00942	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN589@Calc_DRI[eax]
  00949	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN590@Calc_DRI[eax*4]
$LN45@Calc_DRI:

; 423  : 		{
; 424  : 			case CScaleBaseData::HORZ_MONTHLY:		m_pifaRQ[ nRQ]->nScaleInterval_Sec = (60 * 60 * 24 * 31) * m_pifaRQ[ nRQ]->nScaleInterval_Unit;

  00950	69 42 18 80 de
	28 00		 imul	 eax, DWORD PTR [edx+24], 2678400

; 425  : 													break;

  00957	e9 af 00 00 00	 jmp	 $LN600@Calc_DRI
$LN46@Calc_DRI:

; 426  : 			case CScaleBaseData::HORZ_WEEKLEY:		m_pifaRQ[ nRQ]->nScaleInterval_Sec = (60 * 60 * 24 * 7) * m_pifaRQ[ nRQ]->nScaleInterval_Unit;

  0095c	69 42 18 80 3a
	09 00		 imul	 eax, DWORD PTR [edx+24], 604800

; 427  : 													break;

  00963	e9 a3 00 00 00	 jmp	 $LN600@Calc_DRI
$LN47@Calc_DRI:

; 428  : 			case CScaleBaseData::HORZ_DAILY:		
; 429  : 													// 2011.01.24 by SYS >>  YYYY()  : / 14Byte  (YYYYMMDDhhmmss)
; 430  : 													//if (strType == _T("YYYYMMDDHHMMSS"))
; 431  : 													//{
; 432  : 													//	__int64 nTime1 = __int64 (60 * 60 * 24) * m_pifaRQ[ nRQ]->nScaleInterval_Unit;
; 433  : 													//	m_pifaRQ[ nRQ]->nScaleInterval_Sec = __int64(nTime1 * 1000000);
; 434  : 													//}
; 435  : 									
; 436  : 				//else
; 437  : 													// 2011.01.24 by SYS <<
; 438  : 													m_pifaRQ[ nRQ]->nScaleInterval_Sec = (60 * 60 * 24) * m_pifaRQ[ nRQ]->nScaleInterval_Unit;

  00968	69 42 18 80 51
	01 00		 imul	 eax, DWORD PTR [edx+24], 86400

; 439  : 													break;

  0096f	e9 97 00 00 00	 jmp	 $LN600@Calc_DRI
$LN48@Calc_DRI:

; 440  : 			case CScaleBaseData::HORZ_TIME_ONE:	
; 441  : 			case CScaleBaseData::HORZ_TIME_TWO:		if( m_pifaRQ[ nRQ]->pTimePacket)

  00974	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00977	85 c0		 test	 eax, eax
  00979	74 6e		 je	 SHORT $LN52@Calc_DRI

; 442  : 														if( m_pifaRQ[ nRQ]->pTimePacket->GetType().Find( "SS") < 0)

  0097b	6a 01		 push	 1
  0097d	8d 4d a8	 lea	 ecx, DWORD PTR $T12[ebp]
  00980	51		 push	 ecx
  00981	8b c8		 mov	 ecx, eax
  00983	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetType@CPacket@@QAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@_N@Z
  00989	6a 00		 push	 0
  0098b	68 00 00 00 00	 push	 OFFSET ??_C@_02PPNCLIJD@SS@
  00990	8b c8		 mov	 ecx, eax
  00992	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Find@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEHPBDH@Z
  00998	8d 4d a8	 lea	 ecx, DWORD PTR $T12[ebp]
  0099b	89 45 c4	 mov	 DWORD PTR tv4335[ebp], eax
  0099e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  009a4	8b 87 8c 00 00
	00		 mov	 eax, DWORD PTR [edi+140]
  009aa	03 45 cc	 add	 eax, DWORD PTR tv4318[ebp]
  009ad	83 7d c4 00	 cmp	 DWORD PTR tv4335[ebp], 0
  009b1	7d 13		 jge	 SHORT $LN51@Calc_DRI

; 443  : 															m_pifaRQ[nRQ]->nScaleInterval_Unit *= 60; 

  009b3	8b 10		 mov	 edx, DWORD PTR [eax]
  009b5	8b 4a 18	 mov	 ecx, DWORD PTR [edx+24]
  009b8	c1 e1 04	 shl	 ecx, 4
  009bb	2b 4a 18	 sub	 ecx, DWORD PTR [edx+24]
  009be	c1 e1 02	 shl	 ecx, 2
  009c1	89 4a 18	 mov	 DWORD PTR [edx+24], ecx
  009c4	eb 20		 jmp	 SHORT $LN601@Calc_DRI
$LN51@Calc_DRI:

; 444  : 														else 
; 445  : 															m_pifaRQ[nRQ]->nScaleInterval_Unit = ( m_pifaRQ[nRQ]->nScaleInterval_Unit / 100) * 60 + m_pifaRQ[nRQ]->nScaleInterval_Unit % 100;

  009c6	8b 00		 mov	 eax, DWORD PTR [eax]
  009c8	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  009cd	89 45 c4	 mov	 DWORD PTR tv4224[ebp], eax
  009d0	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  009d3	99		 cdq
  009d4	f7 f9		 idiv	 ecx
  009d6	8b c8		 mov	 ecx, eax
  009d8	c1 e1 04	 shl	 ecx, 4
  009db	2b c8		 sub	 ecx, eax
  009dd	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  009e0	8b 4d c4	 mov	 ecx, DWORD PTR tv4224[ebp]
  009e3	89 41 18	 mov	 DWORD PTR [ecx+24], eax
$LN601@Calc_DRI:

; 446  : 													m_pifaRQ[ nRQ]->nScaleInterval_Sec = m_pifaRQ[ nRQ]->nScaleInterval_Unit;

  009e6	8b 4d cc	 mov	 ecx, DWORD PTR tv4318[ebp]
$LN52@Calc_DRI:
  009e9	8b 87 8c 00 00
	00		 mov	 eax, DWORD PTR [edi+140]
  009ef	8b 0c 01	 mov	 ecx, DWORD PTR [ecx+eax]
  009f2	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  009f5	99		 cdq
  009f6	89 41 20	 mov	 DWORD PTR [ecx+32], eax
  009f9	89 51 24	 mov	 DWORD PTR [ecx+36], edx

; 447  : 													// 20080925 JS.Kim	   Scale .
; 448  : 													m_bTimeScale = true;
; 449  : 													break;

  009fc	8b 4d cc	 mov	 ecx, DWORD PTR tv4318[ebp]
  009ff	c6 87 14 06 00
	00 01		 mov	 BYTE PTR [edi+1556], 1
  00a06	eb 12		 jmp	 SHORT $LN23@Calc_DRI
$LN53@Calc_DRI:

; 450  : 			case CScaleBaseData::HORZ_TIME_SECOND:	m_pifaRQ[ nRQ]->nScaleInterval_Sec = m_pifaRQ[ nRQ]->nScaleInterval_Unit;

  00a08	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
$LN600@Calc_DRI:

; 451  : 													break;
; 452  : 		}
; 453  : 
; 454  : 		// (2009/5/15 - Seung-Won, Bae) Init with 0th RQ for Min/Max
; 455  : 		if( 0 == nRQ)

  00a0b	8b 7d d0	 mov	 edi, DWORD PTR tv4250[ebp]
  00a0e	99		 cdq
  00a0f	89 47 20	 mov	 DWORD PTR [edi+32], eax
  00a12	8b c7		 mov	 eax, edi
  00a14	8b 7d bc	 mov	 edi, DWORD PTR _this$GSCopy$1$[ebp]
  00a17	89 50 24	 mov	 DWORD PTR [eax+36], edx
$LN23@Calc_DRI:
  00a1a	83 7d c8 00	 cmp	 DWORD PTR _nRQ$1$[ebp], 0
  00a1e	8b 97 8c 00 00
	00		 mov	 edx, DWORD PTR [edi+140]
  00a24	75 22		 jne	 SHORT $LN54@Calc_DRI

; 456  : 		{
; 457  : 			m_minScaleInterval_eType = m_maxScaleInterval_eType = m_pifaRQ[ nRQ]->eScaleUnit;

  00a26	8b 02		 mov	 eax, DWORD PTR [edx]
  00a28	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00a2b	89 87 e4 00 00
	00		 mov	 DWORD PTR [edi+228], eax
  00a31	89 87 f0 00 00
	00		 mov	 DWORD PTR [edi+240], eax

; 458  : 			m_minScaleInterval_nUnit = m_maxScaleInterval_nUnit = m_pifaRQ[ nRQ]->nScaleInterval_Unit;

  00a37	8b 02		 mov	 eax, DWORD PTR [edx]
  00a39	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  00a3c	89 87 e8 00 00
	00		 mov	 DWORD PTR [edi+232], eax
  00a42	89 87 f4 00 00
	00		 mov	 DWORD PTR [edi+244], eax
$LN54@Calc_DRI:

; 459  : 		}
; 460  : 
; 461  : 		// 1.4.4 Get min/max Scale Interval Info.
; 462  : 		if( m_pifaRQ[ m_minScaleInterval_nRQ]->nScaleInterval_Sec > m_pifaRQ[ nRQ]->nScaleInterval_Sec
; 463  : 			|| ( m_pifaRQ[ m_minScaleInterval_nRQ]->nScaleInterval_Sec == m_pifaRQ[ nRQ]->nScaleInterval_Sec

  00a48	8b 87 ec 00 00
	00		 mov	 eax, DWORD PTR [edi+236]
  00a4e	8b 04 82	 mov	 eax, DWORD PTR [edx+eax*4]
  00a51	89 45 b0	 mov	 DWORD PTR tv4324[ebp], eax
  00a54	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
  00a57	8b 7d b0	 mov	 edi, DWORD PTR tv4324[ebp]
  00a5a	8b 08		 mov	 ecx, DWORD PTR [eax]
  00a5c	89 45 d0	 mov	 DWORD PTR tv4322[ebp], eax
  00a5f	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  00a62	89 45 b4	 mov	 DWORD PTR tv4171[ebp], eax
  00a65	8b 47 24	 mov	 eax, DWORD PTR [edi+36]
  00a68	3b 41 24	 cmp	 eax, DWORD PTR [ecx+36]
  00a6b	8b 7d bc	 mov	 edi, DWORD PTR _this$GSCopy$1$[ebp]
  00a6e	89 45 c4	 mov	 DWORD PTR tv4172[ebp], eax
  00a71	8b 45 d0	 mov	 eax, DWORD PTR tv4322[ebp]
  00a74	7f 47		 jg	 SHORT $LN57@Calc_DRI
  00a76	7c 0b		 jl	 SHORT $LN591@Calc_DRI
  00a78	8b 7d b4	 mov	 edi, DWORD PTR tv4171[ebp]
  00a7b	3b 79 20	 cmp	 edi, DWORD PTR [ecx+32]
  00a7e	8b 7d bc	 mov	 edi, DWORD PTR _this$GSCopy$1$[ebp]
  00a81	77 3a		 ja	 SHORT $LN57@Calc_DRI
$LN591@Calc_DRI:
  00a83	8b 45 b4	 mov	 eax, DWORD PTR tv4171[ebp]
  00a86	3b 41 20	 cmp	 eax, DWORD PTR [ecx+32]
  00a89	75 56		 jne	 SHORT $LN55@Calc_DRI
  00a8b	8b 7d c4	 mov	 edi, DWORD PTR tv4172[ebp]
  00a8e	3b 79 24	 cmp	 edi, DWORD PTR [ecx+36]
  00a91	8b 7d bc	 mov	 edi, DWORD PTR _this$GSCopy$1$[ebp]
  00a94	75 4b		 jne	 SHORT $LN55@Calc_DRI
  00a96	8b 45 b0	 mov	 eax, DWORD PTR tv4324[ebp]
  00a99	8b 78 18	 mov	 edi, DWORD PTR [eax+24]
  00a9c	83 78 14 05	 cmp	 DWORD PTR [eax+20], 5
  00aa0	8b 45 d0	 mov	 eax, DWORD PTR tv4322[ebp]
  00aa3	89 7d b4	 mov	 DWORD PTR tv4314[ebp], edi
  00aa6	8b 79 18	 mov	 edi, DWORD PTR [ecx+24]
  00aa9	74 0a		 je	 SHORT $LN578@Calc_DRI
  00aab	39 7d b4	 cmp	 DWORD PTR tv4314[ebp], edi
  00aae	8b 7d bc	 mov	 edi, DWORD PTR _this$GSCopy$1$[ebp]
  00ab1	7c 0a		 jl	 SHORT $LN57@Calc_DRI
  00ab3	eb 2c		 jmp	 SHORT $LN55@Calc_DRI
$LN578@Calc_DRI:
  00ab5	39 7d b4	 cmp	 DWORD PTR tv4314[ebp], edi
  00ab8	8b 7d bc	 mov	 edi, DWORD PTR _this$GSCopy$1$[ebp]
  00abb	7e 24		 jle	 SHORT $LN55@Calc_DRI
$LN57@Calc_DRI:

; 464  : 				&& ( ( m_pifaRQ[ m_minScaleInterval_nRQ]->eScaleUnit != CScaleBaseData::HORZ_TICK
; 465  : 						&& m_pifaRQ[ m_minScaleInterval_nRQ]->nScaleInterval_Unit < m_pifaRQ[ nRQ]->nScaleInterval_Unit)
; 466  : 					|| ( m_pifaRQ[ m_minScaleInterval_nRQ]->eScaleUnit == CScaleBaseData::HORZ_TICK
; 467  : 						&& m_pifaRQ[ m_minScaleInterval_nRQ]->nScaleInterval_Unit > m_pifaRQ[ nRQ]->nScaleInterval_Unit))))
; 468  : 		{
; 469  : 			m_minScaleInterval_nRQ = nRQ;

  00abd	8b 4d c8	 mov	 ecx, DWORD PTR _nRQ$1$[ebp]
  00ac0	89 8f ec 00 00
	00		 mov	 DWORD PTR [edi+236], ecx

; 470  : 			m_minScaleInterval_eType = m_pifaRQ[ nRQ]->eScaleUnit;

  00ac6	8b 00		 mov	 eax, DWORD PTR [eax]

; 471  : 			m_minScaleInterval_nUnit = m_pifaRQ[ nRQ]->nScaleInterval_Unit;

  00ac8	8b 4d d0	 mov	 ecx, DWORD PTR tv4322[ebp]
  00acb	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00ace	89 87 f0 00 00
	00		 mov	 DWORD PTR [edi+240], eax
  00ad4	8b 01		 mov	 eax, DWORD PTR [ecx]
  00ad6	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  00ad9	89 87 f4 00 00
	00		 mov	 DWORD PTR [edi+244], eax
  00adf	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN55@Calc_DRI:

; 472  : 		}
; 473  : 		if( m_pifaRQ[ m_maxScaleInterval_nRQ]->nScaleInterval_Sec < m_pifaRQ[ nRQ]->nScaleInterval_Sec
; 474  : 			|| ( m_pifaRQ[ m_maxScaleInterval_nRQ]->nScaleInterval_Sec == m_pifaRQ[ nRQ]->nScaleInterval_Sec

  00ae1	8b 87 e0 00 00
	00		 mov	 eax, DWORD PTR [edi+224]
  00ae7	8b 04 82	 mov	 eax, DWORD PTR [edx+eax*4]
  00aea	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00aed	8b 78 24	 mov	 edi, DWORD PTR [eax+36]
  00af0	3b 79 24	 cmp	 edi, DWORD PTR [ecx+36]
  00af3	8b 7d bc	 mov	 edi, DWORD PTR _this$GSCopy$1$[ebp]
  00af6	7c 2a		 jl	 SHORT $LN61@Calc_DRI
  00af8	7f 05		 jg	 SHORT $LN592@Calc_DRI
  00afa	39 50 20	 cmp	 DWORD PTR [eax+32], edx
  00afd	72 23		 jb	 SHORT $LN61@Calc_DRI
$LN592@Calc_DRI:
  00aff	39 50 20	 cmp	 DWORD PTR [eax+32], edx
  00b02	75 40		 jne	 SHORT $LN59@Calc_DRI
  00b04	8b 50 24	 mov	 edx, DWORD PTR [eax+36]
  00b07	3b 51 24	 cmp	 edx, DWORD PTR [ecx+36]
  00b0a	75 38		 jne	 SHORT $LN59@Calc_DRI
  00b0c	83 78 14 05	 cmp	 DWORD PTR [eax+20], 5
  00b10	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  00b13	8b 49 18	 mov	 ecx, DWORD PTR [ecx+24]
  00b16	74 06		 je	 SHORT $LN577@Calc_DRI
  00b18	3b d1		 cmp	 edx, ecx
  00b1a	7f 06		 jg	 SHORT $LN61@Calc_DRI
  00b1c	eb 26		 jmp	 SHORT $LN59@Calc_DRI
$LN577@Calc_DRI:
  00b1e	3b d1		 cmp	 edx, ecx
  00b20	7d 22		 jge	 SHORT $LN59@Calc_DRI
$LN61@Calc_DRI:

; 475  : 				&& ( ( m_pifaRQ[ m_maxScaleInterval_nRQ]->eScaleUnit != CScaleBaseData::HORZ_TICK
; 476  : 						&& m_pifaRQ[ m_maxScaleInterval_nRQ]->nScaleInterval_Unit > m_pifaRQ[ nRQ]->nScaleInterval_Unit)
; 477  : 					|| ( m_pifaRQ[ m_maxScaleInterval_nRQ]->eScaleUnit == CScaleBaseData::HORZ_TICK
; 478  : 						&& m_pifaRQ[ m_maxScaleInterval_nRQ]->nScaleInterval_Unit < m_pifaRQ[ nRQ]->nScaleInterval_Unit))))
; 479  : 		{
; 480  : 			m_maxScaleInterval_nRQ = nRQ;
; 481  : 			m_maxScaleInterval_eType = m_pifaRQ[ nRQ]->eScaleUnit;

  00b22	8b 4d d0	 mov	 ecx, DWORD PTR tv4322[ebp]
  00b25	8b 45 c8	 mov	 eax, DWORD PTR _nRQ$1$[ebp]
  00b28	89 87 e0 00 00
	00		 mov	 DWORD PTR [edi+224], eax
  00b2e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00b30	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00b33	89 87 e4 00 00
	00		 mov	 DWORD PTR [edi+228], eax

; 482  : 			m_maxScaleInterval_nUnit = m_pifaRQ[ nRQ]->nScaleInterval_Unit;

  00b39	8b 01		 mov	 eax, DWORD PTR [ecx]
  00b3b	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  00b3e	89 87 e8 00 00
	00		 mov	 DWORD PTR [edi+232], eax
$LN59@Calc_DRI:

; 486  : 		m_TimeDiffManager.SetRQDiffTime( saRQ.GetAt(nRQ), pPacketList->GetBaseTimeDifference(), pPacketList->GetCurrDateTime());

  00b44	8b 4d c0	 mov	 ecx, DWORD PTR _pPacketList$1$[ebp]
  00b47	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetCurrDateTime@CPacketList@@QBE_JXZ
  00b4d	8b 4d c0	 mov	 ecx, DWORD PTR _pPacketList$1$[ebp]
  00b50	52		 push	 edx
  00b51	50		 push	 eax
  00b52	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetBaseTimeDifference@CPacketList@@QAEHXZ
  00b58	50		 push	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl

; 289  : 		if( nIndex < 0 || nIndex >= m_nSize )

  00b59	8b 45 c8	 mov	 eax, DWORD PTR _nRQ$1$[ebp]
  00b5c	85 c0		 test	 eax, eax
  00b5e	0f 88 a0 02 00
	00		 js	 $LN471@Calc_DRI
  00b64	3b 45 94	 cmp	 eax, DWORD PTR _saRQ$[ebp+8]
  00b67	0f 8d 97 02 00
	00		 jge	 $LN471@Calc_DRI

; 291  : 		return m_pData[nIndex]; }

  00b6d	8b 4d cc	 mov	 ecx, DWORD PTR tv4318[ebp]
  00b70	8b 45 90	 mov	 eax, DWORD PTR _saRQ$[ebp+4]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 486  : 		m_TimeDiffManager.SetRQDiffTime( saRQ.GetAt(nRQ), pPacketList->GetBaseTimeDifference(), pPacketList->GetCurrDateTime());

  00b73	51		 push	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl

; 291  : 		return m_pData[nIndex]; }

  00b74	03 c1		 add	 eax, ecx
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 486  : 		m_TimeDiffManager.SetRQDiffTime( saRQ.GetAt(nRQ), pPacketList->GetBaseTimeDifference(), pPacketList->GetCurrDateTime());

  00b76	8b cc		 mov	 ecx, esp
  00b78	50		 push	 eax
  00b79	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z
  00b7f	8d 8f ec 05 00
	00		 lea	 ecx, DWORD PTR [edi+1516]
  00b85	e8 00 00 00 00	 call	 ?SetRQDiffTime@CXScaleTimeDiffManager@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H_J@Z ; CXScaleTimeDiffManager::SetRQDiffTime

; 487  : 		if( pPacketList->GetMarketTime( nMarketStartTime, nMarketEndTime) )

  00b8a	8b 4d c0	 mov	 ecx, DWORD PTR _pPacketList$1$[ebp]
  00b8d	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _nMarketEndTime$[ebp]
  00b93	50		 push	 eax
  00b94	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR _nMarketStartTime$[ebp]
  00b9a	50		 push	 eax
  00b9b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetMarketTime@CPacketList@@QBE_NAAH0@Z
  00ba1	84 c0		 test	 al, al
  00ba3	74 3f		 je	 SHORT $LN63@Calc_DRI

; 488  : 			m_TimeDiffManager.SetRQMarketTime( saRQ.GetAt(nRQ), nMarketStartTime, nMarketEndTime, pPacketList->GetMarketDayType());

  00ba5	8b 4d c0	 mov	 ecx, DWORD PTR _pPacketList$1$[ebp]
  00ba8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetMarketDayType@CPacketList@@QAE?AW4MARKETDAYTYPE@CPacketType@@XZ
  00bae	50		 push	 eax
  00baf	ff b5 7c ff ff
	ff		 push	 DWORD PTR _nMarketEndTime$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl

; 289  : 		if( nIndex < 0 || nIndex >= m_nSize )

  00bb5	8b 45 c8	 mov	 eax, DWORD PTR _nRQ$1$[ebp]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 488  : 			m_TimeDiffManager.SetRQMarketTime( saRQ.GetAt(nRQ), nMarketStartTime, nMarketEndTime, pPacketList->GetMarketDayType());

  00bb8	ff b5 78 ff ff
	ff		 push	 DWORD PTR _nMarketStartTime$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl

; 289  : 		if( nIndex < 0 || nIndex >= m_nSize )

  00bbe	3b 45 94	 cmp	 eax, DWORD PTR _saRQ$[ebp+8]
  00bc1	0f 8d 3d 02 00
	00		 jge	 $LN471@Calc_DRI

; 291  : 		return m_pData[nIndex]; }

  00bc7	8b 4d cc	 mov	 ecx, DWORD PTR tv4318[ebp]
  00bca	8b 45 90	 mov	 eax, DWORD PTR _saRQ$[ebp+4]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 488  : 			m_TimeDiffManager.SetRQMarketTime( saRQ.GetAt(nRQ), nMarketStartTime, nMarketEndTime, pPacketList->GetMarketDayType());

  00bcd	51		 push	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl

; 291  : 		return m_pData[nIndex]; }

  00bce	03 c1		 add	 eax, ecx
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 488  : 			m_TimeDiffManager.SetRQMarketTime( saRQ.GetAt(nRQ), nMarketStartTime, nMarketEndTime, pPacketList->GetMarketDayType());

  00bd0	8b cc		 mov	 ecx, esp
  00bd2	50		 push	 eax
  00bd3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z
  00bd9	8d 8f ec 05 00
	00		 lea	 ecx, DWORD PTR [edi+1516]
  00bdf	e8 00 00 00 00	 call	 ?SetRQMarketTime@CXScaleTimeDiffManager@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HHW4MARKETDAYTYPE@CPacketType@@@Z ; CXScaleTimeDiffManager::SetRQMarketTime
$LN63@Calc_DRI:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 51   :         if (_Ptr->_Right->_Isnil) { // climb looking for right subtree

  00be4	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00be7	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00beb	74 1d		 je	 SHORT $LN484@Calc_DRI

; 52   :             _Nodeptr _Pnode;
; 53   :             while (!(_Pnode = _Ptr->_Parent)->_Isnil && _Ptr == _Pnode->_Right) {

  00bed	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00bf0	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00bf4	75 10		 jne	 SHORT $LN483@Calc_DRI
$LL482@Calc_DRI:
  00bf6	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  00bf9	75 0b		 jne	 SHORT $LN483@Calc_DRI

; 54   :                 _Ptr = _Pnode; // ==> parent while right subtree

  00bfb	8b f0		 mov	 esi, eax
  00bfd	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00c00	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00c04	74 f0		 je	 SHORT $LL482@Calc_DRI
$LN483@Calc_DRI:

; 55   :             }
; 56   : 
; 57   :             _Ptr = _Pnode; // ==> parent (head if end())

  00c06	8b f0		 mov	 esi, eax

; 58   :         } else {

  00c08	eb 16		 jmp	 SHORT $LN485@Calc_DRI
$LN484@Calc_DRI:

; 59   :             _Ptr = _Mytree::_Min(_Ptr->_Right); // ==> smallest of right subtree

  00c0a	8b f0		 mov	 esi, eax

; 451  :         while (!_Pnode->_Left->_Isnil) {

  00c0c	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00c0e	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00c12	75 0c		 jne	 SHORT $LN485@Calc_DRI
$LL488@Calc_DRI:
  00c14	8b 01		 mov	 eax, DWORD PTR [ecx]

; 452  :             _Pnode = _Pnode->_Left;

  00c16	8b f1		 mov	 esi, ecx
  00c18	8b c8		 mov	 ecx, eax
  00c1a	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00c1e	74 f4		 je	 SHORT $LL488@Calc_DRI
$LN485@Calc_DRI:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 492  : 	}

  00c20	8d 4d a0	 lea	 ecx, DWORD PTR _strType$9[ebp]
  00c23	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00c27	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 233  :         return this->_Ptr == _Right._Ptr;

  00c2d	8b 45 ac	 mov	 eax, DWORD PTR _pmapPacketList$1$[ebp]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 388  : 	for( nRQ = 0; it_packetRQ != pmapPacketList->end(); nRQ++)

  00c30	ff 45 c8	 inc	 DWORD PTR _nRQ$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 233  :         return this->_Ptr == _Right._Ptr;

  00c33	3b 30		 cmp	 esi, DWORD PTR [eax]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 388  : 	for( nRQ = 0; it_packetRQ != pmapPacketList->end(); nRQ++)

  00c35	0f 85 25 f7 ff
	ff		 jne	 $LL22@Calc_DRI
$LN21@Calc_DRI:

; 493  : 
; 494  : 	// (2009/9/13 - Seung-Won, Bae) for Rearrange of m_pifaOEBT
; 495  : 	OEBT_INFO** pifaOEBT = ( OEBT_INFO**)( new LPVOID[ m_nCountOfRQ]);

  00c3b	8b 47 6c	 mov	 eax, DWORD PTR [edi+108]
  00c3e	33 c9		 xor	 ecx, ecx
  00c40	ba 04 00 00 00	 mov	 edx, 4
  00c45	f7 e2		 mul	 edx
  00c47	0f 90 c1	 seto	 cl
  00c4a	f7 d9		 neg	 ecx
  00c4c	0b c8		 or	 ecx, eax
  00c4e	51		 push	 ecx
  00c4f	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]

; 496  : 	for( nRQ = 0; nRQ < saRQ.GetSize(); nRQ++)

  00c54	33 d2		 xor	 edx, edx
  00c56	89 45 a4	 mov	 DWORD PTR _pifaOEBT$1$[ebp], eax
  00c59	83 c4 04	 add	 esp, 4
  00c5c	89 55 ac	 mov	 DWORD PTR _nRQ$2$[ebp], edx
  00c5f	39 55 94	 cmp	 DWORD PTR _saRQ$[ebp+8], edx
  00c62	0f 8e 93 00 00
	00		 jle	 $LN588@Calc_DRI

; 493  : 
; 494  : 	// (2009/9/13 - Seung-Won, Bae) for Rearrange of m_pifaOEBT
; 495  : 	OEBT_INFO** pifaOEBT = ( OEBT_INFO**)( new LPVOID[ m_nCountOfRQ]);

  00c68	8b c8		 mov	 ecx, eax
  00c6a	89 45 b8	 mov	 DWORD PTR tv4257[ebp], eax
  00c6d	0f 1f 00	 npad	 3
$LL27@Calc_DRI:

; 497  : 	{
; 498  : 		pifaOEBT[ nRQ] = NULL;

  00c70	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 499  : 		for( int nOldRQ = 0; nOldRQ < m_saRQ.GetSize(); nOldRQ++)

  00c76	33 f6		 xor	 esi, esi
  00c78	8b 87 80 00 00
	00		 mov	 eax, DWORD PTR [edi+128]
  00c7e	85 c0		 test	 eax, eax
  00c80	7e 66		 jle	 SHORT $LN25@Calc_DRI
$LL30@Calc_DRI:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl

; 306  : 		if( nIndex < 0 || nIndex >= m_nSize )

  00c82	85 d2		 test	 edx, edx
  00c84	0f 88 7a 01 00
	00		 js	 $LN471@Calc_DRI
  00c8a	3b 55 94	 cmp	 edx, DWORD PTR _saRQ$[ebp+8]
  00c8d	0f 8d 71 01 00
	00		 jge	 $LN471@Calc_DRI
  00c93	85 f6		 test	 esi, esi
  00c95	0f 88 69 01 00
	00		 js	 $LN471@Calc_DRI
  00c9b	3b f0		 cmp	 esi, eax
  00c9d	0f 8d 61 01 00
	00		 jge	 $LN471@Calc_DRI

; 307  : 			AfxThrowInvalidArgException();
; 308  : 		return m_pData[nIndex]; }

  00ca3	8b 4f 7c	 mov	 ecx, DWORD PTR [edi+124]
  00ca6	8d 04 b5 00 00
	00 00		 lea	 eax, DWORD PTR [esi*4]
  00cad	03 c8		 add	 ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h

; 377  : 		return( m_pszData );

  00caf	8b 45 90	 mov	 eax, DWORD PTR _saRQ$[ebp+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h

; 2479 : 		return(str1.Compare(str2) == 0);

  00cb2	ff 34 90	 push	 DWORD PTR [eax+edx*4]
  00cb5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Compare@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEHPBD@Z
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 500  : 			if( m_saRQ[ nOldRQ] == saRQ[ nRQ])

  00cbb	8b 4d b8	 mov	 ecx, DWORD PTR tv4257[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h

; 2479 : 		return(str1.Compare(str2) == 0);

  00cbe	85 c0		 test	 eax, eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 500  : 			if( m_saRQ[ nOldRQ] == saRQ[ nRQ])

  00cc0	75 18		 jne	 SHORT $LN28@Calc_DRI

; 501  : 			{
; 502  : 				pifaOEBT[ nRQ] = m_pifaOEBT[ nOldRQ];

  00cc2	8b 87 90 00 00
	00		 mov	 eax, DWORD PTR [edi+144]
  00cc8	8b 04 b0	 mov	 eax, DWORD PTR [eax+esi*4]
  00ccb	89 01		 mov	 DWORD PTR [ecx], eax

; 503  : 				m_pifaOEBT[ nOldRQ] = NULL;

  00ccd	8b 87 90 00 00
	00		 mov	 eax, DWORD PTR [edi+144]
  00cd3	c7 04 b0 00 00
	00 00		 mov	 DWORD PTR [eax+esi*4], 0
$LN28@Calc_DRI:

; 499  : 		for( int nOldRQ = 0; nOldRQ < m_saRQ.GetSize(); nOldRQ++)

  00cda	8b 87 80 00 00
	00		 mov	 eax, DWORD PTR [edi+128]
  00ce0	46		 inc	 esi
  00ce1	8b 55 ac	 mov	 edx, DWORD PTR _nRQ$2$[ebp]
  00ce4	3b f0		 cmp	 esi, eax
  00ce6	7c 9a		 jl	 SHORT $LL30@Calc_DRI
$LN25@Calc_DRI:

; 496  : 	for( nRQ = 0; nRQ < saRQ.GetSize(); nRQ++)

  00ce8	42		 inc	 edx
  00ce9	83 c1 04	 add	 ecx, 4
  00cec	89 55 ac	 mov	 DWORD PTR _nRQ$2$[ebp], edx
  00cef	89 4d b8	 mov	 DWORD PTR tv4257[ebp], ecx
  00cf2	3b 55 94	 cmp	 edx, DWORD PTR _saRQ$[ebp+8]
  00cf5	0f 8c 75 ff ff
	ff		 jl	 $LL27@Calc_DRI
$LN588@Calc_DRI:

; 504  : 			}
; 505  : 	}
; 506  : 	for( nRQ = 0; nRQ < m_saRQ.GetSize(); nRQ++)

  00cfb	33 f6		 xor	 esi, esi
  00cfd	39 b7 80 00 00
	00		 cmp	 DWORD PTR [edi+128], esi
  00d03	7e 39		 jle	 SHORT $LN32@Calc_DRI
  00d05	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL33@Calc_DRI:

; 507  : 		if( m_pifaOEBT[ nRQ]) delete m_pifaOEBT[ nRQ];

  00d10	8b 87 90 00 00
	00		 mov	 eax, DWORD PTR [edi+144]
  00d16	8b 04 b0	 mov	 eax, DWORD PTR [eax+esi*4]
  00d19	89 45 a8	 mov	 DWORD PTR $T11[ebp], eax
  00d1c	85 c0		 test	 eax, eax
  00d1e	74 15		 je	 SHORT $LN31@Calc_DRI
  00d20	8b c8		 mov	 ecx, eax
  00d22	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00d28	6a 08		 push	 8
  00d2a	ff 75 a8	 push	 DWORD PTR $T11[ebp]
  00d2d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00d32	83 c4 08	 add	 esp, 8
$LN31@Calc_DRI:

; 504  : 			}
; 505  : 	}
; 506  : 	for( nRQ = 0; nRQ < m_saRQ.GetSize(); nRQ++)

  00d35	46		 inc	 esi
  00d36	3b b7 80 00 00
	00		 cmp	 esi, DWORD PTR [edi+128]
  00d3c	7c d2		 jl	 SHORT $LL33@Calc_DRI
$LN32@Calc_DRI:

; 508  : 	delete [] m_pifaOEBT;

  00d3e	ff b7 90 00 00
	00		 push	 DWORD PTR [edi+144]
  00d44	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]

; 509  : 	m_pifaOEBT = pifaOEBT;

  00d49	8b 45 a4	 mov	 eax, DWORD PTR _pifaOEBT$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl

; 286  : 	{ SetSize(0); }

  00d4c	8d 4f 78	 lea	 ecx, DWORD PTR [edi+120]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 508  : 	delete [] m_pifaOEBT;

  00d4f	83 c4 04	 add	 esp, 4

; 509  : 	m_pifaOEBT = pifaOEBT;

  00d52	89 87 90 00 00
	00		 mov	 DWORD PTR [edi+144], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl

; 286  : 	{ SetSize(0); }

  00d58	6a ff		 push	 -1
  00d5a	6a 00		 push	 0
  00d5c	e8 00 00 00 00	 call	 ?SetSize@CStringArray@@QAEXHH@Z ; CStringArray::SetSize
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 511  : 	m_saRQ.Append( saRQ);

  00d61	8d 45 8c	 lea	 eax, DWORD PTR _saRQ$[ebp]
  00d64	50		 push	 eax
  00d65	8d 4f 78	 lea	 ecx, DWORD PTR [edi+120]
  00d68	e8 00 00 00 00	 call	 ?Append@CStringArray@@QAEHABV1@@Z ; CStringArray::Append

; 512  : 
; 513  : 	// 20080925 JS.Kim	   Scale .
; 514  : 	m_TimeDiffManager.SetCurrentRQ( m_pIChartCtrl->GetCurrentRQ());	//     RQ 

  00d6d	8b 4f 50	 mov	 ecx, DWORD PTR [edi+80]
  00d70	51		 push	 ecx
  00d71	8b f4		 mov	 esi, esp
  00d73	8b 01		 mov	 eax, DWORD PTR [ecx]
  00d75	8b 80 d8 02 00
	00		 mov	 eax, DWORD PTR [eax+728]
  00d7b	ff d0		 call	 eax
  00d7d	50		 push	 eax
  00d7e	8b ce		 mov	 ecx, esi
  00d80	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  00d86	8d 8f ec 05 00
	00		 lea	 ecx, DWORD PTR [edi+1516]
  00d8c	e8 00 00 00 00	 call	 ?SetCurrentRQ@CXScaleTimeDiffManager@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ; CXScaleTimeDiffManager::SetCurrentRQ

; 515  : 
; 516  : 	// 2. Cacl_DRI_Merge
; 517  : 	if( p_bWithMerge) Calc_DRI_Merge();

  00d91	83 7d 08 00	 cmp	 DWORD PTR _p_bWithMerge$[ebp], 0
  00d95	74 07		 je	 SHORT $LN66@Calc_DRI
  00d97	8b 07		 mov	 eax, DWORD PTR [edi]
  00d99	8b cf		 mov	 ecx, edi
  00d9b	ff 50 70	 call	 DWORD PTR [eax+112]
$LN66@Calc_DRI:

; 521  : 	m_bCeiling = ( m_minScaleInterval_nUnit % 60 == 0 && CPacketType::FLOOR != m_pifaRQ[ 0]->pPacketList->GetRealType());

  00d9e	8b 87 f4 00 00
	00		 mov	 eax, DWORD PTR [edi+244]
  00da4	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00da9	99		 cdq
  00daa	f7 f9		 idiv	 ecx
  00dac	85 d2		 test	 edx, edx
  00dae	75 22		 jne	 SHORT $LN90@Calc_DRI
  00db0	8b 87 8c 00 00
	00		 mov	 eax, DWORD PTR [edi+140]
  00db6	8b 08		 mov	 ecx, DWORD PTR [eax]
  00db8	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00dbb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetRealType@CPacketList@@QBE?AW4REALTYPE@CPacketType@@XZ
  00dc1	85 c0		 test	 eax, eax
  00dc3	74 0d		 je	 SHORT $LN90@Calc_DRI
  00dc5	b8 01 00 00 00	 mov	 eax, 1
  00dca	eb 08		 jmp	 SHORT $LN91@Calc_DRI
$LN392@Calc_DRI:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00dcc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN90@Calc_DRI:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 521  : 	m_bCeiling = ( m_minScaleInterval_nUnit % 60 == 0 && CPacketType::FLOOR != m_pifaRQ[ 0]->pPacketList->GetRealType());

  00dd2	33 c0		 xor	 eax, eax
$LN91@Calc_DRI:

; 522  : }

  00dd4	8d 4d 8c	 lea	 ecx, DWORD PTR _saRQ$[ebp]
  00dd7	89 87 e4 05 00
	00		 mov	 DWORD PTR [edi+1508], eax
  00ddd	e8 00 00 00 00	 call	 ??1CStringArray@@UAE@XZ	; CStringArray::~CStringArray
$LN1@Calc_DRI:
  00de2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00de5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00dec	59		 pop	 ecx
  00ded	5f		 pop	 edi
  00dee	5e		 pop	 esi
  00def	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00df2	33 cd		 xor	 ecx, ebp
  00df4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00df9	8b e5		 mov	 esp, ebp
  00dfb	5d		 pop	 ebp
  00dfc	c2 04 00	 ret	 4
$LN529@Calc_DRI:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 131  :         _Throw_bad_array_new_length(); // add overflow

  00dff	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN471@Calc_DRI:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 522  : }

  00e04	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN530@Calc_DRI:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1616 :             _Throw_tree_length_error();

  00e09	e8 00 00 00 00	 call	 ?_Throw_tree_length_error@std@@YAXXZ ; std::_Throw_tree_length_error
$LN597@Calc_DRI:
  00e0e	66 90		 npad	 2
$LN590@Calc_DRI:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 522  : }

  00e10	00 00 00 00	 DD	 $LN47@Calc_DRI
  00e14	00 00 00 00	 DD	 $LN46@Calc_DRI
  00e18	00 00 00 00	 DD	 $LN45@Calc_DRI
  00e1c	00 00 00 00	 DD	 $LN48@Calc_DRI
  00e20	00 00 00 00	 DD	 $LN53@Calc_DRI
  00e24	00 00 00 00	 DD	 $LN23@Calc_DRI
$LN589@Calc_DRI:
  00e28	00		 DB	 0
  00e29	01		 DB	 1
  00e2a	02		 DB	 2
  00e2b	03		 DB	 3
  00e2c	05		 DB	 5
  00e2d	03		 DB	 3
  00e2e	05		 DB	 5
  00e2f	05		 DB	 5
  00e30	05		 DB	 5
  00e31	05		 DB	 5
  00e32	05		 DB	 5
  00e33	04		 DB	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Calc_DRI@CXScaleManagerImp@@MAEXH@Z$0:
  00000	8d 4d 8c	 lea	 ecx, DWORD PTR _saRQ$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CStringArray@@UAE@XZ	; CStringArray::~CStringArray
__unwindfunclet$?Calc_DRI@CXScaleManagerImp@@MAEXH@Z$1:
  00008	8d 4d d4	 lea	 ecx, DWORD PTR $T20[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@QAE@XZ
__unwindfunclet$?Calc_DRI@CXScaleManagerImp@@MAEXH@Z$21:
  00010	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  00016	e9 00 00 00 00	 jmp	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> > >
__unwindfunclet$?Calc_DRI@CXScaleManagerImp@@MAEXH@Z$2:
  0001b	8d 4d 88	 lea	 ecx, DWORD PTR $T8[ebp]
  0001e	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?Calc_DRI@CXScaleManagerImp@@MAEXH@Z$6:
  00024	8b 45 84	 mov	 eax, DWORD PTR $T7[ebp]
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 ??3CObject@@SGXPAX@Z	; CObject::operator delete
  0002d	c3		 ret	 0
__unwindfunclet$?Calc_DRI@CXScaleManagerImp@@MAEXH@Z$8:
  0002e	8b 45 c4	 mov	 eax, DWORD PTR $T15[ebp]
  00031	83 e0 01	 and	 eax, 1
  00034	0f 84 0d 00 00
	00		 je	 $LN101@Calc_DRI
  0003a	83 65 c4 fe	 and	 DWORD PTR $T15[ebp], -2	; fffffffeH
  0003e	8d 4d 80	 lea	 ecx, DWORD PTR $T6[ebp]
  00041	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$LN101@Calc_DRI:
  00047	c3		 ret	 0
__unwindfunclet$?Calc_DRI@CXScaleManagerImp@@MAEXH@Z$9:
  00048	8d 4d a0	 lea	 ecx, DWORD PTR _strType$9[ebp]
  0004b	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?Calc_DRI@CXScaleManagerImp@@MAEXH@Z$10:
  00051	8d 4d a4	 lea	 ecx, DWORD PTR $T10[ebp]
  00054	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0005a	cc		 int	 3
  0005b	cc		 int	 3
  0005c	cc		 int	 3
  0005d	cc		 int	 3
  0005e	cc		 int	 3
__ehhandler$?Calc_DRI@CXScaleManagerImp@@MAEXH@Z:
  0005f	90		 npad	 1
  00060	90		 npad	 1
  00061	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00065	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00068	8b 8a 48 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-184]
  0006e	33 c8		 xor	 ecx, eax
  00070	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00075	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00078	33 c8		 xor	 ecx, eax
  0007a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0007f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Calc_DRI@CXScaleManagerImp@@MAEXH@Z
  00084	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Calc_DRI@CXScaleManagerImp@@MAEXH@Z ENDP		; CXScaleManagerImp::Calc_DRI
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?GetDTIFromDRI_AbleRange@CXScaleManagerImp@@IAEHPAV?$CDataBlockList@H$0CAA@@@HPAH@Z
_TEXT	SEGMENT
_pblDTIfDRI$ = 8					; size = 4
_nDRI$ = 12						; size = 4
_pnDTI_Org$ = 16					; size = 4
?GetDTIFromDRI_AbleRange@CXScaleManagerImp@@IAEHPAV?$CDataBlockList@H$0CAA@@@HPAH@Z PROC ; CXScaleManagerImp::GetDTIFromDRI_AbleRange, COMDAT
; _this$ = ecx

; 1467 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1435 : 	if( !pblDTIfDRI) return -1;

  00004	8b 75 08	 mov	 esi, DWORD PTR _pblDTIfDRI$[ebp]

; 1467 : {

  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx

; 1435 : 	if( !pblDTIfDRI) return -1;

  0000a	85 f6		 test	 esi, esi
  0000c	74 34		 je	 SHORT $LN14@GetDTIFrom

; 1436 : 
; 1437 : 	int nItemCount = pblDTIfDRI->GetItemCount();

  0000e	8b ce		 mov	 ecx, esi
  00010	e8 00 00 00 00	 call	 ?GetItemCount@CDataBlockListUNK@@QAEHXZ ; CDataBlockListUNK::GetItemCount
  00015	8b c8		 mov	 ecx, eax

; 1438 : 	if( nItemCount == 0) return -1;

  00017	85 c9		 test	 ecx, ecx
  00019	74 27		 je	 SHORT $LN14@GetDTIFrom

; 1439 : 
; 1440 : 	if( 0 <= nDRI && nDRI < nItemCount)

  0001b	8b 45 0c	 mov	 eax, DWORD PTR _nDRI$[ebp]
  0001e	85 c0		 test	 eax, eax
  00020	78 06		 js	 SHORT $LN11@GetDTIFrom
  00022	3b c1		 cmp	 eax, ecx
  00024	7d 06		 jge	 SHORT $LN20@GetDTIFrom

; 1441 : 	{
; 1442 : 		m_pIReturn = pblDTIfDRI->GetAt(nDRI);
; 1443 : 		if( m_pIReturn) return *m_pIReturn;
; 1444 : 		else return -1;

  00026	eb 07		 jmp	 SHORT $LN22@GetDTIFrom
$LN11@GetDTIFrom:

; 1445 : 	}
; 1446 : 	if( nItemCount <= nDRI)

  00028	3b c8		 cmp	 ecx, eax
  0002a	7f 16		 jg	 SHORT $LN14@GetDTIFrom
$LN20@GetDTIFrom:

; 1447 : 	{
; 1448 : 		m_pIReturn = pblDTIfDRI->GetAt( nItemCount - 1);	// end mark.

  0002c	8d 41 ff	 lea	 eax, DWORD PTR [ecx-1]
$LN22@GetDTIFrom:

; 1468 : 	int nDTI = GetDTIFromDRI(pblDTIfDRI, nDRI);
; 1469 : 	if( pnDTI_Org != NULL) *pnDTI_Org = nDTI;

  0002f	50		 push	 eax
  00030	8b ce		 mov	 ecx, esi
  00032	e8 00 00 00 00	 call	 ?GetAtUNK@CDataBlockListUNK@@QAEPAXH@Z ; CDataBlockListUNK::GetAtUNK
  00037	89 47 60	 mov	 DWORD PTR [edi+96], eax
  0003a	85 c0		 test	 eax, eax
  0003c	74 04		 je	 SHORT $LN14@GetDTIFrom
  0003e	8b 00		 mov	 eax, DWORD PTR [eax]
  00040	eb 03		 jmp	 SHORT $LN6@GetDTIFrom
$LN14@GetDTIFrom:
  00042	83 c8 ff	 or	 eax, -1
$LN6@GetDTIFrom:
  00045	8b 4d 10	 mov	 ecx, DWORD PTR _pnDTI_Org$[ebp]
  00048	5f		 pop	 edi
  00049	5e		 pop	 esi
  0004a	85 c9		 test	 ecx, ecx
  0004c	74 02		 je	 SHORT $LN2@GetDTIFrom
  0004e	89 01		 mov	 DWORD PTR [ecx], eax
$LN2@GetDTIFrom:

; 1470 : 	if( nDTI == -1)	nDTI = 0;
; 1471 : 	if( nDTI < -1)	nDTI = (nDTI * -1) - 3;

  00050	33 c9		 xor	 ecx, ecx
  00052	83 f8 ff	 cmp	 eax, -1
  00055	0f 45 c8	 cmovne	 ecx, eax

; 1472 : 	return nDTI;

  00058	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH
  0005d	2b c1		 sub	 eax, ecx
  0005f	83 f9 ff	 cmp	 ecx, -1
  00062	0f 4d c1	 cmovge	 eax, ecx

; 1473 : }

  00065	5d		 pop	 ebp
  00066	c2 0c 00	 ret	 12			; 0000000cH
?GetDTIFromDRI_AbleRange@CXScaleManagerImp@@IAEHPAV?$CDataBlockList@H$0CAA@@@HPAH@Z ENDP ; CXScaleManagerImp::GetDTIFromDRI_AbleRange
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?GetDTIFromDRI@CXScaleManagerImp@@IAEHPAV?$CDataBlockList@H$0CAA@@@H@Z
_TEXT	SEGMENT
_pblDTIfDRI$ = 8					; size = 4
_nDRI$ = 12						; size = 4
?GetDTIFromDRI@CXScaleManagerImp@@IAEHPAV?$CDataBlockList@H$0CAA@@@H@Z PROC ; CXScaleManagerImp::GetDTIFromDRI, COMDAT
; _this$ = ecx

; 1433 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1434 : 	// (2009/4/10 - Seung-Won, Bae) check NULL.
; 1435 : 	if( !pblDTIfDRI) return -1;

  00004	8b 75 08	 mov	 esi, DWORD PTR _pblDTIfDRI$[ebp]
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
  0000a	85 f6		 test	 esi, esi
  0000c	74 49		 je	 SHORT $LN9@GetDTIFrom

; 1436 : 
; 1437 : 	int nItemCount = pblDTIfDRI->GetItemCount();

  0000e	8b ce		 mov	 ecx, esi
  00010	e8 00 00 00 00	 call	 ?GetItemCount@CDataBlockListUNK@@QAEHXZ ; CDataBlockListUNK::GetItemCount

; 1438 : 	if( nItemCount == 0) return -1;

  00015	85 c0		 test	 eax, eax
  00017	74 3e		 je	 SHORT $LN9@GetDTIFrom

; 1439 : 
; 1440 : 	if( 0 <= nDRI && nDRI < nItemCount)

  00019	8b 55 0c	 mov	 edx, DWORD PTR _nDRI$[ebp]
  0001c	85 d2		 test	 edx, edx
  0001e	78 1b		 js	 SHORT $LN6@GetDTIFrom
  00020	3b d0		 cmp	 edx, eax
  00022	7d 1b		 jge	 SHORT $LN15@GetDTIFrom
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 215  : 	T*	GetAt( int nIndex)	{	return ( T*)GetAtUNK( nIndex);	}

  00024	52		 push	 edx
  00025	8b ce		 mov	 ecx, esi
  00027	e8 00 00 00 00	 call	 ?GetAtUNK@CDataBlockListUNK@@QAEPAXH@Z ; CDataBlockListUNK::GetAtUNK
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 1442 : 		m_pIReturn = pblDTIfDRI->GetAt(nDRI);

  0002c	89 47 60	 mov	 DWORD PTR [edi+96], eax

; 1443 : 		if( m_pIReturn) return *m_pIReturn;

  0002f	85 c0		 test	 eax, eax
  00031	74 24		 je	 SHORT $LN9@GetDTIFrom
  00033	8b 00		 mov	 eax, DWORD PTR [eax]
  00035	5f		 pop	 edi

; 1453 : }

  00036	5e		 pop	 esi
  00037	5d		 pop	 ebp
  00038	c2 08 00	 ret	 8
$LN6@GetDTIFrom:

; 1444 : 		else return -1;
; 1445 : 	}
; 1446 : 	if( nItemCount <= nDRI)

  0003b	3b c2		 cmp	 eax, edx
  0003d	7f 18		 jg	 SHORT $LN9@GetDTIFrom
$LN15@GetDTIFrom:

; 1448 : 		m_pIReturn = pblDTIfDRI->GetAt( nItemCount - 1);	// end mark.

  0003f	48		 dec	 eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 215  : 	T*	GetAt( int nIndex)	{	return ( T*)GetAtUNK( nIndex);	}

  00040	8b ce		 mov	 ecx, esi
  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 ?GetAtUNK@CDataBlockListUNK@@QAEPAXH@Z ; CDataBlockListUNK::GetAtUNK
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 1448 : 		m_pIReturn = pblDTIfDRI->GetAt( nItemCount - 1);	// end mark.

  00048	89 47 60	 mov	 DWORD PTR [edi+96], eax

; 1449 : 		if( m_pIReturn) return *m_pIReturn;

  0004b	85 c0		 test	 eax, eax
  0004d	74 08		 je	 SHORT $LN9@GetDTIFrom
  0004f	8b 00		 mov	 eax, DWORD PTR [eax]
  00051	5f		 pop	 edi

; 1453 : }

  00052	5e		 pop	 esi
  00053	5d		 pop	 ebp
  00054	c2 08 00	 ret	 8
$LN9@GetDTIFrom:
  00057	5f		 pop	 edi

; 1450 : 		else return -1;
; 1451 : 	}
; 1452 : 	return -1;															// no matched.

  00058	83 c8 ff	 or	 eax, -1

; 1453 : }

  0005b	5e		 pop	 esi
  0005c	5d		 pop	 ebp
  0005d	c2 08 00	 ret	 8
?GetDTIFromDRI@CXScaleManagerImp@@IAEHPAV?$CDataBlockList@H$0CAA@@@H@Z ENDP ; CXScaleManagerImp::GetDTIFromDRI
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.h
;	COMDAT ?GetMinScaleInterval_nUnit@CXScaleManagerImp@@MAEHXZ
_TEXT	SEGMENT
?GetMinScaleInterval_nUnit@CXScaleManagerImp@@MAEHXZ PROC ; CXScaleManagerImp::GetMinScaleInterval_nUnit, COMDAT
; _this$ = ecx

; 365  : 	virtual int		GetMinScaleInterval_nUnit( void)	{	return m_minScaleInterval_nUnit;	}

  00000	8b 81 f4 00 00
	00		 mov	 eax, DWORD PTR [ecx+244]
  00006	c3		 ret	 0
?GetMinScaleInterval_nUnit@CXScaleManagerImp@@MAEHXZ ENDP ; CXScaleManagerImp::GetMinScaleInterval_nUnit
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
;	COMDAT ??_G?$CDataBlockList@_J$0CAA@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CDataBlockList@_J$0CAA@@@UAEPAXI@Z PROC		; CDataBlockList<__int64,512>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 163  : 	{

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CDataBlockList@_J$0CAA@@@6B@

; 164  : 	}

  0000c	e8 00 00 00 00	 call	 ??1CDataBlockListUNK@@UAE@XZ ; CDataBlockListUNK::~CDataBlockListUNK
  00011	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00015	74 0b		 je	 SHORT $LN7@scalar
  00017	6a 34		 push	 52			; 00000034H
  00019	56		 push	 esi
  0001a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001f	83 c4 08	 add	 esp, 8
$LN7@scalar:
  00022	8b c6		 mov	 eax, esi
  00024	5e		 pop	 esi
  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
??_G?$CDataBlockList@_J$0CAA@@@UAEPAXI@Z ENDP		; CDataBlockList<__int64,512>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
;	COMDAT ??1?$CDataBlockList@_J$0CAA@@@UAE@XZ
_TEXT	SEGMENT
??1?$CDataBlockList@_J$0CAA@@@UAE@XZ PROC		; CDataBlockList<__int64,512>::~CDataBlockList<__int64,512>, COMDAT
; _this$ = ecx

; 163  : 	{

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CDataBlockList@_J$0CAA@@@6B@

; 164  : 	}

  00006	e9 00 00 00 00	 jmp	 ??1CDataBlockListUNK@@UAE@XZ ; CDataBlockListUNK::~CDataBlockListUNK
??1?$CDataBlockList@_J$0CAA@@@UAE@XZ ENDP		; CDataBlockList<__int64,512>::~CDataBlockList<__int64,512>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@@2@@std@@QAE@XZ PROC ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,CXScaleManagerImp::VERTBOX_INFO *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,CXScaleManagerImp::VERTBOX_INFO *> > >::~map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,CXScaleManagerImp::VERTBOX_INFO *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,CXScaleManagerImp::VERTBOX_INFO *> > >, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 752  :         _Erase_tree(_Al, _Myhead->_Parent);

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	ff 70 04	 push	 DWORD PTR [eax+4]
  00008	56		 push	 esi
  00009	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,CXScaleManagerImp::VERTBOX_INFO *> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,CXScaleManagerImp::VERTBOX_INFO *>,void *> > >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 255  :         ::operator delete(_Ptr, _Bytes);

  0000e	6a 2c		 push	 44			; 0000002cH
  00010	ff 36		 push	 DWORD PTR [esi]
  00012	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00017	83 c4 08	 add	 esp, 8
  0001a	5e		 pop	 esi
  0001b	c3		 ret	 0
??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@@2@@std@@QAE@XZ ENDP ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,CXScaleManagerImp::VERTBOX_INFO *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,CXScaleManagerImp::VERTBOX_INFO *> > >::~map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,CXScaleManagerImp::VERTBOX_INFO *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,CXScaleManagerImp::VERTBOX_INFO *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@PAX@std@@@2@QAU32@@Z
_TEXT	SEGMENT
__Head$1$ = -8						; size = 4
_this$1$ = -4						; size = 4
__Loc$ = 8						; size = 8
__Newnode$ = 16						; size = 4
?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@PAX@std@@@2@QAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,CXScaleManagerImp::VERTBOX_INFO *> > >::_Insert_node, COMDAT
; _this$ = ecx

; 644  :     _Nodeptr _Insert_node(const _Tree_id<_Nodeptr> _Loc, const _Nodeptr _Newnode) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 645  :         ++_Mysize;
; 646  :         const auto _Head  = _Myhead;
; 647  :         _Newnode->_Parent = _Loc._Parent;

  00006	8b 55 08	 mov	 edx, DWORD PTR __Loc$[ebp]
  00009	8b c1		 mov	 eax, ecx
  0000b	89 45 fc	 mov	 DWORD PTR _this$1$[ebp], eax
  0000e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00010	ff 40 04	 inc	 DWORD PTR [eax+4]
  00013	8b 45 10	 mov	 eax, DWORD PTR __Newnode$[ebp]
  00016	89 4d f8	 mov	 DWORD PTR __Head$1$[ebp], ecx
  00019	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 648  :         if (_Loc._Parent == _Head) { // first node in tree, just set head values

  0001c	3b d1		 cmp	 edx, ecx
  0001e	75 12		 jne	 SHORT $LN5@Insert_nod

; 649  :             _Head->_Left     = _Newnode;

  00020	89 01		 mov	 DWORD PTR [ecx], eax

; 650  :             _Head->_Parent   = _Newnode;

  00022	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 651  :             _Head->_Right    = _Newnode;

  00025	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 652  :             _Newnode->_Color = _Black; // the root is black

  00028	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 711  :     }

  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c2 0c 00	 ret	 12			; 0000000cH
$LN5@Insert_nod:

; 653  :             return _Newnode;
; 654  :         }
; 655  : 
; 656  :         _STL_INTERNAL_CHECK(_Loc._Child != _Tree_child::_Unused);
; 657  :         if (_Loc._Child == _Tree_child::_Right) { // add to right of _Loc._Parent

  00032	83 7d 0c 00	 cmp	 DWORD PTR __Loc$[ebp+4], 0
  00036	75 0d		 jne	 SHORT $LN6@Insert_nod

; 658  :             _STL_INTERNAL_CHECK(_Loc._Parent->_Right->_Isnil);
; 659  :             _Loc._Parent->_Right = _Newnode;

  00038	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 660  :             if (_Loc._Parent == _Head->_Right) { // remember rightmost node

  0003b	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  0003e	75 0d		 jne	 SHORT $LN9@Insert_nod

; 661  :                 _Head->_Right = _Newnode;

  00040	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 662  :             }
; 663  :         } else { // add to left of _Loc._Parent

  00043	eb 08		 jmp	 SHORT $LN9@Insert_nod
$LN6@Insert_nod:

; 664  :             _STL_INTERNAL_CHECK(_Loc._Parent->_Left->_Isnil);
; 665  :             _Loc._Parent->_Left = _Newnode;

  00045	89 02		 mov	 DWORD PTR [edx], eax

; 666  :             if (_Loc._Parent == _Head->_Left) { // remember leftmost node

  00047	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00049	75 02		 jne	 SHORT $LN9@Insert_nod

; 667  :                 _Head->_Left = _Newnode;

  0004b	89 01		 mov	 DWORD PTR [ecx], eax
$LN9@Insert_nod:

; 668  :             }
; 669  :         }
; 670  : 
; 671  :         for (_Nodeptr _Pnode = _Newnode; _Pnode->_Parent->_Color == _Red;) {

  0004d	8b d0		 mov	 edx, eax
  0004f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00052	80 78 0c 00	 cmp	 BYTE PTR [eax+12], 0
  00056	0f 85 99 01 00
	00		 jne	 $LN3@Insert_nod
  0005c	53		 push	 ebx
  0005d	56		 push	 esi
  0005e	57		 push	 edi
  0005f	90		 npad	 1
$LL2@Insert_nod:

; 672  :             if (_Pnode->_Parent == _Pnode->_Parent->_Parent->_Left) { // fixup red-red in left subtree

  00060	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00063	8d 7a 04	 lea	 edi, DWORD PTR [edx+4]
  00066	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00069	8d 59 04	 lea	 ebx, DWORD PTR [ecx+4]
  0006c	8b 06		 mov	 eax, DWORD PTR [esi]
  0006e	3b c8		 cmp	 ecx, eax
  00070	0f 85 ba 00 00
	00		 jne	 $LN10@Insert_nod

; 673  :                 const auto _Parent_sibling = _Pnode->_Parent->_Parent->_Right;

  00076	8b 46 08	 mov	 eax, DWORD PTR [esi+8]

; 674  :                 if (_Parent_sibling->_Color == _Red) { // parent's sibling has two red children, blacken both

  00079	80 78 0c 00	 cmp	 BYTE PTR [eax+12], 0
  0007d	0f 84 b3 00 00
	00		 je	 $LN53@Insert_nod

; 675  :                     _Pnode->_Parent->_Color          = _Black;
; 676  :                     _Parent_sibling->_Color          = _Black;
; 677  :                     _Pnode->_Parent->_Parent->_Color = _Red;
; 678  :                     _Pnode                           = _Pnode->_Parent->_Parent;
; 679  :                 } else { // parent's sibling has red and black children
; 680  :                     if (_Pnode == _Pnode->_Parent->_Right) { // rotate right child to left

  00083	8b 71 08	 mov	 esi, DWORD PTR [ecx+8]
  00086	3b d6		 cmp	 edx, esi
  00088	75 47		 jne	 SHORT $LN51@Insert_nod

; 460  :         _Wherenode->_Right = _Pnode->_Left;

  0008a	8b 06		 mov	 eax, DWORD PTR [esi]

; 681  :                         _Pnode = _Pnode->_Parent;

  0008c	8b d1		 mov	 edx, ecx

; 460  :         _Wherenode->_Right = _Pnode->_Left;

  0008e	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 461  : 
; 462  :         if (!_Pnode->_Left->_Isnil) {

  00091	8b 06		 mov	 eax, DWORD PTR [esi]
  00093	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00097	75 03		 jne	 SHORT $LN20@Insert_nod

; 463  :             _Pnode->_Left->_Parent = _Wherenode;

  00099	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN20@Insert_nod:

; 464  :         }
; 465  : 
; 466  :         _Pnode->_Parent = _Wherenode->_Parent;

  0009c	8b 03		 mov	 eax, DWORD PTR [ebx]
  0009e	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 467  : 
; 468  :         if (_Wherenode == _Myhead->_Parent) {

  000a1	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]
  000a4	8b 00		 mov	 eax, DWORD PTR [eax]
  000a6	3b 50 04	 cmp	 edx, DWORD PTR [eax+4]
  000a9	75 0b		 jne	 SHORT $LN21@Insert_nod

; 469  :             _Myhead->_Parent = _Pnode;

  000ab	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 477  :         _Wherenode->_Parent = _Pnode;

  000ae	8b fb		 mov	 edi, ebx
  000b0	89 16		 mov	 DWORD PTR [esi], edx
  000b2	89 33		 mov	 DWORD PTR [ebx], esi
  000b4	eb 1d		 jmp	 SHORT $LN49@Insert_nod
$LN21@Insert_nod:

; 470  :         } else if (_Wherenode == _Wherenode->_Parent->_Left) {

  000b6	8b 03		 mov	 eax, DWORD PTR [ebx]
  000b8	3b 10		 cmp	 edx, DWORD PTR [eax]
  000ba	75 0a		 jne	 SHORT $LN23@Insert_nod

; 471  :             _Wherenode->_Parent->_Left = _Pnode;

  000bc	89 30		 mov	 DWORD PTR [eax], esi

; 477  :         _Wherenode->_Parent = _Pnode;

  000be	8b fb		 mov	 edi, ebx
  000c0	89 16		 mov	 DWORD PTR [esi], edx
  000c2	89 33		 mov	 DWORD PTR [ebx], esi
  000c4	eb 0d		 jmp	 SHORT $LN49@Insert_nod
$LN23@Insert_nod:

; 473  :             _Wherenode->_Parent->_Right = _Pnode;

  000c6	89 70 08	 mov	 DWORD PTR [eax+8], esi

; 477  :         _Wherenode->_Parent = _Pnode;

  000c9	8b fb		 mov	 edi, ebx
  000cb	89 16		 mov	 DWORD PTR [esi], edx
  000cd	89 33		 mov	 DWORD PTR [ebx], esi
  000cf	eb 02		 jmp	 SHORT $LN49@Insert_nod
$LN51@Insert_nod:
  000d1	8b f1		 mov	 esi, ecx
$LN49@Insert_nod:

; 682  :                         _Lrotate(_Pnode);
; 683  :                     }
; 684  : 
; 685  :                     _Pnode->_Parent->_Color          = _Black; // propagate red up

  000d3	c6 46 0c 01	 mov	 BYTE PTR [esi+12], 1

; 686  :                     _Pnode->_Parent->_Parent->_Color = _Red;

  000d7	8b 07		 mov	 eax, DWORD PTR [edi]
  000d9	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000dc	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 687  :                     _Rrotate(_Pnode->_Parent->_Parent);

  000e0	8b 07		 mov	 eax, DWORD PTR [edi]
  000e2	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 481  :         _Nodeptr _Pnode   = _Wherenode->_Left;

  000e5	8b 31		 mov	 esi, DWORD PTR [ecx]

; 482  :         _Wherenode->_Left = _Pnode->_Right;

  000e7	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000ea	89 01		 mov	 DWORD PTR [ecx], eax

; 483  : 
; 484  :         if (!_Pnode->_Right->_Isnil) {

  000ec	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000ef	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  000f3	75 03		 jne	 SHORT $LN27@Insert_nod

; 485  :             _Pnode->_Right->_Parent = _Wherenode;

  000f5	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN27@Insert_nod:

; 486  :         }
; 487  : 
; 488  :         _Pnode->_Parent = _Wherenode->_Parent;

  000f8	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  000fb	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 489  : 
; 490  :         if (_Wherenode == _Myhead->_Parent) {

  000fe	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]
  00101	8b 00		 mov	 eax, DWORD PTR [eax]
  00103	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00106	75 0b		 jne	 SHORT $LN28@Insert_nod

; 491  :             _Myhead->_Parent = _Pnode;

  00108	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 496  :         }
; 497  : 
; 498  :         _Pnode->_Right      = _Wherenode;

  0010b	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 688  :                 }
; 689  :             } else { // fixup red-red in right subtree

  0010e	e9 cc 00 00 00	 jmp	 $LN52@Insert_nod
$LN28@Insert_nod:

; 492  :         } else if (_Wherenode == _Wherenode->_Parent->_Right) {

  00113	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00116	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00119	75 0b		 jne	 SHORT $LN30@Insert_nod

; 493  :             _Wherenode->_Parent->_Right = _Pnode;

  0011b	89 70 08	 mov	 DWORD PTR [eax+8], esi

; 496  :         }
; 497  : 
; 498  :         _Pnode->_Right      = _Wherenode;

  0011e	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 688  :                 }
; 689  :             } else { // fixup red-red in right subtree

  00121	e9 b9 00 00 00	 jmp	 $LN52@Insert_nod
$LN30@Insert_nod:

; 495  :             _Wherenode->_Parent->_Left = _Pnode;

  00126	89 30		 mov	 DWORD PTR [eax], esi

; 496  :         }
; 497  : 
; 498  :         _Pnode->_Right      = _Wherenode;

  00128	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 688  :                 }
; 689  :             } else { // fixup red-red in right subtree

  0012b	e9 af 00 00 00	 jmp	 $LN52@Insert_nod
$LN10@Insert_nod:

; 690  :                 const auto _Parent_sibling = _Pnode->_Parent->_Parent->_Left;
; 691  :                 if (_Parent_sibling->_Color == _Red) { // parent's sibling has two red children, blacken both

  00130	80 78 0c 00	 cmp	 BYTE PTR [eax+12], 0
  00134	75 1b		 jne	 SHORT $LN15@Insert_nod
$LN53@Insert_nod:

; 668  :             }
; 669  :         }
; 670  : 
; 671  :         for (_Nodeptr _Pnode = _Newnode; _Pnode->_Parent->_Color == _Red;) {

  00136	c6 41 0c 01	 mov	 BYTE PTR [ecx+12], 1
  0013a	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1
  0013e	8b 07		 mov	 eax, DWORD PTR [edi]
  00140	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00143	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0
  00147	8b 07		 mov	 eax, DWORD PTR [edi]
  00149	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0014c	e9 91 00 00 00	 jmp	 $LN46@Insert_nod
$LN15@Insert_nod:

; 692  :                     _Pnode->_Parent->_Color          = _Black;
; 693  :                     _Parent_sibling->_Color          = _Black;
; 694  :                     _Pnode->_Parent->_Parent->_Color = _Red;
; 695  :                     _Pnode                           = _Pnode->_Parent->_Parent;
; 696  :                 } else { // parent's sibling has red and black children
; 697  :                     if (_Pnode == _Pnode->_Parent->_Left) { // rotate left child to right

  00151	8b 01		 mov	 eax, DWORD PTR [ecx]
  00153	3b d0		 cmp	 edx, eax
  00155	75 3e		 jne	 SHORT $LN39@Insert_nod

; 698  :                         _Pnode = _Pnode->_Parent;

  00157	8b d1		 mov	 edx, ecx

; 481  :         _Nodeptr _Pnode   = _Wherenode->_Left;

  00159	8b c8		 mov	 ecx, eax

; 482  :         _Wherenode->_Left = _Pnode->_Right;

  0015b	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0015e	89 02		 mov	 DWORD PTR [edx], eax

; 483  : 
; 484  :         if (!_Pnode->_Right->_Isnil) {

  00160	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00163	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00167	75 03		 jne	 SHORT $LN34@Insert_nod

; 485  :             _Pnode->_Right->_Parent = _Wherenode;

  00169	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN34@Insert_nod:

; 486  :         }
; 487  : 
; 488  :         _Pnode->_Parent = _Wherenode->_Parent;

  0016c	8b 03		 mov	 eax, DWORD PTR [ebx]
  0016e	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 489  : 
; 490  :         if (_Wherenode == _Myhead->_Parent) {

  00171	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]
  00174	8b 00		 mov	 eax, DWORD PTR [eax]
  00176	3b 50 04	 cmp	 edx, DWORD PTR [eax+4]
  00179	75 05		 jne	 SHORT $LN35@Insert_nod

; 491  :             _Myhead->_Parent = _Pnode;

  0017b	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0017e	eb 0e		 jmp	 SHORT $LN38@Insert_nod
$LN35@Insert_nod:

; 492  :         } else if (_Wherenode == _Wherenode->_Parent->_Right) {

  00180	8b 03		 mov	 eax, DWORD PTR [ebx]
  00182	3b 50 08	 cmp	 edx, DWORD PTR [eax+8]
  00185	75 05		 jne	 SHORT $LN37@Insert_nod

; 493  :             _Wherenode->_Parent->_Right = _Pnode;

  00187	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 494  :         } else {

  0018a	eb 02		 jmp	 SHORT $LN38@Insert_nod
$LN37@Insert_nod:

; 495  :             _Wherenode->_Parent->_Left = _Pnode;

  0018c	89 08		 mov	 DWORD PTR [eax], ecx
$LN38@Insert_nod:

; 496  :         }
; 497  : 
; 498  :         _Pnode->_Right      = _Wherenode;

  0018e	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 499  :         _Wherenode->_Parent = _Pnode;

  00191	8b fb		 mov	 edi, ebx
  00193	89 0b		 mov	 DWORD PTR [ebx], ecx
$LN39@Insert_nod:

; 699  :                         _Rrotate(_Pnode);
; 700  :                     }
; 701  : 
; 702  :                     _Pnode->_Parent->_Color          = _Black; // propagate red up

  00195	c6 41 0c 01	 mov	 BYTE PTR [ecx+12], 1

; 703  :                     _Pnode->_Parent->_Parent->_Color = _Red;

  00199	8b 07		 mov	 eax, DWORD PTR [edi]
  0019b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0019e	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 704  :                     _Lrotate(_Pnode->_Parent->_Parent);

  001a2	8b 07		 mov	 eax, DWORD PTR [edi]
  001a4	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 459  :         _Nodeptr _Pnode    = _Wherenode->_Right;

  001a7	8b 71 08	 mov	 esi, DWORD PTR [ecx+8]

; 460  :         _Wherenode->_Right = _Pnode->_Left;

  001aa	8b 06		 mov	 eax, DWORD PTR [esi]
  001ac	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 461  : 
; 462  :         if (!_Pnode->_Left->_Isnil) {

  001af	8b 06		 mov	 eax, DWORD PTR [esi]
  001b1	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  001b5	75 03		 jne	 SHORT $LN41@Insert_nod

; 463  :             _Pnode->_Left->_Parent = _Wherenode;

  001b7	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN41@Insert_nod:

; 464  :         }
; 465  : 
; 466  :         _Pnode->_Parent = _Wherenode->_Parent;

  001ba	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  001bd	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 467  : 
; 468  :         if (_Wherenode == _Myhead->_Parent) {

  001c0	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]
  001c3	8b 00		 mov	 eax, DWORD PTR [eax]
  001c5	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  001c8	75 05		 jne	 SHORT $LN42@Insert_nod

; 469  :             _Myhead->_Parent = _Pnode;

  001ca	89 70 04	 mov	 DWORD PTR [eax+4], esi
  001cd	eb 0e		 jmp	 SHORT $LN45@Insert_nod
$LN42@Insert_nod:

; 470  :         } else if (_Wherenode == _Wherenode->_Parent->_Left) {

  001cf	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  001d2	3b 08		 cmp	 ecx, DWORD PTR [eax]
  001d4	75 04		 jne	 SHORT $LN44@Insert_nod

; 471  :             _Wherenode->_Parent->_Left = _Pnode;

  001d6	89 30		 mov	 DWORD PTR [eax], esi

; 472  :         } else {

  001d8	eb 03		 jmp	 SHORT $LN45@Insert_nod
$LN44@Insert_nod:

; 473  :             _Wherenode->_Parent->_Right = _Pnode;

  001da	89 70 08	 mov	 DWORD PTR [eax+8], esi
$LN45@Insert_nod:

; 474  :         }
; 475  : 
; 476  :         _Pnode->_Left       = _Wherenode;

  001dd	89 0e		 mov	 DWORD PTR [esi], ecx
$LN52@Insert_nod:

; 668  :             }
; 669  :         }
; 670  : 
; 671  :         for (_Nodeptr _Pnode = _Newnode; _Pnode->_Parent->_Color == _Red;) {

  001df	89 71 04	 mov	 DWORD PTR [ecx+4], esi
$LN46@Insert_nod:
  001e2	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  001e5	80 78 0c 00	 cmp	 BYTE PTR [eax+12], 0
  001e9	0f 84 71 fe ff
	ff		 je	 $LL2@Insert_nod
  001ef	8b 4d f8	 mov	 ecx, DWORD PTR __Head$1$[ebp]
  001f2	5f		 pop	 edi
  001f3	5e		 pop	 esi
  001f4	5b		 pop	 ebx
$LN3@Insert_nod:

; 705  :                 }
; 706  :             }
; 707  :         }
; 708  : 
; 709  :         _Head->_Parent->_Color = _Black; // root is always black

  001f5	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  001f8	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 710  :         return _Newnode;

  001fc	8b 45 10	 mov	 eax, DWORD PTR __Newnode$[ebp]

; 711  :     }

  001ff	8b e5		 mov	 esp, ebp
  00201	5d		 pop	 ebp
  00202	c2 0c 00	 ret	 12			; 0000000cH
?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@PAX@std@@@2@QAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,CXScaleManagerImp::VERTBOX_INFO *> > >::_Insert_node
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?GetRQIndexFromString@CXScaleManagerImp@@MAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
_TEXT	SEGMENT
__Loc$2 = -52						; size = 12
_stringRQ$ = -40					; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_strRQ$ = 8						; size = 4
?GetRQIndexFromString@CXScaleManagerImp@@MAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z PROC ; CXScaleManagerImp::GetRQIndexFromString, COMDAT
; _this$ = ecx

; 1478 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?GetRQIndexFromString@CXScaleManagerImp@@MAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 28	 sub	 esp, 40			; 00000028H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b f9		 mov	 edi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 404  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  0002d	8b 45 08	 mov	 eax, DWORD PTR _strRQ$[ebp]
  00030	8b d0		 mov	 edx, eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 1478 : {

  00032	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2313 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00039	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _stringRQ$[ebp], 0

; 4562 :         _My_data._Mysize = 0;

  00040	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _stringRQ$[ebp+16], 0

; 4563 : 
; 4564 : #ifdef __cpp_lib_constexpr_string
; 4565 :         if (_STD is_constant_evaluated()) {
; 4566 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4567 :             auto& _Al              = _Getal();
; 4568 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4569 :             _My_data._Bx._Ptr      = _New_ptr;
; 4570 : 
; 4571 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4572 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4573 :         } else
; 4574 : #endif // __cpp_lib_constexpr_string
; 4575 :         {
; 4576 :             _My_data._Myres = _BUF_SIZE - 1;

  00047	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR _stringRQ$[ebp+20], 15 ; 0000000fH

; 404  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  0004e	8d 72 01	 lea	 esi, DWORD PTR [edx+1]
$LL114@GetRQIndex:
  00051	8a 0a		 mov	 cl, BYTE PTR [edx]
  00053	42		 inc	 edx
  00054	84 c9		 test	 cl, cl
  00056	75 f9		 jne	 SHORT $LL114@GetRQIndex
  00058	2b d6		 sub	 edx, esi

; 3230 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0005a	8d 4d d8	 lea	 ecx, DWORD PTR _stringRQ$[ebp]
  0005d	52		 push	 edx
  0005e	50		 push	 eax
  0005f	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1353 :         const _Tree_find_result<_Nodeptr> _Loc = _Find_lower_bound(_Keyval);

  00064	8d 45 d8	 lea	 eax, DWORD PTR _stringRQ$[ebp]
  00067	50		 push	 eax
  00068	8d 45 cc	 lea	 eax, DWORD PTR __Loc$2[ebp]
  0006b	50		 push	 eax
  0006c	8d 4f 70	 lea	 ecx, DWORD PTR [edi+112]
  0006f	e8 00 00 00 00	 call	 ??$_Find_lower_bound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Find_lower_bound<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >

; 1591 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  00074	8b 75 d4	 mov	 esi, DWORD PTR __Loc$2[ebp+8]
  00077	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  0007b	75 1e		 jne	 SHORT $LN2@GetRQIndex
  0007d	8d 46 10	 lea	 eax, DWORD PTR [esi+16]
  00080	50		 push	 eax
  00081	8d 45 d8	 lea	 eax, DWORD PTR _stringRQ$[ebp]
  00084	50		 push	 eax
  00085	8d 4f 70	 lea	 ecx, DWORD PTR [edi+112]
  00088	e8 00 00 00 00	 call	 ??R?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0@Z ; std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator()
  0008d	84 c0		 test	 al, al
  0008f	75 0a		 jne	 SHORT $LN2@GetRQIndex

; 38   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  00091	3b 77 70	 cmp	 esi, DWORD PTR [edi+112]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 1482 : 	if( it != m_midxRQ.end()) return it->second;

  00094	74 05		 je	 SHORT $LN2@GetRQIndex
  00096	8b 76 28	 mov	 esi, DWORD PTR [esi+40]
  00099	eb 03		 jmp	 SHORT $LN6@GetRQIndex
$LN2@GetRQIndex:

; 1484 : 	return -1;

  0009b	83 ce ff	 or	 esi, -1
$LN6@GetRQIndex:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2286 :         return _BUF_SIZE <= _Myres;

  0009e	8b 55 ec	 mov	 edx, DWORD PTR _stringRQ$[ebp+20]
  000a1	83 fa 10	 cmp	 edx, 16			; 00000010H

; 4584 :         if (_Mypair._Myval2._Large_string_engaged()) {

  000a4	72 2e		 jb	 SHORT $LN98@GetRQIndex
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000a6	8b 4d d8	 mov	 ecx, DWORD PTR _stringRQ$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4588 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  000a9	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000aa	8b c1		 mov	 eax, ecx

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  000ac	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  000b2	72 16		 jb	 SHORT $LN108@GetRQIndex

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000b4	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  000b7	83 c2 23	 add	 edx, 35			; 00000023H
  000ba	2b c1		 sub	 eax, ecx

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000bc	83 c0 fc	 add	 eax, -4			; fffffffcH
  000bf	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  000c2	76 06		 jbe	 SHORT $LN108@GetRQIndex
  000c4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN108@GetRQIndex:

; 255  :         ::operator delete(_Ptr, _Bytes);

  000ca	52		 push	 edx
  000cb	51		 push	 ecx
  000cc	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  000d1	83 c4 08	 add	 esp, 8
$LN98@GetRQIndex:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 1484 : 	return -1;

  000d4	8d 4d 08	 lea	 ecx, DWORD PTR _strRQ$[ebp]
  000d7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  000dd	8b c6		 mov	 eax, esi

; 1485 : }

  000df	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000e2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000e9	59		 pop	 ecx
  000ea	5f		 pop	 edi
  000eb	5e		 pop	 esi
  000ec	5b		 pop	 ebx
  000ed	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000f0	33 cd		 xor	 ecx, ebp
  000f2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000f7	8b e5		 mov	 esp, ebp
  000f9	5d		 pop	 ebp
  000fa	c2 04 00	 ret	 4
$LN116@GetRQIndex:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetRQIndexFromString@CXScaleManagerImp@@MAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z$0:
  00000	8d 4d 08	 lea	 ecx, DWORD PTR _strRQ$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
  0000d	cc		 int	 3
__ehhandler$?GetRQIndexFromString@CXScaleManagerImp@@MAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z:
  0000e	90		 npad	 1
  0000f	90		 npad	 1
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a c8	 mov	 ecx, DWORD PTR [edx-56]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00024	33 c8		 xor	 ecx, eax
  00026	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?GetRQIndexFromString@CXScaleManagerImp@@MAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
  00030	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?GetRQIndexFromString@CXScaleManagerImp@@MAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ENDP ; CXScaleManagerImp::GetRQIndexFromString
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\Dll_Load\XScaleManager.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?GetVerticalBoxInfo@CXScaleManagerImp@@UAEXPBD0AAVCRect@@AAKAAH@Z
_TEXT	SEGMENT
_bFill$GSCopy$1$ = -60					; size = 4
_clrColor$GSCopy$1$ = -56				; size = 4
_rcBox$GSCopy$1$ = -52					; size = 4
_lpszPacketName$GSCopy$1$ = -48				; size = 4
__Loc$1 = -44						; size = 12
_area$2 = -40						; size = 6
_this$GSCopy$1$ = -32					; size = 4
$T3 = -28						; size = 24
__$ArrayPad$ = -4					; size = 4
_lpszRQ$ = 8						; size = 4
_lpszPacketName$ = 12					; size = 4
_rcBox$ = 16						; size = 4
_clrColor$ = 20						; size = 4
_bFill$ = 24						; size = 4
?GetVerticalBoxInfo@CXScaleManagerImp@@UAEXPBD0AAVCRect@@AAKAAH@Z PROC ; CXScaleManagerImp::GetVerticalBoxInfo, COMDAT
; _this$ = ecx

; 4013 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 0c	 mov	 eax, DWORD PTR _lpszPacketName$[ebp]
  00013	53		 push	 ebx
  00014	8b 5d 08	 mov	 ebx, DWORD PTR _lpszRQ$[ebp]
  00017	56		 push	 esi
  00018	89 45 d0	 mov	 DWORD PTR _lpszPacketName$GSCopy$1$[ebp], eax
  0001b	8b f1		 mov	 esi, ecx
  0001d	8b 45 10	 mov	 eax, DWORD PTR _rcBox$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 404  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00020	8b cb		 mov	 ecx, ebx
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 4013 : {

  00022	89 45 cc	 mov	 DWORD PTR _rcBox$GSCopy$1$[ebp], eax
  00025	8b 45 14	 mov	 eax, DWORD PTR _clrColor$[ebp]
  00028	89 45 c8	 mov	 DWORD PTR _clrColor$GSCopy$1$[ebp], eax
  0002b	8b 45 18	 mov	 eax, DWORD PTR _bFill$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 404  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  0002e	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 4013 : {

  00031	57		 push	 edi
  00032	89 75 e0	 mov	 DWORD PTR _this$GSCopy$1$[ebp], esi
  00035	89 45 c4	 mov	 DWORD PTR _bFill$GSCopy$1$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2313 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00038	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR $T3[ebp], 0

; 4562 :         _My_data._Mysize = 0;

  0003f	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T3[ebp+16], 0

; 4563 : 
; 4564 : #ifdef __cpp_lib_constexpr_string
; 4565 :         if (_STD is_constant_evaluated()) {
; 4566 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4567 :             auto& _Al              = _Getal();
; 4568 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4569 :             _My_data._Bx._Ptr      = _New_ptr;
; 4570 : 
; 4571 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4572 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4573 :         } else
; 4574 : #endif // __cpp_lib_constexpr_string
; 4575 :         {
; 4576 :             _My_data._Myres = _BUF_SIZE - 1;

  00046	c7 45 f8 0f 00
	00 00		 mov	 DWORD PTR $T3[ebp+20], 15 ; 0000000fH
  0004d	0f 1f 00	 npad	 3
$LL112@GetVertica:

; 404  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00050	8a 01		 mov	 al, BYTE PTR [ecx]
  00052	41		 inc	 ecx
  00053	84 c0		 test	 al, al
  00055	75 f9		 jne	 SHORT $LL112@GetVertica
  00057	2b ca		 sub	 ecx, edx

; 3230 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00059	51		 push	 ecx
  0005a	53		 push	 ebx
  0005b	8d 4d e4	 lea	 ecx, DWORD PTR $T3[ebp]
  0005e	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1353 :         const _Tree_find_result<_Nodeptr> _Loc = _Find_lower_bound(_Keyval);

  00063	8d 45 e4	 lea	 eax, DWORD PTR $T3[ebp]
  00066	50		 push	 eax
  00067	8d 45 d4	 lea	 eax, DWORD PTR __Loc$1[ebp]
  0006a	50		 push	 eax
  0006b	8d 8e 94 00 00
	00		 lea	 ecx, DWORD PTR [esi+148]
  00071	e8 00 00 00 00	 call	 ??$_Find_lower_bound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@PAX@std@@@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,CXScaleManagerImp::VERTBOX_INFO *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,CXScaleManagerImp::VERTBOX_INFO *> >,0> >::_Find_lower_bound<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >

; 1591 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  00076	8b 7d dc	 mov	 edi, DWORD PTR __Loc$1[ebp+8]
  00079	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  0007d	75 17		 jne	 SHORT $LN33@GetVertica
  0007f	8d 47 10	 lea	 eax, DWORD PTR [edi+16]
  00082	50		 push	 eax
  00083	8d 45 e4	 lea	 eax, DWORD PTR $T3[ebp]
  00086	50		 push	 eax
  00087	8d 8e 94 00 00
	00		 lea	 ecx, DWORD PTR [esi+148]
  0008d	e8 00 00 00 00	 call	 ??R?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0@Z ; std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator()
  00092	84 c0		 test	 al, al
  00094	74 06		 je	 SHORT $LN32@GetVertica
$LN33@GetVertica:

; 1358 :         return _Get_scary()->_Myhead;

  00096	8b be 94 00 00
	00		 mov	 edi, DWORD PTR [esi+148]
$LN32@GetVertica:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4584 :         if (_Mypair._Myval2._Large_string_engaged()) {

  0009c	8b 55 f8	 mov	 edx, DWORD PTR $T3[ebp+20]
  0009f	83 fa 10	 cmp	 edx, 16			; 00000010H
  000a2	72 2e		 jb	 SHORT $LN57@GetVertica
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000a4	8b 4d e4	 mov	 ecx, DWORD PTR $T3[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4588 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  000a7	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000a8	8b c1		 mov	 eax, ecx

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  000aa	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  000b0	72 16		 jb	 SHORT $LN67@GetVertica

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000b2	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  000b5	83 c2 23	 add	 edx, 35			; 00000023H
  000b8	2b c1		 sub	 eax, ecx

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000ba	83 c0 fc	 add	 eax, -4			; fffffffcH
  000bd	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  000c0	76 06		 jbe	 SHORT $LN67@GetVertica
  000c2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN67@GetVertica:

; 255  :         ::operator delete(_Ptr, _Bytes);

  000c8	52		 push	 edx
  000c9	51		 push	 ecx
  000ca	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  000cf	83 c4 08	 add	 esp, 8
$LN57@GetVertica:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 4015 : 	if(itVertBox != m_mifVertBox.end())

  000d2	3b be 94 00 00
	00		 cmp	 edi, DWORD PTR [esi+148]
  000d8	0f 84 b3 00 00
	00		 je	 $LN4@GetVertica

; 4016 : 	{
; 4017 : 		CPacketList* pPacketList = m_ppacketListManager->GetPacketList(lpszRQ);

  000de	8b ce		 mov	 ecx, esi
  000e0	53		 push	 ebx
  000e1	8b 49 48	 mov	 ecx, DWORD PTR [ecx+72]
  000e4	8b 01		 mov	 eax, DWORD PTR [ecx]
  000e6	ff 50 1c	 call	 DWORD PTR [eax+28]

; 4018 : 		CPacket* pPacket = pPacketList->GetBaseData(lpszPacketName);

  000e9	6a 01		 push	 1
  000eb	51		 push	 ecx
  000ec	8b cc		 mov	 ecx, esp
  000ee	8b f0		 mov	 esi, eax
  000f0	ff 75 d0	 push	 DWORD PTR _lpszPacketName$GSCopy$1$[ebp]
  000f3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  000f9	8b ce		 mov	 ecx, esi
  000fb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetBaseData@CPacketList@@QAEPAVCPacket@@V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@_N@Z

; 4019 : 		if(!pPacket)

  00101	85 c0		 test	 eax, eax
  00103	0f 84 88 00 00
	00		 je	 $LN4@GetVertica

; 4020 : 			return;
; 4021 : 
; 4022 : 		CList<double, double>* pDataList = pPacket->GetnumericDataList();

  00109	8b c8		 mov	 ecx, eax
  0010b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetnumericDataList@CPacket@@QAEPAV?$CList@NN@@XZ

; 4023 : 		if( !pDataList) return;

  00111	85 c0		 test	 eax, eax
  00113	74 7c		 je	 SHORT $LN4@GetVertica

; 4024 : 
; 4025 : 		POSITION pos = pDataList->GetHeadPosition();

  00115	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 4026 : 		int nDTI = -1;

  00118	83 ca ff	 or	 edx, -1

; 4027 : 		while(pos)

  0011b	85 c9		 test	 ecx, ecx
  0011d	74 72		 je	 SHORT $LN4@GetVertica
  0011f	8b 47 28	 mov	 eax, DWORD PTR [edi+40]
  00122	f2 0f 10 08	 movsd	 xmm1, QWORD PTR [eax]
$LL2@GetVertica:

; 4030 : 			if(pDataList->GetNext(pos) == itVertBox->second->dHorzValue)

  00126	f2 0f 10 41 08	 movsd	 xmm0, QWORD PTR [ecx+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 811  : 	{ CNode* pNode = (CNode*) rPosition;

  0012b	8d 01		 lea	 eax, DWORD PTR [ecx]

; 812  : 		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 813  : 		rPosition = (POSITION) pNode->pNext;

  0012d	8b 09		 mov	 ecx, DWORD PTR [ecx]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 4029 : 			nDTI++;

  0012f	42		 inc	 edx

; 4030 : 			if(pDataList->GetNext(pos) == itVertBox->second->dHorzValue)

  00130	66 0f 2e c1	 ucomisd xmm0, xmm1
  00134	9f		 lahf
  00135	f6 c4 44	 test	 ah, 68			; 00000044H
  00138	7b 04		 jnp	 SHORT $LN108@GetVertica

; 4027 : 		while(pos)

  0013a	85 c9		 test	 ecx, ecx
  0013c	75 e8		 jne	 SHORT $LL2@GetVertica
$LN108@GetVertica:

; 4031 : 				break;
; 4032 : 		}
; 4033 : 
; 4034 : 		if(nDTI < 0)

  0013e	85 d2		 test	 edx, edx
  00140	78 4f		 js	 SHORT $LN4@GetVertica
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\Dll_Load\XScaleManager.h

; 67   : 			left = center = right = 0;

  00142	33 c0		 xor	 eax, eax
  00144	89 45 da	 mov	 DWORD PTR _area$2[ebp+2], eax
  00147	66 89 45 d8	 mov	 WORD PTR _area$2[ebp], ax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 4038 : 		if(!GetAREAfRQnDTI(lpszRQ, nDTI, 0, &area))

  0014b	8d 45 d8	 lea	 eax, DWORD PTR _area$2[ebp]
  0014e	50		 push	 eax
  0014f	6a 00		 push	 0
  00151	52		 push	 edx
  00152	51		 push	 ecx
  00153	8b cc		 mov	 ecx, esp
  00155	53		 push	 ebx
  00156	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  0015c	8b 4d e0	 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  0015f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00161	ff 90 d0 00 00
	00		 call	 DWORD PTR [eax+208]
  00167	85 c0		 test	 eax, eax
  00169	74 26		 je	 SHORT $LN4@GetVertica

; 4039 : 			return;
; 4040 : 		
; 4041 : 		rcBox.left = area.left;

  0016b	8b 4d cc	 mov	 ecx, DWORD PTR _rcBox$GSCopy$1$[ebp]
  0016e	0f bf 45 d8	 movsx	 eax, WORD PTR _area$2[ebp]
  00172	89 01		 mov	 DWORD PTR [ecx], eax

; 4042 : 		rcBox.right = area.right;

  00174	0f bf 45 dc	 movsx	 eax, WORD PTR _area$2[ebp+4]
  00178	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 4043 : 		
; 4044 : 		clrColor = itVertBox->second->clrColor;

  0017b	8b 47 28	 mov	 eax, DWORD PTR [edi+40]
  0017e	8b 4d c8	 mov	 ecx, DWORD PTR _clrColor$GSCopy$1$[ebp]
  00181	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00184	89 01		 mov	 DWORD PTR [ecx], eax

; 4045 : 		bFill = itVertBox->second->bFill;

  00186	8b 47 28	 mov	 eax, DWORD PTR [edi+40]
  00189	8b 4d c4	 mov	 ecx, DWORD PTR _bFill$GSCopy$1$[ebp]
  0018c	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0018f	89 01		 mov	 DWORD PTR [ecx], eax
$LN4@GetVertica:

; 4046 : 	}
; 4047 : }

  00191	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00194	5f		 pop	 edi
  00195	5e		 pop	 esi
  00196	33 cd		 xor	 ecx, ebp
  00198	5b		 pop	 ebx
  00199	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0019e	8b e5		 mov	 esp, ebp
  001a0	5d		 pop	 ebp
  001a1	c2 14 00	 ret	 20			; 00000014H
$LN113@GetVertica:
?GetVerticalBoxInfo@CXScaleManagerImp@@UAEXPBD0AAVCRect@@AAKAAH@Z ENDP ; CXScaleManagerImp::GetVerticalBoxInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?AddVerticalBoxInfo@CXScaleManagerImp@@UAEXPBDNKH@Z
_TEXT	SEGMENT
__Loc$2 = -72						; size = 12
__Loc$3 = -72						; size = 12
_pMapVerBox$1$ = -60					; size = 4
$T4 = -56						; size = 12
$T5 = -52						; size = 8
_lpszRQ$GSCopy$1$ = -48					; size = 4
tv1365 = -48						; size = 4
$T6 = -44						; size = 28
$T7 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_lpszRQ$ = 8						; size = 4
_dHorzValue$ = 12					; size = 8
_clrColor$ = 20						; size = 4
_bFill$ = 24						; size = 4
?AddVerticalBoxInfo@CXScaleManagerImp@@UAEXPBDNKH@Z PROC ; CXScaleManagerImp::AddVerticalBoxInfo, COMDAT
; _this$ = ecx

; 3991 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?AddVerticalBoxInfo@CXScaleManagerImp@@UAEXPBDNKH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	56		 push	 esi
  0001f	57		 push	 edi
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	8b f9		 mov	 edi, ecx
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _lpszRQ$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 404  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  0002f	8b d1		 mov	 edx, ecx
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 3991 : {

  00031	89 4d d0	 mov	 DWORD PTR _lpszRQ$GSCopy$1$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2313 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00034	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR $T7[ebp], 0

; 4562 :         _My_data._Mysize = 0;

  0003b	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T7[ebp+16], 0

; 4563 : 
; 4564 : #ifdef __cpp_lib_constexpr_string
; 4565 :         if (_STD is_constant_evaluated()) {
; 4566 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4567 :             auto& _Al              = _Getal();
; 4568 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4569 :             _My_data._Bx._Ptr      = _New_ptr;
; 4570 : 
; 4571 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4572 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4573 :         } else
; 4574 : #endif // __cpp_lib_constexpr_string
; 4575 :         {
; 4576 :             _My_data._Myres = _BUF_SIZE - 1;

  00042	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T7[ebp+20], 15 ; 0000000fH

; 404  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00049	8d 72 01	 lea	 esi, DWORD PTR [edx+1]
  0004c	0f 1f 40 00	 npad	 4
$LL282@AddVertica:
  00050	8a 02		 mov	 al, BYTE PTR [edx]
  00052	42		 inc	 edx
  00053	84 c0		 test	 al, al
  00055	75 f9		 jne	 SHORT $LL282@AddVertica
  00057	2b d6		 sub	 edx, esi

; 3230 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00059	52		 push	 edx
  0005a	51		 push	 ecx
  0005b	8d 4d d8	 lea	 ecx, DWORD PTR $T7[ebp]
  0005e	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1353 :         const _Tree_find_result<_Nodeptr> _Loc = _Find_lower_bound(_Keyval);

  00063	8d 45 d8	 lea	 eax, DWORD PTR $T7[ebp]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 3992 : 	MAP_RQ_VERTBOX::iterator it = m_mifVertBox.find(lpszRQ);

  00066	81 c7 94 00 00
	00		 add	 edi, 148		; 00000094H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1353 :         const _Tree_find_result<_Nodeptr> _Loc = _Find_lower_bound(_Keyval);

  0006c	50		 push	 eax
  0006d	8d 45 b8	 lea	 eax, DWORD PTR __Loc$3[ebp]
  00070	8b cf		 mov	 ecx, edi
  00072	50		 push	 eax
  00073	e8 00 00 00 00	 call	 ??$_Find_lower_bound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@PAX@std@@@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,CXScaleManagerImp::VERTBOX_INFO *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,CXScaleManagerImp::VERTBOX_INFO *> >,0> >::_Find_lower_bound<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >

; 1591 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  00078	8b 75 c0	 mov	 esi, DWORD PTR __Loc$3[ebp+8]
  0007b	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  0007f	75 13		 jne	 SHORT $LN26@AddVertica
  00081	8d 46 10	 lea	 eax, DWORD PTR [esi+16]
  00084	8b cf		 mov	 ecx, edi
  00086	50		 push	 eax
  00087	8d 45 d8	 lea	 eax, DWORD PTR $T7[ebp]
  0008a	50		 push	 eax
  0008b	e8 00 00 00 00	 call	 ??R?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0@Z ; std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator()
  00090	84 c0		 test	 al, al
  00092	74 02		 je	 SHORT $LN25@AddVertica
$LN26@AddVertica:

; 1358 :         return _Get_scary()->_Myhead;

  00094	8b 37		 mov	 esi, DWORD PTR [edi]
$LN25@AddVertica:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4584 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00096	8b 55 ec	 mov	 edx, DWORD PTR $T7[ebp+20]
  00099	83 fa 10	 cmp	 edx, 16			; 00000010H
  0009c	72 2c		 jb	 SHORT $LN50@AddVertica
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0009e	8b 4d d8	 mov	 ecx, DWORD PTR $T7[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4588 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  000a1	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000a2	8b c1		 mov	 eax, ecx

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  000a4	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  000aa	72 14		 jb	 SHORT $LN60@AddVertica

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000ac	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  000af	83 c2 23	 add	 edx, 35			; 00000023H
  000b2	2b c1		 sub	 eax, ecx

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000b4	83 c0 fc	 add	 eax, -4			; fffffffcH
  000b7	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  000ba	0f 87 fc 00 00
	00		 ja	 $LN270@AddVertica
$LN60@AddVertica:

; 255  :         ::operator delete(_Ptr, _Bytes);

  000c0	52		 push	 edx
  000c1	51		 push	 ecx
  000c2	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  000c7	83 c4 08	 add	 esp, 8
$LN50@AddVertica:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 3993 : 	if(it != m_mifVertBox.end())

  000ca	3b 37		 cmp	 esi, DWORD PTR [edi]
  000cc	74 23		 je	 SHORT $LN2@AddVertica

; 3994 : 	{
; 3995 : 		it->second->dHorzValue = dHorzValue;

  000ce	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  000d1	f2 0f 10 45 0c	 movsd	 xmm0, QWORD PTR _dHorzValue$[ebp]
  000d6	f2 0f 11 00	 movsd	 QWORD PTR [eax], xmm0

; 3996 : 		it->second->clrColor = clrColor;

  000da	8b 4e 28	 mov	 ecx, DWORD PTR [esi+40]
  000dd	8b 45 14	 mov	 eax, DWORD PTR _clrColor$[ebp]
  000e0	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 3997 : 		it->second->bFill = bFill;

  000e3	8b 4e 28	 mov	 ecx, DWORD PTR [esi+40]
  000e6	8b 45 18	 mov	 eax, DWORD PTR _bFill$[ebp]
  000e9	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 3998 : 	}

  000ec	e9 42 01 00 00	 jmp	 $LN263@AddVertica
$LN2@AddVertica:

; 4001 : 		VERTBOX_INFO* pMapVerBox = new VERTBOX_INFO;

  000f1	6a 10		 push	 16			; 00000010H
  000f3	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 4004 : 		pMapVerBox->clrColor = clrColor;

  000f8	8b 4d 14	 mov	 ecx, DWORD PTR _clrColor$[ebp]
  000fb	8b f0		 mov	 esi, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 404  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  000fd	8b 55 d0	 mov	 edx, DWORD PTR _lpszRQ$GSCopy$1$[ebp]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 4001 : 		VERTBOX_INFO* pMapVerBox = new VERTBOX_INFO;

  00100	83 c4 04	 add	 esp, 4

; 4002 : 
; 4003 : 		pMapVerBox->dHorzValue = dHorzValue;

  00103	f2 0f 10 45 0c	 movsd	 xmm0, QWORD PTR _dHorzValue$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2313 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00108	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T6[ebp], 0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 4004 : 		pMapVerBox->clrColor = clrColor;

  0010f	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 4005 : 		pMapVerBox->bFill = bFill;

  00112	8b 4d 18	 mov	 ecx, DWORD PTR _bFill$[ebp]
  00115	89 4e 0c	 mov	 DWORD PTR [esi+12], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 404  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00118	8b ca		 mov	 ecx, edx
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 4001 : 		VERTBOX_INFO* pMapVerBox = new VERTBOX_INFO;

  0011a	89 75 c4	 mov	 DWORD PTR _pMapVerBox$1$[ebp], esi

; 4002 : 
; 4003 : 		pMapVerBox->dHorzValue = dHorzValue;

  0011d	f2 0f 11 06	 movsd	 QWORD PTR [esi], xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4562 :         _My_data._Mysize = 0;

  00121	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR $T6[ebp+16], 0

; 404  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00128	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]

; 4576 :             _My_data._Myres = _BUF_SIZE - 1;

  0012b	c7 45 e8 0f 00
	00 00		 mov	 DWORD PTR $T6[ebp+20], 15 ; 0000000fH

; 4577 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4578 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00132	c6 45 d4 00	 mov	 BYTE PTR $T6[ebp], 0

; 404  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00136	89 45 d0	 mov	 DWORD PTR tv1365[ebp], eax
  00139	0f 1f 80 00 00
	00 00		 npad	 7
$LL283@AddVertica:
  00140	8a 01		 mov	 al, BYTE PTR [ecx]
  00142	41		 inc	 ecx
  00143	84 c0		 test	 al, al
  00145	75 f9		 jne	 SHORT $LL283@AddVertica
  00147	2b 4d d0	 sub	 ecx, DWORD PTR tv1365[ebp]

; 3230 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0014a	51		 push	 ecx
  0014b	52		 push	 edx
  0014c	8d 4d d4	 lea	 ecx, DWORD PTR $T6[ebp]
  0014f	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 186  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00154	89 75 ec	 mov	 DWORD PTR $T6[ebp+24], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1006 :             _Loc                = _Find_lower_bound(_Keyval);

  00157	8d 45 d4	 lea	 eax, DWORD PTR $T6[ebp]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 4007 : 		m_mifVertBox.insert(PAIR_RQ_VERTBOX(lpszRQ, pMapVerBox));

  0015a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1006 :             _Loc                = _Find_lower_bound(_Keyval);

  00161	50		 push	 eax
  00162	8d 45 c8	 lea	 eax, DWORD PTR $T4[ebp]
  00165	8b cf		 mov	 ecx, edi
  00167	50		 push	 eax
  00168	e8 00 00 00 00	 call	 ??$_Find_lower_bound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@PAX@std@@@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,CXScaleManagerImp::VERTBOX_INFO *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,CXScaleManagerImp::VERTBOX_INFO *> >,0> >::_Find_lower_bound<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
  0016d	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  00171	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00174	66 0f d6 45 b8	 movq	 QWORD PTR __Loc$2[ebp], xmm0

; 1591 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  00179	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0017d	75 4f		 jne	 SHORT $LN125@AddVertica
  0017f	83 c0 10	 add	 eax, 16			; 00000010H
  00182	8b cf		 mov	 ecx, edi
  00184	50		 push	 eax
  00185	8d 45 d4	 lea	 eax, DWORD PTR $T6[ebp]
  00188	50		 push	 eax
  00189	e8 00 00 00 00	 call	 ??R?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0@Z ; std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator()
  0018e	84 c0		 test	 al, al
  00190	75 3c		 jne	 SHORT $LN125@AddVertica
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2286 :         return _BUF_SIZE <= _Myres;

  00192	8b 55 e8	 mov	 edx, DWORD PTR $T6[ebp+20]
  00195	83 fa 10	 cmp	 edx, 16			; 00000010H

; 4584 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00198	0f 82 95 00 00
	00		 jb	 $LN263@AddVertica
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0019e	8b 4d d4	 mov	 ecx, DWORD PTR $T6[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4588 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  001a1	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  001a2	8b c1		 mov	 eax, ecx

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  001a4	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  001aa	72 16		 jb	 SHORT $LN273@AddVertica

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  001ac	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  001af	83 c2 23	 add	 edx, 35			; 00000023H
  001b2	2b c1		 sub	 eax, ecx

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  001b4	83 c0 fc	 add	 eax, -4			; fffffffcH
  001b7	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  001ba	76 06		 jbe	 SHORT $LN273@AddVertica
$LN270@AddVertica:
  001bc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN273@AddVertica:

; 255  :         ::operator delete(_Ptr, _Bytes);

  001c2	52		 push	 edx
  001c3	51		 push	 ecx
  001c4	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  001c9	83 c4 08	 add	 esp, 8
  001cc	eb 65		 jmp	 SHORT $LN263@AddVertica
$LN125@AddVertica:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1615 :         if (max_size() == _Get_scary()->_Mysize) {

  001ce	81 7f 04 5d 74
	d1 05		 cmp	 DWORD PTR [edi+4], 97612893 ; 05d1745dH
  001d5	74 79		 je	 SHORT $LN287@AddVertica

; 1012 :             _Inserted = _Tree_temp_node<_Alnode>(_Getal(), _Scary->_Myhead, _STD forward<_Valtys>(_Vals)...)._Release();

  001d7	8b 37		 mov	 esi, DWORD PTR [edi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 958  :     _CONSTEXPR20_DYNALLOC explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

  001d9	89 7d cc	 mov	 DWORD PTR $T5[ebp], edi

; 79   :         return ::operator new(_Bytes);

  001dc	6a 2c		 push	 44			; 0000002cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 783  :     explicit _Tree_temp_node_alloc(_Alnode& _Al_) : _Alloc_construct_ptr<_Alnode>(_Al_) {

  001de	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 965  :         _Ptr = nullptr; // if allocate throws, prevents double-free

  001e2	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR $T5[ebp+4], 0

; 79   :         return ::operator new(_Bytes);

  001e9	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2835 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  001ee	0f 10 45 d4	 movups	 xmm0, XMMWORD PTR $T6[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 242  :         : first(_STD forward<_Other1>(_Right.first)), second(_STD forward<_Other2>(_Right.second)) {}

  001f2	8b 4d c4	 mov	 ecx, DWORD PTR _pMapVerBox$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 79   :         return ::operator new(_Bytes);

  001f5	83 c4 04	 add	 esp, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2322 :     size_type _Mysize = 0; // current length of string

  001f8	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], 0

; 2323 :     size_type _Myres  = 0; // current storage reserved for string

  001ff	c7 40 24 00 00
	00 00		 mov	 DWORD PTR [eax+36], 0

; 2835 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  00206	0f 11 40 10	 movups	 XMMWORD PTR [eax+16], xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1031 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  0020a	50		 push	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2835 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  0020b	f3 0f 7e 45 e4	 movq	 xmm0, QWORD PTR $T6[ebp+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1031 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  00210	ff 75 bc	 push	 DWORD PTR __Loc$2[ebp+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2835 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  00213	66 0f d6 40 20	 movq	 QWORD PTR [eax+32], xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1031 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  00218	ff 75 b8	 push	 DWORD PTR __Loc$2[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 242  :         : first(_STD forward<_Other1>(_Right.first)), second(_STD forward<_Other2>(_Right.second)) {}

  0021b	89 48 28	 mov	 DWORD PTR [eax+40], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1031 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  0021e	8b cf		 mov	 ecx, edi

; 806  :         _Construct_in_place(this->_Ptr->_Left, _Myhead);

  00220	89 30		 mov	 DWORD PTR [eax], esi

; 807  :         _Construct_in_place(this->_Ptr->_Parent, _Myhead);

  00222	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 808  :         _Construct_in_place(this->_Ptr->_Right, _Myhead);

  00225	89 70 08	 mov	 DWORD PTR [eax+8], esi

; 809  :         this->_Ptr->_Color = _Red;

  00228	66 c7 40 0c 00
	00		 mov	 WORD PTR [eax+12], 0

; 1031 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  0022e	e8 00 00 00 00	 call	 ?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@PAX@std@@@2@QAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,CXScaleManagerImp::VERTBOX_INFO *> > >::_Insert_node
$LN263@AddVertica:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 4009 : }

  00233	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00236	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0023d	59		 pop	 ecx
  0023e	5f		 pop	 edi
  0023f	5e		 pop	 esi
  00240	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00243	33 cd		 xor	 ecx, ebp
  00245	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0024a	8b e5		 mov	 esp, ebp
  0024c	5d		 pop	 ebp
  0024d	c2 14 00	 ret	 20			; 00000014H
$LN287@AddVertica:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1616 :             _Throw_tree_length_error();

  00250	e8 00 00 00 00	 call	 ?_Throw_tree_length_error@std@@YAXXZ ; std::_Throw_tree_length_error
$LN285@AddVertica:
  00255	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AddVerticalBoxInfo@CXScaleManagerImp@@UAEXPBDNKH@Z$1:
  00000	8d 4d d4	 lea	 ecx, DWORD PTR $T6[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@QAE@XZ
__unwindfunclet$?AddVerticalBoxInfo@CXScaleManagerImp@@UAEXPBDNKH@Z$10:
  00008	8d 4d cc	 lea	 ecx, DWORD PTR $T5[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,CXScaleManagerImp::VERTBOX_INFO *>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,CXScaleManagerImp::VERTBOX_INFO *>,void *> > >
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$?AddVerticalBoxInfo@CXScaleManagerImp@@UAEXPBDNKH@Z:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0002b	33 c8		 xor	 ecx, eax
  0002d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00032	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?AddVerticalBoxInfo@CXScaleManagerImp@@UAEXPBDNKH@Z
  00037	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?AddVerticalBoxInfo@CXScaleManagerImp@@UAEXPBDNKH@Z ENDP ; CXScaleManagerImp::AddVerticalBoxInfo
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?GetThreadFlag@CXScaleManagerImp@@UAEHXZ
_TEXT	SEGMENT
?GetThreadFlag@CXScaleManagerImp@@UAEHXZ PROC		; CXScaleManagerImp::GetThreadFlag, COMDAT
; _this$ = ecx

; 2802 : 	return m_nThread_Flag;

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 2803 : }

  00003	c3		 ret	 0
?GetThreadFlag@CXScaleManagerImp@@UAEHXZ ENDP		; CXScaleManagerImp::GetThreadFlag
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?SetThreadFlag@CXScaleManagerImp@@UAEXH@Z
_TEXT	SEGMENT
_nFlag$ = 8						; size = 4
?SetThreadFlag@CXScaleManagerImp@@UAEXH@Z PROC		; CXScaleManagerImp::SetThreadFlag, COMDAT
; _this$ = ecx

; 2796 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2797 : 	m_nThread_Flag = nFlag;

  00003	8b 45 08	 mov	 eax, DWORD PTR _nFlag$[ebp]
  00006	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 2798 : }

  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?SetThreadFlag@CXScaleManagerImp@@UAEXH@Z ENDP		; CXScaleManagerImp::SetThreadFlag
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?Initialize@CXScaleManagerImp@@UAEXH@Z
_TEXT	SEGMENT
_bCalc$ = 8						; size = 4
?Initialize@CXScaleManagerImp@@UAEXH@Z PROC		; CXScaleManagerImp::Initialize, COMDAT
; _this$ = ecx

; 2774 : 	m_bReverse = FALSE;					// 

  00000	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 2775 : 	m_bWeightedVolume = FALSE;			//  

  00007	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 2776 : 	m_bUseOEBTMargin = FALSE;			//  ()

  0000e	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 2777 : 	m_nLeftDataHideCount = 0;			//   

  00015	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0

; 2778 : 	// (2009/2/8 - Seung-Won, Bae) Set initial of Fixed Interval to false. and Do not load previous user setting.
; 2779 : 	m_bFixedInterval = FALSE;			//   : xScaleManager - ojtaso (20070528)

  0001c	c7 41 24 00 00
	00 00		 mov	 DWORD PTR [ecx+36], 0

; 2780 : 	// (2009/2/11 - Seung-Won, Bae) Init Resize Type.
; 2781 : 	m_rstype = RSAT_ITEM_COUNT_FIX;		//  (ITEM)  	- [(ITEM)   ]

  00023	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0

; 2782 : }

  0002a	c2 04 00	 ret	 4
?Initialize@CXScaleManagerImp@@UAEXH@Z ENDP		; CXScaleManagerImp::Initialize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\time.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\time.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\time.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?GetTimeFromDRI@CXScaleManagerImp@@UAEXHPA_J@Z
_TEXT	SEGMENT
_nDRI$ = 8						; size = 4
_ptimeScale$ = 12					; size = 4
?GetTimeFromDRI@CXScaleManagerImp@@UAEXHPA_J@Z PROC	; CXScaleManagerImp::GetTimeFromDRI, COMDAT
; _this$ = ecx

; 1553 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi
  00004	8b f9		 mov	 edi, ecx

; 1554 : 	// 0. Check exception.
; 1555 : 	if( m_nItemCount_Total == 0)

  00006	83 7f 58 00	 cmp	 DWORD PTR [edi+88], 0
  0000a	75 15		 jne	 SHORT $LN4@GetTimeFro

; 1556 : 	{
; 1557 : 		*ptimeScale = 0;

  0000c	8b 45 0c	 mov	 eax, DWORD PTR _ptimeScale$[ebp]
  0000f	5f		 pop	 edi
  00010	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00016	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 1593 : }

  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
$LN4@GetTimeFro:
  00021	53		 push	 ebx
  00022	56		 push	 esi

; 1558 : 		return;
; 1559 : 	}
; 1560 : 
; 1561 : 	int nDRITimeCount = m_blTimefDRI.GetItemCount();

  00023	8d 8f ac 00 00
	00		 lea	 ecx, DWORD PTR [edi+172]
  00029	e8 00 00 00 00	 call	 ?GetItemCount@CDataBlockListUNK@@QAEHXZ ; CDataBlockListUNK::GetItemCount

; 1562 : 	// 1. In Range of full time line or past.
; 1563 : 	if( nDRI < 0) nDRI = 0;
; 1564 : 	if( 0 <= nDRI && nDRI < nDRITimeCount)

  0002e	8b 55 08	 mov	 edx, DWORD PTR _nDRI$[ebp]
  00031	33 f6		 xor	 esi, esi
  00033	85 d2		 test	 edx, edx
  00035	0f 49 f2	 cmovns	 esi, edx
  00038	85 f6		 test	 esi, esi
  0003a	78 2f		 js	 SHORT $LN6@GetTimeFro
  0003c	3b f0		 cmp	 esi, eax
  0003e	7d 2b		 jge	 SHORT $LN6@GetTimeFro
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 215  : 	T*	GetAt( int nIndex)	{	return ( T*)GetAtUNK( nIndex);	}

  00040	56		 push	 esi
  00041	8d 8f ac 00 00
	00		 lea	 ecx, DWORD PTR [edi+172]
  00047	e8 00 00 00 00	 call	 ?GetAtUNK@CDataBlockListUNK@@QAEPAXH@Z ; CDataBlockListUNK::GetAtUNK
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 1566 : 		m_pTReturn = m_blTimefDRI.GetAt( nDRI);

  0004c	89 47 5c	 mov	 DWORD PTR [edi+92], eax

; 1567 : 		if( m_pTReturn) *ptimeScale = *m_pTReturn;

  0004f	85 c0		 test	 eax, eax
  00051	0f 84 b3 00 00
	00		 je	 $LN28@GetTimeFro
  00057	8b 08		 mov	 ecx, DWORD PTR [eax]
  00059	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0005c	8b 45 0c	 mov	 eax, DWORD PTR _ptimeScale$[ebp]
  0005f	5e		 pop	 esi
  00060	5b		 pop	 ebx
  00061	5f		 pop	 edi
  00062	89 08		 mov	 DWORD PTR [eax], ecx
  00064	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 1593 : }

  00067	5d		 pop	 ebp
  00068	c2 08 00	 ret	 8
$LN6@GetTimeFro:

; 1568 : 		return;
; 1569 : 	}
; 1570 : 
; 1571 : 	// 2. for Future.
; 1572 : 	int nDRI_Gap = nDRI - nDRITimeCount + 1;

  0006b	2b f0		 sub	 esi, eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 215  : 	T*	GetAt( int nIndex)	{	return ( T*)GetAtUNK( nIndex);	}

  0006d	8d 8f ac 00 00
	00		 lea	 ecx, DWORD PTR [edi+172]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 1573 : 	m_pTReturn = m_blTimefDRI.GetAt( nDRITimeCount - 1);

  00073	48		 dec	 eax
  00074	46		 inc	 esi
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 215  : 	T*	GetAt( int nIndex)	{	return ( T*)GetAtUNK( nIndex);	}

  00075	50		 push	 eax
  00076	e8 00 00 00 00	 call	 ?GetAtUNK@CDataBlockListUNK@@QAEPAXH@Z ; CDataBlockListUNK::GetAtUNK
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 1574 : 	if( m_pTReturn) *ptimeScale = *m_pTReturn;

  0007b	8b 5d 0c	 mov	 ebx, DWORD PTR _ptimeScale$[ebp]
  0007e	89 47 5c	 mov	 DWORD PTR [edi+92], eax
  00081	85 c0		 test	 eax, eax
  00083	74 0a		 je	 SHORT $LN8@GetTimeFro
  00085	8b 08		 mov	 ecx, DWORD PTR [eax]
  00087	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0008a	89 0b		 mov	 DWORD PTR [ebx], ecx
  0008c	89 43 04	 mov	 DWORD PTR [ebx+4], eax
$LN8@GetTimeFro:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\time.h

; 499  :             return _localtime64(_Time);

  0008f	53		 push	 ebx
  00090	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___localtime64
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 1575 : 	tm* ptmCur = localtime( ptimeScale);

  00096	8b d0		 mov	 edx, eax
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\time.h

; 499  :             return _localtime64(_Time);

  00098	83 c4 04	 add	 esp, 4
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 1576 : 	if( !ptmCur) return;

  0009b	85 d2		 test	 edx, edx
  0009d	74 6b		 je	 SHORT $LN28@GetTimeFro

; 1577 : 	switch( m_minScaleInterval_eType)

  0009f	8b 8f f0 00 00
	00		 mov	 ecx, DWORD PTR [edi+240]
  000a5	49		 dec	 ecx
  000a6	83 f9 0b	 cmp	 ecx, 11			; 0000000bH
  000a9	77 50		 ja	 SHORT $LN2@GetTimeFro
  000ab	0f b6 89 00 00
	00 00		 movzx	 ecx, BYTE PTR $LN26@GetTimeFro[ecx]
  000b2	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN27@GetTimeFro[ecx*4]
$LN10@GetTimeFro:

; 1578 : 	{
; 1579 : 		case CScaleBaseData::HORZ_MONTHLY:		ptmCur->tm_mon	+= ( m_minScaleInterval_nUnit * nDRI_Gap);

  000b9	8b 87 f4 00 00
	00		 mov	 eax, DWORD PTR [edi+244]
  000bf	0f af c6	 imul	 eax, esi
  000c2	01 42 10	 add	 DWORD PTR [edx+16], eax

; 1580 : 												break;

  000c5	eb 34		 jmp	 SHORT $LN2@GetTimeFro
$LN11@GetTimeFro:

; 1581 : 		case CScaleBaseData::HORZ_WEEKLEY:		ptmCur->tm_mday += ( m_minScaleInterval_nUnit * 7 * nDRI_Gap);

  000c7	8b 8f f4 00 00
	00		 mov	 ecx, DWORD PTR [edi+244]
  000cd	0f af ce	 imul	 ecx, esi
  000d0	8d 04 cd 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*8]
  000d7	2b c1		 sub	 eax, ecx
  000d9	01 42 0c	 add	 DWORD PTR [edx+12], eax

; 1582 : 												break;

  000dc	eb 1d		 jmp	 SHORT $LN2@GetTimeFro
$LN12@GetTimeFro:

; 1583 : 		case CScaleBaseData::HORZ_DAILY:		ptmCur->tm_mday += ( m_minScaleInterval_nUnit * nDRI_Gap);

  000de	8b 87 f4 00 00
	00		 mov	 eax, DWORD PTR [edi+244]
  000e4	0f af c6	 imul	 eax, esi
  000e7	01 42 0c	 add	 DWORD PTR [edx+12], eax

; 1584 : 												break;

  000ea	eb 0f		 jmp	 SHORT $LN2@GetTimeFro
$LN13@GetTimeFro:

; 1585 : 		case CScaleBaseData::HORZ_TIME_ONE:
; 1586 : 		case CScaleBaseData::HORZ_TIME_TWO:
; 1587 : 		case CScaleBaseData::HORZ_TIME_SECOND:	ptmCur->tm_sec	+= ( m_minScaleInterval_nUnit * nDRI_Gap);

  000ec	8b 87 f4 00 00
	00		 mov	 eax, DWORD PTR [edi+244]
  000f2	0f af c6	 imul	 eax, esi
  000f5	01 02		 add	 DWORD PTR [edx], eax

; 1588 : 												break;

  000f7	eb 02		 jmp	 SHORT $LN2@GetTimeFro
$LN16@GetTimeFro:

; 1589 : 		case CScaleBaseData::HORZ_TICK:			ptmCur->tm_sec	+= nDRI_Gap;

  000f9	01 32		 add	 DWORD PTR [edx], esi
$LN2@GetTimeFro:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\time.h

; 515  :             return _mktime64(_Tm);

  000fb	52		 push	 edx
  000fc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___mktime64
  00102	83 c4 04	 add	 esp, 4
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 1592 : 	*ptimeScale = mktime(ptmCur);

  00105	89 03		 mov	 DWORD PTR [ebx], eax
  00107	89 53 04	 mov	 DWORD PTR [ebx+4], edx
$LN28@GetTimeFro:
  0010a	5e		 pop	 esi
  0010b	5b		 pop	 ebx
  0010c	5f		 pop	 edi

; 1593 : }

  0010d	5d		 pop	 ebp
  0010e	c2 08 00	 ret	 8
  00111	0f 1f 00	 npad	 3
$LN27@GetTimeFro:
  00114	00 00 00 00	 DD	 $LN12@GetTimeFro
  00118	00 00 00 00	 DD	 $LN11@GetTimeFro
  0011c	00 00 00 00	 DD	 $LN10@GetTimeFro
  00120	00 00 00 00	 DD	 $LN13@GetTimeFro
  00124	00 00 00 00	 DD	 $LN16@GetTimeFro
  00128	00 00 00 00	 DD	 $LN2@GetTimeFro
$LN26@GetTimeFro:
  0012c	00		 DB	 0
  0012d	01		 DB	 1
  0012e	02		 DB	 2
  0012f	03		 DB	 3
  00130	04		 DB	 4
  00131	03		 DB	 3
  00132	05		 DB	 5
  00133	05		 DB	 5
  00134	05		 DB	 5
  00135	05		 DB	 5
  00136	05		 DB	 5
  00137	03		 DB	 3
?GetTimeFromDRI@CXScaleManagerImp@@UAEXHPA_J@Z ENDP	; CXScaleManagerImp::GetTimeFromDRI
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?IsUseable@CXScaleManagerImp@@UAEHXZ
_TEXT	SEGMENT
?IsUseable@CXScaleManagerImp@@UAEHXZ PROC		; CXScaleManagerImp::IsUseable, COMDAT
; _this$ = ecx

; 2738 : 	return (m_nCountOfRQ != 0);

  00000	33 c0		 xor	 eax, eax
  00002	39 41 6c	 cmp	 DWORD PTR [ecx+108], eax
  00005	0f 95 c0	 setne	 al

; 2739 : }

  00008	c3		 ret	 0
?IsUseable@CXScaleManagerImp@@UAEHXZ ENDP		; CXScaleManagerImp::IsUseable
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?GetScaleUnitAlphaWeight@CXScaleManagerImp@@UAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_strRQ$ = 8						; size = 4
?GetScaleUnitAlphaWeight@CXScaleManagerImp@@UAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z PROC ; CXScaleManagerImp::GetScaleUnitAlphaWeight, COMDAT
; _this$ = ecx

; 1821 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?GetScaleUnitAlphaWeight@CXScaleManagerImp@@UAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx

; 1822 : 	int	nRQ = GetRQIndexFromString( strRQ);

  00026	51		 push	 ecx
  00027	8d 45 08	 lea	 eax, DWORD PTR _strRQ$[ebp]
  0002a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00031	8b cc		 mov	 ecx, esp
  00033	50		 push	 eax
  00034	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z
  0003a	8b 06		 mov	 eax, DWORD PTR [esi]
  0003c	8b ce		 mov	 ecx, esi
  0003e	ff 50 04	 call	 DWORD PTR [eax+4]
  00041	8b c8		 mov	 ecx, eax

; 1823 : 	if( nRQ < 0) return 1;

  00043	85 c9		 test	 ecx, ecx
  00045	79 07		 jns	 SHORT $LN4@GetScaleUn
  00047	be 01 00 00 00	 mov	 esi, 1
  0004c	eb 25		 jmp	 SHORT $LN22@GetScaleUn
$LN4@GetScaleUn:

; 1824 : 	switch( m_pifaRQ[ nRQ]->eScaleUnit)

  0004e	8b 86 8c 00 00
	00		 mov	 eax, DWORD PTR [esi+140]
  00054	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
  00057	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  0005a	48		 dec	 eax
  0005b	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  0005e	77 0e		 ja	 SHORT $LN2@GetScaleUn
  00060	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN23@GetScaleUn[eax*4]
$LN7@GetScaleUn:

; 1825 : 	{
; 1826 : 		case CScaleBaseData::HORZ_MONTHLY:		return 160;
; 1827 : 		case CScaleBaseData::HORZ_WEEKLEY:		return 160;
; 1828 : 		case CScaleBaseData::HORZ_DAILY:		return 200;

  00067	be c8 00 00 00	 mov	 esi, 200		; 000000c8H
  0006c	eb 05		 jmp	 SHORT $LN22@GetScaleUn
$LN2@GetScaleUn:

; 1829 : 		case CScaleBaseData::HORZ_TIME_ONE:		return 160;
; 1830 : 		case CScaleBaseData::HORZ_TIME_TWO:		return 160;
; 1831 : 		case CScaleBaseData::HORZ_TIME_SECOND:	return 160;
; 1832 : 		case CScaleBaseData::HORZ_TICK:			return 160;
; 1833 : 	}
; 1834 : 	return 160;

  0006e	be a0 00 00 00	 mov	 esi, 160		; 000000a0H
$LN22@GetScaleUn:
  00073	8d 4d 08	 lea	 ecx, DWORD PTR _strRQ$[ebp]
  00076	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0007c	8b c6		 mov	 eax, esi

; 1835 : }

  0007e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00081	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00088	59		 pop	 ecx
  00089	5e		 pop	 esi
  0008a	8b e5		 mov	 esp, ebp
  0008c	5d		 pop	 ebp
  0008d	c2 04 00	 ret	 4
$LN23@GetScaleUn:
  00090	00 00 00 00	 DD	 $LN7@GetScaleUn
  00094	00 00 00 00	 DD	 $LN2@GetScaleUn
  00098	00 00 00 00	 DD	 $LN2@GetScaleUn
  0009c	00 00 00 00	 DD	 $LN2@GetScaleUn
  000a0	00 00 00 00	 DD	 $LN2@GetScaleUn
  000a4	00 00 00 00	 DD	 $LN2@GetScaleUn
  000a8	00 00 00 00	 DD	 $LN2@GetScaleUn
  000ac	00 00 00 00	 DD	 $LN2@GetScaleUn
  000b0	00 00 00 00	 DD	 $LN2@GetScaleUn
  000b4	00 00 00 00	 DD	 $LN2@GetScaleUn
  000b8	00 00 00 00	 DD	 $LN2@GetScaleUn
  000bc	00 00 00 00	 DD	 $LN2@GetScaleUn
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetScaleUnitAlphaWeight@CXScaleManagerImp@@UAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z$0:
  00000	8d 4d 08	 lea	 ecx, DWORD PTR _strRQ$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
  0000d	cc		 int	 3
__ehhandler$?GetScaleUnitAlphaWeight@CXScaleManagerImp@@UAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z:
  0000e	90		 npad	 1
  0000f	90		 npad	 1
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?GetScaleUnitAlphaWeight@CXScaleManagerImp@@UAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
  00026	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?GetScaleUnitAlphaWeight@CXScaleManagerImp@@UAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ENDP ; CXScaleManagerImp::GetScaleUnitAlphaWeight
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?GetPacketType@CXScaleManagerImp@@UAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PBD@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_strRQ$ = 12						; size = 4
_lpszRQ$ = 12						; size = 4
?GetPacketType@CXScaleManagerImp@@UAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PBD@Z PROC ; CXScaleManagerImp::GetPacketType, COMDAT
; _this$ = ecx

; 1747 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?GetPacketType@CXScaleManagerImp@@UAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f1		 mov	 esi, ecx

; 1748 : 	CString strRQ( lpszRQ);

  00027	ff 75 0c	 push	 DWORD PTR _lpszRQ$[ebp]
  0002a	8d 4d 0c	 lea	 ecx, DWORD PTR _strRQ$[ebp]
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h

; 519  : 		return( GetData()->nDataLength );

  00033	8b 45 0c	 mov	 eax, DWORD PTR _strRQ$[ebp]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 1748 : 	CString strRQ( lpszRQ);

  00036	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h

; 533  : 		return( GetLength() == 0 );

  0003d	83 78 f4 00	 cmp	 DWORD PTR [eax-12], 0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 1749 : 	if( strRQ.IsEmpty()) strRQ = m_pIChartCtrl->GetCurrentRQ();

  00041	75 18		 jne	 SHORT $LN2@GetPacketT
  00043	8b 4e 50	 mov	 ecx, DWORD PTR [esi+80]
  00046	8b 01		 mov	 eax, DWORD PTR [ecx]
  00048	ff 90 d8 02 00
	00		 call	 DWORD PTR [eax+728]
  0004e	50		 push	 eax
  0004f	8d 4d 0c	 lea	 ecx, DWORD PTR _strRQ$[ebp]
  00052	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z
  00058	8b 45 0c	 mov	 eax, DWORD PTR _strRQ$[ebp]
$LN2@GetPacketT:

; 1750 : 	CPacketRQ* lpPacketRQ = (CPacketRQ*)m_ppacketListManager->GetPacketRQ( strRQ);

  0005b	8b 4e 48	 mov	 ecx, DWORD PTR [esi+72]
  0005e	50		 push	 eax
  0005f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00061	ff 52 20	 call	 DWORD PTR [edx+32]

; 1751 : 
; 1752 : 	CPacketList* pPacketList = m_ppacketListManager->GetPacketList( strRQ);

  00064	8b 4e 48	 mov	 ecx, DWORD PTR [esi+72]
  00067	8b f8		 mov	 edi, eax
  00069	ff 75 0c	 push	 DWORD PTR _strRQ$[ebp]
  0006c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0006e	ff 52 1c	 call	 DWORD PTR [edx+28]

; 1753 : 	CPacket* pPacket = pPacketList->GetBaseData(lpPacketRQ->GetPacketName());

  00071	6a 01		 push	 1
  00073	51		 push	 ecx
  00074	8b cc		 mov	 ecx, esp
  00076	8b f0		 mov	 esi, eax
  00078	ff 77 10	 push	 DWORD PTR [edi+16]
  0007b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  00081	8b ce		 mov	 ecx, esi
  00083	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetBaseData@CPacketList@@QAEPAVCPacket@@V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@_N@Z

; 1754 : 	if(pPacket == NULL) 

  00089	85 c0		 test	 eax, eax
  0008b	75 2d		 jne	 SHORT $LN3@GetPacketT

; 1755 : 		return _T("MMDDHHMM");

  0008d	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00090	68 00 00 00 00	 push	 OFFSET ??_C@_08KLIIINKM@MMDDHHMM@
  00095	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  0009b	8d 4d 0c	 lea	 ecx, DWORD PTR _strRQ$[ebp]
  0009e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  000a4	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1758 : }

  000a7	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000aa	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000b1	59		 pop	 ecx
  000b2	5f		 pop	 edi
  000b3	5e		 pop	 esi
  000b4	8b e5		 mov	 esp, ebp
  000b6	5d		 pop	 ebp
  000b7	c2 08 00	 ret	 8
$LN3@GetPacketT:

; 1756 : 
; 1757 : 	return pPacket->GetType();

  000ba	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  000bd	8b c8		 mov	 ecx, eax
  000bf	6a 01		 push	 1
  000c1	56		 push	 esi
  000c2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetType@CPacket@@QAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@_N@Z
  000c8	8d 4d 0c	 lea	 ecx, DWORD PTR _strRQ$[ebp]
  000cb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  000d1	8b c6		 mov	 eax, esi

; 1758 : }

  000d3	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000d6	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000dd	59		 pop	 ecx
  000de	5f		 pop	 edi
  000df	5e		 pop	 esi
  000e0	8b e5		 mov	 esp, ebp
  000e2	5d		 pop	 ebp
  000e3	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetPacketType@CXScaleManagerImp@@UAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PBD@Z$0:
  00000	8d 4d 0c	 lea	 ecx, DWORD PTR _strRQ$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
  0000d	cc		 int	 3
__ehhandler$?GetPacketType@CXScaleManagerImp@@UAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PBD@Z:
  0000e	90		 npad	 1
  0000f	90		 npad	 1
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?GetPacketType@CXScaleManagerImp@@UAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PBD@Z
  00026	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?GetPacketType@CXScaleManagerImp@@UAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PBD@Z ENDP ; CXScaleManagerImp::GetPacketType
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?GetCurScaleInfo@CXScaleManagerImp@@UAEXAAH@Z
_TEXT	SEGMENT
_nDRI$ = 8						; size = 4
?GetCurScaleInfo@CXScaleManagerImp@@UAEXAAH@Z PROC	; CXScaleManagerImp::GetCurScaleInfo, COMDAT
; _this$ = ecx

; 1512 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1513 : 	nDRI = m_blAreafDRI[ 0].GetIndex();

  00003	81 c1 88 03 00
	00		 add	 ecx, 904		; 00000388H
  00009	e8 00 00 00 00	 call	 ?GetIndex@CDataBlockListUNK@@QAEHXZ ; CDataBlockListUNK::GetIndex
  0000e	8b 4d 08	 mov	 ecx, DWORD PTR _nDRI$[ebp]
  00011	89 01		 mov	 DWORD PTR [ecx], eax

; 1514 : }

  00013	5d		 pop	 ebp
  00014	c2 04 00	 ret	 4
?GetCurScaleInfo@CXScaleManagerImp@@UAEXAAH@Z ENDP	; CXScaleManagerImp::GetCurScaleInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?SetCurScaleInfo@CXScaleManagerImp@@UAEXH@Z
_TEXT	SEGMENT
_nDRI$ = 8						; size = 4
?SetCurScaleInfo@CXScaleManagerImp@@UAEXH@Z PROC	; CXScaleManagerImp::SetCurScaleInfo, COMDAT
; _this$ = ecx

; 1505 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1506 : 	m_blTimefDRI.SetIndex(nDRI);

  00004	8b 75 08	 mov	 esi, DWORD PTR _nDRI$[ebp]
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
  0000a	56		 push	 esi
  0000b	8d 8f ac 00 00
	00		 lea	 ecx, DWORD PTR [edi+172]
  00011	e8 00 00 00 00	 call	 ?SetIndex@CDataBlockListUNK@@QAEXH@Z ; CDataBlockListUNK::SetIndex

; 1507 : 	m_blAreafDRI[ 0].SetIndex(nDRI - m_nDRI_Start_Cur);

  00016	2b 77 28	 sub	 esi, DWORD PTR [edi+40]
  00019	8d 8f 88 03 00
	00		 lea	 ecx, DWORD PTR [edi+904]
  0001f	56		 push	 esi
  00020	e8 00 00 00 00	 call	 ?SetIndex@CDataBlockListUNK@@QAEXH@Z ; CDataBlockListUNK::SetIndex
  00025	5f		 pop	 edi
  00026	5e		 pop	 esi

; 1508 : }

  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?SetCurScaleInfo@CXScaleManagerImp@@UAEXH@Z ENDP	; CXScaleManagerImp::SetCurScaleInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?GetScaleInterval_Unit_Max@CXScaleManagerImp@@UAEHXZ
_TEXT	SEGMENT
?GetScaleInterval_Unit_Max@CXScaleManagerImp@@UAEHXZ PROC ; CXScaleManagerImp::GetScaleInterval_Unit_Max, COMDAT
; _this$ = ecx

; 1500 : 	return m_maxScaleInterval_nUnit;

  00000	8b 81 e8 00 00
	00		 mov	 eax, DWORD PTR [ecx+232]

; 1501 : }

  00006	c3		 ret	 0
?GetScaleInterval_Unit_Max@CXScaleManagerImp@@UAEHXZ ENDP ; CXScaleManagerImp::GetScaleInterval_Unit_Max
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?GetScaleUnit_Max@CXScaleManagerImp@@UAE?AW4HORZSCALEDRAWERTYPE@CScaleBaseData@@PBD@Z
_TEXT	SEGMENT
_lpszRQ$ = 8						; size = 4
?GetScaleUnit_Max@CXScaleManagerImp@@UAE?AW4HORZSCALEDRAWERTYPE@CScaleBaseData@@PBD@Z PROC ; CXScaleManagerImp::GetScaleUnit_Max, COMDAT
; _this$ = ecx

; 1490 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1491 : 	if( lpszRQ) if( !*lpszRQ) lpszRQ = NULL;

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpszRQ$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	85 c0		 test	 eax, eax
  0000b	74 05		 je	 SHORT $LN7@GetScaleUn
  0000d	80 38 00	 cmp	 BYTE PTR [eax], 0
  00010	75 0b		 jne	 SHORT $LN8@GetScaleUn
$LN7@GetScaleUn:

; 1492 : 	int nRQ = GetRQIndexFromString( lpszRQ ? lpszRQ : m_pIChartCtrl->GetCurrentRQ());

  00012	8b 4e 50	 mov	 ecx, DWORD PTR [esi+80]
  00015	8b 01		 mov	 eax, DWORD PTR [ecx]
  00017	ff 90 d8 02 00
	00		 call	 DWORD PTR [eax+728]
$LN8@GetScaleUn:
  0001d	51		 push	 ecx
  0001e	8b cc		 mov	 ecx, esp
  00020	50		 push	 eax
  00021	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  00027	8b 06		 mov	 eax, DWORD PTR [esi]
  00029	8b ce		 mov	 ecx, esi
  0002b	ff 50 04	 call	 DWORD PTR [eax+4]

; 1493 : 	if( 0 <= nRQ)	return m_pifaRQ[ nRQ]->eScaleUnit;

  0002e	85 c0		 test	 eax, eax
  00030	78 11		 js	 SHORT $LN4@GetScaleUn
  00032	8b 8e 8c 00 00
	00		 mov	 ecx, DWORD PTR [esi+140]
  00038	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  0003b	8b 40 14	 mov	 eax, DWORD PTR [eax+20]

; 1495 : }

  0003e	5e		 pop	 esi
  0003f	5d		 pop	 ebp
  00040	c2 04 00	 ret	 4
$LN4@GetScaleUn:

; 1494 : 	else			return m_maxScaleInterval_eType;

  00043	8b 86 e4 00 00
	00		 mov	 eax, DWORD PTR [esi+228]

; 1495 : }

  00049	5e		 pop	 esi
  0004a	5d		 pop	 ebp
  0004b	c2 04 00	 ret	 4
?GetScaleUnit_Max@CXScaleManagerImp@@UAE?AW4HORZSCALEDRAWERTYPE@CScaleBaseData@@PBD@Z ENDP ; CXScaleManagerImp::GetScaleUnit_Max
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?GetDTIFromDRI_AbleRange@CXScaleManagerImp@@UAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HPAH@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_strRQ$ = 8						; size = 4
_nDRI$ = 12						; size = 4
_pnDTI_Org$ = 16					; size = 4
?GetDTIFromDRI_AbleRange@CXScaleManagerImp@@UAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HPAH@Z PROC ; CXScaleManagerImp::GetDTIFromDRI_AbleRange, COMDAT
; _this$ = ecx

; 1456 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?GetDTIFromDRI_AbleRange@CXScaleManagerImp@@UAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HPAH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f9		 mov	 edi, ecx

; 1457 : 	int nRQ = GetRQIndexFromString( strRQ);

  00027	51		 push	 ecx
  00028	8d 45 08	 lea	 eax, DWORD PTR _strRQ$[ebp]
  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00032	8b cc		 mov	 ecx, esp
  00034	50		 push	 eax
  00035	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z
  0003b	8b 07		 mov	 eax, DWORD PTR [edi]
  0003d	8b cf		 mov	 ecx, edi
  0003f	ff 50 04	 call	 DWORD PTR [eax+4]
  00042	8b f0		 mov	 esi, eax

; 1458 : 	if( nRQ < 0) return -1;

  00044	85 f6		 test	 esi, esi
  00046	79 05		 jns	 SHORT $LN2@GetDTIFrom
  00048	83 ce ff	 or	 esi, -1
  0004b	eb 62		 jmp	 SHORT $LN6@GetDTIFrom
$LN2@GetDTIFrom:

; 1459 : 	return GetDTIFromDRI_AbleRange( m_pblaDTIfDRI[ nRQ], nDRI, pnDTI_Org);

  0004d	8b 87 a8 00 00
	00		 mov	 eax, DWORD PTR [edi+168]
  00053	8b 34 b0	 mov	 esi, DWORD PTR [eax+esi*4]

; 1435 : 	if( !pblDTIfDRI) return -1;

  00056	85 f6		 test	 esi, esi
  00058	74 34		 je	 SHORT $LN20@GetDTIFrom

; 1436 : 
; 1437 : 	int nItemCount = pblDTIfDRI->GetItemCount();

  0005a	8b ce		 mov	 ecx, esi
  0005c	e8 00 00 00 00	 call	 ?GetItemCount@CDataBlockListUNK@@QAEHXZ ; CDataBlockListUNK::GetItemCount
  00061	8b c8		 mov	 ecx, eax

; 1438 : 	if( nItemCount == 0) return -1;

  00063	85 c9		 test	 ecx, ecx
  00065	74 27		 je	 SHORT $LN20@GetDTIFrom

; 1439 : 
; 1440 : 	if( 0 <= nDRI && nDRI < nItemCount)

  00067	8b 45 0c	 mov	 eax, DWORD PTR _nDRI$[ebp]
  0006a	85 c0		 test	 eax, eax
  0006c	78 06		 js	 SHORT $LN17@GetDTIFrom
  0006e	3b c1		 cmp	 eax, ecx
  00070	7d 06		 jge	 SHORT $LN26@GetDTIFrom

; 1441 : 	{
; 1442 : 		m_pIReturn = pblDTIfDRI->GetAt(nDRI);
; 1443 : 		if( m_pIReturn) return *m_pIReturn;
; 1444 : 		else return -1;

  00072	eb 07		 jmp	 SHORT $LN29@GetDTIFrom
$LN17@GetDTIFrom:

; 1445 : 	}
; 1446 : 	if( nItemCount <= nDRI)

  00074	3b c8		 cmp	 ecx, eax
  00076	7f 16		 jg	 SHORT $LN20@GetDTIFrom
$LN26@GetDTIFrom:

; 1447 : 	{
; 1448 : 		m_pIReturn = pblDTIfDRI->GetAt( nItemCount - 1);	// end mark.

  00078	8d 41 ff	 lea	 eax, DWORD PTR [ecx-1]
$LN29@GetDTIFrom:

; 1469 : 	if( pnDTI_Org != NULL) *pnDTI_Org = nDTI;

  0007b	50		 push	 eax
  0007c	8b ce		 mov	 ecx, esi
  0007e	e8 00 00 00 00	 call	 ?GetAtUNK@CDataBlockListUNK@@QAEPAXH@Z ; CDataBlockListUNK::GetAtUNK
  00083	89 47 60	 mov	 DWORD PTR [edi+96], eax
  00086	85 c0		 test	 eax, eax
  00088	74 04		 je	 SHORT $LN20@GetDTIFrom
  0008a	8b 00		 mov	 eax, DWORD PTR [eax]
  0008c	eb 03		 jmp	 SHORT $LN12@GetDTIFrom
$LN20@GetDTIFrom:
  0008e	83 c8 ff	 or	 eax, -1
$LN12@GetDTIFrom:
  00091	8b 4d 10	 mov	 ecx, DWORD PTR _pnDTI_Org$[ebp]
  00094	85 c9		 test	 ecx, ecx
  00096	74 02		 je	 SHORT $LN8@GetDTIFrom
  00098	89 01		 mov	 DWORD PTR [ecx], eax
$LN8@GetDTIFrom:

; 1470 : 	if( nDTI == -1)	nDTI = 0;
; 1471 : 	if( nDTI < -1)	nDTI = (nDTI * -1) - 3;

  0009a	33 c9		 xor	 ecx, ecx

; 1459 : 	return GetDTIFromDRI_AbleRange( m_pblaDTIfDRI[ nRQ], nDRI, pnDTI_Org);

  0009c	be fd ff ff ff	 mov	 esi, -3			; fffffffdH

; 1471 : 	if( nDTI < -1)	nDTI = (nDTI * -1) - 3;

  000a1	83 f8 ff	 cmp	 eax, -1
  000a4	0f 45 c8	 cmovne	 ecx, eax

; 1459 : 	return GetDTIFromDRI_AbleRange( m_pblaDTIfDRI[ nRQ], nDRI, pnDTI_Org);

  000a7	2b f1		 sub	 esi, ecx
  000a9	83 f9 ff	 cmp	 ecx, -1
  000ac	0f 4d f1	 cmovge	 esi, ecx
$LN6@GetDTIFrom:
  000af	8d 4d 08	 lea	 ecx, DWORD PTR _strRQ$[ebp]
  000b2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  000b8	8b c6		 mov	 eax, esi

; 1460 : }

  000ba	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000bd	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000c4	59		 pop	 ecx
  000c5	5f		 pop	 edi
  000c6	5e		 pop	 esi
  000c7	8b e5		 mov	 esp, ebp
  000c9	5d		 pop	 ebp
  000ca	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetDTIFromDRI_AbleRange@CXScaleManagerImp@@UAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HPAH@Z$0:
  00000	8d 4d 08	 lea	 ecx, DWORD PTR _strRQ$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
  0000d	cc		 int	 3
__ehhandler$?GetDTIFromDRI_AbleRange@CXScaleManagerImp@@UAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HPAH@Z:
  0000e	90		 npad	 1
  0000f	90		 npad	 1
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?GetDTIFromDRI_AbleRange@CXScaleManagerImp@@UAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HPAH@Z
  00026	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?GetDTIFromDRI_AbleRange@CXScaleManagerImp@@UAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HPAH@Z ENDP ; CXScaleManagerImp::GetDTIFromDRI_AbleRange
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?GetDrawIndex@CXScaleManagerImp@@UAEXHHAAH0@Z
_TEXT	SEGMENT
_bIncludePrev$ = 8					; size = 4
_bOEBT$ = 12						; size = 4
_nDTI_Start$ = 16					; size = 4
_nDTI_End$ = 20						; size = 4
?GetDrawIndex@CXScaleManagerImp@@UAEXHHAAH0@Z PROC	; CXScaleManagerImp::GetDrawIndex, COMDAT
; _this$ = ecx

; 1414 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 1415 : 	if(m_ppacketListManager)	

  00005	ff 75 14	 push	 DWORD PTR _nDTI_End$[ebp]
  00008	8b f9		 mov	 edi, ecx
  0000a	ff 75 10	 push	 DWORD PTR _nDTI_Start$[ebp]
  0000d	ff 75 0c	 push	 DWORD PTR _bOEBT$[ebp]
  00010	83 7f 48 00	 cmp	 DWORD PTR [edi+72], 0
  00014	ff 75 08	 push	 DWORD PTR _bIncludePrev$[ebp]
  00017	74 13		 je	 SHORT $LN2@GetDrawInd

; 1416 : 		GetDrawIndex( m_pIChartCtrl->GetCurrentRQ(), bIncludePrev, bOEBT, nDTI_Start, nDTI_End);

  00019	8b 4f 50	 mov	 ecx, DWORD PTR [edi+80]
  0001c	51		 push	 ecx
  0001d	8b f4		 mov	 esi, esp
  0001f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00021	ff 90 d8 02 00
	00		 call	 DWORD PTR [eax+728]
  00027	50		 push	 eax
  00028	8b ce		 mov	 ecx, esi
  0002a	eb 08		 jmp	 SHORT $LN7@GetDrawInd
$LN2@GetDrawInd:

; 1417 : 	else
; 1418 : 		GetDrawIndex(_T("DEFAULT"), bIncludePrev, bOEBT, nDTI_Start, nDTI_End);

  0002c	51		 push	 ecx
  0002d	8b cc		 mov	 ecx, esp
  0002f	68 00 00 00 00	 push	 OFFSET ??_C@_07MGCPDNLD@DEFAULT@
$LN7@GetDrawInd:

; 1419 : }

  00034	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  0003a	8b 07		 mov	 eax, DWORD PTR [edi]
  0003c	8b cf		 mov	 ecx, edi
  0003e	ff 90 a4 00 00
	00		 call	 DWORD PTR [eax+164]
  00044	5f		 pop	 edi
  00045	5e		 pop	 esi
  00046	5d		 pop	 ebp
  00047	c2 10 00	 ret	 16			; 00000010H
?GetDrawIndex@CXScaleManagerImp@@UAEXHHAAH0@Z ENDP	; CXScaleManagerImp::GetDrawIndex
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?GetDrawIndex@CXScaleManagerImp@@UAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HHAAH1@Z
_TEXT	SEGMENT
_nDTI_End$GSCopy$1$ = -56				; size = 4
tv835 = -52						; size = 4
_blDTIfDRI$1$ = -48					; size = 4
tv829 = -48						; size = 4
_nDTI$1$ = -44						; size = 4
_nDRI$1$ = -44						; size = 4
_stringRQ$ = -40					; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_strRQ$ = 8						; size = 4
_bIncludePrev$ = 12					; size = 4
_bOEBT$ = 16						; size = 4
_nDTI_Start$ = 20					; size = 4
_nDTI_End$ = 24						; size = 4
?GetDrawIndex@CXScaleManagerImp@@UAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HHAAH1@Z PROC ; CXScaleManagerImp::GetDrawIndex, COMDAT
; _this$ = ecx

; 1371 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?GetDrawIndex@CXScaleManagerImp@@UAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HHAAH1@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b f1		 mov	 esi, ecx
  0002d	8b 5d 18	 mov	 ebx, DWORD PTR _nDTI_End$[ebp]
  00030	8b 7d 14	 mov	 edi, DWORD PTR _nDTI_Start$[ebp]
  00033	89 5d c8	 mov	 DWORD PTR _nDTI_End$GSCopy$1$[ebp], ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 404  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00036	8b 45 08	 mov	 eax, DWORD PTR _strRQ$[ebp]
  00039	8b d0		 mov	 edx, eax

; 2313 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  0003b	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _stringRQ$[ebp], 0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 1371 : {

  00042	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4562 :         _My_data._Mysize = 0;

  00049	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _stringRQ$[ebp+16], 0

; 404  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00050	8d 4a 01	 lea	 ecx, DWORD PTR [edx+1]

; 4576 :             _My_data._Myres = _BUF_SIZE - 1;

  00053	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR _stringRQ$[ebp+20], 15 ; 0000000fH

; 4577 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4578 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  0005a	c6 45 d8 00	 mov	 BYTE PTR _stringRQ$[ebp], 0

; 404  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  0005e	89 4d d0	 mov	 DWORD PTR tv829[ebp], ecx
$LL133@GetDrawInd:
  00061	8a 0a		 mov	 cl, BYTE PTR [edx]
  00063	42		 inc	 edx
  00064	84 c9		 test	 cl, cl
  00066	75 f9		 jne	 SHORT $LL133@GetDrawInd
  00068	2b 55 d0	 sub	 edx, DWORD PTR tv829[ebp]

; 3230 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0006b	8d 4d d8	 lea	 ecx, DWORD PTR _stringRQ$[ebp]
  0006e	52		 push	 edx
  0006f	50		 push	 eax
  00070	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 1378 : 	int nRQ = GetRQIndexFromString( strRQ);

  00075	51		 push	 ecx
  00076	8d 45 08	 lea	 eax, DWORD PTR _strRQ$[ebp]
  00079	c7 03 ff ff ff
	ff		 mov	 DWORD PTR [ebx], -1
  0007f	8b cc		 mov	 ecx, esp
  00081	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00085	50		 push	 eax
  00086	c7 07 ff ff ff
	ff		 mov	 DWORD PTR [edi], -1
  0008c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z
  00092	8b 06		 mov	 eax, DWORD PTR [esi]
  00094	8b ce		 mov	 ecx, esi
  00096	ff 50 04	 call	 DWORD PTR [eax+4]

; 1379 : 	if( nRQ < 0) return;

  00099	85 c0		 test	 eax, eax
  0009b	79 5b		 jns	 SHORT $LN2@GetDrawInd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2286 :         return _BUF_SIZE <= _Myres;

  0009d	8b 55 ec	 mov	 edx, DWORD PTR _stringRQ$[ebp+20]
  000a0	83 fa 10	 cmp	 edx, 16			; 00000010H

; 4584 :         if (_Mypair._Myval2._Large_string_engaged()) {

  000a3	72 2c		 jb	 SHORT $LN111@GetDrawInd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000a5	8b 4d d8	 mov	 ecx, DWORD PTR _stringRQ$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4588 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  000a8	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000a9	8b c1		 mov	 eax, ecx

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  000ab	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  000b1	72 14		 jb	 SHORT $LN121@GetDrawInd

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000b3	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  000b6	83 c2 23	 add	 edx, 35			; 00000023H
  000b9	2b c1		 sub	 eax, ecx

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000bb	83 c0 fc	 add	 eax, -4			; fffffffcH
  000be	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  000c1	0f 87 cc 01 00
	00		 ja	 $LN118@GetDrawInd
$LN121@GetDrawInd:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 1410 : }

  000c7	52		 push	 edx
  000c8	51		 push	 ecx
  000c9	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  000ce	83 c4 08	 add	 esp, 8
$LN111@GetDrawInd:
  000d1	8d 4d 08	 lea	 ecx, DWORD PTR _strRQ$[ebp]
  000d4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  000da	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000dd	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000e4	59		 pop	 ecx
  000e5	5f		 pop	 edi
  000e6	5e		 pop	 esi
  000e7	5b		 pop	 ebx
  000e8	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000eb	33 cd		 xor	 ecx, ebp
  000ed	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000f2	8b e5		 mov	 esp, ebp
  000f4	5d		 pop	 ebp
  000f5	c2 14 00	 ret	 20			; 00000014H
$LN2@GetDrawInd:

; 1380 : 	CDataBlockList<int>* blDTIfDRI = m_pblaDTIfDRI[ nRQ];

  000f8	8d 0c 85 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*4]
  000ff	8b 86 a8 00 00
	00		 mov	 eax, DWORD PTR [esi+168]
  00105	89 4d cc	 mov	 DWORD PTR tv835[ebp], ecx
  00108	8b 04 01	 mov	 eax, DWORD PTR [ecx+eax]

; 1381 : 
; 1382 : 	nDTI_Start	= GetDTIFromDRI_AbleRange(blDTIfDRI, m_nDRI_Start_Cur, &nDTI_Start_Org);

  0010b	8b 4e 28	 mov	 ecx, DWORD PTR [esi+40]
  0010e	89 45 d0	 mov	 DWORD PTR _blDTIfDRI$1$[ebp], eax
  00111	89 4d d4	 mov	 DWORD PTR _nDRI$1$[ebp], ecx

; 1435 : 	if( !pblDTIfDRI) return -1;

  00114	85 c0		 test	 eax, eax
  00116	75 20		 jne	 SHORT $LN67@GetDrawInd
  00118	89 07		 mov	 DWORD PTR [edi], eax
  0011a	33 c9		 xor	 ecx, ecx
  0011c	83 c8 ff	 or	 eax, -1
  0011f	3b c0		 cmp	 eax, eax
  00121	0f 45 c8	 cmovne	 ecx, eax
  00124	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH
  00129	2b c1		 sub	 eax, ecx
  0012b	83 f9 ff	 cmp	 ecx, -1
  0012e	0f 4d c1	 cmovge	 eax, ecx
  00131	89 03		 mov	 DWORD PTR [ebx], eax
  00133	e9 1d 01 00 00	 jmp	 $LN130@GetDrawInd
$LN67@GetDrawInd:

; 1437 : 	int nItemCount = pblDTIfDRI->GetItemCount();

  00138	8b c8		 mov	 ecx, eax
  0013a	e8 00 00 00 00	 call	 ?GetItemCount@CDataBlockListUNK@@QAEHXZ ; CDataBlockListUNK::GetItemCount
  0013f	8b c8		 mov	 ecx, eax

; 1438 : 	if( nItemCount == 0) return -1;

  00141	bb fd ff ff ff	 mov	 ebx, -3			; fffffffdH
  00146	85 c9		 test	 ecx, ecx
  00148	74 68		 je	 SHORT $LN74@GetDrawInd

; 1439 : 
; 1440 : 	if( 0 <= nDRI && nDRI < nItemCount)

  0014a	8b 45 d4	 mov	 eax, DWORD PTR _nDRI$1$[ebp]
  0014d	85 c0		 test	 eax, eax
  0014f	78 2f		 js	 SHORT $LN71@GetDrawInd
  00151	3b c1		 cmp	 eax, ecx
  00153	7d 2f		 jge	 SHORT $LN128@GetDrawInd
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 215  : 	T*	GetAt( int nIndex)	{	return ( T*)GetAtUNK( nIndex);	}

  00155	8b 4d d0	 mov	 ecx, DWORD PTR _blDTIfDRI$1$[ebp]
  00158	50		 push	 eax
  00159	e8 00 00 00 00	 call	 ?GetAtUNK@CDataBlockListUNK@@QAEPAXH@Z ; CDataBlockListUNK::GetAtUNK
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 1442 : 		m_pIReturn = pblDTIfDRI->GetAt(nDRI);

  0015e	89 46 60	 mov	 DWORD PTR [esi+96], eax

; 1443 : 		if( m_pIReturn) return *m_pIReturn;

  00161	85 c0		 test	 eax, eax
  00163	74 4d		 je	 SHORT $LN74@GetDrawInd
  00165	8b 00		 mov	 eax, DWORD PTR [eax]
  00167	33 c9		 xor	 ecx, ecx
  00169	83 f8 ff	 cmp	 eax, -1
  0016c	89 45 d4	 mov	 DWORD PTR _nDTI$1$[ebp], eax
  0016f	0f 45 c8	 cmovne	 ecx, eax
  00172	8b c3		 mov	 eax, ebx
  00174	2b c1		 sub	 eax, ecx
  00176	83 f9 ff	 cmp	 ecx, -1
  00179	0f 4d c1	 cmovge	 eax, ecx
  0017c	89 07		 mov	 DWORD PTR [edi], eax
  0017e	eb 3e		 jmp	 SHORT $LN136@GetDrawInd
$LN71@GetDrawInd:

; 1445 : 	}
; 1446 : 	if( nItemCount <= nDRI)

  00180	3b c8		 cmp	 ecx, eax
  00182	7f 2e		 jg	 SHORT $LN74@GetDrawInd
$LN128@GetDrawInd:

; 1448 : 		m_pIReturn = pblDTIfDRI->GetAt( nItemCount - 1);	// end mark.

  00184	8d 41 ff	 lea	 eax, DWORD PTR [ecx-1]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 215  : 	T*	GetAt( int nIndex)	{	return ( T*)GetAtUNK( nIndex);	}

  00187	8b 4d d0	 mov	 ecx, DWORD PTR _blDTIfDRI$1$[ebp]
  0018a	50		 push	 eax
  0018b	e8 00 00 00 00	 call	 ?GetAtUNK@CDataBlockListUNK@@QAEPAXH@Z ; CDataBlockListUNK::GetAtUNK
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 1448 : 		m_pIReturn = pblDTIfDRI->GetAt( nItemCount - 1);	// end mark.

  00190	89 46 60	 mov	 DWORD PTR [esi+96], eax

; 1449 : 		if( m_pIReturn) return *m_pIReturn;

  00193	85 c0		 test	 eax, eax
  00195	74 1b		 je	 SHORT $LN74@GetDrawInd
  00197	8b 00		 mov	 eax, DWORD PTR [eax]
  00199	33 c9		 xor	 ecx, ecx
  0019b	83 f8 ff	 cmp	 eax, -1
  0019e	89 45 d4	 mov	 DWORD PTR _nDTI$1$[ebp], eax
  001a1	0f 45 c8	 cmovne	 ecx, eax
  001a4	8b c3		 mov	 eax, ebx
  001a6	2b c1		 sub	 eax, ecx
  001a8	83 f9 ff	 cmp	 ecx, -1
  001ab	0f 4d c1	 cmovge	 eax, ecx
  001ae	89 07		 mov	 DWORD PTR [edi], eax
  001b0	eb 0c		 jmp	 SHORT $LN136@GetDrawInd
$LN74@GetDrawInd:

; 1437 : 	int nItemCount = pblDTIfDRI->GetItemCount();

  001b2	83 c8 ff	 or	 eax, -1
  001b5	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  001bb	89 45 d4	 mov	 DWORD PTR _nDTI$1$[ebp], eax
$LN136@GetDrawInd:
  001be	8b 4d d0	 mov	 ecx, DWORD PTR _blDTIfDRI$1$[ebp]
  001c1	8b 5e 2c	 mov	 ebx, DWORD PTR [esi+44]
  001c4	e8 00 00 00 00	 call	 ?GetItemCount@CDataBlockListUNK@@QAEHXZ ; CDataBlockListUNK::GetItemCount

; 1438 : 	if( nItemCount == 0) return -1;

  001c9	85 c0		 test	 eax, eax
  001cb	74 24		 je	 SHORT $LN93@GetDrawInd

; 1439 : 
; 1440 : 	if( 0 <= nDRI && nDRI < nItemCount)

  001cd	85 db		 test	 ebx, ebx
  001cf	78 07		 js	 SHORT $LN90@GetDrawInd
  001d1	3b d8		 cmp	 ebx, eax
  001d3	7d 07		 jge	 SHORT $LN127@GetDrawInd
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 215  : 	T*	GetAt( int nIndex)	{	return ( T*)GetAtUNK( nIndex);	}

  001d5	53		 push	 ebx
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 1444 : 		else return -1;

  001d6	eb 06		 jmp	 SHORT $LN138@GetDrawInd
$LN90@GetDrawInd:

; 1445 : 	}
; 1446 : 	if( nItemCount <= nDRI)

  001d8	3b c3		 cmp	 eax, ebx
  001da	7f 15		 jg	 SHORT $LN93@GetDrawInd
$LN127@GetDrawInd:

; 1448 : 		m_pIReturn = pblDTIfDRI->GetAt( nItemCount - 1);	// end mark.

  001dc	48		 dec	 eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 215  : 	T*	GetAt( int nIndex)	{	return ( T*)GetAtUNK( nIndex);	}

  001dd	50		 push	 eax
$LN138@GetDrawInd:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 1471 : 	if( nDTI < -1)	nDTI = (nDTI * -1) - 3;

  001de	8b 4d d0	 mov	 ecx, DWORD PTR _blDTIfDRI$1$[ebp]
  001e1	e8 00 00 00 00	 call	 ?GetAtUNK@CDataBlockListUNK@@QAEPAXH@Z ; CDataBlockListUNK::GetAtUNK
  001e6	89 46 60	 mov	 DWORD PTR [esi+96], eax
  001e9	85 c0		 test	 eax, eax
  001eb	74 04		 je	 SHORT $LN93@GetDrawInd
  001ed	8b 08		 mov	 ecx, DWORD PTR [eax]
  001ef	eb 03		 jmp	 SHORT $LN85@GetDrawInd
$LN93@GetDrawInd:
  001f1	83 c9 ff	 or	 ecx, -1
$LN85@GetDrawInd:

; 1383 : 	nDTI_End	= GetDTIFromDRI_AbleRange(blDTIfDRI, m_nDRI_End_Cur, &nDTI_End_Org);

  001f4	8b 5d c8	 mov	 ebx, DWORD PTR _nDTI_End$GSCopy$1$[ebp]

; 1471 : 	if( nDTI < -1)	nDTI = (nDTI * -1) - 3;

  001f7	33 c0		 xor	 eax, eax
  001f9	83 f9 ff	 cmp	 ecx, -1

; 1383 : 	nDTI_End	= GetDTIFromDRI_AbleRange(blDTIfDRI, m_nDRI_End_Cur, &nDTI_End_Org);

  001fc	ba fd ff ff ff	 mov	 edx, -3			; fffffffdH

; 1471 : 	if( nDTI < -1)	nDTI = (nDTI * -1) - 3;

  00201	0f 45 c1	 cmovne	 eax, ecx

; 1383 : 	nDTI_End	= GetDTIFromDRI_AbleRange(blDTIfDRI, m_nDRI_End_Cur, &nDTI_End_Org);

  00204	2b d0		 sub	 edx, eax
  00206	83 f8 ff	 cmp	 eax, -1
  00209	0f 4d d0	 cmovge	 edx, eax

; 1384 : 
; 1385 : 	if(nDTI_Start_Org >= 0 || nDTI_Start_Org != nDTI_End_Org)

  0020c	8b 45 d4	 mov	 eax, DWORD PTR _nDTI$1$[ebp]
  0020f	89 13		 mov	 DWORD PTR [ebx], edx
  00211	85 c0		 test	 eax, eax
  00213	79 04		 jns	 SHORT $LN5@GetDrawInd
  00215	3b c1		 cmp	 eax, ecx
  00217	74 3c		 je	 SHORT $LN130@GetDrawInd
$LN5@GetDrawInd:

; 1386 : 	{
; 1387 : 		//    RQ .
; 1388 : 		// (2008/12/29 - Seung-Won, Bae) Do not use m_mifOEBT. Use m_pifaOEBT.
; 1389 : 		//	MAP_RQ_OEBT::iterator it = m_mifOEBT.find(stringRQ);
; 1390 : 		//	BOOL bOEBT_RQ = (it != m_mifOEBT.end());
; 1391 : 		//    RQ     
; 1392 : 		//          .
; 1393 : 		if( m_pifaOEBT[ nRQ] && bOEBT == FALSE && m_bUseOEBTMargin == TRUE)

  00219	8b 86 90 00 00
	00		 mov	 eax, DWORD PTR [esi+144]
  0021f	8b 4d cc	 mov	 ecx, DWORD PTR tv835[ebp]
  00222	8b 04 01	 mov	 eax, DWORD PTR [ecx+eax]
  00225	85 c0		 test	 eax, eax
  00227	74 11		 je	 SHORT $LN6@GetDrawInd
  00229	83 7d 10 00	 cmp	 DWORD PTR _bOEBT$[ebp], 0
  0022d	75 0b		 jne	 SHORT $LN6@GetDrawInd
  0022f	83 7e 14 01	 cmp	 DWORD PTR [esi+20], 1
  00233	75 05		 jne	 SHORT $LN6@GetDrawInd

; 1394 : 			nDTI_End -= m_pifaOEBT[ nRQ]->nFutureCount;

  00235	2b 50 04	 sub	 edx, DWORD PTR [eax+4]
  00238	89 13		 mov	 DWORD PTR [ebx], edx
$LN6@GetDrawInd:

; 1395 : 
; 1396 : 		//           .
; 1397 : 		if(bIncludePrev == TRUE) nDTI_Start--;

  0023a	83 7d 0c 01	 cmp	 DWORD PTR _bIncludePrev$[ebp], 1
  0023e	8b 07		 mov	 eax, DWORD PTR [edi]
  00240	75 03		 jne	 SHORT $LN7@GetDrawInd
  00242	48		 dec	 eax
  00243	89 07		 mov	 DWORD PTR [edi], eax
$LN7@GetDrawInd:

; 1398 : 
; 1399 : 		if(nDTI_Start < 0) nDTI_Start = 0;

  00245	85 c0		 test	 eax, eax
  00247	79 08		 jns	 SHORT $LN8@GetDrawInd
  00249	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  0024f	33 c0		 xor	 eax, eax
$LN8@GetDrawInd:

; 1400 : 
; 1401 : 		if(nDTI_End < nDTI_Start)

  00251	39 03		 cmp	 DWORD PTR [ebx], eax
  00253	7d 0c		 jge	 SHORT $LN9@GetDrawInd
$LN130@GetDrawInd:

; 1402 : 		{
; 1403 : 			nDTI_Start = nDTI_End = -1;

  00255	c7 03 ff ff ff
	ff		 mov	 DWORD PTR [ebx], -1
  0025b	c7 07 ff ff ff
	ff		 mov	 DWORD PTR [edi], -1
$LN9@GetDrawInd:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2286 :         return _BUF_SIZE <= _Myres;

  00261	8b 55 ec	 mov	 edx, DWORD PTR _stringRQ$[ebp+20]
  00264	83 fa 10	 cmp	 edx, 16			; 00000010H

; 4584 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00267	0f 82 64 fe ff
	ff		 jb	 $LN111@GetDrawInd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0026d	8b 4d d8	 mov	 ecx, DWORD PTR _stringRQ$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4588 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00270	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00271	8b c1		 mov	 eax, ecx

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00273	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00279	0f 82 48 fe ff
	ff		 jb	 $LN121@GetDrawInd

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0027f	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00282	83 c2 23	 add	 edx, 35			; 00000023H
  00285	2b c1		 sub	 eax, ecx

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00287	83 c0 fc	 add	 eax, -4			; fffffffcH
  0028a	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0028d	0f 86 34 fe ff
	ff		 jbe	 $LN121@GetDrawInd
$LN118@GetDrawInd:
  00293	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN135@GetDrawInd:
  00299	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetDrawIndex@CXScaleManagerImp@@UAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HHAAH1@Z$0:
  00000	8d 4d 08	 lea	 ecx, DWORD PTR _strRQ$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?GetDrawIndex@CXScaleManagerImp@@UAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HHAAH1@Z$1:
  00009	8d 4d d8	 lea	 ecx, DWORD PTR _stringRQ$[ebp]
  0000c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
  00015	cc		 int	 3
__ehhandler$?GetDrawIndex@CXScaleManagerImp@@UAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HHAAH1@Z:
  00016	90		 npad	 1
  00017	90		 npad	 1
  00018	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001f	8b 4a c4	 mov	 ecx, DWORD PTR [edx-60]
  00022	33 c8		 xor	 ecx, eax
  00024	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00029	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0002c	33 c8		 xor	 ecx, eax
  0002e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00033	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?GetDrawIndex@CXScaleManagerImp@@UAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HHAAH1@Z
  00038	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?GetDrawIndex@CXScaleManagerImp@@UAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HHAAH1@Z ENDP ; CXScaleManagerImp::GetDrawIndex
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?GetPageCountNextStep@CXScaleManagerImp@@UAEHHHHHH@Z
_TEXT	SEGMENT
tv324 = -16						; size = 8
tv301 = -16						; size = 8
tv254 = -16						; size = 8
tv342 = -8						; size = 8
tv336 = -8						; size = 8
_dItemWidth$3$ = -8					; size = 8
_nSliderPos_Prev$ = 8					; size = 4
_nSliderPos_New$ = 12					; size = 4
_nSBCode$ = 16						; size = 4
_nMin$ = 20						; size = 4
_nMax$ = 24						; size = 4
?GetPageCountNextStep@CXScaleManagerImp@@UAEHHHHHH@Z PROC ; CXScaleManagerImp::GetPageCountNextStep, COMDAT
; _this$ = ecx

; 1896 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx

; 1897 : 	if( 1 != m_nCountOfBlockColumn || m_nCountOfRQ == 0 || !m_bFixedInterval) return nSliderPos_New;

  00009	83 be 2c 01 00
	00 01		 cmp	 DWORD PTR [esi+300], 1
  00010	0f 85 63 01 00
	00		 jne	 $LN3@GetPageCou
  00016	83 7e 6c 00	 cmp	 DWORD PTR [esi+108], 0
  0001a	0f 84 59 01 00
	00		 je	 $LN3@GetPageCou
  00020	83 7e 24 00	 cmp	 DWORD PTR [esi+36], 0
  00024	0f 84 4f 01 00
	00		 je	 $LN3@GetPageCou

; 1898 : 
; 1899 : 	int nCount = GetCount();

  0002a	8b 06		 mov	 eax, DWORD PTR [esi]
  0002c	53		 push	 ebx
  0002d	57		 push	 edi
  0002e	ff 90 84 00 00
	00		 call	 DWORD PTR [eax+132]

; 1900 : 	int nPreDrawCount = m_nDrawCount_Cur;
; 1901 : 	int nDrawCount_Cur = nSliderPos_New;

  00034	8b 7d 0c	 mov	 edi, DWORD PTR _nSliderPos_New$[ebp]
  00037	0f 57 e4	 xorps	 xmm4, xmm4

; 1902 : 	double dItemWidth = ( double)m_nScreenWidth_Cur[ 0] / ( double)max( nDrawCount_Cur, m_nMinDataCountOnOnePage);

  0003a	8b 5e 34	 mov	 ebx, DWORD PTR [esi+52]
  0003d	8b c3		 mov	 eax, ebx
  0003f	66 0f 6e 96 38
	03 00 00	 movd	 xmm2, DWORD PTR [esi+824]
  00047	3b fb		 cmp	 edi, ebx
  00049	f3 0f e6 d2	 cvtdq2pd xmm2, xmm2
  0004d	0f 4f c7	 cmovg	 eax, edi

; 1903 : 
; 1904 : 	//    
; 1905 : 	if( 0 < dItemWidth && dItemWidth < 1)

  00050	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@3ff0000000000000
  00058	66 0f 6e c0	 movd	 xmm0, eax
  0005c	0f 28 da	 movaps	 xmm3, xmm2
  0005f	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00063	f2 0f 11 55 f0	 movsd	 QWORD PTR tv301[ebp], xmm2
  00068	f2 0f 5e d8	 divsd	 xmm3, xmm0
  0006c	66 0f 2f dc	 comisd	 xmm3, xmm4
  00070	76 40		 jbe	 SHORT $LN4@GetPageCou
  00072	66 0f 2f cb	 comisd	 xmm1, xmm3
  00076	76 3a		 jbe	 SHORT $LN4@GetPageCou

; 1906 : 			dItemWidth = 1.0 / ceil( 1 / dItemWidth);

  00078	0f 28 c1	 movaps	 xmm0, xmm1
  0007b	83 ec 08	 sub	 esp, 8
  0007e	f2 0f 5e c3	 divsd	 xmm0, xmm3
  00082	f2 0f 11 45 f8	 movsd	 QWORD PTR tv342[ebp], xmm0
  00087	dd 45 f8	 fld	 QWORD PTR tv342[ebp]
  0008a	dd 1c 24	 fstp	 QWORD PTR [esp]
  0008d	e8 00 00 00 00	 call	 _ceil
  00092	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@3ff0000000000000
  0009a	83 c4 08	 add	 esp, 8
  0009d	f2 0f 10 55 f0	 movsd	 xmm2, QWORD PTR tv301[ebp]
  000a2	0f 28 d9	 movaps	 xmm3, xmm1
  000a5	dd 5d f8	 fstp	 QWORD PTR tv336[ebp]
  000a8	f2 0f 5e 5d f8	 divsd	 xmm3, QWORD PTR tv336[ebp]
  000ad	0f 57 e4	 xorps	 xmm4, xmm4
  000b0	eb 0c		 jmp	 SHORT $LN5@GetPageCou
$LN4@GetPageCou:

; 1907 : 	else	dItemWidth = ( int)dItemWidth;

  000b2	f2 0f 2c c3	 cvttsd2si eax, xmm3
  000b6	66 0f 6e d8	 movd	 xmm3, eax
  000ba	f3 0f e6 db	 cvtdq2pd xmm3, xmm3
$LN5@GetPageCou:

; 1908 : 	// (2009/1/8 - Seung-Won, Bae) Update Count and Start to avoid the right indent too large.
; 1909 : 	if( 0 < dItemWidth) nDrawCount_Cur = ( int)( ( double)m_nScreenWidth_Cur[ 0] / dItemWidth);

  000be	66 0f 2f dc	 comisd	 xmm3, xmm4
  000c2	76 0b		 jbe	 SHORT $LN6@GetPageCou
  000c4	0f 28 c2	 movaps	 xmm0, xmm2
  000c7	f2 0f 5e c3	 divsd	 xmm0, xmm3
  000cb	f2 0f 2c f8	 cvttsd2si edi, xmm0
$LN6@GetPageCou:

; 1910 : 
; 1911 : 	if( m_nItemCount_Total < nDrawCount_Cur)

  000cf	8b 46 58	 mov	 eax, DWORD PTR [esi+88]
  000d2	3b c7		 cmp	 eax, edi
  000d4	0f 8d 94 00 00
	00		 jge	 $LN10@GetPageCou

; 1912 : 	{
; 1913 : 		nDrawCount_Cur = m_nItemCount_Total;

  000da	8b f8		 mov	 edi, eax

; 1914 : 		dItemWidth = ( double)m_nScreenWidth_Cur[ 0] / ( double)max( nDrawCount_Cur, m_nMinDataCountOnOnePage);

  000dc	3b fb		 cmp	 edi, ebx
  000de	0f 4e c3	 cmovle	 eax, ebx
  000e1	66 0f 6e c0	 movd	 xmm0, eax
  000e5	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  000e9	f2 0f 5e d0	 divsd	 xmm2, xmm0

; 1915 : 		if( 0 < dItemWidth && dItemWidth < 1 && ceil( 1 / dItemWidth) != 1)

  000ed	66 0f 2f d4	 comisd	 xmm2, xmm4
  000f1	f2 0f 11 55 f8	 movsd	 QWORD PTR _dItemWidth$3$[ebp], xmm2
  000f6	76 4c		 jbe	 SHORT $LN8@GetPageCou
  000f8	66 0f 2f ca	 comisd	 xmm1, xmm2
  000fc	76 46		 jbe	 SHORT $LN8@GetPageCou
  000fe	0f 28 c1	 movaps	 xmm0, xmm1
  00101	83 ec 08	 sub	 esp, 8
  00104	f2 0f 5e c2	 divsd	 xmm0, xmm2
  00108	f2 0f 11 45 f0	 movsd	 QWORD PTR tv324[ebp], xmm0
  0010d	dd 45 f0	 fld	 QWORD PTR tv324[ebp]
  00110	dd 1c 24	 fstp	 QWORD PTR [esp]
  00113	e8 00 00 00 00	 call	 _ceil
  00118	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@3ff0000000000000
  00120	83 c4 08	 add	 esp, 8
  00123	dd 5d f0	 fstp	 QWORD PTR tv254[ebp]
  00126	f2 0f 10 4d f0	 movsd	 xmm1, QWORD PTR tv254[ebp]
  0012b	66 0f 2e c8	 ucomisd xmm1, xmm0
  0012f	9f		 lahf
  00130	f6 c4 44	 test	 ah, 68			; 00000044H
  00133	7b 0a		 jnp	 SHORT $LN16@GetPageCou

; 1916 : 				dItemWidth = 1.0 / ( ceil( 1 / dItemWidth) - 1);

  00135	f2 0f 5c c8	 subsd	 xmm1, xmm0
  00139	f2 0f 5e c1	 divsd	 xmm0, xmm1
  0013d	eb 12		 jmp	 SHORT $LN9@GetPageCou
$LN16@GetPageCou:

; 1915 : 		if( 0 < dItemWidth && dItemWidth < 1 && ceil( 1 / dItemWidth) != 1)

  0013f	f2 0f 10 55 f8	 movsd	 xmm2, QWORD PTR _dItemWidth$3$[ebp]
$LN8@GetPageCou:

; 1917 : 		else	dItemWidth = int( dItemWidth) + 1;

  00144	f2 0f 2c c2	 cvttsd2si eax, xmm2
  00148	40		 inc	 eax
  00149	66 0f 6e c0	 movd	 xmm0, eax
  0014d	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
$LN9@GetPageCou:

; 1918 : 		if( 0 < dItemWidth) nDrawCount_Cur = ( int)( ( double)m_nScreenWidth_Cur[ 0] / dItemWidth);

  00151	0f 57 c9	 xorps	 xmm1, xmm1
  00154	66 0f 2f c1	 comisd	 xmm0, xmm1
  00158	76 14		 jbe	 SHORT $LN10@GetPageCou
  0015a	66 0f 6e 8e 38
	03 00 00	 movd	 xmm1, DWORD PTR [esi+824]
  00162	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1
  00166	f2 0f 5e c8	 divsd	 xmm1, xmm0
  0016a	f2 0f 2c f9	 cvttsd2si edi, xmm1
$LN10@GetPageCou:

; 1919 : 	}
; 1920 : 	return nDrawCount_Cur;

  0016e	8b c7		 mov	 eax, edi
  00170	5f		 pop	 edi
  00171	5b		 pop	 ebx
  00172	5e		 pop	 esi

; 1921 : }

  00173	8b e5		 mov	 esp, ebp
  00175	5d		 pop	 ebp
  00176	c2 14 00	 ret	 20			; 00000014H
$LN3@GetPageCou:

; 1897 : 	if( 1 != m_nCountOfBlockColumn || m_nCountOfRQ == 0 || !m_bFixedInterval) return nSliderPos_New;

  00179	8b 45 0c	 mov	 eax, DWORD PTR _nSliderPos_New$[ebp]
  0017c	5e		 pop	 esi

; 1921 : }

  0017d	8b e5		 mov	 esp, ebp
  0017f	5d		 pop	 ebp
  00180	c2 14 00	 ret	 20			; 00000014H
?GetPageCountNextStep@CXScaleManagerImp@@UAEHHHHHH@Z ENDP ; CXScaleManagerImp::GetPageCountNextStep
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?GetStartEndDrawIdx_Cur@CXScaleManagerImp@@UAEXAAH0@Z
_TEXT	SEGMENT
_nStartDrawIdx$ = 8					; size = 4
_nEndDrawIdx$ = 12					; size = 4
?GetStartEndDrawIdx_Cur@CXScaleManagerImp@@UAEXAAH0@Z PROC ; CXScaleManagerImp::GetStartEndDrawIdx_Cur, COMDAT
; _this$ = ecx

; 1231 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1232 : 	nStartDrawIdx = m_nDRI_Start_Cur;

  00003	8b 45 08	 mov	 eax, DWORD PTR _nStartDrawIdx$[ebp]
  00006	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  00009	89 10		 mov	 DWORD PTR [eax], edx

; 1233 : 	nEndDrawIdx = m_nDRI_End_Cur;

  0000b	8b 45 0c	 mov	 eax, DWORD PTR _nEndDrawIdx$[ebp]
  0000e	8b 49 2c	 mov	 ecx, DWORD PTR [ecx+44]
  00011	89 08		 mov	 DWORD PTR [eax], ecx

; 1234 : }

  00013	5d		 pop	 ebp
  00014	c2 08 00	 ret	 8
?GetStartEndDrawIdx_Cur@CXScaleManagerImp@@UAEXAAH0@Z ENDP ; CXScaleManagerImp::GetStartEndDrawIdx_Cur
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?SetStartEndDrawIdx_Cur@CXScaleManagerImp@@UAEXHHH@Z
_TEXT	SEGMENT
_nStartDrawIdx$ = 8					; size = 4
_nEndDrawIdx$ = 12					; size = 4
_p_bMoreZoomIn$ = 16					; size = 4
?SetStartEndDrawIdx_Cur@CXScaleManagerImp@@UAEXHHH@Z PROC ; CXScaleManagerImp::SetStartEndDrawIdx_Cur, COMDAT
; _this$ = ecx

; 1237 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1238 : 	int nDrawCount = (nEndDrawIdx - nStartDrawIdx + 1);

  00003	8b 55 0c	 mov	 edx, DWORD PTR _nEndDrawIdx$[ebp]
  00006	8b c2		 mov	 eax, edx
  00008	2b 45 08	 sub	 eax, DWORD PTR _nStartDrawIdx$[ebp]
  0000b	53		 push	 ebx
  0000c	56		 push	 esi
  0000d	8b f1		 mov	 esi, ecx
  0000f	40		 inc	 eax

; 1239 : 	if( nDrawCount < m_nMinDataCountOnOnePage) nDrawCount = m_nMinDataCountOnOnePage;

  00010	8b 5e 34	 mov	 ebx, DWORD PTR [esi+52]

; 1240 : 
; 1241 : 	m_nDRI_End_Cur		= nEndDrawIdx;

  00013	3b c3		 cmp	 eax, ebx
  00015	89 56 2c	 mov	 DWORD PTR [esi+44], edx
  00018	0f 4d d8	 cmovge	 ebx, eax

; 1242 : 	m_nDRI_Start_Cur	= nEndDrawIdx - nDrawCount + 1;

  0001b	8b c2		 mov	 eax, edx
  0001d	2b c3		 sub	 eax, ebx
  0001f	83 c0 01	 add	 eax, 1
  00022	89 46 28	 mov	 DWORD PTR [esi+40], eax

; 1243 : 
; 1244 : 	// (2009/1/18 - Seung-Won, Bae) Check Limit.
; 1245 : 	if( m_nDRI_Start_Cur < 0)

  00025	79 0f		 jns	 SHORT $LN16@SetStartEn

; 1246 : 	{
; 1247 : 		m_nDRI_Start_Cur = 0;
; 1248 : 		m_nDRI_End_Cur = m_nDRI_Start_Cur + nDrawCount - 1;

  00027	8d 53 ff	 lea	 edx, DWORD PTR [ebx-1]
  0002a	c7 46 28 00 00
	00 00		 mov	 DWORD PTR [esi+40], 0
  00031	89 56 2c	 mov	 DWORD PTR [esi+44], edx
  00034	33 c0		 xor	 eax, eax
$LN16@SetStartEn:

; 1249 : 	}
; 1250 : 	// (2009/2/19 - Seung-Won, Bae) If no-data, Set view range to (0:ZoomValue) for accepting of ZoomValue.
; 1251 : 	if( 0 < m_nItemCount_Total && m_nItemCount_Total <= m_nDRI_End_Cur)

  00036	8b 4e 58	 mov	 ecx, DWORD PTR [esi+88]
  00039	85 c9		 test	 ecx, ecx
  0003b	7e 10		 jle	 SHORT $LN7@SetStartEn
  0003d	3b ca		 cmp	 ecx, edx
  0003f	7f 0c		 jg	 SHORT $LN7@SetStartEn

; 1252 : 	{
; 1253 : 		m_nDRI_End_Cur = m_nItemCount_Total - 1;

  00041	8d 41 ff	 lea	 eax, DWORD PTR [ecx-1]
  00044	89 46 2c	 mov	 DWORD PTR [esi+44], eax

; 1254 : 		m_nDRI_Start_Cur = m_nDRI_End_Cur - nDrawCount + 1;

  00047	2b c3		 sub	 eax, ebx
  00049	40		 inc	 eax
  0004a	89 46 28	 mov	 DWORD PTR [esi+40], eax
$LN7@SetStartEn:

; 1255 : 	}
; 1256 : 	if( m_nDRI_Start_Cur < 0)

  0004d	85 c0		 test	 eax, eax
  0004f	79 0f		 jns	 SHORT $LN8@SetStartEn

; 1257 : 	{
; 1258 : 		m_nDRI_Start_Cur = 0;
; 1259 : 		m_nDRI_End_Cur = m_nItemCount_Total - 1;

  00051	8d 41 ff	 lea	 eax, DWORD PTR [ecx-1]
  00054	c7 46 28 00 00
	00 00		 mov	 DWORD PTR [esi+40], 0
  0005b	89 46 2c	 mov	 DWORD PTR [esi+44], eax

; 1260 : 		nDrawCount = m_nItemCount_Total;

  0005e	8b d9		 mov	 ebx, ecx
$LN8@SetStartEn:

; 1261 : 	}
; 1262 : 		
; 1263 : 	if( m_nDrawCount_Cur != nDrawCount
; 1264 : 		|| m_pIChartCtrl->IsWholeView() && !m_bWholeViewPre
; 1265 : 		|| !m_pIChartCtrl->IsWholeView() && m_bWholeViewPre)

  00060	39 5e 30	 cmp	 DWORD PTR [esi+48], ebx
  00063	75 2e		 jne	 SHORT $LN10@SetStartEn
  00065	8b 4e 50	 mov	 ecx, DWORD PTR [esi+80]
  00068	8b 01		 mov	 eax, DWORD PTR [ecx]
  0006a	8b 40 50	 mov	 eax, DWORD PTR [eax+80]
  0006d	ff d0		 call	 eax
  0006f	84 c0		 test	 al, al
  00071	74 09		 je	 SHORT $LN19@SetStartEn
  00073	83 be f8 00 00
	00 00		 cmp	 DWORD PTR [esi+248], 0
  0007a	74 17		 je	 SHORT $LN10@SetStartEn
$LN19@SetStartEn:
  0007c	8b 4e 50	 mov	 ecx, DWORD PTR [esi+80]
  0007f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00081	8b 40 50	 mov	 eax, DWORD PTR [eax+80]
  00084	ff d0		 call	 eax
  00086	84 c0		 test	 al, al
  00088	75 2c		 jne	 SHORT $LN3@SetStartEn
  0008a	83 be f8 00 00
	00 00		 cmp	 DWORD PTR [esi+248], 0
  00091	74 23		 je	 SHORT $LN3@SetStartEn
$LN10@SetStartEn:
  00093	57		 push	 edi

; 1266 : 		for( int i = 0; i < m_nCountOfBlockColumn; i++) Calc_ItemWidth( i, nDrawCount, p_bMoreZoomIn);

  00094	33 ff		 xor	 edi, edi
  00096	39 be 2c 01 00
	00		 cmp	 DWORD PTR [esi+300], edi
  0009c	7e 17		 jle	 SHORT $LN20@SetStartEn
  0009e	66 90		 npad	 2
$LL4@SetStartEn:
  000a0	ff 75 10	 push	 DWORD PTR _p_bMoreZoomIn$[ebp]
  000a3	8b ce		 mov	 ecx, esi
  000a5	53		 push	 ebx
  000a6	57		 push	 edi
  000a7	e8 00 00 00 00	 call	 ?Calc_ItemWidth@CXScaleManagerImp@@IAEXHHH@Z ; CXScaleManagerImp::Calc_ItemWidth
  000ac	47		 inc	 edi
  000ad	3b be 2c 01 00
	00		 cmp	 edi, DWORD PTR [esi+300]
  000b3	7c eb		 jl	 SHORT $LL4@SetStartEn
$LN20@SetStartEn:
  000b5	5f		 pop	 edi
$LN3@SetStartEn:

; 1267 : 
; 1268 : 	// 3. Update ScrollBar and Zoom SliderBar
; 1269 : 	m_pIChartCtrl->UpdateZoomAndScrollInfo( m_nItemCount_Total, m_nDRI_Start_Cur, m_nDrawCount_Cur);

  000b6	8b 4e 50	 mov	 ecx, DWORD PTR [esi+80]
  000b9	ff 76 30	 push	 DWORD PTR [esi+48]
  000bc	ff 76 28	 push	 DWORD PTR [esi+40]
  000bf	8b 01		 mov	 eax, DWORD PTR [ecx]
  000c1	ff 76 58	 push	 DWORD PTR [esi+88]
  000c4	ff 90 10 08 00
	00		 call	 DWORD PTR [eax+2064]
  000ca	5e		 pop	 esi
  000cb	5b		 pop	 ebx

; 1270 : }

  000cc	5d		 pop	 ebp
  000cd	c2 0c 00	 ret	 12			; 0000000cH
?SetStartEndDrawIdx_Cur@CXScaleManagerImp@@UAEXHHH@Z ENDP ; CXScaleManagerImp::SetStartEndDrawIdx_Cur
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?GetEndDrawIdx_Cur@CXScaleManagerImp@@UAEHXZ
_TEXT	SEGMENT
?GetEndDrawIdx_Cur@CXScaleManagerImp@@UAEHXZ PROC	; CXScaleManagerImp::GetEndDrawIdx_Cur, COMDAT
; _this$ = ecx

; 1227 : 	return m_nDRI_End_Cur;

  00000	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]

; 1228 : }

  00003	c3		 ret	 0
?GetEndDrawIdx_Cur@CXScaleManagerImp@@UAEHXZ ENDP	; CXScaleManagerImp::GetEndDrawIdx_Cur
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?GetStartDrawIdx_Cur@CXScaleManagerImp@@UAEHXZ
_TEXT	SEGMENT
?GetStartDrawIdx_Cur@CXScaleManagerImp@@UAEHXZ PROC	; CXScaleManagerImp::GetStartDrawIdx_Cur, COMDAT
; _this$ = ecx

; 1206 : 	return m_nDRI_Start_Cur;

  00000	8b 41 28	 mov	 eax, DWORD PTR [ecx+40]

; 1207 : }

  00003	c3		 ret	 0
?GetStartDrawIdx_Cur@CXScaleManagerImp@@UAEHXZ ENDP	; CXScaleManagerImp::GetStartDrawIdx_Cur
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?GetDrawCount_Cur@CXScaleManagerImp@@UAEHXZ
_TEXT	SEGMENT
?GetDrawCount_Cur@CXScaleManagerImp@@UAEHXZ PROC	; CXScaleManagerImp::GetDrawCount_Cur, COMDAT
; _this$ = ecx

; 1191 : 	return m_nDrawCount_Cur;

  00000	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]

; 1192 : }

  00003	c3		 ret	 0
?GetDrawCount_Cur@CXScaleManagerImp@@UAEHXZ ENDP	; CXScaleManagerImp::GetDrawCount_Cur
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?GetCount@CXScaleManagerImp@@UAEHXZ
_TEXT	SEGMENT
?GetCount@CXScaleManagerImp@@UAEHXZ PROC		; CXScaleManagerImp::GetCount, COMDAT
; _this$ = ecx

; 1185 : 	return m_nItemCount_Total;	// the future count is included in total..

  00000	8b 41 58	 mov	 eax, DWORD PTR [ecx+88]

; 1186 : }

  00003	c3		 ret	 0
?GetCount@CXScaleManagerImp@@UAEHXZ ENDP		; CXScaleManagerImp::GetCount
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?SetIChartCtrl@CXScaleManagerImp@@UAEXPAUIChartCtrl@@@Z
_TEXT	SEGMENT
_p_pICharetCtrl$ = 8					; size = 4
?SetIChartCtrl@CXScaleManagerImp@@UAEXPAUIChartCtrl@@@Z PROC ; CXScaleManagerImp::SetIChartCtrl, COMDAT
; _this$ = ecx

; 2743 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 2744 : 	m_pIChartCtrl = p_pICharetCtrl;

  00006	8b 4d 08	 mov	 ecx, DWORD PTR _p_pICharetCtrl$[ebp]
  00009	89 4e 50	 mov	 DWORD PTR [esi+80], ecx

; 2745 : 	m_eChartMode = m_pIChartCtrl->GetChartMode();

  0000c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000e	ff 90 0c 03 00
	00		 call	 DWORD PTR [eax+780]
  00014	89 86 e8 05 00
	00		 mov	 DWORD PTR [esi+1512], eax
  0001a	5e		 pop	 esi

; 2746 : }

  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
?SetIChartCtrl@CXScaleManagerImp@@UAEXPAUIChartCtrl@@@Z ENDP ; CXScaleManagerImp::SetIChartCtrl
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?RealDataReceived@CXScaleManagerImp@@UAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_strRQ$ = 8						; size = 4
_p_bIndexedReal$ = 12					; size = 4
?RealDataReceived@CXScaleManagerImp@@UAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z PROC ; CXScaleManagerImp::RealDataReceived, COMDAT
; _this$ = ecx

; 1108 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?RealDataReceived@CXScaleManagerImp@@UAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f1		 mov	 esi, ecx

; 1109 : 	if( 0 == m_nCountOfRQ)

  00027	83 7e 6c 00	 cmp	 DWORD PTR [esi+108], 0
  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00032	75 11		 jne	 SHORT $LN3@RealDataRe

; 1110 : 	{
; 1111 : 		// (2009/1/11 - Seung-Won, Bae) for X Scale Manager's Calc_DRI
; 1112 : 		Calc_DRI();

  00034	8b 06		 mov	 eax, DWORD PTR [esi]
  00036	6a 01		 push	 1
  00038	ff 50 6c	 call	 DWORD PTR [eax+108]

; 1113 : 		if( 0 == m_nCountOfRQ) return;

  0003b	83 7e 6c 00	 cmp	 DWORD PTR [esi+108], 0
  0003f	0f 84 97 00 00
	00		 je	 $LN6@RealDataRe
$LN3@RealDataRe:

; 1114 : 	}
; 1115 : 
; 1116 : 	// Set Real Flag.
; 1117 : 	int nRQ = GetRQIndexFromString( strRQ);

  00045	51		 push	 ecx
  00046	8d 45 08	 lea	 eax, DWORD PTR _strRQ$[ebp]
  00049	8b cc		 mov	 ecx, esp
  0004b	50		 push	 eax
  0004c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z
  00052	8b 06		 mov	 eax, DWORD PTR [esi]
  00054	8b ce		 mov	 ecx, esi
  00056	ff 50 04	 call	 DWORD PTR [eax+4]
  00059	8b f8		 mov	 edi, eax

; 1118 : 	if( nRQ < 0) return;

  0005b	85 ff		 test	 edi, edi
  0005d	78 7d		 js	 SHORT $LN6@RealDataRe

; 1119 : 
; 1120 : 	if( p_bIndexedReal)

  0005f	83 7d 0c 00	 cmp	 DWORD PTR _p_bIndexedReal$[ebp], 0
  00063	74 1c		 je	 SHORT $LN5@RealDataRe

; 1121 : 	{
; 1122 : 		m_nNeedCalcArea = 2;
; 1123 : 		m_pifaRQ[ nRQ]->nUpdatedRealDRI = -1;

  00065	8b 86 8c 00 00
	00		 mov	 eax, DWORD PTR [esi+140]
  0006b	c7 86 fc 00 00
	00 02 00 00 00	 mov	 DWORD PTR [esi+252], 2
  00075	8b 04 b8	 mov	 eax, DWORD PTR [eax+edi*4]
  00078	c7 40 30 ff ff
	ff ff		 mov	 DWORD PTR [eax+48], -1

; 1124 : 	}

  0007f	eb 5b		 jmp	 SHORT $LN6@RealDataRe
$LN5@RealDataRe:

; 1125 : 	else
; 1126 : 	{
; 1127 : 		if( 0 == m_nNeedCalcArea) m_nNeedCalcArea = 1;	// the Flag on by DRI() with full(2) or partial(1)

  00081	83 be fc 00 00
	00 00		 cmp	 DWORD PTR [esi+252], 0
  00088	75 0a		 jne	 SHORT $LN7@RealDataRe
  0008a	c7 86 fc 00 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+252], 1
$LN7@RealDataRe:

; 1128 : 														// Do not reset 2 with 1.
; 1129 : 
; 1130 : 		if( m_pifaRQ[ nRQ]->nUpdatedRealDRI != INT_MAX)

  00094	8b 86 8c 00 00
	00		 mov	 eax, DWORD PTR [esi+140]
  0009a	8b 0c b8	 mov	 ecx, DWORD PTR [eax+edi*4]
  0009d	81 79 30 ff ff
	ff 7f		 cmp	 DWORD PTR [ecx+48], 2147483647 ; 7fffffffH
  000a4	74 26		 je	 SHORT $LN9@RealDataRe

; 1132 : 			m_pIReturn = m_pblaDRIfDTI[ nRQ]->GetAt( m_pifaRQ[ nRQ]->nLastRealDTI);

  000a6	8b 86 a0 00 00
	00		 mov	 eax, DWORD PTR [esi+160]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 215  : 	T*	GetAt( int nIndex)	{	return ( T*)GetAtUNK( nIndex);	}

  000ac	ff 71 28	 push	 DWORD PTR [ecx+40]
  000af	8b 0c b8	 mov	 ecx, DWORD PTR [eax+edi*4]
  000b2	e8 00 00 00 00	 call	 ?GetAtUNK@CDataBlockListUNK@@QAEPAXH@Z ; CDataBlockListUNK::GetAtUNK
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 1132 : 			m_pIReturn = m_pblaDRIfDTI[ nRQ]->GetAt( m_pifaRQ[ nRQ]->nLastRealDTI);

  000b7	89 46 60	 mov	 DWORD PTR [esi+96], eax

; 1133 : 			if( m_pIReturn) m_pifaRQ[ nRQ]->nUpdatedRealDRI = *m_pIReturn;

  000ba	85 c0		 test	 eax, eax
  000bc	74 0e		 je	 SHORT $LN9@RealDataRe
  000be	8b 8e 8c 00 00
	00		 mov	 ecx, DWORD PTR [esi+140]
  000c4	8b 00		 mov	 eax, DWORD PTR [eax]
  000c6	8b 0c b9	 mov	 ecx, DWORD PTR [ecx+edi*4]
  000c9	89 41 30	 mov	 DWORD PTR [ecx+48], eax
$LN9@RealDataRe:

; 1134 : 		}
; 1135 : 
; 1136 : 		m_pifaRQ[ nRQ]->bRealReceived = TRUE;

  000cc	8b 86 8c 00 00
	00		 mov	 eax, DWORD PTR [esi+140]
  000d2	8b 04 b8	 mov	 eax, DWORD PTR [eax+edi*4]
  000d5	c7 40 2c 01 00
	00 00		 mov	 DWORD PTR [eax+44], 1
$LN6@RealDataRe:

; 1137 : 	}
; 1138 : }

  000dc	8d 4d 08	 lea	 ecx, DWORD PTR _strRQ$[ebp]
  000df	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  000e5	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000e8	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ef	59		 pop	 ecx
  000f0	5f		 pop	 edi
  000f1	5e		 pop	 esi
  000f2	8b e5		 mov	 esp, ebp
  000f4	5d		 pop	 ebp
  000f5	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?RealDataReceived@CXScaleManagerImp@@UAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z$0:
  00000	8d 4d 08	 lea	 ecx, DWORD PTR _strRQ$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
  0000d	cc		 int	 3
__ehhandler$?RealDataReceived@CXScaleManagerImp@@UAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z:
  0000e	90		 npad	 1
  0000f	90		 npad	 1
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?RealDataReceived@CXScaleManagerImp@@UAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z
  00026	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?RealDataReceived@CXScaleManagerImp@@UAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z ENDP ; CXScaleManagerImp::RealDataReceived
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?Clear_OEBTRQ@CXScaleManagerImp@@UAEXXZ
_TEXT	SEGMENT
?Clear_OEBTRQ@CXScaleManagerImp@@UAEXXZ PROC		; CXScaleManagerImp::Clear_OEBTRQ, COMDAT
; _this$ = ecx

; 288  : {

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f9		 mov	 edi, ecx

; 289  : 	// (2008/12/29 - Seung-Won, Bae) Do not use m_mifOEBT. Use m_pifaOEBT.
; 290  : 	//	MAP_RQ_OEBT::iterator it = m_mifOEBT.begin();
; 291  : 	//	while(it != m_mifOEBT.end())
; 292  : 	//	{
; 293  : 	//		delete it->second;
; 294  : 	//		it++;
; 295  : 	//	}
; 296  : 	//	m_mifOEBT.clear();
; 297  : 	for( int nRQ = 0; nRQ < m_nCountOfRQ; nRQ++) if( m_pifaOEBT[ nRQ])

  00004	33 f6		 xor	 esi, esi
  00006	39 77 6c	 cmp	 DWORD PTR [edi+108], esi
  00009	7e 39		 jle	 SHORT $LN3@Clear_OEBT
  0000b	53		 push	 ebx
  0000c	0f 1f 40 00	 npad	 4
$LL4@Clear_OEBT:
  00010	8b 87 90 00 00
	00		 mov	 eax, DWORD PTR [edi+144]
  00016	8b 1c b0	 mov	 ebx, DWORD PTR [eax+esi*4]
  00019	85 db		 test	 ebx, ebx
  0001b	74 20		 je	 SHORT $LN2@Clear_OEBT

; 298  : 	{
; 299  : 		delete m_pifaOEBT[ nRQ];
; 300  : 		m_pifaOEBT[ nRQ] = NULL;

  0001d	8b cb		 mov	 ecx, ebx
  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00025	6a 08		 push	 8
  00027	53		 push	 ebx
  00028	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002d	8b 87 90 00 00
	00		 mov	 eax, DWORD PTR [edi+144]
  00033	83 c4 08	 add	 esp, 8
  00036	c7 04 b0 00 00
	00 00		 mov	 DWORD PTR [eax+esi*4], 0
$LN2@Clear_OEBT:

; 289  : 	// (2008/12/29 - Seung-Won, Bae) Do not use m_mifOEBT. Use m_pifaOEBT.
; 290  : 	//	MAP_RQ_OEBT::iterator it = m_mifOEBT.begin();
; 291  : 	//	while(it != m_mifOEBT.end())
; 292  : 	//	{
; 293  : 	//		delete it->second;
; 294  : 	//		it++;
; 295  : 	//	}
; 296  : 	//	m_mifOEBT.clear();
; 297  : 	for( int nRQ = 0; nRQ < m_nCountOfRQ; nRQ++) if( m_pifaOEBT[ nRQ])

  0003d	46		 inc	 esi
  0003e	3b 77 6c	 cmp	 esi, DWORD PTR [edi+108]
  00041	7c cd		 jl	 SHORT $LL4@Clear_OEBT
  00043	5b		 pop	 ebx
$LN3@Clear_OEBT:
  00044	5f		 pop	 edi

; 301  : 	}
; 302  : }

  00045	5e		 pop	 esi
  00046	c3		 ret	 0
?Clear_OEBTRQ@CXScaleManagerImp@@UAEXXZ ENDP		; CXScaleManagerImp::Clear_OEBTRQ
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?DelOEBTRQ@CXScaleManagerImp@@UAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_strRQ$ = 8						; size = 4
?DelOEBTRQ@CXScaleManagerImp@@UAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z PROC ; CXScaleManagerImp::DelOEBTRQ, COMDAT
; _this$ = ecx

; 278  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?DelOEBTRQ@CXScaleManagerImp@@UAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	53		 push	 ebx
  00013	56		 push	 esi
  00014	57		 push	 edi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8b f9		 mov	 edi, ecx

; 279  : 	int nRQ = GetRQIndexFromString( strRQ);

  00028	51		 push	 ecx
  00029	8d 45 08	 lea	 eax, DWORD PTR _strRQ$[ebp]
  0002c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00033	8b cc		 mov	 ecx, esp
  00035	50		 push	 eax
  00036	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z
  0003c	8b 07		 mov	 eax, DWORD PTR [edi]
  0003e	8b cf		 mov	 ecx, edi
  00040	ff 50 04	 call	 DWORD PTR [eax+4]
  00043	8b d8		 mov	 ebx, eax

; 280  : 	if( 0 <= nRQ)

  00045	85 db		 test	 ebx, ebx
  00047	78 2d		 js	 SHORT $LN2@DelOEBTRQ

; 281  : 	{
; 282  : 		delete m_pifaOEBT[ nRQ];

  00049	8b 87 90 00 00
	00		 mov	 eax, DWORD PTR [edi+144]
  0004f	8b 34 98	 mov	 esi, DWORD PTR [eax+ebx*4]
  00052	85 f6		 test	 esi, esi
  00054	74 19		 je	 SHORT $LN9@DelOEBTRQ
  00056	8b ce		 mov	 ecx, esi
  00058	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0005e	6a 08		 push	 8
  00060	56		 push	 esi
  00061	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00066	8b 87 90 00 00
	00		 mov	 eax, DWORD PTR [edi+144]
  0006c	83 c4 08	 add	 esp, 8
$LN9@DelOEBTRQ:

; 283  : 		m_pifaOEBT[ nRQ] = NULL;

  0006f	c7 04 98 00 00
	00 00		 mov	 DWORD PTR [eax+ebx*4], 0
$LN2@DelOEBTRQ:

; 284  : 	}
; 285  : }

  00076	8d 4d 08	 lea	 ecx, DWORD PTR _strRQ$[ebp]
  00079	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0007f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00082	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00089	59		 pop	 ecx
  0008a	5f		 pop	 edi
  0008b	5e		 pop	 esi
  0008c	5b		 pop	 ebx
  0008d	8b e5		 mov	 esp, ebp
  0008f	5d		 pop	 ebp
  00090	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DelOEBTRQ@CXScaleManagerImp@@UAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z$0:
  00000	8d 4d 08	 lea	 ecx, DWORD PTR _strRQ$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
  0000d	cc		 int	 3
__ehhandler$?DelOEBTRQ@CXScaleManagerImp@@UAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z:
  0000e	90		 npad	 1
  0000f	90		 npad	 1
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?DelOEBTRQ@CXScaleManagerImp@@UAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
  00026	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?DelOEBTRQ@CXScaleManagerImp@@UAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ENDP ; CXScaleManagerImp::DelOEBTRQ
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?AddOEBTRQ@CXScaleManagerImp@@UAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@00@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_strRQ$ = 8						; size = 4
_strGraphName$ = 12					; size = 4
_strIndicatorName$ = 16					; size = 4
?AddOEBTRQ@CXScaleManagerImp@@UAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@00@Z PROC ; CXScaleManagerImp::AddOEBTRQ, COMDAT
; _this$ = ecx

; 254  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?AddOEBTRQ@CXScaleManagerImp@@UAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@00@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	53		 push	 ebx
  00013	56		 push	 esi
  00014	57		 push	 edi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8b f9		 mov	 edi, ecx

; 255  : 	//  Span .
; 256  : 	CIndicatorInfo* pInfo = m_pIndicatorList->GetGraphIndicatorInfo(EILT_USER, strGraphName, strIndicatorName, EIIGT_WITHOUT_DEFAULT);

  00028	8b 4f 4c	 mov	 ecx, DWORD PTR [edi+76]
  0002b	6a 00		 push	 0
  0002d	ff 75 10	 push	 DWORD PTR _strIndicatorName$[ebp]
  00030	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  00037	ff 75 0c	 push	 DWORD PTR _strGraphName$[ebp]
  0003a	6a 03		 push	 3
  0003c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetGraphIndicatorInfo@CIndicatorList@@QAEPAVCIndicatorInfo@@W4EIndicatorListType@@PBD1W4EIndicatorInfoGettingType@@@Z

; 257  : 	if(pInfo == NULL) return;

  00042	85 c0		 test	 eax, eax
  00044	74 79		 je	 SHORT $LN29@AddOEBTRQ

; 258  : 
; 259  : 	CList<double, double>* pList = pInfo->GetCommonCalConditionList();

  00046	8b c8		 mov	 ecx, eax
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetCommonCalConditionList@CIndicatorInfo@@QAEPAV?$CList@NN@@XZ

; 260  : 	if(pList == NULL) return;

  0004e	85 c0		 test	 eax, eax
  00050	74 6d		 je	 SHORT $LN29@AddOEBTRQ

; 261  : 
; 262  : 	POSITION pos = pList->GetHeadPosition();

  00052	8b 58 04	 mov	 ebx, DWORD PTR [eax+4]

; 263  : 	if(pos == NULL) return;

  00055	85 db		 test	 ebx, ebx
  00057	74 66		 je	 SHORT $LN29@AddOEBTRQ

; 264  : 
; 265  : 	POEBT_INFO poebtinfo = new OEBT_INFO;

  00059	6a 08		 push	 8
  0005b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00060	8b f0		 mov	 esi, eax
  00062	83 c4 04	 add	 esp, 4
  00065	85 f6		 test	 esi, esi
  00067	74 0a		 je	 SHORT $LN8@AddOEBTRQ
  00069	8b ce		 mov	 ecx, esi
  0006b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00071	eb 02		 jmp	 SHORT $LN9@AddOEBTRQ
$LN8@AddOEBTRQ:
  00073	33 f6		 xor	 esi, esi
$LN9@AddOEBTRQ:

; 266  : 	poebtinfo->strGraphName = strGraphName;

  00075	8d 45 0c	 lea	 eax, DWORD PTR _strGraphName$[ebp]
  00078	8b ce		 mov	 ecx, esi
  0007a	50		 push	 eax
  0007b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z

; 267  : 
; 268  : 	double dCalcCond = 0;
; 269  : 	dCalcCond = pList->GetNext(pos);
; 270  : 	poebtinfo->nFutureCount = int(dCalcCond);

  00081	f2 0f 2c 43 08	 cvttsd2si eax, QWORD PTR [ebx+8]

; 271  : 
; 272  : 	int nRQ = GetRQIndexFromString( strRQ);

  00086	51		 push	 ecx
  00087	8b cc		 mov	 ecx, esp
  00089	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0008c	8d 45 08	 lea	 eax, DWORD PTR _strRQ$[ebp]
  0008f	50		 push	 eax
  00090	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z
  00096	8b 07		 mov	 eax, DWORD PTR [edi]
  00098	8b cf		 mov	 ecx, edi
  0009a	ff 50 04	 call	 DWORD PTR [eax+4]

; 273  : 	if( 0 <= nRQ) m_pifaOEBT[ nRQ] = poebtinfo;

  0009d	85 c0		 test	 eax, eax
  0009f	78 0b		 js	 SHORT $LN5@AddOEBTRQ
  000a1	8b 8f 90 00 00
	00		 mov	 ecx, DWORD PTR [edi+144]
  000a7	89 34 81	 mov	 DWORD PTR [ecx+eax*4], esi
  000aa	eb 13		 jmp	 SHORT $LN29@AddOEBTRQ
$LN5@AddOEBTRQ:
  000ac	8b ce		 mov	 ecx, esi
  000ae	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  000b4	6a 08		 push	 8
  000b6	56		 push	 esi
  000b7	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  000bc	83 c4 08	 add	 esp, 8
$LN29@AddOEBTRQ:

; 274  : 	else delete poebtinfo;
; 275  : }

  000bf	8d 4d 08	 lea	 ecx, DWORD PTR _strRQ$[ebp]
  000c2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  000c8	8d 4d 0c	 lea	 ecx, DWORD PTR _strGraphName$[ebp]
  000cb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  000d1	8d 4d 10	 lea	 ecx, DWORD PTR _strIndicatorName$[ebp]
  000d4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  000da	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000dd	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000e4	59		 pop	 ecx
  000e5	5f		 pop	 edi
  000e6	5e		 pop	 esi
  000e7	5b		 pop	 ebx
  000e8	8b e5		 mov	 esp, ebp
  000ea	5d		 pop	 ebp
  000eb	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AddOEBTRQ@CXScaleManagerImp@@UAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@00@Z$0:
  00000	8d 4d 10	 lea	 ecx, DWORD PTR _strIndicatorName$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?AddOEBTRQ@CXScaleManagerImp@@UAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@00@Z$1:
  00009	8d 4d 0c	 lea	 ecx, DWORD PTR _strGraphName$[ebp]
  0000c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?AddOEBTRQ@CXScaleManagerImp@@UAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@00@Z$2:
  00012	8d 4d 08	 lea	 ecx, DWORD PTR _strRQ$[ebp]
  00015	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0001b	cc		 int	 3
  0001c	cc		 int	 3
  0001d	cc		 int	 3
  0001e	cc		 int	 3
  0001f	cc		 int	 3
__ehhandler$?AddOEBTRQ@CXScaleManagerImp@@UAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@00@Z:
  00020	90		 npad	 1
  00021	90		 npad	 1
  00022	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00026	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00029	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  0002c	33 c8		 xor	 ecx, eax
  0002e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00033	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?AddOEBTRQ@CXScaleManagerImp@@UAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@00@Z
  00038	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?AddOEBTRQ@CXScaleManagerImp@@UAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@00@Z ENDP ; CXScaleManagerImp::AddOEBTRQ
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?IsFixedInterval@CXScaleManagerImp@@UAEHXZ
_TEXT	SEGMENT
?IsFixedInterval@CXScaleManagerImp@@UAEHXZ PROC		; CXScaleManagerImp::IsFixedInterval, COMDAT
; _this$ = ecx

; 2768 : 	return m_bFixedInterval;

  00000	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]

; 2769 : }

  00003	c3		 ret	 0
?IsFixedInterval@CXScaleManagerImp@@UAEHXZ ENDP		; CXScaleManagerImp::IsFixedInterval
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?SetFixedInterval@CXScaleManagerImp@@UAEXHH@Z
_TEXT	SEGMENT
_bFixedInterval$ = 8					; size = 4
_bCalc$ = 12						; size = 4
?SetFixedInterval@CXScaleManagerImp@@UAEXHH@Z PROC	; CXScaleManagerImp::SetFixedInterval, COMDAT
; _this$ = ecx

; 2750 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2751 : 	if( m_bFixedInterval && bFixedInterval
; 2752 : 		|| !m_bFixedInterval && !bFixedInterval) return;

  00003	8b 45 08	 mov	 eax, DWORD PTR _bFixedInterval$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	83 7e 24 00	 cmp	 DWORD PTR [esi+36], 0
  0000d	74 06		 je	 SHORT $LN14@SetFixedIn
  0000f	85 c0		 test	 eax, eax
  00011	75 6a		 jne	 SHORT $LN8@SetFixedIn
  00013	eb 04		 jmp	 SHORT $LN5@SetFixedIn
$LN14@SetFixedIn:
  00015	85 c0		 test	 eax, eax
  00017	74 64		 je	 SHORT $LN8@SetFixedIn
$LN5@SetFixedIn:

; 2753 : 
; 2754 : 	m_bFixedInterval = bFixedInterval;
; 2755 : 	if( bCalc && !m_pIChartCtrl->IsWholeView())

  00019	83 7d 0c 00	 cmp	 DWORD PTR _bCalc$[ebp], 0
  0001d	89 46 24	 mov	 DWORD PTR [esi+36], eax
  00020	74 5b		 je	 SHORT $LN8@SetFixedIn
  00022	8b 4e 50	 mov	 ecx, DWORD PTR [esi+80]
  00025	8b 01		 mov	 eax, DWORD PTR [ecx]
  00027	8b 40 50	 mov	 eax, DWORD PTR [eax+80]
  0002a	ff d0		 call	 eax
  0002c	84 c0		 test	 al, al
  0002e	75 4d		 jne	 SHORT $LN8@SetFixedIn

; 2756 : 	{
; 2757 : 		m_pIChartCtrl->ZoomTo( m_pIChartCtrl->GetOnePageDataCount(), FALSE);

  00030	8b 4e 50	 mov	 ecx, DWORD PTR [esi+80]
  00033	57		 push	 edi
  00034	6a 00		 push	 0
  00036	8b 39		 mov	 edi, DWORD PTR [ecx]
  00038	ff 97 24 04 00
	00		 call	 DWORD PTR [edi+1060]
  0003e	8b 4e 50	 mov	 ecx, DWORD PTR [esi+80]
  00041	50		 push	 eax
  00042	ff 97 a4 02 00
	00		 call	 DWORD PTR [edi+676]

; 2758 : 
; 2759 : 		for( int i = 0; i < m_nCountOfBlockColumn; i++) Calc_ItemWidth( i, m_nDrawCount_Cur);

  00048	33 ff		 xor	 edi, edi
  0004a	39 be 2c 01 00
	00		 cmp	 DWORD PTR [esi+300], edi
  00050	7e 16		 jle	 SHORT $LN3@SetFixedIn
$LL4@SetFixedIn:
  00052	6a 00		 push	 0
  00054	ff 76 30	 push	 DWORD PTR [esi+48]
  00057	8b ce		 mov	 ecx, esi
  00059	57		 push	 edi
  0005a	e8 00 00 00 00	 call	 ?Calc_ItemWidth@CXScaleManagerImp@@IAEXHHH@Z ; CXScaleManagerImp::Calc_ItemWidth
  0005f	47		 inc	 edi
  00060	3b be 2c 01 00
	00		 cmp	 edi, DWORD PTR [esi+300]
  00066	7c ea		 jl	 SHORT $LL4@SetFixedIn
$LN3@SetFixedIn:

; 2760 : 
; 2761 : 		// 3. Update ScrollBar and Zoom SliderBar
; 2762 : 		m_pIChartCtrl->UpdateZoomAndScrollInfo( m_nItemCount_Total, m_nDRI_Start_Cur, m_nDrawCount_Cur);

  00068	8b 4e 50	 mov	 ecx, DWORD PTR [esi+80]
  0006b	ff 76 30	 push	 DWORD PTR [esi+48]
  0006e	ff 76 28	 push	 DWORD PTR [esi+40]
  00071	8b 01		 mov	 eax, DWORD PTR [ecx]
  00073	ff 76 58	 push	 DWORD PTR [esi+88]
  00076	ff 90 10 08 00
	00		 call	 DWORD PTR [eax+2064]
  0007c	5f		 pop	 edi
$LN8@SetFixedIn:
  0007d	5e		 pop	 esi

; 2763 : 	}
; 2764 : }

  0007e	5d		 pop	 ebp
  0007f	c2 08 00	 ret	 8
?SetFixedInterval@CXScaleManagerImp@@UAEXHH@Z ENDP	; CXScaleManagerImp::SetFixedInterval
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?GetCandleTypeOnResize@CXScaleManagerImp@@UAE?AW4RSA_TYPE@CXScaleManager@@XZ
_TEXT	SEGMENT
?GetCandleTypeOnResize@CXScaleManagerImp@@UAE?AW4RSA_TYPE@CXScaleManager@@XZ PROC ; CXScaleManagerImp::GetCandleTypeOnResize, COMDAT
; _this$ = ecx

; 250  : 	return m_rstype;

  00000	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]

; 251  : }

  00003	c3		 ret	 0
?GetCandleTypeOnResize@CXScaleManagerImp@@UAE?AW4RSA_TYPE@CXScaleManager@@XZ ENDP ; CXScaleManagerImp::GetCandleTypeOnResize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?SetCandleTypeOnResize@CXScaleManagerImp@@UAEXW4RSA_TYPE@CXScaleManager@@@Z
_TEXT	SEGMENT
_rstype$ = 8						; size = 4
?SetCandleTypeOnResize@CXScaleManagerImp@@UAEXW4RSA_TYPE@CXScaleManager@@@Z PROC ; CXScaleManagerImp::SetCandleTypeOnResize, COMDAT
; _this$ = ecx

; 243  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 244  : 	m_rstype = rstype;

  00003	8b 45 08	 mov	 eax, DWORD PTR _rstype$[ebp]

; 245  : 	if( m_nCountOfBlockColumn > 1) m_rstype = RSAT_ITEM_COUNT_FIX;

  00006	33 d2		 xor	 edx, edx
  00008	83 b9 2c 01 00
	00 01		 cmp	 DWORD PTR [ecx+300], 1
  0000f	0f 4f c2	 cmovg	 eax, edx
  00012	89 41 20	 mov	 DWORD PTR [ecx+32], eax

; 246  : }

  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
?SetCandleTypeOnResize@CXScaleManagerImp@@UAEXW4RSA_TYPE@CXScaleManager@@@Z ENDP ; CXScaleManagerImp::SetCandleTypeOnResize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?SetRightMarginWidth@CXScaleManagerImp@@UAEXH@Z
_TEXT	SEGMENT
_nRightMarginWidth$ = 8					; size = 4
?SetRightMarginWidth@CXScaleManagerImp@@UAEXH@Z PROC	; CXScaleManagerImp::SetRightMarginWidth, COMDAT
; _this$ = ecx

; 224  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 225  : 	m_nRightMarginWidth = nRightMarginWidth * 8;

  00003	8b 45 08	 mov	 eax, DWORD PTR _nRightMarginWidth$[ebp]
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	c1 e0 03	 shl	 eax, 3
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h

; 686  : 	::InflateRect(this, x, y);

  0000d	6a 01		 push	 1
  0000f	6a 01		 push	 1
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 225  : 	m_nRightMarginWidth = nRightMarginWidth * 8;

  00011	89 46 1c	 mov	 DWORD PTR [esi+28], eax

; 226  : 
; 227  : 	// (2009/5/12 - Seung-Won, Bae) for Fixed Item Width
; 228  : 	m_rctClient.InflateRect( 1, 1);

  00014	8d 86 b8 05 00
	00		 lea	 eax, DWORD PTR [esi+1464]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h

; 686  : 	::InflateRect(this, x, y);

  0001a	50		 push	 eax
  0001b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InflateRect@12
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 230  : 	for( int i = 0; i < m_nCountOfBlockColumn; i++)

  00021	33 db		 xor	 ebx, ebx
  00023	39 9e 2c 01 00
	00		 cmp	 DWORD PTR [esi+300], ebx
  00029	7e 26		 jle	 SHORT $LN3@SetRightMa

; 225  : 	m_nRightMarginWidth = nRightMarginWidth * 8;

  0002b	57		 push	 edi
  0002c	8d be 58 01 00
	00		 lea	 edi, DWORD PTR [esi+344]
$LL4@SetRightMa:

; 231  : 		SetScreenRegion( i, m_naScreenRegionLeft[ i], m_naScreenRegionWidth[ i], TRUE);

  00032	8b 06		 mov	 eax, DWORD PTR [esi]
  00034	8b ce		 mov	 ecx, esi
  00036	6a 01		 push	 1
  00038	ff 77 28	 push	 DWORD PTR [edi+40]
  0003b	ff 37		 push	 DWORD PTR [edi]
  0003d	53		 push	 ebx
  0003e	ff 90 54 01 00
	00		 call	 DWORD PTR [eax+340]
  00044	43		 inc	 ebx
  00045	8d 7f 04	 lea	 edi, DWORD PTR [edi+4]
  00048	3b 9e 2c 01 00
	00		 cmp	 ebx, DWORD PTR [esi+300]
  0004e	7c e2		 jl	 SHORT $LL4@SetRightMa
  00050	5f		 pop	 edi
$LN3@SetRightMa:
  00051	5e		 pop	 esi

; 232  : }

  00052	5b		 pop	 ebx
  00053	5d		 pop	 ebp
  00054	c2 04 00	 ret	 4
?SetRightMarginWidth@CXScaleManagerImp@@UAEXH@Z ENDP	; CXScaleManagerImp::SetRightMarginWidth
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?SetUseOEBTMargin@CXScaleManagerImp@@UAEXH@Z
_TEXT	SEGMENT
_bUseOEBTMargin$ = 8					; size = 4
?SetUseOEBTMargin@CXScaleManagerImp@@UAEXH@Z PROC	; CXScaleManagerImp::SetUseOEBTMargin, COMDAT
; _this$ = ecx

; 218  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 219  : 	m_bUseOEBTMargin = bUseOEBTMargin;

  00003	8b 45 08	 mov	 eax, DWORD PTR _bUseOEBTMargin$[ebp]
  00006	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 220  : }

  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?SetUseOEBTMargin@CXScaleManagerImp@@UAEXH@Z ENDP	; CXScaleManagerImp::SetUseOEBTMargin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?GetUseOEBTMargin@CXScaleManagerImp@@UAEHXZ
_TEXT	SEGMENT
?GetUseOEBTMargin@CXScaleManagerImp@@UAEHXZ PROC	; CXScaleManagerImp::GetUseOEBTMargin, COMDAT
; _this$ = ecx

; 214  : 	return m_bUseOEBTMargin;

  00000	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]

; 215  : }

  00003	c3		 ret	 0
?GetUseOEBTMargin@CXScaleManagerImp@@UAEHXZ ENDP	; CXScaleManagerImp::GetUseOEBTMargin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?GetLeftDataHideCount@CXScaleManagerImp@@UAEHXZ
_TEXT	SEGMENT
?GetLeftDataHideCount@CXScaleManagerImp@@UAEHXZ PROC	; CXScaleManagerImp::GetLeftDataHideCount, COMDAT
; _this$ = ecx

; 208  : 	return m_nLeftDataHideCount;

  00000	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]

; 209  : }

  00003	c3		 ret	 0
?GetLeftDataHideCount@CXScaleManagerImp@@UAEHXZ ENDP	; CXScaleManagerImp::GetLeftDataHideCount
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?SetLeftDataHideCount@CXScaleManagerImp@@UAEXHH@Z
_TEXT	SEGMENT
_nLeftDataHideCount$ = 8				; size = 4
_bCalc$ = 12						; size = 4
?SetLeftDataHideCount@CXScaleManagerImp@@UAEXHH@Z PROC	; CXScaleManagerImp::SetLeftDataHideCount, COMDAT
; _this$ = ecx

; 200  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 201  : 	m_nLeftDataHideCount = nLeftDataHideCount;
; 202  : 	// (2009/1/11 - Seung-Won, Bae) for X Scale Manager's Calc_DRI
; 203  : 	if( bCalc) Calc_DRI();

  00003	83 7d 0c 00	 cmp	 DWORD PTR _bCalc$[ebp], 0
  00007	8b 45 08	 mov	 eax, DWORD PTR _nLeftDataHideCount$[ebp]
  0000a	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  0000d	74 07		 je	 SHORT $LN2@SetLeftDat
  0000f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00011	6a 01		 push	 1
  00013	ff 50 6c	 call	 DWORD PTR [eax+108]
$LN2@SetLeftDat:

; 204  : }

  00016	5d		 pop	 ebp
  00017	c2 08 00	 ret	 8
?SetLeftDataHideCount@CXScaleManagerImp@@UAEXHH@Z ENDP	; CXScaleManagerImp::SetLeftDataHideCount
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?GetWeightedVolume@CXScaleManagerImp@@UAEHXZ
_TEXT	SEGMENT
?GetWeightedVolume@CXScaleManagerImp@@UAEHXZ PROC	; CXScaleManagerImp::GetWeightedVolume, COMDAT
; _this$ = ecx

; 180  : 	return m_bWeightedVolume;

  00000	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]

; 181  : }

  00003	c3		 ret	 0
?GetWeightedVolume@CXScaleManagerImp@@UAEHXZ ENDP	; CXScaleManagerImp::GetWeightedVolume
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?SetWeightedVolume@CXScaleManagerImp@@UAEXHH@Z
_TEXT	SEGMENT
_bWeightedVolume$ = 8					; size = 4
_bCalc$ = 12						; size = 4
?SetWeightedVolume@CXScaleManagerImp@@UAEXHH@Z PROC	; CXScaleManagerImp::SetWeightedVolume, COMDAT
; _this$ = ecx

; 174  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 175  : 	m_bWeightedVolume = bWeightedVolume;

  00003	8b 45 08	 mov	 eax, DWORD PTR _bWeightedVolume$[ebp]
  00006	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 176  : }

  00009	5d		 pop	 ebp
  0000a	c2 08 00	 ret	 8
?SetWeightedVolume@CXScaleManagerImp@@UAEXHH@Z ENDP	; CXScaleManagerImp::SetWeightedVolume
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?GetReverse@CXScaleManagerImp@@UAEHXZ
_TEXT	SEGMENT
?GetReverse@CXScaleManagerImp@@UAEHXZ PROC		; CXScaleManagerImp::GetReverse, COMDAT
; _this$ = ecx

; 169  : 	return m_bReverse;

  00000	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]

; 170  : }

  00003	c3		 ret	 0
?GetReverse@CXScaleManagerImp@@UAEHXZ ENDP		; CXScaleManagerImp::GetReverse
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?SetReverse@CXScaleManagerImp@@UAEXH@Z
_TEXT	SEGMENT
_bReverse$ = 8						; size = 4
?SetReverse@CXScaleManagerImp@@UAEXH@Z PROC		; CXScaleManagerImp::SetReverse, COMDAT
; _this$ = ecx

; 153  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 154  : 	if( !m_pIChartCtrl->IsRunningOneChart())

  00006	8b 4e 50	 mov	 ecx, DWORD PTR [esi+80]
  00009	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000b	ff 90 38 01 00
	00		 call	 DWORD PTR [eax+312]
  00011	85 c0		 test	 eax, eax
  00013	0f 85 85 00 00
	00		 jne	 $LN24@SetReverse

; 155  : 	{
; 156  : 		if(m_bReverse == TRUE && bReverse == FALSE)

  00019	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0001c	57		 push	 edi
  0001d	83 f8 01	 cmp	 eax, 1
  00020	75 39		 jne	 SHORT $LN9@SetReverse
  00022	8b 7d 08	 mov	 edi, DWORD PTR _bReverse$[ebp]
  00025	85 ff		 test	 edi, edi
  00027	75 29		 jne	 SHORT $LN23@SetReverse

; 157  : 			for( int i = 0; i < m_nCountOfBlockColumn; i++)

  00029	33 d2		 xor	 edx, edx
  0002b	39 96 2c 01 00
	00		 cmp	 DWORD PTR [esi+300], edx
  00031	7e 1f		 jle	 SHORT $LN23@SetReverse
  00033	8d 8e f8 01 00
	00		 lea	 ecx, DWORD PTR [esi+504]
  00039	0f 1f 80 00 00
	00 00		 npad	 7
$LL4@SetReverse:

; 158  : 				m_nScreenLeft_Cur[ i] -= m_nRightMarginWidth;

  00040	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00043	8d 49 04	 lea	 ecx, DWORD PTR [ecx+4]
  00046	29 41 fc	 sub	 DWORD PTR [ecx-4], eax
  00049	42		 inc	 edx
  0004a	3b 96 2c 01 00
	00		 cmp	 edx, DWORD PTR [esi+300]
  00050	7c ee		 jl	 SHORT $LL4@SetReverse
$LN23@SetReverse:

; 162  : 	}
; 163  : 
; 164  : 	m_bReverse = bReverse;

  00052	89 7e 0c	 mov	 DWORD PTR [esi+12], edi
  00055	5f		 pop	 edi
  00056	5e		 pop	 esi

; 165  : }

  00057	5d		 pop	 ebp
  00058	c2 04 00	 ret	 4
$LN9@SetReverse:

; 159  : 		else if(m_bReverse == FALSE && bReverse == TRUE)

  0005b	85 c0		 test	 eax, eax
  0005d	75 33		 jne	 SHORT $LN22@SetReverse
  0005f	8b 7d 08	 mov	 edi, DWORD PTR _bReverse$[ebp]
  00062	83 ff 01	 cmp	 edi, 1
  00065	75 eb		 jne	 SHORT $LN23@SetReverse

; 160  : 			for( int i = 0; i < m_nCountOfBlockColumn; i++)

  00067	33 d2		 xor	 edx, edx
  00069	39 96 2c 01 00
	00		 cmp	 DWORD PTR [esi+300], edx
  0006f	7e e1		 jle	 SHORT $LN23@SetReverse
  00071	8d 8e f8 01 00
	00		 lea	 ecx, DWORD PTR [esi+504]
$LL7@SetReverse:

; 161  : 				m_nScreenLeft_Cur[ i] += m_nRightMarginWidth;

  00077	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0007a	8d 49 04	 lea	 ecx, DWORD PTR [ecx+4]
  0007d	01 41 fc	 add	 DWORD PTR [ecx-4], eax
  00080	42		 inc	 edx
  00081	3b 96 2c 01 00
	00		 cmp	 edx, DWORD PTR [esi+300]
  00087	7c ee		 jl	 SHORT $LL7@SetReverse

; 162  : 	}
; 163  : 
; 164  : 	m_bReverse = bReverse;

  00089	89 7e 0c	 mov	 DWORD PTR [esi+12], edi
  0008c	5f		 pop	 edi
  0008d	5e		 pop	 esi

; 165  : }

  0008e	5d		 pop	 ebp
  0008f	c2 04 00	 ret	 4
$LN22@SetReverse:

; 162  : 	}
; 163  : 
; 164  : 	m_bReverse = bReverse;

  00092	8b 45 08	 mov	 eax, DWORD PTR _bReverse$[ebp]
  00095	5f		 pop	 edi
  00096	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  00099	5e		 pop	 esi

; 165  : }

  0009a	5d		 pop	 ebp
  0009b	c2 04 00	 ret	 4
$LN24@SetReverse:

; 162  : 	}
; 163  : 
; 164  : 	m_bReverse = bReverse;

  0009e	8b 45 08	 mov	 eax, DWORD PTR _bReverse$[ebp]
  000a1	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  000a4	5e		 pop	 esi

; 165  : }

  000a5	5d		 pop	 ebp
  000a6	c2 04 00	 ret	 4
?SetReverse@CXScaleManagerImp@@UAEXH@Z ENDP		; CXScaleManagerImp::SetReverse
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?GetApplyToolBar@CXScaleManagerImp@@UAEHXZ
_TEXT	SEGMENT
?GetApplyToolBar@CXScaleManagerImp@@UAEHXZ PROC		; CXScaleManagerImp::GetApplyToolBar, COMDAT
; _this$ = ecx

; 148  : 	return m_bApplyToolBar;

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 149  : }

  00003	c3		 ret	 0
?GetApplyToolBar@CXScaleManagerImp@@UAEHXZ ENDP		; CXScaleManagerImp::GetApplyToolBar
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?SetApplyToolBar@CXScaleManagerImp@@UAEXH@Z
_TEXT	SEGMENT
_bApplyToolBar$ = 8					; size = 4
?SetApplyToolBar@CXScaleManagerImp@@UAEXH@Z PROC	; CXScaleManagerImp::SetApplyToolBar, COMDAT
; _this$ = ecx

; 142  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 143  : 	m_bApplyToolBar = bApplyToolBar;

  00003	8b 45 08	 mov	 eax, DWORD PTR _bApplyToolBar$[ebp]
  00006	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 144  : }

  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?SetApplyToolBar@CXScaleManagerImp@@UAEXH@Z ENDP	; CXScaleManagerImp::SetApplyToolBar
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.h
;	COMDAT ?GetPacketListManager@CXScaleManagerImp@@UAEPAVCPacketListManager@@XZ
_TEXT	SEGMENT
?GetPacketListManager@CXScaleManagerImp@@UAEPAVCPacketListManager@@XZ PROC ; CXScaleManagerImp::GetPacketListManager, COMDAT
; _this$ = ecx

; 191  : 	virtual CPacketListManager *	GetPacketListManager( void)		{	return m_ppacketListManager;	}

  00000	8b 41 48	 mov	 eax, DWORD PTR [ecx+72]
  00003	c3		 ret	 0
?GetPacketListManager@CXScaleManagerImp@@UAEPAVCPacketListManager@@XZ ENDP ; CXScaleManagerImp::GetPacketListManager
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?SetIndicatorList@CXScaleManagerImp@@UAEXPAVCIndicatorList@@@Z
_TEXT	SEGMENT
_pIndicatorList$ = 8					; size = 4
?SetIndicatorList@CXScaleManagerImp@@UAEXPAVCIndicatorList@@@Z PROC ; CXScaleManagerImp::SetIndicatorList, COMDAT
; _this$ = ecx

; 136  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 137  : 	m_pIndicatorList = pIndicatorList;

  00003	8b 45 08	 mov	 eax, DWORD PTR _pIndicatorList$[ebp]
  00006	89 41 4c	 mov	 DWORD PTR [ecx+76], eax

; 138  : }

  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?SetIndicatorList@CXScaleManagerImp@@UAEXPAVCIndicatorList@@@Z ENDP ; CXScaleManagerImp::SetIndicatorList
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?SetPacketListManager@CXScaleManagerImp@@UAEXPAVCPacketListManager@@@Z
_TEXT	SEGMENT
_ppacketListManager$ = 8				; size = 4
?SetPacketListManager@CXScaleManagerImp@@UAEXPAVCPacketListManager@@@Z PROC ; CXScaleManagerImp::SetPacketListManager, COMDAT
; _this$ = ecx

; 131  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 132  : 	m_ppacketListManager = ppacketListManager;

  00003	8b 45 08	 mov	 eax, DWORD PTR _ppacketListManager$[ebp]
  00006	89 41 48	 mov	 DWORD PTR [ecx+72], eax

; 133  : }

  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?SetPacketListManager@CXScaleManagerImp@@UAEXPAVCPacketListManager@@@Z ENDP ; CXScaleManagerImp::SetPacketListManager
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?GetDTIFromDRI@CXScaleManagerImp@@IAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_strRQ$ = 8						; size = 4
_nDRI$ = 12						; size = 4
?GetDTIFromDRI@CXScaleManagerImp@@IAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z PROC ; CXScaleManagerImp::GetDTIFromDRI, COMDAT
; _this$ = ecx

; 1422 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?GetDTIFromDRI@CXScaleManagerImp@@IAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f9		 mov	 edi, ecx

; 1423 : 	int nRQ = GetRQIndexFromString( strRQ);

  00027	51		 push	 ecx
  00028	8d 45 08	 lea	 eax, DWORD PTR _strRQ$[ebp]
  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00032	8b cc		 mov	 ecx, esp
  00034	50		 push	 eax
  00035	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z
  0003b	8b 07		 mov	 eax, DWORD PTR [edi]
  0003d	8b cf		 mov	 ecx, edi
  0003f	ff 50 04	 call	 DWORD PTR [eax+4]
  00042	8b f0		 mov	 esi, eax

; 1424 : 	if( nRQ < 0) return -1;

  00044	85 f6		 test	 esi, esi
  00046	78 41		 js	 SHORT $LN15@GetDTIFrom

; 1425 : 	return GetDTIFromDRI( m_pblaDTIfDRI[ nRQ], nDRI);

  00048	8b 87 a8 00 00
	00		 mov	 eax, DWORD PTR [edi+168]
  0004e	8b 34 b0	 mov	 esi, DWORD PTR [eax+esi*4]

; 1435 : 	if( !pblDTIfDRI) return -1;

  00051	85 f6		 test	 esi, esi
  00053	74 34		 je	 SHORT $LN15@GetDTIFrom

; 1436 : 
; 1437 : 	int nItemCount = pblDTIfDRI->GetItemCount();

  00055	8b ce		 mov	 ecx, esi
  00057	e8 00 00 00 00	 call	 ?GetItemCount@CDataBlockListUNK@@QAEHXZ ; CDataBlockListUNK::GetItemCount
  0005c	8b c8		 mov	 ecx, eax

; 1438 : 	if( nItemCount == 0) return -1;

  0005e	85 c9		 test	 ecx, ecx
  00060	74 27		 je	 SHORT $LN15@GetDTIFrom

; 1439 : 
; 1440 : 	if( 0 <= nDRI && nDRI < nItemCount)

  00062	8b 45 0c	 mov	 eax, DWORD PTR _nDRI$[ebp]
  00065	85 c0		 test	 eax, eax
  00067	78 06		 js	 SHORT $LN12@GetDTIFrom
  00069	3b c1		 cmp	 eax, ecx
  0006b	7d 06		 jge	 SHORT $LN21@GetDTIFrom

; 1441 : 	{
; 1442 : 		m_pIReturn = pblDTIfDRI->GetAt(nDRI);
; 1443 : 		if( m_pIReturn) return *m_pIReturn;
; 1444 : 		else return -1;

  0006d	eb 07		 jmp	 SHORT $LN24@GetDTIFrom
$LN12@GetDTIFrom:

; 1445 : 	}
; 1446 : 	if( nItemCount <= nDRI)

  0006f	3b c8		 cmp	 ecx, eax
  00071	7f 16		 jg	 SHORT $LN15@GetDTIFrom
$LN21@GetDTIFrom:

; 1447 : 	{
; 1448 : 		m_pIReturn = pblDTIfDRI->GetAt( nItemCount - 1);	// end mark.

  00073	8d 41 ff	 lea	 eax, DWORD PTR [ecx-1]
$LN24@GetDTIFrom:

; 1425 : 	return GetDTIFromDRI( m_pblaDTIfDRI[ nRQ], nDRI);

  00076	50		 push	 eax
  00077	8b ce		 mov	 ecx, esi
  00079	e8 00 00 00 00	 call	 ?GetAtUNK@CDataBlockListUNK@@QAEPAXH@Z ; CDataBlockListUNK::GetAtUNK
  0007e	89 47 60	 mov	 DWORD PTR [edi+96], eax
  00081	85 c0		 test	 eax, eax
  00083	74 04		 je	 SHORT $LN15@GetDTIFrom
  00085	8b 30		 mov	 esi, DWORD PTR [eax]
  00087	eb 03		 jmp	 SHORT $LN7@GetDTIFrom
$LN15@GetDTIFrom:
  00089	83 ce ff	 or	 esi, -1
$LN7@GetDTIFrom:
  0008c	8d 4d 08	 lea	 ecx, DWORD PTR _strRQ$[ebp]
  0008f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00095	8b c6		 mov	 eax, esi

; 1426 : }

  00097	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0009a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a1	59		 pop	 ecx
  000a2	5f		 pop	 edi
  000a3	5e		 pop	 esi
  000a4	8b e5		 mov	 esp, ebp
  000a6	5d		 pop	 ebp
  000a7	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetDTIFromDRI@CXScaleManagerImp@@IAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z$0:
  00000	8d 4d 08	 lea	 ecx, DWORD PTR _strRQ$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
  0000d	cc		 int	 3
__ehhandler$?GetDTIFromDRI@CXScaleManagerImp@@IAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z:
  0000e	90		 npad	 1
  0000f	90		 npad	 1
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?GetDTIFromDRI@CXScaleManagerImp@@IAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z
  00026	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?GetDTIFromDRI@CXScaleManagerImp@@IAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z ENDP ; CXScaleManagerImp::GetDTIFromDRI
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltime.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltime.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltime.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltime.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltime.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?GetTimeValueFromTime@CXScaleManagerImp@@IAEN_JV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
_TEXT	SEGMENT
_tmResult$ = -200					; size = 8
$T2 = -192						; size = 8
$T3 = -188						; size = 4
$T4 = -188						; size = 4
$T5 = -188						; size = 4
$T6 = -188						; size = 4
$T7 = -188						; size = 4
$T8 = -188						; size = 4
_strResult$ = -184					; size = 4
_ptmTemp$9 = -180					; size = 36
_ptmTemp$10 = -180					; size = 36
_szBuffer$11 = -144					; size = 128
_szBuffer$12 = -144					; size = 128
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_tmValue$ = 8						; size = 8
_strType$ = 16						; size = 4
?GetTimeValueFromTime@CXScaleManagerImp@@IAEN_JV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z PROC ; CXScaleManagerImp::GetTimeValueFromTime, COMDAT
; _this$ = ecx

; 1992 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?GetTimeValueFromTime@CXScaleManagerImp@@IAEN_JV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec bc 00 00
	00		 sub	 esp, 188		; 000000bcH
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 1993 : 	CString strResult;

  0002b	8d 8d 48 ff ff
	ff		 lea	 ecx, DWORD PTR _strResult$[ebp]
  00031	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltime.h

; 417  : 	m_time( time )

  0003e	8b 4d 0c	 mov	 ecx, DWORD PTR _tmValue$[ebp+4]
  00041	8b 45 08	 mov	 eax, DWORD PTR _tmValue$[ebp]
  00044	89 8d 3c ff ff
	ff		 mov	 DWORD PTR _tmResult$[ebp+4], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h

; 2486 : 		return(str1.Compare(psz2) == 0);

  0004a	8d 4d 10	 lea	 ecx, DWORD PTR _strType$[ebp]
  0004d	68 00 00 00 00	 push	 OFFSET ??_C@_06EBMMBHJD@YYYYMM@
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 1993 : 	CString strResult;

  00052	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltime.h

; 417  : 	m_time( time )

  00056	89 85 38 ff ff
	ff		 mov	 DWORD PTR _tmResult$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h

; 2486 : 		return(str1.Compare(psz2) == 0);

  0005c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Compare@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEHPBD@Z
  00062	85 c0		 test	 eax, eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 1996 : 	if(strType == "YYYYMM")

  00064	75 6c		 jne	 SHORT $LN2@GetTimeVal
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltime.h

; 1066 : 	if (_localtime64_s(&ptmTemp, &m_time) != 0)

  00066	8d 85 38 ff ff
	ff		 lea	 eax, DWORD PTR _tmResult$[ebp]
  0006c	50		 push	 eax
  0006d	8d 85 4c ff ff
	ff		 lea	 eax, DWORD PTR _ptmTemp$10[ebp]
  00073	50		 push	 eax
  00074	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___localtime64_s
  0007a	83 c4 08	 add	 esp, 8
  0007d	85 c0		 test	 eax, eax
  0007f	0f 85 ff 01 00
	00		 jne	 $LN62@GetTimeVal

; 1069 : 	}
; 1070 : 
; 1071 : 	if (!_tcsftime(szBuffer, maxTimeBufferSize, pFormat, &ptmTemp))

  00085	8d 85 4c ff ff
	ff		 lea	 eax, DWORD PTR _ptmTemp$10[ebp]
  0008b	50		 push	 eax
  0008c	68 00 00 00 00	 push	 OFFSET ??_C@_04GICMHJFP@?$CFY?$CFm@
  00091	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR _szBuffer$12[ebp]
  00097	68 80 00 00 00	 push	 128			; 00000080H
  0009c	50		 push	 eax
  0009d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strftime
  000a3	83 c4 10	 add	 esp, 16			; 00000010H

; 1072 : 	{
; 1073 : 		szBuffer[0] = '\0';
; 1074 : 	}
; 1075 : 
; 1076 : 	return szBuffer;

  000a6	8d 8d 44 ff ff
	ff		 lea	 ecx, DWORD PTR $T8[ebp]
  000ac	f7 d8		 neg	 eax
  000ae	1a c0		 sbb	 al, al
  000b0	20 85 70 ff ff
	ff		 and	 BYTE PTR _szBuffer$12[ebp], al
  000b6	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR _szBuffer$12[ebp]
  000bc	50		 push	 eax
  000bd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 1997 : 		strResult = tmResult.Format(_T("%Y%m"));

  000c3	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  000c7	8d 85 44 ff ff
	ff		 lea	 eax, DWORD PTR $T8[ebp]
  000cd	e9 3b 01 00 00	 jmp	 $LN60@GetTimeVal
$LN2@GetTimeVal:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h

; 2486 : 		return(str1.Compare(psz2) == 0);

  000d2	68 00 00 00 00	 push	 OFFSET ??_C@_08DKDJLCMP@YYYYMMDD@
  000d7	8d 4d 10	 lea	 ecx, DWORD PTR _strType$[ebp]
  000da	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Compare@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEHPBD@Z
  000e0	85 c0		 test	 eax, eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 1998 : 	else if(strType == "YYYYMMDD")

  000e2	75 6c		 jne	 SHORT $LN4@GetTimeVal
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltime.h

; 1066 : 	if (_localtime64_s(&ptmTemp, &m_time) != 0)

  000e4	8d 85 38 ff ff
	ff		 lea	 eax, DWORD PTR _tmResult$[ebp]
  000ea	50		 push	 eax
  000eb	8d 85 4c ff ff
	ff		 lea	 eax, DWORD PTR _ptmTemp$9[ebp]
  000f1	50		 push	 eax
  000f2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___localtime64_s
  000f8	83 c4 08	 add	 esp, 8
  000fb	85 c0		 test	 eax, eax
  000fd	0f 85 8b 01 00
	00		 jne	 $LN63@GetTimeVal

; 1069 : 	}
; 1070 : 
; 1071 : 	if (!_tcsftime(szBuffer, maxTimeBufferSize, pFormat, &ptmTemp))

  00103	8d 85 4c ff ff
	ff		 lea	 eax, DWORD PTR _ptmTemp$9[ebp]
  00109	50		 push	 eax
  0010a	68 00 00 00 00	 push	 OFFSET ??_C@_06CLONMKIH@?$CFY?$CFm?$CFd@
  0010f	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR _szBuffer$11[ebp]
  00115	68 80 00 00 00	 push	 128			; 00000080H
  0011a	50		 push	 eax
  0011b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strftime
  00121	83 c4 10	 add	 esp, 16			; 00000010H

; 1072 : 	{
; 1073 : 		szBuffer[0] = '\0';
; 1074 : 	}
; 1075 : 
; 1076 : 	return szBuffer;

  00124	8d 8d 44 ff ff
	ff		 lea	 ecx, DWORD PTR $T7[ebp]
  0012a	f7 d8		 neg	 eax
  0012c	1a c0		 sbb	 al, al
  0012e	20 85 70 ff ff
	ff		 and	 BYTE PTR _szBuffer$11[ebp], al
  00134	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR _szBuffer$11[ebp]
  0013a	50		 push	 eax
  0013b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 1999 : 		strResult = tmResult.Format(_T("%Y%m%d"));

  00141	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  00145	8d 85 44 ff ff
	ff		 lea	 eax, DWORD PTR $T7[ebp]
  0014b	e9 bd 00 00 00	 jmp	 $LN60@GetTimeVal
$LN4@GetTimeVal:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h

; 2486 : 		return(str1.Compare(psz2) == 0);

  00150	68 00 00 00 00	 push	 OFFSET ??_C@_08KLIIINKM@MMDDHHMM@
  00155	8d 4d 10	 lea	 ecx, DWORD PTR _strType$[ebp]
  00158	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Compare@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEHPBD@Z
  0015e	85 c0		 test	 eax, eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 2000 : 	else if(strType == "MMDDHHMM")

  00160	75 20		 jne	 SHORT $LN6@GetTimeVal

; 2001 : 		strResult = tmResult.Format(_T("%m%d%H%M"));

  00162	68 00 00 00 00	 push	 OFFSET ??_C@_08LIEOKHEF@?$CFm?$CFd?$CFH?$CFM@
  00167	8d 85 44 ff ff
	ff		 lea	 eax, DWORD PTR $T6[ebp]
  0016d	50		 push	 eax
  0016e	8d 8d 38 ff ff
	ff		 lea	 ecx, DWORD PTR _tmResult$[ebp]
  00174	e8 00 00 00 00	 call	 ?Format@CTime@ATL@@QBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@2@PBD@Z ; ATL::CTime::Format
  00179	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  0017d	e9 8b 00 00 00	 jmp	 $LN60@GetTimeVal
$LN6@GetTimeVal:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h

; 2486 : 		return(str1.Compare(psz2) == 0);

  00182	68 00 00 00 00	 push	 OFFSET ??_C@_06MAANBBPI@HHMMSS@
  00187	8d 4d 10	 lea	 ecx, DWORD PTR _strType$[ebp]
  0018a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Compare@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEHPBD@Z
  00190	85 c0		 test	 eax, eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 2002 : 	else if(strType == "HHMMSS")

  00192	75 1d		 jne	 SHORT $LN8@GetTimeVal

; 2003 : 		strResult = tmResult.Format(_T("%H%M%S"));

  00194	68 00 00 00 00	 push	 OFFSET ??_C@_06NDFCBELD@?$CFH?$CFM?$CFS@
  00199	8d 85 44 ff ff
	ff		 lea	 eax, DWORD PTR $T5[ebp]
  0019f	50		 push	 eax
  001a0	8d 8d 38 ff ff
	ff		 lea	 ecx, DWORD PTR _tmResult$[ebp]
  001a6	e8 00 00 00 00	 call	 ?Format@CTime@ATL@@QBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@2@PBD@Z ; ATL::CTime::Format
  001ab	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  001af	eb 5c		 jmp	 SHORT $LN60@GetTimeVal
$LN8@GetTimeVal:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h

; 2486 : 		return(str1.Compare(psz2) == 0);

  001b1	68 00 00 00 00	 push	 OFFSET ??_C@_08JFMBEEDE@DDHHMMSS@
  001b6	8d 4d 10	 lea	 ecx, DWORD PTR _strType$[ebp]
  001b9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Compare@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEHPBD@Z
  001bf	85 c0		 test	 eax, eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 2004 : 	else if(strType == "DDHHMMSS")

  001c1	75 1d		 jne	 SHORT $LN10@GetTimeVal

; 2005 : 		strResult = tmResult.Format(_T("%d%H%M%S"));

  001c3	68 00 00 00 00	 push	 OFFSET ??_C@_08DEPALGMO@?$CFd?$CFH?$CFM?$CFS@
  001c8	8d 85 44 ff ff
	ff		 lea	 eax, DWORD PTR $T4[ebp]
  001ce	50		 push	 eax
  001cf	8d 8d 38 ff ff
	ff		 lea	 ecx, DWORD PTR _tmResult$[ebp]
  001d5	e8 00 00 00 00	 call	 ?Format@CTime@ATL@@QBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@2@PBD@Z ; ATL::CTime::Format
  001da	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  001de	eb 2d		 jmp	 SHORT $LN60@GetTimeVal
$LN10@GetTimeVal:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h

; 2486 : 		return(str1.Compare(psz2) == 0);

  001e0	68 00 00 00 00	 push	 OFFSET ??_C@_0P@IMPIBBAB@YYYYMMDDHHMMSS@
  001e5	8d 4d 10	 lea	 ecx, DWORD PTR _strType$[ebp]
  001e8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Compare@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEHPBD@Z
  001ee	85 c0		 test	 eax, eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 2007 : 	else if(strType == "YYYYMMDDHHMMSS")

  001f0	75 36		 jne	 SHORT $LN12@GetTimeVal

; 2008 : 		strResult = tmResult.Format(_T("%Y%m%d%H%M%S"));

  001f2	68 00 00 00 00	 push	 OFFSET ??_C@_0N@BNMNAMM@?$CFY?$CFm?$CFd?$CFH?$CFM?$CFS@
  001f7	8d 85 44 ff ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  001fd	50		 push	 eax
  001fe	8d 8d 38 ff ff
	ff		 lea	 ecx, DWORD PTR _tmResult$[ebp]
  00204	e8 00 00 00 00	 call	 ?Format@CTime@ATL@@QBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@2@PBD@Z ; ATL::CTime::Format
  00209	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
$LN60@GetTimeVal:

; 2012 : 
; 2013 : 	return atof(strResult);

  0020d	50		 push	 eax
  0020e	8d 8d 48 ff ff
	ff		 lea	 ecx, DWORD PTR _strResult$[ebp]
  00214	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
  0021a	8d 8d 44 ff ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00220	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00226	eb 11		 jmp	 SHORT $LN13@GetTimeVal
$LN12@GetTimeVal:

; 2009 : 	// 2011.01.11 by SYS <<
; 2010 : 	else
; 2011 : 		strResult = _T("0");

  00228	68 00 00 00 00	 push	 OFFSET ??_C@_01GBGANLPD@0@
  0022d	8d 8d 48 ff ff
	ff		 lea	 ecx, DWORD PTR _strResult$[ebp]
  00233	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z
$LN13@GetTimeVal:

; 2012 : 
; 2013 : 	return atof(strResult);

  00239	ff b5 48 ff ff
	ff		 push	 DWORD PTR _strResult$[ebp]
  0023f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atof
  00245	83 c4 04	 add	 esp, 4
  00248	8d 8d 48 ff ff
	ff		 lea	 ecx, DWORD PTR _strResult$[ebp]
  0024e	dd 9d 40 ff ff
	ff		 fstp	 QWORD PTR $T2[ebp]
  00254	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0025a	8d 4d 10	 lea	 ecx, DWORD PTR _strType$[ebp]
  0025d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00263	dd 85 40 ff ff
	ff		 fld	 QWORD PTR $T2[ebp]

; 2014 : }

  00269	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0026c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00273	59		 pop	 ecx
  00274	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00277	33 cd		 xor	 ecx, ebp
  00279	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0027e	8b e5		 mov	 esp, ebp
  00280	5d		 pop	 ebp
  00281	c2 0c 00	 ret	 12			; 0000000cH
$LN62@GetTimeVal:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltime.h

; 1068 : 		AtlThrow(E_INVALIDARG);

  00284	68 57 00 07 80	 push	 -2147024809		; 80070057H
  00289	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN63@GetTimeVal:
  0028e	68 57 00 07 80	 push	 -2147024809		; 80070057H
  00293	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN59@GetTimeVal:
  00298	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetTimeValueFromTime@CXScaleManagerImp@@IAEN_JV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z$0:
  00000	8d 4d 10	 lea	 ecx, DWORD PTR _strType$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?GetTimeValueFromTime@CXScaleManagerImp@@IAEN_JV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z$1:
  00009	8d 8d 48 ff ff
	ff		 lea	 ecx, DWORD PTR _strResult$[ebp]
  0000f	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?GetTimeValueFromTime@CXScaleManagerImp@@IAEN_JV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z$2:
  00015	8d 8d 44 ff ff
	ff		 lea	 ecx, DWORD PTR $T8[ebp]
  0001b	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?GetTimeValueFromTime@CXScaleManagerImp@@IAEN_JV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z$3:
  00021	8d 8d 44 ff ff
	ff		 lea	 ecx, DWORD PTR $T7[ebp]
  00027	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?GetTimeValueFromTime@CXScaleManagerImp@@IAEN_JV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z$4:
  0002d	8d 8d 44 ff ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  00033	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?GetTimeValueFromTime@CXScaleManagerImp@@IAEN_JV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z$5:
  00039	8d 8d 44 ff ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  0003f	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?GetTimeValueFromTime@CXScaleManagerImp@@IAEN_JV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z$6:
  00045	8d 8d 44 ff ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  0004b	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?GetTimeValueFromTime@CXScaleManagerImp@@IAEN_JV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z$7:
  00051	8d 8d 44 ff ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00057	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0005d	cc		 int	 3
  0005e	cc		 int	 3
  0005f	cc		 int	 3
  00060	cc		 int	 3
  00061	cc		 int	 3
__ehhandler$?GetTimeValueFromTime@CXScaleManagerImp@@IAEN_JV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z:
  00062	90		 npad	 1
  00063	90		 npad	 1
  00064	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00068	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0006b	8b 8a 40 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-192]
  00071	33 c8		 xor	 ecx, eax
  00073	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00078	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0007b	33 c8		 xor	 ecx, eax
  0007d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00082	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?GetTimeValueFromTime@CXScaleManagerImp@@IAEN_JV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
  00087	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?GetTimeValueFromTime@CXScaleManagerImp@@IAEN_JV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ENDP ; CXScaleManagerImp::GetTimeValueFromTime
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\time.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\time.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\time.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\time.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\time.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\time.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\time.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\time.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\time.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\time.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\time.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?GetTimeFromTimeValue@CXScaleManagerImp@@IAE_J_KV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAUtagRQ_INFO@1@AAUtm@@PBDPAVCMapTimeToLong@@@Z
_TEXT	SEGMENT
tv5582 = -84						; size = 8
tv5573 = -84						; size = 8
tv5438 = -84						; size = 8
tv5429 = -84						; size = 8
tv5299 = -84						; size = 8
tv5290 = -84						; size = 8
tv5168 = -84						; size = 8
tv5159 = -84						; size = 8
tv5029 = -84						; size = 8
tv5020 = -84						; size = 8
tv4890 = -84						; size = 8
tv4881 = -84						; size = 8
tv4759 = -84						; size = 8
tv4750 = -84						; size = 8
tv3529 = -84						; size = 8
tv3520 = -84						; size = 8
tv3390 = -84						; size = 8
tv3381 = -84						; size = 8
tv3257 = -84						; size = 8
tv3248 = -84						; size = 8
tv3144 = -84						; size = 8
tv3135 = -84						; size = 8
tv3000 = -84						; size = 8
tv2991 = -84						; size = 8
tv2859 = -84						; size = 8
tv2850 = -84						; size = 8
tv2711 = -84						; size = 8
tv2702 = -84						; size = 8
tv2572 = -84						; size = 8
tv2563 = -84						; size = 8
tv2426 = -84						; size = 8
tv2417 = -84						; size = 8
tv2266 = -84						; size = 8
tv2257 = -84						; size = 8
tv2127 = -84						; size = 8
tv2118 = -84						; size = 8
tv1994 = -84						; size = 8
tv1985 = -84						; size = 8
tv1680 = -84						; size = 8
tv1671 = -84						; size = 8
tv1538 = -84						; size = 8
tv1529 = -84						; size = 8
tv1403 = -84						; size = 8
tv1394 = -84						; size = 8
tv1219 = -84						; size = 8
tv1205 = -84						; size = 8
tv1136 = -84						; size = 8
tv905 = -84						; size = 8
tv893 = -84						; size = 8
tv865 = -84						; size = 8
tv508 = -84						; size = 8
tv457 = -84						; size = 8
_timeCur$2 = -84					; size = 8
_timeResult$ = -76					; size = 8
tv6661 = -68						; size = 8
tv6652 = -68						; size = 8
tv6522 = -68						; size = 8
tv6513 = -68						; size = 8
tv6378 = -68						; size = 8
tv6369 = -68						; size = 8
tv6262 = -68						; size = 8
tv6253 = -68						; size = 8
tv6120 = -68						; size = 8
tv6111 = -68						; size = 8
tv5981 = -68						; size = 8
tv5972 = -68						; size = 8
tv5837 = -68						; size = 8
tv5828 = -68						; size = 8
tv5721 = -68						; size = 8
tv5712 = -68						; size = 8
tv4592 = -68						; size = 8
tv4583 = -68						; size = 8
tv4444 = -68						; size = 8
tv4320 = -68						; size = 8
tv4311 = -68						; size = 8
tv4207 = -68						; size = 8
tv4198 = -68						; size = 8
tv4076 = -68						; size = 8
tv4067 = -68						; size = 8
tv3963 = -68						; size = 8
tv3954 = -68						; size = 8
tv3832 = -68						; size = 8
tv3823 = -68						; size = 8
tv3716 = -68						; size = 8
tv3707 = -68						; size = 8
tv1157 = -68						; size = 8
tv8580 = -64						; size = 4
tv8513 = -64						; size = 4
tv8378 = -64						; size = 4
tv8308 = -64						; size = 4
tv8283 = -64						; size = 4
tv8254 = -64						; size = 4
tv8220 = -64						; size = 4
tv8183 = -64						; size = 4
tv8159 = -64						; size = 4
tv8130 = -64						; size = 4
tv8096 = -64						; size = 4
tv7862 = -64						; size = 4
tv7837 = -64						; size = 4
tv7789 = -64						; size = 4
tv7766 = -64						; size = 4
tv7718 = -64						; size = 4
tv7677 = -64						; size = 4
tv7995 = -60						; size = 4
tv7975 = -60						; size = 4
tv7953 = -60						; size = 4
tv7929 = -60						; size = 4
tv7905 = -60						; size = 4
tv7885 = -60						; size = 4
tv7871 = -60						; size = 4
tv7846 = -60						; size = 4
tv7813 = -60						; size = 4
tv7775 = -60						; size = 4
tv7742 = -60						; size = 4
tv7691 = -60						; size = 4
tv7676 = -60						; size = 4
tv7125 = -60						; size = 4
tv7124 = -60						; size = 4
tv6983 = -60						; size = 4
tv6927 = -60						; size = 4
tv4453 = -56						; size = 8
tv8636 = -52						; size = 4
tv8614 = -52						; size = 4
tv8302 = -52						; size = 4
tv8276 = -52						; size = 4
tv8178 = -52						; size = 4
tv8152 = -52						; size = 4
tv7962 = -52						; size = 4
tv7938 = -52						; size = 4
tv7872 = -52						; size = 4
tv7847 = -52						; size = 4
tv7822 = -52						; size = 4
tv7776 = -52						; size = 4
tv7751 = -52						; size = 4
tv7700 = -52						; size = 4
tv7185 = -52						; size = 4
tv7184 = -52						; size = 4
tv7001 = -52						; size = 4
tv6936 = -52						; size = 4
tv8684 = -48						; size = 4
tv8664 = -48						; size = 4
tv8640 = -48						; size = 4
tv8304 = -48						; size = 4
tv8277 = -48						; size = 4
tv8179 = -48						; size = 4
tv8153 = -48						; size = 4
tv7963 = -48						; size = 4
tv7939 = -48						; size = 4
tv7823 = -48						; size = 4
tv7752 = -48						; size = 4
tv7701 = -48						; size = 4
tv7667 = -48						; size = 4
tv7003 = -48						; size = 4
tv6937 = -48						; size = 4
tv8872 = -44						; size = 4
tv7522 = -44						; size = 4
tv7489 = -44						; size = 4
tv7445 = -44						; size = 4
tv7423 = -44						; size = 4
tv7401 = -44						; size = 4
tv7386 = -44						; size = 4
tv7353 = -44						; size = 4
tv7329 = -44						; size = 4
tv6988 = -44						; size = 4
tv9342 = -40						; size = 4
tv9273 = -40						; size = 4
tv9236 = -40						; size = 4
tv9204 = -40						; size = 4
tv9154 = -40						; size = 4
tv8963 = -40						; size = 4
tv8897 = -40						; size = 4
tv8873 = -40						; size = 4
tv8757 = -40						; size = 4
tv8736 = -40						; size = 4
tv8708 = -40						; size = 4
tv8688 = -40						; size = 4
tv8660 = -40						; size = 4
tv8499 = -40						; size = 4
tv8364 = -40						; size = 4
tv8242 = -40						; size = 4
tv8118 = -40						; size = 4
tv7643 = -40						; size = 4
tv7617 = -40						; size = 4
tv7575 = -40						; size = 4
tv7533 = -40						; size = 4
tv7523 = -40						; size = 4
tv7498 = -40						; size = 4
tv7387 = -40						; size = 4
tv7362 = -40						; size = 4
tv7305 = -40						; size = 4
tv7257 = -40						; size = 4
tv7241 = -40						; size = 4
tv7221 = -40						; size = 4
tv7198 = -40						; size = 4
tv7120 = -40						; size = 4
_nDay$1$ = -40						; size = 4
_nHour$1$ = -40						; size = 4
_nMin$1$ = -40						; size = 4
tv9175 = -36						; size = 4
tv8964 = -36						; size = 4
tv8761 = -36						; size = 4
tv8712 = -36						; size = 4
tv8241 = -36						; size = 4
tv8117 = -36						; size = 4
tv7601 = -36						; size = 4
tv7559 = -36						; size = 4
tv7499 = -36						; size = 4
tv7363 = -36						; size = 4
tv7314 = -36						; size = 4
tv7281 = -36						; size = 4
tv7212 = -36						; size = 4
tv7163 = -36						; size = 4
tv7122 = -36						; size = 4
tv7099 = -36						; size = 4
tv7079 = -36						; size = 4
tv7010 = -36						; size = 4
tv6994 = -36						; size = 4
_nHour$1$ = -36						; size = 4
tv9268 = -32						; size = 4
tv9200 = -32						; size = 4
tv9176 = -32						; size = 4
tv9029 = -32						; size = 4
tv8838 = -32						; size = 4
tv7315 = -32						; size = 4
tv7290 = -32						; size = 4
tv7211 = -32						; size = 4
tv7182 = -32						; size = 4
tv7152 = -32						; size = 4
tv7098 = -32						; size = 4
_nYear$1$ = -32						; size = 4
tv9269 = -28						; size = 4
tv8731 = -28						; size = 4
tv8683 = -28						; size = 4
tv8635 = -28						; size = 4
tv8602 = -28						; size = 4
tv7623 = -28						; size = 4
tv7581 = -28						; size = 4
tv7539 = -28						; size = 4
tv7291 = -28						; size = 4
tv7151 = -28						; size = 4
tv9328 = -24						; size = 4
tv9141 = -24						; size = 4
tv8732 = -24						; size = 4
_nMon$1$ = -24						; size = 4
_nDay$1$ = -24						; size = 4
tv7006 = -20						; size = 4
_nMon$1$ = -20						; size = 4
_this$1$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_lTime$ = 8						; size = 8
_strType$ = 16						; size = 4
tv9075 = 20						; size = 4
tv9042 = 20						; size = 4
tv8968 = 20						; size = 4
tv8932 = 20						; size = 4
tv8901 = 20						; size = 4
tv8851 = 20						; size = 4
tv7513 = 20						; size = 4
tv7465 = 20						; size = 4
tv7377 = 20						; size = 4
_pifRQ$ = 20						; size = 4
$T3 = 24						; size = 4
_tmResult$ = 24						; size = 4
_p_szRQ$ = 28						; size = 4
tv9406 = 32						; size = 4
tv9369 = 32						; size = 4
tv9330 = 32						; size = 4
tv9307 = 32						; size = 4
tv9199 = 32						; size = 4
tv9180 = 32						; size = 4
tv9142 = 32						; size = 4
tv9120 = 32						; size = 4
tv9030 = 32						; size = 4
tv9008 = 32						; size = 4
tv8896 = 32						; size = 4
tv8877 = 32						; size = 4
tv8839 = 32						; size = 4
tv8817 = 32						; size = 4
tv8540 = 32						; size = 4
tv8501 = 32						; size = 4
tv8478 = 32						; size = 4
tv8441 = 32						; size = 4
tv8405 = 32						; size = 4
tv8366 = 32						; size = 4
tv8343 = 32						; size = 4
tv7439 = 32						; size = 4
tv7183 = 32						; size = 4
tv7117 = 32						; size = 4
$T4 = 32						; size = 4
tv6986 = 32						; size = 4
tv6984 = 32						; size = 4
_ptmCur$1$ = 32						; size = 4
_p_pamapSpecialTime$ = 32				; size = 4
?GetTimeFromTimeValue@CXScaleManagerImp@@IAE_J_KV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAUtagRQ_INFO@1@AAUtm@@PBDPAVCMapTimeToLong@@@Z PROC ; CXScaleManagerImp::GetTimeFromTimeValue, COMDAT
; _this$ = ecx

; 2324 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?GetTimeFromTimeValue@CXScaleManagerImp@@IAE_J_KV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAUtagRQ_INFO@1@AAUtm@@PBDPAVCMapTimeToLong@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 48	 sub	 esp, 72			; 00000048H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$1$[ebp], ecx
  0002b	8b 7d 18	 mov	 edi, DWORD PTR _tmResult$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h

; 2486 : 		return(str1.Compare(psz2) == 0);

  0002e	8d 4d 10	 lea	 ecx, DWORD PTR _strType$[ebp]
  00031	0f 57 c0	 xorps	 xmm0, xmm0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 2324 : {

  00034	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h

; 2486 : 		return(str1.Compare(psz2) == 0);

  0003b	68 00 00 00 00	 push	 OFFSET ??_C@_0P@IMPIBBAB@YYYYMMDDHHMMSS@
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 2325 : 	time_t timeResult = 0;

  00040	66 0f 13 45 b4	 movlpd	 QWORD PTR _timeResult$[ebp], xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h

; 2486 : 		return(str1.Compare(psz2) == 0);

  00045	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Compare@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEHPBD@Z
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 2329 : 	if (strType == "YYYYMMDDHHMMSS" || lTime > 10000000000000)

  0004b	8b 75 08	 mov	 esi, DWORD PTR _lTime$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h

; 2486 : 		return(str1.Compare(psz2) == 0);

  0004e	85 c0		 test	 eax, eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 2329 : 	if (strType == "YYYYMMDDHHMMSS" || lTime > 10000000000000)

  00050	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp___localtime64
  00055	89 45 d4	 mov	 DWORD PTR tv6988[ebp], eax
  00058	8b 45 0c	 mov	 eax, DWORD PTR _lTime$[ebp+4]
  0005b	0f 84 8d 0d 00
	00		 je	 $LN10@GetTimeFro
  00061	3d 18 09 00 00	 cmp	 eax, 2328		; 00000918H
  00066	0f 87 82 0d 00
	00		 ja	 $LN10@GetTimeFro
  0006c	72 0c		 jb	 SHORT $LN159@GetTimeFro
  0006e	81 fe 00 a0 72
	4e		 cmp	 esi, 1316134912		; 4e72a000H
  00074	0f 87 74 0d 00
	00		 ja	 $LN10@GetTimeFro
$LN159@GetTimeFro:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h

; 2486 : 		return(str1.Compare(psz2) == 0);

  0007a	68 00 00 00 00	 push	 OFFSET ??_C@_06EBMMBHJD@YYYYMM@
  0007f	8d 4d 10	 lea	 ecx, DWORD PTR _strType$[ebp]
  00082	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Compare@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEHPBD@Z
  00088	85 c0		 test	 eax, eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 2483 : 		if( strType == "YYYYMM")

  0008a	0f 85 b5 00 00
	00		 jne	 $LN38@GetTimeFro

; 2484 : 		{
; 2485 : 			memset(&tmResult, 0, sizeof(tm));
; 2486 : 
; 2487 : 			if(lTime)

  00090	8b 4d 0c	 mov	 ecx, DWORD PTR _lTime$[ebp+4]
  00093	0f 57 c0	 xorps	 xmm0, xmm0
  00096	0f 11 07	 movups	 XMMWORD PTR [edi], xmm0
  00099	0f 11 47 10	 movups	 XMMWORD PTR [edi+16], xmm0
  0009d	89 47 20	 mov	 DWORD PTR [edi+32], eax
  000a0	8b c6		 mov	 eax, esi
  000a2	0b c1		 or	 eax, ecx
  000a4	0f 84 bd 1a 00
	00		 je	 $LN37@GetTimeFro

; 2488 : 			{
; 2489 : 				tmResult.tm_year = (lTime / 100) - 1900;

  000aa	8b c6		 mov	 eax, esi
  000ac	ba 15 ae 47 e1	 mov	 edx, -515396075		; e147ae15H
  000b1	f7 e2		 mul	 edx
  000b3	bf 7a 14 ae 47	 mov	 edi, 1202590842		; 47ae147aH
  000b8	89 45 ac	 mov	 DWORD PTR tv1680[ebp], eax
  000bb	8b f2		 mov	 esi, edx
  000bd	8b 45 08	 mov	 eax, DWORD PTR _lTime$[ebp]
  000c0	f7 e7		 mul	 edi
  000c2	8b f8		 mov	 edi, eax
  000c4	89 55 d8	 mov	 DWORD PTR tv7221[ebp], edx
  000c7	8b c1		 mov	 eax, ecx
  000c9	b9 15 ae 47 e1	 mov	 ecx, -515396075		; e147ae15H
  000ce	f7 e1		 mul	 ecx
  000d0	8b c8		 mov	 ecx, eax
  000d2	89 55 20	 mov	 DWORD PTR tv9406[ebp], edx
  000d5	8b 45 0c	 mov	 eax, DWORD PTR _lTime$[ebp+4]
  000d8	ba 7a 14 ae 47	 mov	 edx, 1202590842		; 47ae147aH
  000dd	f7 e2		 mul	 edx
  000df	03 ce		 add	 ecx, esi
  000e1	89 55 e0	 mov	 DWORD PTR tv7211[ebp], edx
  000e4	8b 55 20	 mov	 edx, DWORD PTR tv9406[ebp]
  000e7	83 d2 00	 adc	 edx, 0
  000ea	89 45 dc	 mov	 DWORD PTR tv7212[ebp], eax
  000ed	8b f0		 mov	 esi, eax
  000ef	03 f9		 add	 edi, ecx
  000f1	8b 4d d8	 mov	 ecx, DWORD PTR tv7221[ebp]
  000f4	83 d1 00	 adc	 ecx, 0
  000f7	89 7d ac	 mov	 DWORD PTR tv1671[ebp], edi
  000fa	33 c0		 xor	 eax, eax
  000fc	8b 7d 18	 mov	 edi, DWORD PTR _tmResult$[ebp]
  000ff	03 d1		 add	 edx, ecx
  00101	8b 4d 08	 mov	 ecx, DWORD PTR _lTime$[ebp]
  00104	13 c0		 adc	 eax, eax
  00106	03 f2		 add	 esi, edx
  00108	8b 55 e0	 mov	 edx, DWORD PTR tv7211[ebp]
  0010b	13 d0		 adc	 edx, eax

; 2490 : 				tmResult.tm_mon = (lTime % 100) - 1;
; 2491 : 				tmResult.tm_mday = 1;

  0010d	c7 47 0c 01 00
	00 00		 mov	 DWORD PTR [edi+12], 1
  00114	8b 45 0c	 mov	 eax, DWORD PTR _lTime$[ebp+4]
  00117	2b ce		 sub	 ecx, esi
  00119	1b c2		 sbb	 eax, edx
  0011b	0f ac c1 01	 shrd	 ecx, eax, 1
  0011f	d1 e8		 shr	 eax, 1
  00121	03 ce		 add	 ecx, esi
  00123	8b 75 08	 mov	 esi, DWORD PTR _lTime$[ebp]
  00126	13 c2		 adc	 eax, edx
  00128	0f ac c1 06	 shrd	 ecx, eax, 6
  0012c	8d 81 94 f8 ff
	ff		 lea	 eax, DWORD PTR [ecx-1900]
  00132	89 47 14	 mov	 DWORD PTR [edi+20], eax
  00135	6b c1 64	 imul	 eax, ecx, 100
  00138	8b ce		 mov	 ecx, esi
  0013a	2b c8		 sub	 ecx, eax
  0013c	49		 dec	 ecx
  0013d	89 4f 10	 mov	 DWORD PTR [edi+16], ecx

; 2492 : 			}
; 2493 : 		}

  00140	e9 22 1a 00 00	 jmp	 $LN37@GetTimeFro
$LN38@GetTimeFro:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h

; 2486 : 		return(str1.Compare(psz2) == 0);

  00145	68 00 00 00 00	 push	 OFFSET ??_C@_08DKDJLCMP@YYYYMMDD@
  0014a	8d 4d 10	 lea	 ecx, DWORD PTR _strType$[ebp]
  0014d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Compare@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEHPBD@Z
  00153	85 c0		 test	 eax, eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 2495 : 		else if(strType == "YYYYMMDD")

  00155	0f 85 af 01 00
	00		 jne	 $LN41@GetTimeFro

; 2496 : 		{
; 2497 : 			memset(&tmResult, 0, sizeof(tm));
; 2498 : 
; 2499 : 			if(lTime)

  0015b	8b 4d 0c	 mov	 ecx, DWORD PTR _lTime$[ebp+4]
  0015e	0f 57 c0	 xorps	 xmm0, xmm0
  00161	0f 11 07	 movups	 XMMWORD PTR [edi], xmm0
  00164	0f 11 47 10	 movups	 XMMWORD PTR [edi+16], xmm0
  00168	89 47 20	 mov	 DWORD PTR [edi+32], eax
  0016b	8b c6		 mov	 eax, esi
  0016d	0b c1		 or	 eax, ecx
  0016f	0f 84 f2 19 00
	00		 je	 $LN37@GetTimeFro

; 2500 : 			{
; 2501 : 				tmResult.tm_year = (lTime / 10000) - 1900;

  00175	8b c6		 mov	 eax, esi
  00177	ba 4b 59 86 38	 mov	 edx, 948328779		; 3886594bH
  0017c	f7 e2		 mul	 edx
  0017e	bf d6 c5 6d 34	 mov	 edi, 879609302		; 346dc5d6H
  00183	89 45 ac	 mov	 DWORD PTR tv1538[ebp], eax
  00186	8b f2		 mov	 esi, edx
  00188	8b 45 08	 mov	 eax, DWORD PTR _lTime$[ebp]
  0018b	f7 e7		 mul	 edi
  0018d	8b f8		 mov	 edi, eax
  0018f	89 55 d8	 mov	 DWORD PTR tv7198[ebp], edx
  00192	8b c1		 mov	 eax, ecx
  00194	b9 4b 59 86 38	 mov	 ecx, 948328779		; 3886594bH
  00199	f7 e1		 mul	 ecx
  0019b	8b c8		 mov	 ecx, eax
  0019d	89 55 20	 mov	 DWORD PTR tv9369[ebp], edx
  001a0	8b 45 0c	 mov	 eax, DWORD PTR _lTime$[ebp+4]
  001a3	ba d6 c5 6d 34	 mov	 edx, 879609302		; 346dc5d6H
  001a8	f7 e2		 mul	 edx
  001aa	03 ce		 add	 ecx, esi
  001ac	89 55 e0	 mov	 DWORD PTR tv7182[ebp], edx
  001af	8b 55 20	 mov	 edx, DWORD PTR tv9369[ebp]
  001b2	83 d2 00	 adc	 edx, 0
  001b5	89 45 dc	 mov	 DWORD PTR tv7122[ebp], eax
  001b8	8b f0		 mov	 esi, eax
  001ba	03 f9		 add	 edi, ecx
  001bc	8b 4d d8	 mov	 ecx, DWORD PTR tv7198[ebp]
  001bf	83 d1 00	 adc	 ecx, 0
  001c2	89 7d ac	 mov	 DWORD PTR tv1529[ebp], edi
  001c5	33 c0		 xor	 eax, eax

; 2502 : 				tmResult.tm_mon  = (lTime % 10000) / 100 - 1;

  001c7	bf 10 27 00 00	 mov	 edi, 10000		; 00002710H
  001cc	03 d1		 add	 edx, ecx
  001ce	8b 4d e0	 mov	 ecx, DWORD PTR tv7182[ebp]
  001d1	13 c0		 adc	 eax, eax
  001d3	03 f2		 add	 esi, edx
  001d5	8b 55 18	 mov	 edx, DWORD PTR _tmResult$[ebp]
  001d8	13 c8		 adc	 ecx, eax
  001da	0f ac ce 0b	 shrd	 esi, ecx, 11
  001de	c1 e9 0b	 shr	 ecx, 11			; 0000000bH
  001e1	8d 86 94 f8 ff
	ff		 lea	 eax, DWORD PTR [esi-1900]
  001e7	89 42 14	 mov	 DWORD PTR [edx+20], eax
  001ea	8b c1		 mov	 eax, ecx
  001ec	f7 e7		 mul	 edi
  001ee	8b c8		 mov	 ecx, eax
  001f0	8b c6		 mov	 eax, esi
  001f2	f7 e7		 mul	 edi
  001f4	8b 7d 08	 mov	 edi, DWORD PTR _lTime$[ebp]
  001f7	03 ca		 add	 ecx, edx
  001f9	2b f8		 sub	 edi, eax
  001fb	8b 45 0c	 mov	 eax, DWORD PTR _lTime$[ebp+4]
  001fe	1b c1		 sbb	 eax, ecx
  00200	89 7d e8	 mov	 DWORD PTR tv9328[ebp], edi
  00203	89 45 20	 mov	 DWORD PTR tv9330[ebp], eax
  00206	b9 15 ae 47 e1	 mov	 ecx, -515396075		; e147ae15H
  0020b	8b c7		 mov	 eax, edi
  0020d	f7 e1		 mul	 ecx
  0020f	89 45 ac	 mov	 DWORD PTR tv1403[ebp], eax
  00212	8b f2		 mov	 esi, edx
  00214	8b c7		 mov	 eax, edi
  00216	ba 7a 14 ae 47	 mov	 edx, 1202590842		; 47ae147aH
  0021b	f7 e2		 mul	 edx
  0021d	8b f8		 mov	 edi, eax
  0021f	89 55 dc	 mov	 DWORD PTR tv7163[ebp], edx
  00222	8b 45 20	 mov	 eax, DWORD PTR tv9330[ebp]
  00225	f7 e1		 mul	 ecx
  00227	8b c8		 mov	 ecx, eax
  00229	89 55 d8	 mov	 DWORD PTR tv9342[ebp], edx
  0022c	8b 45 20	 mov	 eax, DWORD PTR tv9330[ebp]
  0022f	ba 7a 14 ae 47	 mov	 edx, 1202590842		; 47ae147aH
  00234	f7 e2		 mul	 edx
  00236	03 ce		 add	 ecx, esi
  00238	89 55 e4	 mov	 DWORD PTR tv7151[ebp], edx
  0023b	8b 55 d8	 mov	 edx, DWORD PTR tv9342[ebp]
  0023e	83 d2 00	 adc	 edx, 0
  00241	89 45 e0	 mov	 DWORD PTR tv7152[ebp], eax
  00244	03 f9		 add	 edi, ecx
  00246	8b 4d dc	 mov	 ecx, DWORD PTR tv7163[ebp]
  00249	89 7d ac	 mov	 DWORD PTR tv1394[ebp], edi
  0024c	83 d1 00	 adc	 ecx, 0
  0024f	33 c0		 xor	 eax, eax
  00251	03 d1		 add	 edx, ecx
  00253	13 c0		 adc	 eax, eax
  00255	8b 4d e0	 mov	 ecx, DWORD PTR tv7152[ebp]

; 2503 : 				tmResult.tm_mday = (lTime % 100);

  00258	bf 7a 14 ae 47	 mov	 edi, 1202590842		; 47ae147aH
  0025d	8b 75 e8	 mov	 esi, DWORD PTR tv9328[ebp]
  00260	03 ca		 add	 ecx, edx
  00262	8b 55 e4	 mov	 edx, DWORD PTR tv7151[ebp]
  00265	13 d0		 adc	 edx, eax
  00267	8b 45 20	 mov	 eax, DWORD PTR tv9330[ebp]
  0026a	2b f1		 sub	 esi, ecx
  0026c	1b c2		 sbb	 eax, edx
  0026e	0f ac c6 01	 shrd	 esi, eax, 1
  00272	d1 e8		 shr	 eax, 1
  00274	03 f1		 add	 esi, ecx
  00276	b9 15 ae 47 e1	 mov	 ecx, -515396075		; e147ae15H
  0027b	13 c2		 adc	 eax, edx
  0027d	ba 15 ae 47 e1	 mov	 edx, -515396075		; e147ae15H
  00282	0f ac c6 06	 shrd	 esi, eax, 6
  00286	8b 45 18	 mov	 eax, DWORD PTR _tmResult$[ebp]
  00289	4e		 dec	 esi
  0028a	89 70 10	 mov	 DWORD PTR [eax+16], esi
  0028d	8b 45 08	 mov	 eax, DWORD PTR _lTime$[ebp]
  00290	f7 e2		 mul	 edx
  00292	89 45 ac	 mov	 DWORD PTR tv1219[ebp], eax
  00295	8b f2		 mov	 esi, edx
  00297	8b 45 08	 mov	 eax, DWORD PTR _lTime$[ebp]
  0029a	f7 e7		 mul	 edi
  0029c	8b f8		 mov	 edi, eax
  0029e	89 55 d8	 mov	 DWORD PTR tv7120[ebp], edx
  002a1	8b 45 0c	 mov	 eax, DWORD PTR _lTime$[ebp+4]
  002a4	f7 e1		 mul	 ecx
  002a6	8b c8		 mov	 ecx, eax
  002a8	89 55 20	 mov	 DWORD PTR tv9307[ebp], edx
  002ab	8b 45 0c	 mov	 eax, DWORD PTR _lTime$[ebp+4]
  002ae	ba 7a 14 ae 47	 mov	 edx, 1202590842		; 47ae147aH
  002b3	f7 e2		 mul	 edx
  002b5	03 ce		 add	 ecx, esi
  002b7	89 55 e0	 mov	 DWORD PTR tv7098[ebp], edx
  002ba	8b 55 20	 mov	 edx, DWORD PTR tv9307[ebp]
  002bd	83 d2 00	 adc	 edx, 0
  002c0	89 45 dc	 mov	 DWORD PTR tv7099[ebp], eax
  002c3	8b f0		 mov	 esi, eax
  002c5	03 f9		 add	 edi, ecx
  002c7	8b 4d d8	 mov	 ecx, DWORD PTR tv7120[ebp]
  002ca	83 d1 00	 adc	 ecx, 0
  002cd	89 7d ac	 mov	 DWORD PTR tv1205[ebp], edi
  002d0	33 c0		 xor	 eax, eax
  002d2	8b 7d 18	 mov	 edi, DWORD PTR _tmResult$[ebp]
  002d5	03 d1		 add	 edx, ecx
  002d7	8b 4d 08	 mov	 ecx, DWORD PTR _lTime$[ebp]
  002da	13 c0		 adc	 eax, eax
  002dc	03 f2		 add	 esi, edx
  002de	8b 55 e0	 mov	 edx, DWORD PTR tv7098[ebp]
  002e1	13 d0		 adc	 edx, eax
  002e3	8b 45 0c	 mov	 eax, DWORD PTR _lTime$[ebp+4]
  002e6	2b ce		 sub	 ecx, esi
  002e8	1b c2		 sbb	 eax, edx
  002ea	0f ac c1 01	 shrd	 ecx, eax, 1
  002ee	d1 e8		 shr	 eax, 1
  002f0	03 ce		 add	 ecx, esi
  002f2	8b 75 08	 mov	 esi, DWORD PTR _lTime$[ebp]
  002f5	13 c2		 adc	 eax, edx
  002f7	0f ac c1 06	 shrd	 ecx, eax, 6
  002fb	6b c1 64	 imul	 eax, ecx, 100
  002fe	8b ce		 mov	 ecx, esi
  00300	2b c8		 sub	 ecx, eax
  00302	89 4f 0c	 mov	 DWORD PTR [edi+12], ecx

; 2504 : 			}
; 2505 : 		}

  00305	e9 5d 18 00 00	 jmp	 $LN37@GetTimeFro
$LN41@GetTimeFro:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h

; 2486 : 		return(str1.Compare(psz2) == 0);

  0030a	68 00 00 00 00	 push	 OFFSET ??_C@_08KLIIINKM@MMDDHHMM@
  0030f	8d 4d 10	 lea	 ecx, DWORD PTR _strType$[ebp]
  00312	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Compare@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEHPBD@Z
  00318	85 c0		 test	 eax, eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 2507 : 		else if(strType == "MMDDHHMM")

  0031a	0f 85 01 04 00
	00		 jne	 $LN44@GetTimeFro

; 2508 : 		{
; 2509 : 			// (2009/1/25 - Seung-Won, Bae) Check special time.
; 2510 : 			// (2009/9/15 - Seung-Won, Bae) Do not support special time for WorldOn.
; 2511 : 			if( CChartInfo::WORLD_ON != m_eChartMode && p_pamapSpecialTime && g_iMetaTable.IsSpecialTime( ( lTime % 10000) * 100))

  00320	8b 45 f0	 mov	 eax, DWORD PTR _this$1$[ebp]
  00323	83 b8 e8 05 00
	00 03		 cmp	 DWORD PTR [eax+1512], 3
  0032a	0f 84 fb 00 00
	00		 je	 $LN46@GetTimeFro
  00330	83 7d 20 00	 cmp	 DWORD PTR _p_pamapSpecialTime$[ebp], 0
  00334	0f 84 f1 00 00
	00		 je	 $LN46@GetTimeFro
  0033a	8b c6		 mov	 eax, esi
  0033c	b9 4b 59 86 38	 mov	 ecx, 948328779		; 3886594bH
  00341	f7 e1		 mul	 ecx
  00343	bf d6 c5 6d 34	 mov	 edi, 879609302		; 346dc5d6H
  00348	89 45 ac	 mov	 DWORD PTR tv905[ebp], eax
  0034b	8b f2		 mov	 esi, edx
  0034d	8b 45 08	 mov	 eax, DWORD PTR _lTime$[ebp]
  00350	f7 e7		 mul	 edi
  00352	8b f8		 mov	 edi, eax
  00354	89 55 dc	 mov	 DWORD PTR tv7079[ebp], edx
  00357	8b 45 0c	 mov	 eax, DWORD PTR _lTime$[ebp+4]
  0035a	f7 e1		 mul	 ecx
  0035c	8b c8		 mov	 ecx, eax
  0035e	89 55 d8	 mov	 DWORD PTR tv9273[ebp], edx
  00361	8b 45 0c	 mov	 eax, DWORD PTR _lTime$[ebp+4]
  00364	ba d6 c5 6d 34	 mov	 edx, 879609302		; 346dc5d6H
  00369	f7 e2		 mul	 edx
  0036b	03 ce		 add	 ecx, esi
  0036d	89 55 e4	 mov	 DWORD PTR tv9269[ebp], edx
  00370	8b 55 d8	 mov	 edx, DWORD PTR tv9273[ebp]
  00373	83 d2 00	 adc	 edx, 0
  00376	89 45 e0	 mov	 DWORD PTR tv9268[ebp], eax
  00379	8b f0		 mov	 esi, eax
  0037b	03 f9		 add	 edi, ecx
  0037d	8b 4d dc	 mov	 ecx, DWORD PTR tv7079[ebp]
  00380	83 d1 00	 adc	 ecx, 0
  00383	89 7d ac	 mov	 DWORD PTR tv893[ebp], edi
  00386	33 c0		 xor	 eax, eax
  00388	03 d1		 add	 edx, ecx
  0038a	8b 4d e4	 mov	 ecx, DWORD PTR tv9269[ebp]
  0038d	13 c0		 adc	 eax, eax
  0038f	03 f2		 add	 esi, edx
  00391	13 c8		 adc	 ecx, eax
  00393	0f ac ce 0b	 shrd	 esi, ecx, 11
  00397	69 c6 10 27 00
	00		 imul	 eax, esi, 10000
  0039d	8b 75 08	 mov	 esi, DWORD PTR _lTime$[ebp]
  003a0	8b ce		 mov	 ecx, esi
  003a2	2b c8		 sub	 ecx, eax
  003a4	6b c1 64	 imul	 eax, ecx, 100
  003a7	89 4d d8	 mov	 DWORD PTR tv7241[ebp], ecx
  003aa	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_iMetaTable@@3VIMetaTable@@A ; g_iMetaTable
  003af	50		 push	 eax
  003b0	e8 00 00 00 00	 call	 ?IsSpecialTime@IMetaTable@@QAEHH@Z ; IMetaTable::IsSpecialTime
  003b5	85 c0		 test	 eax, eax
  003b7	74 72		 je	 SHORT $LN46@GetTimeFro

; 2512 : 			{
; 2513 : 				if( 0 == tmResult.tm_year)

  003b9	8b 7d 18	 mov	 edi, DWORD PTR _tmResult$[ebp]
  003bc	83 7f 14 00	 cmp	 DWORD PTR [edi+20], 0
  003c0	75 32		 jne	 SHORT $LN49@GetTimeFro

; 2514 : 				{
; 2515 : 					// 20080925 JS.Kim	   Scale .Local PC     () <<
; 2516 : 					tm* ptmCur = m_TimeDiffManager.CalcCurrentDateTimToPacketTime( p_szRQ);

  003c2	51		 push	 ecx
  003c3	8b cc		 mov	 ecx, esp
  003c5	ff 75 1c	 push	 DWORD PTR _p_szRQ$[ebp]
  003c8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  003ce	8b 4d f0	 mov	 ecx, DWORD PTR _this$1$[ebp]
  003d1	81 c1 ec 05 00
	00		 add	 ecx, 1516		; 000005ecH
  003d7	e8 00 00 00 00	 call	 ?CalcCurrentDateTimToPacketTime@CXScaleTimeDiffManager@@QAEPAUtm@@V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ; CXScaleTimeDiffManager::CalcCurrentDateTimToPacketTime

; 2517 : 					if( ptmCur) tmResult = *ptmCur;

  003dc	85 c0		 test	 eax, eax
  003de	74 14		 je	 SHORT $LN49@GetTimeFro
  003e0	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  003e3	0f 11 07	 movups	 XMMWORD PTR [edi], xmm0
  003e6	0f 10 40 10	 movups	 xmm0, XMMWORD PTR [eax+16]
  003ea	0f 11 47 10	 movups	 XMMWORD PTR [edi+16], xmm0
  003ee	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  003f1	89 47 20	 mov	 DWORD PTR [edi+32], eax
$LN49@GetTimeFro:

; 2518 : 				}
; 2519 : 				tmResult.tm_min++;

  003f4	ff 47 04	 inc	 DWORD PTR [edi+4]

; 2521 : 				timeResult = m_TimeDiffManager.GetRQScreenTime( p_szRQ, &tmResult);

  003f7	57		 push	 edi
  003f8	51		 push	 ecx
  003f9	8b cc		 mov	 ecx, esp
  003fb	ff 75 1c	 push	 DWORD PTR _p_szRQ$[ebp]
  003fe	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  00404	8b 4d f0	 mov	 ecx, DWORD PTR _this$1$[ebp]
  00407	8d 89 ec 05 00
	00		 lea	 ecx, DWORD PTR [ecx+1516]
  0040d	e8 00 00 00 00	 call	 ?GetRQScreenTime@CXScaleTimeDiffManager@@QAE_JV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAUtm@@@Z ; CXScaleTimeDiffManager::GetRQScreenTime
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl

; 597  : 	{ (*this)[key] = newValue; }

  00412	8b 4d 20	 mov	 ecx, DWORD PTR _p_pamapSpecialTime$[ebp]
  00415	50		 push	 eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 2521 : 				timeResult = m_TimeDiffManager.GetRQScreenTime( p_szRQ, &tmResult);

  00416	89 45 b4	 mov	 DWORD PTR _timeResult$[ebp], eax
  00419	89 55 b8	 mov	 DWORD PTR _timeResult$[ebp+4], edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl

; 597  : 	{ (*this)[key] = newValue; }

  0041c	e8 00 00 00 00	 call	 ??ACMapPtrToPtr@@QAEAAPAXPAX@Z ; CMapPtrToPtr::operator[]
  00421	8b 4d d8	 mov	 ecx, DWORD PTR tv7241[ebp]
  00424	89 08		 mov	 DWORD PTR [eax], ecx
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 2523 : 			}

  00426	e9 3c 17 00 00	 jmp	 $LN37@GetTimeFro
$LN46@GetTimeFro:

; 2524 : 			else
; 2525 : 			{
; 2526 : 				// (2009/5/12 - Seung-Won, Bae) Do not check local time for speed.
; 2527 : 				int nMon = ( lTime / 1000000) - 1;

  0042b	b9 db 34 b6 d7	 mov	 ecx, -675924773		; d7b634dbH
  00430	8b c6		 mov	 eax, esi
  00432	f7 e1		 mul	 ecx
  00434	bf 82 de 1b 43	 mov	 edi, 1125899906		; 431bde82H
  00439	89 45 ac	 mov	 DWORD PTR tv508[ebp], eax
  0043c	8b f2		 mov	 esi, edx
  0043e	8b 45 08	 mov	 eax, DWORD PTR _lTime$[ebp]
  00441	f7 e7		 mul	 edi
  00443	89 55 dc	 mov	 DWORD PTR tv7010[ebp], edx
  00446	8b f8		 mov	 edi, eax
  00448	8b 45 0c	 mov	 eax, DWORD PTR _lTime$[ebp+4]
  0044b	f7 e1		 mul	 ecx
  0044d	89 55 d8	 mov	 DWORD PTR tv9236[ebp], edx
  00450	8b c8		 mov	 ecx, eax
  00452	8b 45 0c	 mov	 eax, DWORD PTR _lTime$[ebp+4]
  00455	ba 82 de 1b 43	 mov	 edx, 1125899906		; 431bde82H
  0045a	f7 e2		 mul	 edx
  0045c	03 ce		 add	 ecx, esi
  0045e	89 55 20	 mov	 DWORD PTR tv6984[ebp], edx
  00461	8b 55 d8	 mov	 edx, DWORD PTR tv9236[ebp]
  00464	83 d2 00	 adc	 edx, 0
  00467	89 45 ec	 mov	 DWORD PTR tv7006[ebp], eax
  0046a	03 f9		 add	 edi, ecx
  0046c	8b 4d dc	 mov	 ecx, DWORD PTR tv7010[ebp]
  0046f	89 7d ac	 mov	 DWORD PTR tv457[ebp], edi

; 2528 : 				if( 0 == tmResult.tm_year)

  00472	8b 7d 18	 mov	 edi, DWORD PTR _tmResult$[ebp]
  00475	83 d1 00	 adc	 ecx, 0
  00478	33 c0		 xor	 eax, eax
  0047a	03 d1		 add	 edx, ecx
  0047c	8b 4d ec	 mov	 ecx, DWORD PTR tv7006[ebp]
  0047f	13 c0		 adc	 eax, eax
  00481	03 ca		 add	 ecx, edx
  00483	8b 55 20	 mov	 edx, DWORD PTR tv6984[ebp]
  00486	13 d0		 adc	 edx, eax
  00488	0f ac d1 12	 shrd	 ecx, edx, 18
  0048c	c1 ea 12	 shr	 edx, 18			; 00000012H
  0048f	83 7f 14 00	 cmp	 DWORD PTR [edi+20], 0
  00493	89 4d ec	 mov	 DWORD PTR tv7006[ebp], ecx
  00496	8d 41 ff	 lea	 eax, DWORD PTR [ecx-1]
  00499	89 55 20	 mov	 DWORD PTR tv6984[ebp], edx
  0049c	89 45 e8	 mov	 DWORD PTR _nMon$1$[ebp], eax
  0049f	75 51		 jne	 SHORT $LN181@GetTimeFro

; 2529 : 				{
; 2530 : 					// 20080925 JS.Kim	   Scale .Local PC     () <<
; 2531 : 					tm* ptmCur = m_TimeDiffManager.CalcCurrentDateTimToPacketTime( p_szRQ);

  004a1	51		 push	 ecx
  004a2	8b cc		 mov	 ecx, esp
  004a4	ff 75 1c	 push	 DWORD PTR _p_szRQ$[ebp]
  004a7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  004ad	8b 4d f0	 mov	 ecx, DWORD PTR _this$1$[ebp]
  004b0	8d 89 ec 05 00
	00		 lea	 ecx, DWORD PTR [ecx+1516]
  004b6	e8 00 00 00 00	 call	 ?CalcCurrentDateTimToPacketTime@CXScaleTimeDiffManager@@QAEPAUtm@@V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ; CXScaleTimeDiffManager::CalcCurrentDateTimToPacketTime

; 2532 : 					if( ptmCur) tmResult = *ptmCur;

  004bb	85 c0		 test	 eax, eax
  004bd	74 14		 je	 SHORT $LN51@GetTimeFro
  004bf	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  004c2	0f 11 07	 movups	 XMMWORD PTR [edi], xmm0
  004c5	0f 10 40 10	 movups	 xmm0, XMMWORD PTR [eax+16]
  004c9	0f 11 47 10	 movups	 XMMWORD PTR [edi+16], xmm0
  004cd	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  004d0	89 47 20	 mov	 DWORD PTR [edi+32], eax
$LN51@GetTimeFro:

; 2533 : 					if( lTime && nMon > tmResult.tm_mon) tmResult.tm_year--;

  004d3	8b 75 08	 mov	 esi, DWORD PTR _lTime$[ebp]
  004d6	8b c6		 mov	 eax, esi
  004d8	8b 4d 0c	 mov	 ecx, DWORD PTR _lTime$[ebp+4]
  004db	0b c1		 or	 eax, ecx
  004dd	8b 45 e8	 mov	 eax, DWORD PTR _nMon$1$[ebp]
  004e0	74 08		 je	 SHORT $LN52@GetTimeFro
  004e2	3b 47 10	 cmp	 eax, DWORD PTR [edi+16]
  004e5	7e 03		 jle	 SHORT $LN52@GetTimeFro
  004e7	ff 4f 14	 dec	 DWORD PTR [edi+20]
$LN52@GetTimeFro:

; 2528 : 				if( 0 == tmResult.tm_year)

  004ea	8b 55 20	 mov	 edx, DWORD PTR tv6984[ebp]

; 2534 : 					tmResult.tm_mon = nMon;

  004ed	89 47 10	 mov	 DWORD PTR [edi+16], eax
  004f0	eb 06		 jmp	 SHORT $LN156@GetTimeFro
$LN181@GetTimeFro:

; 2528 : 				if( 0 == tmResult.tm_year)

  004f2	8b 75 08	 mov	 esi, DWORD PTR _lTime$[ebp]
  004f5	8b 4d 0c	 mov	 ecx, DWORD PTR _lTime$[ebp+4]
$LN156@GetTimeFro:

; 2535 : 				}
; 2536 : 				if( lTime)

  004f8	8b c6		 mov	 eax, esi
  004fa	0b c1		 or	 eax, ecx
  004fc	0f 84 14 02 00
	00		 je	 $LN53@GetTimeFro

; 2537 : 				{
; 2538 : 					if( nMon < tmResult.tm_mon) tmResult.tm_year++;

  00502	8b 45 e8	 mov	 eax, DWORD PTR _nMon$1$[ebp]
  00505	3b 47 10	 cmp	 eax, DWORD PTR [edi+16]
  00508	7d 03		 jge	 SHORT $LN54@GetTimeFro
  0050a	ff 47 14	 inc	 DWORD PTR [edi+20]
$LN54@GetTimeFro:

; 2539 : 					tmResult.tm_mon = nMon;

  0050d	89 47 10	 mov	 DWORD PTR [edi+16], eax

; 2540 : 					tmResult.tm_mday = (lTime % 1000000) / 10000;

  00510	8b c2		 mov	 eax, edx
  00512	bf 40 42 0f 00	 mov	 edi, 1000000		; 000f4240H
  00517	f7 e7		 mul	 edi
  00519	8b c8		 mov	 ecx, eax
  0051b	8b 45 ec	 mov	 eax, DWORD PTR tv7006[ebp]
  0051e	f7 e7		 mul	 edi
  00520	8b fe		 mov	 edi, esi
  00522	03 ca		 add	 ecx, edx
  00524	2b f8		 sub	 edi, eax
  00526	8b 45 0c	 mov	 eax, DWORD PTR _lTime$[ebp+4]
  00529	1b c1		 sbb	 eax, ecx
  0052b	b9 4b 59 86 38	 mov	 ecx, 948328779		; 3886594bH
  00530	89 45 20	 mov	 DWORD PTR tv7117[ebp], eax
  00533	8b c7		 mov	 eax, edi
  00535	f7 e1		 mul	 ecx
  00537	89 45 ac	 mov	 DWORD PTR tv1136[ebp], eax
  0053a	8b f2		 mov	 esi, edx
  0053c	8b c7		 mov	 eax, edi
  0053e	ba d6 c5 6d 34	 mov	 edx, 879609302		; 346dc5d6H
  00543	f7 e2		 mul	 edx
  00545	8b f8		 mov	 edi, eax
  00547	89 55 dc	 mov	 DWORD PTR tv6994[ebp], edx
  0054a	8b 45 20	 mov	 eax, DWORD PTR tv7117[ebp]
  0054d	f7 e1		 mul	 ecx
  0054f	8b c8		 mov	 ecx, eax
  00551	89 55 d8	 mov	 DWORD PTR tv9204[ebp], edx
  00554	8b 45 20	 mov	 eax, DWORD PTR tv7117[ebp]
  00557	ba d6 c5 6d 34	 mov	 edx, 879609302		; 346dc5d6H
  0055c	f7 e2		 mul	 edx
  0055e	03 ce		 add	 ecx, esi
  00560	89 55 e0	 mov	 DWORD PTR tv9200[ebp], edx
  00563	8b 55 d8	 mov	 edx, DWORD PTR tv9204[ebp]
  00566	83 d2 00	 adc	 edx, 0
  00569	89 45 20	 mov	 DWORD PTR tv9199[ebp], eax
  0056c	8b f0		 mov	 esi, eax
  0056e	03 f9		 add	 edi, ecx
  00570	8b 4d dc	 mov	 ecx, DWORD PTR tv6994[ebp]
  00573	83 d1 00	 adc	 ecx, 0
  00576	89 7d ac	 mov	 DWORD PTR tv865[ebp], edi
  00579	33 c0		 xor	 eax, eax

; 2541 : 					tmResult.tm_hour = (lTime % 10000) / 100;

  0057b	bf d6 c5 6d 34	 mov	 edi, 879609302		; 346dc5d6H
  00580	03 d1		 add	 edx, ecx
  00582	8b 4d e0	 mov	 ecx, DWORD PTR tv9200[ebp]
  00585	13 c0		 adc	 eax, eax
  00587	03 f2		 add	 esi, edx
  00589	ba 4b 59 86 38	 mov	 edx, 948328779		; 3886594bH
  0058e	13 c8		 adc	 ecx, eax
  00590	8b 45 18	 mov	 eax, DWORD PTR _tmResult$[ebp]
  00593	0f ac ce 0b	 shrd	 esi, ecx, 11
  00597	b9 4b 59 86 38	 mov	 ecx, 948328779		; 3886594bH
  0059c	89 70 0c	 mov	 DWORD PTR [eax+12], esi
  0059f	8b 45 08	 mov	 eax, DWORD PTR _lTime$[ebp]
  005a2	f7 e2		 mul	 edx
  005a4	89 45 ac	 mov	 DWORD PTR tv1985[ebp], eax
  005a7	8b f2		 mov	 esi, edx
  005a9	8b 45 08	 mov	 eax, DWORD PTR _lTime$[ebp]
  005ac	f7 e7		 mul	 edi
  005ae	8b f8		 mov	 edi, eax
  005b0	89 55 d8	 mov	 DWORD PTR tv7257[ebp], edx
  005b3	8b 45 0c	 mov	 eax, DWORD PTR _lTime$[ebp+4]
  005b6	f7 e1		 mul	 ecx
  005b8	8b c8		 mov	 ecx, eax
  005ba	89 55 20	 mov	 DWORD PTR tv9180[ebp], edx
  005bd	8b 45 0c	 mov	 eax, DWORD PTR _lTime$[ebp+4]
  005c0	ba d6 c5 6d 34	 mov	 edx, 879609302		; 346dc5d6H
  005c5	f7 e2		 mul	 edx
  005c7	03 ce		 add	 ecx, esi
  005c9	89 55 e0	 mov	 DWORD PTR tv9176[ebp], edx
  005cc	8b 55 20	 mov	 edx, DWORD PTR tv9180[ebp]
  005cf	83 d2 00	 adc	 edx, 0
  005d2	89 45 dc	 mov	 DWORD PTR tv9175[ebp], eax
  005d5	8b f0		 mov	 esi, eax
  005d7	03 f9		 add	 edi, ecx
  005d9	8b 4d d8	 mov	 ecx, DWORD PTR tv7257[ebp]
  005dc	83 d1 00	 adc	 ecx, 0
  005df	89 7d ac	 mov	 DWORD PTR tv1994[ebp], edi
  005e2	33 c0		 xor	 eax, eax
  005e4	03 d1		 add	 edx, ecx
  005e6	13 c0		 adc	 eax, eax
  005e8	03 f2		 add	 esi, edx
  005ea	8b 4d e0	 mov	 ecx, DWORD PTR tv9176[ebp]
  005ed	bf 10 27 00 00	 mov	 edi, 10000		; 00002710H
  005f2	13 c8		 adc	 ecx, eax
  005f4	0f ac ce 0b	 shrd	 esi, ecx, 11
  005f8	c1 e9 0b	 shr	 ecx, 11			; 0000000bH
  005fb	8b c1		 mov	 eax, ecx
  005fd	f7 e7		 mul	 edi
  005ff	8b c8		 mov	 ecx, eax
  00601	8b c6		 mov	 eax, esi
  00603	f7 e7		 mul	 edi
  00605	8b 7d 08	 mov	 edi, DWORD PTR _lTime$[ebp]
  00608	03 ca		 add	 ecx, edx
  0060a	2b f8		 sub	 edi, eax
  0060c	8b 45 0c	 mov	 eax, DWORD PTR _lTime$[ebp+4]
  0060f	1b c1		 sbb	 eax, ecx
  00611	89 7d e8	 mov	 DWORD PTR tv9141[ebp], edi
  00614	89 45 20	 mov	 DWORD PTR tv9142[ebp], eax
  00617	b9 15 ae 47 e1	 mov	 ecx, -515396075		; e147ae15H
  0061c	8b c7		 mov	 eax, edi
  0061e	f7 e1		 mul	 ecx
  00620	89 45 ac	 mov	 DWORD PTR tv2118[ebp], eax
  00623	8b f2		 mov	 esi, edx
  00625	8b c7		 mov	 eax, edi
  00627	ba 7a 14 ae 47	 mov	 edx, 1202590842		; 47ae147aH
  0062c	f7 e2		 mul	 edx
  0062e	8b f8		 mov	 edi, eax
  00630	89 55 dc	 mov	 DWORD PTR tv7281[ebp], edx
  00633	8b 45 20	 mov	 eax, DWORD PTR tv9142[ebp]
  00636	f7 e1		 mul	 ecx
  00638	8b c8		 mov	 ecx, eax
  0063a	89 55 d8	 mov	 DWORD PTR tv9154[ebp], edx
  0063d	8b 45 20	 mov	 eax, DWORD PTR tv9142[ebp]
  00640	ba 7a 14 ae 47	 mov	 edx, 1202590842		; 47ae147aH
  00645	f7 e2		 mul	 edx
  00647	03 ce		 add	 ecx, esi
  00649	8b 75 e8	 mov	 esi, DWORD PTR tv9141[ebp]
  0064c	89 45 e0	 mov	 DWORD PTR tv7290[ebp], eax
  0064f	89 55 e4	 mov	 DWORD PTR tv7291[ebp], edx
  00652	8b 55 d8	 mov	 edx, DWORD PTR tv9154[ebp]
  00655	83 d2 00	 adc	 edx, 0
  00658	03 f9		 add	 edi, ecx
  0065a	8b 4d dc	 mov	 ecx, DWORD PTR tv7281[ebp]
  0065d	83 d1 00	 adc	 ecx, 0
  00660	89 7d ac	 mov	 DWORD PTR tv2127[ebp], edi
  00663	33 c0		 xor	 eax, eax

; 2542 : 					tmResult.tm_min	= (lTime % 100);

  00665	bf 7a 14 ae 47	 mov	 edi, 1202590842		; 47ae147aH
  0066a	03 d1		 add	 edx, ecx
  0066c	8b 4d e0	 mov	 ecx, DWORD PTR tv7290[ebp]
  0066f	13 c0		 adc	 eax, eax
  00671	03 ca		 add	 ecx, edx
  00673	8b 55 e4	 mov	 edx, DWORD PTR tv7291[ebp]
  00676	13 d0		 adc	 edx, eax
  00678	8b 45 20	 mov	 eax, DWORD PTR tv9142[ebp]
  0067b	2b f1		 sub	 esi, ecx
  0067d	1b c2		 sbb	 eax, edx
  0067f	0f ac c6 01	 shrd	 esi, eax, 1
  00683	d1 e8		 shr	 eax, 1
  00685	03 f1		 add	 esi, ecx
  00687	b9 15 ae 47 e1	 mov	 ecx, -515396075		; e147ae15H
  0068c	13 c2		 adc	 eax, edx
  0068e	ba 15 ae 47 e1	 mov	 edx, -515396075		; e147ae15H
  00693	0f ac c6 06	 shrd	 esi, eax, 6
  00697	8b 45 18	 mov	 eax, DWORD PTR _tmResult$[ebp]
  0069a	89 70 08	 mov	 DWORD PTR [eax+8], esi
  0069d	8b 45 08	 mov	 eax, DWORD PTR _lTime$[ebp]
  006a0	f7 e2		 mul	 edx
  006a2	89 45 ac	 mov	 DWORD PTR tv2257[ebp], eax
  006a5	8b f2		 mov	 esi, edx
  006a7	8b 45 08	 mov	 eax, DWORD PTR _lTime$[ebp]
  006aa	f7 e7		 mul	 edi
  006ac	8b f8		 mov	 edi, eax
  006ae	89 55 d8	 mov	 DWORD PTR tv7305[ebp], edx
  006b1	8b 45 0c	 mov	 eax, DWORD PTR _lTime$[ebp+4]
  006b4	f7 e1		 mul	 ecx
  006b6	8b c8		 mov	 ecx, eax
  006b8	89 55 20	 mov	 DWORD PTR tv9120[ebp], edx
  006bb	8b 45 0c	 mov	 eax, DWORD PTR _lTime$[ebp+4]
  006be	ba 7a 14 ae 47	 mov	 edx, 1202590842		; 47ae147aH
  006c3	f7 e2		 mul	 edx
  006c5	89 45 dc	 mov	 DWORD PTR tv7314[ebp], eax
  006c8	89 55 e0	 mov	 DWORD PTR tv7315[ebp], edx
  006cb	8b 55 20	 mov	 edx, DWORD PTR tv9120[ebp]
  006ce	03 ce		 add	 ecx, esi
  006d0	8b 75 dc	 mov	 esi, DWORD PTR tv7314[ebp]
  006d3	83 d2 00	 adc	 edx, 0
  006d6	03 f9		 add	 edi, ecx
  006d8	8b 4d d8	 mov	 ecx, DWORD PTR tv7305[ebp]
  006db	83 d1 00	 adc	 ecx, 0
  006de	89 7d ac	 mov	 DWORD PTR tv2266[ebp], edi
  006e1	33 c0		 xor	 eax, eax
  006e3	8b 7d 18	 mov	 edi, DWORD PTR _tmResult$[ebp]
  006e6	03 d1		 add	 edx, ecx
  006e8	8b 4d 08	 mov	 ecx, DWORD PTR _lTime$[ebp]
  006eb	13 c0		 adc	 eax, eax
  006ed	03 f2		 add	 esi, edx
  006ef	8b 55 e0	 mov	 edx, DWORD PTR tv7315[ebp]
  006f2	13 d0		 adc	 edx, eax
  006f4	8b 45 0c	 mov	 eax, DWORD PTR _lTime$[ebp+4]
  006f7	2b ce		 sub	 ecx, esi
  006f9	1b c2		 sbb	 eax, edx
  006fb	0f ac c1 01	 shrd	 ecx, eax, 1
  006ff	d1 e8		 shr	 eax, 1
  00701	03 ce		 add	 ecx, esi
  00703	8b 75 08	 mov	 esi, DWORD PTR _lTime$[ebp]
  00706	13 c2		 adc	 eax, edx
  00708	0f ac c1 06	 shrd	 ecx, eax, 6
  0070c	6b c1 64	 imul	 eax, ecx, 100
  0070f	8b ce		 mov	 ecx, esi
  00711	2b c8		 sub	 ecx, eax
  00713	89 4f 04	 mov	 DWORD PTR [edi+4], ecx
$LN53@GetTimeFro:

; 2543 : 				}
; 2544 : 				tmResult.tm_sec = 0;

  00716	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0

; 2545 : 			}
; 2546 : 		}

  0071c	e9 46 14 00 00	 jmp	 $LN37@GetTimeFro
$LN44@GetTimeFro:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h

; 2486 : 		return(str1.Compare(psz2) == 0);

  00721	68 00 00 00 00	 push	 OFFSET ??_C@_06MAANBBPI@HHMMSS@
  00726	8d 4d 10	 lea	 ecx, DWORD PTR _strType$[ebp]
  00729	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Compare@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEHPBD@Z
  0072f	85 c0		 test	 eax, eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 2548 : 		else if(strType == "HHMMSS")

  00731	0f 85 72 02 00
	00		 jne	 $LN55@GetTimeFro

; 2549 : 		{
; 2550 : 			// (2009/1/25 - Seung-Won, Bae) Check special time.
; 2551 : 			// (2009/9/15 - Seung-Won, Bae) Do not support special time for WorldOn.
; 2552 : 			if( CChartInfo::WORLD_ON != m_eChartMode && p_pamapSpecialTime && g_iMetaTable.IsSpecialTime( lTime))

  00737	8b 45 f0	 mov	 eax, DWORD PTR _this$1$[ebp]
  0073a	83 b8 e8 05 00
	00 03		 cmp	 DWORD PTR [eax+1512], 3
  00741	0f 84 8c 00 00
	00		 je	 $LN57@GetTimeFro
  00747	83 7d 20 00	 cmp	 DWORD PTR _p_pamapSpecialTime$[ebp], 0
  0074b	0f 84 82 00 00
	00		 je	 $LN57@GetTimeFro
  00751	56		 push	 esi
  00752	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_iMetaTable@@3VIMetaTable@@A ; g_iMetaTable
  00757	e8 00 00 00 00	 call	 ?IsSpecialTime@IMetaTable@@QAEHH@Z ; IMetaTable::IsSpecialTime
  0075c	85 c0		 test	 eax, eax
  0075e	74 73		 je	 SHORT $LN57@GetTimeFro

; 2553 : 			{
; 2554 : 				if( 0 == tmResult.tm_year)

  00760	83 7f 14 00	 cmp	 DWORD PTR [edi+20], 0
  00764	8b 45 1c	 mov	 eax, DWORD PTR _p_szRQ$[ebp]
  00767	75 33		 jne	 SHORT $LN60@GetTimeFro

; 2555 : 				{
; 2556 : 					// 20080925 JS.Kim	   Scale .Local PC     () <<
; 2557 : 					tm* ptmCur = m_TimeDiffManager.CalcCurrentDateTimToPacketTime( p_szRQ);

  00769	51		 push	 ecx
  0076a	8b cc		 mov	 ecx, esp
  0076c	50		 push	 eax
  0076d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  00773	8b 4d f0	 mov	 ecx, DWORD PTR _this$1$[ebp]
  00776	81 c1 ec 05 00
	00		 add	 ecx, 1516		; 000005ecH
  0077c	e8 00 00 00 00	 call	 ?CalcCurrentDateTimToPacketTime@CXScaleTimeDiffManager@@QAEPAUtm@@V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ; CXScaleTimeDiffManager::CalcCurrentDateTimToPacketTime

; 2558 : 					if( ptmCur) tmResult = *ptmCur;

  00781	85 c0		 test	 eax, eax
  00783	74 14		 je	 SHORT $LN186@GetTimeFro
  00785	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00788	0f 11 07	 movups	 XMMWORD PTR [edi], xmm0
  0078b	0f 10 40 10	 movups	 xmm0, XMMWORD PTR [eax+16]
  0078f	0f 11 47 10	 movups	 XMMWORD PTR [edi+16], xmm0
  00793	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  00796	89 47 20	 mov	 DWORD PTR [edi+32], eax
$LN186@GetTimeFro:

; 2559 : 				}
; 2560 : 				tmResult.tm_sec++;

  00799	8b 45 1c	 mov	 eax, DWORD PTR _p_szRQ$[ebp]
$LN60@GetTimeFro:
  0079c	ff 07		 inc	 DWORD PTR [edi]

; 2562 : 				timeResult = m_TimeDiffManager.GetRQScreenTime( p_szRQ, &tmResult);

  0079e	57		 push	 edi
  0079f	51		 push	 ecx
  007a0	8b cc		 mov	 ecx, esp
  007a2	50		 push	 eax
  007a3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  007a9	8b 4d f0	 mov	 ecx, DWORD PTR _this$1$[ebp]
  007ac	8d 89 ec 05 00
	00		 lea	 ecx, DWORD PTR [ecx+1516]
  007b2	e8 00 00 00 00	 call	 ?GetRQScreenTime@CXScaleTimeDiffManager@@QAE_JV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAUtm@@@Z ; CXScaleTimeDiffManager::GetRQScreenTime
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl

; 597  : 	{ (*this)[key] = newValue; }

  007b7	8b 4d 20	 mov	 ecx, DWORD PTR _p_pamapSpecialTime$[ebp]
  007ba	50		 push	 eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 2562 : 				timeResult = m_TimeDiffManager.GetRQScreenTime( p_szRQ, &tmResult);

  007bb	89 45 b4	 mov	 DWORD PTR _timeResult$[ebp], eax
  007be	89 55 b8	 mov	 DWORD PTR _timeResult$[ebp+4], edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl

; 597  : 	{ (*this)[key] = newValue; }

  007c1	e8 00 00 00 00	 call	 ??ACMapPtrToPtr@@QAEAAPAXPAX@Z ; CMapPtrToPtr::operator[]
  007c6	89 30		 mov	 DWORD PTR [eax], esi
  007c8	8b 7d b4	 mov	 edi, DWORD PTR _timeResult$[ebp]
  007cb	8b 75 b8	 mov	 esi, DWORD PTR _timeResult$[ebp+4]
  007ce	e9 53 15 00 00	 jmp	 $LN112@GetTimeFro
$LN57@GetTimeFro:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 2568 : 				int nHour = (lTime / 10000);

  007d3	b9 4b 59 86 38	 mov	 ecx, 948328779		; 3886594bH
  007d8	8b c6		 mov	 eax, esi
  007da	f7 e1		 mul	 ecx
  007dc	bf d6 c5 6d 34	 mov	 edi, 879609302		; 346dc5d6H
  007e1	89 45 ac	 mov	 DWORD PTR tv2417[ebp], eax
  007e4	8b f2		 mov	 esi, edx
  007e6	8b 45 08	 mov	 eax, DWORD PTR _lTime$[ebp]
  007e9	f7 e7		 mul	 edi
  007eb	8b f8		 mov	 edi, eax
  007ed	89 55 d4	 mov	 DWORD PTR tv7329[ebp], edx
  007f0	8b 45 0c	 mov	 eax, DWORD PTR _lTime$[ebp+4]
  007f3	f7 e1		 mul	 ecx
  007f5	8b c8		 mov	 ecx, eax
  007f7	89 55 14	 mov	 DWORD PTR tv9075[ebp], edx
  007fa	8b 45 0c	 mov	 eax, DWORD PTR _lTime$[ebp+4]
  007fd	ba d6 c5 6d 34	 mov	 edx, 879609302		; 346dc5d6H
  00802	f7 e2		 mul	 edx
  00804	03 ce		 add	 ecx, esi
  00806	89 55 20	 mov	 DWORD PTR tv7183[ebp], edx
  00809	8b 55 14	 mov	 edx, DWORD PTR tv9075[ebp]
  0080c	83 d2 00	 adc	 edx, 0
  0080f	89 45 d8	 mov	 DWORD PTR _nHour$1$[ebp], eax
  00812	03 f9		 add	 edi, ecx
  00814	8b 4d d4	 mov	 ecx, DWORD PTR tv7329[ebp]
  00817	89 7d ac	 mov	 DWORD PTR tv2426[ebp], edi
  0081a	8b 7d d8	 mov	 edi, DWORD PTR _nHour$1$[ebp]
  0081d	83 d1 00	 adc	 ecx, 0
  00820	33 c0		 xor	 eax, eax
  00822	03 d1		 add	 edx, ecx
  00824	8b 4d 20	 mov	 ecx, DWORD PTR tv7183[ebp]
  00827	13 c0		 adc	 eax, eax
  00829	03 fa		 add	 edi, edx
  0082b	13 c8		 adc	 ecx, eax
  0082d	0f ac cf 0b	 shrd	 edi, ecx, 11
  00831	c1 e9 0b	 shr	 ecx, 11			; 0000000bH
  00834	89 4d 20	 mov	 DWORD PTR tv7183[ebp], ecx

; 2569 : 				if( 0 == tmResult.tm_year)

  00837	8b 4d 18	 mov	 ecx, DWORD PTR _tmResult$[ebp]
  0083a	83 79 14 00	 cmp	 DWORD PTR [ecx+20], 0
  0083e	75 4e		 jne	 SHORT $LN179@GetTimeFro

; 2570 : 				{
; 2571 : 					// 20080925 JS.Kim	   Scale .Local PC     () <<
; 2572 : 					tm* ptmCur = m_TimeDiffManager.CalcCurrentDateTimToPacketTime( p_szRQ);

  00840	51		 push	 ecx
  00841	8b cc		 mov	 ecx, esp
  00843	ff 75 1c	 push	 DWORD PTR _p_szRQ$[ebp]
  00846	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  0084c	8b 4d f0	 mov	 ecx, DWORD PTR _this$1$[ebp]
  0084f	8d 89 ec 05 00
	00		 lea	 ecx, DWORD PTR [ecx+1516]
  00855	e8 00 00 00 00	 call	 ?CalcCurrentDateTimToPacketTime@CXScaleTimeDiffManager@@QAEPAUtm@@V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ; CXScaleTimeDiffManager::CalcCurrentDateTimToPacketTime

; 2573 : 					if( ptmCur) tmResult = *ptmCur;

  0085a	8b 4d 18	 mov	 ecx, DWORD PTR _tmResult$[ebp]
  0085d	85 c0		 test	 eax, eax
  0085f	74 14		 je	 SHORT $LN62@GetTimeFro
  00861	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00864	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0
  00867	0f 10 40 10	 movups	 xmm0, XMMWORD PTR [eax+16]
  0086b	0f 11 41 10	 movups	 XMMWORD PTR [ecx+16], xmm0
  0086f	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  00872	89 41 20	 mov	 DWORD PTR [ecx+32], eax
$LN62@GetTimeFro:

; 2574 : 					if( lTime && nHour > tmResult.tm_hour) tmResult.tm_mday--;

  00875	8b 75 08	 mov	 esi, DWORD PTR _lTime$[ebp]
  00878	8b c6		 mov	 eax, esi
  0087a	8b 55 0c	 mov	 edx, DWORD PTR _lTime$[ebp+4]
  0087d	0b c2		 or	 eax, edx
  0087f	74 08		 je	 SHORT $LN63@GetTimeFro
  00881	3b 79 08	 cmp	 edi, DWORD PTR [ecx+8]
  00884	7e 03		 jle	 SHORT $LN63@GetTimeFro
  00886	ff 49 0c	 dec	 DWORD PTR [ecx+12]
$LN63@GetTimeFro:

; 2575 : 					tmResult.tm_hour = nHour;

  00889	89 79 08	 mov	 DWORD PTR [ecx+8], edi
  0088c	eb 06		 jmp	 SHORT $LN157@GetTimeFro
$LN179@GetTimeFro:

; 2569 : 				if( 0 == tmResult.tm_year)

  0088e	8b 75 08	 mov	 esi, DWORD PTR _lTime$[ebp]
  00891	8b 55 0c	 mov	 edx, DWORD PTR _lTime$[ebp+4]
$LN157@GetTimeFro:

; 2576 : 				}
; 2577 : 				if( lTime)

  00894	8b c6		 mov	 eax, esi
  00896	0b c2		 or	 eax, edx
  00898	0f 84 07 05 00
	00		 je	 $LN75@GetTimeFro

; 2578 : 				{
; 2579 : 					if( nHour < tmResult.tm_hour) tmResult.tm_mday++;

  0089e	3b 79 08	 cmp	 edi, DWORD PTR [ecx+8]
  008a1	7d 03		 jge	 SHORT $LN65@GetTimeFro
  008a3	ff 41 0c	 inc	 DWORD PTR [ecx+12]
$LN65@GetTimeFro:

; 2580 : 					tmResult.tm_hour = nHour;
; 2581 : 					tmResult.tm_min	= (lTime % 10000) / 100;

  008a6	8b 45 20	 mov	 eax, DWORD PTR tv7183[ebp]
  008a9	89 79 08	 mov	 DWORD PTR [ecx+8], edi
  008ac	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  008b1	f7 e1		 mul	 ecx
  008b3	ba 10 27 00 00	 mov	 edx, 10000		; 00002710H
  008b8	8b c8		 mov	 ecx, eax
  008ba	8b c7		 mov	 eax, edi
  008bc	f7 e2		 mul	 edx
  008be	8b fe		 mov	 edi, esi
  008c0	03 ca		 add	 ecx, edx
  008c2	2b f8		 sub	 edi, eax
  008c4	8b 45 0c	 mov	 eax, DWORD PTR _lTime$[ebp+4]
  008c7	1b c1		 sbb	 eax, ecx
  008c9	89 7d e0	 mov	 DWORD PTR tv9029[ebp], edi
  008cc	89 45 20	 mov	 DWORD PTR tv9030[ebp], eax
  008cf	b9 15 ae 47 e1	 mov	 ecx, -515396075		; e147ae15H
  008d4	8b c7		 mov	 eax, edi
  008d6	f7 e1		 mul	 ecx
  008d8	89 45 ac	 mov	 DWORD PTR tv2563[ebp], eax
  008db	8b f2		 mov	 esi, edx
  008dd	8b c7		 mov	 eax, edi
  008df	ba 7a 14 ae 47	 mov	 edx, 1202590842		; 47ae147aH
  008e4	f7 e2		 mul	 edx
  008e6	8b f8		 mov	 edi, eax
  008e8	89 55 d4	 mov	 DWORD PTR tv7353[ebp], edx
  008eb	8b 45 20	 mov	 eax, DWORD PTR tv9030[ebp]
  008ee	f7 e1		 mul	 ecx
  008f0	8b c8		 mov	 ecx, eax
  008f2	89 55 14	 mov	 DWORD PTR tv9042[ebp], edx
  008f5	8b 45 20	 mov	 eax, DWORD PTR tv9030[ebp]
  008f8	ba 7a 14 ae 47	 mov	 edx, 1202590842		; 47ae147aH
  008fd	f7 e2		 mul	 edx
  008ff	03 ce		 add	 ecx, esi
  00901	8b 75 e0	 mov	 esi, DWORD PTR tv9029[ebp]
  00904	89 45 d8	 mov	 DWORD PTR tv7362[ebp], eax
  00907	89 55 dc	 mov	 DWORD PTR tv7363[ebp], edx
  0090a	8b 55 14	 mov	 edx, DWORD PTR tv9042[ebp]
  0090d	83 d2 00	 adc	 edx, 0
  00910	03 f9		 add	 edi, ecx
  00912	8b 4d d4	 mov	 ecx, DWORD PTR tv7353[ebp]
  00915	83 d1 00	 adc	 ecx, 0
  00918	89 7d ac	 mov	 DWORD PTR tv2572[ebp], edi
  0091b	33 c0		 xor	 eax, eax

; 2582 : 					tmResult.tm_sec	= (lTime % 100);

  0091d	bf 7a 14 ae 47	 mov	 edi, 1202590842		; 47ae147aH
  00922	03 d1		 add	 edx, ecx
  00924	8b 4d d8	 mov	 ecx, DWORD PTR tv7362[ebp]
  00927	13 c0		 adc	 eax, eax
  00929	03 ca		 add	 ecx, edx
  0092b	8b 55 dc	 mov	 edx, DWORD PTR tv7363[ebp]
  0092e	13 d0		 adc	 edx, eax
  00930	8b 45 20	 mov	 eax, DWORD PTR tv9030[ebp]
  00933	2b f1		 sub	 esi, ecx
  00935	1b c2		 sbb	 eax, edx
  00937	0f ac c6 01	 shrd	 esi, eax, 1
  0093b	d1 e8		 shr	 eax, 1
  0093d	03 f1		 add	 esi, ecx
  0093f	b9 15 ae 47 e1	 mov	 ecx, -515396075		; e147ae15H
  00944	13 c2		 adc	 eax, edx
  00946	ba 15 ae 47 e1	 mov	 edx, -515396075		; e147ae15H
  0094b	0f ac c6 06	 shrd	 esi, eax, 6
  0094f	8b 45 18	 mov	 eax, DWORD PTR _tmResult$[ebp]
  00952	89 70 04	 mov	 DWORD PTR [eax+4], esi
  00955	8b 45 08	 mov	 eax, DWORD PTR _lTime$[ebp]
  00958	f7 e2		 mul	 edx
  0095a	89 45 ac	 mov	 DWORD PTR tv2702[ebp], eax
  0095d	8b f2		 mov	 esi, edx
  0095f	8b 45 08	 mov	 eax, DWORD PTR _lTime$[ebp]
  00962	f7 e7		 mul	 edi
  00964	8b f8		 mov	 edi, eax
  00966	89 55 14	 mov	 DWORD PTR tv7377[ebp], edx
  00969	8b 45 0c	 mov	 eax, DWORD PTR _lTime$[ebp+4]
  0096c	f7 e1		 mul	 ecx
  0096e	8b c8		 mov	 ecx, eax
  00970	89 55 20	 mov	 DWORD PTR tv9008[ebp], edx
  00973	8b 45 0c	 mov	 eax, DWORD PTR _lTime$[ebp+4]
  00976	ba 7a 14 ae 47	 mov	 edx, 1202590842		; 47ae147aH
  0097b	f7 e2		 mul	 edx
  0097d	03 ce		 add	 ecx, esi
  0097f	89 55 d8	 mov	 DWORD PTR tv7387[ebp], edx
  00982	8b 55 20	 mov	 edx, DWORD PTR tv9008[ebp]
  00985	89 45 d4	 mov	 DWORD PTR tv7386[ebp], eax
  00988	83 d2 00	 adc	 edx, 0
  0098b	03 f9		 add	 edi, ecx
  0098d	8b 4d 14	 mov	 ecx, DWORD PTR tv7377[ebp]
  00990	83 d1 00	 adc	 ecx, 0
  00993	89 7d ac	 mov	 DWORD PTR tv2711[ebp], edi
  00996	33 c0		 xor	 eax, eax
  00998	03 d1		 add	 edx, ecx
  0099a	8b 4d d4	 mov	 ecx, DWORD PTR tv7386[ebp]
  0099d	13 c0		 adc	 eax, eax
  0099f	03 ca		 add	 ecx, edx
  009a1	8b 55 d8	 mov	 edx, DWORD PTR tv7387[ebp]
  009a4	e9 d6 03 00 00	 jmp	 $LN189@GetTimeFro
$LN55@GetTimeFro:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h

; 2486 : 		return(str1.Compare(psz2) == 0);

  009a9	68 00 00 00 00	 push	 OFFSET ??_C@_08JFMBEEDE@DDHHMMSS@
  009ae	8d 4d 10	 lea	 ecx, DWORD PTR _strType$[ebp]
  009b1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Compare@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEHPBD@Z
  009b7	85 c0		 test	 eax, eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 2594 : 		else if (strType == "DDHHMMSS")

  009b9	0f 85 10 04 00
	00		 jne	 $LN66@GetTimeFro

; 2595 : 		{
; 2596 : 			// (2009/1/25 - Seung-Won, Bae) Check special time.
; 2597 : 			// (2009/9/15 - Seung-Won, Bae) Do not support special time for WorldOn.
; 2598 : 			if( CChartInfo::WORLD_ON != m_eChartMode && p_pamapSpecialTime && g_iMetaTable.IsSpecialTime( lTime % 1000000))

  009bf	8b 45 f0	 mov	 eax, DWORD PTR _this$1$[ebp]
  009c2	83 b8 e8 05 00
	00 03		 cmp	 DWORD PTR [eax+1512], 3
  009c9	0f 84 f9 00 00
	00		 je	 $LN68@GetTimeFro
  009cf	83 7d 20 00	 cmp	 DWORD PTR _p_pamapSpecialTime$[ebp], 0
  009d3	0f 84 ef 00 00
	00		 je	 $LN68@GetTimeFro
  009d9	8b c6		 mov	 eax, esi
  009db	b9 db 34 b6 d7	 mov	 ecx, -675924773		; d7b634dbH
  009e0	f7 e1		 mul	 ecx
  009e2	bf 82 de 1b 43	 mov	 edi, 1125899906		; 431bde82H
  009e7	89 45 ac	 mov	 DWORD PTR tv2850[ebp], eax
  009ea	8b f2		 mov	 esi, edx
  009ec	8b 45 08	 mov	 eax, DWORD PTR _lTime$[ebp]
  009ef	f7 e7		 mul	 edi
  009f1	8b f8		 mov	 edi, eax
  009f3	89 55 d4	 mov	 DWORD PTR tv7401[ebp], edx
  009f6	8b 45 0c	 mov	 eax, DWORD PTR _lTime$[ebp+4]
  009f9	f7 e1		 mul	 ecx
  009fb	8b c8		 mov	 ecx, eax
  009fd	89 55 14	 mov	 DWORD PTR tv8968[ebp], edx
  00a00	8b 45 0c	 mov	 eax, DWORD PTR _lTime$[ebp+4]
  00a03	ba 82 de 1b 43	 mov	 edx, 1125899906		; 431bde82H
  00a08	f7 e2		 mul	 edx
  00a0a	03 ce		 add	 ecx, esi
  00a0c	89 55 dc	 mov	 DWORD PTR tv8964[ebp], edx
  00a0f	8b 55 14	 mov	 edx, DWORD PTR tv8968[ebp]
  00a12	83 d2 00	 adc	 edx, 0
  00a15	89 45 d8	 mov	 DWORD PTR tv8963[ebp], eax
  00a18	8b f0		 mov	 esi, eax
  00a1a	03 f9		 add	 edi, ecx
  00a1c	8b 4d d4	 mov	 ecx, DWORD PTR tv7401[ebp]
  00a1f	83 d1 00	 adc	 ecx, 0
  00a22	89 7d ac	 mov	 DWORD PTR tv2859[ebp], edi
  00a25	33 c0		 xor	 eax, eax
  00a27	03 d1		 add	 edx, ecx
  00a29	8b 4d dc	 mov	 ecx, DWORD PTR tv8964[ebp]
  00a2c	13 c0		 adc	 eax, eax
  00a2e	03 f2		 add	 esi, edx
  00a30	13 c8		 adc	 ecx, eax
  00a32	0f ac ce 12	 shrd	 esi, ecx, 18
  00a36	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_iMetaTable@@3VIMetaTable@@A ; g_iMetaTable
  00a3b	69 c6 40 42 0f
	00		 imul	 eax, esi, 1000000
  00a41	8b 75 08	 mov	 esi, DWORD PTR _lTime$[ebp]
  00a44	8b fe		 mov	 edi, esi
  00a46	2b f8		 sub	 edi, eax
  00a48	57		 push	 edi
  00a49	e8 00 00 00 00	 call	 ?IsSpecialTime@IMetaTable@@QAEHH@Z ; IMetaTable::IsSpecialTime
  00a4e	85 c0		 test	 eax, eax
  00a50	74 76		 je	 SHORT $LN68@GetTimeFro

; 2599 : 			{
; 2600 : 				if( 0 == tmResult.tm_year)

  00a52	8b 75 18	 mov	 esi, DWORD PTR _tmResult$[ebp]
  00a55	8b 45 1c	 mov	 eax, DWORD PTR _p_szRQ$[ebp]
  00a58	83 7e 14 00	 cmp	 DWORD PTR [esi+20], 0
  00a5c	75 33		 jne	 SHORT $LN71@GetTimeFro

; 2601 : 				{
; 2602 : 					// 20080925 JS.Kim	   Scale .Local PC     () <<
; 2603 : 					tm* ptmCur = m_TimeDiffManager.CalcCurrentDateTimToPacketTime( p_szRQ);

  00a5e	51		 push	 ecx
  00a5f	8b cc		 mov	 ecx, esp
  00a61	50		 push	 eax
  00a62	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  00a68	8b 4d f0	 mov	 ecx, DWORD PTR _this$1$[ebp]
  00a6b	81 c1 ec 05 00
	00		 add	 ecx, 1516		; 000005ecH
  00a71	e8 00 00 00 00	 call	 ?CalcCurrentDateTimToPacketTime@CXScaleTimeDiffManager@@QAEPAUtm@@V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ; CXScaleTimeDiffManager::CalcCurrentDateTimToPacketTime

; 2604 : 					if( ptmCur) tmResult = *ptmCur;

  00a76	85 c0		 test	 eax, eax
  00a78	74 14		 je	 SHORT $LN187@GetTimeFro
  00a7a	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00a7d	0f 11 06	 movups	 XMMWORD PTR [esi], xmm0
  00a80	0f 10 40 10	 movups	 xmm0, XMMWORD PTR [eax+16]
  00a84	0f 11 46 10	 movups	 XMMWORD PTR [esi+16], xmm0
  00a88	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  00a8b	89 46 20	 mov	 DWORD PTR [esi+32], eax
$LN187@GetTimeFro:

; 2605 : 				}
; 2606 : 				tmResult.tm_sec++;

  00a8e	8b 45 1c	 mov	 eax, DWORD PTR _p_szRQ$[ebp]
$LN71@GetTimeFro:
  00a91	ff 06		 inc	 DWORD PTR [esi]

; 2608 : 				timeResult = m_TimeDiffManager.GetRQScreenTime( p_szRQ, &tmResult);

  00a93	56		 push	 esi
  00a94	51		 push	 ecx
  00a95	8b cc		 mov	 ecx, esp
  00a97	50		 push	 eax
  00a98	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  00a9e	8b 4d f0	 mov	 ecx, DWORD PTR _this$1$[ebp]
  00aa1	8d 89 ec 05 00
	00		 lea	 ecx, DWORD PTR [ecx+1516]
  00aa7	e8 00 00 00 00	 call	 ?GetRQScreenTime@CXScaleTimeDiffManager@@QAE_JV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAUtm@@@Z ; CXScaleTimeDiffManager::GetRQScreenTime
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl

; 597  : 	{ (*this)[key] = newValue; }

  00aac	8b 4d 20	 mov	 ecx, DWORD PTR _p_pamapSpecialTime$[ebp]
  00aaf	50		 push	 eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 2608 : 				timeResult = m_TimeDiffManager.GetRQScreenTime( p_szRQ, &tmResult);

  00ab0	89 45 b4	 mov	 DWORD PTR _timeResult$[ebp], eax
  00ab3	89 55 b8	 mov	 DWORD PTR _timeResult$[ebp+4], edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl

; 597  : 	{ (*this)[key] = newValue; }

  00ab6	e8 00 00 00 00	 call	 ??ACMapPtrToPtr@@QAEAAPAXPAX@Z ; CMapPtrToPtr::operator[]
  00abb	89 38		 mov	 DWORD PTR [eax], edi
  00abd	8b 7d b4	 mov	 edi, DWORD PTR _timeResult$[ebp]
  00ac0	8b 75 b8	 mov	 esi, DWORD PTR _timeResult$[ebp+4]
  00ac3	e9 5e 12 00 00	 jmp	 $LN112@GetTimeFro
$LN68@GetTimeFro:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 2614 : 				int nDay = (lTime / 1000000);

  00ac8	b9 db 34 b6 d7	 mov	 ecx, -675924773		; d7b634dbH
  00acd	8b c6		 mov	 eax, esi
  00acf	f7 e1		 mul	 ecx
  00ad1	bf 82 de 1b 43	 mov	 edi, 1125899906		; 431bde82H
  00ad6	89 45 ac	 mov	 DWORD PTR tv2991[ebp], eax
  00ad9	8b f2		 mov	 esi, edx
  00adb	8b 45 08	 mov	 eax, DWORD PTR _lTime$[ebp]
  00ade	f7 e7		 mul	 edi
  00ae0	8b f8		 mov	 edi, eax
  00ae2	89 55 d4	 mov	 DWORD PTR tv7423[ebp], edx
  00ae5	8b 45 0c	 mov	 eax, DWORD PTR _lTime$[ebp+4]
  00ae8	f7 e1		 mul	 ecx
  00aea	8b c8		 mov	 ecx, eax
  00aec	89 55 14	 mov	 DWORD PTR tv8932[ebp], edx
  00aef	8b 45 0c	 mov	 eax, DWORD PTR _lTime$[ebp+4]
  00af2	ba 82 de 1b 43	 mov	 edx, 1125899906		; 431bde82H
  00af7	f7 e2		 mul	 edx
  00af9	03 ce		 add	 ecx, esi
  00afb	89 55 20	 mov	 DWORD PTR tv6986[ebp], edx
  00afe	8b 55 14	 mov	 edx, DWORD PTR tv8932[ebp]
  00b01	83 d2 00	 adc	 edx, 0
  00b04	89 45 d8	 mov	 DWORD PTR _nDay$1$[ebp], eax
  00b07	03 f9		 add	 edi, ecx
  00b09	8b 4d d4	 mov	 ecx, DWORD PTR tv7423[ebp]
  00b0c	89 7d ac	 mov	 DWORD PTR tv3000[ebp], edi
  00b0f	8b 7d d8	 mov	 edi, DWORD PTR _nDay$1$[ebp]
  00b12	83 d1 00	 adc	 ecx, 0
  00b15	33 c0		 xor	 eax, eax
  00b17	03 d1		 add	 edx, ecx
  00b19	8b 4d 20	 mov	 ecx, DWORD PTR tv6986[ebp]
  00b1c	13 c0		 adc	 eax, eax
  00b1e	03 fa		 add	 edi, edx
  00b20	13 c8		 adc	 ecx, eax
  00b22	0f ac cf 12	 shrd	 edi, ecx, 18
  00b26	c1 e9 12	 shr	 ecx, 18			; 00000012H
  00b29	89 4d 20	 mov	 DWORD PTR tv6986[ebp], ecx

; 2615 : 				if( 0 == tmResult.tm_year)

  00b2c	8b 4d 18	 mov	 ecx, DWORD PTR _tmResult$[ebp]
  00b2f	83 79 14 00	 cmp	 DWORD PTR [ecx+20], 0
  00b33	75 4e		 jne	 SHORT $LN180@GetTimeFro

; 2616 : 				{
; 2617 : 					// 20080925 JS.Kim	   Scale .Local PC     () <<
; 2618 : 					tm* ptmCur = m_TimeDiffManager.CalcCurrentDateTimToPacketTime( p_szRQ);

  00b35	51		 push	 ecx
  00b36	8b cc		 mov	 ecx, esp
  00b38	ff 75 1c	 push	 DWORD PTR _p_szRQ$[ebp]
  00b3b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  00b41	8b 4d f0	 mov	 ecx, DWORD PTR _this$1$[ebp]
  00b44	8d 89 ec 05 00
	00		 lea	 ecx, DWORD PTR [ecx+1516]
  00b4a	e8 00 00 00 00	 call	 ?CalcCurrentDateTimToPacketTime@CXScaleTimeDiffManager@@QAEPAUtm@@V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ; CXScaleTimeDiffManager::CalcCurrentDateTimToPacketTime

; 2619 : 					if( ptmCur) tmResult = *ptmCur;

  00b4f	8b 4d 18	 mov	 ecx, DWORD PTR _tmResult$[ebp]
  00b52	85 c0		 test	 eax, eax
  00b54	74 14		 je	 SHORT $LN73@GetTimeFro
  00b56	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00b59	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0
  00b5c	0f 10 40 10	 movups	 xmm0, XMMWORD PTR [eax+16]
  00b60	0f 11 41 10	 movups	 XMMWORD PTR [ecx+16], xmm0
  00b64	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  00b67	89 41 20	 mov	 DWORD PTR [ecx+32], eax
$LN73@GetTimeFro:

; 2620 : 					if( lTime && nDay > tmResult.tm_mday) tmResult.tm_mon--;

  00b6a	8b 75 08	 mov	 esi, DWORD PTR _lTime$[ebp]
  00b6d	8b c6		 mov	 eax, esi
  00b6f	8b 55 0c	 mov	 edx, DWORD PTR _lTime$[ebp+4]
  00b72	0b c2		 or	 eax, edx
  00b74	74 08		 je	 SHORT $LN74@GetTimeFro
  00b76	3b 79 0c	 cmp	 edi, DWORD PTR [ecx+12]
  00b79	7e 03		 jle	 SHORT $LN74@GetTimeFro
  00b7b	ff 49 10	 dec	 DWORD PTR [ecx+16]
$LN74@GetTimeFro:

; 2621 : 					tmResult.tm_mday = nDay;

  00b7e	89 79 0c	 mov	 DWORD PTR [ecx+12], edi
  00b81	eb 06		 jmp	 SHORT $LN158@GetTimeFro
$LN180@GetTimeFro:

; 2615 : 				if( 0 == tmResult.tm_year)

  00b83	8b 75 08	 mov	 esi, DWORD PTR _lTime$[ebp]
  00b86	8b 55 0c	 mov	 edx, DWORD PTR _lTime$[ebp+4]
$LN158@GetTimeFro:

; 2622 : 				}
; 2623 : 				if(lTime)

  00b89	8b c6		 mov	 eax, esi
  00b8b	0b c2		 or	 eax, edx
  00b8d	0f 84 12 02 00
	00		 je	 $LN75@GetTimeFro

; 2624 : 				{
; 2625 : 					if( nDay < tmResult.tm_mday) tmResult.tm_mon++;

  00b93	3b 79 0c	 cmp	 edi, DWORD PTR [ecx+12]
  00b96	7d 03		 jge	 SHORT $LN76@GetTimeFro
  00b98	ff 41 10	 inc	 DWORD PTR [ecx+16]
$LN76@GetTimeFro:

; 2626 : 					tmResult.tm_mday = nDay;
; 2627 : 					tmResult.tm_hour = (lTime % 1000000) / 10000;

  00b9b	8b 45 20	 mov	 eax, DWORD PTR tv6986[ebp]
  00b9e	89 79 0c	 mov	 DWORD PTR [ecx+12], edi
  00ba1	b9 40 42 0f 00	 mov	 ecx, 1000000		; 000f4240H
  00ba6	f7 e1		 mul	 ecx
  00ba8	ba 40 42 0f 00	 mov	 edx, 1000000		; 000f4240H
  00bad	8b c8		 mov	 ecx, eax
  00baf	8b c7		 mov	 eax, edi
  00bb1	f7 e2		 mul	 edx
  00bb3	8b fe		 mov	 edi, esi
  00bb5	03 ca		 add	 ecx, edx
  00bb7	2b f8		 sub	 edi, eax
  00bb9	8b 45 0c	 mov	 eax, DWORD PTR _lTime$[ebp+4]
  00bbc	1b c1		 sbb	 eax, ecx
  00bbe	b9 4b 59 86 38	 mov	 ecx, 948328779		; 3886594bH
  00bc3	89 45 20	 mov	 DWORD PTR tv7439[ebp], eax
  00bc6	8b c7		 mov	 eax, edi
  00bc8	f7 e1		 mul	 ecx
  00bca	89 45 ac	 mov	 DWORD PTR tv3135[ebp], eax
  00bcd	8b f2		 mov	 esi, edx
  00bcf	8b c7		 mov	 eax, edi
  00bd1	ba d6 c5 6d 34	 mov	 edx, 879609302		; 346dc5d6H
  00bd6	f7 e2		 mul	 edx
  00bd8	8b f8		 mov	 edi, eax
  00bda	89 55 d4	 mov	 DWORD PTR tv7445[ebp], edx
  00bdd	8b 45 20	 mov	 eax, DWORD PTR tv7439[ebp]
  00be0	f7 e1		 mul	 ecx
  00be2	8b c8		 mov	 ecx, eax
  00be4	89 55 14	 mov	 DWORD PTR tv8901[ebp], edx
  00be7	8b 45 20	 mov	 eax, DWORD PTR tv7439[ebp]
  00bea	ba d6 c5 6d 34	 mov	 edx, 879609302		; 346dc5d6H
  00bef	f7 e2		 mul	 edx
  00bf1	03 ce		 add	 ecx, esi
  00bf3	89 55 d8	 mov	 DWORD PTR tv8897[ebp], edx
  00bf6	8b 55 14	 mov	 edx, DWORD PTR tv8901[ebp]
  00bf9	83 d2 00	 adc	 edx, 0
  00bfc	89 45 20	 mov	 DWORD PTR tv8896[ebp], eax
  00bff	8b f0		 mov	 esi, eax
  00c01	03 f9		 add	 edi, ecx
  00c03	8b 4d d4	 mov	 ecx, DWORD PTR tv7445[ebp]
  00c06	83 d1 00	 adc	 ecx, 0
  00c09	89 7d ac	 mov	 DWORD PTR tv3144[ebp], edi
  00c0c	33 c0		 xor	 eax, eax

; 2628 : 					tmResult.tm_min	= (lTime % 10000) / 100;

  00c0e	bf d6 c5 6d 34	 mov	 edi, 879609302		; 346dc5d6H
  00c13	03 d1		 add	 edx, ecx
  00c15	8b 4d d8	 mov	 ecx, DWORD PTR tv8897[ebp]
  00c18	13 c0		 adc	 eax, eax
  00c1a	03 f2		 add	 esi, edx
  00c1c	ba 4b 59 86 38	 mov	 edx, 948328779		; 3886594bH
  00c21	13 c8		 adc	 ecx, eax
  00c23	8b 45 18	 mov	 eax, DWORD PTR _tmResult$[ebp]
  00c26	0f ac ce 0b	 shrd	 esi, ecx, 11
  00c2a	b9 4b 59 86 38	 mov	 ecx, 948328779		; 3886594bH
  00c2f	89 70 08	 mov	 DWORD PTR [eax+8], esi
  00c32	8b 45 08	 mov	 eax, DWORD PTR _lTime$[ebp]
  00c35	f7 e2		 mul	 edx
  00c37	89 45 ac	 mov	 DWORD PTR tv3248[ebp], eax
  00c3a	8b f2		 mov	 esi, edx
  00c3c	8b 45 08	 mov	 eax, DWORD PTR _lTime$[ebp]
  00c3f	f7 e7		 mul	 edi
  00c41	8b f8		 mov	 edi, eax
  00c43	89 55 14	 mov	 DWORD PTR tv7465[ebp], edx
  00c46	8b 45 0c	 mov	 eax, DWORD PTR _lTime$[ebp+4]
  00c49	f7 e1		 mul	 ecx
  00c4b	8b c8		 mov	 ecx, eax
  00c4d	89 55 20	 mov	 DWORD PTR tv8877[ebp], edx
  00c50	8b 45 0c	 mov	 eax, DWORD PTR _lTime$[ebp+4]
  00c53	ba d6 c5 6d 34	 mov	 edx, 879609302		; 346dc5d6H
  00c58	f7 e2		 mul	 edx
  00c5a	03 ce		 add	 ecx, esi
  00c5c	89 55 d8	 mov	 DWORD PTR tv8873[ebp], edx
  00c5f	8b 55 20	 mov	 edx, DWORD PTR tv8877[ebp]
  00c62	83 d2 00	 adc	 edx, 0
  00c65	89 45 d4	 mov	 DWORD PTR tv8872[ebp], eax
  00c68	8b f0		 mov	 esi, eax
  00c6a	03 f9		 add	 edi, ecx
  00c6c	8b 4d 14	 mov	 ecx, DWORD PTR tv7465[ebp]
  00c6f	83 d1 00	 adc	 ecx, 0
  00c72	89 7d ac	 mov	 DWORD PTR tv3257[ebp], edi
  00c75	33 c0		 xor	 eax, eax
  00c77	03 d1		 add	 edx, ecx
  00c79	13 c0		 adc	 eax, eax
  00c7b	8b 4d d8	 mov	 ecx, DWORD PTR tv8873[ebp]
  00c7e	03 f2		 add	 esi, edx
  00c80	bf 10 27 00 00	 mov	 edi, 10000		; 00002710H
  00c85	13 c8		 adc	 ecx, eax
  00c87	0f ac ce 0b	 shrd	 esi, ecx, 11
  00c8b	c1 e9 0b	 shr	 ecx, 11			; 0000000bH
  00c8e	8b c1		 mov	 eax, ecx
  00c90	f7 e7		 mul	 edi
  00c92	8b c8		 mov	 ecx, eax
  00c94	8b c6		 mov	 eax, esi
  00c96	f7 e7		 mul	 edi
  00c98	8b 7d 08	 mov	 edi, DWORD PTR _lTime$[ebp]
  00c9b	03 ca		 add	 ecx, edx
  00c9d	2b f8		 sub	 edi, eax
  00c9f	8b 45 0c	 mov	 eax, DWORD PTR _lTime$[ebp+4]
  00ca2	1b c1		 sbb	 eax, ecx
  00ca4	89 7d e0	 mov	 DWORD PTR tv8838[ebp], edi
  00ca7	89 45 20	 mov	 DWORD PTR tv8839[ebp], eax
  00caa	b9 15 ae 47 e1	 mov	 ecx, -515396075		; e147ae15H
  00caf	8b c7		 mov	 eax, edi
  00cb1	f7 e1		 mul	 ecx
  00cb3	89 45 ac	 mov	 DWORD PTR tv3381[ebp], eax
  00cb6	8b f2		 mov	 esi, edx
  00cb8	8b c7		 mov	 eax, edi
  00cba	ba 7a 14 ae 47	 mov	 edx, 1202590842		; 47ae147aH
  00cbf	f7 e2		 mul	 edx
  00cc1	8b f8		 mov	 edi, eax
  00cc3	89 55 d4	 mov	 DWORD PTR tv7489[ebp], edx
  00cc6	8b 45 20	 mov	 eax, DWORD PTR tv8839[ebp]
  00cc9	f7 e1		 mul	 ecx
  00ccb	8b c8		 mov	 ecx, eax
  00ccd	89 55 14	 mov	 DWORD PTR tv8851[ebp], edx
  00cd0	8b 45 20	 mov	 eax, DWORD PTR tv8839[ebp]
  00cd3	ba 7a 14 ae 47	 mov	 edx, 1202590842		; 47ae147aH
  00cd8	f7 e2		 mul	 edx
  00cda	03 ce		 add	 ecx, esi
  00cdc	8b 75 e0	 mov	 esi, DWORD PTR tv8838[ebp]
  00cdf	89 45 d8	 mov	 DWORD PTR tv7498[ebp], eax
  00ce2	89 55 dc	 mov	 DWORD PTR tv7499[ebp], edx
  00ce5	8b 55 14	 mov	 edx, DWORD PTR tv8851[ebp]
  00ce8	83 d2 00	 adc	 edx, 0
  00ceb	03 f9		 add	 edi, ecx
  00ced	8b 4d d4	 mov	 ecx, DWORD PTR tv7489[ebp]
  00cf0	83 d1 00	 adc	 ecx, 0
  00cf3	89 7d ac	 mov	 DWORD PTR tv3390[ebp], edi
  00cf6	33 c0		 xor	 eax, eax

; 2629 : 					tmResult.tm_sec	= (lTime % 100);

  00cf8	bf 7a 14 ae 47	 mov	 edi, 1202590842		; 47ae147aH
  00cfd	03 d1		 add	 edx, ecx
  00cff	8b 4d d8	 mov	 ecx, DWORD PTR tv7498[ebp]
  00d02	13 c0		 adc	 eax, eax
  00d04	03 ca		 add	 ecx, edx
  00d06	8b 55 dc	 mov	 edx, DWORD PTR tv7499[ebp]
  00d09	13 d0		 adc	 edx, eax
  00d0b	8b 45 20	 mov	 eax, DWORD PTR tv8839[ebp]
  00d0e	2b f1		 sub	 esi, ecx
  00d10	1b c2		 sbb	 eax, edx
  00d12	0f ac c6 01	 shrd	 esi, eax, 1
  00d16	d1 e8		 shr	 eax, 1
  00d18	03 f1		 add	 esi, ecx
  00d1a	b9 15 ae 47 e1	 mov	 ecx, -515396075		; e147ae15H
  00d1f	13 c2		 adc	 eax, edx
  00d21	ba 15 ae 47 e1	 mov	 edx, -515396075		; e147ae15H
  00d26	0f ac c6 06	 shrd	 esi, eax, 6
  00d2a	8b 45 18	 mov	 eax, DWORD PTR _tmResult$[ebp]
  00d2d	89 70 04	 mov	 DWORD PTR [eax+4], esi
  00d30	8b 45 08	 mov	 eax, DWORD PTR _lTime$[ebp]
  00d33	f7 e2		 mul	 edx
  00d35	89 45 ac	 mov	 DWORD PTR tv3520[ebp], eax
  00d38	8b f2		 mov	 esi, edx
  00d3a	8b 45 08	 mov	 eax, DWORD PTR _lTime$[ebp]
  00d3d	f7 e7		 mul	 edi
  00d3f	8b f8		 mov	 edi, eax
  00d41	89 55 14	 mov	 DWORD PTR tv7513[ebp], edx
  00d44	8b 45 0c	 mov	 eax, DWORD PTR _lTime$[ebp+4]
  00d47	f7 e1		 mul	 ecx
  00d49	8b c8		 mov	 ecx, eax
  00d4b	89 55 20	 mov	 DWORD PTR tv8817[ebp], edx
  00d4e	8b 45 0c	 mov	 eax, DWORD PTR _lTime$[ebp+4]
  00d51	ba 7a 14 ae 47	 mov	 edx, 1202590842		; 47ae147aH
  00d56	f7 e2		 mul	 edx
  00d58	89 45 d4	 mov	 DWORD PTR tv7522[ebp], eax
  00d5b	03 ce		 add	 ecx, esi
  00d5d	89 55 d8	 mov	 DWORD PTR tv7523[ebp], edx
  00d60	8b 55 20	 mov	 edx, DWORD PTR tv8817[ebp]
  00d63	83 d2 00	 adc	 edx, 0
  00d66	03 f9		 add	 edi, ecx
  00d68	8b 4d 14	 mov	 ecx, DWORD PTR tv7513[ebp]
  00d6b	83 d1 00	 adc	 ecx, 0
  00d6e	89 7d ac	 mov	 DWORD PTR tv3529[ebp], edi
  00d71	33 c0		 xor	 eax, eax
  00d73	03 d1		 add	 edx, ecx
  00d75	8b 4d d4	 mov	 ecx, DWORD PTR tv7522[ebp]
  00d78	13 c0		 adc	 eax, eax
  00d7a	03 ca		 add	 ecx, edx
  00d7c	8b 55 d8	 mov	 edx, DWORD PTR tv7523[ebp]
$LN189@GetTimeFro:
  00d7f	8b 75 08	 mov	 esi, DWORD PTR _lTime$[ebp]
  00d82	13 d0		 adc	 edx, eax
  00d84	8b 7d 0c	 mov	 edi, DWORD PTR _lTime$[ebp+4]
  00d87	8b c6		 mov	 eax, esi
  00d89	2b c1		 sub	 eax, ecx
  00d8b	1b fa		 sbb	 edi, edx
  00d8d	0f ac f8 01	 shrd	 eax, edi, 1
  00d91	d1 ef		 shr	 edi, 1
  00d93	03 c1		 add	 eax, ecx
  00d95	8b 4d 18	 mov	 ecx, DWORD PTR _tmResult$[ebp]
  00d98	13 fa		 adc	 edi, edx
  00d9a	0f ac f8 06	 shrd	 eax, edi, 6
  00d9e	6b c0 64	 imul	 eax, eax, 100
  00da1	2b f0		 sub	 esi, eax
  00da3	89 31		 mov	 DWORD PTR [ecx], esi
$LN75@GetTimeFro:

; 2630 : 				}
; 2631 : 
; 2632 : 				// 20080925 JS.Kim	   Scale . Packet       
; 2633 : 				timeResult = m_TimeDiffManager.GetRQScreenTime( p_szRQ, &tmResult);

  00da5	51		 push	 ecx
  00da6	51		 push	 ecx
  00da7	8b cc		 mov	 ecx, esp
  00da9	ff 75 1c	 push	 DWORD PTR _p_szRQ$[ebp]
  00dac	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  00db2	8b 4d f0	 mov	 ecx, DWORD PTR _this$1$[ebp]
  00db5	8d 89 ec 05 00
	00		 lea	 ecx, DWORD PTR [ecx+1516]
  00dbb	e8 00 00 00 00	 call	 ?GetRQScreenTime@CXScaleTimeDiffManager@@QAE_JV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAUtm@@@Z ; CXScaleTimeDiffManager::GetRQScreenTime
  00dc0	89 55 b8	 mov	 DWORD PTR _timeResult$[ebp+4], edx
  00dc3	8b f8		 mov	 edi, eax
  00dc5	89 45 b4	 mov	 DWORD PTR _timeResult$[ebp], eax
  00dc8	8b f2		 mov	 esi, edx
  00dca	e9 57 0f 00 00	 jmp	 $LN112@GetTimeFro
$LN66@GetTimeFro:

; 2634 : 			}
; 2635 : 
; 2636 : 			return timeResult;
; 2637 : 		}
; 2638 : 		else
; 2639 : 		{
; 2640 : 			// 6. ETC (current pc time ^^;)
; 2641 : 			// 20080925 JS.Kim	   Scale .Local PC     () <<
; 2642 : 			tm* ptmCur = m_TimeDiffManager.CalcCurrentDateTimToPacketTime( p_szRQ);

  00dcf	51		 push	 ecx
  00dd0	8b cc		 mov	 ecx, esp
  00dd2	ff 75 1c	 push	 DWORD PTR _p_szRQ$[ebp]
  00dd5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  00ddb	8b 4d f0	 mov	 ecx, DWORD PTR _this$1$[ebp]
  00dde	81 c1 ec 05 00
	00		 add	 ecx, 1516		; 000005ecH
  00de4	e8 00 00 00 00	 call	 ?CalcCurrentDateTimToPacketTime@CXScaleTimeDiffManager@@QAEPAUtm@@V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ; CXScaleTimeDiffManager::CalcCurrentDateTimToPacketTime

; 2643 : 			tmResult = *ptmCur;

  00de9	e9 45 0b 00 00	 jmp	 $LN193@GetTimeFro
$LN10@GetTimeFro:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\time.h

; 522  :             return _time64(_Time);

  00dee	8d 45 ac	 lea	 eax, DWORD PTR _timeCur$2[ebp]
  00df1	50		 push	 eax
  00df2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___time64

; 499  :             return _localtime64(_Time);

  00df8	8d 45 ac	 lea	 eax, DWORD PTR _timeCur$2[ebp]
  00dfb	50		 push	 eax
  00dfc	ff 55 d4	 call	 DWORD PTR tv6988[ebp]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 2343 : 		if (lTime > 10000000000000)

  00dff	8b 4d 0c	 mov	 ecx, DWORD PTR _lTime$[ebp+4]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\time.h

; 499  :             return _localtime64(_Time);

  00e02	83 c4 08	 add	 esp, 8
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 2334 : 		ptmCur = localtime(&timeCur);

  00e05	89 45 20	 mov	 DWORD PTR _ptmCur$1$[ebp], eax

; 2343 : 		if (lTime > 10000000000000)

  00e08	81 f9 18 09 00
	00		 cmp	 ecx, 2328		; 00000918H
  00e0e	0f 82 a6 04 00
	00		 jb	 $LN11@GetTimeFro
  00e14	77 0c		 ja	 SHORT $LN160@GetTimeFro
  00e16	81 fe 00 a0 72
	4e		 cmp	 esi, 1316134912		; 4e72a000H
  00e1c	0f 86 98 04 00
	00		 jbe	 $LN11@GetTimeFro
$LN160@GetTimeFro:

; 2344 : 		{
; 2345 : 			// Data YYYYMMDDhhmmss  ..
; 2346 : 			nYear	= (lTime / 10000000000) - 1900;

  00e22	53		 push	 ebx
  00e23	6a 02		 push	 2
  00e25	68 00 e4 0b 54	 push	 1410065408		; 540be400H
  00e2a	51		 push	 ecx
  00e2b	56		 push	 esi
  00e2c	e8 00 00 00 00	 call	 __aulldvrm
  00e31	89 5d d8	 mov	 DWORD PTR tv7533[ebp], ebx
  00e34	5b		 pop	 ebx
  00e35	90		 npad	 1
  00e36	05 94 f8 ff ff	 add	 eax, -1900		; fffff894H
  00e3b	89 55 c0	 mov	 DWORD PTR tv1157[ebp+4], edx
  00e3e	89 45 e0	 mov	 DWORD PTR _nYear$1$[ebp], eax

; 2347 : 			nMon	= (lTime % 10000000000) / 100000000 - 1;

  00e41	ba fd ce 61 84	 mov	 edx, -2073964803	; 8461cefdH
  00e46	8b c1		 mov	 eax, ecx
  00e48	bf 11 77 cc ab	 mov	 edi, -1412663535	; abcc7711H
  00e4d	f7 e2		 mul	 edx
  00e4f	89 45 bc	 mov	 DWORD PTR tv3707[ebp], eax
  00e52	8b f2		 mov	 esi, edx
  00e54	8b c1		 mov	 eax, ecx
  00e56	b9 fd ce 61 84	 mov	 ecx, -2073964803	; 8461cefdH
  00e5b	f7 e7		 mul	 edi
  00e5d	8b f8		 mov	 edi, eax
  00e5f	89 55 e4	 mov	 DWORD PTR tv7539[ebp], edx
  00e62	8b 45 d8	 mov	 eax, DWORD PTR tv7533[ebp]
  00e65	f7 e1		 mul	 ecx
  00e67	8b c8		 mov	 ecx, eax
  00e69	89 55 dc	 mov	 DWORD PTR tv8761[ebp], edx
  00e6c	8b 45 d8	 mov	 eax, DWORD PTR tv7533[ebp]
  00e6f	ba 11 77 cc ab	 mov	 edx, -1412663535	; abcc7711H
  00e74	f7 e2		 mul	 edx
  00e76	03 ce		 add	 ecx, esi
  00e78	89 55 d8	 mov	 DWORD PTR tv8757[ebp], edx
  00e7b	8b 55 dc	 mov	 edx, DWORD PTR tv8761[ebp]
  00e7e	83 d2 00	 adc	 edx, 0
  00e81	89 45 ec	 mov	 DWORD PTR _nMon$1$[ebp], eax
  00e84	8b 75 ec	 mov	 esi, DWORD PTR _nMon$1$[ebp]
  00e87	03 f9		 add	 edi, ecx
  00e89	8b 4d e4	 mov	 ecx, DWORD PTR tv7539[ebp]
  00e8c	83 d1 00	 adc	 ecx, 0
  00e8f	89 7d bc	 mov	 DWORD PTR tv3716[ebp], edi
  00e92	33 c0		 xor	 eax, eax

; 2348 : 			nDay	= (lTime % 100000000) / 1000000;

  00e94	bf 11 77 cc ab	 mov	 edi, -1412663535	; abcc7711H
  00e99	03 d1		 add	 edx, ecx
  00e9b	8b 4d d8	 mov	 ecx, DWORD PTR tv8757[ebp]
  00e9e	13 c0		 adc	 eax, eax
  00ea0	03 f2		 add	 esi, edx
  00ea2	ba fd ce 61 84	 mov	 edx, -2073964803	; 8461cefdH
  00ea7	13 c8		 adc	 ecx, eax
  00ea9	8b 45 08	 mov	 eax, DWORD PTR _lTime$[ebp]
  00eac	f7 e2		 mul	 edx
  00eae	0f ac ce 1a	 shrd	 esi, ecx, 26
  00eb2	89 45 bc	 mov	 DWORD PTR tv3823[ebp], eax
  00eb5	b9 fd ce 61 84	 mov	 ecx, -2073964803	; 8461cefdH
  00eba	8b 45 08	 mov	 eax, DWORD PTR _lTime$[ebp]
  00ebd	4e		 dec	 esi
  00ebe	89 75 ec	 mov	 DWORD PTR _nMon$1$[ebp], esi
  00ec1	8b f2		 mov	 esi, edx
  00ec3	f7 e7		 mul	 edi
  00ec5	8b f8		 mov	 edi, eax
  00ec7	89 55 dc	 mov	 DWORD PTR tv7559[ebp], edx
  00eca	8b 45 0c	 mov	 eax, DWORD PTR _lTime$[ebp+4]
  00ecd	f7 e1		 mul	 ecx
  00ecf	8b c8		 mov	 ecx, eax
  00ed1	89 55 d8	 mov	 DWORD PTR tv8736[ebp], edx
  00ed4	8b 45 0c	 mov	 eax, DWORD PTR _lTime$[ebp+4]
  00ed7	ba 11 77 cc ab	 mov	 edx, -1412663535	; abcc7711H
  00edc	f7 e2		 mul	 edx
  00ede	03 ce		 add	 ecx, esi
  00ee0	89 55 e8	 mov	 DWORD PTR tv8732[ebp], edx
  00ee3	8b 55 d8	 mov	 edx, DWORD PTR tv8736[ebp]
  00ee6	83 d2 00	 adc	 edx, 0
  00ee9	89 45 e4	 mov	 DWORD PTR tv8731[ebp], eax
  00eec	8b f0		 mov	 esi, eax
  00eee	03 f9		 add	 edi, ecx
  00ef0	8b 4d dc	 mov	 ecx, DWORD PTR tv7559[ebp]
  00ef3	83 d1 00	 adc	 ecx, 0
  00ef6	89 7d bc	 mov	 DWORD PTR tv3832[ebp], edi
  00ef9	33 c0		 xor	 eax, eax
  00efb	03 d1		 add	 edx, ecx
  00efd	13 c0		 adc	 eax, eax
  00eff	03 f2		 add	 esi, edx
  00f01	8b 4d e8	 mov	 ecx, DWORD PTR tv8732[ebp]
  00f04	bf 00 e1 f5 05	 mov	 edi, 100000000		; 05f5e100H
  00f09	13 c8		 adc	 ecx, eax
  00f0b	0f ac ce 1a	 shrd	 esi, ecx, 26
  00f0f	c1 e9 1a	 shr	 ecx, 26			; 0000001aH
  00f12	8b c1		 mov	 eax, ecx
  00f14	f7 e7		 mul	 edi
  00f16	8b c8		 mov	 ecx, eax
  00f18	8b c6		 mov	 eax, esi
  00f1a	f7 e7		 mul	 edi
  00f1c	8b 7d 08	 mov	 edi, DWORD PTR _lTime$[ebp]
  00f1f	03 ca		 add	 ecx, edx
  00f21	2b f8		 sub	 edi, eax
  00f23	8b 45 0c	 mov	 eax, DWORD PTR _lTime$[ebp+4]
  00f26	1b c1		 sbb	 eax, ecx
  00f28	b9 db 34 b6 d7	 mov	 ecx, -675924773		; d7b634dbH
  00f2d	89 45 d8	 mov	 DWORD PTR tv7575[ebp], eax
  00f30	8b c7		 mov	 eax, edi
  00f32	f7 e1		 mul	 ecx
  00f34	89 45 bc	 mov	 DWORD PTR tv3954[ebp], eax
  00f37	8b f2		 mov	 esi, edx
  00f39	8b c7		 mov	 eax, edi
  00f3b	ba 82 de 1b 43	 mov	 edx, 1125899906		; 431bde82H
  00f40	f7 e2		 mul	 edx
  00f42	8b f8		 mov	 edi, eax
  00f44	89 55 e4	 mov	 DWORD PTR tv7581[ebp], edx
  00f47	8b 45 d8	 mov	 eax, DWORD PTR tv7575[ebp]
  00f4a	f7 e1		 mul	 ecx
  00f4c	8b c8		 mov	 ecx, eax
  00f4e	89 55 dc	 mov	 DWORD PTR tv8712[ebp], edx
  00f51	8b 45 d8	 mov	 eax, DWORD PTR tv7575[ebp]
  00f54	ba 82 de 1b 43	 mov	 edx, 1125899906		; 431bde82H
  00f59	f7 e2		 mul	 edx
  00f5b	03 ce		 add	 ecx, esi
  00f5d	89 55 d8	 mov	 DWORD PTR tv8708[ebp], edx
  00f60	8b 55 dc	 mov	 edx, DWORD PTR tv8712[ebp]
  00f63	83 d2 00	 adc	 edx, 0
  00f66	89 45 e8	 mov	 DWORD PTR _nDay$1$[ebp], eax
  00f69	8b 75 e8	 mov	 esi, DWORD PTR _nDay$1$[ebp]
  00f6c	03 f9		 add	 edi, ecx
  00f6e	8b 4d e4	 mov	 ecx, DWORD PTR tv7581[ebp]
  00f71	83 d1 00	 adc	 ecx, 0
  00f74	89 7d bc	 mov	 DWORD PTR tv3963[ebp], edi
  00f77	33 c0		 xor	 eax, eax

; 2349 : 			nHour	= (lTime % 1000000) / 10000;

  00f79	bf 82 de 1b 43	 mov	 edi, 1125899906		; 431bde82H
  00f7e	03 d1		 add	 edx, ecx
  00f80	8b 4d d8	 mov	 ecx, DWORD PTR tv8708[ebp]
  00f83	13 c0		 adc	 eax, eax
  00f85	03 f2		 add	 esi, edx
  00f87	ba db 34 b6 d7	 mov	 edx, -675924773		; d7b634dbH
  00f8c	13 c8		 adc	 ecx, eax
  00f8e	8b 45 08	 mov	 eax, DWORD PTR _lTime$[ebp]
  00f91	f7 e2		 mul	 edx
  00f93	0f ac ce 12	 shrd	 esi, ecx, 18
  00f97	89 45 bc	 mov	 DWORD PTR tv4067[ebp], eax
  00f9a	b9 db 34 b6 d7	 mov	 ecx, -675924773		; d7b634dbH
  00f9f	8b 45 08	 mov	 eax, DWORD PTR _lTime$[ebp]
  00fa2	89 75 e8	 mov	 DWORD PTR _nDay$1$[ebp], esi
  00fa5	8b f2		 mov	 esi, edx
  00fa7	f7 e7		 mul	 edi
  00fa9	8b f8		 mov	 edi, eax
  00fab	89 55 dc	 mov	 DWORD PTR tv7601[ebp], edx
  00fae	8b 45 0c	 mov	 eax, DWORD PTR _lTime$[ebp+4]
  00fb1	f7 e1		 mul	 ecx
  00fb3	8b c8		 mov	 ecx, eax
  00fb5	89 55 d8	 mov	 DWORD PTR tv8688[ebp], edx
  00fb8	8b 45 0c	 mov	 eax, DWORD PTR _lTime$[ebp+4]
  00fbb	ba 82 de 1b 43	 mov	 edx, 1125899906		; 431bde82H
  00fc0	f7 e2		 mul	 edx
  00fc2	03 ce		 add	 ecx, esi
  00fc4	89 55 d0	 mov	 DWORD PTR tv8684[ebp], edx
  00fc7	8b 55 d8	 mov	 edx, DWORD PTR tv8688[ebp]
  00fca	83 d2 00	 adc	 edx, 0
  00fcd	89 45 e4	 mov	 DWORD PTR tv8683[ebp], eax
  00fd0	03 f9		 add	 edi, ecx
  00fd2	8b 4d dc	 mov	 ecx, DWORD PTR tv7601[ebp]
  00fd5	89 7d bc	 mov	 DWORD PTR tv4076[ebp], edi
  00fd8	83 d1 00	 adc	 ecx, 0
  00fdb	33 c0		 xor	 eax, eax
  00fdd	03 d1		 add	 edx, ecx
  00fdf	13 c0		 adc	 eax, eax
  00fe1	8b 75 e4	 mov	 esi, DWORD PTR tv8683[ebp]
  00fe4	bf 40 42 0f 00	 mov	 edi, 1000000		; 000f4240H
  00fe9	8b 4d d0	 mov	 ecx, DWORD PTR tv8684[ebp]
  00fec	03 f2		 add	 esi, edx
  00fee	13 c8		 adc	 ecx, eax
  00ff0	0f ac ce 12	 shrd	 esi, ecx, 18
  00ff4	c1 e9 12	 shr	 ecx, 18			; 00000012H
  00ff7	8b c1		 mov	 eax, ecx
  00ff9	f7 e7		 mul	 edi
  00ffb	8b c8		 mov	 ecx, eax
  00ffd	8b c6		 mov	 eax, esi
  00fff	f7 e7		 mul	 edi
  01001	8b 7d 08	 mov	 edi, DWORD PTR _lTime$[ebp]
  01004	03 ca		 add	 ecx, edx
  01006	2b f8		 sub	 edi, eax
  01008	8b 45 0c	 mov	 eax, DWORD PTR _lTime$[ebp+4]
  0100b	1b c1		 sbb	 eax, ecx
  0100d	b9 4b 59 86 38	 mov	 ecx, 948328779		; 3886594bH
  01012	89 45 d8	 mov	 DWORD PTR tv7617[ebp], eax
  01015	8b c7		 mov	 eax, edi
  01017	f7 e1		 mul	 ecx
  01019	89 45 bc	 mov	 DWORD PTR tv4198[ebp], eax
  0101c	8b f2		 mov	 esi, edx
  0101e	8b c7		 mov	 eax, edi
  01020	ba d6 c5 6d 34	 mov	 edx, 879609302		; 346dc5d6H
  01025	f7 e2		 mul	 edx
  01027	8b f8		 mov	 edi, eax
  01029	89 55 e4	 mov	 DWORD PTR tv7623[ebp], edx
  0102c	8b 45 d8	 mov	 eax, DWORD PTR tv7617[ebp]
  0102f	f7 e1		 mul	 ecx
  01031	8b c8		 mov	 ecx, eax
  01033	89 55 d0	 mov	 DWORD PTR tv8664[ebp], edx
  01036	8b 45 d8	 mov	 eax, DWORD PTR tv7617[ebp]
  01039	ba d6 c5 6d 34	 mov	 edx, 879609302		; 346dc5d6H
  0103e	f7 e2		 mul	 edx
  01040	03 ce		 add	 ecx, esi
  01042	89 55 d8	 mov	 DWORD PTR tv8660[ebp], edx
  01045	8b 55 d0	 mov	 edx, DWORD PTR tv8664[ebp]
  01048	83 d2 00	 adc	 edx, 0
  0104b	89 45 dc	 mov	 DWORD PTR _nHour$1$[ebp], eax
  0104e	8b 75 dc	 mov	 esi, DWORD PTR _nHour$1$[ebp]
  01051	03 f9		 add	 edi, ecx
  01053	8b 4d e4	 mov	 ecx, DWORD PTR tv7623[ebp]
  01056	83 d1 00	 adc	 ecx, 0
  01059	89 7d bc	 mov	 DWORD PTR tv4207[ebp], edi
  0105c	33 c0		 xor	 eax, eax

; 2350 : 			nMin	= (lTime % 10000) / 100;

  0105e	bf d6 c5 6d 34	 mov	 edi, 879609302		; 346dc5d6H
  01063	03 d1		 add	 edx, ecx
  01065	8b 4d d8	 mov	 ecx, DWORD PTR tv8660[ebp]
  01068	13 c0		 adc	 eax, eax
  0106a	03 f2		 add	 esi, edx
  0106c	ba 4b 59 86 38	 mov	 edx, 948328779		; 3886594bH
  01071	13 c8		 adc	 ecx, eax
  01073	8b 45 08	 mov	 eax, DWORD PTR _lTime$[ebp]
  01076	f7 e2		 mul	 edx
  01078	0f ac ce 0b	 shrd	 esi, ecx, 11
  0107c	89 45 bc	 mov	 DWORD PTR tv4311[ebp], eax
  0107f	b9 4b 59 86 38	 mov	 ecx, 948328779		; 3886594bH
  01084	8b 45 08	 mov	 eax, DWORD PTR _lTime$[ebp]
  01087	89 75 dc	 mov	 DWORD PTR _nHour$1$[ebp], esi
  0108a	8b f2		 mov	 esi, edx
  0108c	f7 e7		 mul	 edi
  0108e	8b f8		 mov	 edi, eax
  01090	89 55 d8	 mov	 DWORD PTR tv7643[ebp], edx
  01093	8b 45 0c	 mov	 eax, DWORD PTR _lTime$[ebp+4]
  01096	f7 e1		 mul	 ecx
  01098	8b c8		 mov	 ecx, eax
  0109a	89 55 d0	 mov	 DWORD PTR tv8640[ebp], edx
  0109d	8b 45 0c	 mov	 eax, DWORD PTR _lTime$[ebp+4]
  010a0	ba d6 c5 6d 34	 mov	 edx, 879609302		; 346dc5d6H
  010a5	f7 e2		 mul	 edx
  010a7	03 ce		 add	 ecx, esi
  010a9	89 55 cc	 mov	 DWORD PTR tv8636[ebp], edx
  010ac	8b 55 d0	 mov	 edx, DWORD PTR tv8640[ebp]
  010af	83 d2 00	 adc	 edx, 0
  010b2	89 45 e4	 mov	 DWORD PTR tv8635[ebp], eax
  010b5	03 f9		 add	 edi, ecx
  010b7	8b 4d d8	 mov	 ecx, DWORD PTR tv7643[ebp]
  010ba	89 7d bc	 mov	 DWORD PTR tv4320[ebp], edi
  010bd	83 d1 00	 adc	 ecx, 0
  010c0	33 c0		 xor	 eax, eax
  010c2	03 d1		 add	 edx, ecx
  010c4	8b 75 e4	 mov	 esi, DWORD PTR tv8635[ebp]
  010c7	8b 4d cc	 mov	 ecx, DWORD PTR tv8636[ebp]
  010ca	bf 10 27 00 00	 mov	 edi, 10000		; 00002710H
  010cf	13 c0		 adc	 eax, eax
  010d1	03 f2		 add	 esi, edx
  010d3	13 c8		 adc	 ecx, eax
  010d5	0f ac ce 0b	 shrd	 esi, ecx, 11
  010d9	c1 e9 0b	 shr	 ecx, 11			; 0000000bH
  010dc	8b c1		 mov	 eax, ecx
  010de	f7 e7		 mul	 edi
  010e0	8b c8		 mov	 ecx, eax
  010e2	8b c6		 mov	 eax, esi
  010e4	f7 e7		 mul	 edi
  010e6	8b 7d 08	 mov	 edi, DWORD PTR _lTime$[ebp]
  010e9	03 ca		 add	 ecx, edx
  010eb	2b f8		 sub	 edi, eax
  010ed	8b 45 0c	 mov	 eax, DWORD PTR _lTime$[ebp+4]
  010f0	1b c1		 sbb	 eax, ecx
  010f2	89 7d d8	 mov	 DWORD PTR _nMin$1$[ebp], edi
  010f5	89 45 e4	 mov	 DWORD PTR tv8602[ebp], eax
  010f8	b9 15 ae 47 e1	 mov	 ecx, -515396075		; e147ae15H
  010fd	8b c7		 mov	 eax, edi
  010ff	f7 e1		 mul	 ecx
  01101	89 45 bc	 mov	 DWORD PTR tv4444[ebp], eax
  01104	8b f2		 mov	 esi, edx
  01106	8b c7		 mov	 eax, edi
  01108	ba 7a 14 ae 47	 mov	 edx, 1202590842		; 47ae147aH
  0110d	f7 e2		 mul	 edx
  0110f	8b f8		 mov	 edi, eax
  01111	89 55 d0	 mov	 DWORD PTR tv7667[ebp], edx
  01114	8b 45 e4	 mov	 eax, DWORD PTR tv8602[ebp]
  01117	f7 e1		 mul	 ecx
  01119	8b c8		 mov	 ecx, eax
  0111b	89 55 cc	 mov	 DWORD PTR tv8614[ebp], edx
  0111e	8b 45 e4	 mov	 eax, DWORD PTR tv8602[ebp]
  01121	ba 7a 14 ae 47	 mov	 edx, 1202590842		; 47ae147aH
  01126	f7 e2		 mul	 edx
  01128	03 ce		 add	 ecx, esi
  0112a	8b 75 d8	 mov	 esi, DWORD PTR _nMin$1$[ebp]
  0112d	89 55 c0	 mov	 DWORD PTR tv7677[ebp], edx
  01130	8b 55 cc	 mov	 edx, DWORD PTR tv8614[ebp]
  01133	83 d2 00	 adc	 edx, 0
  01136	89 45 c4	 mov	 DWORD PTR tv7676[ebp], eax
  01139	03 f9		 add	 edi, ecx
  0113b	8b 4d d0	 mov	 ecx, DWORD PTR tv7667[ebp]
  0113e	89 7d c8	 mov	 DWORD PTR tv4453[ebp], edi

; 2351 : 			nSec	= (lTime % 100);

  01141	bf 7a 14 ae 47	 mov	 edi, 1202590842		; 47ae147aH
  01146	83 d1 00	 adc	 ecx, 0
  01149	33 c0		 xor	 eax, eax
  0114b	03 d1		 add	 edx, ecx
  0114d	8b 4d c4	 mov	 ecx, DWORD PTR tv7676[ebp]
  01150	13 c0		 adc	 eax, eax
  01152	03 ca		 add	 ecx, edx
  01154	8b 55 c0	 mov	 edx, DWORD PTR tv7677[ebp]
  01157	13 d0		 adc	 edx, eax
  01159	8b 45 e4	 mov	 eax, DWORD PTR tv8602[ebp]
  0115c	2b f1		 sub	 esi, ecx
  0115e	1b c2		 sbb	 eax, edx
  01160	0f ac c6 01	 shrd	 esi, eax, 1
  01164	d1 e8		 shr	 eax, 1
  01166	03 f1		 add	 esi, ecx
  01168	b9 15 ae 47 e1	 mov	 ecx, -515396075		; e147ae15H
  0116d	13 c2		 adc	 eax, edx
  0116f	ba 15 ae 47 e1	 mov	 edx, -515396075		; e147ae15H
  01174	0f ac c6 06	 shrd	 esi, eax, 6
  01178	8b 45 08	 mov	 eax, DWORD PTR _lTime$[ebp]
  0117b	f7 e2		 mul	 edx
  0117d	89 75 d8	 mov	 DWORD PTR _nMin$1$[ebp], esi
  01180	89 45 bc	 mov	 DWORD PTR tv4583[ebp], eax
  01183	8b f2		 mov	 esi, edx
  01185	8b 45 08	 mov	 eax, DWORD PTR _lTime$[ebp]
  01188	f7 e7		 mul	 edi
  0118a	8b f8		 mov	 edi, eax
  0118c	89 55 c4	 mov	 DWORD PTR tv7691[ebp], edx
  0118f	8b 45 0c	 mov	 eax, DWORD PTR _lTime$[ebp+4]
  01192	f7 e1		 mul	 ecx
  01194	8b c8		 mov	 ecx, eax
  01196	89 55 c0	 mov	 DWORD PTR tv8580[ebp], edx
  01199	8b 45 0c	 mov	 eax, DWORD PTR _lTime$[ebp+4]
  0119c	ba 7a 14 ae 47	 mov	 edx, 1202590842		; 47ae147aH
  011a1	f7 e2		 mul	 edx
  011a3	03 ce		 add	 ecx, esi
  011a5	89 55 d0	 mov	 DWORD PTR tv7701[ebp], edx
  011a8	8b 55 c0	 mov	 edx, DWORD PTR tv8580[ebp]
  011ab	83 d2 00	 adc	 edx, 0
  011ae	89 45 cc	 mov	 DWORD PTR tv7700[ebp], eax
  011b1	8b f0		 mov	 esi, eax
  011b3	03 f9		 add	 edi, ecx
  011b5	8b 4d c4	 mov	 ecx, DWORD PTR tv7691[ebp]
  011b8	83 d1 00	 adc	 ecx, 0
  011bb	89 7d bc	 mov	 DWORD PTR tv4592[ebp], edi
  011be	33 c0		 xor	 eax, eax
  011c0	03 d1		 add	 edx, ecx
  011c2	8b 4d 08	 mov	 ecx, DWORD PTR _lTime$[ebp]
  011c5	13 c0		 adc	 eax, eax
  011c7	03 f2		 add	 esi, edx
  011c9	8b 55 d0	 mov	 edx, DWORD PTR tv7701[ebp]
  011cc	13 d0		 adc	 edx, eax
  011ce	8b 45 0c	 mov	 eax, DWORD PTR _lTime$[ebp+4]
  011d1	2b ce		 sub	 ecx, esi
  011d3	1b c2		 sbb	 eax, edx
  011d5	0f ac c1 01	 shrd	 ecx, eax, 1
  011d9	d1 e8		 shr	 eax, 1
  011db	03 ce		 add	 ecx, esi
  011dd	8b 75 08	 mov	 esi, DWORD PTR _lTime$[ebp]
  011e0	13 c2		 adc	 eax, edx
  011e2	8b d6		 mov	 edx, esi
  011e4	0f ac c1 06	 shrd	 ecx, eax, 6
  011e8	6b c1 64	 imul	 eax, ecx, 100
  011eb	2b d0		 sub	 edx, eax

; 2352 : 			
; 2353 : 			switch(pifRQ->eScaleUnit)

  011ed	8b 45 14	 mov	 eax, DWORD PTR _pifRQ$[ebp]
  011f0	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  011f3	48		 dec	 eax
  011f4	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  011f7	0f 87 67 09 00
	00		 ja	 $LN178@GetTimeFro
  011fd	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN161@GetTimeFro[eax]
  01204	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN162@GetTimeFro[eax*4]
$LN13@GetTimeFro:

; 2354 : 			{
; 2355 : 			case CScaleBaseData::HORZ_DAILY:		// 
; 2356 : 			case CScaleBaseData::HORZ_WEEKLEY:		//  
; 2357 : 				memset(&tmResult, 0, sizeof(tm));

  0120b	8b 7d 18	 mov	 edi, DWORD PTR _tmResult$[ebp]

; 2358 : 				tmResult.tm_year = nYear;

  0120e	8b 4d e0	 mov	 ecx, DWORD PTR _nYear$1$[ebp]
  01211	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  01217	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0
  0121e	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0
  01225	c7 47 18 00 00
	00 00		 mov	 DWORD PTR [edi+24], 0
  0122c	c7 47 1c 00 00
	00 00		 mov	 DWORD PTR [edi+28], 0
  01233	c7 47 20 00 00
	00 00		 mov	 DWORD PTR [edi+32], 0
  0123a	89 4f 14	 mov	 DWORD PTR [edi+20], ecx

; 2359 : 				tmResult.tm_mon  = nMon;

  0123d	8b 4d ec	 mov	 ecx, DWORD PTR _nMon$1$[ebp]
  01240	89 4f 10	 mov	 DWORD PTR [edi+16], ecx

; 2360 : 				tmResult.tm_mday = nDay;

  01243	8b 4d e8	 mov	 ecx, DWORD PTR _nDay$1$[ebp]
  01246	89 4f 0c	 mov	 DWORD PTR [edi+12], ecx

; 2361 : 				break;

  01249	e9 19 09 00 00	 jmp	 $LN37@GetTimeFro
$LN15@GetTimeFro:

; 2362 : 			case CScaleBaseData::HORZ_MONTHLY:		//  
; 2363 : 				memset(&tmResult, 0, sizeof(tm));

  0124e	8b 7d 18	 mov	 edi, DWORD PTR _tmResult$[ebp]

; 2364 : 				tmResult.tm_year = nYear;

  01251	8b 4d e0	 mov	 ecx, DWORD PTR _nYear$1$[ebp]
  01254	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  0125a	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0
  01261	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0
  01268	c7 47 18 00 00
	00 00		 mov	 DWORD PTR [edi+24], 0
  0126f	c7 47 1c 00 00
	00 00		 mov	 DWORD PTR [edi+28], 0
  01276	c7 47 20 00 00
	00 00		 mov	 DWORD PTR [edi+32], 0
  0127d	89 4f 14	 mov	 DWORD PTR [edi+20], ecx

; 2365 : 				tmResult.tm_mon  = nMon;

  01280	8b 4d ec	 mov	 ecx, DWORD PTR _nMon$1$[ebp]
  01283	89 4f 10	 mov	 DWORD PTR [edi+16], ecx

; 2366 : 				tmResult.tm_mday = 1;

  01286	c7 47 0c 01 00
	00 00		 mov	 DWORD PTR [edi+12], 1

; 2367 : 				break;

  0128d	e9 d5 08 00 00	 jmp	 $LN37@GetTimeFro
$LN16@GetTimeFro:

; 2368 : 			case CScaleBaseData::HORZ_TIME_ONE:		// 
; 2369 : 			case CScaleBaseData::HORZ_TIME_TWO:
; 2370 : 			case CScaleBaseData::HORZ_TICK:			//  
; 2371 : 			case CScaleBaseData::HORZ_TIME_SECOND:	// 
; 2372 : 				if (lTime > 10000000000000)
; 2373 : 				{
; 2374 : 					// Data YYYYMMDDhhmmss  ..
; 2375 : 					ptmCur->tm_year = nYear;

  01292	8b 45 20	 mov	 eax, DWORD PTR _ptmCur$1$[ebp]
  01295	8b 4d e0	 mov	 ecx, DWORD PTR _nYear$1$[ebp]

; 2376 : 					ptmCur->tm_mon  = nMon;
; 2377 : 					ptmCur->tm_mday = nDay;
; 2378 : 					ptmCur->tm_hour = nHour;
; 2379 : 					ptmCur->tm_min	= nMin;

  01298	8b 7d d8	 mov	 edi, DWORD PTR _nMin$1$[ebp]
  0129b	89 48 14	 mov	 DWORD PTR [eax+20], ecx
  0129e	8b 4d ec	 mov	 ecx, DWORD PTR _nMon$1$[ebp]
  012a1	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  012a4	8b 4d e8	 mov	 ecx, DWORD PTR _nDay$1$[ebp]
  012a7	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  012aa	8b 4d dc	 mov	 ecx, DWORD PTR _nHour$1$[ebp]
  012ad	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  012b0	89 78 04	 mov	 DWORD PTR [eax+4], edi

; 2380 : 					ptmCur->tm_sec	= nSec;

  012b3	89 10		 mov	 DWORD PTR [eax], edx

; 2381 : 					tmResult = *ptmCur;	
; 2382 : 				}			
; 2383 : 				break;
; 2384 : 			}
; 2385 : 		}

  012b5	e9 76 06 00 00	 jmp	 $LN191@GetTimeFro
$LN11@GetTimeFro:

; 2386 : 		else
; 2387 : 		{
; 2388 : 			switch(pifRQ->eScaleUnit)

  012ba	8b 45 14	 mov	 eax, DWORD PTR _pifRQ$[ebp]
  012bd	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  012c0	48		 dec	 eax
  012c1	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  012c4	0f 87 9d 08 00
	00		 ja	 $LN37@GetTimeFro
  012ca	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN163@GetTimeFro[eax]
  012d1	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN164@GetTimeFro[eax*4]
$LN21@GetTimeFro:

; 2389 : 			{
; 2390 : 			case CScaleBaseData::HORZ_DAILY:		// 
; 2391 : 			case CScaleBaseData::HORZ_WEEKLEY:		//  
; 2392 : 				if (lTime > 10000000)

  012d8	85 c9		 test	 ecx, ecx
  012da	75 0c		 jne	 SHORT $LN165@GetTimeFro
  012dc	81 fe 80 96 98
	00		 cmp	 esi, 10000000		; 00989680H
  012e2	0f 86 7f 08 00
	00		 jbe	 $LN37@GetTimeFro
$LN165@GetTimeFro:

; 2393 : 				{
; 2394 : 					// Data YYYYMMDD  ..
; 2395 : 					memset(&tmResult, 0, sizeof(tm));
; 2396 : 					if(lTime)
; 2397 : 					{
; 2398 : 						tmResult.tm_year = (lTime / 10000) - 1900;

  012e8	8b c6		 mov	 eax, esi
  012ea	ba 4b 59 86 38	 mov	 edx, 948328779		; 3886594bH
  012ef	f7 e2		 mul	 edx
  012f1	0f 57 c0	 xorps	 xmm0, xmm0
  012f4	0f 11 07	 movups	 XMMWORD PTR [edi], xmm0
  012f7	0f 11 47 10	 movups	 XMMWORD PTR [edi+16], xmm0
  012fb	c7 47 20 00 00
	00 00		 mov	 DWORD PTR [edi+32], 0
  01302	bf d6 c5 6d 34	 mov	 edi, 879609302		; 346dc5d6H
  01307	89 45 ac	 mov	 DWORD PTR tv4750[ebp], eax
  0130a	8b f2		 mov	 esi, edx
  0130c	8b 45 08	 mov	 eax, DWORD PTR _lTime$[ebp]
  0130f	f7 e7		 mul	 edi
  01311	8b f8		 mov	 edi, eax
  01313	89 55 c0	 mov	 DWORD PTR tv7718[ebp], edx
  01316	8b c1		 mov	 eax, ecx
  01318	b9 4b 59 86 38	 mov	 ecx, 948328779		; 3886594bH
  0131d	f7 e1		 mul	 ecx
  0131f	8b c8		 mov	 ecx, eax
  01321	89 55 20	 mov	 DWORD PTR tv8540[ebp], edx
  01324	8b 45 0c	 mov	 eax, DWORD PTR _lTime$[ebp+4]
  01327	ba d6 c5 6d 34	 mov	 edx, 879609302		; 346dc5d6H
  0132c	f7 e2		 mul	 edx
  0132e	03 ce		 add	 ecx, esi
  01330	89 55 cc	 mov	 DWORD PTR tv7184[ebp], edx
  01333	8b 55 20	 mov	 edx, DWORD PTR tv8540[ebp]
  01336	83 d2 00	 adc	 edx, 0
  01339	89 45 c4	 mov	 DWORD PTR tv7124[ebp], eax
  0133c	8b f0		 mov	 esi, eax
  0133e	03 f9		 add	 edi, ecx
  01340	8b 4d c0	 mov	 ecx, DWORD PTR tv7718[ebp]
  01343	83 d1 00	 adc	 ecx, 0
  01346	89 7d ac	 mov	 DWORD PTR tv4759[ebp], edi
  01349	33 c0		 xor	 eax, eax

; 2399 : 						tmResult.tm_mon  = (lTime % 10000) / 100 - 1;

  0134b	bf 10 27 00 00	 mov	 edi, 10000		; 00002710H
  01350	03 d1		 add	 edx, ecx
  01352	8b 4d cc	 mov	 ecx, DWORD PTR tv7184[ebp]
  01355	13 c0		 adc	 eax, eax
  01357	03 f2		 add	 esi, edx
  01359	8b 55 18	 mov	 edx, DWORD PTR _tmResult$[ebp]
  0135c	13 c8		 adc	 ecx, eax
  0135e	0f ac ce 0b	 shrd	 esi, ecx, 11
  01362	c1 e9 0b	 shr	 ecx, 11			; 0000000bH
  01365	8d 86 94 f8 ff
	ff		 lea	 eax, DWORD PTR [esi-1900]
  0136b	89 42 14	 mov	 DWORD PTR [edx+20], eax
  0136e	8b c1		 mov	 eax, ecx
  01370	f7 e7		 mul	 edi
  01372	8b c8		 mov	 ecx, eax
  01374	8b c6		 mov	 eax, esi
  01376	f7 e7		 mul	 edi
  01378	8b 7d 08	 mov	 edi, DWORD PTR _lTime$[ebp]
  0137b	03 ca		 add	 ecx, edx
  0137d	2b f8		 sub	 edi, eax
  0137f	8b 45 0c	 mov	 eax, DWORD PTR _lTime$[ebp+4]
  01382	1b c1		 sbb	 eax, ecx
  01384	89 7d d8	 mov	 DWORD PTR tv8499[ebp], edi
  01387	89 45 20	 mov	 DWORD PTR tv8501[ebp], eax
  0138a	b9 15 ae 47 e1	 mov	 ecx, -515396075		; e147ae15H
  0138f	8b c7		 mov	 eax, edi
  01391	f7 e1		 mul	 ecx
  01393	8b f2		 mov	 esi, edx
  01395	89 45 ac	 mov	 DWORD PTR tv4881[ebp], eax
  01398	8b c7		 mov	 eax, edi
  0139a	ba 7a 14 ae 47	 mov	 edx, 1202590842		; 47ae147aH
  0139f	f7 e2		 mul	 edx
  013a1	8b f8		 mov	 edi, eax
  013a3	89 55 c4	 mov	 DWORD PTR tv7742[ebp], edx
  013a6	8b 45 20	 mov	 eax, DWORD PTR tv8501[ebp]
  013a9	f7 e1		 mul	 ecx
  013ab	89 55 c0	 mov	 DWORD PTR tv8513[ebp], edx
  013ae	8b c8		 mov	 ecx, eax
  013b0	8b 45 20	 mov	 eax, DWORD PTR tv8501[ebp]
  013b3	ba 7a 14 ae 47	 mov	 edx, 1202590842		; 47ae147aH
  013b8	f7 e2		 mul	 edx
  013ba	03 ce		 add	 ecx, esi
  013bc	89 55 d0	 mov	 DWORD PTR tv7752[ebp], edx
  013bf	8b 55 c0	 mov	 edx, DWORD PTR tv8513[ebp]
  013c2	83 d2 00	 adc	 edx, 0
  013c5	89 45 cc	 mov	 DWORD PTR tv7751[ebp], eax
  013c8	03 f9		 add	 edi, ecx
  013ca	8b 4d c4	 mov	 ecx, DWORD PTR tv7742[ebp]
  013cd	89 7d ac	 mov	 DWORD PTR tv4890[ebp], edi
  013d0	83 d1 00	 adc	 ecx, 0
  013d3	8b 75 d8	 mov	 esi, DWORD PTR tv8499[ebp]
  013d6	33 c0		 xor	 eax, eax

; 2400 : 						tmResult.tm_mday = (lTime % 100);

  013d8	bf 7a 14 ae 47	 mov	 edi, 1202590842		; 47ae147aH
  013dd	03 d1		 add	 edx, ecx
  013df	8b 4d cc	 mov	 ecx, DWORD PTR tv7751[ebp]
  013e2	13 c0		 adc	 eax, eax
  013e4	03 ca		 add	 ecx, edx
  013e6	8b 55 d0	 mov	 edx, DWORD PTR tv7752[ebp]
  013e9	13 d0		 adc	 edx, eax
  013eb	8b 45 20	 mov	 eax, DWORD PTR tv8501[ebp]
  013ee	2b f1		 sub	 esi, ecx
  013f0	1b c2		 sbb	 eax, edx
  013f2	0f ac c6 01	 shrd	 esi, eax, 1
  013f6	d1 e8		 shr	 eax, 1
  013f8	03 f1		 add	 esi, ecx
  013fa	b9 15 ae 47 e1	 mov	 ecx, -515396075		; e147ae15H
  013ff	13 c2		 adc	 eax, edx
  01401	ba 15 ae 47 e1	 mov	 edx, -515396075		; e147ae15H
  01406	0f ac c6 06	 shrd	 esi, eax, 6
  0140a	8b 45 18	 mov	 eax, DWORD PTR _tmResult$[ebp]
  0140d	4e		 dec	 esi
  0140e	89 70 10	 mov	 DWORD PTR [eax+16], esi
  01411	8b 45 08	 mov	 eax, DWORD PTR _lTime$[ebp]
  01414	f7 e2		 mul	 edx
  01416	89 45 ac	 mov	 DWORD PTR tv5020[ebp], eax
  01419	8b f2		 mov	 esi, edx
  0141b	8b 45 08	 mov	 eax, DWORD PTR _lTime$[ebp]
  0141e	f7 e7		 mul	 edi
  01420	8b f8		 mov	 edi, eax
  01422	89 55 c0	 mov	 DWORD PTR tv7766[ebp], edx
  01425	8b 45 0c	 mov	 eax, DWORD PTR _lTime$[ebp+4]
  01428	f7 e1		 mul	 ecx
  0142a	8b c8		 mov	 ecx, eax
  0142c	89 55 20	 mov	 DWORD PTR tv8478[ebp], edx
  0142f	8b 45 0c	 mov	 eax, DWORD PTR _lTime$[ebp+4]
  01432	ba 7a 14 ae 47	 mov	 edx, 1202590842		; 47ae147aH
  01437	f7 e2		 mul	 edx
  01439	03 ce		 add	 ecx, esi
  0143b	89 55 cc	 mov	 DWORD PTR tv7776[ebp], edx
  0143e	8b 55 20	 mov	 edx, DWORD PTR tv8478[ebp]
  01441	83 d2 00	 adc	 edx, 0
  01444	89 45 c4	 mov	 DWORD PTR tv7775[ebp], eax
  01447	8b f0		 mov	 esi, eax
  01449	03 f9		 add	 edi, ecx
  0144b	8b 4d c0	 mov	 ecx, DWORD PTR tv7766[ebp]
  0144e	83 d1 00	 adc	 ecx, 0
  01451	89 7d ac	 mov	 DWORD PTR tv5029[ebp], edi
  01454	33 c0		 xor	 eax, eax
  01456	8b 7d 18	 mov	 edi, DWORD PTR _tmResult$[ebp]
  01459	03 d1		 add	 edx, ecx
  0145b	8b 4d 08	 mov	 ecx, DWORD PTR _lTime$[ebp]
  0145e	13 c0		 adc	 eax, eax
  01460	03 f2		 add	 esi, edx
  01462	8b 55 cc	 mov	 edx, DWORD PTR tv7776[ebp]
  01465	13 d0		 adc	 edx, eax
  01467	8b 45 0c	 mov	 eax, DWORD PTR _lTime$[ebp+4]
  0146a	2b ce		 sub	 ecx, esi
  0146c	1b c2		 sbb	 eax, edx
  0146e	0f ac c1 01	 shrd	 ecx, eax, 1
  01472	d1 e8		 shr	 eax, 1
  01474	03 ce		 add	 ecx, esi
  01476	8b 75 08	 mov	 esi, DWORD PTR _lTime$[ebp]
  01479	13 c2		 adc	 eax, edx
  0147b	0f ac c1 06	 shrd	 ecx, eax, 6
  0147f	6b c1 64	 imul	 eax, ecx, 100
  01482	8b ce		 mov	 ecx, esi
  01484	2b c8		 sub	 ecx, eax
  01486	89 4f 0c	 mov	 DWORD PTR [edi+12], ecx

; 2401 : 					}
; 2402 : 				}
; 2403 : 				break;

  01489	e9 d9 06 00 00	 jmp	 $LN37@GetTimeFro
$LN25@GetTimeFro:

; 2404 : 			case CScaleBaseData::HORZ_MONTHLY:		//  
; 2405 : // vntsorl_20110407:[A00000378] Global  //    
; 2406 : 				if (lTime > 10000000)

  0148e	85 c9		 test	 ecx, ecx
  01490	0f 85 c8 00 00
	00		 jne	 $LN166@GetTimeFro
  01496	81 fe 80 96 98
	00		 cmp	 esi, 10000000		; 00989680H
  0149c	0f 87 bc 00 00
	00		 ja	 $LN166@GetTimeFro

; 2417 : 				else if (lTime > 100000)

  014a2	85 c9		 test	 ecx, ecx
  014a4	75 0c		 jne	 SHORT $LN167@GetTimeFro
  014a6	81 fe a0 86 01
	00		 cmp	 esi, 100000		; 000186a0H
  014ac	0f 86 b5 06 00
	00		 jbe	 $LN37@GetTimeFro
$LN167@GetTimeFro:

; 2418 : 				{
; 2419 : 					// Data YYYYMM  ..
; 2420 : 					memset(&tmResult, 0, sizeof(tm));
; 2421 : 					if(lTime)
; 2422 : 					{
; 2423 : 						tmResult.tm_year = (lTime / 100) - 1900;

  014b2	8b c6		 mov	 eax, esi
  014b4	ba 15 ae 47 e1	 mov	 edx, -515396075		; e147ae15H
  014b9	f7 e2		 mul	 edx
  014bb	0f 57 c0	 xorps	 xmm0, xmm0
  014be	0f 11 07	 movups	 XMMWORD PTR [edi], xmm0
  014c1	0f 11 47 10	 movups	 XMMWORD PTR [edi+16], xmm0
  014c5	c7 47 20 00 00
	00 00		 mov	 DWORD PTR [edi+32], 0
  014cc	bf 7a 14 ae 47	 mov	 edi, 1202590842		; 47ae147aH
  014d1	89 45 ac	 mov	 DWORD PTR tv5573[ebp], eax
  014d4	8b f2		 mov	 esi, edx
  014d6	8b 45 08	 mov	 eax, DWORD PTR _lTime$[ebp]
  014d9	f7 e7		 mul	 edi
  014db	8b f8		 mov	 edi, eax
  014dd	89 55 c0	 mov	 DWORD PTR tv7862[ebp], edx
  014e0	8b c1		 mov	 eax, ecx
  014e2	b9 15 ae 47 e1	 mov	 ecx, -515396075		; e147ae15H
  014e7	f7 e1		 mul	 ecx
  014e9	8b c8		 mov	 ecx, eax
  014eb	89 55 20	 mov	 DWORD PTR tv8441[ebp], edx
  014ee	8b 45 0c	 mov	 eax, DWORD PTR _lTime$[ebp+4]
  014f1	ba 7a 14 ae 47	 mov	 edx, 1202590842		; 47ae147aH
  014f6	f7 e2		 mul	 edx
  014f8	03 ce		 add	 ecx, esi
  014fa	89 55 cc	 mov	 DWORD PTR tv7872[ebp], edx
  014fd	8b 55 20	 mov	 edx, DWORD PTR tv8441[ebp]
  01500	83 d2 00	 adc	 edx, 0
  01503	89 45 c4	 mov	 DWORD PTR tv7871[ebp], eax
  01506	8b f0		 mov	 esi, eax
  01508	03 f9		 add	 edi, ecx
  0150a	8b 4d c0	 mov	 ecx, DWORD PTR tv7862[ebp]
  0150d	83 d1 00	 adc	 ecx, 0
  01510	89 7d ac	 mov	 DWORD PTR tv5582[ebp], edi
  01513	33 c0		 xor	 eax, eax
  01515	8b 7d 18	 mov	 edi, DWORD PTR _tmResult$[ebp]
  01518	03 d1		 add	 edx, ecx
  0151a	8b 4d 08	 mov	 ecx, DWORD PTR _lTime$[ebp]
  0151d	13 c0		 adc	 eax, eax
  0151f	03 f2		 add	 esi, edx
  01521	8b 55 cc	 mov	 edx, DWORD PTR tv7872[ebp]
  01524	13 d0		 adc	 edx, eax

; 2424 : 						tmResult.tm_mon = (lTime % 100) - 1;
; 2425 : 						tmResult.tm_mday = 1;

  01526	c7 47 0c 01 00
	00 00		 mov	 DWORD PTR [edi+12], 1
  0152d	8b 45 0c	 mov	 eax, DWORD PTR _lTime$[ebp+4]
  01530	2b ce		 sub	 ecx, esi
  01532	1b c2		 sbb	 eax, edx
  01534	0f ac c1 01	 shrd	 ecx, eax, 1
  01538	d1 e8		 shr	 eax, 1
  0153a	03 ce		 add	 ecx, esi
  0153c	8b 75 08	 mov	 esi, DWORD PTR _lTime$[ebp]
  0153f	13 c2		 adc	 eax, edx
  01541	0f ac c1 06	 shrd	 ecx, eax, 6
  01545	8d 81 94 f8 ff
	ff		 lea	 eax, DWORD PTR [ecx-1900]
  0154b	89 47 14	 mov	 DWORD PTR [edi+20], eax
  0154e	6b c1 64	 imul	 eax, ecx, 100
  01551	8b ce		 mov	 ecx, esi
  01553	2b c8		 sub	 ecx, eax
  01555	49		 dec	 ecx
  01556	89 4f 10	 mov	 DWORD PTR [edi+16], ecx

; 2426 : 					}
; 2427 : 				}
; 2428 : 				break;

  01559	e9 09 06 00 00	 jmp	 $LN37@GetTimeFro
$LN166@GetTimeFro:

; 2407 : 				{
; 2408 : 					// Data YYYYMMDD  ..
; 2409 : 					memset(&tmResult, 0, sizeof(tm));
; 2410 : 					if(lTime)
; 2411 : 					{
; 2412 : 						tmResult.tm_year = (lTime / 10000) - 1900;

  0155e	8b c6		 mov	 eax, esi
  01560	ba 4b 59 86 38	 mov	 edx, 948328779		; 3886594bH
  01565	f7 e2		 mul	 edx
  01567	0f 57 c0	 xorps	 xmm0, xmm0
  0156a	0f 11 07	 movups	 XMMWORD PTR [edi], xmm0
  0156d	0f 11 47 10	 movups	 XMMWORD PTR [edi+16], xmm0
  01571	c7 47 20 00 00
	00 00		 mov	 DWORD PTR [edi+32], 0
  01578	bf d6 c5 6d 34	 mov	 edi, 879609302		; 346dc5d6H
  0157d	89 45 ac	 mov	 DWORD PTR tv5159[ebp], eax
  01580	8b f2		 mov	 esi, edx
  01582	8b 45 08	 mov	 eax, DWORD PTR _lTime$[ebp]
  01585	f7 e7		 mul	 edi
  01587	8b f8		 mov	 edi, eax
  01589	89 55 c0	 mov	 DWORD PTR tv7789[ebp], edx
  0158c	8b c1		 mov	 eax, ecx
  0158e	b9 4b 59 86 38	 mov	 ecx, 948328779		; 3886594bH
  01593	f7 e1		 mul	 ecx
  01595	8b c8		 mov	 ecx, eax
  01597	89 55 20	 mov	 DWORD PTR tv8405[ebp], edx
  0159a	8b 45 0c	 mov	 eax, DWORD PTR _lTime$[ebp+4]
  0159d	ba d6 c5 6d 34	 mov	 edx, 879609302		; 346dc5d6H
  015a2	f7 e2		 mul	 edx
  015a4	03 ce		 add	 ecx, esi
  015a6	89 55 cc	 mov	 DWORD PTR tv7185[ebp], edx
  015a9	8b 55 20	 mov	 edx, DWORD PTR tv8405[ebp]
  015ac	83 d2 00	 adc	 edx, 0
  015af	89 45 c4	 mov	 DWORD PTR tv7125[ebp], eax
  015b2	8b f0		 mov	 esi, eax
  015b4	03 f9		 add	 edi, ecx
  015b6	8b 4d c0	 mov	 ecx, DWORD PTR tv7789[ebp]
  015b9	83 d1 00	 adc	 ecx, 0
  015bc	89 7d ac	 mov	 DWORD PTR tv5168[ebp], edi
  015bf	33 c0		 xor	 eax, eax

; 2413 : 						tmResult.tm_mon  = (lTime % 10000) / 100 - 1;

  015c1	bf 10 27 00 00	 mov	 edi, 10000		; 00002710H
  015c6	03 d1		 add	 edx, ecx
  015c8	8b 4d cc	 mov	 ecx, DWORD PTR tv7185[ebp]
  015cb	13 c0		 adc	 eax, eax
  015cd	03 f2		 add	 esi, edx
  015cf	8b 55 18	 mov	 edx, DWORD PTR _tmResult$[ebp]
  015d2	13 c8		 adc	 ecx, eax
  015d4	0f ac ce 0b	 shrd	 esi, ecx, 11
  015d8	c1 e9 0b	 shr	 ecx, 11			; 0000000bH
  015db	8d 86 94 f8 ff
	ff		 lea	 eax, DWORD PTR [esi-1900]
  015e1	89 42 14	 mov	 DWORD PTR [edx+20], eax
  015e4	8b c1		 mov	 eax, ecx
  015e6	f7 e7		 mul	 edi
  015e8	8b c8		 mov	 ecx, eax
  015ea	8b c6		 mov	 eax, esi
  015ec	f7 e7		 mul	 edi
  015ee	8b 7d 08	 mov	 edi, DWORD PTR _lTime$[ebp]
  015f1	03 ca		 add	 ecx, edx
  015f3	2b f8		 sub	 edi, eax
  015f5	8b 45 0c	 mov	 eax, DWORD PTR _lTime$[ebp+4]
  015f8	1b c1		 sbb	 eax, ecx
  015fa	89 7d d8	 mov	 DWORD PTR tv8364[ebp], edi
  015fd	89 45 20	 mov	 DWORD PTR tv8366[ebp], eax
  01600	b9 15 ae 47 e1	 mov	 ecx, -515396075		; e147ae15H
  01605	8b c7		 mov	 eax, edi
  01607	f7 e1		 mul	 ecx
  01609	8b f2		 mov	 esi, edx
  0160b	89 45 ac	 mov	 DWORD PTR tv5290[ebp], eax
  0160e	8b c7		 mov	 eax, edi
  01610	ba 7a 14 ae 47	 mov	 edx, 1202590842		; 47ae147aH
  01615	f7 e2		 mul	 edx
  01617	8b f8		 mov	 edi, eax
  01619	89 55 c4	 mov	 DWORD PTR tv7813[ebp], edx
  0161c	8b 45 20	 mov	 eax, DWORD PTR tv8366[ebp]
  0161f	f7 e1		 mul	 ecx
  01621	89 55 c0	 mov	 DWORD PTR tv8378[ebp], edx
  01624	8b c8		 mov	 ecx, eax
  01626	8b 45 20	 mov	 eax, DWORD PTR tv8366[ebp]
  01629	ba 7a 14 ae 47	 mov	 edx, 1202590842		; 47ae147aH
  0162e	f7 e2		 mul	 edx
  01630	03 ce		 add	 ecx, esi
  01632	89 55 d0	 mov	 DWORD PTR tv7823[ebp], edx
  01635	8b 55 c0	 mov	 edx, DWORD PTR tv8378[ebp]
  01638	83 d2 00	 adc	 edx, 0
  0163b	89 45 cc	 mov	 DWORD PTR tv7822[ebp], eax
  0163e	03 f9		 add	 edi, ecx
  01640	8b 4d c4	 mov	 ecx, DWORD PTR tv7813[ebp]
  01643	89 7d ac	 mov	 DWORD PTR tv5299[ebp], edi
  01646	83 d1 00	 adc	 ecx, 0
  01649	8b 75 d8	 mov	 esi, DWORD PTR tv8364[ebp]
  0164c	33 c0		 xor	 eax, eax

; 2414 : 						tmResult.tm_mday = (lTime % 100);

  0164e	bf 7a 14 ae 47	 mov	 edi, 1202590842		; 47ae147aH
  01653	03 d1		 add	 edx, ecx
  01655	8b 4d cc	 mov	 ecx, DWORD PTR tv7822[ebp]
  01658	13 c0		 adc	 eax, eax
  0165a	03 ca		 add	 ecx, edx
  0165c	8b 55 d0	 mov	 edx, DWORD PTR tv7823[ebp]
  0165f	13 d0		 adc	 edx, eax
  01661	8b 45 20	 mov	 eax, DWORD PTR tv8366[ebp]
  01664	2b f1		 sub	 esi, ecx
  01666	1b c2		 sbb	 eax, edx
  01668	0f ac c6 01	 shrd	 esi, eax, 1
  0166c	d1 e8		 shr	 eax, 1
  0166e	03 f1		 add	 esi, ecx
  01670	b9 15 ae 47 e1	 mov	 ecx, -515396075		; e147ae15H
  01675	13 c2		 adc	 eax, edx
  01677	ba 15 ae 47 e1	 mov	 edx, -515396075		; e147ae15H
  0167c	0f ac c6 06	 shrd	 esi, eax, 6
  01680	8b 45 18	 mov	 eax, DWORD PTR _tmResult$[ebp]
  01683	4e		 dec	 esi
  01684	89 70 10	 mov	 DWORD PTR [eax+16], esi
  01687	8b 45 08	 mov	 eax, DWORD PTR _lTime$[ebp]
  0168a	f7 e2		 mul	 edx
  0168c	89 45 ac	 mov	 DWORD PTR tv5429[ebp], eax
  0168f	8b f2		 mov	 esi, edx
  01691	8b 45 08	 mov	 eax, DWORD PTR _lTime$[ebp]
  01694	f7 e7		 mul	 edi
  01696	8b f8		 mov	 edi, eax
  01698	89 55 c0	 mov	 DWORD PTR tv7837[ebp], edx
  0169b	8b 45 0c	 mov	 eax, DWORD PTR _lTime$[ebp+4]
  0169e	f7 e1		 mul	 ecx
  016a0	8b c8		 mov	 ecx, eax
  016a2	89 55 20	 mov	 DWORD PTR tv8343[ebp], edx
  016a5	8b 45 0c	 mov	 eax, DWORD PTR _lTime$[ebp+4]
  016a8	ba 7a 14 ae 47	 mov	 edx, 1202590842		; 47ae147aH
  016ad	f7 e2		 mul	 edx
  016af	03 ce		 add	 ecx, esi
  016b1	89 55 cc	 mov	 DWORD PTR tv7847[ebp], edx
  016b4	8b 55 20	 mov	 edx, DWORD PTR tv8343[ebp]
  016b7	83 d2 00	 adc	 edx, 0
  016ba	89 45 c4	 mov	 DWORD PTR tv7846[ebp], eax
  016bd	8b f0		 mov	 esi, eax
  016bf	03 f9		 add	 edi, ecx
  016c1	8b 4d c0	 mov	 ecx, DWORD PTR tv7837[ebp]
  016c4	83 d1 00	 adc	 ecx, 0
  016c7	89 7d ac	 mov	 DWORD PTR tv5438[ebp], edi
  016ca	33 c0		 xor	 eax, eax
  016cc	8b 7d 18	 mov	 edi, DWORD PTR _tmResult$[ebp]
  016cf	03 d1		 add	 edx, ecx
  016d1	8b 4d 08	 mov	 ecx, DWORD PTR _lTime$[ebp]
  016d4	13 c0		 adc	 eax, eax
  016d6	03 f2		 add	 esi, edx
  016d8	8b 55 cc	 mov	 edx, DWORD PTR tv7847[ebp]
  016db	13 d0		 adc	 edx, eax
  016dd	8b 45 0c	 mov	 eax, DWORD PTR _lTime$[ebp+4]
  016e0	2b ce		 sub	 ecx, esi
  016e2	1b c2		 sbb	 eax, edx
  016e4	0f ac c1 01	 shrd	 ecx, eax, 1
  016e8	d1 e8		 shr	 eax, 1
  016ea	03 ce		 add	 ecx, esi
  016ec	8b 75 08	 mov	 esi, DWORD PTR _lTime$[ebp]
  016ef	13 c2		 adc	 eax, edx
  016f1	0f ac c1 06	 shrd	 ecx, eax, 6
  016f5	6b c1 64	 imul	 eax, ecx, 100
  016f8	8b ce		 mov	 ecx, esi
  016fa	2b c8		 sub	 ecx, eax
  016fc	89 4f 0c	 mov	 DWORD PTR [edi+12], ecx

; 2415 : 					}
; 2416 : 				}

  016ff	e9 63 04 00 00	 jmp	 $LN37@GetTimeFro
$LN31@GetTimeFro:

; 2429 : 			case CScaleBaseData::HORZ_TIME_ONE:		// 
; 2430 : 			case CScaleBaseData::HORZ_TIME_TWO:
; 2431 : // vntsorl_20110407:[A00000378] Global  //    
; 2432 : 				// Data MMDDHHMM  ..
; 2433 : 				if (lTime > 1000000)

  01704	85 c9		 test	 ecx, ecx
  01706	75 0c		 jne	 SHORT $LN168@GetTimeFro
  01708	81 fe 40 42 0f
	00		 cmp	 esi, 1000000		; 000f4240H
  0170e	0f 86 53 04 00
	00		 jbe	 $LN37@GetTimeFro
$LN168@GetTimeFro:

; 2434 : 				{
; 2435 : 					// Data YYYYMMDD  ..
; 2436 : 					memset(&tmResult, 0, sizeof(tm));
; 2437 : 					if(lTime)
; 2438 : 					{
; 2439 : 						ptmCur->tm_mon  = (lTime / 1000000) - 1;

  01714	8b c6		 mov	 eax, esi
  01716	ba db 34 b6 d7	 mov	 edx, -675924773		; d7b634dbH
  0171b	f7 e2		 mul	 edx
  0171d	0f 57 c0	 xorps	 xmm0, xmm0
  01720	0f 11 07	 movups	 XMMWORD PTR [edi], xmm0
  01723	0f 11 47 10	 movups	 XMMWORD PTR [edi+16], xmm0
  01727	c7 47 20 00 00
	00 00		 mov	 DWORD PTR [edi+32], 0
  0172e	bf 82 de 1b 43	 mov	 edi, 1125899906		; 431bde82H
  01733	89 45 bc	 mov	 DWORD PTR tv5712[ebp], eax
  01736	8b f2		 mov	 esi, edx
  01738	8b 45 08	 mov	 eax, DWORD PTR _lTime$[ebp]
  0173b	f7 e7		 mul	 edi

; 2440 : 						ptmCur->tm_mday = (lTime / 10000) % 100;

  0173d	6a 00		 push	 0
  0173f	8b f8		 mov	 edi, eax
  01741	89 55 c4	 mov	 DWORD PTR tv7885[ebp], edx
  01744	8b c1		 mov	 eax, ecx
  01746	b9 db 34 b6 d7	 mov	 ecx, -675924773		; d7b634dbH
  0174b	f7 e1		 mul	 ecx
  0174d	6a 64		 push	 100			; 00000064H
  0174f	8b c8		 mov	 ecx, eax
  01751	89 55 c0	 mov	 DWORD PTR tv8308[ebp], edx
  01754	8b 45 0c	 mov	 eax, DWORD PTR _lTime$[ebp+4]
  01757	ba 82 de 1b 43	 mov	 edx, 1125899906		; 431bde82H
  0175c	f7 e2		 mul	 edx
  0175e	03 ce		 add	 ecx, esi
  01760	89 55 d0	 mov	 DWORD PTR tv8304[ebp], edx
  01763	8b 55 c0	 mov	 edx, DWORD PTR tv8308[ebp]
  01766	83 d2 00	 adc	 edx, 0
  01769	89 45 cc	 mov	 DWORD PTR tv8302[ebp], eax
  0176c	8b f0		 mov	 esi, eax
  0176e	03 f9		 add	 edi, ecx
  01770	8b 4d c4	 mov	 ecx, DWORD PTR tv7885[ebp]
  01773	83 d1 00	 adc	 ecx, 0
  01776	89 7d bc	 mov	 DWORD PTR tv5721[ebp], edi
  01779	33 c0		 xor	 eax, eax
  0177b	bf d6 c5 6d 34	 mov	 edi, 879609302		; 346dc5d6H
  01780	03 d1		 add	 edx, ecx
  01782	8b 4d d0	 mov	 ecx, DWORD PTR tv8304[ebp]
  01785	13 c0		 adc	 eax, eax
  01787	03 f2		 add	 esi, edx
  01789	ba 4b 59 86 38	 mov	 edx, 948328779		; 3886594bH
  0178e	13 c8		 adc	 ecx, eax
  01790	8b 45 20	 mov	 eax, DWORD PTR _ptmCur$1$[ebp]
  01793	0f ac ce 12	 shrd	 esi, ecx, 18
  01797	b9 4b 59 86 38	 mov	 ecx, 948328779		; 3886594bH
  0179c	4e		 dec	 esi
  0179d	89 70 10	 mov	 DWORD PTR [eax+16], esi
  017a0	8b 45 08	 mov	 eax, DWORD PTR _lTime$[ebp]
  017a3	f7 e2		 mul	 edx
  017a5	89 45 bc	 mov	 DWORD PTR tv5828[ebp], eax
  017a8	8b f2		 mov	 esi, edx
  017aa	8b 45 08	 mov	 eax, DWORD PTR _lTime$[ebp]
  017ad	f7 e7		 mul	 edi
  017af	8b f8		 mov	 edi, eax
  017b1	89 55 c4	 mov	 DWORD PTR tv7905[ebp], edx
  017b4	8b 45 0c	 mov	 eax, DWORD PTR _lTime$[ebp+4]
  017b7	f7 e1		 mul	 ecx
  017b9	8b c8		 mov	 ecx, eax
  017bb	89 55 c0	 mov	 DWORD PTR tv8283[ebp], edx
  017be	8b 45 0c	 mov	 eax, DWORD PTR _lTime$[ebp+4]
  017c1	ba d6 c5 6d 34	 mov	 edx, 879609302		; 346dc5d6H
  017c6	f7 e2		 mul	 edx
  017c8	03 ce		 add	 ecx, esi
  017ca	89 55 d0	 mov	 DWORD PTR tv8277[ebp], edx
  017cd	8b 55 c0	 mov	 edx, DWORD PTR tv8283[ebp]
  017d0	8b 75 d0	 mov	 esi, DWORD PTR tv8277[ebp]
  017d3	83 d2 00	 adc	 edx, 0
  017d6	03 f9		 add	 edi, ecx
  017d8	89 45 cc	 mov	 DWORD PTR tv8276[ebp], eax
  017db	8b 4d c4	 mov	 ecx, DWORD PTR tv7905[ebp]
  017de	83 d1 00	 adc	 ecx, 0
  017e1	89 7d bc	 mov	 DWORD PTR tv5837[ebp], edi
  017e4	8b 7d cc	 mov	 edi, DWORD PTR tv8276[ebp]
  017e7	33 c0		 xor	 eax, eax
  017e9	03 d1		 add	 edx, ecx
  017eb	13 c0		 adc	 eax, eax
  017ed	03 fa		 add	 edi, edx
  017ef	13 f0		 adc	 esi, eax
  017f1	0f ac f7 0b	 shrd	 edi, esi, 11
  017f5	c1 ee 0b	 shr	 esi, 11			; 0000000bH
  017f8	56		 push	 esi
  017f9	57		 push	 edi
  017fa	e8 00 00 00 00	 call	 __aullrem
  017ff	8b 4d 20	 mov	 ecx, DWORD PTR _ptmCur$1$[ebp]
  01802	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 2441 : 						ptmCur->tm_hour = (lTime % 10000) / 100;

  01805	8b c6		 mov	 eax, esi
  01807	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  0180c	f7 e1		 mul	 ecx
  0180e	ba 10 27 00 00	 mov	 edx, 10000		; 00002710H
  01813	8b c8		 mov	 ecx, eax
  01815	8b c7		 mov	 eax, edi
  01817	f7 e2		 mul	 edx
  01819	8b 7d 08	 mov	 edi, DWORD PTR _lTime$[ebp]
  0181c	03 ca		 add	 ecx, edx
  0181e	2b f8		 sub	 edi, eax
  01820	8b 45 0c	 mov	 eax, DWORD PTR _lTime$[ebp+4]
  01823	1b c1		 sbb	 eax, ecx
  01825	89 7d dc	 mov	 DWORD PTR tv8241[ebp], edi
  01828	89 45 d8	 mov	 DWORD PTR tv8242[ebp], eax
  0182b	b9 15 ae 47 e1	 mov	 ecx, -515396075		; e147ae15H
  01830	8b c7		 mov	 eax, edi
  01832	f7 e1		 mul	 ecx
  01834	89 45 bc	 mov	 DWORD PTR tv5972[ebp], eax
  01837	8b f2		 mov	 esi, edx
  01839	8b c7		 mov	 eax, edi
  0183b	ba 7a 14 ae 47	 mov	 edx, 1202590842		; 47ae147aH
  01840	f7 e2		 mul	 edx
  01842	8b f8		 mov	 edi, eax
  01844	89 55 c4	 mov	 DWORD PTR tv7929[ebp], edx
  01847	8b 45 d8	 mov	 eax, DWORD PTR tv8242[ebp]
  0184a	f7 e1		 mul	 ecx
  0184c	8b c8		 mov	 ecx, eax
  0184e	89 55 c0	 mov	 DWORD PTR tv8254[ebp], edx
  01851	8b 45 d8	 mov	 eax, DWORD PTR tv8242[ebp]
  01854	ba 7a 14 ae 47	 mov	 edx, 1202590842		; 47ae147aH
  01859	f7 e2		 mul	 edx
  0185b	03 ce		 add	 ecx, esi
  0185d	8b 75 dc	 mov	 esi, DWORD PTR tv8241[ebp]
  01860	89 45 cc	 mov	 DWORD PTR tv7938[ebp], eax
  01863	89 55 d0	 mov	 DWORD PTR tv7939[ebp], edx
  01866	8b 55 c0	 mov	 edx, DWORD PTR tv8254[ebp]
  01869	83 d2 00	 adc	 edx, 0
  0186c	03 f9		 add	 edi, ecx
  0186e	8b 4d c4	 mov	 ecx, DWORD PTR tv7929[ebp]
  01871	83 d1 00	 adc	 ecx, 0
  01874	89 7d bc	 mov	 DWORD PTR tv5981[ebp], edi
  01877	33 c0		 xor	 eax, eax

; 2442 : 						ptmCur->tm_min	= (lTime % 100);

  01879	bf 7a 14 ae 47	 mov	 edi, 1202590842		; 47ae147aH
  0187e	03 d1		 add	 edx, ecx
  01880	8b 4d cc	 mov	 ecx, DWORD PTR tv7938[ebp]
  01883	13 c0		 adc	 eax, eax
  01885	03 ca		 add	 ecx, edx
  01887	8b 55 d0	 mov	 edx, DWORD PTR tv7939[ebp]
  0188a	13 d0		 adc	 edx, eax
  0188c	8b 45 d8	 mov	 eax, DWORD PTR tv8242[ebp]
  0188f	2b f1		 sub	 esi, ecx
  01891	1b c2		 sbb	 eax, edx
  01893	0f ac c6 01	 shrd	 esi, eax, 1
  01897	d1 e8		 shr	 eax, 1
  01899	03 f1		 add	 esi, ecx
  0189b	b9 15 ae 47 e1	 mov	 ecx, -515396075		; e147ae15H
  018a0	13 c2		 adc	 eax, edx
  018a2	ba 15 ae 47 e1	 mov	 edx, -515396075		; e147ae15H
  018a7	0f ac c6 06	 shrd	 esi, eax, 6
  018ab	8b 45 20	 mov	 eax, DWORD PTR _ptmCur$1$[ebp]
  018ae	89 70 08	 mov	 DWORD PTR [eax+8], esi
  018b1	8b 45 08	 mov	 eax, DWORD PTR _lTime$[ebp]
  018b4	f7 e2		 mul	 edx
  018b6	89 45 bc	 mov	 DWORD PTR tv6111[ebp], eax
  018b9	8b f2		 mov	 esi, edx
  018bb	8b 45 08	 mov	 eax, DWORD PTR _lTime$[ebp]
  018be	f7 e7		 mul	 edi
  018c0	8b f8		 mov	 edi, eax
  018c2	89 55 c4	 mov	 DWORD PTR tv7953[ebp], edx
  018c5	8b 45 0c	 mov	 eax, DWORD PTR _lTime$[ebp+4]
  018c8	f7 e1		 mul	 ecx
  018ca	8b c8		 mov	 ecx, eax
  018cc	89 55 c0	 mov	 DWORD PTR tv8220[ebp], edx
  018cf	8b 45 0c	 mov	 eax, DWORD PTR _lTime$[ebp+4]
  018d2	ba 7a 14 ae 47	 mov	 edx, 1202590842		; 47ae147aH
  018d7	f7 e2		 mul	 edx
  018d9	89 45 cc	 mov	 DWORD PTR tv7962[ebp], eax
  018dc	03 ce		 add	 ecx, esi
  018de	89 55 d0	 mov	 DWORD PTR tv7963[ebp], edx
  018e1	8b 55 c0	 mov	 edx, DWORD PTR tv8220[ebp]
  018e4	8b 75 cc	 mov	 esi, DWORD PTR tv7962[ebp]
  018e7	83 d2 00	 adc	 edx, 0
  018ea	03 f9		 add	 edi, ecx
  018ec	8b 4d c4	 mov	 ecx, DWORD PTR tv7953[ebp]
  018ef	89 7d bc	 mov	 DWORD PTR tv6120[ebp], edi
  018f2	83 d1 00	 adc	 ecx, 0
  018f5	33 c0		 xor	 eax, eax
  018f7	03 d1		 add	 edx, ecx
  018f9	8b 4d 08	 mov	 ecx, DWORD PTR _lTime$[ebp]
  018fc	13 c0		 adc	 eax, eax
  018fe	03 f2		 add	 esi, edx
  01900	8b 55 d0	 mov	 edx, DWORD PTR tv7963[ebp]
  01903	13 d0		 adc	 edx, eax
  01905	8b 45 0c	 mov	 eax, DWORD PTR _lTime$[ebp+4]
  01908	2b ce		 sub	 ecx, esi
  0190a	1b c2		 sbb	 eax, edx
  0190c	0f ac c1 01	 shrd	 ecx, eax, 1
  01910	d1 e8		 shr	 eax, 1
  01912	03 ce		 add	 ecx, esi
  01914	8b 75 08	 mov	 esi, DWORD PTR _lTime$[ebp]
  01917	13 c2		 adc	 eax, edx
  01919	0f ac c1 06	 shrd	 ecx, eax, 6
  0191d	6b c1 64	 imul	 eax, ecx, 100
  01920	8b ce		 mov	 ecx, esi
  01922	2b c8		 sub	 ecx, eax
  01924	8b 45 20	 mov	 eax, DWORD PTR _ptmCur$1$[ebp]
  01927	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 2443 : 						ptmCur->tm_sec	= 0;

  0192a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN191@GetTimeFro:

; 2644 : 		}
; 2645 : 	}
; 2646 : 
; 2647 : 	// 20080925 JS.Kim	   Scale . Packet       
; 2648 : //	timeResult = mktime(&tmResult);
; 2649 : 	switch(pifRQ->eScaleUnit)

  01930	8b 7d 18	 mov	 edi, DWORD PTR _tmResult$[ebp]
$LN193@GetTimeFro:
  01933	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  01936	0f 11 07	 movups	 XMMWORD PTR [edi], xmm0
  01939	0f 10 40 10	 movups	 xmm0, XMMWORD PTR [eax+16]
  0193d	0f 11 47 10	 movups	 XMMWORD PTR [edi+16], xmm0
  01941	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  01944	89 47 20	 mov	 DWORD PTR [edi+32], eax
  01947	e9 1b 02 00 00	 jmp	 $LN37@GetTimeFro
$LN35@GetTimeFro:

; 2444 : 						tmResult = *ptmCur;	
; 2445 : 					}
; 2446 : 				}
; 2447 : 				break;
; 2448 : 			case CScaleBaseData::HORZ_TICK:			//  
; 2449 : 			case CScaleBaseData::HORZ_TIME_SECOND:	// 
; 2450 : // vntsorl_20110407:[A00000378] Global  //    
; 2451 : 				// Data DDHHMMSS  ..
; 2452 : 				if (lTime > 1000000)

  0194c	85 c9		 test	 ecx, ecx
  0194e	75 0c		 jne	 SHORT $LN169@GetTimeFro
  01950	81 fe 40 42 0f
	00		 cmp	 esi, 1000000		; 000f4240H
  01956	0f 86 0b 02 00
	00		 jbe	 $LN37@GetTimeFro
$LN169@GetTimeFro:

; 2453 : 				{
; 2454 : 						ptmCur->tm_mday  = (lTime / 1000000);

  0195c	8b c6		 mov	 eax, esi
  0195e	ba db 34 b6 d7	 mov	 edx, -675924773		; d7b634dbH
  01963	f7 e2		 mul	 edx
  01965	bf 82 de 1b 43	 mov	 edi, 1125899906		; 431bde82H
  0196a	89 45 bc	 mov	 DWORD PTR tv6253[ebp], eax
  0196d	8b f2		 mov	 esi, edx
  0196f	8b 45 08	 mov	 eax, DWORD PTR _lTime$[ebp]
  01972	f7 e7		 mul	 edi

; 2455 : 						ptmCur->tm_hour = (lTime / 10000) % 100;

  01974	6a 00		 push	 0
  01976	8b f8		 mov	 edi, eax
  01978	89 55 c4	 mov	 DWORD PTR tv7975[ebp], edx
  0197b	8b c1		 mov	 eax, ecx
  0197d	b9 db 34 b6 d7	 mov	 ecx, -675924773		; d7b634dbH
  01982	f7 e1		 mul	 ecx
  01984	6a 64		 push	 100			; 00000064H
  01986	8b c8		 mov	 ecx, eax
  01988	89 55 c0	 mov	 DWORD PTR tv8183[ebp], edx
  0198b	8b 45 0c	 mov	 eax, DWORD PTR _lTime$[ebp+4]
  0198e	ba 82 de 1b 43	 mov	 edx, 1125899906		; 431bde82H
  01993	f7 e2		 mul	 edx
  01995	03 ce		 add	 ecx, esi
  01997	89 55 d0	 mov	 DWORD PTR tv8179[ebp], edx
  0199a	8b 55 c0	 mov	 edx, DWORD PTR tv8183[ebp]
  0199d	83 d2 00	 adc	 edx, 0
  019a0	89 45 cc	 mov	 DWORD PTR tv8178[ebp], eax
  019a3	8b f0		 mov	 esi, eax
  019a5	03 f9		 add	 edi, ecx
  019a7	8b 4d c4	 mov	 ecx, DWORD PTR tv7975[ebp]
  019aa	83 d1 00	 adc	 ecx, 0
  019ad	89 7d bc	 mov	 DWORD PTR tv6262[ebp], edi
  019b0	33 c0		 xor	 eax, eax
  019b2	bf d6 c5 6d 34	 mov	 edi, 879609302		; 346dc5d6H
  019b7	03 d1		 add	 edx, ecx
  019b9	8b 4d d0	 mov	 ecx, DWORD PTR tv8179[ebp]
  019bc	13 c0		 adc	 eax, eax
  019be	03 f2		 add	 esi, edx
  019c0	ba 4b 59 86 38	 mov	 edx, 948328779		; 3886594bH
  019c5	13 c8		 adc	 ecx, eax
  019c7	8b 45 20	 mov	 eax, DWORD PTR _ptmCur$1$[ebp]
  019ca	0f ac ce 12	 shrd	 esi, ecx, 18
  019ce	b9 4b 59 86 38	 mov	 ecx, 948328779		; 3886594bH
  019d3	89 70 0c	 mov	 DWORD PTR [eax+12], esi
  019d6	8b 45 08	 mov	 eax, DWORD PTR _lTime$[ebp]
  019d9	f7 e2		 mul	 edx
  019db	89 45 bc	 mov	 DWORD PTR tv6369[ebp], eax
  019de	8b f2		 mov	 esi, edx
  019e0	8b 45 08	 mov	 eax, DWORD PTR _lTime$[ebp]
  019e3	f7 e7		 mul	 edi
  019e5	8b f8		 mov	 edi, eax
  019e7	89 55 c4	 mov	 DWORD PTR tv7995[ebp], edx
  019ea	8b 45 0c	 mov	 eax, DWORD PTR _lTime$[ebp+4]
  019ed	f7 e1		 mul	 ecx
  019ef	8b c8		 mov	 ecx, eax
  019f1	89 55 c0	 mov	 DWORD PTR tv8159[ebp], edx
  019f4	8b 45 0c	 mov	 eax, DWORD PTR _lTime$[ebp+4]
  019f7	ba d6 c5 6d 34	 mov	 edx, 879609302		; 346dc5d6H
  019fc	f7 e2		 mul	 edx
  019fe	03 ce		 add	 ecx, esi
  01a00	89 55 d0	 mov	 DWORD PTR tv8153[ebp], edx
  01a03	8b 55 c0	 mov	 edx, DWORD PTR tv8159[ebp]
  01a06	8b 75 d0	 mov	 esi, DWORD PTR tv8153[ebp]
  01a09	83 d2 00	 adc	 edx, 0
  01a0c	03 f9		 add	 edi, ecx
  01a0e	89 45 cc	 mov	 DWORD PTR tv8152[ebp], eax
  01a11	8b 4d c4	 mov	 ecx, DWORD PTR tv7995[ebp]
  01a14	83 d1 00	 adc	 ecx, 0
  01a17	89 7d bc	 mov	 DWORD PTR tv6378[ebp], edi
  01a1a	8b 7d cc	 mov	 edi, DWORD PTR tv8152[ebp]
  01a1d	33 c0		 xor	 eax, eax
  01a1f	03 d1		 add	 edx, ecx
  01a21	13 c0		 adc	 eax, eax
  01a23	03 fa		 add	 edi, edx
  01a25	13 f0		 adc	 esi, eax
  01a27	0f ac f7 0b	 shrd	 edi, esi, 11
  01a2b	c1 ee 0b	 shr	 esi, 11			; 0000000bH
  01a2e	56		 push	 esi
  01a2f	57		 push	 edi
  01a30	e8 00 00 00 00	 call	 __aullrem
  01a35	8b 4d 20	 mov	 ecx, DWORD PTR _ptmCur$1$[ebp]
  01a38	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 2456 : 						ptmCur->tm_min = (lTime % 10000) / 100;

  01a3b	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  01a40	8b c6		 mov	 eax, esi
  01a42	f7 e1		 mul	 ecx
  01a44	ba 10 27 00 00	 mov	 edx, 10000		; 00002710H
  01a49	8b c8		 mov	 ecx, eax
  01a4b	8b c7		 mov	 eax, edi
  01a4d	f7 e2		 mul	 edx
  01a4f	8b 7d 08	 mov	 edi, DWORD PTR _lTime$[ebp]
  01a52	03 ca		 add	 ecx, edx
  01a54	2b f8		 sub	 edi, eax
  01a56	8b 45 0c	 mov	 eax, DWORD PTR _lTime$[ebp+4]
  01a59	1b c1		 sbb	 eax, ecx
  01a5b	89 7d dc	 mov	 DWORD PTR tv8117[ebp], edi
  01a5e	89 45 d8	 mov	 DWORD PTR tv8118[ebp], eax
  01a61	b9 15 ae 47 e1	 mov	 ecx, -515396075		; e147ae15H
  01a66	8b c7		 mov	 eax, edi
  01a68	f7 e1		 mul	 ecx
  01a6a	89 45 bc	 mov	 DWORD PTR tv6513[ebp], eax
  01a6d	8b f2		 mov	 esi, edx
  01a6f	8b c7		 mov	 eax, edi
  01a71	ba 7a 14 ae 47	 mov	 edx, 1202590842		; 47ae147aH
  01a76	f7 e2		 mul	 edx
  01a78	8b f8		 mov	 edi, eax
  01a7a	89 55 c4	 mov	 DWORD PTR tv6927[ebp], edx
  01a7d	8b 45 d8	 mov	 eax, DWORD PTR tv8118[ebp]
  01a80	f7 e1		 mul	 ecx
  01a82	8b c8		 mov	 ecx, eax
  01a84	89 55 c0	 mov	 DWORD PTR tv8130[ebp], edx
  01a87	8b 45 d8	 mov	 eax, DWORD PTR tv8118[ebp]
  01a8a	ba 7a 14 ae 47	 mov	 edx, 1202590842		; 47ae147aH
  01a8f	f7 e2		 mul	 edx
  01a91	03 ce		 add	 ecx, esi
  01a93	8b 75 dc	 mov	 esi, DWORD PTR tv8117[ebp]
  01a96	89 55 d0	 mov	 DWORD PTR tv6937[ebp], edx
  01a99	8b 55 c0	 mov	 edx, DWORD PTR tv8130[ebp]
  01a9c	83 d2 00	 adc	 edx, 0
  01a9f	89 45 cc	 mov	 DWORD PTR tv6936[ebp], eax
  01aa2	03 f9		 add	 edi, ecx
  01aa4	8b 4d c4	 mov	 ecx, DWORD PTR tv6927[ebp]
  01aa7	89 7d bc	 mov	 DWORD PTR tv6522[ebp], edi

; 2457 : 						ptmCur->tm_sec	= (lTime % 100);

  01aaa	bf 7a 14 ae 47	 mov	 edi, 1202590842		; 47ae147aH
  01aaf	83 d1 00	 adc	 ecx, 0
  01ab2	33 c0		 xor	 eax, eax
  01ab4	03 d1		 add	 edx, ecx
  01ab6	8b 4d cc	 mov	 ecx, DWORD PTR tv6936[ebp]
  01ab9	13 c0		 adc	 eax, eax
  01abb	03 ca		 add	 ecx, edx
  01abd	8b 55 d0	 mov	 edx, DWORD PTR tv6937[ebp]
  01ac0	13 d0		 adc	 edx, eax
  01ac2	8b 45 d8	 mov	 eax, DWORD PTR tv8118[ebp]
  01ac5	2b f1		 sub	 esi, ecx
  01ac7	1b c2		 sbb	 eax, edx
  01ac9	0f ac c6 01	 shrd	 esi, eax, 1
  01acd	d1 e8		 shr	 eax, 1
  01acf	03 f1		 add	 esi, ecx
  01ad1	b9 15 ae 47 e1	 mov	 ecx, -515396075		; e147ae15H
  01ad6	13 c2		 adc	 eax, edx
  01ad8	ba 15 ae 47 e1	 mov	 edx, -515396075		; e147ae15H
  01add	0f ac c6 06	 shrd	 esi, eax, 6
  01ae1	8b 45 20	 mov	 eax, DWORD PTR _ptmCur$1$[ebp]
  01ae4	89 70 04	 mov	 DWORD PTR [eax+4], esi
  01ae7	8b 45 08	 mov	 eax, DWORD PTR _lTime$[ebp]
  01aea	f7 e2		 mul	 edx
  01aec	89 45 bc	 mov	 DWORD PTR tv6652[ebp], eax
  01aef	8b f2		 mov	 esi, edx
  01af1	8b 45 08	 mov	 eax, DWORD PTR _lTime$[ebp]
  01af4	f7 e7		 mul	 edi
  01af6	8b f8		 mov	 edi, eax
  01af8	89 55 c4	 mov	 DWORD PTR tv6983[ebp], edx
  01afb	8b 45 0c	 mov	 eax, DWORD PTR _lTime$[ebp+4]
  01afe	f7 e1		 mul	 ecx
  01b00	89 55 c0	 mov	 DWORD PTR tv8096[ebp], edx
  01b03	8b c8		 mov	 ecx, eax
  01b05	8b 45 0c	 mov	 eax, DWORD PTR _lTime$[ebp+4]
  01b08	ba 7a 14 ae 47	 mov	 edx, 1202590842		; 47ae147aH
  01b0d	f7 e2		 mul	 edx
  01b0f	03 ce		 add	 ecx, esi
  01b11	89 55 d0	 mov	 DWORD PTR tv7003[ebp], edx
  01b14	8b 55 c0	 mov	 edx, DWORD PTR tv8096[ebp]
  01b17	83 d2 00	 adc	 edx, 0
  01b1a	89 45 cc	 mov	 DWORD PTR tv7001[ebp], eax
  01b1d	03 f9		 add	 edi, ecx
  01b1f	8b 4d c4	 mov	 ecx, DWORD PTR tv6983[ebp]
  01b22	8b 75 cc	 mov	 esi, DWORD PTR tv7001[ebp]
  01b25	83 d1 00	 adc	 ecx, 0
  01b28	33 c0		 xor	 eax, eax
  01b2a	89 7d bc	 mov	 DWORD PTR tv6661[ebp], edi
  01b2d	03 d1		 add	 edx, ecx
  01b2f	8b 4d 08	 mov	 ecx, DWORD PTR _lTime$[ebp]
  01b32	13 c0		 adc	 eax, eax
  01b34	03 f2		 add	 esi, edx
  01b36	8b 55 d0	 mov	 edx, DWORD PTR tv7003[ebp]
  01b39	13 d0		 adc	 edx, eax
  01b3b	8b 45 0c	 mov	 eax, DWORD PTR _lTime$[ebp+4]
  01b3e	2b ce		 sub	 ecx, esi
  01b40	1b c2		 sbb	 eax, edx
  01b42	0f ac c1 01	 shrd	 ecx, eax, 1
  01b46	d1 e8		 shr	 eax, 1
  01b48	03 ce		 add	 ecx, esi
  01b4a	8b 75 08	 mov	 esi, DWORD PTR _lTime$[ebp]
  01b4d	13 c2		 adc	 eax, edx
  01b4f	0f ac c1 06	 shrd	 ecx, eax, 6
  01b53	6b c1 64	 imul	 eax, ecx, 100
  01b56	8b ce		 mov	 ecx, esi
  01b58	2b c8		 sub	 ecx, eax
  01b5a	8b 45 20	 mov	 eax, DWORD PTR _ptmCur$1$[ebp]
  01b5d	89 08		 mov	 DWORD PTR [eax], ecx
  01b5f	e9 cc fd ff ff	 jmp	 $LN191@GetTimeFro
$LN178@GetTimeFro:

; 2644 : 		}
; 2645 : 	}
; 2646 : 
; 2647 : 	// 20080925 JS.Kim	   Scale . Packet       
; 2648 : //	timeResult = mktime(&tmResult);
; 2649 : 	switch(pifRQ->eScaleUnit)

  01b64	8b 7d 18	 mov	 edi, DWORD PTR _tmResult$[ebp]
$LN37@GetTimeFro:
  01b67	8b 45 14	 mov	 eax, DWORD PTR _pifRQ$[ebp]
  01b6a	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  01b6d	48		 dec	 eax
  01b6e	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  01b71	0f 87 0b 02 00
	00		 ja	 $LN174@GetTimeFro
  01b77	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN170@GetTimeFro[eax]
  01b7e	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN171@GetTimeFro[eax*4]
$LN77@GetTimeFro:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\time.h

; 515  :             return _mktime64(_Tm);

  01b85	57		 push	 edi
  01b86	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___mktime64
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 2654 : 											timeResult = mktime(&tmResult);

  01b8c	89 45 b4	 mov	 DWORD PTR _timeResult$[ebp], eax
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\time.h

; 499  :             return _localtime64(_Time);

  01b8f	8d 45 b4	 lea	 eax, DWORD PTR _timeResult$[ebp]
  01b92	50		 push	 eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 2654 : 											timeResult = mktime(&tmResult);

  01b93	89 55 b8	 mov	 DWORD PTR _timeResult$[ebp+4], edx
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\time.h

; 499  :             return _localtime64(_Time);

  01b96	ff 55 d4	 call	 DWORD PTR tv6988[ebp]
  01b99	83 c4 08	 add	 esp, 8
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 2669 : 											if( ptmCur) if(ptmCur->tm_wday == 0) timeResult += (3600 * 24);

  01b9c	85 c0		 test	 eax, eax
  01b9e	74 1c		 je	 SHORT $LN173@GetTimeFro
  01ba0	83 78 18 00	 cmp	 DWORD PTR [eax+24], 0
  01ba4	75 16		 jne	 SHORT $LN173@GetTimeFro
  01ba6	8b 45 b4	 mov	 eax, DWORD PTR _timeResult$[ebp]
  01ba9	8b 75 b8	 mov	 esi, DWORD PTR _timeResult$[ebp+4]
  01bac	05 80 51 01 00	 add	 eax, 86400		; 00015180H
  01bb1	89 45 b4	 mov	 DWORD PTR _timeResult$[ebp], eax
  01bb4	83 d6 00	 adc	 esi, 0
  01bb7	89 75 b8	 mov	 DWORD PTR _timeResult$[ebp+4], esi
  01bba	eb 06		 jmp	 SHORT $LN192@GetTimeFro
$LN173@GetTimeFro:
  01bbc	8b 75 b8	 mov	 esi, DWORD PTR _timeResult$[ebp+4]
  01bbf	8b 45 b4	 mov	 eax, DWORD PTR _timeResult$[ebp]
$LN192@GetTimeFro:

; 2670 : 
; 2671 : 											// 20080925 JS.Kim	   Scale .     Packet       
; 2672 : 											if( m_bTimeScale) timeResult = m_TimeDiffManager.GetRQScreenDateTime( p_szRQ, timeResult);

  01bc2	8b 7d f0	 mov	 edi, DWORD PTR _this$1$[ebp]
  01bc5	89 45 20	 mov	 DWORD PTR $T4[ebp], eax
  01bc8	80 bf 14 06 00
	00 00		 cmp	 BYTE PTR [edi+1556], 0
  01bcf	0f 84 b5 01 00
	00		 je	 $LN182@GetTimeFro
  01bd5	56		 push	 esi
  01bd6	50		 push	 eax
  01bd7	51		 push	 ecx
  01bd8	8b cc		 mov	 ecx, esp
  01bda	ff 75 1c	 push	 DWORD PTR _p_szRQ$[ebp]
  01bdd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  01be3	8d 8f ec 05 00
	00		 lea	 ecx, DWORD PTR [edi+1516]
  01be9	e8 00 00 00 00	 call	 ?GetRQScreenDateTime@CXScaleTimeDiffManager@@QAE_JV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@_J@Z ; CXScaleTimeDiffManager::GetRQScreenDateTime
  01bee	8b f8		 mov	 edi, eax
  01bf0	8b f2		 mov	 esi, edx
  01bf2	89 7d b4	 mov	 DWORD PTR _timeResult$[ebp], edi
  01bf5	89 75 b8	 mov	 DWORD PTR _timeResult$[ebp+4], esi

; 2673 : 											break;

  01bf8	e9 29 01 00 00	 jmp	 $LN112@GetTimeFro
$LN81@GetTimeFro:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\time.h

; 515  :             return _mktime64(_Tm);

  01bfd	57		 push	 edi
  01bfe	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___mktime64
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 2677 : 											timeResult = mktime(&tmResult);

  01c04	89 45 20	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\time.h

; 515  :             return _mktime64(_Tm);

  01c07	83 c4 04	 add	 esp, 4
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 2680 : 											if( tmResult.tm_wday < 1) tmResult.tm_wday += 7;

  01c0a	8b 47 18	 mov	 eax, DWORD PTR [edi+24]
  01c0d	89 55 18	 mov	 DWORD PTR $T3[ebp], edx
  01c10	83 f8 01	 cmp	 eax, 1
  01c13	7d 06		 jge	 SHORT $LN82@GetTimeFro
  01c15	83 c0 07	 add	 eax, 7
  01c18	89 47 18	 mov	 DWORD PTR [edi+24], eax
$LN82@GetTimeFro:

; 2681 : 											timeResult -= ((3600 * 24) * (tmResult.tm_wday - 1));

  01c1b	69 c0 80 51 01
	00		 imul	 eax, eax, 86400
  01c21	2d 80 51 01 00	 sub	 eax, 86400		; 00015180H
  01c26	99		 cdq
  01c27	8b c8		 mov	 ecx, eax
  01c29	8b f2		 mov	 esi, edx

; 2682 : 
; 2683 : 											// ? do you believe the hour, sec is not 0 ?
; 2684 : 											//	why not minute?
; 2685 : 											timeResult -= (3600 * tmResult.tm_hour);

  01c2b	69 47 08 10 0e
	00 00		 imul	 eax, DWORD PTR [edi+8], 3600
  01c32	99		 cdq

; 2686 : 											timeResult -= tmResult.tm_sec;

  01c33	03 c8		 add	 ecx, eax
  01c35	8b 07		 mov	 eax, DWORD PTR [edi]
  01c37	8b 7d 20	 mov	 edi, DWORD PTR $T4[ebp]
  01c3a	13 f2		 adc	 esi, edx
  01c3c	99		 cdq
  01c3d	03 c8		 add	 ecx, eax
  01c3f	13 f2		 adc	 esi, edx
  01c41	2b f9		 sub	 edi, ecx
  01c43	8b 4d 18	 mov	 ecx, DWORD PTR $T3[ebp]
  01c46	1b ce		 sbb	 ecx, esi
  01c48	89 7d b4	 mov	 DWORD PTR _timeResult$[ebp], edi

; 2687 : 											// 20080925 JS.Kim	   Scale . 
; 2688 : 											//	         
; 2689 : 											//timeResult += 1;
; 2690 : 
; 2691 : 											// 20080925 JS.Kim	   Scale .     Packet       
; 2692 : 											if( m_bTimeScale) timeResult = m_TimeDiffManager.GetRQScreenDateTime( p_szRQ, timeResult);

  01c4b	8b 75 f0	 mov	 esi, DWORD PTR _this$1$[ebp]
  01c4e	89 4d 18	 mov	 DWORD PTR $T3[ebp], ecx
  01c51	89 4d b8	 mov	 DWORD PTR _timeResult$[ebp+4], ecx
  01c54	80 be 14 06 00
	00 00		 cmp	 BYTE PTR [esi+1556], 0
  01c5b	0f 84 c2 00 00
	00		 je	 $LN184@GetTimeFro
  01c61	51		 push	 ecx
  01c62	57		 push	 edi
  01c63	51		 push	 ecx
  01c64	8b cc		 mov	 ecx, esp
  01c66	ff 75 1c	 push	 DWORD PTR _p_szRQ$[ebp]
  01c69	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  01c6f	8d 8e ec 05 00
	00		 lea	 ecx, DWORD PTR [esi+1516]
  01c75	e8 00 00 00 00	 call	 ?GetRQScreenDateTime@CXScaleTimeDiffManager@@QAE_JV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@_J@Z ; CXScaleTimeDiffManager::GetRQScreenDateTime
  01c7a	8b f8		 mov	 edi, eax
  01c7c	8b f2		 mov	 esi, edx
  01c7e	89 7d b4	 mov	 DWORD PTR _timeResult$[ebp], edi
  01c81	89 75 b8	 mov	 DWORD PTR _timeResult$[ebp+4], esi

; 2693 : 											break;

  01c84	e9 9d 00 00 00	 jmp	 $LN112@GetTimeFro
$LN84@GetTimeFro:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\time.h

; 515  :             return _mktime64(_Tm);

  01c89	57		 push	 edi
  01c8a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___mktime64
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 2696 : 											timeResult = mktime(&tmResult);

  01c90	89 45 20	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\time.h

; 515  :             return _mktime64(_Tm);

  01c93	83 c4 04	 add	 esp, 4
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 2699 : 											timeResult -= (3600 * tmResult.tm_hour);

  01c96	69 47 08 10 0e
	00 00		 imul	 eax, DWORD PTR [edi+8], 3600
  01c9d	89 55 18	 mov	 DWORD PTR $T3[ebp], edx
  01ca0	99		 cdq
  01ca1	8b c8		 mov	 ecx, eax
  01ca3	8b f2		 mov	 esi, edx

; 2700 : 											timeResult -= tmResult.tm_sec;

  01ca5	8b 07		 mov	 eax, DWORD PTR [edi]
  01ca7	8b 7d 20	 mov	 edi, DWORD PTR $T4[ebp]
  01caa	99		 cdq
  01cab	03 c8		 add	 ecx, eax
  01cad	13 f2		 adc	 esi, edx
  01caf	2b f9		 sub	 edi, ecx
  01cb1	8b 4d 18	 mov	 ecx, DWORD PTR $T3[ebp]
  01cb4	1b ce		 sbb	 ecx, esi
  01cb6	89 7d b4	 mov	 DWORD PTR _timeResult$[ebp], edi

; 2701 : 
; 2702 : 											// 20080925 JS.Kim	   Scale . 
; 2703 : 											//	         
; 2704 : 											//timeResult += 1;
; 2705 : 
; 2706 : 											// 20080925 JS.Kim	   Scale .     Packet       
; 2707 : 											if( m_bTimeScale) timeResult = m_TimeDiffManager.GetRQScreenDateTime( p_szRQ, timeResult);

  01cb9	8b 75 f0	 mov	 esi, DWORD PTR _this$1$[ebp]
  01cbc	89 4d 18	 mov	 DWORD PTR $T3[ebp], ecx
  01cbf	89 4d b8	 mov	 DWORD PTR _timeResult$[ebp+4], ecx
  01cc2	80 be 14 06 00
	00 00		 cmp	 BYTE PTR [esi+1556], 0
  01cc9	74 58		 je	 SHORT $LN184@GetTimeFro
  01ccb	51		 push	 ecx
  01ccc	57		 push	 edi
  01ccd	51		 push	 ecx
  01cce	8b cc		 mov	 ecx, esp
  01cd0	ff 75 1c	 push	 DWORD PTR _p_szRQ$[ebp]
  01cd3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  01cd9	8d 8e ec 05 00
	00		 lea	 ecx, DWORD PTR [esi+1516]
  01cdf	e8 00 00 00 00	 call	 ?GetRQScreenDateTime@CXScaleTimeDiffManager@@QAE_JV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@_J@Z ; CXScaleTimeDiffManager::GetRQScreenDateTime
  01ce4	8b f8		 mov	 edi, eax
  01ce6	8b f2		 mov	 esi, edx
  01ce8	89 7d b4	 mov	 DWORD PTR _timeResult$[ebp], edi
  01ceb	89 75 b8	 mov	 DWORD PTR _timeResult$[ebp+4], esi

; 2708 : 											break;

  01cee	eb 36		 jmp	 SHORT $LN112@GetTimeFro
$LN86@GetTimeFro:

; 2709 : 
; 2710 : 		case CScaleBaseData::HORZ_TIME_ONE:	
; 2711 : 		case CScaleBaseData::HORZ_TIME_TWO:	// 20080925 JS.Kim	   Scale . Packet       
; 2712 : 											timeResult = m_TimeDiffManager.GetRQScreenTime( p_szRQ, &tmResult);

  01cf0	57		 push	 edi
  01cf1	51		 push	 ecx
  01cf2	8b cc		 mov	 ecx, esp
  01cf4	ff 75 1c	 push	 DWORD PTR _p_szRQ$[ebp]
  01cf7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  01cfd	8b 4d f0	 mov	 ecx, DWORD PTR _this$1$[ebp]
  01d00	8d 89 ec 05 00
	00		 lea	 ecx, DWORD PTR [ecx+1516]
  01d06	e8 00 00 00 00	 call	 ?GetRQScreenTime@CXScaleTimeDiffManager@@QAE_JV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAUtm@@@Z ; CXScaleTimeDiffManager::GetRQScreenTime
  01d0b	89 45 20	 mov	 DWORD PTR $T4[ebp], eax
  01d0e	8b ca		 mov	 ecx, edx

; 2713 : 											timeResult -= tmResult.tm_sec;

  01d10	8b 07		 mov	 eax, DWORD PTR [edi]
  01d12	8b 7d 20	 mov	 edi, DWORD PTR $T4[ebp]
  01d15	99		 cdq
  01d16	2b f8		 sub	 edi, eax
  01d18	89 7d b4	 mov	 DWORD PTR _timeResult$[ebp], edi
  01d1b	1b ca		 sbb	 ecx, edx
  01d1d	89 4d 18	 mov	 DWORD PTR $T3[ebp], ecx
  01d20	89 4d b8	 mov	 DWORD PTR _timeResult$[ebp+4], ecx
$LN184@GetTimeFro:

; 2723 : 			}
; 2724 : 			else
; 2725 : 			{
; 2726 : 				// it was returned directly!
; 2727 : 			}
; 2728 : 			// 2011.01.24 by SYS <<
; 2729 : 			break;
; 2730 : 	}
; 2731 : 
; 2732 : 	return timeResult;

  01d23	8b 75 18	 mov	 esi, DWORD PTR $T3[ebp]
$LN112@GetTimeFro:
  01d26	8d 4d 10	 lea	 ecx, DWORD PTR _strType$[ebp]
  01d29	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  01d2f	8b c7		 mov	 eax, edi
  01d31	8b d6		 mov	 edx, esi

; 2733 : }

  01d33	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  01d36	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  01d3d	59		 pop	 ecx
  01d3e	5f		 pop	 edi
  01d3f	5e		 pop	 esi
  01d40	5b		 pop	 ebx
  01d41	8b e5		 mov	 esp, ebp
  01d43	5d		 pop	 ebp
  01d44	c2 1c 00	 ret	 28			; 0000001cH
$LN88@GetTimeFro:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h

; 2486 : 		return(str1.Compare(psz2) == 0);

  01d47	68 00 00 00 00	 push	 OFFSET ??_C@_0P@IMPIBBAB@YYYYMMDDHHMMSS@
  01d4c	8d 4d 10	 lea	 ecx, DWORD PTR _strType$[ebp]
  01d4f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Compare@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEHPBD@Z
  01d55	85 c0		 test	 eax, eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 2719 : 			if (strType == "YYYYMMDDHHMMSS" || lTime > 10000000000000)

  01d57	74 13		 je	 SHORT $LN172@GetTimeFro
  01d59	81 7d 0c 18 09
	00 00		 cmp	 DWORD PTR _lTime$[ebp+4], 2328 ; 00000918H
  01d60	72 20		 jb	 SHORT $LN174@GetTimeFro
  01d62	77 08		 ja	 SHORT $LN172@GetTimeFro
  01d64	81 fe 00 a0 72
	4e		 cmp	 esi, 1316134912		; 4e72a000H
  01d6a	76 16		 jbe	 SHORT $LN174@GetTimeFro
$LN172@GetTimeFro:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\time.h

; 515  :             return _mktime64(_Tm);

  01d6c	57		 push	 edi
  01d6d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___mktime64
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 2722 : 				timeResult = mktime(&tmResult);

  01d73	8b f8		 mov	 edi, eax
  01d75	8b f2		 mov	 esi, edx
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\time.h

; 515  :             return _mktime64(_Tm);

  01d77	83 c4 04	 add	 esp, 4
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 2722 : 				timeResult = mktime(&tmResult);

  01d7a	89 7d b4	 mov	 DWORD PTR _timeResult$[ebp], edi
  01d7d	89 75 b8	 mov	 DWORD PTR _timeResult$[ebp+4], esi
  01d80	eb a4		 jmp	 SHORT $LN112@GetTimeFro
$LN174@GetTimeFro:

; 2719 : 			if (strType == "YYYYMMDDHHMMSS" || lTime > 10000000000000)

  01d82	8b 75 b8	 mov	 esi, DWORD PTR _timeResult$[ebp+4]
  01d85	8b 7d b4	 mov	 edi, DWORD PTR _timeResult$[ebp]
  01d88	eb 9c		 jmp	 SHORT $LN112@GetTimeFro
$LN182@GetTimeFro:

; 2670 : 
; 2671 : 											// 20080925 JS.Kim	   Scale .     Packet       
; 2672 : 											if( m_bTimeScale) timeResult = m_TimeDiffManager.GetRQScreenDateTime( p_szRQ, timeResult);

  01d8a	8b 7d 20	 mov	 edi, DWORD PTR $T4[ebp]
  01d8d	eb 97		 jmp	 SHORT $LN112@GetTimeFro
  01d8f	90		 npad	 1
$LN162@GetTimeFro:

; 2733 : }

  01d90	00 00 00 00	 DD	 $LN13@GetTimeFro
  01d94	00 00 00 00	 DD	 $LN15@GetTimeFro
  01d98	00 00 00 00	 DD	 $LN16@GetTimeFro
  01d9c	00 00 00 00	 DD	 $LN178@GetTimeFro
$LN161@GetTimeFro:
  01da0	00		 DB	 0
  01da1	00		 DB	 0
  01da2	01		 DB	 1
  01da3	02		 DB	 2
  01da4	02		 DB	 2
  01da5	02		 DB	 2
  01da6	03		 DB	 3
  01da7	03		 DB	 3
  01da8	03		 DB	 3
  01da9	03		 DB	 3
  01daa	03		 DB	 3
  01dab	02		 DB	 2
$LN164@GetTimeFro:
  01dac	00 00 00 00	 DD	 $LN21@GetTimeFro
  01db0	00 00 00 00	 DD	 $LN25@GetTimeFro
  01db4	00 00 00 00	 DD	 $LN31@GetTimeFro
  01db8	00 00 00 00	 DD	 $LN35@GetTimeFro
  01dbc	00 00 00 00	 DD	 $LN37@GetTimeFro
$LN163@GetTimeFro:
  01dc0	00		 DB	 0
  01dc1	00		 DB	 0
  01dc2	01		 DB	 1
  01dc3	02		 DB	 2
  01dc4	03		 DB	 3
  01dc5	02		 DB	 2
  01dc6	04		 DB	 4
  01dc7	04		 DB	 4
  01dc8	04		 DB	 4
  01dc9	04		 DB	 4
  01dca	04		 DB	 4
  01dcb	03		 DB	 3
$LN171@GetTimeFro:
  01dcc	00 00 00 00	 DD	 $LN84@GetTimeFro
  01dd0	00 00 00 00	 DD	 $LN81@GetTimeFro
  01dd4	00 00 00 00	 DD	 $LN77@GetTimeFro
  01dd8	00 00 00 00	 DD	 $LN86@GetTimeFro
  01ddc	00 00 00 00	 DD	 $LN88@GetTimeFro
  01de0	00 00 00 00	 DD	 $LN174@GetTimeFro
$LN170@GetTimeFro:
  01de4	00		 DB	 0
  01de5	01		 DB	 1
  01de6	02		 DB	 2
  01de7	03		 DB	 3
  01de8	04		 DB	 4
  01de9	03		 DB	 3
  01dea	05		 DB	 5
  01deb	05		 DB	 5
  01dec	05		 DB	 5
  01ded	05		 DB	 5
  01dee	05		 DB	 5
  01def	04		 DB	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetTimeFromTimeValue@CXScaleManagerImp@@IAE_J_KV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAUtagRQ_INFO@1@AAUtm@@PBDPAVCMapTimeToLong@@@Z$0:
  00000	8d 4d 10	 lea	 ecx, DWORD PTR _strType$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
  0000d	cc		 int	 3
__ehhandler$?GetTimeFromTimeValue@CXScaleManagerImp@@IAE_J_KV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAUtagRQ_INFO@1@AAUtm@@PBDPAVCMapTimeToLong@@@Z:
  0000e	90		 npad	 1
  0000f	90		 npad	 1
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a a8	 mov	 ecx, DWORD PTR [edx-88]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?GetTimeFromTimeValue@CXScaleManagerImp@@IAE_J_KV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAUtagRQ_INFO@1@AAUtm@@PBDPAVCMapTimeToLong@@@Z
  00026	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?GetTimeFromTimeValue@CXScaleManagerImp@@IAE_J_KV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAUtagRQ_INFO@1@AAUtm@@PBDPAVCMapTimeToLong@@@Z ENDP ; CXScaleManagerImp::GetTimeFromTimeValue
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\time.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\time.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\time.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\time.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?GetNextDRI_ByScaleInterval@CXScaleManagerImp@@IAEHW4HORZSCALEDRAWERTYPE@CScaleBaseData@@HH@Z
_TEXT	SEGMENT
_timeCur$ = -8						; size = 8
_ScaleUnit$ = 8						; size = 4
_timeNext$1$ = 12					; size = 4
_nScaleInterval_Unit$ = 12				; size = 4
_nDRI_Cur$ = 16						; size = 4
?GetNextDRI_ByScaleInterval@CXScaleManagerImp@@IAEHW4HORZSCALEDRAWERTYPE@CScaleBaseData@@HH@Z PROC ; CXScaleManagerImp::GetNextDRI_ByScaleInterval, COMDAT
; _this$ = ecx

; 1841 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx

; 1842 : 	// 1. Get next DRI for tick.
; 1843 : 	if( ScaleUnit == CScaleBaseData::HORZ_TICK)

  00007	8b 5d 08	 mov	 ebx, DWORD PTR _ScaleUnit$[ebp]
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b f9		 mov	 edi, ecx
  0000e	83 fb 05	 cmp	 ebx, 5
  00011	75 26		 jne	 SHORT $LN6@GetNextDRI

; 1844 : 	{
; 1845 : 		// ? what is m_minScaleInterval_nUnit ?
; 1846 : 		int nDRI_Next = nDRI_Cur;
; 1847 : 		if( 0 < m_minScaleInterval_nUnit) nDRI_Next += int( nScaleInterval_Unit / m_minScaleInterval_nUnit);

  00013	8b b7 f4 00 00
	00		 mov	 esi, DWORD PTR [edi+244]
  00019	8b 4d 10	 mov	 ecx, DWORD PTR _nDRI_Cur$[ebp]
  0001c	85 f6		 test	 esi, esi
  0001e	7e 08		 jle	 SHORT $LN7@GetNextDRI
  00020	8b 45 0c	 mov	 eax, DWORD PTR _nScaleInterval_Unit$[ebp]
  00023	99		 cdq
  00024	f7 fe		 idiv	 esi
  00026	03 c8		 add	 ecx, eax
$LN7@GetNextDRI:

; 1848 : 		if( nDRI_Next > m_nItemCount_Total) nDRI_Next = m_nItemCount_Total;

  00028	8b 47 58	 mov	 eax, DWORD PTR [edi+88]

; 1849 : 		return nDRI_Next;

  0002b	3b c8		 cmp	 ecx, eax
  0002d	5f		 pop	 edi

; 1890 : 	}
; 1891 : 	return nDRI_Next;
; 1892 : }

  0002e	5e		 pop	 esi
  0002f	0f 4e c1	 cmovle	 eax, ecx
  00032	5b		 pop	 ebx
  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c2 0c 00	 ret	 12			; 0000000cH
$LN6@GetNextDRI:

; 1850 : 	}
; 1851 : 
; 1852 : 	// 2. Get next DRI for other time type.
; 1853 : 	// 2.1 Get current time value for Current DRI in full time line.
; 1854 : 	int nDRI_Next = nDRI_Cur + 1;

  00039	8b 45 10	 mov	 eax, DWORD PTR _nDRI_Cur$[ebp]

; 1856 : 	m_pTReturn = m_blTimefDRI.GetAt( nDRI_Cur);

  0003c	8d 8f ac 00 00
	00		 lea	 ecx, DWORD PTR [edi+172]
  00042	0f 57 c0	 xorps	 xmm0, xmm0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 215  : 	T*	GetAt( int nIndex)	{	return ( T*)GetAtUNK( nIndex);	}

  00045	50		 push	 eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 1855 : 	time_t timeCur = { 0,};

  00046	66 0f 13 45 f8	 movlpd	 QWORD PTR _timeCur$[ebp], xmm0
  0004b	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 215  : 	T*	GetAt( int nIndex)	{	return ( T*)GetAtUNK( nIndex);	}

  0004e	e8 00 00 00 00	 call	 ?GetAtUNK@CDataBlockListUNK@@QAEPAXH@Z ; CDataBlockListUNK::GetAtUNK
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 1856 : 	m_pTReturn = m_blTimefDRI.GetAt( nDRI_Cur);

  00053	89 47 5c	 mov	 DWORD PTR [edi+92], eax

; 1857 : 	if( m_pTReturn) timeCur = *m_pTReturn;

  00056	85 c0		 test	 eax, eax
  00058	74 0d		 je	 SHORT $LN37@GetNextDRI
  0005a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0005f	89 4d f8	 mov	 DWORD PTR _timeCur$[ebp], ecx
  00062	89 45 fc	 mov	 DWORD PTR _timeCur$[ebp+4], eax
  00065	eb 06		 jmp	 SHORT $LN9@GetNextDRI
$LN37@GetNextDRI:
  00067	8b 45 fc	 mov	 eax, DWORD PTR _timeCur$[ebp+4]
  0006a	8b 4d f8	 mov	 ecx, DWORD PTR _timeCur$[ebp]
$LN9@GetNextDRI:

; 1858 : 	// (2009/6/4 - Seung-Won, Bae) Check Exception.
; 1859 : 	if( timeCur < 0) return nDRI_Next;

  0006d	85 c0		 test	 eax, eax
  0006f	0f 8c a4 00 00
	00		 jl	 $LN12@GetNextDRI
  00075	7f 08		 jg	 SHORT $LN33@GetNextDRI
  00077	85 c9		 test	 ecx, ecx
  00079	0f 82 9a 00 00
	00		 jb	 $LN12@GetNextDRI
$LN33@GetNextDRI:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\time.h

; 499  :             return _localtime64(_Time);

  0007f	8d 45 f8	 lea	 eax, DWORD PTR _timeCur$[ebp]
  00082	50		 push	 eax
  00083	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___localtime64
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 1861 : 	tm* ptmCur = localtime( &timeCur);

  00089	8b d0		 mov	 edx, eax
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\time.h

; 499  :             return _localtime64(_Time);

  0008b	83 c4 04	 add	 esp, 4
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 1865 : 	if(ptmCur == NULL)

  0008e	85 d2		 test	 edx, edx
  00090	75 0e		 jne	 SHORT $LN11@GetNextDRI

; 1890 : 	}
; 1891 : 	return nDRI_Next;
; 1892 : }

  00092	5f		 pop	 edi
  00093	5e		 pop	 esi
  00094	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  00099	5b		 pop	 ebx
  0009a	8b e5		 mov	 esp, ebp
  0009c	5d		 pop	 ebp
  0009d	c2 0c 00	 ret	 12			; 0000000cH
$LN11@GetNextDRI:

; 1866 : 	{
; 1867 : 		return INT_MIN;
; 1868 : 	}
; 1869 : 	// 2011.01.06 by SYS <<
; 1870 : 
; 1871 : 
; 1872 : 	switch( ScaleUnit)

  000a0	8d 43 ff	 lea	 eax, DWORD PTR [ebx-1]
  000a3	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  000a6	77 71		 ja	 SHORT $LN12@GetNextDRI
  000a8	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN34@GetNextDRI[eax*4]
$LN13@GetNextDRI:

; 1873 : 	{
; 1874 : 		default: return nDRI_Next;
; 1875 : 
; 1876 : 		case CScaleBaseData::HORZ_MONTHLY:		ptmCur->tm_mon	+= nScaleInterval_Unit;			break;

  000af	8b 45 0c	 mov	 eax, DWORD PTR _nScaleInterval_Unit$[ebp]
  000b2	01 42 10	 add	 DWORD PTR [edx+16], eax
  000b5	eb 1e		 jmp	 SHORT $LN2@GetNextDRI
$LN14@GetNextDRI:

; 1877 : 		case CScaleBaseData::HORZ_WEEKLEY:		ptmCur->tm_mday += (nScaleInterval_Unit * 7);	break;

  000b7	8b 45 0c	 mov	 eax, DWORD PTR _nScaleInterval_Unit$[ebp]
  000ba	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*8]
  000c1	2b c8		 sub	 ecx, eax
  000c3	01 4a 0c	 add	 DWORD PTR [edx+12], ecx
  000c6	eb 0d		 jmp	 SHORT $LN2@GetNextDRI
$LN15@GetNextDRI:

; 1878 : 		case CScaleBaseData::HORZ_DAILY:		ptmCur->tm_mday += nScaleInterval_Unit;			break;

  000c8	8b 45 0c	 mov	 eax, DWORD PTR _nScaleInterval_Unit$[ebp]
  000cb	01 42 0c	 add	 DWORD PTR [edx+12], eax

; 1879 : 		case CScaleBaseData::HORZ_TIME_ONE:		ptmCur->tm_sec	+= nScaleInterval_Unit;			break;

  000ce	eb 05		 jmp	 SHORT $LN2@GetNextDRI
$LN18@GetNextDRI:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\time.h

; 515  :             return _mktime64(_Tm);

  000d0	8b 45 0c	 mov	 eax, DWORD PTR _nScaleInterval_Unit$[ebp]
  000d3	01 02		 add	 DWORD PTR [edx], eax
$LN2@GetNextDRI:
  000d5	52		 push	 edx
  000d6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___mktime64
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 1883 : 	time_t timeNext = mktime( ptmCur);

  000dc	8b d8		 mov	 ebx, eax
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\time.h

; 515  :             return _mktime64(_Tm);

  000de	83 c4 04	 add	 esp, 4
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 1883 : 	time_t timeNext = mktime( ptmCur);

  000e1	8b c2		 mov	 eax, edx
  000e3	89 45 0c	 mov	 DWORD PTR _timeNext$1$[ebp], eax

; 1884 : 	// 2.3 Search the DRI for next time in full time line.
; 1885 : 	if( timeCur != timeNext) while( m_nItemCount_Total > nDRI_Next)

  000e6	39 5d f8	 cmp	 DWORD PTR _timeCur$[ebp], ebx
  000e9	75 05		 jne	 SHORT $LN35@GetNextDRI
  000eb	39 45 fc	 cmp	 DWORD PTR _timeCur$[ebp+4], eax
  000ee	74 29		 je	 SHORT $LN12@GetNextDRI
$LN35@GetNextDRI:
  000f0	39 77 58	 cmp	 DWORD PTR [edi+88], esi
  000f3	7e 24		 jle	 SHORT $LN12@GetNextDRI
$LL4@GetNextDRI:

; 1886 : 	{
; 1887 : 		GetTimeFromDRI( nDRI_Next, &timeCur);

  000f5	8b 07		 mov	 eax, DWORD PTR [edi]
  000f7	8d 4d f8	 lea	 ecx, DWORD PTR _timeCur$[ebp]
  000fa	51		 push	 ecx
  000fb	56		 push	 esi
  000fc	8b cf		 mov	 ecx, edi
  000fe	ff 90 ec 00 00
	00		 call	 DWORD PTR [eax+236]

; 1888 : 		if( timeNext <= timeCur) break;

  00104	8b 45 0c	 mov	 eax, DWORD PTR _timeNext$1$[ebp]
  00107	3b 45 fc	 cmp	 eax, DWORD PTR _timeCur$[ebp+4]
  0010a	7c 0d		 jl	 SHORT $LN12@GetNextDRI
  0010c	7f 05		 jg	 SHORT $LN36@GetNextDRI
  0010e	3b 5d f8	 cmp	 ebx, DWORD PTR _timeCur$[ebp]
  00111	76 06		 jbe	 SHORT $LN12@GetNextDRI
$LN36@GetNextDRI:

; 1889 : 		nDRI_Next++;

  00113	46		 inc	 esi
  00114	39 77 58	 cmp	 DWORD PTR [edi+88], esi
  00117	7f dc		 jg	 SHORT $LL4@GetNextDRI
$LN12@GetNextDRI:
  00119	5f		 pop	 edi

; 1890 : 	}
; 1891 : 	return nDRI_Next;
; 1892 : }

  0011a	8b c6		 mov	 eax, esi
  0011c	5e		 pop	 esi
  0011d	5b		 pop	 ebx
  0011e	8b e5		 mov	 esp, ebp
  00120	5d		 pop	 ebp
  00121	c2 0c 00	 ret	 12			; 0000000cH
$LN34@GetNextDRI:
  00124	00 00 00 00	 DD	 $LN15@GetNextDRI
  00128	00 00 00 00	 DD	 $LN14@GetNextDRI
  0012c	00 00 00 00	 DD	 $LN13@GetNextDRI
  00130	00 00 00 00	 DD	 $LN18@GetNextDRI
  00134	00 00 00 00	 DD	 $LN12@GetNextDRI
  00138	00 00 00 00	 DD	 $LN18@GetNextDRI
  0013c	00 00 00 00	 DD	 $LN12@GetNextDRI
  00140	00 00 00 00	 DD	 $LN12@GetNextDRI
  00144	00 00 00 00	 DD	 $LN12@GetNextDRI
  00148	00 00 00 00	 DD	 $LN12@GetNextDRI
  0014c	00 00 00 00	 DD	 $LN12@GetNextDRI
  00150	00 00 00 00	 DD	 $LN18@GetNextDRI
?GetNextDRI_ByScaleInterval@CXScaleManagerImp@@IAEHW4HORZSCALEDRAWERTYPE@CScaleBaseData@@HH@Z ENDP ; CXScaleManagerImp::GetNextDRI_ByScaleInterval
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?ClearData@CXScaleManagerImp@@IAEXXZ
_TEXT	SEGMENT
_i$1$ = -4						; size = 4
?ClearData@CXScaleManagerImp@@IAEXXZ PROC		; CXScaleManagerImp::ClearData, COMDAT
; _this$ = ecx

; 1925 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	8b f1		 mov	 esi, ecx
  00008	57		 push	 edi

; 1926 : 	// (2008/12/29 - Seung-Won, Bae) Do not use m_mifOEBT. Use m_pifaOEBT.
; 1927 : 	//	// OEBT 
; 1928 : 	//	MAP_RQ_OEBT::iterator it_oebt = m_mifOEBT.begin();
; 1929 : 	//	while(it_oebt != m_mifOEBT.end())
; 1930 : 	//	{
; 1931 : 	//		delete it_oebt->second;
; 1932 : 	//		it_oebt++;
; 1933 : 	//	}
; 1934 : 
; 1935 : 	if( m_pblaRQTime != NULL)

  00009	8b 86 9c 00 00
	00		 mov	 eax, DWORD PTR [esi+156]
  0000f	85 c0		 test	 eax, eax
  00011	74 3d		 je	 SHORT $LN28@ClearData

; 1936 : 	{
; 1937 : 		for( int nRQ = 0; nRQ < m_nCountOfRQ; nRQ++) delete m_pblaRQTime[ nRQ];

  00013	33 ff		 xor	 edi, edi
  00015	39 7e 6c	 cmp	 DWORD PTR [esi+108], edi
  00018	7e 23		 jle	 SHORT $LN3@ClearData
  0001a	8b d0		 mov	 edx, eax
  0001c	0f 1f 40 00	 npad	 4
$LL4@ClearData:
  00020	8b 0c b8	 mov	 ecx, DWORD PTR [eax+edi*4]
  00023	85 c9		 test	 ecx, ecx
  00025	74 0e		 je	 SHORT $LN2@ClearData
  00027	8b 01		 mov	 eax, DWORD PTR [ecx]
  00029	6a 01		 push	 1
  0002b	ff 10		 call	 DWORD PTR [eax]
  0002d	8b 86 9c 00 00
	00		 mov	 eax, DWORD PTR [esi+156]
  00033	8b d0		 mov	 edx, eax
$LN2@ClearData:
  00035	47		 inc	 edi
  00036	3b 7e 6c	 cmp	 edi, DWORD PTR [esi+108]
  00039	7c e5		 jl	 SHORT $LL4@ClearData
  0003b	8b c2		 mov	 eax, edx
$LN3@ClearData:

; 1938 : 		delete [] m_pblaRQTime;

  0003d	50		 push	 eax
  0003e	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00043	83 c4 04	 add	 esp, 4

; 1939 : 		m_pblaRQTime = NULL;

  00046	c7 86 9c 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+156], 0
$LN28@ClearData:

; 1940 : 	}
; 1941 : 	if(m_pblaDRIfDTI != NULL)

  00050	8b 86 a0 00 00
	00		 mov	 eax, DWORD PTR [esi+160]
  00056	85 c0		 test	 eax, eax
  00058	74 39		 je	 SHORT $LN29@ClearData

; 1942 : 	{
; 1943 : 		for( int nRQ = 0; nRQ < m_nCountOfRQ; nRQ++) delete m_pblaDRIfDTI[ nRQ];

  0005a	33 ff		 xor	 edi, edi
  0005c	39 7e 6c	 cmp	 DWORD PTR [esi+108], edi
  0005f	7e 1f		 jle	 SHORT $LN6@ClearData
  00061	8b d0		 mov	 edx, eax
$LL7@ClearData:
  00063	8b 0c b8	 mov	 ecx, DWORD PTR [eax+edi*4]
  00066	85 c9		 test	 ecx, ecx
  00068	74 0e		 je	 SHORT $LN5@ClearData
  0006a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0006c	6a 01		 push	 1
  0006e	ff 10		 call	 DWORD PTR [eax]
  00070	8b 86 a0 00 00
	00		 mov	 eax, DWORD PTR [esi+160]
  00076	8b d0		 mov	 edx, eax
$LN5@ClearData:
  00078	47		 inc	 edi
  00079	3b 7e 6c	 cmp	 edi, DWORD PTR [esi+108]
  0007c	7c e5		 jl	 SHORT $LL7@ClearData
  0007e	8b c2		 mov	 eax, edx
$LN6@ClearData:

; 1944 : 		delete [] m_pblaDRIfDTI;

  00080	50		 push	 eax
  00081	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00086	83 c4 04	 add	 esp, 4

; 1945 : 		m_pblaDRIfDTI = NULL;

  00089	c7 86 a0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+160], 0
$LN29@ClearData:

; 1946 : 	}
; 1947 : 	if(m_pblaDTIfDRI != NULL)

  00093	8b 86 a8 00 00
	00		 mov	 eax, DWORD PTR [esi+168]
  00099	85 c0		 test	 eax, eax
  0009b	74 39		 je	 SHORT $LN30@ClearData

; 1948 : 	{
; 1949 : 		for( int nRQ = 0; nRQ < m_nCountOfRQ; nRQ++) delete m_pblaDTIfDRI[ nRQ];

  0009d	33 ff		 xor	 edi, edi
  0009f	39 7e 6c	 cmp	 DWORD PTR [esi+108], edi
  000a2	7e 1f		 jle	 SHORT $LN9@ClearData
  000a4	8b d0		 mov	 edx, eax
$LL10@ClearData:
  000a6	8b 0c b8	 mov	 ecx, DWORD PTR [eax+edi*4]
  000a9	85 c9		 test	 ecx, ecx
  000ab	74 0e		 je	 SHORT $LN8@ClearData
  000ad	8b 01		 mov	 eax, DWORD PTR [ecx]
  000af	6a 01		 push	 1
  000b1	ff 10		 call	 DWORD PTR [eax]
  000b3	8b 86 a8 00 00
	00		 mov	 eax, DWORD PTR [esi+168]
  000b9	8b d0		 mov	 edx, eax
$LN8@ClearData:
  000bb	47		 inc	 edi
  000bc	3b 7e 6c	 cmp	 edi, DWORD PTR [esi+108]
  000bf	7c e5		 jl	 SHORT $LL10@ClearData
  000c1	8b c2		 mov	 eax, edx
$LN9@ClearData:

; 1950 : 		delete [] m_pblaDTIfDRI;

  000c3	50		 push	 eax
  000c4	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  000c9	83 c4 04	 add	 esp, 4

; 1951 : 		m_pblaDTIfDRI = NULL;

  000cc	c7 86 a8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+168], 0
$LN30@ClearData:

; 1952 : 	}
; 1953 : 	if(m_pifaRQ != NULL)

  000d6	8b 86 8c 00 00
	00		 mov	 eax, DWORD PTR [esi+140]
  000dc	85 c0		 test	 eax, eax
  000de	74 42		 je	 SHORT $LN31@ClearData

; 1954 : 	{
; 1955 : 		for( int nRQ = 0; nRQ < m_nCountOfRQ; nRQ++) delete m_pifaRQ[ nRQ];

  000e0	33 ff		 xor	 edi, edi
  000e2	39 7e 6c	 cmp	 DWORD PTR [esi+108], edi
  000e5	7e 28		 jle	 SHORT $LN12@ClearData
  000e7	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL13@ClearData:
  000f0	8b 86 8c 00 00
	00		 mov	 eax, DWORD PTR [esi+140]
  000f6	6a 40		 push	 64			; 00000040H
  000f8	ff 34 b8	 push	 DWORD PTR [eax+edi*4]
  000fb	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00100	47		 inc	 edi
  00101	83 c4 08	 add	 esp, 8
  00104	3b 7e 6c	 cmp	 edi, DWORD PTR [esi+108]
  00107	7c e7		 jl	 SHORT $LL13@ClearData
  00109	8b 86 8c 00 00
	00		 mov	 eax, DWORD PTR [esi+140]
$LN12@ClearData:

; 1956 : 		delete [] m_pifaRQ;

  0010f	50		 push	 eax
  00110	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00115	83 c4 04	 add	 esp, 4

; 1957 : 		m_pifaRQ = NULL;

  00118	c7 86 8c 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+140], 0
$LN31@ClearData:

; 1958 : 	}
; 1959 : 	for( int i = 0; i < m_nCountOfBlockColumn; i ++) if( m_pblaAreafDTI[ i] != NULL)

  00122	33 c9		 xor	 ecx, ecx
  00124	89 4d fc	 mov	 DWORD PTR _i$1$[ebp], ecx
  00127	39 8e 2c 01 00
	00		 cmp	 DWORD PTR [esi+300], ecx
  0012d	7e 4b		 jle	 SHORT $LN15@ClearData
  0012f	8d 9e 90 05 00
	00		 lea	 ebx, DWORD PTR [esi+1424]
$LL16@ClearData:
  00135	8b 03		 mov	 eax, DWORD PTR [ebx]
  00137	85 c0		 test	 eax, eax
  00139	74 30		 je	 SHORT $LN14@ClearData

; 1960 : 	{
; 1961 : 		for( int nRQ = 0; nRQ < m_nCountOfRQ; nRQ++) delete m_pblaAreafDTI[ i][ nRQ];

  0013b	33 ff		 xor	 edi, edi
  0013d	39 7e 6c	 cmp	 DWORD PTR [esi+108], edi
  00140	7e 17		 jle	 SHORT $LN142@ClearData
$LL19@ClearData:
  00142	8b 03		 mov	 eax, DWORD PTR [ebx]
  00144	8b 0c b8	 mov	 ecx, DWORD PTR [eax+edi*4]
  00147	85 c9		 test	 ecx, ecx
  00149	74 08		 je	 SHORT $LN17@ClearData
  0014b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0014d	6a 01		 push	 1
  0014f	ff 10		 call	 DWORD PTR [eax]
  00151	8b 03		 mov	 eax, DWORD PTR [ebx]
$LN17@ClearData:
  00153	47		 inc	 edi
  00154	3b 7e 6c	 cmp	 edi, DWORD PTR [esi+108]
  00157	7c e9		 jl	 SHORT $LL19@ClearData
$LN142@ClearData:

; 1962 : 		delete [] m_pblaAreafDTI[ i];

  00159	50		 push	 eax
  0015a	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0015f	8b 4d fc	 mov	 ecx, DWORD PTR _i$1$[ebp]
  00162	83 c4 04	 add	 esp, 4

; 1963 : 		m_pblaAreafDTI[ i] = NULL;

  00165	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], 0
$LN14@ClearData:

; 1958 : 	}
; 1959 : 	for( int i = 0; i < m_nCountOfBlockColumn; i ++) if( m_pblaAreafDTI[ i] != NULL)

  0016b	41		 inc	 ecx
  0016c	83 c3 04	 add	 ebx, 4
  0016f	89 4d fc	 mov	 DWORD PTR _i$1$[ebp], ecx
  00172	3b 8e 2c 01 00
	00		 cmp	 ecx, DWORD PTR [esi+300]
  00178	7c bb		 jl	 SHORT $LL16@ClearData
$LN15@ClearData:

; 1964 : 	}
; 1965 : 	if(m_pifaOEBT != NULL)

  0017a	8b 86 90 00 00
	00		 mov	 eax, DWORD PTR [esi+144]
  00180	85 c0		 test	 eax, eax
  00182	74 4b		 je	 SHORT $LN33@ClearData

; 1966 : 	{
; 1967 : 		// (2008/12/29 - Seung-Won, Bae) Do not use m_mifOEBT. Use m_pifaOEBT.
; 1968 : 		for( int nRQ = 0; nRQ < m_nCountOfRQ; nRQ++) delete m_pifaOEBT[ nRQ];

  00184	33 ff		 xor	 edi, edi
  00186	39 7e 6c	 cmp	 DWORD PTR [esi+108], edi
  00189	7e 31		 jle	 SHORT $LN21@ClearData
  0018b	0f 1f 44 00 00	 npad	 5
$LL22@ClearData:
  00190	8b 86 90 00 00
	00		 mov	 eax, DWORD PTR [esi+144]
  00196	8b 1c b8	 mov	 ebx, DWORD PTR [eax+edi*4]
  00199	85 db		 test	 ebx, ebx
  0019b	74 19		 je	 SHORT $LN20@ClearData
  0019d	8b cb		 mov	 ecx, ebx
  0019f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  001a5	6a 08		 push	 8
  001a7	53		 push	 ebx
  001a8	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  001ad	8b 86 90 00 00
	00		 mov	 eax, DWORD PTR [esi+144]
  001b3	83 c4 08	 add	 esp, 8
$LN20@ClearData:
  001b6	47		 inc	 edi
  001b7	3b 7e 6c	 cmp	 edi, DWORD PTR [esi+108]
  001ba	7c d4		 jl	 SHORT $LL22@ClearData
$LN21@ClearData:

; 1969 : 		delete [] m_pifaOEBT;

  001bc	50		 push	 eax
  001bd	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  001c2	83 c4 04	 add	 esp, 4

; 1970 : 		m_pifaOEBT = NULL;

  001c5	c7 86 90 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+144], 0
$LN33@ClearData:

; 1971 : 	}
; 1972 : 	if( m_pamapSpecialTime != NULL)

  001cf	8b 86 a4 00 00
	00		 mov	 eax, DWORD PTR [esi+164]
  001d5	85 c0		 test	 eax, eax
  001d7	74 3a		 je	 SHORT $LN34@ClearData

; 1973 : 	{
; 1974 : 		for( int nRQ = 0; nRQ < m_nCountOfRQ; nRQ++) delete m_pamapSpecialTime[ nRQ];

  001d9	33 ff		 xor	 edi, edi
  001db	39 7e 6c	 cmp	 DWORD PTR [esi+108], edi
  001de	7e 20		 jle	 SHORT $LN24@ClearData
  001e0	8b d0		 mov	 edx, eax
$LL25@ClearData:
  001e2	8b 0c b8	 mov	 ecx, DWORD PTR [eax+edi*4]
  001e5	85 c9		 test	 ecx, ecx
  001e7	74 0f		 je	 SHORT $LN23@ClearData
  001e9	8b 01		 mov	 eax, DWORD PTR [ecx]
  001eb	6a 01		 push	 1
  001ed	ff 50 04	 call	 DWORD PTR [eax+4]
  001f0	8b 86 a4 00 00
	00		 mov	 eax, DWORD PTR [esi+164]
  001f6	8b d0		 mov	 edx, eax
$LN23@ClearData:
  001f8	47		 inc	 edi
  001f9	3b 7e 6c	 cmp	 edi, DWORD PTR [esi+108]
  001fc	7c e4		 jl	 SHORT $LL25@ClearData
  001fe	8b c2		 mov	 eax, edx
$LN24@ClearData:

; 1975 : 		delete [] m_pamapSpecialTime;

  00200	50		 push	 eax
  00201	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00206	83 c4 04	 add	 esp, 4

; 1976 : 		m_pamapSpecialTime = NULL;

  00209	c7 86 a4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+164], 0
$LN34@ClearData:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1135 :         return iterator(_Scary->_Myhead->_Left, _Scary);

  00213	8b be 94 00 00
	00		 mov	 edi, DWORD PTR [esi+148]
  00219	8d 9e 94 00 00
	00		 lea	 ebx, DWORD PTR [esi+148]

; 38   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  0021f	8b 37		 mov	 esi, DWORD PTR [edi]
  00221	3b f7		 cmp	 esi, edi
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 1981 : 	while(it != m_mifVertBox.end())

  00223	74 4f		 je	 SHORT $LN27@ClearData
$LL26@ClearData:

; 1983 : 		delete it->second;

  00225	6a 10		 push	 16			; 00000010H
  00227	ff 76 28	 push	 DWORD PTR [esi+40]
  0022a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 51   :         if (_Ptr->_Right->_Isnil) { // climb looking for right subtree

  0022f	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 1983 : 		delete it->second;

  00232	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 51   :         if (_Ptr->_Right->_Isnil) { // climb looking for right subtree

  00235	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00239	74 1d		 je	 SHORT $LN87@ClearData

; 52   :             _Nodeptr _Pnode;
; 53   :             while (!(_Pnode = _Ptr->_Parent)->_Isnil && _Ptr == _Pnode->_Right) {

  0023b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0023e	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00242	75 10		 jne	 SHORT $LN143@ClearData
$LL85@ClearData:
  00244	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  00247	75 0b		 jne	 SHORT $LN143@ClearData

; 54   :                 _Ptr = _Pnode; // ==> parent while right subtree

  00249	8b f0		 mov	 esi, eax
  0024b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0024e	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00252	74 f0		 je	 SHORT $LL85@ClearData
$LN143@ClearData:

; 55   :             }
; 56   : 
; 57   :             _Ptr = _Pnode; // ==> parent (head if end())

  00254	8b f0		 mov	 esi, eax

; 58   :         } else {

  00256	eb 16		 jmp	 SHORT $LN92@ClearData
$LN87@ClearData:

; 59   :             _Ptr = _Mytree::_Min(_Ptr->_Right); // ==> smallest of right subtree

  00258	8b f0		 mov	 esi, eax

; 451  :         while (!_Pnode->_Left->_Isnil) {

  0025a	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0025c	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00260	75 0c		 jne	 SHORT $LN92@ClearData
$LL91@ClearData:
  00262	8b 01		 mov	 eax, DWORD PTR [ecx]

; 452  :             _Pnode = _Pnode->_Left;

  00264	8b f1		 mov	 esi, ecx
  00266	8b c8		 mov	 ecx, eax
  00268	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0026c	74 f4		 je	 SHORT $LL91@ClearData
$LN92@ClearData:

; 38   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  0026e	8b 3b		 mov	 edi, DWORD PTR [ebx]

; 233  :         return this->_Ptr == _Right._Ptr;

  00270	3b f7		 cmp	 esi, edi
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 1981 : 	while(it != m_mifVertBox.end())

  00272	75 b1		 jne	 SHORT $LL26@ClearData
$LN27@ClearData:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1343 :         _Scary->_Erase_tree(_Getal(), _Head->_Parent);

  00274	ff 77 04	 push	 DWORD PTR [edi+4]
  00277	8b cb		 mov	 ecx, ebx
  00279	53		 push	 ebx
  0027a	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,CXScaleManagerImp::VERTBOX_INFO *> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,CXScaleManagerImp::VERTBOX_INFO *>,void *> > >

; 1344 :         _Head->_Parent  = _Head;

  0027f	89 7f 04	 mov	 DWORD PTR [edi+4], edi

; 1345 :         _Head->_Left    = _Head;

  00282	89 3f		 mov	 DWORD PTR [edi], edi

; 1346 :         _Head->_Right   = _Head;

  00284	89 7f 08	 mov	 DWORD PTR [edi+8], edi

; 1347 :         _Scary->_Mysize = 0;

  00287	5f		 pop	 edi
  00288	5e		 pop	 esi
  00289	c7 43 04 00 00
	00 00		 mov	 DWORD PTR [ebx+4], 0
  00290	5b		 pop	 ebx
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 1988 : }

  00291	8b e5		 mov	 esp, ebp
  00293	5d		 pop	 ebp
  00294	c3		 ret	 0
?ClearData@CXScaleManagerImp@@IAEXXZ ENDP		; CXScaleManagerImp::ClearData
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?GetLeastTime@CXScaleManagerImp@@IAE_JPAH00@Z
_TEXT	SEGMENT
_timeTemp$ = -16					; size = 8
_timeTemp$1$ = -12					; size = 4
_timeResult$2$ = -8					; size = 4
_this$1$ = -4						; size = 4
_naDTI_Cur$ = 8						; size = 4
_naIRQ$ = 12						; size = 4
_timeResult$1$ = 16					; size = 4
_pnIRQ_Count$ = 16					; size = 4
?GetLeastTime@CXScaleManagerImp@@IAE_JPAH00@Z PROC	; CXScaleManagerImp::GetLeastTime, COMDAT
; _this$ = ecx

; 1070 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1071 : 	*pnIRQ_Count = -1;

  00009	8b 7d 10	 mov	 edi, DWORD PTR _pnIRQ_Count$[ebp]

; 1072 : 	time_t timeTemp = 0;
; 1073 : 	time_t timeResult = INT_MAX;

  0000c	33 db		 xor	 ebx, ebx
  0000e	0f 57 c0	 xorps	 xmm0, xmm0
  00011	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx
  00014	ba ff ff ff 7f	 mov	 edx, 2147483647		; 7fffffffH
  00019	66 0f 13 45 f0	 movlpd	 QWORD PTR _timeTemp$[ebp], xmm0

; 1074 : 	// 1. Search the minimum time value and RQ that has it.
; 1075 : 	for( int nRQ = 0; nRQ < m_nCountOfRQ; nRQ++)

  0001e	33 f6		 xor	 esi, esi
  00020	89 55 10	 mov	 DWORD PTR _timeResult$1$[ebp], edx
  00023	c7 07 ff ff ff
	ff		 mov	 DWORD PTR [edi], -1
  00029	83 c8 ff	 or	 eax, -1
  0002c	89 5d f8	 mov	 DWORD PTR _timeResult$2$[ebp], ebx
  0002f	39 59 6c	 cmp	 DWORD PTR [ecx+108], ebx
  00032	0f 8e a7 00 00
	00		 jle	 $LN3@GetLeastTi
  00038	8b 5d f4	 mov	 ebx, DWORD PTR _timeTemp$[ebp+4]
  0003b	8b 45 f0	 mov	 eax, DWORD PTR _timeTemp$[ebp]
  0003e	89 45 f4	 mov	 DWORD PTR _timeTemp$1$[ebp], eax
$LL4@GetLeastTi:

; 1076 : 	{
; 1077 : 		// 1.1 Check current DTI is on end.
; 1078 : 		if( m_pblaRQTime[ nRQ]->GetItemCount() == ( naDTI_Cur[ nRQ] + 1)
; 1079 : 			|| naDTI_Cur[ nRQ] < -1)

  00041	8b 89 9c 00 00
	00		 mov	 ecx, DWORD PTR [ecx+156]
  00047	8b 0c b1	 mov	 ecx, DWORD PTR [ecx+esi*4]
  0004a	e8 00 00 00 00	 call	 ?GetItemCount@CDataBlockListUNK@@QAEHXZ ; CDataBlockListUNK::GetItemCount
  0004f	8b 4d 08	 mov	 ecx, DWORD PTR _naDTI_Cur$[ebp]
  00052	8b 0c b1	 mov	 ecx, DWORD PTR [ecx+esi*4]
  00055	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  00058	3b c2		 cmp	 eax, edx
  0005a	74 6e		 je	 SHORT $LN32@GetLeastTi
  0005c	83 f9 ff	 cmp	 ecx, -1
  0005f	7c 69		 jl	 SHORT $LN32@GetLeastTi

; 1083 : 		m_pTReturn = m_pblaRQTime[ nRQ]->GetAt( naDTI_Cur[ nRQ] + 1);

  00061	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 215  : 	T*	GetAt( int nIndex)	{	return ( T*)GetAtUNK( nIndex);	}

  00064	52		 push	 edx
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 1083 : 		m_pTReturn = m_pblaRQTime[ nRQ]->GetAt( naDTI_Cur[ nRQ] + 1);

  00065	8b 80 9c 00 00
	00		 mov	 eax, DWORD PTR [eax+156]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 215  : 	T*	GetAt( int nIndex)	{	return ( T*)GetAtUNK( nIndex);	}

  0006b	8b 0c b0	 mov	 ecx, DWORD PTR [eax+esi*4]
  0006e	e8 00 00 00 00	 call	 ?GetAtUNK@CDataBlockListUNK@@QAEPAXH@Z ; CDataBlockListUNK::GetAtUNK
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 1083 : 		m_pTReturn = m_pblaRQTime[ nRQ]->GetAt( naDTI_Cur[ nRQ] + 1);

  00073	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
  00076	89 41 5c	 mov	 DWORD PTR [ecx+92], eax

; 1084 : 		if( m_pTReturn) timeTemp = *m_pTReturn;

  00079	85 c0		 test	 eax, eax
  0007b	74 0a		 je	 SHORT $LN29@GetLeastTi
  0007d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0007f	8b 58 04	 mov	 ebx, DWORD PTR [eax+4]
  00082	89 4d f4	 mov	 DWORD PTR _timeTemp$1$[ebp], ecx
  00085	eb 03		 jmp	 SHORT $LN22@GetLeastTi
$LN29@GetLeastTi:
  00087	8b 4d f4	 mov	 ecx, DWORD PTR _timeTemp$1$[ebp]
$LN22@GetLeastTi:

; 1085 : 
; 1086 : 		// 1.3 Get the minimum time value.
; 1087 : 		if( timeResult < timeTemp) continue;

  0008a	8b 45 f8	 mov	 eax, DWORD PTR _timeResult$2$[ebp]
  0008d	8b 55 10	 mov	 edx, DWORD PTR _timeResult$1$[ebp]
  00090	3b c3		 cmp	 eax, ebx
  00092	7c 39		 jl	 SHORT $LN2@GetLeastTi
  00094	7f 04		 jg	 SHORT $LN26@GetLeastTi
  00096	3b d1		 cmp	 edx, ecx
  00098	72 33		 jb	 SHORT $LN2@GetLeastTi
$LN26@GetLeastTi:

; 1088 : 		if( timeTemp < timeResult)

  0009a	3b d8		 cmp	 ebx, eax
  0009c	7f 20		 jg	 SHORT $LN23@GetLeastTi
  0009e	7c 04		 jl	 SHORT $LN27@GetLeastTi
  000a0	3b ca		 cmp	 ecx, edx
  000a2	73 1a		 jae	 SHORT $LN23@GetLeastTi
$LN27@GetLeastTi:

; 1089 : 		{
; 1090 : 			timeResult = timeTemp;

  000a4	8b d1		 mov	 edx, ecx

; 1091 : 			*pnIRQ_Count = 0;

  000a6	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0

; 1092 : 		}
; 1093 : 
; 1094 : 		// 1.4 Get the RQs that have the time value with same to the minimum time value.
; 1095 : 		naIRQ[ *pnIRQ_Count] = nRQ;

  000ac	8b 4d 0c	 mov	 ecx, DWORD PTR _naIRQ$[ebp]
  000af	33 c0		 xor	 eax, eax
  000b1	89 55 10	 mov	 DWORD PTR _timeResult$1$[ebp], edx
  000b4	89 5d f8	 mov	 DWORD PTR _timeResult$2$[ebp], ebx
  000b7	89 34 81	 mov	 DWORD PTR [ecx+eax*4], esi

; 1096 : 		( *pnIRQ_Count)++;

  000ba	ff 07		 inc	 DWORD PTR [edi]
  000bc	eb 0f		 jmp	 SHORT $LN2@GetLeastTi
$LN23@GetLeastTi:

; 1091 : 			*pnIRQ_Count = 0;

  000be	8b 07		 mov	 eax, DWORD PTR [edi]

; 1092 : 		}
; 1093 : 
; 1094 : 		// 1.4 Get the RQs that have the time value with same to the minimum time value.
; 1095 : 		naIRQ[ *pnIRQ_Count] = nRQ;

  000c0	8b 4d 0c	 mov	 ecx, DWORD PTR _naIRQ$[ebp]
  000c3	89 34 81	 mov	 DWORD PTR [ecx+eax*4], esi

; 1096 : 		( *pnIRQ_Count)++;

  000c6	ff 07		 inc	 DWORD PTR [edi]
  000c8	eb 03		 jmp	 SHORT $LN2@GetLeastTi
$LN32@GetLeastTi:

; 1074 : 	// 1. Search the minimum time value and RQ that has it.
; 1075 : 	for( int nRQ = 0; nRQ < m_nCountOfRQ; nRQ++)

  000ca	8b 55 10	 mov	 edx, DWORD PTR _timeResult$1$[ebp]
$LN2@GetLeastTi:
  000cd	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
  000d0	46		 inc	 esi
  000d1	3b 71 6c	 cmp	 esi, DWORD PTR [ecx+108]
  000d4	0f 8c 67 ff ff
	ff		 jl	 $LL4@GetLeastTi

; 1091 : 			*pnIRQ_Count = 0;

  000da	8b 07		 mov	 eax, DWORD PTR [edi]
  000dc	8b 5d f8	 mov	 ebx, DWORD PTR _timeResult$2$[ebp]
$LN3@GetLeastTi:

; 1097 : 	}
; 1098 : 
; 1099 : 	//    RQ
; 1100 : 	for( int nCount = 0; nCount < *pnIRQ_Count; nCount++)

  000df	33 f6		 xor	 esi, esi
  000e1	85 c0		 test	 eax, eax
  000e3	7e 24		 jle	 SHORT $LN28@GetLeastTi
  000e5	8b 45 0c	 mov	 eax, DWORD PTR _naIRQ$[ebp]
  000e8	8b 55 08	 mov	 edx, DWORD PTR _naDTI_Cur$[ebp]
  000eb	0f 1f 44 00 00	 npad	 5
$LL7@GetLeastTi:

; 1101 : 		naDTI_Cur[ naIRQ[ nCount]]++;

  000f0	8b 0c b0	 mov	 ecx, DWORD PTR [eax+esi*4]
  000f3	46		 inc	 esi
  000f4	ff 04 8a	 inc	 DWORD PTR [edx+ecx*4]
  000f7	3b 37		 cmp	 esi, DWORD PTR [edi]
  000f9	7c f5		 jl	 SHORT $LL7@GetLeastTi

; 1102 : 
; 1103 : 	return timeResult;

  000fb	8b 45 10	 mov	 eax, DWORD PTR _timeResult$1$[ebp]

; 1104 : }

  000fe	8b d3		 mov	 edx, ebx
  00100	5f		 pop	 edi
  00101	5e		 pop	 esi
  00102	5b		 pop	 ebx
  00103	8b e5		 mov	 esp, ebp
  00105	5d		 pop	 ebp
  00106	c2 0c 00	 ret	 12			; 0000000cH
$LN28@GetLeastTi:
  00109	5f		 pop	 edi

; 1102 : 
; 1103 : 	return timeResult;

  0010a	8b c2		 mov	 eax, edx

; 1104 : }

  0010c	8b d3		 mov	 edx, ebx
  0010e	5e		 pop	 esi
  0010f	5b		 pop	 ebx
  00110	8b e5		 mov	 esp, ebp
  00112	5d		 pop	 ebp
  00113	c2 0c 00	 ret	 12			; 0000000cH
?GetLeastTime@CXScaleManagerImp@@IAE_JPAH00@Z ENDP	; CXScaleManagerImp::GetLeastTime
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
;	COMDAT ??_G?$CDataBlockList@UtagAREA@CXScaleManager@@$0CAA@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CDataBlockList@UtagAREA@CXScaleManager@@$0CAA@@@UAEPAXI@Z PROC ; CDataBlockList<CXScaleManager::tagAREA,512>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 163  : 	{

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CDataBlockList@UtagAREA@CXScaleManager@@$0CAA@@@6B@

; 164  : 	}

  0000c	e8 00 00 00 00	 call	 ??1CDataBlockListUNK@@UAE@XZ ; CDataBlockListUNK::~CDataBlockListUNK
  00011	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00015	74 0b		 je	 SHORT $LN7@scalar
  00017	6a 34		 push	 52			; 00000034H
  00019	56		 push	 esi
  0001a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001f	83 c4 08	 add	 esp, 8
$LN7@scalar:
  00022	8b c6		 mov	 eax, esi
  00024	5e		 pop	 esi
  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
??_G?$CDataBlockList@UtagAREA@CXScaleManager@@$0CAA@@@UAEPAXI@Z ENDP ; CDataBlockList<CXScaleManager::tagAREA,512>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
;	COMDAT ??1?$CDataBlockList@UtagAREA@CXScaleManager@@$0CAA@@@UAE@XZ
_TEXT	SEGMENT
??1?$CDataBlockList@UtagAREA@CXScaleManager@@$0CAA@@@UAE@XZ PROC ; CDataBlockList<CXScaleManager::tagAREA,512>::~CDataBlockList<CXScaleManager::tagAREA,512>, COMDAT
; _this$ = ecx

; 163  : 	{

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CDataBlockList@UtagAREA@CXScaleManager@@$0CAA@@@6B@

; 164  : 	}

  00006	e9 00 00 00 00	 jmp	 ??1CDataBlockListUNK@@UAE@XZ ; CDataBlockListUNK::~CDataBlockListUNK
??1?$CDataBlockList@UtagAREA@CXScaleManager@@$0CAA@@@UAE@XZ ENDP ; CDataBlockList<CXScaleManager::tagAREA,512>::~CDataBlockList<CXScaleManager::tagAREA,512>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
;	COMDAT ??0?$CDataBlockList@UtagAREA@CXScaleManager@@$0CAA@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$CDataBlockList@UtagAREA@CXScaleManager@@$0CAA@@@QAE@XZ PROC ; CDataBlockList<CXScaleManager::tagAREA,512>::CDataBlockList<CXScaleManager::tagAREA,512>, COMDAT
; _this$ = ecx

; 158  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00004	c7 41 28 00 00
	00 00		 mov	 DWORD PTR [ecx+40], 0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 159  : 	}

  0000b	8b c1		 mov	 eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  0000d	c7 41 2c 00 00
	00 00		 mov	 DWORD PTR [ecx+44], 0
  00014	c7 41 30 00 00
	00 00		 mov	 DWORD PTR [ecx+48], 0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 158  : 	{

  0001b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 24   : 		m_nItemSize = nItemSize;

  0001e	c7 41 04 06 00
	00 00		 mov	 DWORD PTR [ecx+4], 6

; 25   : 		m_nBlockSize = nBlockSize;

  00025	c7 41 08 00 02
	00 00		 mov	 DWORD PTR [ecx+8], 512	; 00000200H

; 26   : 
; 27   : 		m_nItemCount = 0;

  0002c	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 28   : 		m_nFirstBlockStartIndex = 0;

  00033	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 29   : 		m_nLastBlockEndIndex = 0;

  0003a	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 30   : 
; 31   : 		m_nIndex = 0;

  00041	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0

; 32   : 		m_nBlockIndex = 0;

  00048	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 33   : 		m_nIndexInBlock = 0;

  0004f	c7 41 24 00 00
	00 00		 mov	 DWORD PTR [ecx+36], 0

; 34   : 		m_lpBlockIndex = NULL;

  00056	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0

; 158  : 	{

  0005d	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CDataBlockList@UtagAREA@CXScaleManager@@$0CAA@@@6B@

; 159  : 	}

  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c3		 ret	 0
??0?$CDataBlockList@UtagAREA@CXScaleManager@@$0CAA@@@QAE@XZ ENDP ; CDataBlockList<CXScaleManager::tagAREA,512>::CDataBlockList<CXScaleManager::tagAREA,512>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ??1CXScaleManagerImp@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1CXScaleManagerImp@@UAE@XZ PROC			; CXScaleManagerImp::~CXScaleManagerImp, COMDAT
; _this$ = ecx

; 126  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CXScaleManagerImp@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f9		 mov	 edi, ecx
  00026	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7CXScaleManagerImp@@6B@

; 127  : 	ClearData();

  0002c	e8 00 00 00 00	 call	 ?ClearData@CXScaleManagerImp@@IAEXXZ ; CXScaleManagerImp::ClearData

; 128  : }

  00031	68 00 00 00 00	 push	 OFFSET ??1?$CDataBlockList@H$0CAA@@@UAE@XZ ; CDataBlockList<int,512>::~CDataBlockList<int,512>
  00036	6a 0a		 push	 10			; 0000000aH
  00038	6a 34		 push	 52			; 00000034H
  0003a	8d 87 84 0c 00
	00		 lea	 eax, DWORD PTR [edi+3204]
  00040	50		 push	 eax
  00041	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  00046	68 00 00 00 00	 push	 OFFSET ??1?$CDataBlockList@Utm@@$0CAA@@@UAE@XZ ; CDataBlockList<tm,512>::~CDataBlockList<tm,512>
  0004b	6a 0a		 push	 10			; 0000000aH
  0004d	6a 34		 push	 52			; 00000034H
  0004f	8d 87 7c 0a 00
	00		 lea	 eax, DWORD PTR [edi+2684]
  00055	50		 push	 eax
  00056	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  0005b	8d 8f 74 0a 00
	00		 lea	 ecx, DWORD PTR [edi+2676]
  00061	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00067	68 00 00 00 00	 push	 OFFSET ??1?$CDataBlockList@H$0CAA@@@UAE@XZ ; CDataBlockList<int,512>::~CDataBlockList<int,512>
  0006c	6a 0a		 push	 10			; 0000000aH
  0006e	6a 34		 push	 52			; 00000034H
  00070	8d 87 64 08 00
	00		 lea	 eax, DWORD PTR [edi+2148]
  00076	50		 push	 eax
  00077	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  0007c	68 00 00 00 00	 push	 OFFSET ??1?$CDataBlockList@Utm@@$0CAA@@@UAE@XZ ; CDataBlockList<tm,512>::~CDataBlockList<tm,512>
  00081	6a 0a		 push	 10			; 0000000aH
  00083	6a 34		 push	 52			; 00000034H
  00085	8d 87 5c 06 00
	00		 lea	 eax, DWORD PTR [edi+1628]
  0008b	50		 push	 eax
  0008c	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  00091	8d 8f 18 06 00
	00		 lea	 ecx, DWORD PTR [edi+1560]
  00097	e8 00 00 00 00	 call	 ??1CMapWordToPtr@@UAE@XZ ; CMapWordToPtr::~CMapWordToPtr
  0009c	8d 8f ec 05 00
	00		 lea	 ecx, DWORD PTR [edi+1516]
  000a2	e8 00 00 00 00	 call	 ??1CXScaleTimeDiffManager@@UAE@XZ ; CXScaleTimeDiffManager::~CXScaleTimeDiffManager
  000a7	68 00 00 00 00	 push	 OFFSET ??1?$CDataBlockList@UtagAREA@CXScaleManager@@$0CAA@@@UAE@XZ ; CDataBlockList<CXScaleManager::tagAREA,512>::~CDataBlockList<CXScaleManager::tagAREA,512>
  000ac	6a 0a		 push	 10			; 0000000aH
  000ae	6a 34		 push	 52			; 00000034H
  000b0	8d 87 88 03 00
	00		 lea	 eax, DWORD PTR [edi+904]
  000b6	50		 push	 eax
  000b7	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  000bc	8d 8f ac 00 00
	00		 lea	 ecx, DWORD PTR [edi+172]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 163  : 	{

  000c2	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CDataBlockList@_J$0CAA@@@6B@

; 164  : 	}

  000c8	e8 00 00 00 00	 call	 ??1CDataBlockListUNK@@UAE@XZ ; CDataBlockListUNK::~CDataBlockListUNK
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 752  :         _Erase_tree(_Al, _Myhead->_Parent);

  000cd	8b 87 94 00 00
	00		 mov	 eax, DWORD PTR [edi+148]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 128  : }

  000d3	8d b7 94 00 00
	00		 lea	 esi, DWORD PTR [edi+148]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 752  :         _Erase_tree(_Al, _Myhead->_Parent);

  000d9	8b ce		 mov	 ecx, esi
  000db	ff 70 04	 push	 DWORD PTR [eax+4]
  000de	56		 push	 esi
  000df	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,CXScaleManagerImp::VERTBOX_INFO *> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,CXScaleManagerImp::VERTBOX_INFO *>,void *> > >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 255  :         ::operator delete(_Ptr, _Bytes);

  000e4	6a 2c		 push	 44			; 0000002cH
  000e6	ff 36		 push	 DWORD PTR [esi]
  000e8	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  000ed	83 c4 08	 add	 esp, 8
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 128  : }

  000f0	8d 4f 78	 lea	 ecx, DWORD PTR [edi+120]
  000f3	e8 00 00 00 00	 call	 ??1CStringArray@@UAE@XZ	; CStringArray::~CStringArray
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 752  :         _Erase_tree(_Al, _Myhead->_Parent);

  000f8	8b 47 70	 mov	 eax, DWORD PTR [edi+112]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 128  : }

  000fb	8d 77 70	 lea	 esi, DWORD PTR [edi+112]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 752  :         _Erase_tree(_Al, _Myhead->_Parent);

  000fe	8b ce		 mov	 ecx, esi
  00100	ff 70 04	 push	 DWORD PTR [eax+4]
  00103	56		 push	 esi
  00104	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> > >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 255  :         ::operator delete(_Ptr, _Bytes);

  00109	6a 2c		 push	 44			; 0000002cH
  0010b	ff 36		 push	 DWORD PTR [esi]
  0010d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00112	83 c4 08	 add	 esp, 8
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 128  : }

  00115	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7CXScaleManager@@6B@
  0011b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0011e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00125	59		 pop	 ecx
  00126	5f		 pop	 edi
  00127	5e		 pop	 esi
  00128	8b e5		 mov	 esp, ebp
  0012a	5d		 pop	 ebp
  0012b	c3		 ret	 0
  0012c	cc		 int	 3
  0012d	cc		 int	 3
  0012e	cc		 int	 3
  0012f	cc		 int	 3
  00130	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1CXScaleManagerImp@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CXScaleManagerImp@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CXScaleManagerImp@@UAE@XZ ENDP			; CXScaleManagerImp::~CXScaleManagerImp
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\Dll_Load\XScaleManager.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\Dll_Load\XScaleManager.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\Dll_Load\XScaleManager.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\Dll_Load\XScaleManager.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\Dll_Load\XScaleManager.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ??0CXScaleManagerImp@@QAE@XZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
_this$ = -24						; size = 4
_this$ = -24						; size = 4
$T2 = -24						; size = 6
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CXScaleManagerImp@@QAE@XZ PROC			; CXScaleManagerImp::CXScaleManagerImp, COMDAT
; _this$ = ecx

; 21   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CXScaleManagerImp@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b d9		 mov	 ebx, ecx
  0002a	89 5d f0	 mov	 DWORD PTR _this$[ebp], ebx
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\Dll_Load\XScaleManager.h

; 67   : 			left = center = right = 0;

  0002d	33 c0		 xor	 eax, eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 21   : {

  0002f	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], OFFSET ??_7CXScaleManagerImp@@6B@
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\Dll_Load\XScaleManager.h

; 67   : 			left = center = right = 0;

  00035	89 43 3e	 mov	 DWORD PTR [ebx+62], eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 21   : {

  00038	8d 73 70	 lea	 esi, DWORD PTR [ebx+112]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\Dll_Load\XScaleManager.h

; 67   : 			left = center = right = 0;

  0003b	66 89 43 3c	 mov	 WORD PTR [ebx+60], ax
  0003f	89 43 44	 mov	 DWORD PTR [ebx+68], eax
  00042	66 89 43 42	 mov	 WORD PTR [ebx+66], ax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 21   : {

  00046	89 75 e8	 mov	 DWORD PTR _this$[ebp], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 79   :         return ::operator new(_Bytes);

  00049	6a 2c		 push	 44			; 0000002cH
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 21   : {

  0004b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 435  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

  00052	89 06		 mov	 DWORD PTR [esi], eax
  00054	89 46 04	 mov	 DWORD PTR [esi+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 79   :         return ::operator new(_Bytes);

  00057	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0005c	83 c4 04	 add	 esp, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 345  :         _Construct_in_place(_Pnode->_Left, _Pnode);

  0005f	89 00		 mov	 DWORD PTR [eax], eax

; 346  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

  00061	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 347  :         _Construct_in_place(_Pnode->_Right, _Pnode);

  00064	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 348  :         _Pnode->_Color = _Black;

  00067	66 c7 40 0c 01
	01		 mov	 WORD PTR [eax+12], 257	; 00000101H

; 1917 :         _Scary->_Myhead = _Node::_Buyheadnode(_Getal());

  0006d	89 06		 mov	 DWORD PTR [esi], eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 21   : {

  0006f	8d 4b 78	 lea	 ecx, DWORD PTR [ebx+120]
  00072	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00076	e8 00 00 00 00	 call	 ??0CStringArray@@QAE@XZ	; CStringArray::CStringArray
  0007b	8d b3 94 00 00
	00		 lea	 esi, DWORD PTR [ebx+148]
  00081	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00085	89 75 e8	 mov	 DWORD PTR _this$[ebp], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 79   :         return ::operator new(_Bytes);

  00088	6a 2c		 push	 44			; 0000002cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 435  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

  0008a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00090	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 79   :         return ::operator new(_Bytes);

  00097	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0009c	83 c4 04	 add	 esp, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 345  :         _Construct_in_place(_Pnode->_Left, _Pnode);

  0009f	89 00		 mov	 DWORD PTR [eax], eax

; 346  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

  000a1	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 347  :         _Construct_in_place(_Pnode->_Right, _Pnode);

  000a4	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 348  :         _Pnode->_Color = _Black;

  000a7	66 c7 40 0c 01
	01		 mov	 WORD PTR [eax+12], 257	; 00000101H

; 1917 :         _Scary->_Myhead = _Node::_Buyheadnode(_Getal());

  000ad	89 06		 mov	 DWORD PTR [esi], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  000af	c7 83 d4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ebx+212], 0
  000b9	c7 83 d8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ebx+216], 0
  000c3	c7 83 dc 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ebx+220], 0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 24   : 		m_nItemSize = nItemSize;

  000cd	c7 83 b0 00 00
	00 08 00 00 00	 mov	 DWORD PTR [ebx+176], 8

; 25   : 		m_nBlockSize = nBlockSize;

  000d7	c7 83 b4 00 00
	00 00 02 00 00	 mov	 DWORD PTR [ebx+180], 512 ; 00000200H

; 26   : 
; 27   : 		m_nItemCount = 0;

  000e1	c7 83 b8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ebx+184], 0

; 28   : 		m_nFirstBlockStartIndex = 0;

  000eb	c7 83 bc 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ebx+188], 0

; 29   : 		m_nLastBlockEndIndex = 0;

  000f5	c7 83 c0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ebx+192], 0

; 30   : 
; 31   : 		m_nIndex = 0;

  000ff	c7 83 c4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ebx+196], 0

; 32   : 		m_nBlockIndex = 0;

  00109	c7 83 c8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ebx+200], 0

; 33   : 		m_nIndexInBlock = 0;

  00113	c7 83 d0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ebx+208], 0

; 34   : 		m_lpBlockIndex = NULL;

  0011d	c7 83 cc 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ebx+204], 0

; 158  : 	{

  00127	c7 83 ac 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ebx+172], OFFSET ??_7?$CDataBlockList@_J$0CAA@@@6B@
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 21   : {

  00131	68 00 00 00 00	 push	 OFFSET ??1?$CDataBlockList@UtagAREA@CXScaleManager@@$0CAA@@@UAE@XZ ; CDataBlockList<CXScaleManager::tagAREA,512>::~CDataBlockList<CXScaleManager::tagAREA,512>
  00136	68 00 00 00 00	 push	 OFFSET ??0?$CDataBlockList@UtagAREA@CXScaleManager@@$0CAA@@@QAE@XZ ; CDataBlockList<CXScaleManager::tagAREA,512>::CDataBlockList<CXScaleManager::tagAREA,512>
  0013b	6a 0a		 push	 10			; 0000000aH
  0013d	6a 34		 push	 52			; 00000034H
  0013f	8d 83 88 03 00
	00		 lea	 eax, DWORD PTR [ebx+904]
  00145	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  00149	50		 push	 eax
  0014a	e8 00 00 00 00	 call	 ??_L@YGXPAXIIP6EX0@Z1@Z
  0014f	8d bb b8 05 00
	00		 lea	 edi, DWORD PTR [ebx+1464]
  00155	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  00159	8d 8b ec 05 00
	00		 lea	 ecx, DWORD PTR [ebx+1516]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h

; 528  : 	left = 0;

  0015f	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0

; 529  : 	top = 0;

  00165	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0

; 530  : 	right = 0;

  0016c	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0

; 531  : 	bottom = 0;

  00173	c7 47 0c 00 00
	00 00		 mov	 DWORD PTR [edi+12], 0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 21   : {

  0017a	e8 00 00 00 00	 call	 ??0CXScaleTimeDiffManager@@QAE@XZ ; CXScaleTimeDiffManager::CXScaleTimeDiffManager
  0017f	8b f3		 mov	 esi, ebx
  00181	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  00185	81 c6 18 06 00
	00		 add	 esi, 1560		; 00000618H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 2048 : 		: BASE_CLASS(nBlockSize) { }

  0018b	6a 0a		 push	 10			; 0000000aH
  0018d	8b ce		 mov	 ecx, esi
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 21   : {

  0018f	89 75 e8	 mov	 DWORD PTR _this$[ebp], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 2048 : 		: BASE_CLASS(nBlockSize) { }

  00192	e8 00 00 00 00	 call	 ??0CMapWordToPtr@@QAE@H@Z ; CMapWordToPtr::CMapWordToPtr
  00197	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CTypedPtrMap@VCMapWordToPtr@@FPAVCXScaleGridTime@@@@6B@
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 21   : {

  0019d	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
  001a1	68 00 00 00 00	 push	 OFFSET ??1?$CDataBlockList@Utm@@$0CAA@@@UAE@XZ ; CDataBlockList<tm,512>::~CDataBlockList<tm,512>
  001a6	68 00 00 00 00	 push	 OFFSET ??0?$CDataBlockList@Utm@@$0CAA@@@QAE@XZ ; CDataBlockList<tm,512>::CDataBlockList<tm,512>
  001ab	8b f3		 mov	 esi, ebx
  001ad	6a 0a		 push	 10			; 0000000aH
  001af	6a 34		 push	 52			; 00000034H
  001b1	8d 86 5c 06 00
	00		 lea	 eax, DWORD PTR [esi+1628]
  001b7	50		 push	 eax
  001b8	e8 00 00 00 00	 call	 ??_L@YGXPAXIIP6EX0@Z1@Z
  001bd	68 00 00 00 00	 push	 OFFSET ??1?$CDataBlockList@H$0CAA@@@UAE@XZ ; CDataBlockList<int,512>::~CDataBlockList<int,512>
  001c2	68 00 00 00 00	 push	 OFFSET ??0?$CDataBlockList@H$0CAA@@@QAE@XZ ; CDataBlockList<int,512>::CDataBlockList<int,512>
  001c7	6a 0a		 push	 10			; 0000000aH
  001c9	6a 34		 push	 52			; 00000034H
  001cb	8d 86 64 08 00
	00		 lea	 eax, DWORD PTR [esi+2148]
  001d1	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
  001d5	50		 push	 eax
  001d6	e8 00 00 00 00	 call	 ??_L@YGXPAXIIP6EX0@Z1@Z
  001db	8d 8e 74 0a 00
	00		 lea	 ecx, DWORD PTR [esi+2676]
  001e1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  001e7	68 00 00 00 00	 push	 OFFSET ??1?$CDataBlockList@Utm@@$0CAA@@@UAE@XZ ; CDataBlockList<tm,512>::~CDataBlockList<tm,512>
  001ec	68 00 00 00 00	 push	 OFFSET ??0?$CDataBlockList@Utm@@$0CAA@@@QAE@XZ ; CDataBlockList<tm,512>::CDataBlockList<tm,512>
  001f1	6a 0a		 push	 10			; 0000000aH
  001f3	6a 34		 push	 52			; 00000034H
  001f5	8d 86 7c 0a 00
	00		 lea	 eax, DWORD PTR [esi+2684]
  001fb	c6 45 fc 0a	 mov	 BYTE PTR __$EHRec$[ebp+8], 10 ; 0000000aH
  001ff	50		 push	 eax
  00200	e8 00 00 00 00	 call	 ??_L@YGXPAXIIP6EX0@Z1@Z
  00205	68 00 00 00 00	 push	 OFFSET ??1?$CDataBlockList@H$0CAA@@@UAE@XZ ; CDataBlockList<int,512>::~CDataBlockList<int,512>
  0020a	68 00 00 00 00	 push	 OFFSET ??0?$CDataBlockList@H$0CAA@@@QAE@XZ ; CDataBlockList<int,512>::CDataBlockList<int,512>
  0020f	6a 0a		 push	 10			; 0000000aH
  00211	6a 34		 push	 52			; 00000034H
  00213	8d 86 84 0c 00
	00		 lea	 eax, DWORD PTR [esi+3204]
  00219	c6 45 fc 0b	 mov	 BYTE PTR __$EHRec$[ebp+8], 11 ; 0000000bH
  0021d	50		 push	 eax
  0021e	e8 00 00 00 00	 call	 ??_L@YGXPAXIIP6EX0@Z1@Z

; 22   : 	// (2009/9/15 - Seung-Won, Bae) Do not support special time for WorldOn.
; 23   : 	m_eChartMode = CChartInfo::HTS;

  00223	c7 86 e8 05 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+1512], 1

; 24   : 
; 25   : 	// (2009/6/4 - Seung-Won, Bae) for ceiled Minute Scale with second time data.
; 26   : 	m_bCeiling = 0;

  0022d	c7 86 e4 05 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+1508], 0

; 27   : 
; 28   : 	// (2009/2/13 - Seung-Won, Bae) for Multi-Column.
; 29   : 	m_nCountOfBlockColumn = 0;				//  : xScaleManager - ojtaso (20071128)

  00237	c7 86 2c 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+300], 0

; 30   : 	for( int i = 0; i < _MAX_COL; i++)
; 31   : 	{
; 32   : 		m_naScreenRegionLeft[	i] = 0;
; 33   : 		m_naScreenRegionWidth[	i] = 0;
; 34   : 		m_daItemWidth[			i] = 1.0;

  00241	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@3ff00000000000003ff0000000000000
  00248	c7 86 58 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+344], 0
  00252	c7 86 80 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+384], 0
  0025c	0f 11 86 a8 01
	00 00		 movups	 XMMWORD PTR [esi+424], xmm0

; 35   : 		m_naItemWidth[			i] = 1;

  00263	c7 86 60 03 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+864], 1

; 36   : 		m_pblaAreafDTI[			i] = NULL;

  0026d	c7 86 90 05 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+1424], 0

; 37   : 		m_naScreenStart_Cur[	i] = 0;

  00277	c7 86 98 02 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+664], 0

; 38   : 		m_naScreenEnd_Cur[		i] = 0;

  00281	c7 86 c0 02 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+704], 0

; 39   : 		m_naScaleType[			i] = -1;

  0028b	c7 86 34 06 00
	00 ff ff ff ff	 mov	 DWORD PTR [esi+1588], -1
  00295	c7 86 5c 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+348], 0
  0029f	c7 86 84 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+388], 0
  002a9	c7 86 64 03 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+868], 1
  002b3	c7 86 94 05 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+1428], 0
  002bd	c7 86 9c 02 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+668], 0
  002c7	c7 86 c4 02 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+708], 0
  002d1	c7 86 38 06 00
	00 ff ff ff ff	 mov	 DWORD PTR [esi+1592], -1
  002db	c7 86 60 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+352], 0
  002e5	c7 86 88 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+392], 0
  002ef	0f 11 86 b8 01
	00 00		 movups	 XMMWORD PTR [esi+440], xmm0
  002f6	c7 86 68 03 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+872], 1
  00300	c7 86 98 05 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+1432], 0
  0030a	c7 86 a0 02 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+672], 0
  00314	c7 86 c8 02 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+712], 0
  0031e	c7 86 3c 06 00
	00 ff ff ff ff	 mov	 DWORD PTR [esi+1596], -1
  00328	c7 86 64 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+356], 0
  00332	c7 86 8c 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+396], 0
  0033c	c7 86 6c 03 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+876], 1
  00346	c7 86 9c 05 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+1436], 0
  00350	c7 86 a4 02 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+676], 0
  0035a	c7 86 cc 02 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+716], 0
  00364	c7 86 40 06 00
	00 ff ff ff ff	 mov	 DWORD PTR [esi+1600], -1
  0036e	c7 86 68 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+360], 0
  00378	c7 86 90 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+400], 0
  00382	0f 11 86 c8 01
	00 00		 movups	 XMMWORD PTR [esi+456], xmm0
  00389	c6 45 fc 0c	 mov	 BYTE PTR __$EHRec$[ebp+8], 12 ; 0000000cH
  0038d	c7 86 70 03 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+880], 1
  00397	c7 86 a0 05 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+1440], 0
  003a1	c7 86 a8 02 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+680], 0
  003ab	c7 86 d0 02 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+720], 0
  003b5	c7 86 44 06 00
	00 ff ff ff ff	 mov	 DWORD PTR [esi+1604], -1
  003bf	c7 86 6c 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+364], 0
  003c9	c7 86 94 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+404], 0
  003d3	c7 86 74 03 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+884], 1
  003dd	c7 86 a4 05 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+1444], 0
  003e7	c7 86 ac 02 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+684], 0
  003f1	c7 86 d4 02 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+724], 0
  003fb	c7 86 48 06 00
	00 ff ff ff ff	 mov	 DWORD PTR [esi+1608], -1
  00405	c7 86 70 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+368], 0
  0040f	c7 86 98 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+408], 0
  00419	0f 11 86 d8 01
	00 00		 movups	 XMMWORD PTR [esi+472], xmm0
  00420	c7 86 78 03 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+888], 1
  0042a	c7 86 a8 05 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+1448], 0
  00434	c7 86 b0 02 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+688], 0
  0043e	c7 86 d8 02 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+728], 0
  00448	c7 86 4c 06 00
	00 ff ff ff ff	 mov	 DWORD PTR [esi+1612], -1
  00452	c7 86 74 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+372], 0
  0045c	c7 86 9c 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+412], 0
  00466	c7 86 7c 03 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+892], 1
  00470	c7 86 ac 05 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+1452], 0
  0047a	c7 86 b4 02 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+692], 0
  00484	c7 86 dc 02 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+732], 0
  0048e	c7 86 50 06 00
	00 ff ff ff ff	 mov	 DWORD PTR [esi+1616], -1
  00498	c7 86 78 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+376], 0
  004a2	c7 86 a0 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+416], 0
  004ac	0f 11 86 e8 01
	00 00		 movups	 XMMWORD PTR [esi+488], xmm0
  004b3	c7 86 80 03 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+896], 1
  004bd	c7 86 b0 05 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+1456], 0
  004c7	c7 86 b8 02 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+696], 0
  004d1	c7 86 e0 02 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+736], 0
  004db	c7 86 54 06 00
	00 ff ff ff ff	 mov	 DWORD PTR [esi+1620], -1
  004e5	c7 86 7c 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+380], 0
  004ef	c7 86 a4 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+420], 0
  004f9	c7 86 84 03 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+900], 1
  00503	c7 86 b4 05 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+1460], 0
  0050d	c7 86 bc 02 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+700], 0
  00517	c7 86 e4 02 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+740], 0
  00521	c7 86 58 06 00
	00 ff ff ff ff	 mov	 DWORD PTR [esi+1624], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h

; 669  : 	::SetRectEmpty(this);

  0052b	57		 push	 edi
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 43   : 	m_nDefaultDataSpace = 0;

  0052c	c7 86 28 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+296], 0

; 44   : 
; 45   : 	// (2009/1/19 - Seung-Won, Bae) for Scale Time List
; 46   : 	m_nSkipFactor = 1;

  00536	c7 86 6c 0a 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+2668], 1

; 47   : 	m_eScaleDrawType = CScaleBaseData::HORZ_NOTYPE;

  00540	c7 86 70 0a 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+2672], 0

; 48   : 
; 49   : 	// (2009/1/16 - Seung-Won, Bae) Support the Re-Calculation Mode on OCX OnDrawing
; 50   : 	m_nCalculationMode = 2;			// 0:No-Calc, 1:CalcByReal, 2:CalcAll

  0054a	c7 86 20 01 00
	00 02 00 00 00	 mov	 DWORD PTR [esi+288], 2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h

; 669  : 	::SetRectEmpty(this);

  00554	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetRectEmpty@4
  0055a	0f 57 c0	 xorps	 xmm0, xmm0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\Dll_Load\XScaleManager.h

; 72   : 			left = left_p;

  0055d	c7 45 e8 78 ec
	78 ec		 mov	 DWORD PTR $T2[ebp], -327619464 ; ec78ec78H
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 96   : 	m_areaNONE = AREA(-5000, -5000, -5000);

  00564	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\Dll_Load\XScaleManager.h

; 72   : 			left = left_p;

  00567	b9 78 ec ff ff	 mov	 ecx, -5000		; ffffec78H
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp

; 96   : 	m_areaNONE = AREA(-5000, -5000, -5000);

  0056c	89 46 3c	 mov	 DWORD PTR [esi+60], eax
  0056f	c7 86 c8 05 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+1480], 0
  00579	c7 86 cc 05 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+1484], 0
  00583	f2 0f 11 86 d0
	05 00 00	 movsd	 QWORD PTR [esi+1488], xmm0
  0058b	c7 86 fc 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+252], 0
  00595	c7 86 00 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+256], 0
  0059f	c7 86 04 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [esi+260], -1
  005a9	c7 86 08 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+264], 0
  005b3	c7 86 0c 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+268], 0
  005bd	c7 86 10 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [esi+272], -1
  005c7	c7 86 14 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+276], 0
  005d1	f2 0f 11 86 18
	01 00 00	 movsd	 QWORD PTR [esi+280], xmm0
  005d9	c7 86 f8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+248], 0
  005e3	c7 46 54 00 00
	00 00		 mov	 DWORD PTR [esi+84], 0
  005ea	c7 46 5c 00 00
	00 00		 mov	 DWORD PTR [esi+92], 0
  005f1	c7 46 08 01 00
	00 00		 mov	 DWORD PTR [esi+8], 1
  005f8	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  005ff	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00606	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
  0060d	c7 86 e0 05 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+1504], 0
  00617	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
  0061e	c7 46 1c 00 00
	00 00		 mov	 DWORD PTR [esi+28], 0
  00625	c7 46 34 05 00
	00 00		 mov	 DWORD PTR [esi+52], 5
  0062c	c7 46 20 00 00
	00 00		 mov	 DWORD PTR [esi+32], 0
  00633	c7 46 24 00 00
	00 00		 mov	 DWORD PTR [esi+36], 0
  0063a	c7 46 28 00 00
	00 00		 mov	 DWORD PTR [esi+40], 0
  00641	c7 46 2c 00 00
	00 00		 mov	 DWORD PTR [esi+44], 0
  00648	c7 46 30 00 00
	00 00		 mov	 DWORD PTR [esi+48], 0
  0064f	c7 46 58 00 00
	00 00		 mov	 DWORD PTR [esi+88], 0
  00656	66 89 4e 40	 mov	 WORD PTR [esi+64], cx

; 97   : 
; 98   : 	m_nCountOfRQ = 0;

  0065a	c7 46 6c 00 00
	00 00		 mov	 DWORD PTR [esi+108], 0

; 99   : 
; 100  : 	m_minScaleInterval_nRQ = 0;

  00661	c7 86 ec 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+236], 0

; 101  : 	m_minScaleInterval_eType = CScaleBaseData::HORZ_DAILY;

  0066b	c7 86 f0 00 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+240], 1

; 102  : 	m_minScaleInterval_nUnit = 1;
; 103  : 
; 104  : 	m_maxScaleInterval_nRQ = 0;
; 105  : 	m_maxScaleInterval_eType = CScaleBaseData::HORZ_DAILY;
; 106  : 	m_maxScaleInterval_nUnit = 1;
; 107  : 
; 108  : 	// (2008/12/29 - Seung-Won, Bae) Do not use m_mifOEBT. Use m_pifaOEBT.
; 109  : 	//	m_mifOEBT.clear();
; 110  : 
; 111  : 	m_pblaRQTime = NULL;
; 112  : 	m_pblaDRIfDTI = NULL;
; 113  : 	m_pblaDTIfDRI = NULL;
; 114  : 	m_pifaRQ = NULL;
; 115  : 	m_pifaOEBT = NULL;
; 116  : 	m_pamapSpecialTime = NULL;
; 117  : 
; 118  : 	// 20080925 JS.Kim	   Scale 
; 119  : 	m_TimeDiffManager.SetXScaleManagerImp( this);

  00675	56		 push	 esi
  00676	8d 8b ec 05 00
	00		 lea	 ecx, DWORD PTR [ebx+1516]
  0067c	c7 86 f4 00 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+244], 1
  00686	c7 86 e0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+224], 0
  00690	c7 86 e4 00 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+228], 1
  0069a	c7 86 e8 00 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+232], 1
  006a4	c7 86 9c 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+156], 0
  006ae	c7 86 a0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+160], 0
  006b8	c7 86 a8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+168], 0
  006c2	c7 86 8c 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+140], 0
  006cc	c7 86 90 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+144], 0
  006d6	c7 86 a4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+164], 0
  006e0	e8 00 00 00 00	 call	 ?SetXScaleManagerImp@CXScaleTimeDiffManager@@QAEXPAVCXScaleManagerImp@@@Z ; CXScaleTimeDiffManager::SetXScaleManagerImp

; 120  : 	m_bTimeScale = false;

  006e5	c6 86 14 06 00
	00 00		 mov	 BYTE PTR [esi+1556], 0

; 121  : 
; 122  : 	m_nMinMaxRatio = 0;
; 123  : }

  006ec	8b c6		 mov	 eax, esi
  006ee	c7 86 78 0a 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+2680], 0
  006f8	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  006fb	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00702	59		 pop	 ecx
  00703	5f		 pop	 edi
  00704	5e		 pop	 esi
  00705	5b		 pop	 ebx
  00706	8b e5		 mov	 esp, ebp
  00708	5d		 pop	 ebp
  00709	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CXScaleManagerImp@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CXScaleManager@@UAE@XZ ; CXScaleManager::~CXScaleManager
__unwindfunclet$??0CXScaleManagerImp@@QAE@XZ$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 70	 add	 ecx, 112		; 00000070H
  0000e	e9 00 00 00 00	 jmp	 ??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE@XZ
__unwindfunclet$??0CXScaleManagerImp@@QAE@XZ$2:
  00013	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	83 c1 78	 add	 ecx, 120		; 00000078H
  00019	e9 00 00 00 00	 jmp	 ??1CStringArray@@UAE@XZ	; CStringArray::~CStringArray
__unwindfunclet$??0CXScaleManagerImp@@QAE@XZ$3:
  0001e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	81 c1 94 00 00
	00		 add	 ecx, 148		; 00000094H
  00027	e9 00 00 00 00	 jmp	 ??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUVERTBOX_INFO@CXScaleManagerImp@@@std@@@2@@std@@QAE@XZ
__unwindfunclet$??0CXScaleManagerImp@@QAE@XZ$4:
  0002c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	81 c1 ac 00 00
	00		 add	 ecx, 172		; 000000acH
  00035	e9 00 00 00 00	 jmp	 ??1?$CDataBlockList@_J$0CAA@@@UAE@XZ ; CDataBlockList<__int64,512>::~CDataBlockList<__int64,512>
__unwindfunclet$??0CXScaleManagerImp@@QAE@XZ$5:
  0003a	68 00 00 00 00	 push	 OFFSET ??1?$CDataBlockList@UtagAREA@CXScaleManager@@$0CAA@@@UAE@XZ ; CDataBlockList<CXScaleManager::tagAREA,512>::~CDataBlockList<CXScaleManager::tagAREA,512>
  0003f	6a 0a		 push	 10			; 0000000aH
  00041	6a 34		 push	 52			; 00000034H
  00043	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00046	05 88 03 00 00	 add	 eax, 904		; 00000388H
  0004b	50		 push	 eax
  0004c	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  00051	c3		 ret	 0
__unwindfunclet$??0CXScaleManagerImp@@QAE@XZ$6:
  00052	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00055	81 c1 ec 05 00
	00		 add	 ecx, 1516		; 000005ecH
  0005b	e9 00 00 00 00	 jmp	 ??1CXScaleTimeDiffManager@@UAE@XZ ; CXScaleTimeDiffManager::~CXScaleTimeDiffManager
__unwindfunclet$??0CXScaleManagerImp@@QAE@XZ$7:
  00060	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00063	81 c1 18 06 00
	00		 add	 ecx, 1560		; 00000618H
  00069	e9 00 00 00 00	 jmp	 ??1?$CTypedPtrMap@VCMapWordToPtr@@FPAVCXScaleGridTime@@@@UAE@XZ
__unwindfunclet$??0CXScaleManagerImp@@QAE@XZ$8:
  0006e	68 00 00 00 00	 push	 OFFSET ??1?$CDataBlockList@Utm@@$0CAA@@@UAE@XZ ; CDataBlockList<tm,512>::~CDataBlockList<tm,512>
  00073	6a 0a		 push	 10			; 0000000aH
  00075	6a 34		 push	 52			; 00000034H
  00077	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0007a	05 5c 06 00 00	 add	 eax, 1628		; 0000065cH
  0007f	50		 push	 eax
  00080	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  00085	c3		 ret	 0
__unwindfunclet$??0CXScaleManagerImp@@QAE@XZ$9:
  00086	68 00 00 00 00	 push	 OFFSET ??1?$CDataBlockList@H$0CAA@@@UAE@XZ ; CDataBlockList<int,512>::~CDataBlockList<int,512>
  0008b	6a 0a		 push	 10			; 0000000aH
  0008d	6a 34		 push	 52			; 00000034H
  0008f	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00092	05 64 08 00 00	 add	 eax, 2148		; 00000864H
  00097	50		 push	 eax
  00098	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  0009d	c3		 ret	 0
__unwindfunclet$??0CXScaleManagerImp@@QAE@XZ$10:
  0009e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000a1	81 c1 74 0a 00
	00		 add	 ecx, 2676		; 00000a74H
  000a7	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$??0CXScaleManagerImp@@QAE@XZ$11:
  000ad	68 00 00 00 00	 push	 OFFSET ??1?$CDataBlockList@Utm@@$0CAA@@@UAE@XZ ; CDataBlockList<tm,512>::~CDataBlockList<tm,512>
  000b2	6a 0a		 push	 10			; 0000000aH
  000b4	6a 34		 push	 52			; 00000034H
  000b6	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000b9	05 7c 0a 00 00	 add	 eax, 2684		; 00000a7cH
  000be	50		 push	 eax
  000bf	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  000c4	c3		 ret	 0
__unwindfunclet$??0CXScaleManagerImp@@QAE@XZ$12:
  000c5	68 00 00 00 00	 push	 OFFSET ??1?$CDataBlockList@H$0CAA@@@UAE@XZ ; CDataBlockList<int,512>::~CDataBlockList<int,512>
  000ca	6a 0a		 push	 10			; 0000000aH
  000cc	6a 34		 push	 52			; 00000034H
  000ce	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000d1	05 84 0c 00 00	 add	 eax, 3204		; 00000c84H
  000d6	50		 push	 eax
  000d7	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  000dc	c3		 ret	 0
  000dd	cc		 int	 3
  000de	cc		 int	 3
  000df	cc		 int	 3
  000e0	cc		 int	 3
  000e1	cc		 int	 3
__ehhandler$??0CXScaleManagerImp@@QAE@XZ:
  000e2	90		 npad	 1
  000e3	90		 npad	 1
  000e4	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  000e8	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  000eb	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  000ee	33 c8		 xor	 ecx, eax
  000f0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000f5	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CXScaleManagerImp@@QAE@XZ
  000fa	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CXScaleManagerImp@@QAE@XZ ENDP			; CXScaleManagerImp::CXScaleManagerImp
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
;	COMDAT ??_G?$CDataBlockList@H$0CAA@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CDataBlockList@H$0CAA@@@UAEPAXI@Z PROC		; CDataBlockList<int,512>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 163  : 	{

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CDataBlockList@H$0CAA@@@6B@

; 164  : 	}

  0000c	e8 00 00 00 00	 call	 ??1CDataBlockListUNK@@UAE@XZ ; CDataBlockListUNK::~CDataBlockListUNK
  00011	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00015	74 0b		 je	 SHORT $LN7@scalar
  00017	6a 34		 push	 52			; 00000034H
  00019	56		 push	 esi
  0001a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001f	83 c4 08	 add	 esp, 8
$LN7@scalar:
  00022	8b c6		 mov	 eax, esi
  00024	5e		 pop	 esi
  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
??_G?$CDataBlockList@H$0CAA@@@UAEPAXI@Z ENDP		; CDataBlockList<int,512>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
;	COMDAT ??1?$CDataBlockList@H$0CAA@@@UAE@XZ
_TEXT	SEGMENT
??1?$CDataBlockList@H$0CAA@@@UAE@XZ PROC		; CDataBlockList<int,512>::~CDataBlockList<int,512>, COMDAT
; _this$ = ecx

; 163  : 	{

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CDataBlockList@H$0CAA@@@6B@

; 164  : 	}

  00006	e9 00 00 00 00	 jmp	 ??1CDataBlockListUNK@@UAE@XZ ; CDataBlockListUNK::~CDataBlockListUNK
??1?$CDataBlockList@H$0CAA@@@UAE@XZ ENDP		; CDataBlockList<int,512>::~CDataBlockList<int,512>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
;	COMDAT ??0?$CDataBlockList@H$0CAA@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$CDataBlockList@H$0CAA@@@QAE@XZ PROC		; CDataBlockList<int,512>::CDataBlockList<int,512>, COMDAT
; _this$ = ecx

; 158  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00004	c7 41 28 00 00
	00 00		 mov	 DWORD PTR [ecx+40], 0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 159  : 	}

  0000b	8b c1		 mov	 eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  0000d	c7 41 2c 00 00
	00 00		 mov	 DWORD PTR [ecx+44], 0
  00014	c7 41 30 00 00
	00 00		 mov	 DWORD PTR [ecx+48], 0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 158  : 	{

  0001b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 24   : 		m_nItemSize = nItemSize;

  0001e	c7 41 04 04 00
	00 00		 mov	 DWORD PTR [ecx+4], 4

; 25   : 		m_nBlockSize = nBlockSize;

  00025	c7 41 08 00 02
	00 00		 mov	 DWORD PTR [ecx+8], 512	; 00000200H

; 26   : 
; 27   : 		m_nItemCount = 0;

  0002c	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 28   : 		m_nFirstBlockStartIndex = 0;

  00033	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 29   : 		m_nLastBlockEndIndex = 0;

  0003a	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 30   : 
; 31   : 		m_nIndex = 0;

  00041	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0

; 32   : 		m_nBlockIndex = 0;

  00048	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 33   : 		m_nIndexInBlock = 0;

  0004f	c7 41 24 00 00
	00 00		 mov	 DWORD PTR [ecx+36], 0

; 34   : 		m_lpBlockIndex = NULL;

  00056	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0

; 158  : 	{

  0005d	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CDataBlockList@H$0CAA@@@6B@

; 159  : 	}

  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c3		 ret	 0
??0?$CDataBlockList@H$0CAA@@@QAE@XZ ENDP		; CDataBlockList<int,512>::CDataBlockList<int,512>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
;	COMDAT ??_G?$CDataBlockList@Utm@@$0CAA@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CDataBlockList@Utm@@$0CAA@@@UAEPAXI@Z PROC	; CDataBlockList<tm,512>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 163  : 	{

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CDataBlockList@Utm@@$0CAA@@@6B@

; 164  : 	}

  0000c	e8 00 00 00 00	 call	 ??1CDataBlockListUNK@@UAE@XZ ; CDataBlockListUNK::~CDataBlockListUNK
  00011	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00015	74 0b		 je	 SHORT $LN7@scalar
  00017	6a 34		 push	 52			; 00000034H
  00019	56		 push	 esi
  0001a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001f	83 c4 08	 add	 esp, 8
$LN7@scalar:
  00022	8b c6		 mov	 eax, esi
  00024	5e		 pop	 esi
  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
??_G?$CDataBlockList@Utm@@$0CAA@@@UAEPAXI@Z ENDP	; CDataBlockList<tm,512>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
;	COMDAT ??1?$CDataBlockList@Utm@@$0CAA@@@UAE@XZ
_TEXT	SEGMENT
??1?$CDataBlockList@Utm@@$0CAA@@@UAE@XZ PROC		; CDataBlockList<tm,512>::~CDataBlockList<tm,512>, COMDAT
; _this$ = ecx

; 163  : 	{

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CDataBlockList@Utm@@$0CAA@@@6B@

; 164  : 	}

  00006	e9 00 00 00 00	 jmp	 ??1CDataBlockListUNK@@UAE@XZ ; CDataBlockListUNK::~CDataBlockListUNK
??1?$CDataBlockList@Utm@@$0CAA@@@UAE@XZ ENDP		; CDataBlockList<tm,512>::~CDataBlockList<tm,512>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
;	COMDAT ??0?$CDataBlockList@Utm@@$0CAA@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$CDataBlockList@Utm@@$0CAA@@@QAE@XZ PROC		; CDataBlockList<tm,512>::CDataBlockList<tm,512>, COMDAT
; _this$ = ecx

; 158  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00004	c7 41 28 00 00
	00 00		 mov	 DWORD PTR [ecx+40], 0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 159  : 	}

  0000b	8b c1		 mov	 eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  0000d	c7 41 2c 00 00
	00 00		 mov	 DWORD PTR [ecx+44], 0
  00014	c7 41 30 00 00
	00 00		 mov	 DWORD PTR [ecx+48], 0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 158  : 	{

  0001b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 24   : 		m_nItemSize = nItemSize;

  0001e	c7 41 04 24 00
	00 00		 mov	 DWORD PTR [ecx+4], 36	; 00000024H

; 25   : 		m_nBlockSize = nBlockSize;

  00025	c7 41 08 00 02
	00 00		 mov	 DWORD PTR [ecx+8], 512	; 00000200H

; 26   : 
; 27   : 		m_nItemCount = 0;

  0002c	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 28   : 		m_nFirstBlockStartIndex = 0;

  00033	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 29   : 		m_nLastBlockEndIndex = 0;

  0003a	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 30   : 
; 31   : 		m_nIndex = 0;

  00041	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0

; 32   : 		m_nBlockIndex = 0;

  00048	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 33   : 		m_nIndexInBlock = 0;

  0004f	c7 41 24 00 00
	00 00		 mov	 DWORD PTR [ecx+36], 0

; 34   : 		m_lpBlockIndex = NULL;

  00056	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0

; 158  : 	{

  0005d	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CDataBlockList@Utm@@$0CAA@@@6B@

; 159  : 	}

  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c3		 ret	 0
??0?$CDataBlockList@Utm@@$0CAA@@@QAE@XZ ENDP		; CDataBlockList<tm,512>::CDataBlockList<tm,512>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE@XZ PROC ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::~map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 752  :         _Erase_tree(_Al, _Myhead->_Parent);

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	ff 70 04	 push	 DWORD PTR [eax+4]
  00008	56		 push	 esi
  00009	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> > >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 255  :         ::operator delete(_Ptr, _Bytes);

  0000e	6a 2c		 push	 44			; 0000002cH
  00010	ff 36		 push	 DWORD PTR [esi]
  00012	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00017	83 c4 08	 add	 esp, 8
  0001a	5e		 pop	 esi
  0001b	c3		 ret	 0
??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE@XZ ENDP ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::~map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@2@QAU32@@Z
_TEXT	SEGMENT
__Head$1$ = -8						; size = 4
_this$1$ = -4						; size = 4
__Loc$ = 8						; size = 8
__Newnode$ = 16						; size = 4
?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@2@QAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Insert_node, COMDAT
; _this$ = ecx

; 644  :     _Nodeptr _Insert_node(const _Tree_id<_Nodeptr> _Loc, const _Nodeptr _Newnode) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 645  :         ++_Mysize;
; 646  :         const auto _Head  = _Myhead;
; 647  :         _Newnode->_Parent = _Loc._Parent;

  00006	8b 55 08	 mov	 edx, DWORD PTR __Loc$[ebp]
  00009	8b c1		 mov	 eax, ecx
  0000b	89 45 fc	 mov	 DWORD PTR _this$1$[ebp], eax
  0000e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00010	ff 40 04	 inc	 DWORD PTR [eax+4]
  00013	8b 45 10	 mov	 eax, DWORD PTR __Newnode$[ebp]
  00016	89 4d f8	 mov	 DWORD PTR __Head$1$[ebp], ecx
  00019	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 648  :         if (_Loc._Parent == _Head) { // first node in tree, just set head values

  0001c	3b d1		 cmp	 edx, ecx
  0001e	75 12		 jne	 SHORT $LN5@Insert_nod

; 649  :             _Head->_Left     = _Newnode;

  00020	89 01		 mov	 DWORD PTR [ecx], eax

; 650  :             _Head->_Parent   = _Newnode;

  00022	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 651  :             _Head->_Right    = _Newnode;

  00025	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 652  :             _Newnode->_Color = _Black; // the root is black

  00028	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 711  :     }

  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c2 0c 00	 ret	 12			; 0000000cH
$LN5@Insert_nod:

; 653  :             return _Newnode;
; 654  :         }
; 655  : 
; 656  :         _STL_INTERNAL_CHECK(_Loc._Child != _Tree_child::_Unused);
; 657  :         if (_Loc._Child == _Tree_child::_Right) { // add to right of _Loc._Parent

  00032	83 7d 0c 00	 cmp	 DWORD PTR __Loc$[ebp+4], 0
  00036	75 0d		 jne	 SHORT $LN6@Insert_nod

; 658  :             _STL_INTERNAL_CHECK(_Loc._Parent->_Right->_Isnil);
; 659  :             _Loc._Parent->_Right = _Newnode;

  00038	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 660  :             if (_Loc._Parent == _Head->_Right) { // remember rightmost node

  0003b	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  0003e	75 0d		 jne	 SHORT $LN9@Insert_nod

; 661  :                 _Head->_Right = _Newnode;

  00040	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 662  :             }
; 663  :         } else { // add to left of _Loc._Parent

  00043	eb 08		 jmp	 SHORT $LN9@Insert_nod
$LN6@Insert_nod:

; 664  :             _STL_INTERNAL_CHECK(_Loc._Parent->_Left->_Isnil);
; 665  :             _Loc._Parent->_Left = _Newnode;

  00045	89 02		 mov	 DWORD PTR [edx], eax

; 666  :             if (_Loc._Parent == _Head->_Left) { // remember leftmost node

  00047	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00049	75 02		 jne	 SHORT $LN9@Insert_nod

; 667  :                 _Head->_Left = _Newnode;

  0004b	89 01		 mov	 DWORD PTR [ecx], eax
$LN9@Insert_nod:

; 668  :             }
; 669  :         }
; 670  : 
; 671  :         for (_Nodeptr _Pnode = _Newnode; _Pnode->_Parent->_Color == _Red;) {

  0004d	8b d0		 mov	 edx, eax
  0004f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00052	80 78 0c 00	 cmp	 BYTE PTR [eax+12], 0
  00056	0f 85 99 01 00
	00		 jne	 $LN3@Insert_nod
  0005c	53		 push	 ebx
  0005d	56		 push	 esi
  0005e	57		 push	 edi
  0005f	90		 npad	 1
$LL2@Insert_nod:

; 672  :             if (_Pnode->_Parent == _Pnode->_Parent->_Parent->_Left) { // fixup red-red in left subtree

  00060	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00063	8d 7a 04	 lea	 edi, DWORD PTR [edx+4]
  00066	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00069	8d 59 04	 lea	 ebx, DWORD PTR [ecx+4]
  0006c	8b 06		 mov	 eax, DWORD PTR [esi]
  0006e	3b c8		 cmp	 ecx, eax
  00070	0f 85 ba 00 00
	00		 jne	 $LN10@Insert_nod

; 673  :                 const auto _Parent_sibling = _Pnode->_Parent->_Parent->_Right;

  00076	8b 46 08	 mov	 eax, DWORD PTR [esi+8]

; 674  :                 if (_Parent_sibling->_Color == _Red) { // parent's sibling has two red children, blacken both

  00079	80 78 0c 00	 cmp	 BYTE PTR [eax+12], 0
  0007d	0f 84 b3 00 00
	00		 je	 $LN53@Insert_nod

; 675  :                     _Pnode->_Parent->_Color          = _Black;
; 676  :                     _Parent_sibling->_Color          = _Black;
; 677  :                     _Pnode->_Parent->_Parent->_Color = _Red;
; 678  :                     _Pnode                           = _Pnode->_Parent->_Parent;
; 679  :                 } else { // parent's sibling has red and black children
; 680  :                     if (_Pnode == _Pnode->_Parent->_Right) { // rotate right child to left

  00083	8b 71 08	 mov	 esi, DWORD PTR [ecx+8]
  00086	3b d6		 cmp	 edx, esi
  00088	75 47		 jne	 SHORT $LN51@Insert_nod

; 460  :         _Wherenode->_Right = _Pnode->_Left;

  0008a	8b 06		 mov	 eax, DWORD PTR [esi]

; 681  :                         _Pnode = _Pnode->_Parent;

  0008c	8b d1		 mov	 edx, ecx

; 460  :         _Wherenode->_Right = _Pnode->_Left;

  0008e	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 461  : 
; 462  :         if (!_Pnode->_Left->_Isnil) {

  00091	8b 06		 mov	 eax, DWORD PTR [esi]
  00093	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00097	75 03		 jne	 SHORT $LN20@Insert_nod

; 463  :             _Pnode->_Left->_Parent = _Wherenode;

  00099	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN20@Insert_nod:

; 464  :         }
; 465  : 
; 466  :         _Pnode->_Parent = _Wherenode->_Parent;

  0009c	8b 03		 mov	 eax, DWORD PTR [ebx]
  0009e	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 467  : 
; 468  :         if (_Wherenode == _Myhead->_Parent) {

  000a1	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]
  000a4	8b 00		 mov	 eax, DWORD PTR [eax]
  000a6	3b 50 04	 cmp	 edx, DWORD PTR [eax+4]
  000a9	75 0b		 jne	 SHORT $LN21@Insert_nod

; 469  :             _Myhead->_Parent = _Pnode;

  000ab	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 477  :         _Wherenode->_Parent = _Pnode;

  000ae	8b fb		 mov	 edi, ebx
  000b0	89 16		 mov	 DWORD PTR [esi], edx
  000b2	89 33		 mov	 DWORD PTR [ebx], esi
  000b4	eb 1d		 jmp	 SHORT $LN49@Insert_nod
$LN21@Insert_nod:

; 470  :         } else if (_Wherenode == _Wherenode->_Parent->_Left) {

  000b6	8b 03		 mov	 eax, DWORD PTR [ebx]
  000b8	3b 10		 cmp	 edx, DWORD PTR [eax]
  000ba	75 0a		 jne	 SHORT $LN23@Insert_nod

; 471  :             _Wherenode->_Parent->_Left = _Pnode;

  000bc	89 30		 mov	 DWORD PTR [eax], esi

; 477  :         _Wherenode->_Parent = _Pnode;

  000be	8b fb		 mov	 edi, ebx
  000c0	89 16		 mov	 DWORD PTR [esi], edx
  000c2	89 33		 mov	 DWORD PTR [ebx], esi
  000c4	eb 0d		 jmp	 SHORT $LN49@Insert_nod
$LN23@Insert_nod:

; 473  :             _Wherenode->_Parent->_Right = _Pnode;

  000c6	89 70 08	 mov	 DWORD PTR [eax+8], esi

; 477  :         _Wherenode->_Parent = _Pnode;

  000c9	8b fb		 mov	 edi, ebx
  000cb	89 16		 mov	 DWORD PTR [esi], edx
  000cd	89 33		 mov	 DWORD PTR [ebx], esi
  000cf	eb 02		 jmp	 SHORT $LN49@Insert_nod
$LN51@Insert_nod:
  000d1	8b f1		 mov	 esi, ecx
$LN49@Insert_nod:

; 682  :                         _Lrotate(_Pnode);
; 683  :                     }
; 684  : 
; 685  :                     _Pnode->_Parent->_Color          = _Black; // propagate red up

  000d3	c6 46 0c 01	 mov	 BYTE PTR [esi+12], 1

; 686  :                     _Pnode->_Parent->_Parent->_Color = _Red;

  000d7	8b 07		 mov	 eax, DWORD PTR [edi]
  000d9	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000dc	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 687  :                     _Rrotate(_Pnode->_Parent->_Parent);

  000e0	8b 07		 mov	 eax, DWORD PTR [edi]
  000e2	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 481  :         _Nodeptr _Pnode   = _Wherenode->_Left;

  000e5	8b 31		 mov	 esi, DWORD PTR [ecx]

; 482  :         _Wherenode->_Left = _Pnode->_Right;

  000e7	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000ea	89 01		 mov	 DWORD PTR [ecx], eax

; 483  : 
; 484  :         if (!_Pnode->_Right->_Isnil) {

  000ec	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000ef	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  000f3	75 03		 jne	 SHORT $LN27@Insert_nod

; 485  :             _Pnode->_Right->_Parent = _Wherenode;

  000f5	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN27@Insert_nod:

; 486  :         }
; 487  : 
; 488  :         _Pnode->_Parent = _Wherenode->_Parent;

  000f8	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  000fb	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 489  : 
; 490  :         if (_Wherenode == _Myhead->_Parent) {

  000fe	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]
  00101	8b 00		 mov	 eax, DWORD PTR [eax]
  00103	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00106	75 0b		 jne	 SHORT $LN28@Insert_nod

; 491  :             _Myhead->_Parent = _Pnode;

  00108	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 496  :         }
; 497  : 
; 498  :         _Pnode->_Right      = _Wherenode;

  0010b	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 688  :                 }
; 689  :             } else { // fixup red-red in right subtree

  0010e	e9 cc 00 00 00	 jmp	 $LN52@Insert_nod
$LN28@Insert_nod:

; 492  :         } else if (_Wherenode == _Wherenode->_Parent->_Right) {

  00113	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00116	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00119	75 0b		 jne	 SHORT $LN30@Insert_nod

; 493  :             _Wherenode->_Parent->_Right = _Pnode;

  0011b	89 70 08	 mov	 DWORD PTR [eax+8], esi

; 496  :         }
; 497  : 
; 498  :         _Pnode->_Right      = _Wherenode;

  0011e	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 688  :                 }
; 689  :             } else { // fixup red-red in right subtree

  00121	e9 b9 00 00 00	 jmp	 $LN52@Insert_nod
$LN30@Insert_nod:

; 495  :             _Wherenode->_Parent->_Left = _Pnode;

  00126	89 30		 mov	 DWORD PTR [eax], esi

; 496  :         }
; 497  : 
; 498  :         _Pnode->_Right      = _Wherenode;

  00128	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 688  :                 }
; 689  :             } else { // fixup red-red in right subtree

  0012b	e9 af 00 00 00	 jmp	 $LN52@Insert_nod
$LN10@Insert_nod:

; 690  :                 const auto _Parent_sibling = _Pnode->_Parent->_Parent->_Left;
; 691  :                 if (_Parent_sibling->_Color == _Red) { // parent's sibling has two red children, blacken both

  00130	80 78 0c 00	 cmp	 BYTE PTR [eax+12], 0
  00134	75 1b		 jne	 SHORT $LN15@Insert_nod
$LN53@Insert_nod:

; 668  :             }
; 669  :         }
; 670  : 
; 671  :         for (_Nodeptr _Pnode = _Newnode; _Pnode->_Parent->_Color == _Red;) {

  00136	c6 41 0c 01	 mov	 BYTE PTR [ecx+12], 1
  0013a	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1
  0013e	8b 07		 mov	 eax, DWORD PTR [edi]
  00140	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00143	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0
  00147	8b 07		 mov	 eax, DWORD PTR [edi]
  00149	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0014c	e9 91 00 00 00	 jmp	 $LN46@Insert_nod
$LN15@Insert_nod:

; 692  :                     _Pnode->_Parent->_Color          = _Black;
; 693  :                     _Parent_sibling->_Color          = _Black;
; 694  :                     _Pnode->_Parent->_Parent->_Color = _Red;
; 695  :                     _Pnode                           = _Pnode->_Parent->_Parent;
; 696  :                 } else { // parent's sibling has red and black children
; 697  :                     if (_Pnode == _Pnode->_Parent->_Left) { // rotate left child to right

  00151	8b 01		 mov	 eax, DWORD PTR [ecx]
  00153	3b d0		 cmp	 edx, eax
  00155	75 3e		 jne	 SHORT $LN39@Insert_nod

; 698  :                         _Pnode = _Pnode->_Parent;

  00157	8b d1		 mov	 edx, ecx

; 481  :         _Nodeptr _Pnode   = _Wherenode->_Left;

  00159	8b c8		 mov	 ecx, eax

; 482  :         _Wherenode->_Left = _Pnode->_Right;

  0015b	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0015e	89 02		 mov	 DWORD PTR [edx], eax

; 483  : 
; 484  :         if (!_Pnode->_Right->_Isnil) {

  00160	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00163	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00167	75 03		 jne	 SHORT $LN34@Insert_nod

; 485  :             _Pnode->_Right->_Parent = _Wherenode;

  00169	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN34@Insert_nod:

; 486  :         }
; 487  : 
; 488  :         _Pnode->_Parent = _Wherenode->_Parent;

  0016c	8b 03		 mov	 eax, DWORD PTR [ebx]
  0016e	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 489  : 
; 490  :         if (_Wherenode == _Myhead->_Parent) {

  00171	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]
  00174	8b 00		 mov	 eax, DWORD PTR [eax]
  00176	3b 50 04	 cmp	 edx, DWORD PTR [eax+4]
  00179	75 05		 jne	 SHORT $LN35@Insert_nod

; 491  :             _Myhead->_Parent = _Pnode;

  0017b	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0017e	eb 0e		 jmp	 SHORT $LN38@Insert_nod
$LN35@Insert_nod:

; 492  :         } else if (_Wherenode == _Wherenode->_Parent->_Right) {

  00180	8b 03		 mov	 eax, DWORD PTR [ebx]
  00182	3b 50 08	 cmp	 edx, DWORD PTR [eax+8]
  00185	75 05		 jne	 SHORT $LN37@Insert_nod

; 493  :             _Wherenode->_Parent->_Right = _Pnode;

  00187	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 494  :         } else {

  0018a	eb 02		 jmp	 SHORT $LN38@Insert_nod
$LN37@Insert_nod:

; 495  :             _Wherenode->_Parent->_Left = _Pnode;

  0018c	89 08		 mov	 DWORD PTR [eax], ecx
$LN38@Insert_nod:

; 496  :         }
; 497  : 
; 498  :         _Pnode->_Right      = _Wherenode;

  0018e	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 499  :         _Wherenode->_Parent = _Pnode;

  00191	8b fb		 mov	 edi, ebx
  00193	89 0b		 mov	 DWORD PTR [ebx], ecx
$LN39@Insert_nod:

; 699  :                         _Rrotate(_Pnode);
; 700  :                     }
; 701  : 
; 702  :                     _Pnode->_Parent->_Color          = _Black; // propagate red up

  00195	c6 41 0c 01	 mov	 BYTE PTR [ecx+12], 1

; 703  :                     _Pnode->_Parent->_Parent->_Color = _Red;

  00199	8b 07		 mov	 eax, DWORD PTR [edi]
  0019b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0019e	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 704  :                     _Lrotate(_Pnode->_Parent->_Parent);

  001a2	8b 07		 mov	 eax, DWORD PTR [edi]
  001a4	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 459  :         _Nodeptr _Pnode    = _Wherenode->_Right;

  001a7	8b 71 08	 mov	 esi, DWORD PTR [ecx+8]

; 460  :         _Wherenode->_Right = _Pnode->_Left;

  001aa	8b 06		 mov	 eax, DWORD PTR [esi]
  001ac	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 461  : 
; 462  :         if (!_Pnode->_Left->_Isnil) {

  001af	8b 06		 mov	 eax, DWORD PTR [esi]
  001b1	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  001b5	75 03		 jne	 SHORT $LN41@Insert_nod

; 463  :             _Pnode->_Left->_Parent = _Wherenode;

  001b7	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN41@Insert_nod:

; 464  :         }
; 465  : 
; 466  :         _Pnode->_Parent = _Wherenode->_Parent;

  001ba	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  001bd	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 467  : 
; 468  :         if (_Wherenode == _Myhead->_Parent) {

  001c0	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]
  001c3	8b 00		 mov	 eax, DWORD PTR [eax]
  001c5	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  001c8	75 05		 jne	 SHORT $LN42@Insert_nod

; 469  :             _Myhead->_Parent = _Pnode;

  001ca	89 70 04	 mov	 DWORD PTR [eax+4], esi
  001cd	eb 0e		 jmp	 SHORT $LN45@Insert_nod
$LN42@Insert_nod:

; 470  :         } else if (_Wherenode == _Wherenode->_Parent->_Left) {

  001cf	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  001d2	3b 08		 cmp	 ecx, DWORD PTR [eax]
  001d4	75 04		 jne	 SHORT $LN44@Insert_nod

; 471  :             _Wherenode->_Parent->_Left = _Pnode;

  001d6	89 30		 mov	 DWORD PTR [eax], esi

; 472  :         } else {

  001d8	eb 03		 jmp	 SHORT $LN45@Insert_nod
$LN44@Insert_nod:

; 473  :             _Wherenode->_Parent->_Right = _Pnode;

  001da	89 70 08	 mov	 DWORD PTR [eax+8], esi
$LN45@Insert_nod:

; 474  :         }
; 475  : 
; 476  :         _Pnode->_Left       = _Wherenode;

  001dd	89 0e		 mov	 DWORD PTR [esi], ecx
$LN52@Insert_nod:

; 668  :             }
; 669  :         }
; 670  : 
; 671  :         for (_Nodeptr _Pnode = _Newnode; _Pnode->_Parent->_Color == _Red;) {

  001df	89 71 04	 mov	 DWORD PTR [ecx+4], esi
$LN46@Insert_nod:
  001e2	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  001e5	80 78 0c 00	 cmp	 BYTE PTR [eax+12], 0
  001e9	0f 84 71 fe ff
	ff		 je	 $LL2@Insert_nod
  001ef	8b 4d f8	 mov	 ecx, DWORD PTR __Head$1$[ebp]
  001f2	5f		 pop	 edi
  001f3	5e		 pop	 esi
  001f4	5b		 pop	 ebx
$LN3@Insert_nod:

; 705  :                 }
; 706  :             }
; 707  :         }
; 708  : 
; 709  :         _Head->_Parent->_Color = _Black; // root is always black

  001f5	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  001f8	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 710  :         return _Newnode;

  001fc	8b 45 10	 mov	 eax, DWORD PTR __Newnode$[ebp]

; 711  :     }

  001ff	8b e5		 mov	 esp, ebp
  00201	5d		 pop	 ebp
  00202	c2 0c 00	 ret	 12			; 0000000cH
?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@2@QAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Insert_node
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??R?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??R?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0@Z PROC ; std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator(), COMDAT
; _this$ = ecx

; 116  :     _NODISCARD constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2272 :         const value_type* _Result = _Bx._Buf;

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	8b c8		 mov	 ecx, eax

; 2286 :         return _BUF_SIZE <= _Myres;

  00008	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 2273 :         if (_Large_string_engaged()) {

  0000c	72 02		 jb	 SHORT $LN8@operator

; 2274 :             _Result = _Unfancy(_Bx._Ptr);

  0000e	8b 08		 mov	 ecx, DWORD PTR [eax]
$LN8@operator:
  00010	53		 push	 ebx
  00011	56		 push	 esi

; 2272 :         const value_type* _Result = _Bx._Buf;

  00012	8b 75 08	 mov	 esi, DWORD PTR __Left$[ebp]
  00015	8b d6		 mov	 edx, esi
  00017	57		 push	 edi

; 2286 :         return _BUF_SIZE <= _Myres;

  00018	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 2273 :         if (_Large_string_engaged()) {

  0001c	72 02		 jb	 SHORT $LN13@operator

; 2274 :             _Result = _Unfancy(_Bx._Ptr);

  0001e	8b 16		 mov	 edx, DWORD PTR [esi]
$LN13@operator:

; 4380 :         return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

  00020	8b 5e 10	 mov	 ebx, DWORD PTR [esi+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 66   :     return _Right < _Left ? _Right : _Left;

  00023	8b f3		 mov	 esi, ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4380 :         return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

  00025	8b 78 10	 mov	 edi, DWORD PTR [eax+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 66   :     return _Right < _Left ? _Right : _Left;

  00028	3b fb		 cmp	 edi, ebx
  0002a	0f 42 f7	 cmovb	 esi, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 384  :         return _CSTD memcmp(_First1, _First2, _Count);

  0002d	83 ee 04	 sub	 esi, 4
  00030	72 11		 jb	 SHORT $LN28@operator
$LL29@operator:
  00032	8b 02		 mov	 eax, DWORD PTR [edx]
  00034	3b 01		 cmp	 eax, DWORD PTR [ecx]
  00036	75 10		 jne	 SHORT $LN27@operator
  00038	83 c2 04	 add	 edx, 4
  0003b	83 c1 04	 add	 ecx, 4
  0003e	83 ee 04	 sub	 esi, 4
  00041	73 ef		 jae	 SHORT $LL29@operator
$LN28@operator:
  00043	83 fe fc	 cmp	 esi, -4			; fffffffcH
  00046	74 34		 je	 SHORT $LN26@operator
$LN27@operator:
  00048	8a 02		 mov	 al, BYTE PTR [edx]
  0004a	3a 01		 cmp	 al, BYTE PTR [ecx]
  0004c	75 27		 jne	 SHORT $LN30@operator
  0004e	83 fe fd	 cmp	 esi, -3			; fffffffdH
  00051	74 29		 je	 SHORT $LN26@operator
  00053	8a 42 01	 mov	 al, BYTE PTR [edx+1]
  00056	3a 41 01	 cmp	 al, BYTE PTR [ecx+1]
  00059	75 1a		 jne	 SHORT $LN30@operator
  0005b	83 fe fe	 cmp	 esi, -2			; fffffffeH
  0005e	74 1c		 je	 SHORT $LN26@operator
  00060	8a 42 02	 mov	 al, BYTE PTR [edx+2]
  00063	3a 41 02	 cmp	 al, BYTE PTR [ecx+2]
  00066	75 0d		 jne	 SHORT $LN30@operator
  00068	83 fe ff	 cmp	 esi, -1
  0006b	74 0f		 je	 SHORT $LN26@operator
  0006d	8a 42 03	 mov	 al, BYTE PTR [edx+3]
  00070	3a 41 03	 cmp	 al, BYTE PTR [ecx+3]
  00073	74 07		 je	 SHORT $LN26@operator
$LN30@operator:
  00075	1b c0		 sbb	 eax, eax
  00077	83 c8 01	 or	 eax, 1
  0007a	eb 02		 jmp	 SHORT $LN31@operator
$LN26@operator:
  0007c	33 c0		 xor	 eax, eax
$LN31@operator:

; 580  :     if (_Ans != 0) {

  0007e	85 c0		 test	 eax, eax
  00080	75 15		 jne	 SHORT $LN20@operator

; 581  :         return _Ans;
; 582  :     }
; 583  : 
; 584  :     if (_Left_size < _Right_size) {

  00082	3b fb		 cmp	 edi, ebx
  00084	76 0d		 jbe	 SHORT $LN32@operator
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 117  :         return _Left < _Right;

  00086	5f		 pop	 edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 585  :         return -1;

  00087	83 c8 ff	 or	 eax, -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 117  :         return _Left < _Right;

  0008a	5e		 pop	 esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4809 :     return _Left.compare(_Right) < 0;

  0008b	c1 e8 1f	 shr	 eax, 31			; 0000001fH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 117  :         return _Left < _Right;

  0008e	5b		 pop	 ebx

; 118  :     }

  0008f	5d		 pop	 ebp
  00090	c2 08 00	 ret	 8
$LN32@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 588  :     if (_Left_size > _Right_size) {

  00093	1b c0		 sbb	 eax, eax
  00095	f7 d8		 neg	 eax
$LN20@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 117  :         return _Left < _Right;

  00097	5f		 pop	 edi
  00098	5e		 pop	 esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4809 :     return _Left.compare(_Right) < 0;

  00099	c1 e8 1f	 shr	 eax, 31			; 0000001fH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 117  :         return _Left < _Right;

  0009c	5b		 pop	 ebx

; 118  :     }

  0009d	5d		 pop	 ebp
  0009e	c2 08 00	 ret	 8
??R?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0@Z ENDP ; std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GCXScaleManager@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCXScaleManager@@UAEPAXI@Z PROC			; CXScaleManager::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CXScaleManager@@6B@
  00010	74 0b		 je	 SHORT $LN4@scalar
  00012	6a 08		 push	 8
  00014	56		 push	 esi
  00015	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001a	83 c4 08	 add	 esp, 8
$LN4@scalar:
  0001d	8b c6		 mov	 eax, esi
  0001f	5e		 pop	 esi
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??_GCXScaleManager@@UAEPAXI@Z ENDP			; CXScaleManager::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\Dll_Load\XScaleManager.h
;	COMDAT ??1CXScaleManager@@UAE@XZ
_TEXT	SEGMENT
??1CXScaleManager@@UAE@XZ PROC				; CXScaleManager::~CXScaleManager, COMDAT
; _this$ = ecx

; 104  : 	virtual ~CXScaleManager(void) {};

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CXScaleManager@@6B@
  00006	c3		 ret	 0
??1CXScaleManager@@UAE@XZ ENDP				; CXScaleManager::~CXScaleManager
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
;	COMDAT ??_GCMapTimeToLong@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCMapTimeToLong@@UAEPAXI@Z PROC			; CMapTimeToLong::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CMapPtrToPtr@@UAE@XZ	; CMapPtrToPtr::~CMapPtrToPtr
  0000b	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  0000e	a8 01		 test	 al, 1
  00010	74 1f		 je	 SHORT $LN12@scalar
  00012	a8 04		 test	 al, 4
  00014	75 10		 jne	 SHORT $LN3@scalar

; 112  : 	{ ::operator delete(p); }

  00016	56		 push	 esi
  00017	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001c	83 c4 04	 add	 esp, 4
  0001f	8b c6		 mov	 eax, esi
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
$LN3@scalar:
  00026	6a 1c		 push	 28			; 0000001cH
  00028	56		 push	 esi
  00029	e8 00 00 00 00	 call	 ?__global_delete@@YAXPAXI@Z ; __global_delete
  0002e	83 c4 08	 add	 esp, 8
$LN12@scalar:
  00031	8b c6		 mov	 eax, esi
  00033	5e		 pop	 esi
  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
??_GCMapTimeToLong@@UAEPAXI@Z ENDP			; CMapTimeToLong::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GCDataBlockListUNK@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCDataBlockListUNK@@UAEPAXI@Z PROC			; CDataBlockListUNK::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CDataBlockListUNK@@UAE@XZ ; CDataBlockListUNK::~CDataBlockListUNK
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0b		 je	 SHORT $LN4@scalar
  00011	6a 34		 push	 52			; 00000034H
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00019	83 c4 08	 add	 esp, 8
$LN4@scalar:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??_GCDataBlockListUNK@@UAEPAXI@Z ENDP			; CDataBlockListUNK::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h
;	COMDAT ?PushBackUNK@CDataBlockListUNK@@QAEXPAX@Z
_TEXT	SEGMENT
_lpLastBlock$ = -4					; size = 4
_Item$ = 8						; size = 4
?PushBackUNK@CDataBlockListUNK@@QAEXPAX@Z PROC		; CDataBlockListUNK::PushBackUNK, COMDAT
; _this$ = ecx

; 86   : 				{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx

; 87   : 					if( m_nBlockSize < m_nLastBlockEndIndex) return;

  00007	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0000a	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0000d	3b c8		 cmp	 ecx, eax
  0000f	7c 74		 jl	 SHORT $LN1@PushBackUN

; 88   : 
; 89   : 					LPVOID lpLastBlock = NULL;
; 90   : 					if(m_nItemCount == 0 || m_nLastBlockEndIndex == m_nBlockSize)

  00011	83 7e 0c 00	 cmp	 DWORD PTR [esi+12], 0
  00015	57		 push	 edi
  00016	74 0c		 je	 SHORT $LN5@PushBackUN
  00018	3b c1		 cmp	 eax, ecx
  0001a	74 08		 je	 SHORT $LN5@PushBackUN

; 96   : 					}
; 97   : 					else lpLastBlock =  m_vtBlockPointer.back();

  0001c	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  0001f	8b 78 fc	 mov	 edi, DWORD PTR [eax-4]
  00022	eb 39		 jmp	 SHORT $LN10@PushBackUN
$LN5@PushBackUN:

; 94   : 						lpLastBlock = malloc(m_nBlockSize * m_nItemSize);

  00024	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00027	0f af c1	 imul	 eax, ecx
  0002a	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
  00031	50		 push	 eax
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc

; 95   : 						m_vtBlockPointer.push_back(lpLastBlock);

  00038	8d 4e 28	 lea	 ecx, DWORD PTR [esi+40]
  0003b	8b f8		 mov	 edi, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

  0003d	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 94   : 						lpLastBlock = malloc(m_nBlockSize * m_nItemSize);

  00040	83 c4 04	 add	 esp, 4
  00043	89 7d fc	 mov	 DWORD PTR _lpLastBlock$[ebp], edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

  00046	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  00049	74 08		 je	 SHORT $LN11@PushBackUN

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  0004b	89 38		 mov	 DWORD PTR [eax], edi

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

  0004d	83 41 04 04	 add	 DWORD PTR [ecx+4], 4

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  00051	eb 0a		 jmp	 SHORT $LN10@PushBackUN
$LN11@PushBackUN:

; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  00053	8d 55 fc	 lea	 edx, DWORD PTR _lpLastBlock$[ebp]
  00056	52		 push	 edx
  00057	50		 push	 eax
  00058	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABQAX@?$vector@PAXV?$allocator@PAX@std@@@std@@QAEPAPAXQAPAXABQAX@Z ; std::vector<void *,std::allocator<void *> >::_Emplace_reallocate<void * const &>
$LN10@PushBackUN:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\DataBlockList.h

; 99   : 					if( Item && lpLastBlock) 

  0005d	8b 45 08	 mov	 eax, DWORD PTR _Item$[ebp]
  00060	85 c0		 test	 eax, eax
  00062	74 1a		 je	 SHORT $LN6@PushBackUN
  00064	85 ff		 test	 edi, edi
  00066	74 16		 je	 SHORT $LN6@PushBackUN

; 100  : 						memcpy( ( ( PBYTE)lpLastBlock + ( m_nLastBlockEndIndex * m_nItemSize)), Item, m_nItemSize);

  00068	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0006b	51		 push	 ecx
  0006c	50		 push	 eax
  0006d	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00070	0f af c1	 imul	 eax, ecx
  00073	03 c7		 add	 eax, edi
  00075	50		 push	 eax
  00076	e8 00 00 00 00	 call	 _memcpy
  0007b	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN6@PushBackUN:

; 101  : 
; 102  : 					m_nLastBlockEndIndex++;

  0007e	ff 46 14	 inc	 DWORD PTR [esi+20]

; 103  : 					m_nItemCount++;

  00081	ff 46 0c	 inc	 DWORD PTR [esi+12]
  00084	5f		 pop	 edi
$LN1@PushBackUN:
  00085	5e		 pop	 esi

; 104  : 				}

  00086	8b e5		 mov	 esp, ebp
  00088	5d		 pop	 ebp
  00089	c2 04 00	 ret	 4
?PushBackUNK@CDataBlockListUNK@@QAEXPAX@Z ENDP		; CDataBlockListUNK::PushBackUNK
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xlength@?$vector@PAXV?$allocator@PAX@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PAXV?$allocator@PAX@std@@@std@@CAXXZ PROC ; std::vector<void *,std::allocator<void *> >::_Xlength, COMDAT

; 1761 :         _Xlength_error("vector too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlength:
  0000a	cc		 int	 3
?_Xlength@?$vector@PAXV?$allocator@PAX@std@@@std@@CAXXZ ENDP ; std::vector<void *,std::allocator<void *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
__Old$1$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__New_ptr$1$ = 12					; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 3210 :         _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	8b f1		 mov	 esi, ecx
  00008	57		 push	 edi

; 3211 :         // assign [_Ptr, _Ptr + _Count)
; 3212 :         if (_Count <= _Mypair._Myval2._Myres) {

  00009	8b 7d 0c	 mov	 edi, DWORD PTR __Count$[ebp]
  0000c	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  0000f	89 4d fc	 mov	 DWORD PTR __Old$1$[ebp], ecx
  00012	3b f9		 cmp	 edi, ecx
  00014	77 28		 ja	 SHORT $LN2@assign

; 2263 :         value_type* _Result = _Bx._Buf;

  00016	8b de		 mov	 ebx, esi

; 2286 :         return _BUF_SIZE <= _Myres;

  00018	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 2264 :         if (_Large_string_engaged()) {

  0001b	72 02		 jb	 SHORT $LN5@assign

; 2265 :             _Result = _Unfancy(_Bx._Ptr);

  0001d	8b 1e		 mov	 ebx, DWORD PTR [esi]
$LN5@assign:

; 121  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  0001f	57		 push	 edi
  00020	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]

; 3213 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
; 3214 :             _Mypair._Myval2._Mysize = _Count;

  00023	89 7e 10	 mov	 DWORD PTR [esi+16], edi

; 121  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00026	53		 push	 ebx
  00027	e8 00 00 00 00	 call	 _memmove
  0002c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3215 :             _Traits::move(_Old_ptr, _Ptr, _Count);
; 3216 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  0002f	c6 04 3b 00	 mov	 BYTE PTR [ebx+edi], 0

; 3225 :             },
; 3226 :             _Ptr);
; 3227 :     }

  00033	8b c6		 mov	 eax, esi
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c2 08 00	 ret	 8
$LN2@assign:

; 4474 :         if (_New_size > max_size()) {

  0003e	81 ff ff ff ff
	7f		 cmp	 edi, 2147483647		; 7fffffffH
  00044	0f 87 9e 00 00
	00		 ja	 $LN50@assign

; 4454 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  0004a	8b df		 mov	 ebx, edi
  0004c	83 cb 0f	 or	 ebx, 15			; 0000000fH
  0004f	81 fb ff ff ff
	7f		 cmp	 ebx, 2147483647		; 7fffffffH

; 4455 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00055	76 07		 jbe	 SHORT $LN19@assign

; 4456 :             return _Max;

  00057	bb ff ff ff 7f	 mov	 ebx, 2147483647		; 7fffffffH
  0005c	eb 1e		 jmp	 SHORT $LN18@assign
$LN19@assign:

; 4457 :         }
; 4458 : 
; 4459 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  0005e	8b d1		 mov	 edx, ecx
  00060	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00065	d1 ea		 shr	 edx, 1
  00067	2b c2		 sub	 eax, edx
  00069	3b c8		 cmp	 ecx, eax
  0006b	76 07		 jbe	 SHORT $LN20@assign

; 4460 :             return _Max;

  0006d	bb ff ff ff 7f	 mov	 ebx, 2147483647		; 7fffffffH
  00072	eb 08		 jmp	 SHORT $LN18@assign
$LN20@assign:

; 4461 :         }
; 4462 : 
; 4463 :         return (_STD max)(_Masked, _Old + _Old / 2);

  00074	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 43   :     return _Left < _Right ? _Right : _Left;

  00077	3b d8		 cmp	 ebx, eax
  00079	0f 42 d8	 cmovb	 ebx, eax
$LN18@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4481 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  0007c	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
  0007f	8b ce		 mov	 ecx, esi
  00081	50		 push	 eax
  00082	e8 00 00 00 00	 call	 ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00087	57		 push	 edi
  00088	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]

; 4481 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  0008b	89 45 0c	 mov	 DWORD PTR __New_ptr$1$[ebp], eax

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0008e	50		 push	 eax

; 4489 :         _Mypair._Myval2._Mysize = _New_size;

  0008f	89 7e 10	 mov	 DWORD PTR [esi+16], edi

; 4490 :         _Mypair._Myval2._Myres  = _New_capacity;

  00092	89 5e 14	 mov	 DWORD PTR [esi+20], ebx

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00095	e8 00 00 00 00	 call	 _memcpy

; 3224 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  0009a	8b 5d 0c	 mov	 ebx, DWORD PTR __New_ptr$1$[ebp]

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0009d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4492 :         if (_BUF_SIZE <= _Old_capacity) {

  000a0	8b 45 fc	 mov	 eax, DWORD PTR __Old$1$[ebp]

; 3224 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  000a3	c6 04 3b 00	 mov	 BYTE PTR [ebx+edi], 0

; 4492 :         if (_BUF_SIZE <= _Old_capacity) {

  000a7	83 f8 10	 cmp	 eax, 16			; 00000010H
  000aa	72 29		 jb	 SHORT $LN13@assign

; 4493 :             _Al.deallocate(_Mypair._Myval2._Bx._Ptr, _Old_capacity + 1);

  000ac	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000af	8b 06		 mov	 eax, DWORD PTR [esi]

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  000b1	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  000b7	72 12		 jb	 SHORT $LN42@assign

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000b9	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  000bc	83 c1 23	 add	 ecx, 35			; 00000023H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  000bf	2b c2		 sub	 eax, edx

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000c1	83 c0 fc	 add	 eax, -4			; fffffffcH
  000c4	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  000c7	77 19		 ja	 SHORT $LN39@assign

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  000c9	8b c2		 mov	 eax, edx
$LN42@assign:

; 255  :         ::operator delete(_Ptr, _Bytes);

  000cb	51		 push	 ecx
  000cc	50		 push	 eax
  000cd	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  000d2	83 c4 08	 add	 esp, 8
$LN13@assign:
  000d5	5f		 pop	 edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 3220 :         return _Reallocate_for(

  000d6	89 1e		 mov	 DWORD PTR [esi], ebx

; 3225 :             },
; 3226 :             _Ptr);
; 3227 :     }

  000d8	8b c6		 mov	 eax, esi
  000da	5e		 pop	 esi
  000db	5b		 pop	 ebx
  000dc	8b e5		 mov	 esp, ebp
  000de	5d		 pop	 ebp
  000df	c2 08 00	 ret	 8
$LN39@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000e2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN50@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4475 :             _Xlen_string(); // result too long

  000e8	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN47@assign:
  000ed	cc		 int	 3
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2968 :     _CONSTEXPR20_CONTAINER ~basic_string() noexcept {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 2286 :         return _BUF_SIZE <= _Myres;

  00003	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00006	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 4584 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00009	72 27		 jb	 SHORT $LN12@basic_stri
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000b	8b 06		 mov	 eax, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4588 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0000d	41		 inc	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0000e	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00014	72 12		 jb	 SHORT $LN22@basic_stri

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00016	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00019	83 c1 23	 add	 ecx, 35			; 00000023H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001c	2b c2		 sub	 eax, edx

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0001e	83 c0 fc	 add	 eax, -4			; fffffffcH
  00021	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00024	77 1f		 ja	 SHORT $LN19@basic_stri

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00026	8b c2		 mov	 eax, edx
$LN22@basic_stri:

; 255  :         ::operator delete(_Ptr, _Bytes);

  00028	51		 push	 ecx
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	83 c4 08	 add	 esp, 8
$LN12@basic_stri:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4599 :             _Mypair._Myval2._Mysize = 0;

  00032	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 4600 :             _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00039	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 4601 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4602 :             _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00040	c6 06 00	 mov	 BYTE PTR [esi], 0
  00043	5e		 pop	 esi

; 2976 :     }

  00044	c3		 ret	 0
$LN19@basic_stri:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00045	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN27@basic_stri:
  0004b	cc		 int	 3
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 800  :     _NODISCARD _CONSTEXPR20_DYNALLOC __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 228  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0000b	72 29		 jb	 SHORT $LN4@allocate

; 129  :     const size_t _Block_size = _Non_user_size + _Bytes;

  0000d	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]

; 130  :     if (_Block_size <= _Bytes) {

  00010	3b c8		 cmp	 ecx, eax
  00012	76 39		 jbe	 SHORT $LN26@allocate

; 79   :         return ::operator new(_Bytes);

  00014	51		 push	 ecx
  00015	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 134  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  0001a	8b c8		 mov	 ecx, eax

; 79   :         return ::operator new(_Bytes);

  0001c	83 c4 04	 add	 esp, 4

; 135  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0001f	85 c9		 test	 ecx, ecx
  00021	74 0d		 je	 SHORT $LN13@allocate

; 136  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  00023	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00026	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 137  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00029	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 801  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 802  :     }

  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
$LN13@allocate:

; 135  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  00030	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN4@allocate:

; 234  :     if (_Bytes != 0) {

  00036	85 c0		 test	 eax, eax
  00038	74 0d		 je	 SHORT $LN5@allocate

; 79   :         return ::operator new(_Bytes);

  0003a	50		 push	 eax
  0003b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00040	83 c4 04	 add	 esp, 4

; 801  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 802  :     }

  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
$LN5@allocate:

; 238  :     return nullptr;

  00047	33 c0		 xor	 eax, eax

; 801  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 802  :     }

  00049	5d		 pop	 ebp
  0004a	c2 04 00	 ret	 4
$LN26@allocate:

; 131  :         _Throw_bad_array_new_length(); // add overflow

  0004d	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN24@allocate:
  00052	cc		 int	 3
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Xlen_string@std@@YAXXZ
_TEXT	SEGMENT
?_Xlen_string@std@@YAXXZ PROC				; std::_Xlen_string, COMDAT

; 2340 :     _Xlength_error("string too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlen_strin:
  0000a	cc		 int	 3
?_Xlen_string@std@@YAXXZ ENDP				; std::_Xlen_string
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ?_Throw_tree_length_error@std@@YAXXZ
_TEXT	SEGMENT
?_Throw_tree_length_error@std@@YAXXZ PROC		; std::_Throw_tree_length_error, COMDAT

; 416  :     _Xlength_error("map/set too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@GCADKGJO@map?1set?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Throw_tree:
  0000a	cc		 int	 3
?_Throw_tree_length_error@std@@YAXXZ ENDP		; std::_Throw_tree_length_error
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 315  : [[noreturn]] inline void _Throw_bad_array_new_length() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 316  :     _THROW(bad_array_new_length{});

  00006	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00009	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QAE@XZ ; std::bad_array_new_length::bad_array_new_length
  0000e	68 00 00 00 00	 push	 OFFSET __TI3?AVbad_array_new_length@std@@
  00013	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN3@Throw_bad_:
  0001c	cc		 int	 3
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 89   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 90   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN12@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN12@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 72   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0

; 71   :         : _Data()

  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_array_new_length@std@@6B@
  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx

; 90   :         __std_exception_destroy(&_Data);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx
  00010	c3		 ret	 0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 141  :     {

  00000	0f 57 c0	 xorps	 xmm0, xmm0

; 142  :     }

  00003	8b c1		 mov	 eax, ecx

; 65   :         : _Data()

  00005	66 0f d6 41 04	 movq	 QWORD PTR [ecx+4], xmm0

; 66   :     {
; 67   :         _Data._What = _Message;

  0000a	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@

; 141  :     {

  00011	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_array_new_length@std@@6B@

; 142  :     }

  00017	c3		 ret	 0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 89   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 90   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN9@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN9@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 72   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0

; 71   :         : _Data()

  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 89   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 90   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN6@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN6@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 95   :         return _Data._What ? _Data._What : "Unknown exception";

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
  00008	85 c9		 test	 ecx, ecx
  0000a	0f 45 c1	 cmovne	 eax, ecx

; 96   :     }

  0000d	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UAE@XZ
_TEXT	SEGMENT
??1exception@std@@UAE@XZ PROC				; std::exception::~exception, COMDAT
; _this$ = ecx

; 90   :         __std_exception_destroy(&_Data);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx

; 91   :     }

  00010	c3		 ret	 0
??1exception@std@@UAE@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 72   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0
  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8

; 74   :     }

  00026	8b c6		 mov	 eax, esi
  00028	5e		 pop	 esi
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltime.h
;	COMDAT ?Format@CTime@ATL@@QBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@2@PBD@Z
_TEXT	SEGMENT
___$ReturnUdt$GSCopy$ = -172				; size = 4
_ptmTemp$ = -168					; size = 36
_szBuffer$ = -132					; size = 128
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_pFormat$ = 12						; size = 4
?Format@CTime@ATL@@QBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@2@PBD@Z PROC ; ATL::CTime::Format, COMDAT
; _this$ = ecx

; 1057 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec ac 00 00
	00		 sub	 esp, 172		; 000000acH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi
  00014	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  00017	57		 push	 edi
  00018	8b 7d 0c	 mov	 edi, DWORD PTR _pFormat$[ebp]
  0001b	89 b5 54 ff ff
	ff		 mov	 DWORD PTR ___$ReturnUdt$GSCopy$[ebp], esi

; 1058 : 	if(pFormat == NULL)

  00021	85 ff		 test	 edi, edi
  00023	75 03		 jne	 SHORT $LN2@Format

; 1059 : 	{
; 1060 : 		return pFormat;

  00025	57		 push	 edi
  00026	eb 43		 jmp	 SHORT $LN11@Format
$LN2@Format:

; 1061 : 	}
; 1062 : 
; 1063 : 	TCHAR szBuffer[maxTimeBufferSize];
; 1064 : 	struct tm ptmTemp;
; 1065 : 
; 1066 : 	if (_localtime64_s(&ptmTemp, &m_time) != 0)

  00028	51		 push	 ecx
  00029	8d 85 58 ff ff
	ff		 lea	 eax, DWORD PTR _ptmTemp$[ebp]
  0002f	50		 push	 eax
  00030	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___localtime64_s
  00036	83 c4 08	 add	 esp, 8
  00039	85 c0		 test	 eax, eax
  0003b	75 4a		 jne	 SHORT $LN13@Format

; 1069 : 	}
; 1070 : 
; 1071 : 	if (!_tcsftime(szBuffer, maxTimeBufferSize, pFormat, &ptmTemp))

  0003d	8d 85 58 ff ff
	ff		 lea	 eax, DWORD PTR _ptmTemp$[ebp]
  00043	50		 push	 eax
  00044	57		 push	 edi
  00045	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _szBuffer$[ebp]
  0004b	68 80 00 00 00	 push	 128			; 00000080H
  00050	50		 push	 eax
  00051	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strftime
  00057	83 c4 10	 add	 esp, 16			; 00000010H
  0005a	f7 d8		 neg	 eax
  0005c	1a c0		 sbb	 al, al
  0005e	20 85 7c ff ff
	ff		 and	 BYTE PTR _szBuffer$[ebp], al

; 1072 : 	{
; 1073 : 		szBuffer[0] = '\0';
; 1074 : 	}
; 1075 : 
; 1076 : 	return szBuffer;

  00064	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _szBuffer$[ebp]
  0006a	50		 push	 eax
$LN11@Format:

; 1077 : }

  0006b	8b ce		 mov	 ecx, esi
  0006d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  00073	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00076	8b c6		 mov	 eax, esi
  00078	5f		 pop	 edi
  00079	33 cd		 xor	 ecx, ebp
  0007b	5e		 pop	 esi
  0007c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00081	8b e5		 mov	 esp, ebp
  00083	5d		 pop	 ebp
  00084	c2 08 00	 ret	 8
$LN13@Format:

; 1067 : 	{
; 1068 : 		AtlThrow(E_INVALIDARG);

  00087	68 57 00 07 80	 push	 -2147024809		; 80070057H
  0008c	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN10@Format:
  00091	cc		 int	 3
?Format@CTime@ATL@@QBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@2@PBD@Z ENDP ; ATL::CTime::Format
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlexcept.h
;	COMDAT ?AtlThrowImpl@ATL@@YGXJ@Z
_TEXT	SEGMENT
_hr$ = 8						; size = 4
?AtlThrowImpl@ATL@@YGXJ@Z PROC				; ATL::AtlThrowImpl, COMDAT

; 65   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 66   : 	ATLTRACE(atlTraceException, 0, _T("AtlThrow: hr = 0x%x\n"), hr );
; 67   : #ifdef _AFX
; 68   : 	if( hr == E_OUTOFMEMORY )

  00003	8b 45 08	 mov	 eax, DWORD PTR _hr$[ebp]
  00006	3d 0e 00 07 80	 cmp	 eax, -2147024882	; 8007000eH
  0000b	75 05		 jne	 SHORT $LN2@AtlThrowIm

; 69   : 	{
; 70   : 		AfxThrowMemoryException();

  0000d	e8 00 00 00 00	 call	 ?AfxThrowMemoryException@@YGXXZ ; AfxThrowMemoryException
$LN2@AtlThrowIm:

; 71   : 	}
; 72   : 	else
; 73   : 	{
; 74   : 		AfxThrowOleException( hr );

  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ?AfxThrowOleException@@YGXJ@Z ; AfxThrowOleException
$LN5@AtlThrowIm:
  00018	cc		 int	 3
?AtlThrowImpl@ATL@@YGXJ@Z ENDP				; ATL::AtlThrowImpl
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
;	COMDAT ?Dump@CObject@@UBEXAAVCDumpContext@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?Dump@CObject@@UBEXAAVCDumpContext@@@Z PROC		; CObject::Dump, COMDAT
; _this$ = ecx

; 122  : 	{ /* no dumping in release builds */ }

  00000	c2 04 00	 ret	 4
?Dump@CObject@@UBEXAAVCDumpContext@@@Z ENDP		; CObject::Dump
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
;	COMDAT ?AssertValid@CObject@@UBEXXZ
_TEXT	SEGMENT
?AssertValid@CObject@@UBEXXZ PROC			; CObject::AssertValid, COMDAT
; _this$ = ecx

; 120  : 	{ /* no asserts in release builds */ }

  00000	c2 00 00	 ret	 0
?AssertValid@CObject@@UBEXXZ ENDP			; CObject::AssertValid
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
;	COMDAT ?Serialize@CObject@@UAEXAAVCArchive@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?Serialize@CObject@@UAEXAAVCArchive@@@Z PROC		; CObject::Serialize, COMDAT
; _this$ = ecx

; 106  : 	{ /* CObject does not serialize anything by default */ }

  00000	c2 04 00	 ret	 4
?Serialize@CObject@@UAEXAAVCArchive@@@Z ENDP		; CObject::Serialize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
;	COMDAT ??3CObject@@SGXPAX@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
??3CObject@@SGXPAX@Z PROC				; CObject::operator delete, COMDAT

; 112  : 	{ ::operator delete(p); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	ff 75 08	 push	 DWORD PTR _p$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4
  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
??3CObject@@SGXPAX@Z ENDP				; CObject::operator delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	c2 00 00	 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartObject\XScaleManagerImp.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

  00000	c2 00 00	 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
