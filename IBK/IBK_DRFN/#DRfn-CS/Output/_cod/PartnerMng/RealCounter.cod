; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30145.0 

	TITLE	D:\git\src\IBK\IBK_DRFN\#DRfn-CS\_Obj\PartnerMng\RealCounter.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	??1CObject@@UAE@XZ				; CObject::~CObject
PUBLIC	?Serialize@CObject@@UAEXAAVCArchive@@@Z		; CObject::Serialize
PUBLIC	?AssertValid@CObject@@UBEXXZ			; CObject::AssertValid
PUBLIC	?Dump@CObject@@UBEXAAVCDumpContext@@@Z		; CObject::Dump
PUBLIC	??0CRealCounterItem@@QAE@XZ			; CRealCounterItem::CRealCounterItem
PUBLIC	??1CRealCounterItem@@QAE@XZ			; CRealCounterItem::~CRealCounterItem
PUBLIC	??0CRealCounterMng@@QAE@XZ			; CRealCounterMng::CRealCounterMng
PUBLIC	??1CRealCounterMng@@QAE@XZ			; CRealCounterMng::~CRealCounterMng
PUBLIC	??0?$CList@VCRealCounterItem@@AAV1@@@QAE@H@Z	; CList<CRealCounterItem,CRealCounterItem &>::CList<CRealCounterItem,CRealCounterItem &>
PUBLIC	?AddTail@?$CList@VCRealCounterItem@@AAV1@@@QAEPAU__POSITION@@AAVCRealCounterItem@@@Z ; CList<CRealCounterItem,CRealCounterItem &>::AddTail
PUBLIC	?RemoveAll@?$CList@VCRealCounterItem@@AAV1@@@QAEXXZ ; CList<CRealCounterItem,CRealCounterItem &>::RemoveAll
PUBLIC	?RemoveAt@?$CList@VCRealCounterItem@@AAV1@@@QAEXPAU__POSITION@@@Z ; CList<CRealCounterItem,CRealCounterItem &>::RemoveAt
PUBLIC	?NewNode@?$CList@VCRealCounterItem@@AAV1@@@IAEPAUCNode@1@PAU21@0@Z ; CList<CRealCounterItem,CRealCounterItem &>::NewNode
PUBLIC	?FreeNode@?$CList@VCRealCounterItem@@AAV1@@@IAEXPAUCNode@1@@Z ; CList<CRealCounterItem,CRealCounterItem &>::FreeNode
PUBLIC	??1?$CList@VCRealCounterItem@@AAV1@@@UAE@XZ	; CList<CRealCounterItem,CRealCounterItem &>::~CList<CRealCounterItem,CRealCounterItem &>
PUBLIC	?Serialize@?$CList@VCRealCounterItem@@AAV1@@@UAEXAAVCArchive@@@Z ; CList<CRealCounterItem,CRealCounterItem &>::Serialize
PUBLIC	??_G?$CList@VCRealCounterItem@@AAV1@@@UAEPAXI@Z	; CList<CRealCounterItem,CRealCounterItem &>::`scalar deleting destructor'
PUBLIC	?FindItem@CRealCounterMng@@QAEPAU__POSITION@@PBD@Z ; CRealCounterMng::FindItem
PUBLIC	?AddItem@CRealCounterMng@@QAEHPBD@Z		; CRealCounterMng::AddItem
PUBLIC	?RemoveItem@CRealCounterMng@@QAEHPBD@Z		; CRealCounterMng::RemoveItem
PUBLIC	?RemoveAll@CRealCounterMng@@QAEXXZ		; CRealCounterMng::RemoveAll
PUBLIC	??$SerializeElements@VCRealCounterItem@@@@YGXAAVCArchive@@PAVCRealCounterItem@@H@Z ; SerializeElements<CRealCounterItem>
PUBLIC	??_R0?AVCObject@@@8				; CObject `RTTI Type Descriptor'
PUBLIC	??_R3CObject@@8					; CObject::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CObject@@8					; CObject::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CObject@@8			; CObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_7?$CList@VCRealCounterItem@@AAV1@@@6B@	; CList<CRealCounterItem,CRealCounterItem &>::`vftable'
PUBLIC	??_R4?$CList@VCRealCounterItem@@AAV1@@@6B@	; CList<CRealCounterItem,CRealCounterItem &>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CList@VCRealCounterItem@@AAV1@@@@8	; CList<CRealCounterItem,CRealCounterItem &> `RTTI Type Descriptor'
PUBLIC	??_R3?$CList@VCRealCounterItem@@AAV1@@@8	; CList<CRealCounterItem,CRealCounterItem &>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CList@VCRealCounterItem@@AAV1@@@8	; CList<CRealCounterItem,CRealCounterItem &>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CList@VCRealCounterItem@@AAV1@@@8 ; CList<CRealCounterItem,CRealCounterItem &>::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_L@YGXPAXIIP6EX0@Z1@Z:PROC			; `eh vector constructor iterator'
EXTRN	??_M@YGXPAXIIP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	?__global_delete@@YAXPAXI@Z:PROC		; __global_delete
EXTRN	___std_terminate:PROC
EXTRN	?AfxThrowInvalidArgException@@YGXXZ:PROC	; AfxThrowInvalidArgException
EXTRN	?AfxThrowArchiveException@@YGXHPBD@Z:PROC	; AfxThrowArchiveException
EXTRN	?GetRuntimeClass@CObject@@UBEPAUCRuntimeClass@@XZ:PROC ; CObject::GetRuntimeClass
EXTRN	__imp_??A?$CSimpleStringT@D$00@ATL@@QBEDH@Z:PROC
EXTRN	__imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ:PROC
EXTRN	__imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z:PROC
EXTRN	__imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z:PROC
EXTRN	__imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ:PROC
EXTRN	__imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z:PROC
EXTRN	__imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z:PROC
EXTRN	__imp_?Compare@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEHPBD@Z:PROC
EXTRN	__imp_?Mid@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBE?AV12@H@Z:PROC
EXTRN	?Read@CArchive@@QAEIPAXI@Z:PROC			; CArchive::Read
EXTRN	?Write@CArchive@@QAEXPBXI@Z:PROC		; CArchive::Write
EXTRN	?ReadCount@CArchive@@QAEKXZ:PROC		; CArchive::ReadCount
EXTRN	?WriteCount@CArchive@@QAEXK@Z:PROC		; CArchive::WriteCount
EXTRN	?Create@CPlex@@SGPAU1@AAPAU1@II@Z:PROC		; CPlex::Create
EXTRN	?FreeDataChain@CPlex@@QAEXXZ:PROC		; CPlex::FreeDataChain
EXTRN	??_E?$CList@VCRealCounterItem@@AAV1@@@UAEPAXI@Z:PROC ; CList<CRealCounterItem,CRealCounterItem &>::`vector deleting destructor'
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___security_cookie:DWORD
;	COMDAT ??_R1A@?0A@EA@?$CList@VCRealCounterItem@@AAV1@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CList@VCRealCounterItem@@AAV1@@@8 DD FLAT:??_R0?AV?$CList@VCRealCounterItem@@AAV1@@@@8 ; CList<CRealCounterItem,CRealCounterItem &>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CList@VCRealCounterItem@@AAV1@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CList@VCRealCounterItem@@AAV1@@@8
rdata$r	SEGMENT
??_R2?$CList@VCRealCounterItem@@AAV1@@@8 DD FLAT:??_R1A@?0A@EA@?$CList@VCRealCounterItem@@AAV1@@@8 ; CList<CRealCounterItem,CRealCounterItem &>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CObject@@8
rdata$r	ENDS
;	COMDAT ??_R3?$CList@VCRealCounterItem@@AAV1@@@8
rdata$r	SEGMENT
??_R3?$CList@VCRealCounterItem@@AAV1@@@8 DD 00H		; CList<CRealCounterItem,CRealCounterItem &>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$CList@VCRealCounterItem@@AAV1@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CList@VCRealCounterItem@@AAV1@@@@8
data$rs	SEGMENT
??_R0?AV?$CList@VCRealCounterItem@@AAV1@@@@8 DD FLAT:??_7type_info@@6B@ ; CList<CRealCounterItem,CRealCounterItem &> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CList@VCRealCounterItem@@AAV1@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CList@VCRealCounterItem@@AAV1@@@6B@
rdata$r	SEGMENT
??_R4?$CList@VCRealCounterItem@@AAV1@@@6B@ DD 00H	; CList<CRealCounterItem,CRealCounterItem &>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CList@VCRealCounterItem@@AAV1@@@@8
	DD	FLAT:??_R3?$CList@VCRealCounterItem@@AAV1@@@8
rdata$r	ENDS
;	COMDAT ??_7?$CList@VCRealCounterItem@@AAV1@@@6B@
CONST	SEGMENT
??_7?$CList@VCRealCounterItem@@AAV1@@@6B@ DD FLAT:??_R4?$CList@VCRealCounterItem@@AAV1@@@6B@ ; CList<CRealCounterItem,CRealCounterItem &>::`vftable'
	DD	FLAT:?GetRuntimeClass@CObject@@UBEPAUCRuntimeClass@@XZ
	DD	FLAT:??_E?$CList@VCRealCounterItem@@AAV1@@@UAEPAXI@Z
	DD	FLAT:?Serialize@?$CList@VCRealCounterItem@@AAV1@@@UAEXAAVCArchive@@@Z
	DD	FLAT:?AssertValid@CObject@@UBEXXZ
	DD	FLAT:?Dump@CObject@@UBEXAAVCDumpContext@@@Z
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@CObject@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CObject@@8 DD FLAT:??_R0?AVCObject@@@8	; CObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CObject@@8
rdata$r	ENDS
;	COMDAT ??_R2CObject@@8
rdata$r	SEGMENT
??_R2CObject@@8 DD FLAT:??_R1A@?0A@EA@CObject@@8	; CObject::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CObject@@8
rdata$r	SEGMENT
??_R3CObject@@8 DD 00H					; CObject::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CObject@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCObject@@@8
data$rs	SEGMENT
??_R0?AVCObject@@@8 DD FLAT:??_7type_info@@6B@		; CObject `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCObject@@', 00H
data$rs	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?RemoveItem@CRealCounterMng@@QAEHPBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?RemoveItem@CRealCounterMng@@QAEHPBD@Z$0
__ehfuncinfo$?RemoveItem@CRealCounterMng@@QAEHPBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?RemoveItem@CRealCounterMng@@QAEHPBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?AddItem@CRealCounterMng@@QAEHPBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AddItem@CRealCounterMng@@QAEHPBD@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?AddItem@CRealCounterMng@@QAEHPBD@Z$1
__ehfuncinfo$?AddItem@CRealCounterMng@@QAEHPBD@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?AddItem@CRealCounterMng@@QAEHPBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?FindItem@CRealCounterMng@@QAEPAU__POSITION@@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?FindItem@CRealCounterMng@@QAEPAU__POSITION@@PBD@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?FindItem@CRealCounterMng@@QAEPAU__POSITION@@PBD@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?FindItem@CRealCounterMng@@QAEPAU__POSITION@@PBD@Z$2
__ehfuncinfo$?FindItem@CRealCounterMng@@QAEPAU__POSITION@@PBD@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?FindItem@CRealCounterMng@@QAEPAU__POSITION@@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_G?$CList@VCRealCounterItem@@AAV1@@@UAEPAXI@Z DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??_G?$CList@VCRealCounterItem@@AAV1@@@UAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_G?$CList@VCRealCounterItem@@AAV1@@@UAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Serialize@?$CList@VCRealCounterItem@@AAV1@@@UAEXAAVCArchive@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Serialize@?$CList@VCRealCounterItem@@AAV1@@@UAEXAAVCArchive@@@Z$0
__ehfuncinfo$?Serialize@?$CList@VCRealCounterItem@@AAV1@@@UAEXAAVCArchive@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Serialize@?$CList@VCRealCounterItem@@AAV1@@@UAEXAAVCArchive@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CList@VCRealCounterItem@@AAV1@@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1CRealCounterMng@@QAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??1CRealCounterMng@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1CRealCounterMng@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ??$SerializeElements@VCRealCounterItem@@@@YGXAAVCArchive@@PAVCRealCounterItem@@H@Z
_TEXT	SEGMENT
_ar$ = 8						; size = 4
_pElements$ = 12					; size = 4
_nCount$ = 16						; size = 4
??$SerializeElements@VCRealCounterItem@@@@YGXAAVCArchive@@PAVCRealCounterItem@@H@Z PROC ; SerializeElements<CRealCounterItem>, COMDAT

; 67   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 68   : 	ENSURE(nCount == 0 || pElements != NULL);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR _pElements$[ebp]
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b 75 10	 mov	 esi, DWORD PTR _nCount$[ebp]
  0000b	57		 push	 edi
  0000c	85 f6		 test	 esi, esi
  0000e	74 08		 je	 SHORT $LN2@SerializeE
  00010	85 c9		 test	 ecx, ecx
  00012	0f 84 89 00 00
	00		 je	 $LN34@SerializeE
$LN2@SerializeE:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 212  : 	{ return (m_nMode & CArchive::load) == 0; }

  00018	8b 55 08	 mov	 edx, DWORD PTR _ar$[ebp]
  0001b	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0001e	f7 d0		 not	 eax
  00020	a8 01		 test	 al, 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 73   : 	if (ar.IsStoring())

  00022	74 3c		 je	 SHORT $LN10@SerializeE

; 74   : 	{
; 75   : 		TYPE* pData;
; 76   : 		UINT_PTR nElementsLeft;
; 77   : 
; 78   : 		nElementsLeft = nCount;
; 79   : 		pData = pElements;
; 80   : 		while( nElementsLeft > 0 )

  00024	85 f6		 test	 esi, esi
  00026	74 31		 je	 SHORT $LN8@SerializeE
  00028	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL5@SerializeE:

; 81   : 		{
; 82   : 			UINT nElementsToWrite;
; 83   : 
; 84   : 			nElementsToWrite = UINT(__min(nElementsLeft, INT_MAX/sizeof(TYPE)));

  00030	bb ff ff ff 0f	 mov	 ebx, 268435455		; 0fffffffH
  00035	3b f3		 cmp	 esi, ebx
  00037	0f 42 de	 cmovb	 ebx, esi

; 85   : 			ar.Write(pData, nElementsToWrite*sizeof(TYPE));

  0003a	8d 3c dd 00 00
	00 00		 lea	 edi, DWORD PTR [ebx*8]
  00041	57		 push	 edi
  00042	51		 push	 ecx
  00043	8b ca		 mov	 ecx, edx
  00045	e8 00 00 00 00	 call	 ?Write@CArchive@@QAEXPBXI@Z ; CArchive::Write

; 86   : 			nElementsLeft -= nElementsToWrite;
; 87   : 			pData += nElementsToWrite;

  0004a	8b 4d 0c	 mov	 ecx, DWORD PTR _pElements$[ebp]
  0004d	8b 55 08	 mov	 edx, DWORD PTR _ar$[ebp]
  00050	03 cf		 add	 ecx, edi
  00052	89 4d 0c	 mov	 DWORD PTR _pElements$[ebp], ecx
  00055	2b f3		 sub	 esi, ebx
  00057	75 d7		 jne	 SHORT $LL5@SerializeE
$LN8@SerializeE:
  00059	5f		 pop	 edi

; 105  : 		}
; 106  : 	}
; 107  : }

  0005a	5e		 pop	 esi
  0005b	5b		 pop	 ebx
  0005c	5d		 pop	 ebp
  0005d	c2 0c 00	 ret	 12			; 0000000cH
$LN10@SerializeE:

; 97   : 		while( nElementsLeft > 0 )

  00060	85 f6		 test	 esi, esi
  00062	74 f5		 je	 SHORT $LN8@SerializeE
$LL7@SerializeE:

; 98   : 		{
; 99   : 			UINT nElementsToRead;
; 100  : 
; 101  : 			nElementsToRead = UINT(__min(nElementsLeft, INT_MAX/sizeof(TYPE)));

  00064	bf ff ff ff 0f	 mov	 edi, 268435455		; 0fffffffH
  00069	3b f7		 cmp	 esi, edi
  0006b	0f 42 fe	 cmovb	 edi, esi

; 102  : 			ar.EnsureRead(pData, nElementsToRead*sizeof(TYPE));

  0006e	8d 1c fd 00 00
	00 00		 lea	 ebx, DWORD PTR [edi*8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 399  : 	UINT nRead=Read(lpBuf, nCount);

  00075	53		 push	 ebx
  00076	51		 push	 ecx
  00077	8b ca		 mov	 ecx, edx
  00079	e8 00 00 00 00	 call	 ?Read@CArchive@@QAEIPAXI@Z ; CArchive::Read

; 400  : 	if(nRead!=nCount)

  0007e	3b c3		 cmp	 eax, ebx
  00080	75 16		 jne	 SHORT $LN23@SerializeE
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 97   : 		while( nElementsLeft > 0 )

  00082	8b 4d 0c	 mov	 ecx, DWORD PTR _pElements$[ebp]
  00085	8b 55 08	 mov	 edx, DWORD PTR _ar$[ebp]

; 103  : 			nElementsLeft -= nElementsToRead;
; 104  : 			pData += nElementsToRead;

  00088	03 cb		 add	 ecx, ebx
  0008a	89 4d 0c	 mov	 DWORD PTR _pElements$[ebp], ecx
  0008d	2b f7		 sub	 esi, edi
  0008f	75 d3		 jne	 SHORT $LL7@SerializeE

; 105  : 		}
; 106  : 	}
; 107  : }

  00091	5f		 pop	 edi
  00092	5e		 pop	 esi
  00093	5b		 pop	 ebx
  00094	5d		 pop	 ebp
  00095	c2 0c 00	 ret	 12			; 0000000cH
$LN23@SerializeE:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 402  : 		AfxThrowArchiveException(CArchiveException::endOfFile);

  00098	6a 00		 push	 0
  0009a	6a 03		 push	 3
  0009c	e8 00 00 00 00	 call	 ?AfxThrowArchiveException@@YGXHPBD@Z ; AfxThrowArchiveException
$LN34@SerializeE:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 68   : 	ENSURE(nCount == 0 || pElements != NULL);

  000a1	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN32@SerializeE:
  000a6	cc		 int	 3
??$SerializeElements@VCRealCounterItem@@@@YGXAAVCArchive@@PAVCRealCounterItem@@H@Z ENDP ; SerializeElements<CRealCounterItem>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\DrCommon\PartnerMng\RealCounter.cpp
;	COMDAT ?RemoveAll@CRealCounterMng@@QAEXXZ
_TEXT	SEGMENT
?RemoveAll@CRealCounterMng@@QAEXXZ PROC			; CRealCounterMng::RemoveAll, COMDAT
; _this$ = ecx

; 91   : 	m_itemList.RemoveAll();

  00000	e9 00 00 00 00	 jmp	 ?RemoveAll@?$CList@VCRealCounterItem@@AAV1@@@QAEXXZ ; CList<CRealCounterItem,CRealCounterItem &>::RemoveAll
?RemoveAll@CRealCounterMng@@QAEXXZ ENDP			; CRealCounterMng::RemoveAll
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\DrCommon\PartnerMng\RealCounter.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\DrCommon\PartnerMng\RealCounter.cpp
;	COMDAT ?RemoveItem@CRealCounterMng@@QAEHPBD@Z
_TEXT	SEGMENT
_item$2 = -20						; size = 8
__$EHRec$ = -12						; size = 12
_szCode$ = 8						; size = 4
?RemoveItem@CRealCounterMng@@QAEHPBD@Z PROC		; CRealCounterMng::RemoveItem, COMDAT
; _this$ = ecx

; 60   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?RemoveItem@CRealCounterMng@@QAEHPBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b f9		 mov	 edi, ecx

; 61   : 	POSITION pos = FindItem(szCode);

  0002a	ff 75 08	 push	 DWORD PTR _szCode$[ebp]
  0002d	e8 00 00 00 00	 call	 ?FindItem@CRealCounterMng@@QAEPAU__POSITION@@PBD@Z ; CRealCounterMng::FindItem
  00032	8b f0		 mov	 esi, eax

; 62   : 	if(pos)

  00034	85 f6		 test	 esi, esi
  00036	0f 84 81 00 00
	00		 je	 $LN2@RemoveItem

; 63   : 	{
; 64   : 		CRealCounterItem item=m_itemList.GetAt(pos);

  0003c	8d 5e 08	 lea	 ebx, DWORD PTR [esi+8]
  0003f	53		 push	 ebx
  00040	8d 4d ec	 lea	 ecx, DWORD PTR _item$2[ebp]
  00043	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z
  00049	8b 5b 04	 mov	 ebx, DWORD PTR [ebx+4]
  0004c	83 eb 01	 sub	 ebx, 1
  0004f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 65   : 		item.m_nCount --;

  00056	89 5d f0	 mov	 DWORD PTR _item$2[ebp+4], ebx

; 66   : 
; 67   : // 		{
; 68   : // 			CString szDebug;
; 69   : // 			szDebug.Format("RealCount Del [%s --> %d\n", szCode, item.m_nCount);
; 70   : // 			OutputDebugString(szDebug);
; 71   : // 		}
; 72   : 
; 73   : 		if(item.m_nCount==0)

  00059	75 43		 jne	 SHORT $LN6@RemoveItem
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 1107 : 	if (pOldNode == m_pNodeHead)

  0005b	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0005d	3b 77 04	 cmp	 esi, DWORD PTR [edi+4]
  00060	75 05		 jne	 SHORT $LN11@RemoveItem

; 1108 : 	{
; 1109 : 		m_pNodeHead = pOldNode->pNext;

  00062	89 4f 04	 mov	 DWORD PTR [edi+4], ecx

; 1110 : 	}

  00065	eb 05		 jmp	 SHORT $LN12@RemoveItem
$LN11@RemoveItem:

; 1111 : 	else
; 1112 : 	{
; 1113 : 		ASSERT(AfxIsValidAddress(pOldNode->pPrev, sizeof(CNode)));
; 1114 : 		pOldNode->pPrev->pNext = pOldNode->pNext;

  00067	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0006a	89 08		 mov	 DWORD PTR [eax], ecx
$LN12@RemoveItem:

; 1115 : 	}
; 1116 : 	if (pOldNode == m_pNodeTail)

  0006c	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0006f	3b 77 08	 cmp	 esi, DWORD PTR [edi+8]
  00072	75 05		 jne	 SHORT $LN13@RemoveItem

; 1117 : 	{
; 1118 : 		m_pNodeTail = pOldNode->pPrev;

  00074	89 4f 08	 mov	 DWORD PTR [edi+8], ecx

; 1119 : 	}

  00077	eb 05		 jmp	 SHORT $LN14@RemoveItem
$LN13@RemoveItem:

; 1120 : 	else
; 1121 : 	{
; 1122 : 		ASSERT(AfxIsValidAddress(pOldNode->pNext, sizeof(CNode)));
; 1123 : 		pOldNode->pNext->pPrev = pOldNode->pPrev;

  00079	8b 06		 mov	 eax, DWORD PTR [esi]
  0007b	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN14@RemoveItem:

; 937  : 	pNode->data.~TYPE();

  0007e	8d 4e 08	 lea	 ecx, DWORD PTR [esi+8]
  00081	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 938  : 	pNode->pNext = m_pNodeFree;

  00087	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  0008a	89 06		 mov	 DWORD PTR [esi], eax

; 939  : 	m_pNodeFree = pNode;
; 940  : 	m_nCount--;

  0008c	83 47 0c ff	 add	 DWORD PTR [edi+12], -1
  00090	89 77 10	 mov	 DWORD PTR [edi+16], esi

; 941  : 	ASSERT(m_nCount >= 0);  // make sure we don't underflow
; 942  : 
; 943  : 	// if no more elements, cleanup completely
; 944  : 	if (m_nCount == 0)

  00093	75 07		 jne	 SHORT $LN17@RemoveItem

; 945  : 		RemoveAll();

  00095	8b cf		 mov	 ecx, edi
  00097	e8 00 00 00 00	 call	 ?RemoveAll@?$CList@VCRealCounterItem@@AAV1@@@QAEXXZ ; CList<CRealCounterItem,CRealCounterItem &>::RemoveAll
$LN17@RemoveItem:
  0009c	33 db		 xor	 ebx, ebx
$LN6@RemoveItem:
  0009e	8d 4d ec	 lea	 ecx, DWORD PTR _item$2[ebp]
  000a1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\DrCommon\PartnerMng\RealCounter.cpp

; 78   : 		return item.m_nCount;

  000a7	8b c3		 mov	 eax, ebx

; 87   : }

  000a9	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000ac	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000b3	59		 pop	 ecx
  000b4	5f		 pop	 edi
  000b5	5e		 pop	 esi
  000b6	5b		 pop	 ebx
  000b7	8b e5		 mov	 esp, ebp
  000b9	5d		 pop	 ebp
  000ba	c2 04 00	 ret	 4
$LN2@RemoveItem:

; 79   : 	}
; 80   : 
; 81   : // 	{
; 82   : // 		CString szDebug;
; 83   : // 		szDebug.Format("RealCount Del [%s --> 없는종목\n", szCode);
; 84   : // 		OutputDebugString(szDebug);
; 85   : // 	}
; 86   : 	return 0;

  000bd	33 c0		 xor	 eax, eax

; 87   : }

  000bf	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000c2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000c9	59		 pop	 ecx
  000ca	5f		 pop	 edi
  000cb	5e		 pop	 esi
  000cc	5b		 pop	 ebx
  000cd	8b e5		 mov	 esp, ebp
  000cf	5d		 pop	 ebp
  000d0	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?RemoveItem@CRealCounterMng@@QAEHPBD@Z$0:
  00000	8d 4d ec	 lea	 ecx, DWORD PTR _item$2[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CRealCounterItem@@QAE@XZ
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?RemoveItem@CRealCounterMng@@QAEHPBD@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?RemoveItem@CRealCounterMng@@QAEHPBD@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?RemoveItem@CRealCounterMng@@QAEHPBD@Z ENDP		; CRealCounterMng::RemoveItem
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\DrCommon\PartnerMng\RealCounter.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\DrCommon\PartnerMng\RealCounter.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\DrCommon\PartnerMng\RealCounter.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\DrCommon\PartnerMng\RealCounter.cpp
;	COMDAT ?AddItem@CRealCounterMng@@QAEHPBD@Z
_TEXT	SEGMENT
_item$2 = -28						; size = 8
_item$ = -20						; size = 8
__$EHRec$ = -12						; size = 12
_szCode$ = 8						; size = 4
?AddItem@CRealCounterMng@@QAEHPBD@Z PROC		; CRealCounterMng::AddItem, COMDAT
; _this$ = ecx

; 30   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?AddItem@CRealCounterMng@@QAEHPBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	50		 push	 eax
  0001e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00027	8b f1		 mov	 esi, ecx

; 31   : 	POSITION pos = FindItem(szCode);

  00029	8b 7d 08	 mov	 edi, DWORD PTR _szCode$[ebp]
  0002c	57		 push	 edi
  0002d	e8 00 00 00 00	 call	 ?FindItem@CRealCounterMng@@QAEPAU__POSITION@@PBD@Z ; CRealCounterMng::FindItem

; 32   : 	if(pos)

  00032	85 c0		 test	 eax, eax
  00034	74 32		 je	 SHORT $LN2@AddItem

; 33   : 	{
; 34   : 		CRealCounterItem item=m_itemList.GetAt(pos);

  00036	8d 78 08	 lea	 edi, DWORD PTR [eax+8]
  00039	57		 push	 edi
  0003a	8d 4d e4	 lea	 ecx, DWORD PTR _item$2[ebp]
  0003d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z
  00043	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00046	8b cf		 mov	 ecx, edi
  00048	40		 inc	 eax
  00049	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 35   : 		item.m_nCount ++;

  00050	89 45 e8	 mov	 DWORD PTR _item$2[ebp+4], eax
  00053	8d 45 e4	 lea	 eax, DWORD PTR _item$2[ebp]
  00056	50		 push	 eax
  00057	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 847  : 		pNode->data = newElement; }

  0005d	8b 75 e8	 mov	 esi, DWORD PTR _item$2[ebp+4]
  00060	8d 4d e4	 lea	 ecx, DWORD PTR _item$2[ebp]
  00063	89 77 04	 mov	 DWORD PTR [edi+4], esi
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\DrCommon\PartnerMng\RealCounter.cpp

; 43   : 		return item.m_nCount;

  00066	eb 35		 jmp	 SHORT $LN22@AddItem
$LN2@AddItem:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\DrCommon\PartnerMng\RealCounter.h

; 7    : 	CRealCounterItem():m_nCount(0) {}

  00068	8d 4d ec	 lea	 ecx, DWORD PTR _item$[ebp]
  0006b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00071	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _item$[ebp+4], 0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\DrCommon\PartnerMng\RealCounter.cpp

; 47   : 	item.m_szCode = szCode;

  00078	57		 push	 edi
  00079	8d 4d ec	 lea	 ecx, DWORD PTR _item$[ebp]
  0007c	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00083	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z

; 48   : 	item.m_nCount ++;

  00089	ff 45 f0	 inc	 DWORD PTR _item$[ebp+4]

; 49   : 	m_itemList.AddTail(item);

  0008c	8d 45 ec	 lea	 eax, DWORD PTR _item$[ebp]
  0008f	50		 push	 eax
  00090	8b ce		 mov	 ecx, esi
  00092	e8 00 00 00 00	 call	 ?AddTail@?$CList@VCRealCounterItem@@AAV1@@@QAEPAU__POSITION@@AAVCRealCounterItem@@@Z ; CList<CRealCounterItem,CRealCounterItem &>::AddTail

; 50   : 
; 51   : // 	{
; 52   : // 		CString szDebug;
; 53   : // 		szDebug.Format("RealCount Add [%s --> %d\n", szCode, item.m_nCount);
; 54   : // 		OutputDebugString(szDebug);
; 55   : // 	}
; 56   : 	return item.m_nCount;

  00097	8b 75 f0	 mov	 esi, DWORD PTR _item$[ebp+4]
  0009a	8d 4d ec	 lea	 ecx, DWORD PTR _item$[ebp]
$LN22@AddItem:

; 57   : }

  0009d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  000a3	8b c6		 mov	 eax, esi
  000a5	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a8	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000af	59		 pop	 ecx
  000b0	5f		 pop	 edi
  000b1	5e		 pop	 esi
  000b2	8b e5		 mov	 esp, ebp
  000b4	5d		 pop	 ebp
  000b5	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AddItem@CRealCounterMng@@QAEHPBD@Z$0:
  00000	8d 4d e4	 lea	 ecx, DWORD PTR _item$2[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CRealCounterItem@@QAE@XZ
__unwindfunclet$?AddItem@CRealCounterMng@@QAEHPBD@Z$1:
  00008	8d 4d ec	 lea	 ecx, DWORD PTR _item$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1CRealCounterItem@@QAE@XZ
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$?AddItem@CRealCounterMng@@QAEHPBD@Z:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?AddItem@CRealCounterMng@@QAEHPBD@Z
  0002d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?AddItem@CRealCounterMng@@QAEHPBD@Z ENDP		; CRealCounterMng::AddItem
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\DrCommon\PartnerMng\RealCounter.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\DrCommon\PartnerMng\RealCounter.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\DrCommon\PartnerMng\RealCounter.cpp
;	COMDAT ?FindItem@CRealCounterMng@@QAEPAU__POSITION@@PBD@Z
_TEXT	SEGMENT
_item$2 = -20						; size = 8
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_szCompCode$ = 8					; size = 4
_szCode$ = 8						; size = 4
?FindItem@CRealCounterMng@@QAEPAU__POSITION@@PBD@Z PROC	; CRealCounterMng::FindItem, COMDAT
; _this$ = ecx

; 14   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?FindItem@CRealCounterMng@@QAEPAU__POSITION@@PBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b f9		 mov	 edi, ecx

; 15   : 	CString szCompCode(szCode);

  0002a	ff 75 08	 push	 DWORD PTR _szCode$[ebp]
  0002d	8d 4d 08	 lea	 ecx, DWORD PTR _szCompCode$[ebp]
  00030	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z

; 16   : 	if(szCompCode[0]=='A'||szCompCode[0]=='J')

  00036	6a 00		 push	 0
  00038	8d 4d 08	 lea	 ecx, DWORD PTR _szCompCode$[ebp]
  0003b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00042	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??A?$CSimpleStringT@D$00@ATL@@QBEDH@Z
  00048	3c 41		 cmp	 al, 65			; 00000041H
  0004a	74 0f		 je	 SHORT $LN6@FindItem
  0004c	6a 00		 push	 0
  0004e	8d 4d 08	 lea	 ecx, DWORD PTR _szCompCode$[ebp]
  00051	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??A?$CSimpleStringT@D$00@ATL@@QBEDH@Z
  00057	3c 4a		 cmp	 al, 74			; 0000004aH
  00059	75 2a		 jne	 SHORT $LN5@FindItem
$LN6@FindItem:

; 17   : 		szCompCode = szCompCode.Mid(1);

  0005b	6a 01		 push	 1
  0005d	8d 45 f0	 lea	 eax, DWORD PTR $T3[ebp]
  00060	50		 push	 eax
  00061	8d 4d 08	 lea	 ecx, DWORD PTR _szCompCode$[ebp]
  00064	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Mid@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBE?AV12@H@Z
  0006a	50		 push	 eax
  0006b	8d 4d 08	 lea	 ecx, DWORD PTR _szCompCode$[ebp]
  0006e	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00072	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
  00078	8d 4d f0	 lea	 ecx, DWORD PTR $T3[ebp]
  0007b	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0007f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$LN5@FindItem:

; 18   : 	POSITION pos, tPos;
; 19   : 	for(pos=m_itemList.GetHeadPosition(); pos;)

  00085	8b 7f 04	 mov	 edi, DWORD PTR [edi+4]
  00088	85 ff		 test	 edi, edi
  0008a	74 42		 je	 SHORT $LN3@FindItem
  0008c	0f 1f 40 00	 npad	 4
$LL2@FindItem:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 811  : 	{ CNode* pNode = (CNode*) rPosition;

  00090	8b f7		 mov	 esi, edi
  00092	8d 4d ec	 lea	 ecx, DWORD PTR _item$2[ebp]

; 814  : 		return pNode->data; }

  00095	83 c6 08	 add	 esi, 8
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\DrCommon\PartnerMng\RealCounter.cpp

; 21   : 		tPos = pos;

  00098	8b df		 mov	 ebx, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 813  : 		rPosition = (POSITION) pNode->pNext;

  0009a	8b 3f		 mov	 edi, DWORD PTR [edi]
  0009c	56		 push	 esi
  0009d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z
  000a3	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000a6	89 45 f0	 mov	 DWORD PTR _item$2[ebp+4], eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\DrCommon\PartnerMng\RealCounter.cpp

; 23   : 		if(item.m_szCode.Compare(szCompCode)==0)

  000a9	ff 75 08	 push	 DWORD PTR _szCompCode$[ebp]
  000ac	8d 4d ec	 lea	 ecx, DWORD PTR _item$2[ebp]
  000af	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  000b3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Compare@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEHPBD@Z
  000b9	8d 4d ec	 lea	 ecx, DWORD PTR _item$2[ebp]
  000bc	85 c0		 test	 eax, eax
  000be	74 2f		 je	 SHORT $LN27@FindItem

; 24   : 			return tPos;
; 25   : 	}

  000c0	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  000c4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  000ca	85 ff		 test	 edi, edi
  000cc	75 c2		 jne	 SHORT $LL2@FindItem
$LN3@FindItem:

; 26   : 	return NULL;

  000ce	33 db		 xor	 ebx, ebx
$LN12@FindItem:
  000d0	8d 4d 08	 lea	 ecx, DWORD PTR _szCompCode$[ebp]
  000d3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  000d9	8b c3		 mov	 eax, ebx

; 27   : }

  000db	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000de	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000e5	59		 pop	 ecx
  000e6	5f		 pop	 edi
  000e7	5e		 pop	 esi
  000e8	5b		 pop	 ebx
  000e9	8b e5		 mov	 esp, ebp
  000eb	5d		 pop	 ebp
  000ec	c2 04 00	 ret	 4
$LN27@FindItem:
  000ef	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  000f5	eb d9		 jmp	 SHORT $LN12@FindItem
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?FindItem@CRealCounterMng@@QAEPAU__POSITION@@PBD@Z$0:
  00000	8d 4d 08	 lea	 ecx, DWORD PTR _szCompCode$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?FindItem@CRealCounterMng@@QAEPAU__POSITION@@PBD@Z$1:
  00009	8d 4d f0	 lea	 ecx, DWORD PTR $T3[ebp]
  0000c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?FindItem@CRealCounterMng@@QAEPAU__POSITION@@PBD@Z$2:
  00012	8d 4d ec	 lea	 ecx, DWORD PTR _item$2[ebp]
  00015	e9 00 00 00 00	 jmp	 ??1CRealCounterItem@@QAE@XZ
  0001a	cc		 int	 3
  0001b	cc		 int	 3
  0001c	cc		 int	 3
  0001d	cc		 int	 3
  0001e	cc		 int	 3
__ehhandler$?FindItem@CRealCounterMng@@QAEPAU__POSITION@@PBD@Z:
  0001f	90		 npad	 1
  00020	90		 npad	 1
  00021	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00025	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00028	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0002b	33 c8		 xor	 ecx, eax
  0002d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00032	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?FindItem@CRealCounterMng@@QAEPAU__POSITION@@PBD@Z
  00037	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?FindItem@CRealCounterMng@@QAEPAU__POSITION@@PBD@Z ENDP	; CRealCounterMng::FindItem
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
;	COMDAT ??_G?$CList@VCRealCounterItem@@AAV1@@@UAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_G?$CList@VCRealCounterItem@@AAV1@@@UAEPAXI@Z PROC	; CList<CRealCounterItem,CRealCounterItem &>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_G?$CList@VCRealCounterItem@@AAV1@@@UAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 878  : {

  00025	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0002c	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CList@VCRealCounterItem@@AAV1@@@6B@

; 879  : 	RemoveAll();

  00032	e8 00 00 00 00	 call	 ?RemoveAll@?$CList@VCRealCounterItem@@AAV1@@@QAEXXZ ; CList<CRealCounterItem,CRealCounterItem &>::RemoveAll
  00037	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  0003a	a8 01		 test	 al, 1
  0003c	74 2c		 je	 SHORT $LN12@scalar
  0003e	a8 04		 test	 al, 4
  00040	75 1d		 jne	 SHORT $LN3@scalar
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 112  : 	{ ::operator delete(p); }

  00042	56		 push	 esi
  00043	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00048	83 c4 04	 add	 esp, 4
  0004b	8b c6		 mov	 eax, esi
  0004d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00050	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00057	59		 pop	 ecx
  00058	5e		 pop	 esi
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c2 04 00	 ret	 4
$LN3@scalar:
  0005f	6a 1c		 push	 28			; 0000001cH
  00061	56		 push	 esi
  00062	e8 00 00 00 00	 call	 ?__global_delete@@YAXPAXI@Z ; __global_delete
  00067	83 c4 08	 add	 esp, 8
$LN12@scalar:
  0006a	8b c6		 mov	 eax, esi
  0006c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00076	59		 pop	 ecx
  00077	5e		 pop	 esi
  00078	8b e5		 mov	 esp, ebp
  0007a	5d		 pop	 ebp
  0007b	c2 04 00	 ret	 4
  0007e	cc		 int	 3
  0007f	cc		 int	 3
  00080	cc		 int	 3
  00081	cc		 int	 3
  00082	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??_G?$CList@VCRealCounterItem@@AAV1@@@UAEPAXI@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_G?$CList@VCRealCounterItem@@AAV1@@@UAEPAXI@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_G?$CList@VCRealCounterItem@@AAV1@@@UAEPAXI@Z ENDP	; CList<CRealCounterItem,CRealCounterItem &>::`scalar deleting destructor'
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ?Serialize@?$CList@VCRealCounterItem@@AAV1@@@UAEXAAVCArchive@@@Z
_TEXT	SEGMENT
_newData$2 = -32					; size = 8
_nNewCount$1$ = -24					; size = 4
_pData$1$ = -20						; size = 4
_pNode$1$ = -20						; size = 4
_nElementsLeft$1$ = -16					; size = 4
_this$1$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_ar$ = 8						; size = 4
?Serialize@?$CList@VCRealCounterItem@@AAV1@@@UAEXAAVCArchive@@@Z PROC ; CList<CRealCounterItem,CRealCounterItem &>::Serialize, COMDAT
; _this$ = ecx

; 1169 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Serialize@?$CList@VCRealCounterItem@@AAV1@@@UAEXAAVCArchive@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 14	 sub	 esp, 20			; 00000014H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b d9		 mov	 ebx, ecx
  0002a	89 5d f0	 mov	 DWORD PTR _this$1$[ebp], ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 212  : 	{ return (m_nMode & CArchive::load) == 0; }

  0002d	8b 4d 08	 mov	 ecx, DWORD PTR _ar$[ebp]
  00030	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  00033	f7 d0		 not	 eax
  00035	a8 01		 test	 al, 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 1174 : 	if (ar.IsStoring())

  00037	0f 84 b9 00 00
	00		 je	 $LN7@Serialize

; 1175 : 	{
; 1176 : 		ar.WriteCount(m_nCount);

  0003d	ff 73 0c	 push	 DWORD PTR [ebx+12]
  00040	e8 00 00 00 00	 call	 ?WriteCount@CArchive@@QAEXK@Z ; CArchive::WriteCount

; 1177 : 		for (CNode* pNode = m_pNodeHead; pNode != NULL; pNode = pNode->pNext)

  00045	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00048	89 45 ec	 mov	 DWORD PTR _pNode$1$[ebp], eax
  0004b	85 c0		 test	 eax, eax
  0004d	0f 84 7a 01 00
	00		 je	 $LN69@Serialize
$LL4@Serialize:

; 1178 : 		{
; 1179 : 			ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 1180 : 			TYPE* pData;
; 1181 : 			/*
; 1182 : 			 * in some cases the & operator might be overloaded, and we cannot use it to obtain
; 1183 : 			 * the address of a given object.  We then use the following trick to get the address
; 1184 : 			 */
; 1185 : 			pData = reinterpret_cast< TYPE* >( &reinterpret_cast< int& >( static_cast< TYPE& >( pNode->data ) ) );

  00053	8d 70 08	 lea	 esi, DWORD PTR [eax+8]

; 68   : 	ENSURE(nCount == 0 || pElements != NULL);

  00056	85 f6		 test	 esi, esi
  00058	0f 84 8c 01 00
	00		 je	 $LN61@Serialize
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 212  : 	{ return (m_nMode & CArchive::load) == 0; }

  0005e	8b 4d 08	 mov	 ecx, DWORD PTR _ar$[ebp]
  00061	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  00064	f7 d0		 not	 eax
  00066	a8 01		 test	 al, 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 73   : 	if (ar.IsStoring())

  00068	74 33		 je	 SHORT $LN22@Serialize

; 74   : 	{
; 75   : 		TYPE* pData;
; 76   : 		UINT_PTR nElementsLeft;
; 77   : 
; 78   : 		nElementsLeft = nCount;

  0006a	b8 01 00 00 00	 mov	 eax, 1
  0006f	89 45 f0	 mov	 DWORD PTR _nElementsLeft$1$[ebp], eax
$LL17@Serialize:

; 80   : 		while( nElementsLeft > 0 )
; 81   : 		{
; 82   : 			UINT nElementsToWrite;
; 83   : 
; 84   : 			nElementsToWrite = UINT(__min(nElementsLeft, INT_MAX/sizeof(TYPE)));

  00072	bb ff ff ff 0f	 mov	 ebx, 268435455		; 0fffffffH
  00077	3b c3		 cmp	 eax, ebx
  00079	0f 42 d8	 cmovb	 ebx, eax

; 85   : 			ar.Write(pData, nElementsToWrite*sizeof(TYPE));

  0007c	8d 3c dd 00 00
	00 00		 lea	 edi, DWORD PTR [ebx*8]
  00083	57		 push	 edi
  00084	56		 push	 esi
  00085	e8 00 00 00 00	 call	 ?Write@CArchive@@QAEXPBXI@Z ; CArchive::Write

; 86   : 			nElementsLeft -= nElementsToWrite;

  0008a	8b 45 f0	 mov	 eax, DWORD PTR _nElementsLeft$1$[ebp]

; 87   : 			pData += nElementsToWrite;

  0008d	03 f7		 add	 esi, edi
  0008f	8b 4d 08	 mov	 ecx, DWORD PTR _ar$[ebp]
  00092	2b c3		 sub	 eax, ebx
  00094	89 45 f0	 mov	 DWORD PTR _nElementsLeft$1$[ebp], eax
  00097	85 c0		 test	 eax, eax
  00099	75 d7		 jne	 SHORT $LL17@Serialize

; 88   : 		}
; 89   : 	}

  0009b	eb 35		 jmp	 SHORT $LN2@Serialize
$LN22@Serialize:

; 90   : 	else
; 91   : 	{
; 92   : 		TYPE* pData;
; 93   : 		UINT_PTR nElementsLeft;
; 94   : 
; 95   : 		nElementsLeft = nCount;

  0009d	bf 01 00 00 00	 mov	 edi, 1
$LL19@Serialize:

; 98   : 		{
; 99   : 			UINT nElementsToRead;
; 100  : 
; 101  : 			nElementsToRead = UINT(__min(nElementsLeft, INT_MAX/sizeof(TYPE)));

  000a2	bb ff ff ff 0f	 mov	 ebx, 268435455		; 0fffffffH
  000a7	3b fb		 cmp	 edi, ebx
  000a9	0f 42 df	 cmovb	 ebx, edi

; 102  : 			ar.EnsureRead(pData, nElementsToRead*sizeof(TYPE));

  000ac	8d 04 dd 00 00
	00 00		 lea	 eax, DWORD PTR [ebx*8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 399  : 	UINT nRead=Read(lpBuf, nCount);

  000b3	50		 push	 eax
  000b4	56		 push	 esi
  000b5	e8 00 00 00 00	 call	 ?Read@CArchive@@QAEIPAXI@Z ; CArchive::Read

; 400  : 	if(nRead!=nCount)

  000ba	8d 0c dd 00 00
	00 00		 lea	 ecx, DWORD PTR [ebx*8]
  000c1	3b c1		 cmp	 eax, ecx
  000c3	0f 85 18 01 00
	00		 jne	 $LN60@Serialize
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 97   : 		while( nElementsLeft > 0 )

  000c9	03 f1		 add	 esi, ecx
  000cb	8b 4d 08	 mov	 ecx, DWORD PTR _ar$[ebp]

; 103  : 			nElementsLeft -= nElementsToRead;

  000ce	2b fb		 sub	 edi, ebx
  000d0	75 d0		 jne	 SHORT $LL19@Serialize
$LN2@Serialize:

; 1177 : 		for (CNode* pNode = m_pNodeHead; pNode != NULL; pNode = pNode->pNext)

  000d2	8b 45 ec	 mov	 eax, DWORD PTR _pNode$1$[ebp]
  000d5	8b 00		 mov	 eax, DWORD PTR [eax]
  000d7	89 45 ec	 mov	 DWORD PTR _pNode$1$[ebp], eax
  000da	85 c0		 test	 eax, eax
  000dc	0f 85 71 ff ff
	ff		 jne	 $LL4@Serialize

; 1198 : 	}
; 1199 : }

  000e2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000e5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ec	59		 pop	 ecx
  000ed	5f		 pop	 edi
  000ee	5e		 pop	 esi
  000ef	5b		 pop	 ebx
  000f0	8b e5		 mov	 esp, ebp
  000f2	5d		 pop	 ebp
  000f3	c2 04 00	 ret	 4
$LN7@Serialize:

; 1186 : 			SerializeElements<TYPE>(ar, pData, 1);
; 1187 : 		}
; 1188 : 	}
; 1189 : 	else
; 1190 : 	{
; 1191 : 		DWORD_PTR nNewCount = ar.ReadCount();

  000f6	e8 00 00 00 00	 call	 ?ReadCount@CArchive@@QAEKXZ ; CArchive::ReadCount

; 1192 : 		while (nNewCount--)

  000fb	85 c0		 test	 eax, eax
  000fd	0f 84 ca 00 00
	00		 je	 $LN69@Serialize
$LL5@Serialize:

; 1194 : 			TYPE newData[1];

  00103	68 00 00 00 00	 push	 OFFSET ??1CRealCounterItem@@QAE@XZ
  00108	68 00 00 00 00	 push	 OFFSET ??0CRealCounterItem@@QAE@XZ ; CRealCounterItem::CRealCounterItem
  0010d	48		 dec	 eax
  0010e	6a 01		 push	 1
  00110	89 45 e8	 mov	 DWORD PTR _nNewCount$1$[ebp], eax
  00113	8d 45 e0	 lea	 eax, DWORD PTR _newData$2[ebp]
  00116	6a 08		 push	 8
  00118	50		 push	 eax
  00119	e8 00 00 00 00	 call	 ??_L@YGXPAXIIP6EX0@Z1@Z
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 212  : 	{ return (m_nMode & CArchive::load) == 0; }

  0011e	8b 4d 08	 mov	 ecx, DWORD PTR _ar$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 1194 : 			TYPE newData[1];

  00121	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 212  : 	{ return (m_nMode & CArchive::load) == 0; }

  00128	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  0012b	f7 d0		 not	 eax
  0012d	a8 01		 test	 al, 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 73   : 	if (ar.IsStoring())

  0012f	74 38		 je	 SHORT $LN43@Serialize

; 79   : 		pData = pElements;

  00131	8d 45 e0	 lea	 eax, DWORD PTR _newData$2[ebp]
  00134	bb 01 00 00 00	 mov	 ebx, 1
  00139	89 45 ec	 mov	 DWORD PTR _pData$1$[ebp], eax
  0013c	0f 1f 40 00	 npad	 4
$LL38@Serialize:

; 80   : 		while( nElementsLeft > 0 )
; 81   : 		{
; 82   : 			UINT nElementsToWrite;
; 83   : 
; 84   : 			nElementsToWrite = UINT(__min(nElementsLeft, INT_MAX/sizeof(TYPE)));

  00140	bf ff ff ff 0f	 mov	 edi, 268435455		; 0fffffffH
  00145	3b df		 cmp	 ebx, edi
  00147	0f 42 fb	 cmovb	 edi, ebx

; 85   : 			ar.Write(pData, nElementsToWrite*sizeof(TYPE));

  0014a	8d 34 fd 00 00
	00 00		 lea	 esi, DWORD PTR [edi*8]
  00151	56		 push	 esi
  00152	50		 push	 eax
  00153	e8 00 00 00 00	 call	 ?Write@CArchive@@QAEXPBXI@Z ; CArchive::Write

; 87   : 			pData += nElementsToWrite;

  00158	8b 45 ec	 mov	 eax, DWORD PTR _pData$1$[ebp]
  0015b	8b 4d 08	 mov	 ecx, DWORD PTR _ar$[ebp]
  0015e	03 c6		 add	 eax, esi
  00160	89 45 ec	 mov	 DWORD PTR _pData$1$[ebp], eax
  00163	2b df		 sub	 ebx, edi
  00165	75 d9		 jne	 SHORT $LL38@Serialize

; 88   : 		}
; 89   : 	}

  00167	eb 34		 jmp	 SHORT $LN41@Serialize
$LN43@Serialize:

; 90   : 	else
; 91   : 	{
; 92   : 		TYPE* pData;
; 93   : 		UINT_PTR nElementsLeft;
; 94   : 
; 95   : 		nElementsLeft = nCount;

  00169	be 01 00 00 00	 mov	 esi, 1

; 96   : 		pData = pElements;

  0016e	8d 7d e0	 lea	 edi, DWORD PTR _newData$2[ebp]
$LL40@Serialize:

; 98   : 		{
; 99   : 			UINT nElementsToRead;
; 100  : 
; 101  : 			nElementsToRead = UINT(__min(nElementsLeft, INT_MAX/sizeof(TYPE)));

  00171	bb ff ff ff 0f	 mov	 ebx, 268435455		; 0fffffffH
  00176	3b f3		 cmp	 esi, ebx
  00178	0f 42 de	 cmovb	 ebx, esi

; 102  : 			ar.EnsureRead(pData, nElementsToRead*sizeof(TYPE));

  0017b	8d 04 dd 00 00
	00 00		 lea	 eax, DWORD PTR [ebx*8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 399  : 	UINT nRead=Read(lpBuf, nCount);

  00182	50		 push	 eax
  00183	57		 push	 edi
  00184	e8 00 00 00 00	 call	 ?Read@CArchive@@QAEIPAXI@Z ; CArchive::Read

; 400  : 	if(nRead!=nCount)

  00189	8d 0c dd 00 00
	00 00		 lea	 ecx, DWORD PTR [ebx*8]
  00190	3b c1		 cmp	 eax, ecx
  00192	75 4d		 jne	 SHORT $LN60@Serialize
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 97   : 		while( nElementsLeft > 0 )

  00194	03 f9		 add	 edi, ecx
  00196	8b 4d 08	 mov	 ecx, DWORD PTR _ar$[ebp]

; 103  : 			nElementsLeft -= nElementsToRead;

  00199	2b f3		 sub	 esi, ebx
  0019b	75 d4		 jne	 SHORT $LL40@Serialize
$LN41@Serialize:

; 1195 : 			SerializeElements<TYPE>(ar, newData, 1);
; 1196 : 			AddTail(newData[0]);

  0019d	8b 4d f0	 mov	 ecx, DWORD PTR _this$1$[ebp]
  001a0	8d 45 e0	 lea	 eax, DWORD PTR _newData$2[ebp]
  001a3	50		 push	 eax
  001a4	e8 00 00 00 00	 call	 ?AddTail@?$CList@VCRealCounterItem@@AAV1@@@QAEPAU__POSITION@@AAVCRealCounterItem@@@Z ; CList<CRealCounterItem,CRealCounterItem &>::AddTail

; 1197 : 		}

  001a9	68 00 00 00 00	 push	 OFFSET ??1CRealCounterItem@@QAE@XZ
  001ae	6a 01		 push	 1
  001b0	6a 08		 push	 8
  001b2	8d 45 e0	 lea	 eax, DWORD PTR _newData$2[ebp]
  001b5	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  001bc	50		 push	 eax
  001bd	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  001c2	8b 45 e8	 mov	 eax, DWORD PTR _nNewCount$1$[ebp]
  001c5	85 c0		 test	 eax, eax
  001c7	0f 85 36 ff ff
	ff		 jne	 $LL5@Serialize
$LN69@Serialize:

; 1198 : 	}
; 1199 : }

  001cd	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001d0	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001d7	59		 pop	 ecx
  001d8	5f		 pop	 edi
  001d9	5e		 pop	 esi
  001da	5b		 pop	 ebx
  001db	8b e5		 mov	 esp, ebp
  001dd	5d		 pop	 ebp
  001de	c2 04 00	 ret	 4
$LN60@Serialize:
  001e1	6a 00		 push	 0
  001e3	6a 03		 push	 3
  001e5	e8 00 00 00 00	 call	 ?AfxThrowArchiveException@@YGXHPBD@Z ; AfxThrowArchiveException
$LN61@Serialize:

; 68   : 	ENSURE(nCount == 0 || pElements != NULL);

  001ea	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN87@Serialize:
  001ef	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Serialize@?$CList@VCRealCounterItem@@AAV1@@@UAEXAAVCArchive@@@Z$0:
  00000	68 00 00 00 00	 push	 OFFSET ??1CRealCounterItem@@QAE@XZ
  00005	6a 01		 push	 1
  00007	6a 08		 push	 8
  00009	8d 45 e0	 lea	 eax, DWORD PTR _newData$2[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  00012	c3		 ret	 0
  00013	cc		 int	 3
  00014	cc		 int	 3
  00015	cc		 int	 3
  00016	cc		 int	 3
  00017	cc		 int	 3
__ehhandler$?Serialize@?$CList@VCRealCounterItem@@AAV1@@@UAEXAAVCArchive@@@Z:
  00018	90		 npad	 1
  00019	90		 npad	 1
  0001a	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001e	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00021	8b 4a dc	 mov	 ecx, DWORD PTR [edx-36]
  00024	33 c8		 xor	 ecx, eax
  00026	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Serialize@?$CList@VCRealCounterItem@@AAV1@@@UAEXAAVCArchive@@@Z
  00030	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Serialize@?$CList@VCRealCounterItem@@AAV1@@@UAEXAAVCArchive@@@Z ENDP ; CList<CRealCounterItem,CRealCounterItem &>::Serialize
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ??1?$CList@VCRealCounterItem@@AAV1@@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$CList@VCRealCounterItem@@AAV1@@@UAE@XZ PROC	; CList<CRealCounterItem,CRealCounterItem &>::~CList<CRealCounterItem,CRealCounterItem &>, COMDAT
; _this$ = ecx

; 878  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$CList@VCRealCounterItem@@AAV1@@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00022	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CList@VCRealCounterItem@@AAV1@@@6B@

; 879  : 	RemoveAll();

  00028	e8 00 00 00 00	 call	 ?RemoveAll@?$CList@VCRealCounterItem@@AAV1@@@QAEXXZ ; CList<CRealCounterItem,CRealCounterItem &>::RemoveAll

; 880  : 	ASSERT(m_nCount == 0);
; 881  : }

  0002d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00030	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00037	59		 pop	 ecx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
  0003c	cc		 int	 3
  0003d	cc		 int	 3
  0003e	cc		 int	 3
  0003f	cc		 int	 3
  00040	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CList@VCRealCounterItem@@AAV1@@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$CList@VCRealCounterItem@@AAV1@@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$CList@VCRealCounterItem@@AAV1@@@UAE@XZ ENDP	; CList<CRealCounterItem,CRealCounterItem &>::~CList<CRealCounterItem,CRealCounterItem &>
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ?FreeNode@?$CList@VCRealCounterItem@@AAV1@@@IAEXPAUCNode@1@@Z
_TEXT	SEGMENT
_pNode$ = 8						; size = 4
?FreeNode@?$CList@VCRealCounterItem@@AAV1@@@IAEXPAUCNode@1@@Z PROC ; CList<CRealCounterItem,CRealCounterItem &>::FreeNode, COMDAT
; _this$ = ecx

; 936  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 937  : 	pNode->data.~TYPE();

  00004	8b 75 08	 mov	 esi, DWORD PTR _pNode$[ebp]
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
  0000a	8d 4e 08	 lea	 ecx, DWORD PTR [esi+8]
  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 938  : 	pNode->pNext = m_pNodeFree;

  00013	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00016	89 06		 mov	 DWORD PTR [esi], eax

; 939  : 	m_pNodeFree = pNode;
; 940  : 	m_nCount--;

  00018	83 47 0c ff	 add	 DWORD PTR [edi+12], -1
  0001c	89 77 10	 mov	 DWORD PTR [edi+16], esi

; 941  : 	ASSERT(m_nCount >= 0);  // make sure we don't underflow
; 942  : 
; 943  : 	// if no more elements, cleanup completely
; 944  : 	if (m_nCount == 0)

  0001f	75 07		 jne	 SHORT $LN2@FreeNode

; 945  : 		RemoveAll();

  00021	8b cf		 mov	 ecx, edi
  00023	e8 00 00 00 00	 call	 ?RemoveAll@?$CList@VCRealCounterItem@@AAV1@@@QAEXXZ ; CList<CRealCounterItem,CRealCounterItem &>::RemoveAll
$LN2@FreeNode:

; 946  : }

  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
?FreeNode@?$CList@VCRealCounterItem@@AAV1@@@IAEXPAUCNode@1@@Z ENDP ; CList<CRealCounterItem,CRealCounterItem &>::FreeNode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\DrCommon\PartnerMng\RealCounter.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\DrCommon\PartnerMng\RealCounter.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ?NewNode@?$CList@VCRealCounterItem@@AAV1@@@IAEPAUCNode@1@PAU21@0@Z
_TEXT	SEGMENT
_pPrev$ = 8						; size = 4
_pNext$ = 12						; size = 4
?NewNode@?$CList@VCRealCounterItem@@AAV1@@@IAEPAUCNode@1@PAU21@0@Z PROC ; CList<CRealCounterItem,CRealCounterItem &>::NewNode, COMDAT
; _this$ = ecx

; 901  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	57		 push	 edi

; 902  : 	if (m_pNodeFree == NULL)

  00007	83 7e 10 00	 cmp	 DWORD PTR [esi+16], 0
  0000b	75 33		 jne	 SHORT $LN7@NewNode

; 903  : 	{
; 904  : 		// add another block
; 905  : 		CPlex* pNewBlock = CPlex::Create(m_pBlocks, m_nBlockSize,

  0000d	6a 10		 push	 16			; 00000010H
  0000f	ff 76 18	 push	 DWORD PTR [esi+24]
  00012	8d 46 14	 lea	 eax, DWORD PTR [esi+20]
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ?Create@CPlex@@SGPAU1@AAPAU1@II@Z ; CPlex::Create

; 906  : 				 sizeof(CNode));
; 907  : 
; 908  : 		// chain them into free list
; 909  : 		CNode* pNode = (CNode*) pNewBlock->data();
; 910  : 		// free in reverse order to make it easier to debug
; 911  : 		pNode += m_nBlockSize - 1;

  0001b	8b 56 18	 mov	 edx, DWORD PTR [esi+24]
  0001e	83 c0 08	 add	 eax, 8
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e1 04	 shl	 ecx, 4
  00026	83 c1 f0	 add	 ecx, -16		; fffffff0H
  00029	03 c1		 add	 eax, ecx

; 912  : 		for (INT_PTR i = m_nBlockSize-1; i >= 0; i--, pNode--)

  0002b	83 c2 ff	 add	 edx, -1
  0002e	78 10		 js	 SHORT $LN7@NewNode
$LL4@NewNode:

; 913  : 		{
; 914  : 			pNode->pNext = m_pNodeFree;

  00030	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00033	89 08		 mov	 DWORD PTR [eax], ecx

; 915  : 			m_pNodeFree = pNode;

  00035	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00038	83 e8 10	 sub	 eax, 16			; 00000010H
  0003b	83 ea 01	 sub	 edx, 1
  0003e	79 f0		 jns	 SHORT $LL4@NewNode
$LN7@NewNode:

; 916  : 		}
; 917  : 	}
; 918  : 	ENSURE(m_pNodeFree != NULL);  // we must have something

  00040	8b 7e 10	 mov	 edi, DWORD PTR [esi+16]
  00043	85 ff		 test	 edi, edi
  00045	74 2b		 je	 SHORT $LN19@NewNode

; 919  : 
; 920  : 	CList::CNode* pNode = m_pNodeFree;
; 921  : 	m_pNodeFree = m_pNodeFree->pNext;

  00047	8b 07		 mov	 eax, DWORD PTR [edi]

; 922  : 	pNode->pPrev = pPrev;

  00049	8b 4d 08	 mov	 ecx, DWORD PTR _pPrev$[ebp]
  0004c	89 46 10	 mov	 DWORD PTR [esi+16], eax
  0004f	89 4f 04	 mov	 DWORD PTR [edi+4], ecx

; 923  : 	pNode->pNext = pNext;

  00052	8b 4d 0c	 mov	 ecx, DWORD PTR _pNext$[ebp]
  00055	89 0f		 mov	 DWORD PTR [edi], ecx
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\DrCommon\PartnerMng\RealCounter.h

; 7    : 	CRealCounterItem():m_nCount(0) {}

  00057	8d 4f 08	 lea	 ecx, DWORD PTR [edi+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 924  : 	m_nCount++;

  0005a	ff 46 0c	 inc	 DWORD PTR [esi+12]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\DrCommon\PartnerMng\RealCounter.h

; 7    : 	CRealCounterItem():m_nCount(0) {}

  0005d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00063	c7 47 0c 00 00
	00 00		 mov	 DWORD PTR [edi+12], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 931  : 	return pNode;

  0006a	8b c7		 mov	 eax, edi
  0006c	5f		 pop	 edi
  0006d	5e		 pop	 esi

; 932  : }

  0006e	5d		 pop	 ebp
  0006f	c2 08 00	 ret	 8
$LN19@NewNode:

; 916  : 		}
; 917  : 	}
; 918  : 	ENSURE(m_pNodeFree != NULL);  // we must have something

  00072	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN17@NewNode:
  00077	cc		 int	 3
?NewNode@?$CList@VCRealCounterItem@@AAV1@@@IAEPAUCNode@1@PAU21@0@Z ENDP ; CList<CRealCounterItem,CRealCounterItem &>::NewNode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ?RemoveAt@?$CList@VCRealCounterItem@@AAV1@@@QAEXPAU__POSITION@@@Z
_TEXT	SEGMENT
_position$ = 8						; size = 4
?RemoveAt@?$CList@VCRealCounterItem@@AAV1@@@QAEXPAU__POSITION@@@Z PROC ; CList<CRealCounterItem,CRealCounterItem &>::RemoveAt, COMDAT
; _this$ = ecx

; 1100 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1101 : 	ASSERT_VALID(this);
; 1102 : 
; 1103 : 	CNode* pOldNode = (CNode*) position;
; 1104 : 	ASSERT(AfxIsValidAddress(pOldNode, sizeof(CNode)));
; 1105 : 
; 1106 : 	// remove pOldNode from list
; 1107 : 	if (pOldNode == m_pNodeHead)

  00004	8b 75 08	 mov	 esi, DWORD PTR _position$[ebp]
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
  0000a	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0000c	3b 77 04	 cmp	 esi, DWORD PTR [edi+4]
  0000f	75 05		 jne	 SHORT $LN2@RemoveAt

; 1108 : 	{
; 1109 : 		m_pNodeHead = pOldNode->pNext;

  00011	89 4f 04	 mov	 DWORD PTR [edi+4], ecx

; 1110 : 	}

  00014	eb 05		 jmp	 SHORT $LN3@RemoveAt
$LN2@RemoveAt:

; 1111 : 	else
; 1112 : 	{
; 1113 : 		ASSERT(AfxIsValidAddress(pOldNode->pPrev, sizeof(CNode)));
; 1114 : 		pOldNode->pPrev->pNext = pOldNode->pNext;

  00016	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00019	89 08		 mov	 DWORD PTR [eax], ecx
$LN3@RemoveAt:

; 1115 : 	}
; 1116 : 	if (pOldNode == m_pNodeTail)

  0001b	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0001e	3b 77 08	 cmp	 esi, DWORD PTR [edi+8]
  00021	75 05		 jne	 SHORT $LN4@RemoveAt

; 1117 : 	{
; 1118 : 		m_pNodeTail = pOldNode->pPrev;

  00023	89 4f 08	 mov	 DWORD PTR [edi+8], ecx

; 1119 : 	}

  00026	eb 05		 jmp	 SHORT $LN5@RemoveAt
$LN4@RemoveAt:

; 1120 : 	else
; 1121 : 	{
; 1122 : 		ASSERT(AfxIsValidAddress(pOldNode->pNext, sizeof(CNode)));
; 1123 : 		pOldNode->pNext->pPrev = pOldNode->pPrev;

  00028	8b 06		 mov	 eax, DWORD PTR [esi]
  0002a	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN5@RemoveAt:

; 937  : 	pNode->data.~TYPE();

  0002d	8d 4e 08	 lea	 ecx, DWORD PTR [esi+8]
  00030	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 938  : 	pNode->pNext = m_pNodeFree;

  00036	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00039	89 06		 mov	 DWORD PTR [esi], eax

; 939  : 	m_pNodeFree = pNode;
; 940  : 	m_nCount--;

  0003b	83 47 0c ff	 add	 DWORD PTR [edi+12], -1
  0003f	89 77 10	 mov	 DWORD PTR [edi+16], esi

; 941  : 	ASSERT(m_nCount >= 0);  // make sure we don't underflow
; 942  : 
; 943  : 	// if no more elements, cleanup completely
; 944  : 	if (m_nCount == 0)

  00042	75 07		 jne	 SHORT $LN8@RemoveAt

; 945  : 		RemoveAll();

  00044	8b cf		 mov	 ecx, edi
  00046	e8 00 00 00 00	 call	 ?RemoveAll@?$CList@VCRealCounterItem@@AAV1@@@QAEXXZ ; CList<CRealCounterItem,CRealCounterItem &>::RemoveAll
$LN8@RemoveAt:
  0004b	5f		 pop	 edi

; 1124 : 	}
; 1125 : 	FreeNode(pOldNode);
; 1126 : }

  0004c	5e		 pop	 esi
  0004d	5d		 pop	 ebp
  0004e	c2 04 00	 ret	 4
?RemoveAt@?$CList@VCRealCounterItem@@AAV1@@@QAEXPAU__POSITION@@@Z ENDP ; CList<CRealCounterItem,CRealCounterItem &>::RemoveAt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ?RemoveAll@?$CList@VCRealCounterItem@@AAV1@@@QAEXXZ
_TEXT	SEGMENT
?RemoveAll@?$CList@VCRealCounterItem@@AAV1@@@QAEXXZ PROC ; CList<CRealCounterItem,CRealCounterItem &>::RemoveAll, COMDAT
; _this$ = ecx

; 862  : {

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f9		 mov	 edi, ecx

; 863  : 	ASSERT_VALID(this);
; 864  : 
; 865  : 	// destroy elements
; 866  : 	CNode* pNode;
; 867  : 	for (pNode = m_pNodeHead; pNode != NULL; pNode = pNode->pNext)

  00004	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
  00007	85 f6		 test	 esi, esi
  00009	74 14		 je	 SHORT $LN3@RemoveAll
  0000b	0f 1f 44 00 00	 npad	 5
$LL4@RemoveAll:

; 868  : 		pNode->data.~TYPE();

  00010	8d 4e 08	 lea	 ecx, DWORD PTR [esi+8]
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00019	8b 36		 mov	 esi, DWORD PTR [esi]
  0001b	85 f6		 test	 esi, esi
  0001d	75 f1		 jne	 SHORT $LL4@RemoveAll
$LN3@RemoveAll:

; 869  : 
; 870  : 	m_nCount = 0;
; 871  : 	m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
; 872  : 	m_pBlocks->FreeDataChain();

  0001f	8b 4f 14	 mov	 ecx, DWORD PTR [edi+20]
  00022	c7 47 0c 00 00
	00 00		 mov	 DWORD PTR [edi+12], 0
  00029	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0
  00030	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0
  00037	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0
  0003e	e8 00 00 00 00	 call	 ?FreeDataChain@CPlex@@QAEXXZ ; CPlex::FreeDataChain

; 873  : 	m_pBlocks = NULL;

  00043	c7 47 14 00 00
	00 00		 mov	 DWORD PTR [edi+20], 0
  0004a	5f		 pop	 edi
  0004b	5e		 pop	 esi

; 874  : }

  0004c	c3		 ret	 0
?RemoveAll@?$CList@VCRealCounterItem@@AAV1@@@QAEXXZ ENDP ; CList<CRealCounterItem,CRealCounterItem &>::RemoveAll
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\DrCommon\PartnerMng\RealCounter.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\DrCommon\PartnerMng\RealCounter.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\DrCommon\PartnerMng\RealCounter.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ?AddTail@?$CList@VCRealCounterItem@@AAV1@@@QAEPAU__POSITION@@AAVCRealCounterItem@@@Z
_TEXT	SEGMENT
_pNode$1$ = -4						; size = 4
_newElement$ = 8					; size = 4
?AddTail@?$CList@VCRealCounterItem@@AAV1@@@QAEPAU__POSITION@@AAVCRealCounterItem@@@Z PROC ; CList<CRealCounterItem,CRealCounterItem &>::AddTail, COMDAT
; _this$ = ecx

; 965  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	57		 push	 edi

; 902  : 	if (m_pNodeFree == NULL)

  00008	83 7e 10 00	 cmp	 DWORD PTR [esi+16], 0

; 966  : 	ASSERT_VALID(this);
; 967  : 
; 968  : 	CNode* pNewNode = NewNode(m_pNodeTail, NULL);

  0000c	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]

; 902  : 	if (m_pNodeFree == NULL)

  0000f	75 33		 jne	 SHORT $LN11@AddTail

; 903  : 	{
; 904  : 		// add another block
; 905  : 		CPlex* pNewBlock = CPlex::Create(m_pBlocks, m_nBlockSize,

  00011	6a 10		 push	 16			; 00000010H
  00013	ff 76 18	 push	 DWORD PTR [esi+24]
  00016	8d 46 14	 lea	 eax, DWORD PTR [esi+20]
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 ?Create@CPlex@@SGPAU1@AAPAU1@II@Z ; CPlex::Create

; 906  : 				 sizeof(CNode));
; 907  : 
; 908  : 		// chain them into free list
; 909  : 		CNode* pNode = (CNode*) pNewBlock->data();
; 910  : 		// free in reverse order to make it easier to debug
; 911  : 		pNode += m_nBlockSize - 1;

  0001f	8b 56 18	 mov	 edx, DWORD PTR [esi+24]
  00022	83 c0 08	 add	 eax, 8
  00025	8b ca		 mov	 ecx, edx
  00027	c1 e1 04	 shl	 ecx, 4
  0002a	83 c1 f0	 add	 ecx, -16		; fffffff0H
  0002d	03 c8		 add	 ecx, eax

; 912  : 		for (INT_PTR i = m_nBlockSize-1; i >= 0; i--, pNode--)

  0002f	83 c2 ff	 add	 edx, -1
  00032	78 10		 js	 SHORT $LN11@AddTail
$LL8@AddTail:

; 913  : 		{
; 914  : 			pNode->pNext = m_pNodeFree;

  00034	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00037	89 01		 mov	 DWORD PTR [ecx], eax

; 915  : 			m_pNodeFree = pNode;

  00039	89 4e 10	 mov	 DWORD PTR [esi+16], ecx
  0003c	83 e9 10	 sub	 ecx, 16			; 00000010H
  0003f	83 ea 01	 sub	 edx, 1
  00042	79 f0		 jns	 SHORT $LL8@AddTail
$LN11@AddTail:

; 916  : 		}
; 917  : 	}
; 918  : 	ENSURE(m_pNodeFree != NULL);  // we must have something

  00044	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00047	89 4d fc	 mov	 DWORD PTR _pNode$1$[ebp], ecx
  0004a	85 c9		 test	 ecx, ecx
  0004c	74 5c		 je	 SHORT $LN26@AddTail

; 919  : 
; 920  : 	CList::CNode* pNode = m_pNodeFree;
; 921  : 	m_pNodeFree = m_pNodeFree->pNext;

  0004e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00050	53		 push	 ebx
  00051	89 46 10	 mov	 DWORD PTR [esi+16], eax

; 925  : 	ASSERT(m_nCount > 0);  // make sure we don't overflow
; 926  : 
; 927  : #pragma push_macro("new")
; 928  : #undef new
; 929  : 	::new( (void*)( &pNode->data ) ) TYPE;

  00054	8d 59 08	 lea	 ebx, DWORD PTR [ecx+8]
  00057	89 79 04	 mov	 DWORD PTR [ecx+4], edi
  0005a	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\DrCommon\PartnerMng\RealCounter.h

; 7    : 	CRealCounterItem():m_nCount(0) {}

  00060	8b cb		 mov	 ecx, ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 924  : 	m_nCount++;

  00062	ff 46 0c	 inc	 DWORD PTR [esi+12]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\DrCommon\PartnerMng\RealCounter.h

; 7    : 	CRealCounterItem():m_nCount(0) {}

  00065	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 969  : 	pNewNode->data = newElement;

  0006b	8b 7d 08	 mov	 edi, DWORD PTR _newElement$[ebp]
  0006e	8b cb		 mov	 ecx, ebx
  00070	57		 push	 edi
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\DrCommon\PartnerMng\RealCounter.h

; 7    : 	CRealCounterItem():m_nCount(0) {}

  00071	c7 43 04 00 00
	00 00		 mov	 DWORD PTR [ebx+4], 0
  00078	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
  0007e	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00081	89 43 04	 mov	 DWORD PTR [ebx+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 970  : 	if (m_pNodeTail != NULL)

  00084	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00087	8b 45 fc	 mov	 eax, DWORD PTR _pNode$1$[ebp]
  0008a	5b		 pop	 ebx
  0008b	85 c9		 test	 ecx, ecx
  0008d	74 0d		 je	 SHORT $LN2@AddTail

; 971  : 		m_pNodeTail->pNext = pNewNode;

  0008f	89 01		 mov	 DWORD PTR [ecx], eax

; 972  : 	else
; 973  : 		m_pNodeHead = pNewNode;
; 974  : 	m_pNodeTail = pNewNode;
; 975  : 	return (POSITION) pNewNode;

  00091	5f		 pop	 edi
  00092	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00095	5e		 pop	 esi

; 976  : }

  00096	8b e5		 mov	 esp, ebp
  00098	5d		 pop	 ebp
  00099	c2 04 00	 ret	 4
$LN2@AddTail:

; 972  : 	else
; 973  : 		m_pNodeHead = pNewNode;
; 974  : 	m_pNodeTail = pNewNode;
; 975  : 	return (POSITION) pNewNode;

  0009c	5f		 pop	 edi
  0009d	89 46 04	 mov	 DWORD PTR [esi+4], eax
  000a0	89 46 08	 mov	 DWORD PTR [esi+8], eax
  000a3	5e		 pop	 esi

; 976  : }

  000a4	8b e5		 mov	 esp, ebp
  000a6	5d		 pop	 ebp
  000a7	c2 04 00	 ret	 4
$LN26@AddTail:

; 918  : 	ENSURE(m_pNodeFree != NULL);  // we must have something

  000aa	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN24@AddTail:
  000af	cc		 int	 3
?AddTail@?$CList@VCRealCounterItem@@AAV1@@@QAEPAU__POSITION@@AAVCRealCounterItem@@@Z ENDP ; CList<CRealCounterItem,CRealCounterItem &>::AddTail
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ??0?$CList@VCRealCounterItem@@AAV1@@@QAE@H@Z
_TEXT	SEGMENT
_nBlockSize$ = 8					; size = 4
??0?$CList@VCRealCounterItem@@AAV1@@@QAE@H@Z PROC	; CList<CRealCounterItem,CRealCounterItem &>::CList<CRealCounterItem,CRealCounterItem &>, COMDAT
; _this$ = ecx

; 851  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 852  : 	ASSERT(nBlockSize > 0);
; 853  : 
; 854  : 	m_nCount = 0;
; 855  : 	m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
; 856  : 	m_pBlocks = NULL;
; 857  : 	m_nBlockSize = nBlockSize;

  00003	8b 45 08	 mov	 eax, DWORD PTR _nBlockSize$[ebp]
  00006	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 858  : }

  00009	8b c1		 mov	 eax, ecx
  0000b	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CList@VCRealCounterItem@@AAV1@@@6B@
  00011	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0
  00018	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  0001f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00026	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0002d	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
??0?$CList@VCRealCounterItem@@AAV1@@@QAE@H@Z ENDP	; CList<CRealCounterItem,CRealCounterItem &>::CList<CRealCounterItem,CRealCounterItem &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\DrCommon\PartnerMng\RealCounter.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\DrCommon\PartnerMng\RealCounter.cpp
;	COMDAT ??1CRealCounterMng@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1CRealCounterMng@@QAE@XZ PROC				; CRealCounterMng::~CRealCounterMng, COMDAT
; _this$ = ecx

; 9    : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CRealCounterMng@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx

; 91   : 	m_itemList.RemoveAll();

  00025	e8 00 00 00 00	 call	 ?RemoveAll@?$CList@VCRealCounterItem@@AAV1@@@QAEXXZ ; CList<CRealCounterItem,CRealCounterItem &>::RemoveAll
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 879  : 	RemoveAll();

  0002a	8b ce		 mov	 ecx, esi
  0002c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00033	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CList@VCRealCounterItem@@AAV1@@@6B@
  00039	e8 00 00 00 00	 call	 ?RemoveAll@?$CList@VCRealCounterItem@@AAV1@@@QAEXXZ ; CList<CRealCounterItem,CRealCounterItem &>::RemoveAll
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\DrCommon\PartnerMng\RealCounter.cpp

; 11   : }

  0003e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00041	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00048	59		 pop	 ecx
  00049	5e		 pop	 esi
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
  0004e	cc		 int	 3
  0004f	cc		 int	 3
  00050	cc		 int	 3
  00051	cc		 int	 3
  00052	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1CRealCounterMng@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CRealCounterMng@@QAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CRealCounterMng@@QAE@XZ ENDP				; CRealCounterMng::~CRealCounterMng
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\DrCommon\PartnerMng\RealCounter.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\DrCommon\PartnerMng\RealCounter.cpp
;	COMDAT ??0CRealCounterMng@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CRealCounterMng@@QAE@XZ PROC				; CRealCounterMng::CRealCounterMng, COMDAT
; _this$ = ecx

; 5    : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 6    : }

  00007	8b c1		 mov	 eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 851  : {

  00009	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CList@VCRealCounterItem@@AAV1@@@6B@

; 852  : 	ASSERT(nBlockSize > 0);
; 853  : 
; 854  : 	m_nCount = 0;

  0000f	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 855  : 	m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;

  00016	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  0001d	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00024	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 856  : 	m_pBlocks = NULL;

  0002b	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 857  : 	m_nBlockSize = nBlockSize;

  00032	c7 41 18 0a 00
	00 00		 mov	 DWORD PTR [ecx+24], 10	; 0000000aH
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\DrCommon\PartnerMng\RealCounter.cpp

; 6    : }

  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
??0CRealCounterMng@@QAE@XZ ENDP				; CRealCounterMng::CRealCounterMng
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1CRealCounterItem@@QAE@XZ
_TEXT	SEGMENT
??1CRealCounterItem@@QAE@XZ PROC			; CRealCounterItem::~CRealCounterItem, COMDAT
; _this$ = ecx
  00000	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
??1CRealCounterItem@@QAE@XZ ENDP			; CRealCounterItem::~CRealCounterItem
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\DrCommon\PartnerMng\RealCounter.h
;	COMDAT ??0CRealCounterItem@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CRealCounterItem@@QAE@XZ PROC			; CRealCounterItem::CRealCounterItem, COMDAT
; _this$ = ecx

; 7    : 	CRealCounterItem():m_nCount(0) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	89 75 fc	 mov	 DWORD PTR _this$[ebp], esi
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00010	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00017	8b c6		 mov	 eax, esi
  00019	5e		 pop	 esi
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??0CRealCounterItem@@QAE@XZ ENDP			; CRealCounterItem::CRealCounterItem
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
;	COMDAT ?Dump@CObject@@UBEXAAVCDumpContext@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?Dump@CObject@@UBEXAAVCDumpContext@@@Z PROC		; CObject::Dump, COMDAT
; _this$ = ecx

; 122  : 	{ /* no dumping in release builds */ }

  00000	c2 04 00	 ret	 4
?Dump@CObject@@UBEXAAVCDumpContext@@@Z ENDP		; CObject::Dump
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
;	COMDAT ?AssertValid@CObject@@UBEXXZ
_TEXT	SEGMENT
?AssertValid@CObject@@UBEXXZ PROC			; CObject::AssertValid, COMDAT
; _this$ = ecx

; 120  : 	{ /* no asserts in release builds */ }

  00000	c2 00 00	 ret	 0
?AssertValid@CObject@@UBEXXZ ENDP			; CObject::AssertValid
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
;	COMDAT ?Serialize@CObject@@UAEXAAVCArchive@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?Serialize@CObject@@UAEXAAVCArchive@@@Z PROC		; CObject::Serialize, COMDAT
; _this$ = ecx

; 106  : 	{ /* CObject does not serialize anything by default */ }

  00000	c2 04 00	 ret	 4
?Serialize@CObject@@UAEXAAVCArchive@@@Z ENDP		; CObject::Serialize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
;	COMDAT ??1CObject@@UAE@XZ
_TEXT	SEGMENT
??1CObject@@UAE@XZ PROC					; CObject::~CObject, COMDAT
; _this$ = ecx

; 104  : 	{ }

  00000	c2 00 00	 ret	 0
??1CObject@@UAE@XZ ENDP					; CObject::~CObject
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\DrCommon\PartnerMng\RealCounter.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	c2 00 00	 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\DrCommon\PartnerMng\RealCounter.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

  00000	c2 00 00	 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
