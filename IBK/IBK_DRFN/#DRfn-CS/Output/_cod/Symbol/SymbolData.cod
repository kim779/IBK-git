; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30145.0 

	TITLE	D:\git\src\IBK\IBK_DRFN\#DRfn-CS\_Obj\Symbol\SymbolData.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0O@DMAKNGHI@ANALYSIS_TOOL@		; `string'
;	COMDAT ??_C@_0O@DMAKNGHI@ANALYSIS_TOOL@
CONST	SEGMENT
??_C@_0O@DMAKNGHI@ANALYSIS_TOOL@ DB 'ANALYSIS_TOOL', 00H ; `string'
CONST	ENDS
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	??1CObject@@UAE@XZ				; CObject::~CObject
PUBLIC	?Serialize@CObject@@UAEXAAVCArchive@@@Z		; CObject::Serialize
PUBLIC	?AssertValid@CObject@@UBEXXZ			; CObject::AssertValid
PUBLIC	?Dump@CObject@@UBEXAAVCDumpContext@@@Z		; CObject::Dump
PUBLIC	??0?$CList@PAVCDrawingSymbol@@PAV1@@@QAE@H@Z	; CList<CDrawingSymbol *,CDrawingSymbol *>::CList<CDrawingSymbol *,CDrawingSymbol *>
PUBLIC	?AddTail@?$CList@PAVCDrawingSymbol@@PAV1@@@QAEPAU__POSITION@@PAVCDrawingSymbol@@@Z ; CList<CDrawingSymbol *,CDrawingSymbol *>::AddTail
PUBLIC	?RemoveAll@?$CList@PAVCDrawingSymbol@@PAV1@@@QAEXXZ ; CList<CDrawingSymbol *,CDrawingSymbol *>::RemoveAll
PUBLIC	?NewNode@?$CList@PAVCDrawingSymbol@@PAV1@@@IAEPAUCNode@1@PAU21@0@Z ; CList<CDrawingSymbol *,CDrawingSymbol *>::NewNode
PUBLIC	??1?$CList@PAVCDrawingSymbol@@PAV1@@@UAE@XZ	; CList<CDrawingSymbol *,CDrawingSymbol *>::~CList<CDrawingSymbol *,CDrawingSymbol *>
PUBLIC	?Serialize@?$CList@PAVCDrawingSymbol@@PAV1@@@UAEXAAVCArchive@@@Z ; CList<CDrawingSymbol *,CDrawingSymbol *>::Serialize
PUBLIC	??_G?$CList@PAVCDrawingSymbol@@PAV1@@@UAEPAXI@Z	; CList<CDrawingSymbol *,CDrawingSymbol *>::`scalar deleting destructor'
PUBLIC	??_GCOrder@@UAEPAXI@Z				; COrder::`scalar deleting destructor'
PUBLIC	??1ILPCSTR133101@@QAE@XZ			; ILPCSTR133101::~ILPCSTR133101
PUBLIC	??0?$CList@PAVCDrawingSymbolColumn@@PAV1@@@QAE@H@Z ; CList<CDrawingSymbolColumn *,CDrawingSymbolColumn *>::CList<CDrawingSymbolColumn *,CDrawingSymbolColumn *>
PUBLIC	?AddTail@?$CList@PAVCDrawingSymbolColumn@@PAV1@@@QAEPAU__POSITION@@PAVCDrawingSymbolColumn@@@Z ; CList<CDrawingSymbolColumn *,CDrawingSymbolColumn *>::AddTail
PUBLIC	?RemoveAll@?$CList@PAVCDrawingSymbolColumn@@PAV1@@@QAEXXZ ; CList<CDrawingSymbolColumn *,CDrawingSymbolColumn *>::RemoveAll
PUBLIC	?NewNode@?$CList@PAVCDrawingSymbolColumn@@PAV1@@@IAEPAUCNode@1@PAU21@0@Z ; CList<CDrawingSymbolColumn *,CDrawingSymbolColumn *>::NewNode
PUBLIC	??1?$CList@PAVCDrawingSymbolColumn@@PAV1@@@UAE@XZ ; CList<CDrawingSymbolColumn *,CDrawingSymbolColumn *>::~CList<CDrawingSymbolColumn *,CDrawingSymbolColumn *>
PUBLIC	?Serialize@?$CList@PAVCDrawingSymbolColumn@@PAV1@@@UAEXAAVCArchive@@@Z ; CList<CDrawingSymbolColumn *,CDrawingSymbolColumn *>::Serialize
PUBLIC	??_G?$CList@PAVCDrawingSymbolColumn@@PAV1@@@UAEPAXI@Z ; CList<CDrawingSymbolColumn *,CDrawingSymbolColumn *>::`scalar deleting destructor'
PUBLIC	??_GCTree@@UAEPAXI@Z				; CTree::`scalar deleting destructor'
PUBLIC	??1CElementTree@@QAE@XZ				; CElementTree::~CElementTree
PUBLIC	??0CSymbolData@@QAE@XZ				; CSymbolData::CSymbolData
PUBLIC	??1CSymbolData@@QAE@XZ				; CSymbolData::~CSymbolData
PUBLIC	?GetMainBlock@CSymbolData@@QBEPAUIChartManager133101@@XZ ; CSymbolData::GetMainBlock
PUBLIC	?GetPacketManager@CSymbolData@@QBEPAUIPacketManager133101@@XZ ; CSymbolData::GetPacketManager
PUBLIC	?GetChartOCX@CSymbolData@@QBEPAUIChartOCX133101@@XZ ; CSymbolData::GetChartOCX
PUBLIC	?GetPropertiesData@CSymbolData@@QAEPAVCPropertiesData_text@@XZ ; CSymbolData::GetPropertiesData
PUBLIC	?GetFilePath@CSymbolData@@QBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ ; CSymbolData::GetFilePath
PUBLIC	?GetParent@CSymbolData@@QBEPAVCWnd@@XZ		; CSymbolData::GetParent
PUBLIC	?GetElementTree@CSymbolData@@QAEPAVCElementTree@@XZ ; CSymbolData::GetElementTree
PUBLIC	?CopySymbol@CSymbolData@@QAEPAVCDrawingSymbol@@PAV2@@Z ; CSymbolData::CopySymbol
PUBLIC	?GetSymbolType@CSymbolData@@QBE?AW4TOOLTYPE@CSymbolBaseData@@XZ ; CSymbolData::GetSymbolType
PUBLIC	?GetBuletType@CSymbolData@@QBE?AW4TOOLTYPE@CSymbolBaseData@@XZ ; CSymbolData::GetBuletType
PUBLIC	?GetSavedSymbolsData@CSymbolData@@QAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ ; CSymbolData::GetSavedSymbolsData
PUBLIC	?GetUserFilePath@CSymbolData@@QBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ ; CSymbolData::GetUserFilePath
PUBLIC	?RegisterElementToOrderManager@CSymbolData@@QAEXJ@Z ; CSymbolData::RegisterElementToOrderManager
PUBLIC	?UnRegisterElementToOrderManager@CSymbolData@@QAEXJ@Z ; CSymbolData::UnRegisterElementToOrderManager
PUBLIC	?SetMainBlock_Object@CSymbolData@@QAEXPAUIChartManager133101@@PAUIChartOCX133101@@@Z ; CSymbolData::SetMainBlock_Object
PUBLIC	?SetFilePath@CSymbolData@@QAEXABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ; CSymbolData::SetFilePath
PUBLIC	?SetUserFilePath@CSymbolData@@QAEXABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ; CSymbolData::SetUserFilePath
PUBLIC	?SetParent@CSymbolData@@QAEXPAVCWnd@@@Z		; CSymbolData::SetParent
PUBLIC	?SetSymbolType@CSymbolData@@QAEXW4TOOLTYPE@CSymbolBaseData@@@Z ; CSymbolData::SetSymbolType
PUBLIC	?SetBuletType@CSymbolData@@QAEXW4TOOLTYPE@CSymbolBaseData@@@Z ; CSymbolData::SetBuletType
PUBLIC	?BuildSymbolsFromString@CSymbolData@@QAEXABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ; CSymbolData::BuildSymbolsFromString
PUBLIC	?FindSymbol@CSymbolData@@QAEPAVCDrawingSymbol@@ABVCPoint@@@Z ; CSymbolData::FindSymbol
PUBLIC	?DrawElement@CSymbolData@@QAEXPAVCDC@@PAVCDrawingSymbol@@@Z ; CSymbolData::DrawElement
PUBLIC	?Invalidate@CSymbolData@@QAEXXZ			; CSymbolData::Invalidate
PUBLIC	?GetUndoRedoManager@CSymbolData@@QBEABVCUndoRedoManager@@XZ ; CSymbolData::GetUndoRedoManager
PUBLIC	?GetUndoRedoManager@CSymbolData@@QAEAAVCUndoRedoManager@@XZ ; CSymbolData::GetUndoRedoManager
PUBLIC	?MoveSymbol@CSymbolData@@QAEHPAVCDrawingSymbol@@V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ; CSymbolData::MoveSymbol
PUBLIC	?GetBlockIndexInSymbol@CSymbolData@@QBE?AVCBlockIndex@@J@Z ; CSymbolData::GetBlockIndexInSymbol
PUBLIC	?GetOrder@CSymbolData@@QAEAAVCOrder@@XZ		; CSymbolData::GetOrder
PUBLIC	?SetXScaleDrawType@CSymbolData@@QAEXW4HORZSCALEDRAWERTYPE@CScaleBaseData@@@Z ; CSymbolData::SetXScaleDrawType
PUBLIC	?GetXScaleDrawType@CSymbolData@@QAE?AW4HORZSCALEDRAWERTYPE@CScaleBaseData@@XZ ; CSymbolData::GetXScaleDrawType
PUBLIC	?GetDatePacket@CSymbolData@@QBEPAUIPacket133101@@PBD@Z ; CSymbolData::GetDatePacket
PUBLIC	??$SerializeElements@PAVCDrawingSymbol@@@@YGXAAVCArchive@@PAPAVCDrawingSymbol@@H@Z ; SerializeElements<CDrawingSymbol *>
PUBLIC	??$SerializeElements@PAVCDrawingSymbolColumn@@@@YGXAAVCArchive@@PAPAVCDrawingSymbolColumn@@H@Z ; SerializeElements<CDrawingSymbolColumn *>
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_R0?AVCObject@@@8				; CObject `RTTI Type Descriptor'
PUBLIC	??_R3CObject@@8					; CObject::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CObject@@8					; CObject::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CObject@@8			; CObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_7?$CList@PAVCDrawingSymbol@@PAV1@@@6B@	; CList<CDrawingSymbol *,CDrawingSymbol *>::`vftable'
PUBLIC	??_7COrder@@6B@					; COrder::`vftable'
PUBLIC	??_7?$CList@PAVCDrawingSymbolColumn@@PAV1@@@6B@	; CList<CDrawingSymbolColumn *,CDrawingSymbolColumn *>::`vftable'
PUBLIC	??_7CTree@@6B@					; CTree::`vftable'
PUBLIC	?m_strAddInItemName@CSymbolData@@2V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A ; CSymbolData::m_strAddInItemName
PUBLIC	??_R4COrder@@6B@				; COrder::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCOrder@@@8				; COrder `RTTI Type Descriptor'
PUBLIC	??_R3COrder@@8					; COrder::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2COrder@@8					; COrder::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@COrder@@8				; COrder::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CList@PAVCDrawingSymbol@@PAV1@@@6B@	; CList<CDrawingSymbol *,CDrawingSymbol *>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CList@PAVCDrawingSymbol@@PAV1@@@@8	; CList<CDrawingSymbol *,CDrawingSymbol *> `RTTI Type Descriptor'
PUBLIC	??_R3?$CList@PAVCDrawingSymbol@@PAV1@@@8	; CList<CDrawingSymbol *,CDrawingSymbol *>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CList@PAVCDrawingSymbol@@PAV1@@@8	; CList<CDrawingSymbol *,CDrawingSymbol *>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CList@PAVCDrawingSymbol@@PAV1@@@8 ; CList<CDrawingSymbol *,CDrawingSymbol *>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4CTree@@6B@					; CTree::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCTree@@@8				; CTree `RTTI Type Descriptor'
PUBLIC	??_R3CTree@@8					; CTree::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CTree@@8					; CTree::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CTree@@8				; CTree::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CList@PAVCDrawingSymbolColumn@@PAV1@@@6B@ ; CList<CDrawingSymbolColumn *,CDrawingSymbolColumn *>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CList@PAVCDrawingSymbolColumn@@PAV1@@@@8 ; CList<CDrawingSymbolColumn *,CDrawingSymbolColumn *> `RTTI Type Descriptor'
PUBLIC	??_R3?$CList@PAVCDrawingSymbolColumn@@PAV1@@@8	; CList<CDrawingSymbolColumn *,CDrawingSymbolColumn *>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CList@PAVCDrawingSymbolColumn@@PAV1@@@8	; CList<CDrawingSymbolColumn *,CDrawingSymbolColumn *>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CList@PAVCDrawingSymbolColumn@@PAV1@@@8 ; CList<CDrawingSymbolColumn *,CDrawingSymbolColumn *>::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	?__global_delete@@YAXPAXI@Z:PROC		; __global_delete
EXTRN	_atexit:PROC
EXTRN	___std_terminate:PROC
EXTRN	__imp__InvalidateRect@12:PROC
EXTRN	?AfxThrowInvalidArgException@@YGXXZ:PROC	; AfxThrowInvalidArgException
EXTRN	?AfxThrowArchiveException@@YGXHPBD@Z:PROC	; AfxThrowArchiveException
EXTRN	?GetRuntimeClass@CObject@@UBEPAUCRuntimeClass@@XZ:PROC ; CObject::GetRuntimeClass
EXTRN	__imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ:PROC
EXTRN	__imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z:PROC
EXTRN	__imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z:PROC
EXTRN	__imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ:PROC
EXTRN	__imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z:PROC
EXTRN	__imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z:PROC
EXTRN	?Read@CArchive@@QAEIPAXI@Z:PROC			; CArchive::Read
EXTRN	?Write@CArchive@@QAEXPBXI@Z:PROC		; CArchive::Write
EXTRN	?ReadCount@CArchive@@QAEKXZ:PROC		; CArchive::ReadCount
EXTRN	?WriteCount@CArchive@@QAEXK@Z:PROC		; CArchive::WriteCount
EXTRN	?Create@CPlex@@SGPAU1@AAPAU1@II@Z:PROC		; CPlex::Create
EXTRN	?FreeDataChain@CPlex@@QAEXXZ:PROC		; CPlex::FreeDataChain
EXTRN	??0CPropertiesData_text@@QAE@XZ:PROC		; CPropertiesData_text::CPropertiesData_text
EXTRN	??1CPropertiesData_text@@UAE@XZ:PROC		; CPropertiesData_text::~CPropertiesData_text
EXTRN	??1COrder@@UAE@XZ:PROC				; COrder::~COrder
EXTRN	??_E?$CList@PAVCDrawingSymbol@@PAV1@@@UAEPAXI@Z:PROC ; CList<CDrawingSymbol *,CDrawingSymbol *>::`vector deleting destructor'
EXTRN	??_ECOrder@@UAEPAXI@Z:PROC			; COrder::`vector deleting destructor'
EXTRN	??1CTree@@UAE@XZ:PROC				; CTree::~CTree
EXTRN	??_E?$CList@PAVCDrawingSymbolColumn@@PAV1@@@UAEPAXI@Z:PROC ; CList<CDrawingSymbolColumn *,CDrawingSymbolColumn *>::`vector deleting destructor'
EXTRN	??_ECTree@@UAEPAXI@Z:PROC			; CTree::`vector deleting destructor'
EXTRN	?FindSymbol@CElementTree@@QAEPAVCDrawingSymbol@@ABVCPoint@@PAUIChartManager133101@@@Z:PROC ; CElementTree::FindSymbol
EXTRN	?DrawElement@CElementTree@@QAEXPAVCDC@@PAUIChartManager133101@@PAVCDrawingSymbol@@@Z:PROC ; CElementTree::DrawElement
EXTRN	?CopyElement@CElementTree@@QAEJPAVCDrawingSymbol@@@Z:PROC ; CElementTree::CopyElement
EXTRN	?GetSavedSymbolsData@CElementTree@@QAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ:PROC ; CElementTree::GetSavedSymbolsData
EXTRN	?BuildSymbolsFromString@CElementTree@@QAEXW4HORZSCALEDRAWERTYPE@CScaleBaseData@@ABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z:PROC ; CElementTree::BuildSymbolsFromString
EXTRN	?GetBlockIndexInSymbol@CElementTree@@QBE?AVCBlockIndex@@PBVCDrawingSymbol@@@Z:PROC ; CElementTree::GetBlockIndexInSymbol
EXTRN	?GetOrder@CElementTree@@QAEAAVCOrder@@XZ:PROC	; CElementTree::GetOrder
EXTRN	??0CUndoRedoManager@@QAE@XZ:PROC		; CUndoRedoManager::CUndoRedoManager
EXTRN	??1CUndoRedoManager@@QAE@XZ:PROC		; CUndoRedoManager::~CUndoRedoManager
EXTRN	?SetSymbolData@CUndoRedoManager@@QAEXPAVCSymbolData@@@Z:PROC ; CUndoRedoManager::SetSymbolData
EXTRN	?RegisterElementToUnRedoManager@CUndoRedoManager@@QAEXHJPBD0@Z:PROC ; CUndoRedoManager::RegisterElementToUnRedoManager
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___security_cookie:DWORD
_BSS	SEGMENT
?m_strAddInItemName@CSymbolData@@2V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A DD 01H DUP (?) ; CSymbolData::m_strAddInItemName
_BSS	ENDS
CRT$XCU	SEGMENT
??m_strAddInItemName$initializer$@CSymbolData@@2P6AXXZA@@3P6AXXZA DD FLAT:??__E?m_strAddInItemName@CSymbolData@@2V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A@@YAXXZ ; ??m_strAddInItemName$initializer$@CSymbolData@@2P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CList@PAVCDrawingSymbolColumn@@PAV1@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CList@PAVCDrawingSymbolColumn@@PAV1@@@8 DD FLAT:??_R0?AV?$CList@PAVCDrawingSymbolColumn@@PAV1@@@@8 ; CList<CDrawingSymbolColumn *,CDrawingSymbolColumn *>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CList@PAVCDrawingSymbolColumn@@PAV1@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CList@PAVCDrawingSymbolColumn@@PAV1@@@8
rdata$r	SEGMENT
??_R2?$CList@PAVCDrawingSymbolColumn@@PAV1@@@8 DD FLAT:??_R1A@?0A@EA@?$CList@PAVCDrawingSymbolColumn@@PAV1@@@8 ; CList<CDrawingSymbolColumn *,CDrawingSymbolColumn *>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CObject@@8
rdata$r	ENDS
;	COMDAT ??_R3?$CList@PAVCDrawingSymbolColumn@@PAV1@@@8
rdata$r	SEGMENT
??_R3?$CList@PAVCDrawingSymbolColumn@@PAV1@@@8 DD 00H	; CList<CDrawingSymbolColumn *,CDrawingSymbolColumn *>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$CList@PAVCDrawingSymbolColumn@@PAV1@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CList@PAVCDrawingSymbolColumn@@PAV1@@@@8
data$rs	SEGMENT
??_R0?AV?$CList@PAVCDrawingSymbolColumn@@PAV1@@@@8 DD FLAT:??_7type_info@@6B@ ; CList<CDrawingSymbolColumn *,CDrawingSymbolColumn *> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CList@PAVCDrawingSymbolColumn@@PAV1@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CList@PAVCDrawingSymbolColumn@@PAV1@@@6B@
rdata$r	SEGMENT
??_R4?$CList@PAVCDrawingSymbolColumn@@PAV1@@@6B@ DD 00H	; CList<CDrawingSymbolColumn *,CDrawingSymbolColumn *>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CList@PAVCDrawingSymbolColumn@@PAV1@@@@8
	DD	FLAT:??_R3?$CList@PAVCDrawingSymbolColumn@@PAV1@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CTree@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CTree@@8 DD FLAT:??_R0?AVCTree@@@8	; CTree::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CTree@@8
rdata$r	ENDS
;	COMDAT ??_R2CTree@@8
rdata$r	SEGMENT
??_R2CTree@@8 DD FLAT:??_R1A@?0A@EA@CTree@@8		; CTree::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CTree@@8
rdata$r	SEGMENT
??_R3CTree@@8 DD 00H					; CTree::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CTree@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCTree@@@8
data$rs	SEGMENT
??_R0?AVCTree@@@8 DD FLAT:??_7type_info@@6B@		; CTree `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCTree@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CTree@@6B@
rdata$r	SEGMENT
??_R4CTree@@6B@ DD 00H					; CTree::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCTree@@@8
	DD	FLAT:??_R3CTree@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CList@PAVCDrawingSymbol@@PAV1@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CList@PAVCDrawingSymbol@@PAV1@@@8 DD FLAT:??_R0?AV?$CList@PAVCDrawingSymbol@@PAV1@@@@8 ; CList<CDrawingSymbol *,CDrawingSymbol *>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CList@PAVCDrawingSymbol@@PAV1@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CList@PAVCDrawingSymbol@@PAV1@@@8
rdata$r	SEGMENT
??_R2?$CList@PAVCDrawingSymbol@@PAV1@@@8 DD FLAT:??_R1A@?0A@EA@?$CList@PAVCDrawingSymbol@@PAV1@@@8 ; CList<CDrawingSymbol *,CDrawingSymbol *>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CObject@@8
rdata$r	ENDS
;	COMDAT ??_R3?$CList@PAVCDrawingSymbol@@PAV1@@@8
rdata$r	SEGMENT
??_R3?$CList@PAVCDrawingSymbol@@PAV1@@@8 DD 00H		; CList<CDrawingSymbol *,CDrawingSymbol *>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$CList@PAVCDrawingSymbol@@PAV1@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CList@PAVCDrawingSymbol@@PAV1@@@@8
data$rs	SEGMENT
??_R0?AV?$CList@PAVCDrawingSymbol@@PAV1@@@@8 DD FLAT:??_7type_info@@6B@ ; CList<CDrawingSymbol *,CDrawingSymbol *> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CList@PAVCDrawingSymbol@@PAV1@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CList@PAVCDrawingSymbol@@PAV1@@@6B@
rdata$r	SEGMENT
??_R4?$CList@PAVCDrawingSymbol@@PAV1@@@6B@ DD 00H	; CList<CDrawingSymbol *,CDrawingSymbol *>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CList@PAVCDrawingSymbol@@PAV1@@@@8
	DD	FLAT:??_R3?$CList@PAVCDrawingSymbol@@PAV1@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@COrder@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@COrder@@8 DD FLAT:??_R0?AVCOrder@@@8	; COrder::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3COrder@@8
rdata$r	ENDS
;	COMDAT ??_R2COrder@@8
rdata$r	SEGMENT
??_R2COrder@@8 DD FLAT:??_R1A@?0A@EA@COrder@@8		; COrder::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3COrder@@8
rdata$r	SEGMENT
??_R3COrder@@8 DD 00H					; COrder::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2COrder@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCOrder@@@8
data$rs	SEGMENT
??_R0?AVCOrder@@@8 DD FLAT:??_7type_info@@6B@		; COrder `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCOrder@@', 00H
data$rs	ENDS
;	COMDAT ??_R4COrder@@6B@
rdata$r	SEGMENT
??_R4COrder@@6B@ DD 00H					; COrder::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCOrder@@@8
	DD	FLAT:??_R3COrder@@8
rdata$r	ENDS
;	COMDAT ??_7CTree@@6B@
CONST	SEGMENT
??_7CTree@@6B@ DD FLAT:??_R4CTree@@6B@			; CTree::`vftable'
	DD	FLAT:??_ECTree@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$CList@PAVCDrawingSymbolColumn@@PAV1@@@6B@
CONST	SEGMENT
??_7?$CList@PAVCDrawingSymbolColumn@@PAV1@@@6B@ DD FLAT:??_R4?$CList@PAVCDrawingSymbolColumn@@PAV1@@@6B@ ; CList<CDrawingSymbolColumn *,CDrawingSymbolColumn *>::`vftable'
	DD	FLAT:?GetRuntimeClass@CObject@@UBEPAUCRuntimeClass@@XZ
	DD	FLAT:??_E?$CList@PAVCDrawingSymbolColumn@@PAV1@@@UAEPAXI@Z
	DD	FLAT:?Serialize@?$CList@PAVCDrawingSymbolColumn@@PAV1@@@UAEXAAVCArchive@@@Z
	DD	FLAT:?AssertValid@CObject@@UBEXXZ
	DD	FLAT:?Dump@CObject@@UBEXAAVCDumpContext@@@Z
CONST	ENDS
;	COMDAT ??_7COrder@@6B@
CONST	SEGMENT
??_7COrder@@6B@ DD FLAT:??_R4COrder@@6B@		; COrder::`vftable'
	DD	FLAT:??_ECOrder@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$CList@PAVCDrawingSymbol@@PAV1@@@6B@
CONST	SEGMENT
??_7?$CList@PAVCDrawingSymbol@@PAV1@@@6B@ DD FLAT:??_R4?$CList@PAVCDrawingSymbol@@PAV1@@@6B@ ; CList<CDrawingSymbol *,CDrawingSymbol *>::`vftable'
	DD	FLAT:?GetRuntimeClass@CObject@@UBEPAUCRuntimeClass@@XZ
	DD	FLAT:??_E?$CList@PAVCDrawingSymbol@@PAV1@@@UAEPAXI@Z
	DD	FLAT:?Serialize@?$CList@PAVCDrawingSymbol@@PAV1@@@UAEXAAVCArchive@@@Z
	DD	FLAT:?AssertValid@CObject@@UBEXXZ
	DD	FLAT:?Dump@CObject@@UBEXAAVCDumpContext@@@Z
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@CObject@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CObject@@8 DD FLAT:??_R0?AVCObject@@@8	; CObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CObject@@8
rdata$r	ENDS
;	COMDAT ??_R2CObject@@8
rdata$r	SEGMENT
??_R2CObject@@8 DD FLAT:??_R1A@?0A@EA@CObject@@8	; CObject::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CObject@@8
rdata$r	SEGMENT
??_R3CObject@@8 DD 00H					; CObject::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CObject@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCObject@@@8
data$rs	SEGMENT
??_R0?AVCObject@@@8 DD FLAT:??_7type_info@@6B@		; CObject `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCObject@@', 00H
data$rs	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?MoveSymbol@CSymbolData@@QAEHPAVCDrawingSymbol@@V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?MoveSymbol@CSymbolData@@QAEHPAVCDrawingSymbol@@V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z$0
__ehfuncinfo$?MoveSymbol@CSymbolData@@QAEHPAVCDrawingSymbol@@V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?MoveSymbol@CSymbolData@@QAEHPAVCDrawingSymbol@@V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?SetMainBlock_Object@CSymbolData@@QAEXPAUIChartManager133101@@PAUIChartOCX133101@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SetMainBlock_Object@CSymbolData@@QAEXPAUIChartManager133101@@PAUIChartOCX133101@@@Z$0
	DD	0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$?SetMainBlock_Object@CSymbolData@@QAEXPAUIChartManager133101@@PAUIChartOCX133101@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?SetMainBlock_Object@CSymbolData@@QAEXPAUIChartManager133101@@PAUIChartOCX133101@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CSymbolData@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0CSymbolData@@QAE@XZ DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??0CSymbolData@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0CSymbolData@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CSymbolData@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CSymbolData@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0CSymbolData@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0CSymbolData@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0CSymbolData@@QAE@XZ$4
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_G?$CList@PAVCDrawingSymbolColumn@@PAV1@@@UAEPAXI@Z DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??_G?$CList@PAVCDrawingSymbolColumn@@PAV1@@@UAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_G?$CList@PAVCDrawingSymbolColumn@@PAV1@@@UAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CList@PAVCDrawingSymbolColumn@@PAV1@@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1ILPCSTR133101@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_G?$CList@PAVCDrawingSymbol@@PAV1@@@UAEPAXI@Z DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??_G?$CList@PAVCDrawingSymbol@@PAV1@@@UAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_G?$CList@PAVCDrawingSymbol@@PAV1@@@UAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CList@PAVCDrawingSymbol@@PAV1@@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ??$SerializeElements@PAVCDrawingSymbolColumn@@@@YGXAAVCArchive@@PAPAVCDrawingSymbolColumn@@H@Z
_TEXT	SEGMENT
_ar$ = 8						; size = 4
_pElements$ = 12					; size = 4
_nCount$ = 16						; size = 4
??$SerializeElements@PAVCDrawingSymbolColumn@@@@YGXAAVCArchive@@PAPAVCDrawingSymbolColumn@@H@Z PROC ; SerializeElements<CDrawingSymbolColumn *>, COMDAT

; 67   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 68   : 	ENSURE(nCount == 0 || pElements != NULL);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR _pElements$[ebp]
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b 75 10	 mov	 esi, DWORD PTR _nCount$[ebp]
  0000b	57		 push	 edi
  0000c	85 f6		 test	 esi, esi
  0000e	74 08		 je	 SHORT $LN2@SerializeE
  00010	85 c9		 test	 ecx, ecx
  00012	0f 84 89 00 00
	00		 je	 $LN34@SerializeE
$LN2@SerializeE:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 212  : 	{ return (m_nMode & CArchive::load) == 0; }

  00018	8b 55 08	 mov	 edx, DWORD PTR _ar$[ebp]
  0001b	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0001e	f7 d0		 not	 eax
  00020	a8 01		 test	 al, 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 73   : 	if (ar.IsStoring())

  00022	74 3c		 je	 SHORT $LN10@SerializeE

; 74   : 	{
; 75   : 		TYPE* pData;
; 76   : 		UINT_PTR nElementsLeft;
; 77   : 
; 78   : 		nElementsLeft = nCount;
; 79   : 		pData = pElements;
; 80   : 		while( nElementsLeft > 0 )

  00024	85 f6		 test	 esi, esi
  00026	74 31		 je	 SHORT $LN8@SerializeE
  00028	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL5@SerializeE:

; 81   : 		{
; 82   : 			UINT nElementsToWrite;
; 83   : 
; 84   : 			nElementsToWrite = UINT(__min(nElementsLeft, INT_MAX/sizeof(TYPE)));

  00030	bb ff ff ff 1f	 mov	 ebx, 536870911		; 1fffffffH
  00035	3b f3		 cmp	 esi, ebx
  00037	0f 42 de	 cmovb	 ebx, esi

; 85   : 			ar.Write(pData, nElementsToWrite*sizeof(TYPE));

  0003a	8d 3c 9d 00 00
	00 00		 lea	 edi, DWORD PTR [ebx*4]
  00041	57		 push	 edi
  00042	51		 push	 ecx
  00043	8b ca		 mov	 ecx, edx
  00045	e8 00 00 00 00	 call	 ?Write@CArchive@@QAEXPBXI@Z ; CArchive::Write

; 86   : 			nElementsLeft -= nElementsToWrite;
; 87   : 			pData += nElementsToWrite;

  0004a	8b 4d 0c	 mov	 ecx, DWORD PTR _pElements$[ebp]
  0004d	8b 55 08	 mov	 edx, DWORD PTR _ar$[ebp]
  00050	03 cf		 add	 ecx, edi
  00052	89 4d 0c	 mov	 DWORD PTR _pElements$[ebp], ecx
  00055	2b f3		 sub	 esi, ebx
  00057	75 d7		 jne	 SHORT $LL5@SerializeE
$LN8@SerializeE:
  00059	5f		 pop	 edi

; 105  : 		}
; 106  : 	}
; 107  : }

  0005a	5e		 pop	 esi
  0005b	5b		 pop	 ebx
  0005c	5d		 pop	 ebp
  0005d	c2 0c 00	 ret	 12			; 0000000cH
$LN10@SerializeE:

; 97   : 		while( nElementsLeft > 0 )

  00060	85 f6		 test	 esi, esi
  00062	74 f5		 je	 SHORT $LN8@SerializeE
$LL7@SerializeE:

; 98   : 		{
; 99   : 			UINT nElementsToRead;
; 100  : 
; 101  : 			nElementsToRead = UINT(__min(nElementsLeft, INT_MAX/sizeof(TYPE)));

  00064	bf ff ff ff 1f	 mov	 edi, 536870911		; 1fffffffH
  00069	3b f7		 cmp	 esi, edi
  0006b	0f 42 fe	 cmovb	 edi, esi

; 102  : 			ar.EnsureRead(pData, nElementsToRead*sizeof(TYPE));

  0006e	8d 1c bd 00 00
	00 00		 lea	 ebx, DWORD PTR [edi*4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 399  : 	UINT nRead=Read(lpBuf, nCount);

  00075	53		 push	 ebx
  00076	51		 push	 ecx
  00077	8b ca		 mov	 ecx, edx
  00079	e8 00 00 00 00	 call	 ?Read@CArchive@@QAEIPAXI@Z ; CArchive::Read

; 400  : 	if(nRead!=nCount)

  0007e	3b c3		 cmp	 eax, ebx
  00080	75 16		 jne	 SHORT $LN23@SerializeE
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 97   : 		while( nElementsLeft > 0 )

  00082	8b 4d 0c	 mov	 ecx, DWORD PTR _pElements$[ebp]
  00085	8b 55 08	 mov	 edx, DWORD PTR _ar$[ebp]

; 103  : 			nElementsLeft -= nElementsToRead;
; 104  : 			pData += nElementsToRead;

  00088	03 cb		 add	 ecx, ebx
  0008a	89 4d 0c	 mov	 DWORD PTR _pElements$[ebp], ecx
  0008d	2b f7		 sub	 esi, edi
  0008f	75 d3		 jne	 SHORT $LL7@SerializeE

; 105  : 		}
; 106  : 	}
; 107  : }

  00091	5f		 pop	 edi
  00092	5e		 pop	 esi
  00093	5b		 pop	 ebx
  00094	5d		 pop	 ebp
  00095	c2 0c 00	 ret	 12			; 0000000cH
$LN23@SerializeE:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 402  : 		AfxThrowArchiveException(CArchiveException::endOfFile);

  00098	6a 00		 push	 0
  0009a	6a 03		 push	 3
  0009c	e8 00 00 00 00	 call	 ?AfxThrowArchiveException@@YGXHPBD@Z ; AfxThrowArchiveException
$LN34@SerializeE:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 68   : 	ENSURE(nCount == 0 || pElements != NULL);

  000a1	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN32@SerializeE:
  000a6	cc		 int	 3
??$SerializeElements@PAVCDrawingSymbolColumn@@@@YGXAAVCArchive@@PAPAVCDrawingSymbolColumn@@H@Z ENDP ; SerializeElements<CDrawingSymbolColumn *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ??$SerializeElements@PAVCDrawingSymbol@@@@YGXAAVCArchive@@PAPAVCDrawingSymbol@@H@Z
_TEXT	SEGMENT
_ar$ = 8						; size = 4
_pElements$ = 12					; size = 4
_nCount$ = 16						; size = 4
??$SerializeElements@PAVCDrawingSymbol@@@@YGXAAVCArchive@@PAPAVCDrawingSymbol@@H@Z PROC ; SerializeElements<CDrawingSymbol *>, COMDAT

; 67   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 68   : 	ENSURE(nCount == 0 || pElements != NULL);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR _pElements$[ebp]
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b 75 10	 mov	 esi, DWORD PTR _nCount$[ebp]
  0000b	57		 push	 edi
  0000c	85 f6		 test	 esi, esi
  0000e	74 08		 je	 SHORT $LN2@SerializeE
  00010	85 c9		 test	 ecx, ecx
  00012	0f 84 89 00 00
	00		 je	 $LN34@SerializeE
$LN2@SerializeE:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 212  : 	{ return (m_nMode & CArchive::load) == 0; }

  00018	8b 55 08	 mov	 edx, DWORD PTR _ar$[ebp]
  0001b	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0001e	f7 d0		 not	 eax
  00020	a8 01		 test	 al, 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 73   : 	if (ar.IsStoring())

  00022	74 3c		 je	 SHORT $LN10@SerializeE

; 74   : 	{
; 75   : 		TYPE* pData;
; 76   : 		UINT_PTR nElementsLeft;
; 77   : 
; 78   : 		nElementsLeft = nCount;
; 79   : 		pData = pElements;
; 80   : 		while( nElementsLeft > 0 )

  00024	85 f6		 test	 esi, esi
  00026	74 31		 je	 SHORT $LN8@SerializeE
  00028	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL5@SerializeE:

; 81   : 		{
; 82   : 			UINT nElementsToWrite;
; 83   : 
; 84   : 			nElementsToWrite = UINT(__min(nElementsLeft, INT_MAX/sizeof(TYPE)));

  00030	bb ff ff ff 1f	 mov	 ebx, 536870911		; 1fffffffH
  00035	3b f3		 cmp	 esi, ebx
  00037	0f 42 de	 cmovb	 ebx, esi

; 85   : 			ar.Write(pData, nElementsToWrite*sizeof(TYPE));

  0003a	8d 3c 9d 00 00
	00 00		 lea	 edi, DWORD PTR [ebx*4]
  00041	57		 push	 edi
  00042	51		 push	 ecx
  00043	8b ca		 mov	 ecx, edx
  00045	e8 00 00 00 00	 call	 ?Write@CArchive@@QAEXPBXI@Z ; CArchive::Write

; 86   : 			nElementsLeft -= nElementsToWrite;
; 87   : 			pData += nElementsToWrite;

  0004a	8b 4d 0c	 mov	 ecx, DWORD PTR _pElements$[ebp]
  0004d	8b 55 08	 mov	 edx, DWORD PTR _ar$[ebp]
  00050	03 cf		 add	 ecx, edi
  00052	89 4d 0c	 mov	 DWORD PTR _pElements$[ebp], ecx
  00055	2b f3		 sub	 esi, ebx
  00057	75 d7		 jne	 SHORT $LL5@SerializeE
$LN8@SerializeE:
  00059	5f		 pop	 edi

; 105  : 		}
; 106  : 	}
; 107  : }

  0005a	5e		 pop	 esi
  0005b	5b		 pop	 ebx
  0005c	5d		 pop	 ebp
  0005d	c2 0c 00	 ret	 12			; 0000000cH
$LN10@SerializeE:

; 97   : 		while( nElementsLeft > 0 )

  00060	85 f6		 test	 esi, esi
  00062	74 f5		 je	 SHORT $LN8@SerializeE
$LL7@SerializeE:

; 98   : 		{
; 99   : 			UINT nElementsToRead;
; 100  : 
; 101  : 			nElementsToRead = UINT(__min(nElementsLeft, INT_MAX/sizeof(TYPE)));

  00064	bf ff ff ff 1f	 mov	 edi, 536870911		; 1fffffffH
  00069	3b f7		 cmp	 esi, edi
  0006b	0f 42 fe	 cmovb	 edi, esi

; 102  : 			ar.EnsureRead(pData, nElementsToRead*sizeof(TYPE));

  0006e	8d 1c bd 00 00
	00 00		 lea	 ebx, DWORD PTR [edi*4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 399  : 	UINT nRead=Read(lpBuf, nCount);

  00075	53		 push	 ebx
  00076	51		 push	 ecx
  00077	8b ca		 mov	 ecx, edx
  00079	e8 00 00 00 00	 call	 ?Read@CArchive@@QAEIPAXI@Z ; CArchive::Read

; 400  : 	if(nRead!=nCount)

  0007e	3b c3		 cmp	 eax, ebx
  00080	75 16		 jne	 SHORT $LN23@SerializeE
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 97   : 		while( nElementsLeft > 0 )

  00082	8b 4d 0c	 mov	 ecx, DWORD PTR _pElements$[ebp]
  00085	8b 55 08	 mov	 edx, DWORD PTR _ar$[ebp]

; 103  : 			nElementsLeft -= nElementsToRead;
; 104  : 			pData += nElementsToRead;

  00088	03 cb		 add	 ecx, ebx
  0008a	89 4d 0c	 mov	 DWORD PTR _pElements$[ebp], ecx
  0008d	2b f7		 sub	 esi, edi
  0008f	75 d3		 jne	 SHORT $LL7@SerializeE

; 105  : 		}
; 106  : 	}
; 107  : }

  00091	5f		 pop	 edi
  00092	5e		 pop	 esi
  00093	5b		 pop	 ebx
  00094	5d		 pop	 ebp
  00095	c2 0c 00	 ret	 12			; 0000000cH
$LN23@SerializeE:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 402  : 		AfxThrowArchiveException(CArchiveException::endOfFile);

  00098	6a 00		 push	 0
  0009a	6a 03		 push	 3
  0009c	e8 00 00 00 00	 call	 ?AfxThrowArchiveException@@YGXHPBD@Z ; AfxThrowArchiveException
$LN34@SerializeE:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 68   : 	ENSURE(nCount == 0 || pElements != NULL);

  000a1	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN32@SerializeE:
  000a6	cc		 int	 3
??$SerializeElements@PAVCDrawingSymbol@@@@YGXAAVCArchive@@PAPAVCDrawingSymbol@@H@Z ENDP ; SerializeElements<CDrawingSymbol *>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__F?m_strAddInItemName@CSymbolData@@2V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A@@YAXXZ
text$yd	SEGMENT
??__F?m_strAddInItemName@CSymbolData@@2V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CSymbolData::m_strAddInItemName'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?m_strAddInItemName@CSymbolData@@2V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A ; CSymbolData::m_strAddInItemName
  00005	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
??__F?m_strAddInItemName@CSymbolData@@2V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CSymbolData::m_strAddInItemName''
text$yd	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\SymbolData.cpp
;	COMDAT ??__E?m_strAddInItemName@CSymbolData@@2V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A@@YAXXZ
text$di	SEGMENT
??__E?m_strAddInItemName@CSymbolData@@2V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A@@YAXXZ PROC ; `dynamic initializer for 'CSymbolData::m_strAddInItemName'', COMDAT

; 17   : CString CSymbolData::m_strAddInItemName = "ANALYSIS_TOOL";

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0O@DMAKNGHI@ANALYSIS_TOOL@
  00005	b9 00 00 00 00	 mov	 ecx, OFFSET ?m_strAddInItemName@CSymbolData@@2V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A ; CSymbolData::m_strAddInItemName
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  00010	68 00 00 00 00	 push	 OFFSET ??__F?m_strAddInItemName@CSymbolData@@2V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A@@YAXXZ ; `dynamic atexit destructor for 'CSymbolData::m_strAddInItemName''
  00015	e8 00 00 00 00	 call	 _atexit
  0001a	59		 pop	 ecx
  0001b	c3		 ret	 0
??__E?m_strAddInItemName@CSymbolData@@2V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A@@YAXXZ ENDP ; `dynamic initializer for 'CSymbolData::m_strAddInItemName''
text$di	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\SymbolData.cpp
;	COMDAT ?GetDatePacket@CSymbolData@@QBEPAUIPacket133101@@PBD@Z
_TEXT	SEGMENT
_p_szRQ$ = 8						; size = 4
?GetDatePacket@CSymbolData@@QBEPAUIPacket133101@@PBD@Z PROC ; CSymbolData::GetDatePacket, COMDAT
; _this$ = ecx

; 261  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 262  : 	if( !m_pIPacketListManager) return NULL;

  00003	8b 89 fc 00 00
	00		 mov	 ecx, DWORD PTR [ecx+252]
  00009	85 c9		 test	 ecx, ecx
  0000b	75 06		 jne	 SHORT $LN2@GetDatePac
  0000d	33 c0		 xor	 eax, eax

; 264  : }

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
$LN2@GetDatePac:

; 263  : 	return m_pIPacketListManager->GetDatePacket( p_szRQ);

  00013	8b 01		 mov	 eax, DWORD PTR [ecx]

; 264  : }

  00015	5d		 pop	 ebp

; 263  : 	return m_pIPacketListManager->GetDatePacket( p_szRQ);

  00016	ff 60 2c	 jmp	 DWORD PTR [eax+44]
?GetDatePacket@CSymbolData@@QBEPAUIPacket133101@@PBD@Z ENDP ; CSymbolData::GetDatePacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\SymbolData.cpp
;	COMDAT ?GetXScaleDrawType@CSymbolData@@QAE?AW4HORZSCALEDRAWERTYPE@CScaleBaseData@@XZ
_TEXT	SEGMENT
?GetXScaleDrawType@CSymbolData@@QAE?AW4HORZSCALEDRAWERTYPE@CScaleBaseData@@XZ PROC ; CSymbolData::GetXScaleDrawType, COMDAT
; _this$ = ecx

; 274  : 	return m_eScaleType;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 275  : }

  00002	c3		 ret	 0
?GetXScaleDrawType@CSymbolData@@QAE?AW4HORZSCALEDRAWERTYPE@CScaleBaseData@@XZ ENDP ; CSymbolData::GetXScaleDrawType
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\SymbolData.cpp
;	COMDAT ?SetXScaleDrawType@CSymbolData@@QAEXW4HORZSCALEDRAWERTYPE@CScaleBaseData@@@Z
_TEXT	SEGMENT
_eScaleType$ = 8					; size = 4
?SetXScaleDrawType@CSymbolData@@QAEXW4HORZSCALEDRAWERTYPE@CScaleBaseData@@@Z PROC ; CSymbolData::SetXScaleDrawType, COMDAT
; _this$ = ecx

; 268  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 269  : 	m_eScaleType = eScaleType;

  00003	8b 45 08	 mov	 eax, DWORD PTR _eScaleType$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 270  : }

  00008	5d		 pop	 ebp
  00009	c2 04 00	 ret	 4
?SetXScaleDrawType@CSymbolData@@QAEXW4HORZSCALEDRAWERTYPE@CScaleBaseData@@@Z ENDP ; CSymbolData::SetXScaleDrawType
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\SymbolData.cpp
;	COMDAT ?GetOrder@CSymbolData@@QAEAAVCOrder@@XZ
_TEXT	SEGMENT
?GetOrder@CSymbolData@@QAEAAVCOrder@@XZ PROC		; CSymbolData::GetOrder, COMDAT
; _this$ = ecx

; 256  : 	return m_elementTree.GetOrder();

  00000	83 e9 80	 sub	 ecx, -128		; ffffff80H
  00003	e9 00 00 00 00	 jmp	 ?GetOrder@CElementTree@@QAEAAVCOrder@@XZ ; CElementTree::GetOrder
?GetOrder@CSymbolData@@QAEAAVCOrder@@XZ ENDP		; CSymbolData::GetOrder
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\SymbolData.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Include_Chart\BlockBaseData.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\SymbolData.cpp
;	COMDAT ?GetBlockIndexInSymbol@CSymbolData@@QBE?AVCBlockIndex@@J@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_lSymbolAddress$ = 12					; size = 4
?GetBlockIndexInSymbol@CSymbolData@@QBE?AVCBlockIndex@@J@Z PROC ; CSymbolData::GetBlockIndexInSymbol, COMDAT
; _this$ = ecx

; 246  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 247  : 	const CDrawingSymbol* pSelectedSymbol = (const CDrawingSymbol*)lSymbolAddress;
; 248  : 	if(pSelectedSymbol == NULL)

  00003	8b 45 0c	 mov	 eax, DWORD PTR _lSymbolAddress$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 14		 jne	 SHORT $LN2@GetBlockIn
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Include_Chart\BlockBaseData.h

; 19   : 	CBlockIndex() { m_nRow = m_nColumn = -1; };

  0000a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0000d	c7 40 04 ff ff
	ff ff		 mov	 DWORD PTR [eax+4], -1
  00014	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\SymbolData.cpp

; 252  : }

  0001a	5d		 pop	 ebp
  0001b	c2 08 00	 ret	 8
$LN2@GetBlockIn:

; 249  : 		return CBlockIndex();
; 250  : 
; 251  : 	return m_elementTree.GetBlockIndexInSymbol(pSelectedSymbol);

  0001e	50		 push	 eax
  0001f	ff 75 08	 push	 DWORD PTR ___$ReturnUdt$[ebp]
  00022	83 e9 80	 sub	 ecx, -128		; ffffff80H
  00025	e8 00 00 00 00	 call	 ?GetBlockIndexInSymbol@CElementTree@@QBE?AVCBlockIndex@@PBVCDrawingSymbol@@@Z ; CElementTree::GetBlockIndexInSymbol
  0002a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 252  : }

  0002d	5d		 pop	 ebp
  0002e	c2 08 00	 ret	 8
?GetBlockIndexInSymbol@CSymbolData@@QBE?AVCBlockIndex@@J@Z ENDP ; CSymbolData::GetBlockIndexInSymbol
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\SymbolData.cpp
;	COMDAT ?MoveSymbol@CSymbolData@@QAEHPAVCDrawingSymbol@@V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_pSelectedSymbol$ = 8					; size = 4
_strSymbolData_Prev$ = 12				; size = 4
?MoveSymbol@CSymbolData@@QAEHPAVCDrawingSymbol@@V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z PROC ; CSymbolData::MoveSymbol, COMDAT
; _this$ = ecx

; 235  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?MoveSymbol@CSymbolData@@QAEHPAVCDrawingSymbol@@V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 236  : 	if(pSelectedSymbol == NULL)

  00023	8b 45 08	 mov	 eax, DWORD PTR _pSelectedSymbol$[ebp]
  00026	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0002d	85 c0		 test	 eax, eax
  0002f	75 04		 jne	 SHORT $LN2@MoveSymbol
  00031	33 f6		 xor	 esi, esi
  00033	eb 18		 jmp	 SHORT $LN5@MoveSymbol
$LN2@MoveSymbol:

; 237  : 		return FALSE;
; 238  : 
; 239  : 	// Undo / Redo
; 240  : 	GetUndoRedoManager().RegisterElementToUnRedoManager(URT_MOVE, (long)pSelectedSymbol, strSymbolData_Prev);

  00035	6a 00		 push	 0
  00037	ff 75 0c	 push	 DWORD PTR _strSymbolData_Prev$[ebp]
  0003a	81 c1 c0 00 00
	00		 add	 ecx, 192		; 000000c0H
  00040	50		 push	 eax
  00041	6a 02		 push	 2
  00043	e8 00 00 00 00	 call	 ?RegisterElementToUnRedoManager@CUndoRedoManager@@QAEXHJPBD0@Z ; CUndoRedoManager::RegisterElementToUnRedoManager

; 241  : 
; 242  : 	return TRUE;

  00048	be 01 00 00 00	 mov	 esi, 1
$LN5@MoveSymbol:
  0004d	8d 4d 0c	 lea	 ecx, DWORD PTR _strSymbolData_Prev$[ebp]
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00056	8b c6		 mov	 eax, esi

; 243  : }

  00058	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00062	59		 pop	 ecx
  00063	5e		 pop	 esi
  00064	8b e5		 mov	 esp, ebp
  00066	5d		 pop	 ebp
  00067	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?MoveSymbol@CSymbolData@@QAEHPAVCDrawingSymbol@@V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z$0:
  00000	8d 4d 0c	 lea	 ecx, DWORD PTR _strSymbolData_Prev$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
  0000d	cc		 int	 3
__ehhandler$?MoveSymbol@CSymbolData@@QAEHPAVCDrawingSymbol@@V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z:
  0000e	90		 npad	 1
  0000f	90		 npad	 1
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?MoveSymbol@CSymbolData@@QAEHPAVCDrawingSymbol@@V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
  00026	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?MoveSymbol@CSymbolData@@QAEHPAVCDrawingSymbol@@V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ENDP ; CSymbolData::MoveSymbol
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\SymbolData.cpp
;	COMDAT ?GetUndoRedoManager@CSymbolData@@QAEAAVCUndoRedoManager@@XZ
_TEXT	SEGMENT
?GetUndoRedoManager@CSymbolData@@QAEAAVCUndoRedoManager@@XZ PROC ; CSymbolData::GetUndoRedoManager, COMDAT
; _this$ = ecx

; 231  : 	return m_UndoRedoManager;

  00000	8d 81 c0 00 00
	00		 lea	 eax, DWORD PTR [ecx+192]

; 232  : }

  00006	c3		 ret	 0
?GetUndoRedoManager@CSymbolData@@QAEAAVCUndoRedoManager@@XZ ENDP ; CSymbolData::GetUndoRedoManager
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\SymbolData.cpp
;	COMDAT ?GetUndoRedoManager@CSymbolData@@QBEABVCUndoRedoManager@@XZ
_TEXT	SEGMENT
?GetUndoRedoManager@CSymbolData@@QBEABVCUndoRedoManager@@XZ PROC ; CSymbolData::GetUndoRedoManager, COMDAT
; _this$ = ecx

; 226  : 	return m_UndoRedoManager;

  00000	8d 81 c0 00 00
	00		 lea	 eax, DWORD PTR [ecx+192]

; 227  : }

  00006	c3		 ret	 0
?GetUndoRedoManager@CSymbolData@@QBEABVCUndoRedoManager@@XZ ENDP ; CSymbolData::GetUndoRedoManager
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\SymbolData.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\SymbolData.cpp
;	COMDAT ?Invalidate@CSymbolData@@QAEXXZ
_TEXT	SEGMENT
?Invalidate@CSymbolData@@QAEXXZ PROC			; CSymbolData::Invalidate, COMDAT
; _this$ = ecx

; 184  : 	if(m_pParent == NULL)

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	85 c0		 test	 eax, eax
  00005	74 0d		 je	 SHORT $LN1@Invalidate
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl

; 114  : 	{ ASSERT(::IsWindow(m_hWnd)); ::InvalidateRect(m_hWnd, NULL, bErase); }

  00007	6a 01		 push	 1
  00009	6a 00		 push	 0
  0000b	ff 70 20	 push	 DWORD PTR [eax+32]
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InvalidateRect@12
$LN1@Invalidate:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\SymbolData.cpp

; 188  : }

  00014	c3		 ret	 0
?Invalidate@CSymbolData@@QAEXXZ ENDP			; CSymbolData::Invalidate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\SymbolData.cpp
;	COMDAT ?DrawElement@CSymbolData@@QAEXPAVCDC@@PAVCDrawingSymbol@@@Z
_TEXT	SEGMENT
_pDC$ = 8						; size = 4
_pSelected$ = 12					; size = 4
?DrawElement@CSymbolData@@QAEXPAVCDC@@PAVCDrawingSymbol@@@Z PROC ; CSymbolData::DrawElement, COMDAT
; _this$ = ecx

; 155  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 156  : 	m_elementTree.DrawElement(pDC, m_pMainBlock, pSelected);

  00003	ff 75 0c	 push	 DWORD PTR _pSelected$[ebp]
  00006	ff 71 08	 push	 DWORD PTR [ecx+8]
  00009	83 e9 80	 sub	 ecx, -128		; ffffff80H
  0000c	ff 75 08	 push	 DWORD PTR _pDC$[ebp]
  0000f	e8 00 00 00 00	 call	 ?DrawElement@CElementTree@@QAEXPAVCDC@@PAUIChartManager133101@@PAVCDrawingSymbol@@@Z ; CElementTree::DrawElement

; 157  : }

  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
?DrawElement@CSymbolData@@QAEXPAVCDC@@PAVCDrawingSymbol@@@Z ENDP ; CSymbolData::DrawElement
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\SymbolData.cpp
;	COMDAT ?FindSymbol@CSymbolData@@QAEPAVCDrawingSymbol@@ABVCPoint@@@Z
_TEXT	SEGMENT
_point$ = 8						; size = 4
?FindSymbol@CSymbolData@@QAEPAVCDrawingSymbol@@ABVCPoint@@@Z PROC ; CSymbolData::FindSymbol, COMDAT
; _this$ = ecx

; 165  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 166  : 	return m_elementTree.FindSymbol(point, m_pMainBlock);

  00003	ff 71 08	 push	 DWORD PTR [ecx+8]
  00006	83 e9 80	 sub	 ecx, -128		; ffffff80H
  00009	ff 75 08	 push	 DWORD PTR _point$[ebp]
  0000c	e8 00 00 00 00	 call	 ?FindSymbol@CElementTree@@QAEPAVCDrawingSymbol@@ABVCPoint@@PAUIChartManager133101@@@Z ; CElementTree::FindSymbol

; 167  : }

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?FindSymbol@CSymbolData@@QAEPAVCDrawingSymbol@@ABVCPoint@@@Z ENDP ; CSymbolData::FindSymbol
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\SymbolData.cpp
;	COMDAT ?BuildSymbolsFromString@CSymbolData@@QAEXABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
_TEXT	SEGMENT
_Data$ = 8						; size = 4
?BuildSymbolsFromString@CSymbolData@@QAEXABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z PROC ; CSymbolData::BuildSymbolsFromString, COMDAT
; _this$ = ecx

; 175  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 176  : 	// 2011.02.07 by SYS >>  YYYY()  : / 14Byte  (YYYYMMDDhhmmss)
; 177  : 	//m_elementTree.BuildSymbolsFromString(Data);
; 178  : 	m_elementTree.BuildSymbolsFromString(m_eScaleType, Data);

  00003	ff 75 08	 push	 DWORD PTR _Data$[ebp]
  00006	ff 31		 push	 DWORD PTR [ecx]
  00008	83 e9 80	 sub	 ecx, -128		; ffffff80H
  0000b	e8 00 00 00 00	 call	 ?BuildSymbolsFromString@CElementTree@@QAEXW4HORZSCALEDRAWERTYPE@CScaleBaseData@@ABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ; CElementTree::BuildSymbolsFromString

; 179  : 	// 2011.02.07 by SYS <<
; 180  : }

  00010	5d		 pop	 ebp
  00011	c2 04 00	 ret	 4
?BuildSymbolsFromString@CSymbolData@@QAEXABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ENDP ; CSymbolData::BuildSymbolsFromString
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\SymbolData.cpp
;	COMDAT ?SetBuletType@CSymbolData@@QAEXW4TOOLTYPE@CSymbolBaseData@@@Z
_TEXT	SEGMENT
_bulettype$ = 8						; size = 4
?SetBuletType@CSymbolData@@QAEXW4TOOLTYPE@CSymbolBaseData@@@Z PROC ; CSymbolData::SetBuletType, COMDAT
; _this$ = ecx

; 136  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 137  : 	//, , text ..
; 138  : 	// Dlg   .. .
; 139  : 	//dlg     .
; 140  : 	if(bulettype != CSymbolBaseData::SYMBOL_SQUARE && bulettype != CSymbolBaseData::SYMBOL_CIRCLE && bulettype != CSymbolBaseData::SYMBOL_TRIANGLE && bulettype != CSymbolBaseData::SYMBOL_TEXT)

  00003	8b 45 08	 mov	 eax, DWORD PTR _bulettype$[ebp]
  00006	83 f8 01	 cmp	 eax, 1
  00009	74 12		 je	 SHORT $LN2@SetBuletTy
  0000b	83 f8 02	 cmp	 eax, 2
  0000e	74 0d		 je	 SHORT $LN2@SetBuletTy
  00010	83 f8 03	 cmp	 eax, 3
  00013	74 08		 je	 SHORT $LN2@SetBuletTy
  00015	83 f8 04	 cmp	 eax, 4
  00018	74 03		 je	 SHORT $LN2@SetBuletTy

; 141  : 		m_TYPEBulet = bulettype;

  0001a	89 41 20	 mov	 DWORD PTR [ecx+32], eax
$LN2@SetBuletTy:

; 142  : }

  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?SetBuletType@CSymbolData@@QAEXW4TOOLTYPE@CSymbolBaseData@@@Z ENDP ; CSymbolData::SetBuletType
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\SymbolData.cpp
;	COMDAT ?SetSymbolType@CSymbolData@@QAEXW4TOOLTYPE@CSymbolBaseData@@@Z
_TEXT	SEGMENT
_symboltype$ = 8					; size = 4
?SetSymbolType@CSymbolData@@QAEXW4TOOLTYPE@CSymbolBaseData@@@Z PROC ; CSymbolData::SetSymbolType, COMDAT
; _this$ = ecx

; 131  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 132  : 	m_TYPESymbol = symboltype;

  00003	8b 45 08	 mov	 eax, DWORD PTR _symboltype$[ebp]
  00006	89 41 1c	 mov	 DWORD PTR [ecx+28], eax

; 133  : }

  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?SetSymbolType@CSymbolData@@QAEXW4TOOLTYPE@CSymbolBaseData@@@Z ENDP ; CSymbolData::SetSymbolType
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\SymbolData.cpp
;	COMDAT ?SetParent@CSymbolData@@QAEXPAVCWnd@@@Z
_TEXT	SEGMENT
_pParent$ = 8						; size = 4
?SetParent@CSymbolData@@QAEXPAVCWnd@@@Z PROC		; CSymbolData::SetParent, COMDAT
; _this$ = ecx

; 54   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 55   : 	m_pParent = pParent;

  00003	8b 45 08	 mov	 eax, DWORD PTR _pParent$[ebp]
  00006	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 56   : }

  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?SetParent@CSymbolData@@QAEXPAVCWnd@@@Z ENDP		; CSymbolData::SetParent
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\SymbolData.cpp
;	COMDAT ?SetUserFilePath@CSymbolData@@QAEXABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
_TEXT	SEGMENT
_filepath$ = 8						; size = 4
?SetUserFilePath@CSymbolData@@QAEXABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z PROC ; CSymbolData::SetUserFilePath, COMDAT
; _this$ = ecx

; 74   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 75   : 	m_strUserFilePath = filepath;

  00003	83 c1 18	 add	 ecx, 24			; 00000018H

; 76   : }

  00006	5d		 pop	 ebp

; 75   : 	m_strUserFilePath = filepath;

  00007	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
?SetUserFilePath@CSymbolData@@QAEXABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ENDP ; CSymbolData::SetUserFilePath
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\SymbolData.cpp
;	COMDAT ?SetFilePath@CSymbolData@@QAEXABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
_TEXT	SEGMENT
_filepath$ = 8						; size = 4
?SetFilePath@CSymbolData@@QAEXABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z PROC ; CSymbolData::SetFilePath, COMDAT
; _this$ = ecx

; 64   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 65   : 	m_strFilePath = filepath;

  00003	83 c1 14	 add	 ecx, 20			; 00000014H

; 66   : }

  00006	5d		 pop	 ebp

; 65   : 	m_strFilePath = filepath;

  00007	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
?SetFilePath@CSymbolData@@QAEXABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ENDP ; CSymbolData::SetFilePath
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\SymbolData.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Include_AddIn_133101\I133101\_IString.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\SymbolData.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Include_AddIn_133101\I133101\_IString.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\SymbolData.cpp
;	COMDAT ?SetMainBlock_Object@CSymbolData@@QAEXPAUIChartManager133101@@PAUIChartOCX133101@@@Z
_TEXT	SEGMENT
_szUserFilePath$ = -20					; size = 8
__$EHRec$ = -12						; size = 12
_pMainBlock$ = 8					; size = 4
_p_pIChartOCX$ = 12					; size = 4
?SetMainBlock_Object@CSymbolData@@QAEXPAUIChartManager133101@@PAUIChartOCX133101@@@Z PROC ; CSymbolData::SetMainBlock_Object, COMDAT
; _this$ = ecx

; 89   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?SetMainBlock_Object@CSymbolData@@QAEXPAUIChartManager133101@@PAUIChartOCX133101@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	50		 push	 eax
  0001e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00027	8b f1		 mov	 esi, ecx

; 90   : 	if( m_pIChartOCX) m_pIChartOCX->Release();

  00029	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0002c	85 c9		 test	 ecx, ecx
  0002e	74 06		 je	 SHORT $LN2@SetMainBlo
  00030	8b 01		 mov	 eax, DWORD PTR [ecx]
  00032	51		 push	 ecx
  00033	ff 50 08	 call	 DWORD PTR [eax+8]
$LN2@SetMainBlo:

; 91   : 	m_pIChartOCX = p_pIChartOCX;

  00036	8b 7d 0c	 mov	 edi, DWORD PTR _p_pIChartOCX$[ebp]
  00039	89 7e 10	 mov	 DWORD PTR [esi+16], edi

; 92   : 	if(m_pIChartOCX) p_pIChartOCX->AddRef();

  0003c	85 ff		 test	 edi, edi
  0003e	74 06		 je	 SHORT $LN3@SetMainBlo
  00040	8b 07		 mov	 eax, DWORD PTR [edi]
  00042	57		 push	 edi
  00043	ff 50 04	 call	 DWORD PTR [eax+4]
$LN3@SetMainBlo:

; 93   : 
; 94   : 	if( m_pMainBlock) m_pMainBlock->Release();

  00046	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00049	85 c9		 test	 ecx, ecx
  0004b	74 06		 je	 SHORT $LN4@SetMainBlo
  0004d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0004f	51		 push	 ecx
  00050	ff 50 08	 call	 DWORD PTR [eax+8]
$LN4@SetMainBlo:

; 95   : 	m_pMainBlock = pMainBlock;

  00053	8b 4d 08	 mov	 ecx, DWORD PTR _pMainBlock$[ebp]
  00056	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 96   : 	if(m_pMainBlock) m_pMainBlock->AddRef();

  00059	85 c9		 test	 ecx, ecx
  0005b	74 06		 je	 SHORT $LN5@SetMainBlo
  0005d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0005f	51		 push	 ecx
  00060	ff 50 04	 call	 DWORD PTR [eax+4]
$LN5@SetMainBlo:

; 97   : 
; 98   : 	if( m_pIDefaultPacketManager) 

  00063	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00066	85 c9		 test	 ecx, ecx
  00068	74 06		 je	 SHORT $LN6@SetMainBlo

; 99   : 		m_pIDefaultPacketManager->Release();	

  0006a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0006c	51		 push	 ecx
  0006d	ff 50 08	 call	 DWORD PTR [eax+8]
$LN6@SetMainBlo:

; 100  : 	m_pIDefaultPacketManager = p_pIChartOCX->GetIDefaultPacketManager();

  00070	8b 07		 mov	 eax, DWORD PTR [edi]
  00072	8b cf		 mov	 ecx, edi
  00074	ff 50 20	 call	 DWORD PTR [eax+32]
  00077	89 46 0c	 mov	 DWORD PTR [esi+12], eax

; 102  : 	ILPCSTR szUserFilePath = p_pIChartOCX->GetUserFilePathString();

  0007a	8b cf		 mov	 ecx, edi
  0007c	8b 07		 mov	 eax, DWORD PTR [edi]
  0007e	ff 50 64	 call	 DWORD PTR [eax+100]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Include_AddIn_133101\I133101\_IString.h

; 39   : 		m_pIStrData = p_pIString;	// Do not AddRef(). Because It must be Return Value.

  00081	8b f8		 mov	 edi, eax
  00083	89 7d f0	 mov	 DWORD PTR _szUserFilePath$[ebp+4], edi

; 40   : 		if( m_pIStrData) m_szData = m_pIStrData->GetData();

  00086	85 ff		 test	 edi, edi
  00088	74 09		 je	 SHORT $LN11@SetMainBlo
  0008a	8b 17		 mov	 edx, DWORD PTR [edi]
  0008c	8b cf		 mov	 ecx, edi
  0008e	ff 52 10	 call	 DWORD PTR [edx+16]
  00091	eb 02		 jmp	 SHORT $LN19@SetMainBlo
$LN11@SetMainBlo:

; 41   : 		else m_szData = NULL;

  00093	33 c0		 xor	 eax, eax
$LN19@SetMainBlo:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\SymbolData.cpp

; 102  : 	ILPCSTR szUserFilePath = p_pIChartOCX->GetUserFilePathString();

  00095	89 45 ec	 mov	 DWORD PTR _szUserFilePath$[ebp], eax

; 103  : 	m_strUserFilePath = szUserFilePath;

  00098	50		 push	 eax
  00099	8d 4e 18	 lea	 ecx, DWORD PTR [esi+24]
  0009c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  000a3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z

; 104  : 
; 105  : 	// 20081007 JS.Kim	 
; 106  : 	if( m_pIPacketListManager) m_pIPacketListManager->Release();

  000a9	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  000af	85 c9		 test	 ecx, ecx
  000b1	74 06		 je	 SHORT $LN7@SetMainBlo
  000b3	8b 01		 mov	 eax, DWORD PTR [ecx]
  000b5	51		 push	 ecx
  000b6	ff 50 08	 call	 DWORD PTR [eax+8]
$LN7@SetMainBlo:

; 107  : 	m_pIPacketListManager = m_pIChartOCX->GetIPacketListManager();

  000b9	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  000bc	8b 01		 mov	 eax, DWORD PTR [ecx]
  000be	ff 50 1c	 call	 DWORD PTR [eax+28]
  000c1	89 86 fc 00 00
	00		 mov	 DWORD PTR [esi+252], eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Include_AddIn_133101\I133101\_IString.h

; 44   : 	{

  000c7	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1

; 45   : 		if( m_pIStrData)

  000ce	85 ff		 test	 edi, edi
  000d0	74 06		 je	 SHORT $LN15@SetMainBlo

; 46   : 		{
; 47   : 			m_pIStrData->Release();

  000d2	8b 07		 mov	 eax, DWORD PTR [edi]
  000d4	57		 push	 edi
  000d5	ff 50 08	 call	 DWORD PTR [eax+8]
$LN15@SetMainBlo:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\SymbolData.cpp

; 108  : }

  000d8	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000db	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000e2	59		 pop	 ecx
  000e3	5f		 pop	 edi
  000e4	5e		 pop	 esi
  000e5	8b e5		 mov	 esp, ebp
  000e7	5d		 pop	 ebp
  000e8	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SetMainBlock_Object@CSymbolData@@QAEXPAUIChartManager133101@@PAUIChartOCX133101@@@Z$0:
  00000	8d 4d ec	 lea	 ecx, DWORD PTR _szUserFilePath$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1ILPCSTR133101@@QAE@XZ ; ILPCSTR133101::~ILPCSTR133101
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?SetMainBlock_Object@CSymbolData@@QAEXPAUIChartManager133101@@PAUIChartOCX133101@@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?SetMainBlock_Object@CSymbolData@@QAEXPAUIChartManager133101@@PAUIChartOCX133101@@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?SetMainBlock_Object@CSymbolData@@QAEXPAUIChartManager133101@@PAUIChartOCX133101@@@Z ENDP ; CSymbolData::SetMainBlock_Object
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\SymbolData.cpp
;	COMDAT ?UnRegisterElementToOrderManager@CSymbolData@@QAEXJ@Z
_TEXT	SEGMENT
_lElementAdress$ = 8					; size = 4
?UnRegisterElementToOrderManager@CSymbolData@@QAEXJ@Z PROC ; CSymbolData::UnRegisterElementToOrderManager, COMDAT
; _this$ = ecx

; 199  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 200  : 	IAddInToolMgr* pAddInToolManager = m_pIChartOCX->GetIAddInToolMgr();

  00003	8b 49 10	 mov	 ecx, DWORD PTR [ecx+16]
  00006	56		 push	 esi
  00007	8b 01		 mov	 eax, DWORD PTR [ecx]
  00009	ff 50 28	 call	 DWORD PTR [eax+40]

; 201  : 	pAddInToolManager->OnAddInToolCommand(EAI_TOOLORDERMGR_DELETE_TOOL_FROM_ORDERMANAGER,

  0000c	ff 75 08	 push	 DWORD PTR _lElementAdress$[ebp]
  0000f	8b f0		 mov	 esi, eax
  00011	ff 35 00 00 00
	00		 push	 DWORD PTR ?m_strAddInItemName@CSymbolData@@2V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A ; CSymbolData::m_strAddInItemName
  00017	8b ce		 mov	 ecx, esi
  00019	6a 32		 push	 50			; 00000032H
  0001b	8b 16		 mov	 edx, DWORD PTR [esi]
  0001d	ff 92 a0 00 00
	00		 call	 DWORD PTR [edx+160]

; 202  : 															m_strAddInItemName,lElementAdress);
; 203  : 	pAddInToolManager->Release();

  00023	8b 06		 mov	 eax, DWORD PTR [esi]
  00025	56		 push	 esi
  00026	ff 50 08	 call	 DWORD PTR [eax+8]
  00029	5e		 pop	 esi

; 204  : }

  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
?UnRegisterElementToOrderManager@CSymbolData@@QAEXJ@Z ENDP ; CSymbolData::UnRegisterElementToOrderManager
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\SymbolData.cpp
;	COMDAT ?RegisterElementToOrderManager@CSymbolData@@QAEXJ@Z
_TEXT	SEGMENT
_lElementAdress$ = 8					; size = 4
?RegisterElementToOrderManager@CSymbolData@@QAEXJ@Z PROC ; CSymbolData::RegisterElementToOrderManager, COMDAT
; _this$ = ecx

; 191  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 192  : 	IAddInToolMgr* pAddInToolManager = m_pIChartOCX->GetIAddInToolMgr();

  00003	8b 49 10	 mov	 ecx, DWORD PTR [ecx+16]
  00006	56		 push	 esi
  00007	8b 01		 mov	 eax, DWORD PTR [ecx]
  00009	ff 50 28	 call	 DWORD PTR [eax+40]

; 193  : 	pAddInToolManager->OnAddInToolCommand(EAI_TOOLORDERMGR_ADD_TOOL_TO_ORDERMANAGER,

  0000c	ff 75 08	 push	 DWORD PTR _lElementAdress$[ebp]
  0000f	8b f0		 mov	 esi, eax
  00011	ff 35 00 00 00
	00		 push	 DWORD PTR ?m_strAddInItemName@CSymbolData@@2V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A ; CSymbolData::m_strAddInItemName
  00017	8b ce		 mov	 ecx, esi
  00019	6a 31		 push	 49			; 00000031H
  0001b	8b 16		 mov	 edx, DWORD PTR [esi]
  0001d	ff 92 a0 00 00
	00		 call	 DWORD PTR [edx+160]

; 194  : 															m_strAddInItemName,lElementAdress);
; 195  : 	pAddInToolManager->Release();

  00023	8b 06		 mov	 eax, DWORD PTR [esi]
  00025	56		 push	 esi
  00026	ff 50 08	 call	 DWORD PTR [eax+8]
  00029	5e		 pop	 esi

; 196  : }

  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
?RegisterElementToOrderManager@CSymbolData@@QAEXJ@Z ENDP ; CSymbolData::RegisterElementToOrderManager
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\SymbolData.cpp
;	COMDAT ?GetUserFilePath@CSymbolData@@QBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?GetUserFilePath@CSymbolData@@QBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ PROC ; CSymbolData::GetUserFilePath, COMDAT
; _this$ = ecx

; 79   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 80   : 	return m_strUserFilePath;

  00003	8d 41 18	 lea	 eax, DWORD PTR [ecx+24]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00009	50		 push	 eax
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z
  00010	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 81   : }

  00013	5d		 pop	 ebp
  00014	c2 04 00	 ret	 4
?GetUserFilePath@CSymbolData@@QBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ ENDP ; CSymbolData::GetUserFilePath
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\SymbolData.cpp
;	COMDAT ?GetSavedSymbolsData@CSymbolData@@QAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?GetSavedSymbolsData@CSymbolData@@QAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ PROC ; CSymbolData::GetSavedSymbolsData, COMDAT
; _this$ = ecx

; 170  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 171  : 	return m_elementTree.GetSavedSymbolsData();

  00003	ff 75 08	 push	 DWORD PTR ___$ReturnUdt$[ebp]
  00006	83 e9 80	 sub	 ecx, -128		; ffffff80H
  00009	e8 00 00 00 00	 call	 ?GetSavedSymbolsData@CElementTree@@QAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ ; CElementTree::GetSavedSymbolsData
  0000e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 172  : }

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?GetSavedSymbolsData@CSymbolData@@QAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ ENDP ; CSymbolData::GetSavedSymbolsData
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\SymbolData.cpp
;	COMDAT ?GetBuletType@CSymbolData@@QBE?AW4TOOLTYPE@CSymbolBaseData@@XZ
_TEXT	SEGMENT
?GetBuletType@CSymbolData@@QBE?AW4TOOLTYPE@CSymbolBaseData@@XZ PROC ; CSymbolData::GetBuletType, COMDAT
; _this$ = ecx

; 151  : 	return m_TYPEBulet;

  00000	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]

; 152  : }

  00003	c3		 ret	 0
?GetBuletType@CSymbolData@@QBE?AW4TOOLTYPE@CSymbolBaseData@@XZ ENDP ; CSymbolData::GetBuletType
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\SymbolData.cpp
;	COMDAT ?GetSymbolType@CSymbolData@@QBE?AW4TOOLTYPE@CSymbolBaseData@@XZ
_TEXT	SEGMENT
?GetSymbolType@CSymbolData@@QBE?AW4TOOLTYPE@CSymbolBaseData@@XZ PROC ; CSymbolData::GetSymbolType, COMDAT
; _this$ = ecx

; 146  : 	return m_TYPESymbol;

  00000	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]

; 147  : }

  00003	c3		 ret	 0
?GetSymbolType@CSymbolData@@QBE?AW4TOOLTYPE@CSymbolBaseData@@XZ ENDP ; CSymbolData::GetSymbolType
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\SymbolData.cpp
;	COMDAT ?CopySymbol@CSymbolData@@QAEPAVCDrawingSymbol@@PAV2@@Z
_TEXT	SEGMENT
_pDrawingSymbol$ = 8					; size = 4
?CopySymbol@CSymbolData@@QAEPAVCDrawingSymbol@@PAV2@@Z PROC ; CSymbolData::CopySymbol, COMDAT
; _this$ = ecx

; 208  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 209  : 	if(pDrawingSymbol == NULL)

  00003	8b 45 08	 mov	 eax, DWORD PTR _pDrawingSymbol$[ebp]
  00006	53		 push	 ebx
  00007	8b d9		 mov	 ebx, ecx
  00009	85 c0		 test	 eax, eax
  0000b	75 05		 jne	 SHORT $LN2@CopySymbol
  0000d	5b		 pop	 ebx

; 219  : }

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
$LN2@CopySymbol:
  00012	56		 push	 esi
  00013	57		 push	 edi

; 210  : 		return NULL;
; 211  : 
; 212  : 	CDrawingSymbol* pNewDrawingSymbol = (CDrawingSymbol*)m_elementTree.CopyElement(pDrawingSymbol);

  00014	50		 push	 eax
  00015	8d 8b 80 00 00
	00		 lea	 ecx, DWORD PTR [ebx+128]
  0001b	e8 00 00 00 00	 call	 ?CopyElement@CElementTree@@QAEJPAVCDrawingSymbol@@@Z ; CElementTree::CopyElement

; 192  : 	IAddInToolMgr* pAddInToolManager = m_pIChartOCX->GetIAddInToolMgr();

  00020	8b 4b 10	 mov	 ecx, DWORD PTR [ebx+16]

; 210  : 		return NULL;
; 211  : 
; 212  : 	CDrawingSymbol* pNewDrawingSymbol = (CDrawingSymbol*)m_elementTree.CopyElement(pDrawingSymbol);

  00023	8b f8		 mov	 edi, eax

; 192  : 	IAddInToolMgr* pAddInToolManager = m_pIChartOCX->GetIAddInToolMgr();

  00025	8b 11		 mov	 edx, DWORD PTR [ecx]
  00027	ff 52 28	 call	 DWORD PTR [edx+40]
  0002a	8b f0		 mov	 esi, eax

; 193  : 	pAddInToolManager->OnAddInToolCommand(EAI_TOOLORDERMGR_ADD_TOOL_TO_ORDERMANAGER,

  0002c	57		 push	 edi
  0002d	ff 35 00 00 00
	00		 push	 DWORD PTR ?m_strAddInItemName@CSymbolData@@2V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A ; CSymbolData::m_strAddInItemName
  00033	8b ce		 mov	 ecx, esi
  00035	8b 16		 mov	 edx, DWORD PTR [esi]
  00037	6a 31		 push	 49			; 00000031H
  00039	ff 92 a0 00 00
	00		 call	 DWORD PTR [edx+160]

; 194  : 															m_strAddInItemName,lElementAdress);
; 195  : 	pAddInToolManager->Release();

  0003f	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00041	56		 push	 esi
  00042	ff 51 08	 call	 DWORD PTR [ecx+8]

; 213  : 	RegisterElementToOrderManager((long)pNewDrawingSymbol);
; 214  : 
; 215  : 	// Undo / Redo
; 216  : 	GetUndoRedoManager().RegisterElementToUnRedoManager(URT_NEW_OR_DEL, (long)pNewDrawingSymbol);

  00045	6a 00		 push	 0
  00047	6a 00		 push	 0
  00049	57		 push	 edi
  0004a	6a 01		 push	 1
  0004c	8d 8b c0 00 00
	00		 lea	 ecx, DWORD PTR [ebx+192]
  00052	e8 00 00 00 00	 call	 ?RegisterElementToUnRedoManager@CUndoRedoManager@@QAEXHJPBD0@Z ; CUndoRedoManager::RegisterElementToUnRedoManager

; 217  : 
; 218  : 	return pNewDrawingSymbol;

  00057	8b c7		 mov	 eax, edi
  00059	5f		 pop	 edi
  0005a	5e		 pop	 esi
  0005b	5b		 pop	 ebx

; 219  : }

  0005c	5d		 pop	 ebp
  0005d	c2 04 00	 ret	 4
?CopySymbol@CSymbolData@@QAEPAVCDrawingSymbol@@PAV2@@Z ENDP ; CSymbolData::CopySymbol
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\SymbolData.cpp
;	COMDAT ?GetElementTree@CSymbolData@@QAEPAVCElementTree@@XZ
_TEXT	SEGMENT
?GetElementTree@CSymbolData@@QAEPAVCElementTree@@XZ PROC ; CSymbolData::GetElementTree, COMDAT
; _this$ = ecx

; 161  : 	return &m_elementTree;

  00000	8d 81 80 00 00
	00		 lea	 eax, DWORD PTR [ecx+128]

; 162  : }

  00006	c3		 ret	 0
?GetElementTree@CSymbolData@@QAEPAVCElementTree@@XZ ENDP ; CSymbolData::GetElementTree
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\SymbolData.cpp
;	COMDAT ?GetParent@CSymbolData@@QBEPAVCWnd@@XZ
_TEXT	SEGMENT
?GetParent@CSymbolData@@QBEPAVCWnd@@XZ PROC		; CSymbolData::GetParent, COMDAT
; _this$ = ecx

; 60   : 	return m_pParent;

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 61   : }

  00003	c3		 ret	 0
?GetParent@CSymbolData@@QBEPAVCWnd@@XZ ENDP		; CSymbolData::GetParent
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\SymbolData.cpp
;	COMDAT ?GetFilePath@CSymbolData@@QBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?GetFilePath@CSymbolData@@QBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ PROC ; CSymbolData::GetFilePath, COMDAT
; _this$ = ecx

; 69   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 70   : 	return m_strFilePath;

  00003	8d 41 14	 lea	 eax, DWORD PTR [ecx+20]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00009	50		 push	 eax
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z
  00010	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 71   : }

  00013	5d		 pop	 ebp
  00014	c2 04 00	 ret	 4
?GetFilePath@CSymbolData@@QBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ ENDP ; CSymbolData::GetFilePath
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\SymbolData.cpp
;	COMDAT ?GetPropertiesData@CSymbolData@@QAEPAVCPropertiesData_text@@XZ
_TEXT	SEGMENT
?GetPropertiesData@CSymbolData@@QAEPAVCPropertiesData_text@@XZ PROC ; CSymbolData::GetPropertiesData, COMDAT
; _this$ = ecx

; 85   : 	return &m_Properties;

  00000	8d 41 24	 lea	 eax, DWORD PTR [ecx+36]

; 86   : }

  00003	c3		 ret	 0
?GetPropertiesData@CSymbolData@@QAEPAVCPropertiesData_text@@XZ ENDP ; CSymbolData::GetPropertiesData
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\SymbolData.cpp
;	COMDAT ?GetChartOCX@CSymbolData@@QBEPAUIChartOCX133101@@XZ
_TEXT	SEGMENT
?GetChartOCX@CSymbolData@@QBEPAUIChartOCX133101@@XZ PROC ; CSymbolData::GetChartOCX, COMDAT
; _this$ = ecx

; 124  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 125  : 	if( m_pIChartOCX) 

  00003	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  00006	85 d2		 test	 edx, edx
  00008	74 0b		 je	 SHORT $LN4@GetChartOC

; 126  : 		m_pIChartOCX->AddRef();

  0000a	8b 02		 mov	 eax, DWORD PTR [edx]
  0000c	52		 push	 edx
  0000d	ff 50 04	 call	 DWORD PTR [eax+4]

; 127  : 	return m_pIChartOCX;

  00010	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00013	5e		 pop	 esi

; 128  : }

  00014	c3		 ret	 0
$LN4@GetChartOC:

; 127  : 	return m_pIChartOCX;

  00015	8b c2		 mov	 eax, edx
  00017	5e		 pop	 esi

; 128  : }

  00018	c3		 ret	 0
?GetChartOCX@CSymbolData@@QBEPAUIChartOCX133101@@XZ ENDP ; CSymbolData::GetChartOCX
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\SymbolData.cpp
;	COMDAT ?GetPacketManager@CSymbolData@@QBEPAUIPacketManager133101@@XZ
_TEXT	SEGMENT
?GetPacketManager@CSymbolData@@QBEPAUIPacketManager133101@@XZ PROC ; CSymbolData::GetPacketManager, COMDAT
; _this$ = ecx

; 117  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 118  : 	if( m_pIDefaultPacketManager) 

  00003	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  00006	85 d2		 test	 edx, edx
  00008	74 0b		 je	 SHORT $LN4@GetPacketM

; 119  : 		m_pIDefaultPacketManager->AddRef();

  0000a	8b 02		 mov	 eax, DWORD PTR [edx]
  0000c	52		 push	 edx
  0000d	ff 50 04	 call	 DWORD PTR [eax+4]

; 120  : 	return m_pIDefaultPacketManager;

  00010	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00013	5e		 pop	 esi

; 121  : }

  00014	c3		 ret	 0
$LN4@GetPacketM:

; 120  : 	return m_pIDefaultPacketManager;

  00015	8b c2		 mov	 eax, edx
  00017	5e		 pop	 esi

; 121  : }

  00018	c3		 ret	 0
?GetPacketManager@CSymbolData@@QBEPAUIPacketManager133101@@XZ ENDP ; CSymbolData::GetPacketManager
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\SymbolData.cpp
;	COMDAT ?GetMainBlock@CSymbolData@@QBEPAUIChartManager133101@@XZ
_TEXT	SEGMENT
?GetMainBlock@CSymbolData@@QBEPAUIChartManager133101@@XZ PROC ; CSymbolData::GetMainBlock, COMDAT
; _this$ = ecx

; 111  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 112  : 	if( m_pMainBlock) m_pMainBlock->AddRef();

  00003	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00006	85 d2		 test	 edx, edx
  00008	74 0b		 je	 SHORT $LN4@GetMainBlo
  0000a	8b 02		 mov	 eax, DWORD PTR [edx]
  0000c	52		 push	 edx
  0000d	ff 50 04	 call	 DWORD PTR [eax+4]

; 113  : 	return m_pMainBlock;

  00010	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00013	5e		 pop	 esi

; 114  : }

  00014	c3		 ret	 0
$LN4@GetMainBlo:

; 113  : 	return m_pMainBlock;

  00015	8b c2		 mov	 eax, edx
  00017	5e		 pop	 esi

; 114  : }

  00018	c3		 ret	 0
?GetMainBlock@CSymbolData@@QBEPAUIChartManager133101@@XZ ENDP ; CSymbolData::GetMainBlock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\SymbolData.cpp
;	COMDAT ??1CSymbolData@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1CSymbolData@@QAE@XZ PROC				; CSymbolData::~CSymbolData, COMDAT
; _this$ = ecx

; 42   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CSymbolData@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f9		 mov	 edi, ecx

; 43   : 	if( m_pIChartOCX) 

  00026	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  00029	85 c9		 test	 ecx, ecx
  0002b	74 06		 je	 SHORT $LN2@CSymbolDat

; 44   : 		m_pIChartOCX->Release();

  0002d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0002f	51		 push	 ecx
  00030	ff 50 08	 call	 DWORD PTR [eax+8]
$LN2@CSymbolDat:

; 45   : 	if( m_pMainBlock) 

  00033	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00036	85 c9		 test	 ecx, ecx
  00038	74 06		 je	 SHORT $LN3@CSymbolDat

; 46   : 		m_pMainBlock->Release();

  0003a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0003c	51		 push	 ecx
  0003d	ff 50 08	 call	 DWORD PTR [eax+8]
$LN3@CSymbolDat:

; 47   : 	if( m_pIDefaultPacketManager) 

  00040	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  00043	85 c9		 test	 ecx, ecx
  00045	74 06		 je	 SHORT $LN4@CSymbolDat

; 48   : 		m_pIDefaultPacketManager->Release();

  00047	8b 01		 mov	 eax, DWORD PTR [ecx]
  00049	51		 push	 ecx
  0004a	ff 50 08	 call	 DWORD PTR [eax+8]
$LN4@CSymbolDat:

; 49   : 	// 20081007 JS.Kim	 
; 50   : 	if( m_pIPacketListManager) m_pIPacketListManager->Release();

  0004d	8b 8f fc 00 00
	00		 mov	 ecx, DWORD PTR [edi+252]
  00053	85 c9		 test	 ecx, ecx
  00055	74 06		 je	 SHORT $LN5@CSymbolDat
  00057	8b 01		 mov	 eax, DWORD PTR [ecx]
  00059	51		 push	 ecx
  0005a	ff 50 08	 call	 DWORD PTR [eax+8]
$LN5@CSymbolDat:

; 51   : }

  0005d	8d 8f c0 00 00
	00		 lea	 ecx, DWORD PTR [edi+192]
  00063	e8 00 00 00 00	 call	 ??1CUndoRedoManager@@QAE@XZ ; CUndoRedoManager::~CUndoRedoManager
  00068	8d 8f a0 00 00
	00		 lea	 ecx, DWORD PTR [edi+160]
  0006e	e8 00 00 00 00	 call	 ??1CTree@@UAE@XZ	; CTree::~CTree
  00073	8d 8f 80 00 00
	00		 lea	 ecx, DWORD PTR [edi+128]
  00079	e8 00 00 00 00	 call	 ??1COrder@@UAE@XZ	; COrder::~COrder
  0007e	8d 4f 24	 lea	 ecx, DWORD PTR [edi+36]
  00081	e8 00 00 00 00	 call	 ??1CPropertiesData_text@@UAE@XZ ; CPropertiesData_text::~CPropertiesData_text
  00086	8d 4f 18	 lea	 ecx, DWORD PTR [edi+24]
  00089	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0008f	8d 4f 14	 lea	 ecx, DWORD PTR [edi+20]
  00092	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00098	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0009b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a2	59		 pop	 ecx
  000a3	5f		 pop	 edi
  000a4	5e		 pop	 esi
  000a5	8b e5		 mov	 esp, ebp
  000a7	5d		 pop	 ebp
  000a8	c3		 ret	 0
  000a9	cc		 int	 3
  000aa	cc		 int	 3
  000ab	cc		 int	 3
  000ac	cc		 int	 3
  000ad	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1CSymbolData@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CSymbolData@@QAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CSymbolData@@QAE@XZ ENDP				; CSymbolData::~CSymbolData
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\SymbolData.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\SymbolData.cpp
;	COMDAT ??0CSymbolData@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CSymbolData@@QAE@XZ PROC				; CSymbolData::CSymbolData, COMDAT
; _this$ = ecx

; 30   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CSymbolData@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f9		 mov	 edi, ecx
  00027	89 7d f0	 mov	 DWORD PTR _this$[ebp], edi

; 28   : 	m_strFilePath(""),

  0002a	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@@
  0002f	8d 4f 14	 lea	 ecx, DWORD PTR [edi+20]
  00032	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0
  00039	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0
  00040	c7 47 0c 00 00
	00 00		 mov	 DWORD PTR [edi+12], 0
  00047	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0
  0004e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z

; 30   : {

  00054	8d 4f 18	 lea	 ecx, DWORD PTR [edi+24]
  00057	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0005e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00064	8d 4f 24	 lea	 ecx, DWORD PTR [edi+36]
  00067	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0006b	c7 47 20 07 00
	00 00		 mov	 DWORD PTR [edi+32], 7
  00072	e8 00 00 00 00	 call	 ??0CPropertiesData_text@@QAE@XZ ; CPropertiesData_text::CPropertiesData_text
  00077	c7 87 80 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+128], OFFSET ??_7COrder@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 851  : {

  00081	c7 87 84 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+132], OFFSET ??_7?$CList@PAVCDrawingSymbol@@PAV1@@@6B@

; 852  : 	ASSERT(nBlockSize > 0);
; 853  : 
; 854  : 	m_nCount = 0;

  0008b	c7 87 90 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+144], 0

; 855  : 	m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;

  00095	c7 87 94 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+148], 0
  0009f	c7 87 8c 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+140], 0
  000a9	c7 87 88 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+136], 0

; 856  : 	m_pBlocks = NULL;

  000b3	c7 87 98 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+152], 0

; 857  : 	m_nBlockSize = nBlockSize;

  000bd	c7 87 9c 00 00
	00 0a 00 00 00	 mov	 DWORD PTR [edi+156], 10	; 0000000aH
  000c7	c7 87 a0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+160], OFFSET ??_7CTree@@6B@

; 851  : {

  000d1	c7 87 a4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+164], OFFSET ??_7?$CList@PAVCDrawingSymbolColumn@@PAV1@@@6B@

; 852  : 	ASSERT(nBlockSize > 0);
; 853  : 
; 854  : 	m_nCount = 0;

  000db	c7 87 b0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+176], 0

; 855  : 	m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;

  000e5	c7 87 b4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+180], 0
  000ef	c7 87 ac 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+172], 0
  000f9	c7 87 a8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+168], 0

; 856  : 	m_pBlocks = NULL;

  00103	c7 87 b8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+184], 0

; 857  : 	m_nBlockSize = nBlockSize;

  0010d	c7 87 bc 00 00
	00 0a 00 00 00	 mov	 DWORD PTR [edi+188], 10	; 0000000aH
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\SymbolData.cpp

; 30   : {

  00117	8d 8f c0 00 00
	00		 lea	 ecx, DWORD PTR [edi+192]
  0011d	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  00121	e8 00 00 00 00	 call	 ??0CUndoRedoManager@@QAE@XZ ; CUndoRedoManager::CUndoRedoManager

; 31   : 	GetUndoRedoManager().SetSymbolData(this);	// Undo / Redo

  00126	57		 push	 edi
  00127	8d 8f c0 00 00
	00		 lea	 ecx, DWORD PTR [edi+192]
  0012d	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  00131	e8 00 00 00 00	 call	 ?SetSymbolData@CUndoRedoManager@@QAEXPAVCSymbolData@@@Z ; CUndoRedoManager::SetSymbolData

; 32   : 
; 33   : 	// 20081007 JS.Kim	 
; 34   : 	m_pIPacketListManager = NULL;

  00136	c7 87 fc 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+252], 0

; 35   : 
; 36   : 	// 2011.02.07 by SYS >>  YYYY()  : / 14Byte  (YYYYMMDDhhmmss)
; 37   : 	m_eScaleType	= CScaleBaseData::HORZ_DAILY;
; 38   : 	// 2011.02.07 by SYS <<
; 39   : }

  00140	8b c7		 mov	 eax, edi
  00142	c7 07 01 00 00
	00		 mov	 DWORD PTR [edi], 1
  00148	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0014b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00152	59		 pop	 ecx
  00153	5f		 pop	 edi
  00154	5e		 pop	 esi
  00155	8b e5		 mov	 esp, ebp
  00157	5d		 pop	 ebp
  00158	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CSymbolData@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 14	 add	 ecx, 20			; 00000014H
  00006	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$??0CSymbolData@@QAE@XZ$1:
  0000c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	83 c1 18	 add	 ecx, 24			; 00000018H
  00012	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$??0CSymbolData@@QAE@XZ$2:
  00018	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	83 c1 24	 add	 ecx, 36			; 00000024H
  0001e	e9 00 00 00 00	 jmp	 ??1CPropertiesData_text@@UAE@XZ ; CPropertiesData_text::~CPropertiesData_text
__unwindfunclet$??0CSymbolData@@QAE@XZ$3:
  00023	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  0002c	e9 00 00 00 00	 jmp	 ??1CElementTree@@QAE@XZ
__unwindfunclet$??0CSymbolData@@QAE@XZ$4:
  00031	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	81 c1 c0 00 00
	00		 add	 ecx, 192		; 000000c0H
  0003a	e9 00 00 00 00	 jmp	 ??1CUndoRedoManager@@QAE@XZ ; CUndoRedoManager::~CUndoRedoManager
  0003f	cc		 int	 3
  00040	cc		 int	 3
  00041	cc		 int	 3
  00042	cc		 int	 3
  00043	cc		 int	 3
__ehhandler$??0CSymbolData@@QAE@XZ:
  00044	90		 npad	 1
  00045	90		 npad	 1
  00046	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0004a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0004d	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00050	33 c8		 xor	 ecx, eax
  00052	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00057	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CSymbolData@@QAE@XZ
  0005c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CSymbolData@@QAE@XZ ENDP				; CSymbolData::CSymbolData
; Function compile flags: /Ogtp
;	COMDAT ??1CElementTree@@QAE@XZ
_TEXT	SEGMENT
??1CElementTree@@QAE@XZ PROC				; CElementTree::~CElementTree, COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8d 4e 20	 lea	 ecx, DWORD PTR [esi+32]
  00006	e8 00 00 00 00	 call	 ??1CTree@@UAE@XZ	; CTree::~CTree
  0000b	8b ce		 mov	 ecx, esi
  0000d	5e		 pop	 esi
  0000e	e9 00 00 00 00	 jmp	 ??1COrder@@UAE@XZ	; COrder::~COrder
??1CElementTree@@QAE@XZ ENDP				; CElementTree::~CElementTree
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GCTree@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCTree@@UAEPAXI@Z PROC				; CTree::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CTree@@UAE@XZ	; CTree::~CTree
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0b		 je	 SHORT $LN4@scalar
  00011	6a 20		 push	 32			; 00000020H
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00019	83 c4 08	 add	 esp, 8
$LN4@scalar:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??_GCTree@@UAEPAXI@Z ENDP				; CTree::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
;	COMDAT ??_G?$CList@PAVCDrawingSymbolColumn@@PAV1@@@UAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_G?$CList@PAVCDrawingSymbolColumn@@PAV1@@@UAEPAXI@Z PROC ; CList<CDrawingSymbolColumn *,CDrawingSymbolColumn *>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_G?$CList@PAVCDrawingSymbolColumn@@PAV1@@@UAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 872  : 	m_pBlocks->FreeDataChain();

  00025	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]

; 878  : {

  00028	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0002f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CList@PAVCDrawingSymbolColumn@@PAV1@@@6B@

; 870  : 	m_nCount = 0;

  00035	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0

; 871  : 	m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;

  0003c	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00043	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  0004a	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 872  : 	m_pBlocks->FreeDataChain();

  00051	e8 00 00 00 00	 call	 ?FreeDataChain@CPlex@@QAEXXZ ; CPlex::FreeDataChain

; 873  : 	m_pBlocks = NULL;

  00056	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00059	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
  00060	a8 01		 test	 al, 1
  00062	74 2c		 je	 SHORT $LN22@scalar
  00064	a8 04		 test	 al, 4
  00066	75 1d		 jne	 SHORT $LN3@scalar
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 112  : 	{ ::operator delete(p); }

  00068	56		 push	 esi
  00069	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0006e	83 c4 04	 add	 esp, 4
  00071	8b c6		 mov	 eax, esi
  00073	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00076	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007d	59		 pop	 ecx
  0007e	5e		 pop	 esi
  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c2 04 00	 ret	 4
$LN3@scalar:
  00085	6a 1c		 push	 28			; 0000001cH
  00087	56		 push	 esi
  00088	e8 00 00 00 00	 call	 ?__global_delete@@YAXPAXI@Z ; __global_delete
  0008d	83 c4 08	 add	 esp, 8
$LN22@scalar:
  00090	8b c6		 mov	 eax, esi
  00092	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00095	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0009c	59		 pop	 ecx
  0009d	5e		 pop	 esi
  0009e	8b e5		 mov	 esp, ebp
  000a0	5d		 pop	 ebp
  000a1	c2 04 00	 ret	 4
  000a4	cc		 int	 3
  000a5	cc		 int	 3
  000a6	cc		 int	 3
  000a7	cc		 int	 3
  000a8	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??_G?$CList@PAVCDrawingSymbolColumn@@PAV1@@@UAEPAXI@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_G?$CList@PAVCDrawingSymbolColumn@@PAV1@@@UAEPAXI@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_G?$CList@PAVCDrawingSymbolColumn@@PAV1@@@UAEPAXI@Z ENDP ; CList<CDrawingSymbolColumn *,CDrawingSymbolColumn *>::`scalar deleting destructor'
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ?Serialize@?$CList@PAVCDrawingSymbolColumn@@PAV1@@@UAEXAAVCArchive@@@Z
_TEXT	SEGMENT
_nNewCount$1$ = -16					; size = 4
_newData$1 = -12					; size = 4
_pData$1$ = -8						; size = 4
_pData$1$ = -8						; size = 4
_pNode$1$ = -8						; size = 4
_nElementsLeft$1$ = -4					; size = 4
_this$1$ = -4						; size = 4
_ar$ = 8						; size = 4
?Serialize@?$CList@PAVCDrawingSymbolColumn@@PAV1@@@UAEXAAVCArchive@@@Z PROC ; CList<CDrawingSymbolColumn *,CDrawingSymbolColumn *>::Serialize, COMDAT
; _this$ = ecx

; 1169 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx
  00007	8b d9		 mov	 ebx, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 212  : 	{ return (m_nMode & CArchive::load) == 0; }

  00009	8b 4d 08	 mov	 ecx, DWORD PTR _ar$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 1169 : {

  0000c	56		 push	 esi
  0000d	57		 push	 edi
  0000e	89 5d fc	 mov	 DWORD PTR _this$1$[ebp], ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 212  : 	{ return (m_nMode & CArchive::load) == 0; }

  00011	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  00014	f7 d0		 not	 eax
  00016	a8 01		 test	 al, 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 1174 : 	if (ar.IsStoring())

  00018	0f 84 ae 00 00
	00		 je	 $LN7@Serialize

; 1175 : 	{
; 1176 : 		ar.WriteCount(m_nCount);

  0001e	ff 73 0c	 push	 DWORD PTR [ebx+12]
  00021	e8 00 00 00 00	 call	 ?WriteCount@CArchive@@QAEXK@Z ; CArchive::WriteCount

; 1177 : 		for (CNode* pNode = m_pNodeHead; pNode != NULL; pNode = pNode->pNext)

  00026	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00029	89 45 f8	 mov	 DWORD PTR _pNode$1$[ebp], eax
  0002c	85 c0		 test	 eax, eax
  0002e	0f 84 b9 01 00
	00		 je	 $LN86@Serialize
$LL4@Serialize:

; 1178 : 		{
; 1179 : 			ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 1180 : 			TYPE* pData;
; 1181 : 			/*
; 1182 : 			 * in some cases the & operator might be overloaded, and we cannot use it to obtain
; 1183 : 			 * the address of a given object.  We then use the following trick to get the address
; 1184 : 			 */
; 1185 : 			pData = reinterpret_cast< TYPE* >( &reinterpret_cast< int& >( static_cast< TYPE& >( pNode->data ) ) );

  00034	8d 70 08	 lea	 esi, DWORD PTR [eax+8]

; 68   : 	ENSURE(nCount == 0 || pElements != NULL);

  00037	85 f6		 test	 esi, esi
  00039	0f 84 c0 01 00
	00		 je	 $LN76@Serialize
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 212  : 	{ return (m_nMode & CArchive::load) == 0; }

  0003f	8b 4d 08	 mov	 ecx, DWORD PTR _ar$[ebp]
  00042	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  00045	f7 d0		 not	 eax
  00047	a8 01		 test	 al, 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 73   : 	if (ar.IsStoring())

  00049	74 33		 je	 SHORT $LN21@Serialize

; 74   : 	{
; 75   : 		TYPE* pData;
; 76   : 		UINT_PTR nElementsLeft;
; 77   : 
; 78   : 		nElementsLeft = nCount;

  0004b	b8 01 00 00 00	 mov	 eax, 1
  00050	89 45 fc	 mov	 DWORD PTR _nElementsLeft$1$[ebp], eax
$LL16@Serialize:

; 80   : 		while( nElementsLeft > 0 )
; 81   : 		{
; 82   : 			UINT nElementsToWrite;
; 83   : 
; 84   : 			nElementsToWrite = UINT(__min(nElementsLeft, INT_MAX/sizeof(TYPE)));

  00053	bb ff ff ff 1f	 mov	 ebx, 536870911		; 1fffffffH
  00058	3b c3		 cmp	 eax, ebx
  0005a	0f 42 d8	 cmovb	 ebx, eax

; 85   : 			ar.Write(pData, nElementsToWrite*sizeof(TYPE));

  0005d	8d 3c 9d 00 00
	00 00		 lea	 edi, DWORD PTR [ebx*4]
  00064	57		 push	 edi
  00065	56		 push	 esi
  00066	e8 00 00 00 00	 call	 ?Write@CArchive@@QAEXPBXI@Z ; CArchive::Write

; 86   : 			nElementsLeft -= nElementsToWrite;

  0006b	8b 45 fc	 mov	 eax, DWORD PTR _nElementsLeft$1$[ebp]

; 87   : 			pData += nElementsToWrite;

  0006e	03 f7		 add	 esi, edi
  00070	8b 4d 08	 mov	 ecx, DWORD PTR _ar$[ebp]
  00073	2b c3		 sub	 eax, ebx
  00075	89 45 fc	 mov	 DWORD PTR _nElementsLeft$1$[ebp], eax
  00078	85 c0		 test	 eax, eax
  0007a	75 d7		 jne	 SHORT $LL16@Serialize

; 88   : 		}
; 89   : 	}

  0007c	eb 35		 jmp	 SHORT $LN2@Serialize
$LN21@Serialize:

; 90   : 	else
; 91   : 	{
; 92   : 		TYPE* pData;
; 93   : 		UINT_PTR nElementsLeft;
; 94   : 
; 95   : 		nElementsLeft = nCount;

  0007e	bf 01 00 00 00	 mov	 edi, 1
$LL18@Serialize:

; 98   : 		{
; 99   : 			UINT nElementsToRead;
; 100  : 
; 101  : 			nElementsToRead = UINT(__min(nElementsLeft, INT_MAX/sizeof(TYPE)));

  00083	bb ff ff ff 1f	 mov	 ebx, 536870911		; 1fffffffH
  00088	3b fb		 cmp	 edi, ebx
  0008a	0f 42 df	 cmovb	 ebx, edi

; 102  : 			ar.EnsureRead(pData, nElementsToRead*sizeof(TYPE));

  0008d	8d 04 9d 00 00
	00 00		 lea	 eax, DWORD PTR [ebx*4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 399  : 	UINT nRead=Read(lpBuf, nCount);

  00094	50		 push	 eax
  00095	56		 push	 esi
  00096	e8 00 00 00 00	 call	 ?Read@CArchive@@QAEIPAXI@Z ; CArchive::Read

; 400  : 	if(nRead!=nCount)

  0009b	8d 0c 9d 00 00
	00 00		 lea	 ecx, DWORD PTR [ebx*4]
  000a2	3b c1		 cmp	 eax, ecx
  000a4	0f 85 4c 01 00
	00		 jne	 $LN75@Serialize
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 97   : 		while( nElementsLeft > 0 )

  000aa	03 f1		 add	 esi, ecx
  000ac	8b 4d 08	 mov	 ecx, DWORD PTR _ar$[ebp]

; 103  : 			nElementsLeft -= nElementsToRead;

  000af	2b fb		 sub	 edi, ebx
  000b1	75 d0		 jne	 SHORT $LL18@Serialize
$LN2@Serialize:

; 1177 : 		for (CNode* pNode = m_pNodeHead; pNode != NULL; pNode = pNode->pNext)

  000b3	8b 45 f8	 mov	 eax, DWORD PTR _pNode$1$[ebp]
  000b6	8b 00		 mov	 eax, DWORD PTR [eax]
  000b8	89 45 f8	 mov	 DWORD PTR _pNode$1$[ebp], eax
  000bb	85 c0		 test	 eax, eax
  000bd	0f 85 71 ff ff
	ff		 jne	 $LL4@Serialize

; 1197 : 		}
; 1198 : 	}
; 1199 : }

  000c3	5f		 pop	 edi
  000c4	5e		 pop	 esi
  000c5	5b		 pop	 ebx
  000c6	8b e5		 mov	 esp, ebp
  000c8	5d		 pop	 ebp
  000c9	c2 04 00	 ret	 4
$LN7@Serialize:

; 1186 : 			SerializeElements<TYPE>(ar, pData, 1);
; 1187 : 		}
; 1188 : 	}
; 1189 : 	else
; 1190 : 	{
; 1191 : 		DWORD_PTR nNewCount = ar.ReadCount();

  000cc	e8 00 00 00 00	 call	 ?ReadCount@CArchive@@QAEKXZ ; CArchive::ReadCount

; 1192 : 		while (nNewCount--)

  000d1	85 c0		 test	 eax, eax
  000d3	0f 84 14 01 00
	00		 je	 $LN86@Serialize
  000d9	0f 1f 80 00 00
	00 00		 npad	 7
$LL5@Serialize:
  000e0	48		 dec	 eax
  000e1	89 45 f0	 mov	 DWORD PTR _nNewCount$1$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 212  : 	{ return (m_nMode & CArchive::load) == 0; }

  000e4	8b 45 08	 mov	 eax, DWORD PTR _ar$[ebp]
  000e7	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  000ea	f7 d1		 not	 ecx
  000ec	f6 c1 01	 test	 cl, 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 73   : 	if (ar.IsStoring())

  000ef	74 3d		 je	 SHORT $LN42@Serialize

; 79   : 		pData = pElements;

  000f1	8d 4d f4	 lea	 ecx, DWORD PTR _newData$1[ebp]
  000f4	bb 01 00 00 00	 mov	 ebx, 1
  000f9	89 4d f8	 mov	 DWORD PTR _pData$1$[ebp], ecx
  000fc	0f 1f 40 00	 npad	 4
$LL37@Serialize:

; 80   : 		while( nElementsLeft > 0 )
; 81   : 		{
; 82   : 			UINT nElementsToWrite;
; 83   : 
; 84   : 			nElementsToWrite = UINT(__min(nElementsLeft, INT_MAX/sizeof(TYPE)));

  00100	bf ff ff ff 1f	 mov	 edi, 536870911		; 1fffffffH
  00105	3b df		 cmp	 ebx, edi
  00107	0f 42 fb	 cmovb	 edi, ebx

; 85   : 			ar.Write(pData, nElementsToWrite*sizeof(TYPE));

  0010a	8d 34 bd 00 00
	00 00		 lea	 esi, DWORD PTR [edi*4]
  00111	56		 push	 esi
  00112	51		 push	 ecx
  00113	8b c8		 mov	 ecx, eax
  00115	e8 00 00 00 00	 call	 ?Write@CArchive@@QAEXPBXI@Z ; CArchive::Write

; 87   : 			pData += nElementsToWrite;

  0011a	8b 4d f8	 mov	 ecx, DWORD PTR _pData$1$[ebp]
  0011d	8b 45 08	 mov	 eax, DWORD PTR _ar$[ebp]
  00120	03 ce		 add	 ecx, esi
  00122	89 4d f8	 mov	 DWORD PTR _pData$1$[ebp], ecx
  00125	2b df		 sub	 ebx, edi
  00127	75 d7		 jne	 SHORT $LL37@Serialize

; 88   : 		}
; 89   : 	}

  00129	8b 5d fc	 mov	 ebx, DWORD PTR _this$1$[ebp]
  0012c	eb 4a		 jmp	 SHORT $LN40@Serialize
$LN42@Serialize:

; 96   : 		pData = pElements;

  0012e	8d 55 f4	 lea	 edx, DWORD PTR _newData$1[ebp]
  00131	be 01 00 00 00	 mov	 esi, 1
  00136	89 55 f8	 mov	 DWORD PTR _pData$1$[ebp], edx
  00139	0f 1f 80 00 00
	00 00		 npad	 7
$LL39@Serialize:

; 98   : 		{
; 99   : 			UINT nElementsToRead;
; 100  : 
; 101  : 			nElementsToRead = UINT(__min(nElementsLeft, INT_MAX/sizeof(TYPE)));

  00140	bf ff ff ff 1f	 mov	 edi, 536870911		; 1fffffffH
  00145	3b f7		 cmp	 esi, edi
  00147	0f 42 fe	 cmovb	 edi, esi

; 102  : 			ar.EnsureRead(pData, nElementsToRead*sizeof(TYPE));

  0014a	8d 0c bd 00 00
	00 00		 lea	 ecx, DWORD PTR [edi*4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 399  : 	UINT nRead=Read(lpBuf, nCount);

  00151	51		 push	 ecx
  00152	52		 push	 edx
  00153	8b c8		 mov	 ecx, eax
  00155	e8 00 00 00 00	 call	 ?Read@CArchive@@QAEIPAXI@Z ; CArchive::Read

; 400  : 	if(nRead!=nCount)

  0015a	8d 0c bd 00 00
	00 00		 lea	 ecx, DWORD PTR [edi*4]
  00161	3b c1		 cmp	 eax, ecx
  00163	0f 85 8d 00 00
	00		 jne	 $LN75@Serialize
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 97   : 		while( nElementsLeft > 0 )

  00169	8b 55 f8	 mov	 edx, DWORD PTR _pData$1$[ebp]
  0016c	8b 45 08	 mov	 eax, DWORD PTR _ar$[ebp]

; 104  : 			pData += nElementsToRead;

  0016f	03 d1		 add	 edx, ecx
  00171	89 55 f8	 mov	 DWORD PTR _pData$1$[ebp], edx
  00174	2b f7		 sub	 esi, edi
  00176	75 c8		 jne	 SHORT $LL39@Serialize
$LN40@Serialize:

; 902  : 	if (m_pNodeFree == NULL)

  00178	83 7b 10 00	 cmp	 DWORD PTR [ebx+16], 0

; 1193 : 		{
; 1194 : 			TYPE newData[1];
; 1195 : 			SerializeElements<TYPE>(ar, newData, 1);
; 1196 : 			AddTail(newData[0]);

  0017c	8b 75 f4	 mov	 esi, DWORD PTR _newData$1[ebp]

; 968  : 	CNode* pNewNode = NewNode(m_pNodeTail, NULL);

  0017f	8b 7b 08	 mov	 edi, DWORD PTR [ebx+8]

; 902  : 	if (m_pNodeFree == NULL)

  00182	75 32		 jne	 SHORT $LN63@Serialize

; 903  : 	{
; 904  : 		// add another block
; 905  : 		CPlex* pNewBlock = CPlex::Create(m_pBlocks, m_nBlockSize,

  00184	6a 0c		 push	 12			; 0000000cH
  00186	ff 73 18	 push	 DWORD PTR [ebx+24]
  00189	8d 43 14	 lea	 eax, DWORD PTR [ebx+20]
  0018c	50		 push	 eax
  0018d	e8 00 00 00 00	 call	 ?Create@CPlex@@SGPAU1@AAPAU1@II@Z ; CPlex::Create

; 906  : 				 sizeof(CNode));
; 907  : 
; 908  : 		// chain them into free list
; 909  : 		CNode* pNode = (CNode*) pNewBlock->data();
; 910  : 		// free in reverse order to make it easier to debug
; 911  : 		pNode += m_nBlockSize - 1;

  00192	8b 53 18	 mov	 edx, DWORD PTR [ebx+24]
  00195	83 c0 08	 add	 eax, 8
  00198	8d 4a ff	 lea	 ecx, DWORD PTR [edx-1]

; 912  : 		for (INT_PTR i = m_nBlockSize-1; i >= 0; i--, pNode--)

  0019b	83 c2 ff	 add	 edx, -1
  0019e	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]
  001a1	8d 0c 88	 lea	 ecx, DWORD PTR [eax+ecx*4]
  001a4	78 10		 js	 SHORT $LN63@Serialize
$LL60@Serialize:

; 913  : 		{
; 914  : 			pNode->pNext = m_pNodeFree;

  001a6	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  001a9	89 01		 mov	 DWORD PTR [ecx], eax

; 915  : 			m_pNodeFree = pNode;

  001ab	89 4b 10	 mov	 DWORD PTR [ebx+16], ecx
  001ae	83 e9 0c	 sub	 ecx, 12			; 0000000cH
  001b1	83 ea 01	 sub	 edx, 1
  001b4	79 f0		 jns	 SHORT $LL60@Serialize
$LN63@Serialize:

; 916  : 		}
; 917  : 	}
; 918  : 	ENSURE(m_pNodeFree != NULL);  // we must have something

  001b6	8b 4b 10	 mov	 ecx, DWORD PTR [ebx+16]
  001b9	85 c9		 test	 ecx, ecx
  001bb	74 42		 je	 SHORT $LN76@Serialize

; 919  : 
; 920  : 	CList::CNode* pNode = m_pNodeFree;
; 921  : 	m_pNodeFree = m_pNodeFree->pNext;

  001bd	8b 01		 mov	 eax, DWORD PTR [ecx]
  001bf	89 43 10	 mov	 DWORD PTR [ebx+16], eax

; 922  : 	pNode->pPrev = pPrev;

  001c2	89 79 04	 mov	 DWORD PTR [ecx+4], edi

; 923  : 	pNode->pNext = pNext;

  001c5	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 924  : 	m_nCount++;

  001cb	ff 43 0c	 inc	 DWORD PTR [ebx+12]

; 969  : 	pNewNode->data = newElement;

  001ce	89 71 08	 mov	 DWORD PTR [ecx+8], esi

; 970  : 	if (m_pNodeTail != NULL)

  001d1	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  001d4	85 c0		 test	 eax, eax
  001d6	74 04		 je	 SHORT $LN54@Serialize

; 971  : 		m_pNodeTail->pNext = pNewNode;

  001d8	89 08		 mov	 DWORD PTR [eax], ecx
  001da	eb 03		 jmp	 SHORT $LN55@Serialize
$LN54@Serialize:

; 972  : 	else
; 973  : 		m_pNodeHead = pNewNode;

  001dc	89 4b 04	 mov	 DWORD PTR [ebx+4], ecx
$LN55@Serialize:

; 1192 : 		while (nNewCount--)

  001df	8b 45 f0	 mov	 eax, DWORD PTR _nNewCount$1$[ebp]

; 974  : 	m_pNodeTail = pNewNode;

  001e2	89 4b 08	 mov	 DWORD PTR [ebx+8], ecx

; 1192 : 		while (nNewCount--)

  001e5	85 c0		 test	 eax, eax
  001e7	0f 85 f3 fe ff
	ff		 jne	 $LL5@Serialize
$LN86@Serialize:
  001ed	5f		 pop	 edi

; 1197 : 		}
; 1198 : 	}
; 1199 : }

  001ee	5e		 pop	 esi
  001ef	5b		 pop	 ebx
  001f0	8b e5		 mov	 esp, ebp
  001f2	5d		 pop	 ebp
  001f3	c2 04 00	 ret	 4
$LN75@Serialize:
  001f6	6a 00		 push	 0
  001f8	6a 03		 push	 3
  001fa	e8 00 00 00 00	 call	 ?AfxThrowArchiveException@@YGXHPBD@Z ; AfxThrowArchiveException
$LN76@Serialize:
  001ff	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN105@Serialize:
  00204	cc		 int	 3
?Serialize@?$CList@PAVCDrawingSymbolColumn@@PAV1@@@UAEXAAVCArchive@@@Z ENDP ; CList<CDrawingSymbolColumn *,CDrawingSymbolColumn *>::Serialize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ??1?$CList@PAVCDrawingSymbolColumn@@PAV1@@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$CList@PAVCDrawingSymbolColumn@@PAV1@@@UAE@XZ PROC	; CList<CDrawingSymbolColumn *,CDrawingSymbolColumn *>::~CList<CDrawingSymbolColumn *,CDrawingSymbolColumn *>, COMDAT
; _this$ = ecx

; 878  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$CList@PAVCDrawingSymbolColumn@@PAV1@@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx

; 872  : 	m_pBlocks->FreeDataChain();

  00025	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]

; 878  : {

  00028	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CList@PAVCDrawingSymbolColumn@@PAV1@@@6B@

; 870  : 	m_nCount = 0;

  0002e	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0

; 871  : 	m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;

  00035	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0003c	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00043	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 872  : 	m_pBlocks->FreeDataChain();

  0004a	e8 00 00 00 00	 call	 ?FreeDataChain@CPlex@@QAEXXZ ; CPlex::FreeDataChain

; 873  : 	m_pBlocks = NULL;

  0004f	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 879  : 	RemoveAll();
; 880  : 	ASSERT(m_nCount == 0);
; 881  : }

  00056	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00059	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00060	59		 pop	 ecx
  00061	5e		 pop	 esi
  00062	8b e5		 mov	 esp, ebp
  00064	5d		 pop	 ebp
  00065	c3		 ret	 0
  00066	cc		 int	 3
  00067	cc		 int	 3
  00068	cc		 int	 3
  00069	cc		 int	 3
  0006a	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CList@PAVCDrawingSymbolColumn@@PAV1@@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$CList@PAVCDrawingSymbolColumn@@PAV1@@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$CList@PAVCDrawingSymbolColumn@@PAV1@@@UAE@XZ ENDP	; CList<CDrawingSymbolColumn *,CDrawingSymbolColumn *>::~CList<CDrawingSymbolColumn *,CDrawingSymbolColumn *>
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ?NewNode@?$CList@PAVCDrawingSymbolColumn@@PAV1@@@IAEPAUCNode@1@PAU21@0@Z
_TEXT	SEGMENT
_pPrev$ = 8						; size = 4
_pNext$ = 12						; size = 4
?NewNode@?$CList@PAVCDrawingSymbolColumn@@PAV1@@@IAEPAUCNode@1@PAU21@0@Z PROC ; CList<CDrawingSymbolColumn *,CDrawingSymbolColumn *>::NewNode, COMDAT
; _this$ = ecx

; 901  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 902  : 	if (m_pNodeFree == NULL)

  00006	83 7e 10 00	 cmp	 DWORD PTR [esi+16], 0
  0000a	75 34		 jne	 SHORT $LN7@NewNode

; 903  : 	{
; 904  : 		// add another block
; 905  : 		CPlex* pNewBlock = CPlex::Create(m_pBlocks, m_nBlockSize,

  0000c	6a 0c		 push	 12			; 0000000cH
  0000e	ff 76 18	 push	 DWORD PTR [esi+24]
  00011	8d 46 14	 lea	 eax, DWORD PTR [esi+20]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ?Create@CPlex@@SGPAU1@AAPAU1@II@Z ; CPlex::Create

; 906  : 				 sizeof(CNode));
; 907  : 
; 908  : 		// chain them into free list
; 909  : 		CNode* pNode = (CNode*) pNewBlock->data();
; 910  : 		// free in reverse order to make it easier to debug
; 911  : 		pNode += m_nBlockSize - 1;

  0001a	8b 56 18	 mov	 edx, DWORD PTR [esi+24]
  0001d	83 c0 08	 add	 eax, 8
  00020	8d 0c 52	 lea	 ecx, DWORD PTR [edx+edx*2]
  00023	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  00026	83 c0 f4	 add	 eax, -12		; fffffff4H

; 912  : 		for (INT_PTR i = m_nBlockSize-1; i >= 0; i--, pNode--)

  00029	83 c2 ff	 add	 edx, -1
  0002c	78 12		 js	 SHORT $LN7@NewNode
  0002e	66 90		 npad	 2
$LL4@NewNode:

; 913  : 		{
; 914  : 			pNode->pNext = m_pNodeFree;

  00030	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00033	89 08		 mov	 DWORD PTR [eax], ecx

; 915  : 			m_pNodeFree = pNode;

  00035	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00038	83 e8 0c	 sub	 eax, 12			; 0000000cH
  0003b	83 ea 01	 sub	 edx, 1
  0003e	79 f0		 jns	 SHORT $LL4@NewNode
$LN7@NewNode:

; 916  : 		}
; 917  : 	}
; 918  : 	ENSURE(m_pNodeFree != NULL);  // we must have something

  00040	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00043	85 c0		 test	 eax, eax
  00045	74 18		 je	 SHORT $LN17@NewNode

; 919  : 
; 920  : 	CList::CNode* pNode = m_pNodeFree;
; 921  : 	m_pNodeFree = m_pNodeFree->pNext;

  00047	8b 08		 mov	 ecx, DWORD PTR [eax]
  00049	89 4e 10	 mov	 DWORD PTR [esi+16], ecx

; 922  : 	pNode->pPrev = pPrev;

  0004c	8b 4d 08	 mov	 ecx, DWORD PTR _pPrev$[ebp]
  0004f	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 923  : 	pNode->pNext = pNext;

  00052	8b 4d 0c	 mov	 ecx, DWORD PTR _pNext$[ebp]
  00055	89 08		 mov	 DWORD PTR [eax], ecx

; 924  : 	m_nCount++;

  00057	ff 46 0c	 inc	 DWORD PTR [esi+12]

; 925  : 	ASSERT(m_nCount > 0);  // make sure we don't overflow
; 926  : 
; 927  : #pragma push_macro("new")
; 928  : #undef new
; 929  : 	::new( (void*)( &pNode->data ) ) TYPE;
; 930  : #pragma pop_macro("new")
; 931  : 	return pNode;

  0005a	5e		 pop	 esi

; 932  : }

  0005b	5d		 pop	 ebp
  0005c	c2 08 00	 ret	 8
$LN17@NewNode:

; 916  : 		}
; 917  : 	}
; 918  : 	ENSURE(m_pNodeFree != NULL);  // we must have something

  0005f	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN15@NewNode:
  00064	cc		 int	 3
?NewNode@?$CList@PAVCDrawingSymbolColumn@@PAV1@@@IAEPAUCNode@1@PAU21@0@Z ENDP ; CList<CDrawingSymbolColumn *,CDrawingSymbolColumn *>::NewNode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ?RemoveAll@?$CList@PAVCDrawingSymbolColumn@@PAV1@@@QAEXXZ
_TEXT	SEGMENT
?RemoveAll@?$CList@PAVCDrawingSymbolColumn@@PAV1@@@QAEXXZ PROC ; CList<CDrawingSymbolColumn *,CDrawingSymbolColumn *>::RemoveAll, COMDAT
; _this$ = ecx

; 862  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 863  : 	ASSERT_VALID(this);
; 864  : 
; 865  : 	// destroy elements
; 866  : 	CNode* pNode;
; 867  : 	for (pNode = m_pNodeHead; pNode != NULL; pNode = pNode->pNext)
; 868  : 		pNode->data.~TYPE();
; 869  : 
; 870  : 	m_nCount = 0;
; 871  : 	m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
; 872  : 	m_pBlocks->FreeDataChain();

  00003	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00006	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  0000d	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00014	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  0001b	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00022	e8 00 00 00 00	 call	 ?FreeDataChain@CPlex@@QAEXXZ ; CPlex::FreeDataChain

; 873  : 	m_pBlocks = NULL;

  00027	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
  0002e	5e		 pop	 esi

; 874  : }

  0002f	c3		 ret	 0
?RemoveAll@?$CList@PAVCDrawingSymbolColumn@@PAV1@@@QAEXXZ ENDP ; CList<CDrawingSymbolColumn *,CDrawingSymbolColumn *>::RemoveAll
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ?AddTail@?$CList@PAVCDrawingSymbolColumn@@PAV1@@@QAEPAU__POSITION@@PAVCDrawingSymbolColumn@@@Z
_TEXT	SEGMENT
_newElement$ = 8					; size = 4
?AddTail@?$CList@PAVCDrawingSymbolColumn@@PAV1@@@QAEPAU__POSITION@@PAVCDrawingSymbolColumn@@@Z PROC ; CList<CDrawingSymbolColumn *,CDrawingSymbolColumn *>::AddTail, COMDAT
; _this$ = ecx

; 965  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	57		 push	 edi

; 902  : 	if (m_pNodeFree == NULL)

  00007	83 7e 10 00	 cmp	 DWORD PTR [esi+16], 0

; 966  : 	ASSERT_VALID(this);
; 967  : 
; 968  : 	CNode* pNewNode = NewNode(m_pNodeTail, NULL);

  0000b	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]

; 902  : 	if (m_pNodeFree == NULL)

  0000e	75 32		 jne	 SHORT $LN11@AddTail

; 903  : 	{
; 904  : 		// add another block
; 905  : 		CPlex* pNewBlock = CPlex::Create(m_pBlocks, m_nBlockSize,

  00010	6a 0c		 push	 12			; 0000000cH
  00012	ff 76 18	 push	 DWORD PTR [esi+24]
  00015	8d 46 14	 lea	 eax, DWORD PTR [esi+20]
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ?Create@CPlex@@SGPAU1@AAPAU1@II@Z ; CPlex::Create

; 906  : 				 sizeof(CNode));
; 907  : 
; 908  : 		// chain them into free list
; 909  : 		CNode* pNode = (CNode*) pNewBlock->data();
; 910  : 		// free in reverse order to make it easier to debug
; 911  : 		pNode += m_nBlockSize - 1;

  0001e	8b 56 18	 mov	 edx, DWORD PTR [esi+24]
  00021	83 c0 08	 add	 eax, 8
  00024	8d 4a ff	 lea	 ecx, DWORD PTR [edx-1]

; 912  : 		for (INT_PTR i = m_nBlockSize-1; i >= 0; i--, pNode--)

  00027	83 c2 ff	 add	 edx, -1
  0002a	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]
  0002d	8d 0c 88	 lea	 ecx, DWORD PTR [eax+ecx*4]
  00030	78 10		 js	 SHORT $LN11@AddTail
$LL8@AddTail:

; 913  : 		{
; 914  : 			pNode->pNext = m_pNodeFree;

  00032	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00035	89 01		 mov	 DWORD PTR [ecx], eax

; 915  : 			m_pNodeFree = pNode;

  00037	89 4e 10	 mov	 DWORD PTR [esi+16], ecx
  0003a	83 e9 0c	 sub	 ecx, 12			; 0000000cH
  0003d	83 ea 01	 sub	 edx, 1
  00040	79 f0		 jns	 SHORT $LL8@AddTail
$LN11@AddTail:

; 916  : 		}
; 917  : 	}
; 918  : 	ENSURE(m_pNodeFree != NULL);  // we must have something

  00042	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00045	85 c9		 test	 ecx, ecx
  00047	74 39		 je	 SHORT $LN22@AddTail

; 919  : 
; 920  : 	CList::CNode* pNode = m_pNodeFree;
; 921  : 	m_pNodeFree = m_pNodeFree->pNext;

  00049	8b 01		 mov	 eax, DWORD PTR [ecx]
  0004b	89 46 10	 mov	 DWORD PTR [esi+16], eax

; 969  : 	pNewNode->data = newElement;

  0004e	8b 45 08	 mov	 eax, DWORD PTR _newElement$[ebp]

; 922  : 	pNode->pPrev = pPrev;

  00051	89 79 04	 mov	 DWORD PTR [ecx+4], edi

; 923  : 	pNode->pNext = pNext;

  00054	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 924  : 	m_nCount++;

  0005a	ff 46 0c	 inc	 DWORD PTR [esi+12]

; 969  : 	pNewNode->data = newElement;

  0005d	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 970  : 	if (m_pNodeTail != NULL)

  00060	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00063	85 c0		 test	 eax, eax
  00065	74 0d		 je	 SHORT $LN2@AddTail

; 971  : 		m_pNodeTail->pNext = pNewNode;

  00067	89 08		 mov	 DWORD PTR [eax], ecx

; 972  : 	else
; 973  : 		m_pNodeHead = pNewNode;
; 974  : 	m_pNodeTail = pNewNode;
; 975  : 	return (POSITION) pNewNode;

  00069	8b c1		 mov	 eax, ecx
  0006b	5f		 pop	 edi
  0006c	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  0006f	5e		 pop	 esi

; 976  : }

  00070	5d		 pop	 ebp
  00071	c2 04 00	 ret	 4
$LN2@AddTail:

; 972  : 	else
; 973  : 		m_pNodeHead = pNewNode;
; 974  : 	m_pNodeTail = pNewNode;
; 975  : 	return (POSITION) pNewNode;

  00074	5f		 pop	 edi
  00075	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  00078	8b c1		 mov	 eax, ecx
  0007a	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  0007d	5e		 pop	 esi

; 976  : }

  0007e	5d		 pop	 ebp
  0007f	c2 04 00	 ret	 4
$LN22@AddTail:

; 918  : 	ENSURE(m_pNodeFree != NULL);  // we must have something

  00082	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN20@AddTail:
  00087	cc		 int	 3
?AddTail@?$CList@PAVCDrawingSymbolColumn@@PAV1@@@QAEPAU__POSITION@@PAVCDrawingSymbolColumn@@@Z ENDP ; CList<CDrawingSymbolColumn *,CDrawingSymbolColumn *>::AddTail
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ??0?$CList@PAVCDrawingSymbolColumn@@PAV1@@@QAE@H@Z
_TEXT	SEGMENT
_nBlockSize$ = 8					; size = 4
??0?$CList@PAVCDrawingSymbolColumn@@PAV1@@@QAE@H@Z PROC	; CList<CDrawingSymbolColumn *,CDrawingSymbolColumn *>::CList<CDrawingSymbolColumn *,CDrawingSymbolColumn *>, COMDAT
; _this$ = ecx

; 851  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 852  : 	ASSERT(nBlockSize > 0);
; 853  : 
; 854  : 	m_nCount = 0;
; 855  : 	m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
; 856  : 	m_pBlocks = NULL;
; 857  : 	m_nBlockSize = nBlockSize;

  00003	8b 45 08	 mov	 eax, DWORD PTR _nBlockSize$[ebp]
  00006	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 858  : }

  00009	8b c1		 mov	 eax, ecx
  0000b	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CList@PAVCDrawingSymbolColumn@@PAV1@@@6B@
  00011	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0
  00018	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  0001f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00026	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0002d	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
??0?$CList@PAVCDrawingSymbolColumn@@PAV1@@@QAE@H@Z ENDP	; CList<CDrawingSymbolColumn *,CDrawingSymbolColumn *>::CList<CDrawingSymbolColumn *,CDrawingSymbolColumn *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Include_AddIn_133101\I133101\_IString.h
;	COMDAT ??1ILPCSTR133101@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1ILPCSTR133101@@QAE@XZ PROC				; ILPCSTR133101::~ILPCSTR133101, COMDAT
; _this$ = ecx

; 44   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1ILPCSTR133101@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx

; 45   : 		if( m_pIStrData)

  00025	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00028	85 c9		 test	 ecx, ecx
  0002a	74 13		 je	 SHORT $LN2@ILPCSTR133

; 46   : 		{
; 47   : 			m_pIStrData->Release();

  0002c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0002e	51		 push	 ecx
  0002f	ff 50 08	 call	 DWORD PTR [eax+8]

; 48   : 			m_pIStrData = NULL;

  00032	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 49   : 			m_szData = NULL;

  00039	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN2@ILPCSTR133:

; 50   : 		}
; 51   : 	}

  0003f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00042	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00049	59		 pop	 ecx
  0004a	5e		 pop	 esi
  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
  0004f	cc		 int	 3
  00050	cc		 int	 3
  00051	cc		 int	 3
  00052	cc		 int	 3
  00053	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1ILPCSTR133101@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1ILPCSTR133101@@QAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1ILPCSTR133101@@QAE@XZ ENDP				; ILPCSTR133101::~ILPCSTR133101
; Function compile flags: /Ogtp
;	COMDAT ??_GCOrder@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCOrder@@UAEPAXI@Z PROC				; COrder::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1COrder@@UAE@XZ	; COrder::~COrder
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0b		 je	 SHORT $LN4@scalar
  00011	6a 20		 push	 32			; 00000020H
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00019	83 c4 08	 add	 esp, 8
$LN4@scalar:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??_GCOrder@@UAEPAXI@Z ENDP				; COrder::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
;	COMDAT ??_G?$CList@PAVCDrawingSymbol@@PAV1@@@UAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_G?$CList@PAVCDrawingSymbol@@PAV1@@@UAEPAXI@Z PROC	; CList<CDrawingSymbol *,CDrawingSymbol *>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_G?$CList@PAVCDrawingSymbol@@PAV1@@@UAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 872  : 	m_pBlocks->FreeDataChain();

  00025	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]

; 878  : {

  00028	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0002f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CList@PAVCDrawingSymbol@@PAV1@@@6B@

; 870  : 	m_nCount = 0;

  00035	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0

; 871  : 	m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;

  0003c	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00043	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  0004a	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 872  : 	m_pBlocks->FreeDataChain();

  00051	e8 00 00 00 00	 call	 ?FreeDataChain@CPlex@@QAEXXZ ; CPlex::FreeDataChain

; 873  : 	m_pBlocks = NULL;

  00056	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00059	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
  00060	a8 01		 test	 al, 1
  00062	74 2c		 je	 SHORT $LN22@scalar
  00064	a8 04		 test	 al, 4
  00066	75 1d		 jne	 SHORT $LN3@scalar
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 112  : 	{ ::operator delete(p); }

  00068	56		 push	 esi
  00069	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0006e	83 c4 04	 add	 esp, 4
  00071	8b c6		 mov	 eax, esi
  00073	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00076	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007d	59		 pop	 ecx
  0007e	5e		 pop	 esi
  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c2 04 00	 ret	 4
$LN3@scalar:
  00085	6a 1c		 push	 28			; 0000001cH
  00087	56		 push	 esi
  00088	e8 00 00 00 00	 call	 ?__global_delete@@YAXPAXI@Z ; __global_delete
  0008d	83 c4 08	 add	 esp, 8
$LN22@scalar:
  00090	8b c6		 mov	 eax, esi
  00092	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00095	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0009c	59		 pop	 ecx
  0009d	5e		 pop	 esi
  0009e	8b e5		 mov	 esp, ebp
  000a0	5d		 pop	 ebp
  000a1	c2 04 00	 ret	 4
  000a4	cc		 int	 3
  000a5	cc		 int	 3
  000a6	cc		 int	 3
  000a7	cc		 int	 3
  000a8	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??_G?$CList@PAVCDrawingSymbol@@PAV1@@@UAEPAXI@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_G?$CList@PAVCDrawingSymbol@@PAV1@@@UAEPAXI@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_G?$CList@PAVCDrawingSymbol@@PAV1@@@UAEPAXI@Z ENDP	; CList<CDrawingSymbol *,CDrawingSymbol *>::`scalar deleting destructor'
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ?Serialize@?$CList@PAVCDrawingSymbol@@PAV1@@@UAEXAAVCArchive@@@Z
_TEXT	SEGMENT
_nNewCount$1$ = -16					; size = 4
_newData$1 = -12					; size = 4
_pData$1$ = -8						; size = 4
_pData$1$ = -8						; size = 4
_pNode$1$ = -8						; size = 4
_nElementsLeft$1$ = -4					; size = 4
_this$1$ = -4						; size = 4
_ar$ = 8						; size = 4
?Serialize@?$CList@PAVCDrawingSymbol@@PAV1@@@UAEXAAVCArchive@@@Z PROC ; CList<CDrawingSymbol *,CDrawingSymbol *>::Serialize, COMDAT
; _this$ = ecx

; 1169 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx
  00007	8b d9		 mov	 ebx, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 212  : 	{ return (m_nMode & CArchive::load) == 0; }

  00009	8b 4d 08	 mov	 ecx, DWORD PTR _ar$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 1169 : {

  0000c	56		 push	 esi
  0000d	57		 push	 edi
  0000e	89 5d fc	 mov	 DWORD PTR _this$1$[ebp], ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 212  : 	{ return (m_nMode & CArchive::load) == 0; }

  00011	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  00014	f7 d0		 not	 eax
  00016	a8 01		 test	 al, 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 1174 : 	if (ar.IsStoring())

  00018	0f 84 ae 00 00
	00		 je	 $LN7@Serialize

; 1175 : 	{
; 1176 : 		ar.WriteCount(m_nCount);

  0001e	ff 73 0c	 push	 DWORD PTR [ebx+12]
  00021	e8 00 00 00 00	 call	 ?WriteCount@CArchive@@QAEXK@Z ; CArchive::WriteCount

; 1177 : 		for (CNode* pNode = m_pNodeHead; pNode != NULL; pNode = pNode->pNext)

  00026	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00029	89 45 f8	 mov	 DWORD PTR _pNode$1$[ebp], eax
  0002c	85 c0		 test	 eax, eax
  0002e	0f 84 b9 01 00
	00		 je	 $LN86@Serialize
$LL4@Serialize:

; 1178 : 		{
; 1179 : 			ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 1180 : 			TYPE* pData;
; 1181 : 			/*
; 1182 : 			 * in some cases the & operator might be overloaded, and we cannot use it to obtain
; 1183 : 			 * the address of a given object.  We then use the following trick to get the address
; 1184 : 			 */
; 1185 : 			pData = reinterpret_cast< TYPE* >( &reinterpret_cast< int& >( static_cast< TYPE& >( pNode->data ) ) );

  00034	8d 70 08	 lea	 esi, DWORD PTR [eax+8]

; 68   : 	ENSURE(nCount == 0 || pElements != NULL);

  00037	85 f6		 test	 esi, esi
  00039	0f 84 c0 01 00
	00		 je	 $LN76@Serialize
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 212  : 	{ return (m_nMode & CArchive::load) == 0; }

  0003f	8b 4d 08	 mov	 ecx, DWORD PTR _ar$[ebp]
  00042	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  00045	f7 d0		 not	 eax
  00047	a8 01		 test	 al, 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 73   : 	if (ar.IsStoring())

  00049	74 33		 je	 SHORT $LN21@Serialize

; 74   : 	{
; 75   : 		TYPE* pData;
; 76   : 		UINT_PTR nElementsLeft;
; 77   : 
; 78   : 		nElementsLeft = nCount;

  0004b	b8 01 00 00 00	 mov	 eax, 1
  00050	89 45 fc	 mov	 DWORD PTR _nElementsLeft$1$[ebp], eax
$LL16@Serialize:

; 80   : 		while( nElementsLeft > 0 )
; 81   : 		{
; 82   : 			UINT nElementsToWrite;
; 83   : 
; 84   : 			nElementsToWrite = UINT(__min(nElementsLeft, INT_MAX/sizeof(TYPE)));

  00053	bb ff ff ff 1f	 mov	 ebx, 536870911		; 1fffffffH
  00058	3b c3		 cmp	 eax, ebx
  0005a	0f 42 d8	 cmovb	 ebx, eax

; 85   : 			ar.Write(pData, nElementsToWrite*sizeof(TYPE));

  0005d	8d 3c 9d 00 00
	00 00		 lea	 edi, DWORD PTR [ebx*4]
  00064	57		 push	 edi
  00065	56		 push	 esi
  00066	e8 00 00 00 00	 call	 ?Write@CArchive@@QAEXPBXI@Z ; CArchive::Write

; 86   : 			nElementsLeft -= nElementsToWrite;

  0006b	8b 45 fc	 mov	 eax, DWORD PTR _nElementsLeft$1$[ebp]

; 87   : 			pData += nElementsToWrite;

  0006e	03 f7		 add	 esi, edi
  00070	8b 4d 08	 mov	 ecx, DWORD PTR _ar$[ebp]
  00073	2b c3		 sub	 eax, ebx
  00075	89 45 fc	 mov	 DWORD PTR _nElementsLeft$1$[ebp], eax
  00078	85 c0		 test	 eax, eax
  0007a	75 d7		 jne	 SHORT $LL16@Serialize

; 88   : 		}
; 89   : 	}

  0007c	eb 35		 jmp	 SHORT $LN2@Serialize
$LN21@Serialize:

; 90   : 	else
; 91   : 	{
; 92   : 		TYPE* pData;
; 93   : 		UINT_PTR nElementsLeft;
; 94   : 
; 95   : 		nElementsLeft = nCount;

  0007e	bf 01 00 00 00	 mov	 edi, 1
$LL18@Serialize:

; 98   : 		{
; 99   : 			UINT nElementsToRead;
; 100  : 
; 101  : 			nElementsToRead = UINT(__min(nElementsLeft, INT_MAX/sizeof(TYPE)));

  00083	bb ff ff ff 1f	 mov	 ebx, 536870911		; 1fffffffH
  00088	3b fb		 cmp	 edi, ebx
  0008a	0f 42 df	 cmovb	 ebx, edi

; 102  : 			ar.EnsureRead(pData, nElementsToRead*sizeof(TYPE));

  0008d	8d 04 9d 00 00
	00 00		 lea	 eax, DWORD PTR [ebx*4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 399  : 	UINT nRead=Read(lpBuf, nCount);

  00094	50		 push	 eax
  00095	56		 push	 esi
  00096	e8 00 00 00 00	 call	 ?Read@CArchive@@QAEIPAXI@Z ; CArchive::Read

; 400  : 	if(nRead!=nCount)

  0009b	8d 0c 9d 00 00
	00 00		 lea	 ecx, DWORD PTR [ebx*4]
  000a2	3b c1		 cmp	 eax, ecx
  000a4	0f 85 4c 01 00
	00		 jne	 $LN75@Serialize
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 97   : 		while( nElementsLeft > 0 )

  000aa	03 f1		 add	 esi, ecx
  000ac	8b 4d 08	 mov	 ecx, DWORD PTR _ar$[ebp]

; 103  : 			nElementsLeft -= nElementsToRead;

  000af	2b fb		 sub	 edi, ebx
  000b1	75 d0		 jne	 SHORT $LL18@Serialize
$LN2@Serialize:

; 1177 : 		for (CNode* pNode = m_pNodeHead; pNode != NULL; pNode = pNode->pNext)

  000b3	8b 45 f8	 mov	 eax, DWORD PTR _pNode$1$[ebp]
  000b6	8b 00		 mov	 eax, DWORD PTR [eax]
  000b8	89 45 f8	 mov	 DWORD PTR _pNode$1$[ebp], eax
  000bb	85 c0		 test	 eax, eax
  000bd	0f 85 71 ff ff
	ff		 jne	 $LL4@Serialize

; 1197 : 		}
; 1198 : 	}
; 1199 : }

  000c3	5f		 pop	 edi
  000c4	5e		 pop	 esi
  000c5	5b		 pop	 ebx
  000c6	8b e5		 mov	 esp, ebp
  000c8	5d		 pop	 ebp
  000c9	c2 04 00	 ret	 4
$LN7@Serialize:

; 1186 : 			SerializeElements<TYPE>(ar, pData, 1);
; 1187 : 		}
; 1188 : 	}
; 1189 : 	else
; 1190 : 	{
; 1191 : 		DWORD_PTR nNewCount = ar.ReadCount();

  000cc	e8 00 00 00 00	 call	 ?ReadCount@CArchive@@QAEKXZ ; CArchive::ReadCount

; 1192 : 		while (nNewCount--)

  000d1	85 c0		 test	 eax, eax
  000d3	0f 84 14 01 00
	00		 je	 $LN86@Serialize
  000d9	0f 1f 80 00 00
	00 00		 npad	 7
$LL5@Serialize:
  000e0	48		 dec	 eax
  000e1	89 45 f0	 mov	 DWORD PTR _nNewCount$1$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 212  : 	{ return (m_nMode & CArchive::load) == 0; }

  000e4	8b 45 08	 mov	 eax, DWORD PTR _ar$[ebp]
  000e7	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  000ea	f7 d1		 not	 ecx
  000ec	f6 c1 01	 test	 cl, 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 73   : 	if (ar.IsStoring())

  000ef	74 3d		 je	 SHORT $LN42@Serialize

; 79   : 		pData = pElements;

  000f1	8d 4d f4	 lea	 ecx, DWORD PTR _newData$1[ebp]
  000f4	bb 01 00 00 00	 mov	 ebx, 1
  000f9	89 4d f8	 mov	 DWORD PTR _pData$1$[ebp], ecx
  000fc	0f 1f 40 00	 npad	 4
$LL37@Serialize:

; 80   : 		while( nElementsLeft > 0 )
; 81   : 		{
; 82   : 			UINT nElementsToWrite;
; 83   : 
; 84   : 			nElementsToWrite = UINT(__min(nElementsLeft, INT_MAX/sizeof(TYPE)));

  00100	bf ff ff ff 1f	 mov	 edi, 536870911		; 1fffffffH
  00105	3b df		 cmp	 ebx, edi
  00107	0f 42 fb	 cmovb	 edi, ebx

; 85   : 			ar.Write(pData, nElementsToWrite*sizeof(TYPE));

  0010a	8d 34 bd 00 00
	00 00		 lea	 esi, DWORD PTR [edi*4]
  00111	56		 push	 esi
  00112	51		 push	 ecx
  00113	8b c8		 mov	 ecx, eax
  00115	e8 00 00 00 00	 call	 ?Write@CArchive@@QAEXPBXI@Z ; CArchive::Write

; 87   : 			pData += nElementsToWrite;

  0011a	8b 4d f8	 mov	 ecx, DWORD PTR _pData$1$[ebp]
  0011d	8b 45 08	 mov	 eax, DWORD PTR _ar$[ebp]
  00120	03 ce		 add	 ecx, esi
  00122	89 4d f8	 mov	 DWORD PTR _pData$1$[ebp], ecx
  00125	2b df		 sub	 ebx, edi
  00127	75 d7		 jne	 SHORT $LL37@Serialize

; 88   : 		}
; 89   : 	}

  00129	8b 5d fc	 mov	 ebx, DWORD PTR _this$1$[ebp]
  0012c	eb 4a		 jmp	 SHORT $LN40@Serialize
$LN42@Serialize:

; 96   : 		pData = pElements;

  0012e	8d 55 f4	 lea	 edx, DWORD PTR _newData$1[ebp]
  00131	be 01 00 00 00	 mov	 esi, 1
  00136	89 55 f8	 mov	 DWORD PTR _pData$1$[ebp], edx
  00139	0f 1f 80 00 00
	00 00		 npad	 7
$LL39@Serialize:

; 98   : 		{
; 99   : 			UINT nElementsToRead;
; 100  : 
; 101  : 			nElementsToRead = UINT(__min(nElementsLeft, INT_MAX/sizeof(TYPE)));

  00140	bf ff ff ff 1f	 mov	 edi, 536870911		; 1fffffffH
  00145	3b f7		 cmp	 esi, edi
  00147	0f 42 fe	 cmovb	 edi, esi

; 102  : 			ar.EnsureRead(pData, nElementsToRead*sizeof(TYPE));

  0014a	8d 0c bd 00 00
	00 00		 lea	 ecx, DWORD PTR [edi*4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 399  : 	UINT nRead=Read(lpBuf, nCount);

  00151	51		 push	 ecx
  00152	52		 push	 edx
  00153	8b c8		 mov	 ecx, eax
  00155	e8 00 00 00 00	 call	 ?Read@CArchive@@QAEIPAXI@Z ; CArchive::Read

; 400  : 	if(nRead!=nCount)

  0015a	8d 0c bd 00 00
	00 00		 lea	 ecx, DWORD PTR [edi*4]
  00161	3b c1		 cmp	 eax, ecx
  00163	0f 85 8d 00 00
	00		 jne	 $LN75@Serialize
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 97   : 		while( nElementsLeft > 0 )

  00169	8b 55 f8	 mov	 edx, DWORD PTR _pData$1$[ebp]
  0016c	8b 45 08	 mov	 eax, DWORD PTR _ar$[ebp]

; 104  : 			pData += nElementsToRead;

  0016f	03 d1		 add	 edx, ecx
  00171	89 55 f8	 mov	 DWORD PTR _pData$1$[ebp], edx
  00174	2b f7		 sub	 esi, edi
  00176	75 c8		 jne	 SHORT $LL39@Serialize
$LN40@Serialize:

; 902  : 	if (m_pNodeFree == NULL)

  00178	83 7b 10 00	 cmp	 DWORD PTR [ebx+16], 0

; 1193 : 		{
; 1194 : 			TYPE newData[1];
; 1195 : 			SerializeElements<TYPE>(ar, newData, 1);
; 1196 : 			AddTail(newData[0]);

  0017c	8b 75 f4	 mov	 esi, DWORD PTR _newData$1[ebp]

; 968  : 	CNode* pNewNode = NewNode(m_pNodeTail, NULL);

  0017f	8b 7b 08	 mov	 edi, DWORD PTR [ebx+8]

; 902  : 	if (m_pNodeFree == NULL)

  00182	75 32		 jne	 SHORT $LN63@Serialize

; 903  : 	{
; 904  : 		// add another block
; 905  : 		CPlex* pNewBlock = CPlex::Create(m_pBlocks, m_nBlockSize,

  00184	6a 0c		 push	 12			; 0000000cH
  00186	ff 73 18	 push	 DWORD PTR [ebx+24]
  00189	8d 43 14	 lea	 eax, DWORD PTR [ebx+20]
  0018c	50		 push	 eax
  0018d	e8 00 00 00 00	 call	 ?Create@CPlex@@SGPAU1@AAPAU1@II@Z ; CPlex::Create

; 906  : 				 sizeof(CNode));
; 907  : 
; 908  : 		// chain them into free list
; 909  : 		CNode* pNode = (CNode*) pNewBlock->data();
; 910  : 		// free in reverse order to make it easier to debug
; 911  : 		pNode += m_nBlockSize - 1;

  00192	8b 53 18	 mov	 edx, DWORD PTR [ebx+24]
  00195	83 c0 08	 add	 eax, 8
  00198	8d 4a ff	 lea	 ecx, DWORD PTR [edx-1]

; 912  : 		for (INT_PTR i = m_nBlockSize-1; i >= 0; i--, pNode--)

  0019b	83 c2 ff	 add	 edx, -1
  0019e	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]
  001a1	8d 0c 88	 lea	 ecx, DWORD PTR [eax+ecx*4]
  001a4	78 10		 js	 SHORT $LN63@Serialize
$LL60@Serialize:

; 913  : 		{
; 914  : 			pNode->pNext = m_pNodeFree;

  001a6	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  001a9	89 01		 mov	 DWORD PTR [ecx], eax

; 915  : 			m_pNodeFree = pNode;

  001ab	89 4b 10	 mov	 DWORD PTR [ebx+16], ecx
  001ae	83 e9 0c	 sub	 ecx, 12			; 0000000cH
  001b1	83 ea 01	 sub	 edx, 1
  001b4	79 f0		 jns	 SHORT $LL60@Serialize
$LN63@Serialize:

; 916  : 		}
; 917  : 	}
; 918  : 	ENSURE(m_pNodeFree != NULL);  // we must have something

  001b6	8b 4b 10	 mov	 ecx, DWORD PTR [ebx+16]
  001b9	85 c9		 test	 ecx, ecx
  001bb	74 42		 je	 SHORT $LN76@Serialize

; 919  : 
; 920  : 	CList::CNode* pNode = m_pNodeFree;
; 921  : 	m_pNodeFree = m_pNodeFree->pNext;

  001bd	8b 01		 mov	 eax, DWORD PTR [ecx]
  001bf	89 43 10	 mov	 DWORD PTR [ebx+16], eax

; 922  : 	pNode->pPrev = pPrev;

  001c2	89 79 04	 mov	 DWORD PTR [ecx+4], edi

; 923  : 	pNode->pNext = pNext;

  001c5	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 924  : 	m_nCount++;

  001cb	ff 43 0c	 inc	 DWORD PTR [ebx+12]

; 969  : 	pNewNode->data = newElement;

  001ce	89 71 08	 mov	 DWORD PTR [ecx+8], esi

; 970  : 	if (m_pNodeTail != NULL)

  001d1	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  001d4	85 c0		 test	 eax, eax
  001d6	74 04		 je	 SHORT $LN54@Serialize

; 971  : 		m_pNodeTail->pNext = pNewNode;

  001d8	89 08		 mov	 DWORD PTR [eax], ecx
  001da	eb 03		 jmp	 SHORT $LN55@Serialize
$LN54@Serialize:

; 972  : 	else
; 973  : 		m_pNodeHead = pNewNode;

  001dc	89 4b 04	 mov	 DWORD PTR [ebx+4], ecx
$LN55@Serialize:

; 1192 : 		while (nNewCount--)

  001df	8b 45 f0	 mov	 eax, DWORD PTR _nNewCount$1$[ebp]

; 974  : 	m_pNodeTail = pNewNode;

  001e2	89 4b 08	 mov	 DWORD PTR [ebx+8], ecx

; 1192 : 		while (nNewCount--)

  001e5	85 c0		 test	 eax, eax
  001e7	0f 85 f3 fe ff
	ff		 jne	 $LL5@Serialize
$LN86@Serialize:
  001ed	5f		 pop	 edi

; 1197 : 		}
; 1198 : 	}
; 1199 : }

  001ee	5e		 pop	 esi
  001ef	5b		 pop	 ebx
  001f0	8b e5		 mov	 esp, ebp
  001f2	5d		 pop	 ebp
  001f3	c2 04 00	 ret	 4
$LN75@Serialize:
  001f6	6a 00		 push	 0
  001f8	6a 03		 push	 3
  001fa	e8 00 00 00 00	 call	 ?AfxThrowArchiveException@@YGXHPBD@Z ; AfxThrowArchiveException
$LN76@Serialize:
  001ff	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN105@Serialize:
  00204	cc		 int	 3
?Serialize@?$CList@PAVCDrawingSymbol@@PAV1@@@UAEXAAVCArchive@@@Z ENDP ; CList<CDrawingSymbol *,CDrawingSymbol *>::Serialize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ??1?$CList@PAVCDrawingSymbol@@PAV1@@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$CList@PAVCDrawingSymbol@@PAV1@@@UAE@XZ PROC	; CList<CDrawingSymbol *,CDrawingSymbol *>::~CList<CDrawingSymbol *,CDrawingSymbol *>, COMDAT
; _this$ = ecx

; 878  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$CList@PAVCDrawingSymbol@@PAV1@@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx

; 872  : 	m_pBlocks->FreeDataChain();

  00025	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]

; 878  : {

  00028	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CList@PAVCDrawingSymbol@@PAV1@@@6B@

; 870  : 	m_nCount = 0;

  0002e	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0

; 871  : 	m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;

  00035	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0003c	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00043	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 872  : 	m_pBlocks->FreeDataChain();

  0004a	e8 00 00 00 00	 call	 ?FreeDataChain@CPlex@@QAEXXZ ; CPlex::FreeDataChain

; 873  : 	m_pBlocks = NULL;

  0004f	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 879  : 	RemoveAll();
; 880  : 	ASSERT(m_nCount == 0);
; 881  : }

  00056	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00059	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00060	59		 pop	 ecx
  00061	5e		 pop	 esi
  00062	8b e5		 mov	 esp, ebp
  00064	5d		 pop	 ebp
  00065	c3		 ret	 0
  00066	cc		 int	 3
  00067	cc		 int	 3
  00068	cc		 int	 3
  00069	cc		 int	 3
  0006a	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CList@PAVCDrawingSymbol@@PAV1@@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$CList@PAVCDrawingSymbol@@PAV1@@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$CList@PAVCDrawingSymbol@@PAV1@@@UAE@XZ ENDP	; CList<CDrawingSymbol *,CDrawingSymbol *>::~CList<CDrawingSymbol *,CDrawingSymbol *>
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ?NewNode@?$CList@PAVCDrawingSymbol@@PAV1@@@IAEPAUCNode@1@PAU21@0@Z
_TEXT	SEGMENT
_pPrev$ = 8						; size = 4
_pNext$ = 12						; size = 4
?NewNode@?$CList@PAVCDrawingSymbol@@PAV1@@@IAEPAUCNode@1@PAU21@0@Z PROC ; CList<CDrawingSymbol *,CDrawingSymbol *>::NewNode, COMDAT
; _this$ = ecx

; 901  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 902  : 	if (m_pNodeFree == NULL)

  00006	83 7e 10 00	 cmp	 DWORD PTR [esi+16], 0
  0000a	75 34		 jne	 SHORT $LN7@NewNode

; 903  : 	{
; 904  : 		// add another block
; 905  : 		CPlex* pNewBlock = CPlex::Create(m_pBlocks, m_nBlockSize,

  0000c	6a 0c		 push	 12			; 0000000cH
  0000e	ff 76 18	 push	 DWORD PTR [esi+24]
  00011	8d 46 14	 lea	 eax, DWORD PTR [esi+20]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ?Create@CPlex@@SGPAU1@AAPAU1@II@Z ; CPlex::Create

; 906  : 				 sizeof(CNode));
; 907  : 
; 908  : 		// chain them into free list
; 909  : 		CNode* pNode = (CNode*) pNewBlock->data();
; 910  : 		// free in reverse order to make it easier to debug
; 911  : 		pNode += m_nBlockSize - 1;

  0001a	8b 56 18	 mov	 edx, DWORD PTR [esi+24]
  0001d	83 c0 08	 add	 eax, 8
  00020	8d 0c 52	 lea	 ecx, DWORD PTR [edx+edx*2]
  00023	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  00026	83 c0 f4	 add	 eax, -12		; fffffff4H

; 912  : 		for (INT_PTR i = m_nBlockSize-1; i >= 0; i--, pNode--)

  00029	83 c2 ff	 add	 edx, -1
  0002c	78 12		 js	 SHORT $LN7@NewNode
  0002e	66 90		 npad	 2
$LL4@NewNode:

; 913  : 		{
; 914  : 			pNode->pNext = m_pNodeFree;

  00030	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00033	89 08		 mov	 DWORD PTR [eax], ecx

; 915  : 			m_pNodeFree = pNode;

  00035	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00038	83 e8 0c	 sub	 eax, 12			; 0000000cH
  0003b	83 ea 01	 sub	 edx, 1
  0003e	79 f0		 jns	 SHORT $LL4@NewNode
$LN7@NewNode:

; 916  : 		}
; 917  : 	}
; 918  : 	ENSURE(m_pNodeFree != NULL);  // we must have something

  00040	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00043	85 c0		 test	 eax, eax
  00045	74 18		 je	 SHORT $LN17@NewNode

; 919  : 
; 920  : 	CList::CNode* pNode = m_pNodeFree;
; 921  : 	m_pNodeFree = m_pNodeFree->pNext;

  00047	8b 08		 mov	 ecx, DWORD PTR [eax]
  00049	89 4e 10	 mov	 DWORD PTR [esi+16], ecx

; 922  : 	pNode->pPrev = pPrev;

  0004c	8b 4d 08	 mov	 ecx, DWORD PTR _pPrev$[ebp]
  0004f	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 923  : 	pNode->pNext = pNext;

  00052	8b 4d 0c	 mov	 ecx, DWORD PTR _pNext$[ebp]
  00055	89 08		 mov	 DWORD PTR [eax], ecx

; 924  : 	m_nCount++;

  00057	ff 46 0c	 inc	 DWORD PTR [esi+12]

; 925  : 	ASSERT(m_nCount > 0);  // make sure we don't overflow
; 926  : 
; 927  : #pragma push_macro("new")
; 928  : #undef new
; 929  : 	::new( (void*)( &pNode->data ) ) TYPE;
; 930  : #pragma pop_macro("new")
; 931  : 	return pNode;

  0005a	5e		 pop	 esi

; 932  : }

  0005b	5d		 pop	 ebp
  0005c	c2 08 00	 ret	 8
$LN17@NewNode:

; 916  : 		}
; 917  : 	}
; 918  : 	ENSURE(m_pNodeFree != NULL);  // we must have something

  0005f	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN15@NewNode:
  00064	cc		 int	 3
?NewNode@?$CList@PAVCDrawingSymbol@@PAV1@@@IAEPAUCNode@1@PAU21@0@Z ENDP ; CList<CDrawingSymbol *,CDrawingSymbol *>::NewNode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ?RemoveAll@?$CList@PAVCDrawingSymbol@@PAV1@@@QAEXXZ
_TEXT	SEGMENT
?RemoveAll@?$CList@PAVCDrawingSymbol@@PAV1@@@QAEXXZ PROC ; CList<CDrawingSymbol *,CDrawingSymbol *>::RemoveAll, COMDAT
; _this$ = ecx

; 862  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 863  : 	ASSERT_VALID(this);
; 864  : 
; 865  : 	// destroy elements
; 866  : 	CNode* pNode;
; 867  : 	for (pNode = m_pNodeHead; pNode != NULL; pNode = pNode->pNext)
; 868  : 		pNode->data.~TYPE();
; 869  : 
; 870  : 	m_nCount = 0;
; 871  : 	m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
; 872  : 	m_pBlocks->FreeDataChain();

  00003	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00006	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  0000d	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00014	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  0001b	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00022	e8 00 00 00 00	 call	 ?FreeDataChain@CPlex@@QAEXXZ ; CPlex::FreeDataChain

; 873  : 	m_pBlocks = NULL;

  00027	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
  0002e	5e		 pop	 esi

; 874  : }

  0002f	c3		 ret	 0
?RemoveAll@?$CList@PAVCDrawingSymbol@@PAV1@@@QAEXXZ ENDP ; CList<CDrawingSymbol *,CDrawingSymbol *>::RemoveAll
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ?AddTail@?$CList@PAVCDrawingSymbol@@PAV1@@@QAEPAU__POSITION@@PAVCDrawingSymbol@@@Z
_TEXT	SEGMENT
_newElement$ = 8					; size = 4
?AddTail@?$CList@PAVCDrawingSymbol@@PAV1@@@QAEPAU__POSITION@@PAVCDrawingSymbol@@@Z PROC ; CList<CDrawingSymbol *,CDrawingSymbol *>::AddTail, COMDAT
; _this$ = ecx

; 965  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	57		 push	 edi

; 902  : 	if (m_pNodeFree == NULL)

  00007	83 7e 10 00	 cmp	 DWORD PTR [esi+16], 0

; 966  : 	ASSERT_VALID(this);
; 967  : 
; 968  : 	CNode* pNewNode = NewNode(m_pNodeTail, NULL);

  0000b	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]

; 902  : 	if (m_pNodeFree == NULL)

  0000e	75 32		 jne	 SHORT $LN11@AddTail

; 903  : 	{
; 904  : 		// add another block
; 905  : 		CPlex* pNewBlock = CPlex::Create(m_pBlocks, m_nBlockSize,

  00010	6a 0c		 push	 12			; 0000000cH
  00012	ff 76 18	 push	 DWORD PTR [esi+24]
  00015	8d 46 14	 lea	 eax, DWORD PTR [esi+20]
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ?Create@CPlex@@SGPAU1@AAPAU1@II@Z ; CPlex::Create

; 906  : 				 sizeof(CNode));
; 907  : 
; 908  : 		// chain them into free list
; 909  : 		CNode* pNode = (CNode*) pNewBlock->data();
; 910  : 		// free in reverse order to make it easier to debug
; 911  : 		pNode += m_nBlockSize - 1;

  0001e	8b 56 18	 mov	 edx, DWORD PTR [esi+24]
  00021	83 c0 08	 add	 eax, 8
  00024	8d 4a ff	 lea	 ecx, DWORD PTR [edx-1]

; 912  : 		for (INT_PTR i = m_nBlockSize-1; i >= 0; i--, pNode--)

  00027	83 c2 ff	 add	 edx, -1
  0002a	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]
  0002d	8d 0c 88	 lea	 ecx, DWORD PTR [eax+ecx*4]
  00030	78 10		 js	 SHORT $LN11@AddTail
$LL8@AddTail:

; 913  : 		{
; 914  : 			pNode->pNext = m_pNodeFree;

  00032	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00035	89 01		 mov	 DWORD PTR [ecx], eax

; 915  : 			m_pNodeFree = pNode;

  00037	89 4e 10	 mov	 DWORD PTR [esi+16], ecx
  0003a	83 e9 0c	 sub	 ecx, 12			; 0000000cH
  0003d	83 ea 01	 sub	 edx, 1
  00040	79 f0		 jns	 SHORT $LL8@AddTail
$LN11@AddTail:

; 916  : 		}
; 917  : 	}
; 918  : 	ENSURE(m_pNodeFree != NULL);  // we must have something

  00042	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00045	85 c9		 test	 ecx, ecx
  00047	74 39		 je	 SHORT $LN22@AddTail

; 919  : 
; 920  : 	CList::CNode* pNode = m_pNodeFree;
; 921  : 	m_pNodeFree = m_pNodeFree->pNext;

  00049	8b 01		 mov	 eax, DWORD PTR [ecx]
  0004b	89 46 10	 mov	 DWORD PTR [esi+16], eax

; 969  : 	pNewNode->data = newElement;

  0004e	8b 45 08	 mov	 eax, DWORD PTR _newElement$[ebp]

; 922  : 	pNode->pPrev = pPrev;

  00051	89 79 04	 mov	 DWORD PTR [ecx+4], edi

; 923  : 	pNode->pNext = pNext;

  00054	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 924  : 	m_nCount++;

  0005a	ff 46 0c	 inc	 DWORD PTR [esi+12]

; 969  : 	pNewNode->data = newElement;

  0005d	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 970  : 	if (m_pNodeTail != NULL)

  00060	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00063	85 c0		 test	 eax, eax
  00065	74 0d		 je	 SHORT $LN2@AddTail

; 971  : 		m_pNodeTail->pNext = pNewNode;

  00067	89 08		 mov	 DWORD PTR [eax], ecx

; 972  : 	else
; 973  : 		m_pNodeHead = pNewNode;
; 974  : 	m_pNodeTail = pNewNode;
; 975  : 	return (POSITION) pNewNode;

  00069	8b c1		 mov	 eax, ecx
  0006b	5f		 pop	 edi
  0006c	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  0006f	5e		 pop	 esi

; 976  : }

  00070	5d		 pop	 ebp
  00071	c2 04 00	 ret	 4
$LN2@AddTail:

; 972  : 	else
; 973  : 		m_pNodeHead = pNewNode;
; 974  : 	m_pNodeTail = pNewNode;
; 975  : 	return (POSITION) pNewNode;

  00074	5f		 pop	 edi
  00075	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  00078	8b c1		 mov	 eax, ecx
  0007a	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  0007d	5e		 pop	 esi

; 976  : }

  0007e	5d		 pop	 ebp
  0007f	c2 04 00	 ret	 4
$LN22@AddTail:

; 918  : 	ENSURE(m_pNodeFree != NULL);  // we must have something

  00082	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN20@AddTail:
  00087	cc		 int	 3
?AddTail@?$CList@PAVCDrawingSymbol@@PAV1@@@QAEPAU__POSITION@@PAVCDrawingSymbol@@@Z ENDP ; CList<CDrawingSymbol *,CDrawingSymbol *>::AddTail
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ??0?$CList@PAVCDrawingSymbol@@PAV1@@@QAE@H@Z
_TEXT	SEGMENT
_nBlockSize$ = 8					; size = 4
??0?$CList@PAVCDrawingSymbol@@PAV1@@@QAE@H@Z PROC	; CList<CDrawingSymbol *,CDrawingSymbol *>::CList<CDrawingSymbol *,CDrawingSymbol *>, COMDAT
; _this$ = ecx

; 851  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 852  : 	ASSERT(nBlockSize > 0);
; 853  : 
; 854  : 	m_nCount = 0;
; 855  : 	m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
; 856  : 	m_pBlocks = NULL;
; 857  : 	m_nBlockSize = nBlockSize;

  00003	8b 45 08	 mov	 eax, DWORD PTR _nBlockSize$[ebp]
  00006	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 858  : }

  00009	8b c1		 mov	 eax, ecx
  0000b	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CList@PAVCDrawingSymbol@@PAV1@@@6B@
  00011	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0
  00018	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  0001f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00026	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0002d	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
??0?$CList@PAVCDrawingSymbol@@PAV1@@@QAE@H@Z ENDP	; CList<CDrawingSymbol *,CDrawingSymbol *>::CList<CDrawingSymbol *,CDrawingSymbol *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
;	COMDAT ?Dump@CObject@@UBEXAAVCDumpContext@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?Dump@CObject@@UBEXAAVCDumpContext@@@Z PROC		; CObject::Dump, COMDAT
; _this$ = ecx

; 122  : 	{ /* no dumping in release builds */ }

  00000	c2 04 00	 ret	 4
?Dump@CObject@@UBEXAAVCDumpContext@@@Z ENDP		; CObject::Dump
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
;	COMDAT ?AssertValid@CObject@@UBEXXZ
_TEXT	SEGMENT
?AssertValid@CObject@@UBEXXZ PROC			; CObject::AssertValid, COMDAT
; _this$ = ecx

; 120  : 	{ /* no asserts in release builds */ }

  00000	c2 00 00	 ret	 0
?AssertValid@CObject@@UBEXXZ ENDP			; CObject::AssertValid
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
;	COMDAT ?Serialize@CObject@@UAEXAAVCArchive@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?Serialize@CObject@@UAEXAAVCArchive@@@Z PROC		; CObject::Serialize, COMDAT
; _this$ = ecx

; 106  : 	{ /* CObject does not serialize anything by default */ }

  00000	c2 04 00	 ret	 4
?Serialize@CObject@@UAEXAAVCArchive@@@Z ENDP		; CObject::Serialize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
;	COMDAT ??1CObject@@UAE@XZ
_TEXT	SEGMENT
??1CObject@@UAE@XZ PROC					; CObject::~CObject, COMDAT
; _this$ = ecx

; 104  : 	{ }

  00000	c2 00 00	 ret	 0
??1CObject@@UAE@XZ ENDP					; CObject::~CObject
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\SymbolData.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	c2 00 00	 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\SymbolData.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

  00000	c2 00 00	 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
