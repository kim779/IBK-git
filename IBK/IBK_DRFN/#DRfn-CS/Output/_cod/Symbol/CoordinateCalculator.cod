; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30145.0 

	TITLE	D:\git\src\IBK\IBK_DRFN\#DRfn-CS\_Obj\Symbol\CoordinateCalculator.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	?AbsoluteToRelative@CCoordinateCalculator@@QBE?AVCCoordinate@@ABVCCoordinateCalculatorData@@ABVCPoint@@@Z ; CCoordinateCalculator::AbsoluteToRelative
PUBLIC	?RelativeToAbsolute@CCoordinateCalculator@@QBE?AVCPoint@@ABVCCoordinateCalculatorData@@ABVCCoordinate@@@Z ; CCoordinateCalculator::RelativeToAbsolute
PUBLIC	?AbsoluteToAbsolute@CCoordinateCalculator@@QBE?AVCPoint@@ABVCCoordinateCalculatorData@@ABV2@@Z ; CCoordinateCalculator::AbsoluteToAbsolute
PUBLIC	?GetGap@CCoordinateCalculator@@QBE?AVCCoordinate@@ABVCCoordinateCalculatorData@@ABVCPoint@@1@Z ; CCoordinateCalculator::GetGap
PUBLIC	?GetData_X@CCoordinateCalculator@@QBENABVCCoordinateCalculatorData@@ABVCPoint@@H@Z ; CCoordinateCalculator::GetData_X
PUBLIC	?IsCalculator@CCoordinateCalculator@@ABE_NPAUIPacket133101@@@Z ; CCoordinateCalculator::IsCalculator
PUBLIC	?GetDisplayDataCurrentIndex@CCoordinateCalculator@@ABEHPAUIPacket133101@@H@Z ; CCoordinateCalculator::GetDisplayDataCurrentIndex
PUBLIC	??0CSelectableRegionCalculator@@QAE@XZ		; CSelectableRegionCalculator::CSelectableRegionCalculator
PUBLIC	?GetProximityRange@CSelectableRegionCalculator@@QBEHXZ ; CSelectableRegionCalculator::GetProximityRange
PUBLIC	?GetLineRegion@CSelectableRegionCalculator@@QBEXABVCPoint@@0AAVCRgn@@@Z ; CSelectableRegionCalculator::GetLineRegion
PUBLIC	?IsPointInCircle@CSelectableRegionCalculator@@QBE_NABVCPoint@@0@Z ; CSelectableRegionCalculator::IsPointInCircle
PUBLIC	?IsPointInCircle@CSelectableRegionCalculator@@QBE_NABVCPoint@@H0@Z ; CSelectableRegionCalculator::IsPointInCircle
PUBLIC	?GetHorzLineRegion@CSelectableRegionCalculator@@ABE?AVCRect@@ABVCPoint@@0@Z ; CSelectableRegionCalculator::GetHorzLineRegion
PUBLIC	?GetVertLineRegion@CSelectableRegionCalculator@@ABE?AVCRect@@ABVCPoint@@0@Z ; CSelectableRegionCalculator::GetVertLineRegion
PUBLIC	?GetAngleLineRegion@CSelectableRegionCalculator@@ABEXABVCPoint@@0AAVCRgn@@@Z ; CSelectableRegionCalculator::GetAngleLineRegion
PUBLIC	?GetPointOnMovedOrigin@CSelectableRegionCalculator@@ABE?AUtagPOINT@@ABVCPoint@@0@Z ; CSelectableRegionCalculator::GetPointOnMovedOrigin
PUBLIC	?GetVerticalPointsFromLength@CSelectableRegionCalculator@@ABEXABVCPoint@@0AAV2@1@Z ; CSelectableRegionCalculator::GetVerticalPointsFromLength
PUBLIC	?GetLineAngle@CSelectableRegionCalculator@@ABENABVCPoint@@0@Z ; CSelectableRegionCalculator::GetLineAngle
PUBLIC	?GetLineVerticalAngle@CSelectableRegionCalculator@@ABENABN@Z ; CSelectableRegionCalculator::GetLineVerticalAngle
PUBLIC	??_C@_07MGCPDNLD@DEFAULT@			; `string'
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@4000000000000000
PUBLIC	__real@bff0000000000000
PUBLIC	__real@fff0000000000000
PUBLIC	__xmm@7fffffffffffffff7fffffffffffffff
EXTRN	__imp__CreateRectRgn@16:PROC
EXTRN	__imp__CreatePolygonRgn@12:PROC
EXTRN	?Attach@CGdiObject@@QAEHPAX@Z:PROC		; CGdiObject::Attach
EXTRN	?GetRegion@CCoordinateCalculatorData@@QBE?AVCRect@@XZ:PROC ; CCoordinateCalculatorData::GetRegion
EXTRN	?GetDisplayDataStart@CCoordinateCalculatorData@@QBEHXZ:PROC ; CCoordinateCalculatorData::GetDisplayDataStart
EXTRN	?GetDisplayDataEnd@CCoordinateCalculatorData@@QBEHXZ:PROC ; CCoordinateCalculatorData::GetDisplayDataEnd
EXTRN	?GetDisplayDataMin_ScaleType@CCoordinateCalculatorData@@QBENXZ:PROC ; CCoordinateCalculatorData::GetDisplayDataMin_ScaleType
EXTRN	?GetDisplayDataMax_ScaleType@CCoordinateCalculatorData@@QBENXZ:PROC ; CCoordinateCalculatorData::GetDisplayDataMax_ScaleType
EXTRN	?GetPacket_X@CCoordinateCalculatorData@@QBEPAUIPacket133101@@XZ:PROC ; CCoordinateCalculatorData::GetPacket_X
EXTRN	?ApplyLog@CCoordinateCalculatorData@@QBENABN@Z:PROC ; CCoordinateCalculatorData::ApplyLog
EXTRN	?ApplyExp@CCoordinateCalculatorData@@QBENABN@Z:PROC ; CCoordinateCalculatorData::ApplyExp
EXTRN	?GetBlockIndex@CCoordinateCalculatorData@@QBE?AVCBlockIndex@@XZ:PROC ; CCoordinateCalculatorData::GetBlockIndex
EXTRN	??0CCoordinate@@QAE@XZ:PROC			; CCoordinate::CCoordinate
EXTRN	??0CCoordinate@@QAE@ABN0H@Z:PROC		; CCoordinate::CCoordinate
EXTRN	??0CCoordinate@@QAE@ABVCPoint@@@Z:PROC		; CCoordinate::CCoordinate
EXTRN	?GetX@CCoordinate@@QBENXZ:PROC			; CCoordinate::GetX
EXTRN	?GetY@CCoordinate@@QBENXZ:PROC			; CCoordinate::GetY
EXTRN	?GetPixel@CCoordinate@@QBE?AVCPoint@@XZ:PROC	; CCoordinate::GetPixel
EXTRN	?GetTimeDiff@CCoordinate@@QBEHXZ:PROC		; CCoordinate::GetTimeDiff
EXTRN	?AbsoluteToRelative_Y@CDataConversion@@SANABVCRect@@HABN1@Z:PROC ; CDataConversion::AbsoluteToRelative_Y
EXTRN	?RelativeToAbsolute@CDataConversion@@SA?AVCPoint@@ABVCRect@@HHABN1H1@Z:PROC ; CDataConversion::RelativeToAbsolute
EXTRN	?Round@CMath@@SAHN@Z:PROC			; CMath::Round
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__libm_sse2_pow_precise:PROC
EXTRN	__libm_sse2_sqrt_precise:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT __xmm@7fffffffffffffff7fffffffffffffff
CONST	SEGMENT
__xmm@7fffffffffffffff7fffffffffffffff DB 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH
	DB	0ffH, 07fH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 07fH
CONST	ENDS
;	COMDAT __real@fff0000000000000
CONST	SEGMENT
__real@fff0000000000000 DQ 0fff0000000000000r	; -inf
CONST	ENDS
;	COMDAT __real@bff0000000000000
CONST	SEGMENT
__real@bff0000000000000 DQ 0bff0000000000000r	; -1
CONST	ENDS
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT ??_C@_07MGCPDNLD@DEFAULT@
CONST	SEGMENT
??_C@_07MGCPDNLD@DEFAULT@ DB 'DEFAULT', 00H		; `string'
CONST	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\CoordinateCalculator.cpp
;	COMDAT ?GetLineVerticalAngle@CSelectableRegionCalculator@@ABENABN@Z
_TEXT	SEGMENT
_dAngle$ = 8						; size = 4
?GetLineVerticalAngle@CSelectableRegionCalculator@@ABENABN@Z PROC ; CSelectableRegionCalculator::GetLineVerticalAngle, COMDAT
; _this$ = ecx

; 326  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 327  : 	assert(dAngle != 0.0);
; 328  : 	return (-1.0/dAngle);

  00003	8b 45 08	 mov	 eax, DWORD PTR _dAngle$[ebp]
  00006	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@bff0000000000000
  0000c	dc 30		 fdiv	 QWORD PTR [eax]

; 329  : }

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
?GetLineVerticalAngle@CSelectableRegionCalculator@@ABENABN@Z ENDP ; CSelectableRegionCalculator::GetLineVerticalAngle
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\CoordinateCalculator.cpp
;	COMDAT ?GetLineAngle@CSelectableRegionCalculator@@ABENABVCPoint@@0@Z
_TEXT	SEGMENT
tv172 = -8						; size = 8
_point1$ = 8						; size = 4
_point2$ = 12						; size = 4
?GetLineAngle@CSelectableRegionCalculator@@ABENABVCPoint@@0@Z PROC ; CSelectableRegionCalculator::GetLineAngle, COMDAT
; _this$ = ecx

; 319  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 320  : 	return ((double)(point2.y - point1.y) / (double)(point2.x - point1.x));

  00006	8b 55 0c	 mov	 edx, DWORD PTR _point2$[ebp]
  00009	8b 4d 08	 mov	 ecx, DWORD PTR _point1$[ebp]
  0000c	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0000f	2b 41 04	 sub	 eax, DWORD PTR [ecx+4]
  00012	66 0f 6e c8	 movd	 xmm1, eax
  00016	8b 02		 mov	 eax, DWORD PTR [edx]
  00018	2b 01		 sub	 eax, DWORD PTR [ecx]
  0001a	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1
  0001e	66 0f 6e c0	 movd	 xmm0, eax
  00022	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00026	f2 0f 5e c8	 divsd	 xmm1, xmm0
  0002a	f2 0f 11 4d f8	 movsd	 QWORD PTR tv172[ebp], xmm1
  0002f	dd 45 f8	 fld	 QWORD PTR tv172[ebp]

; 321  : }

  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c2 08 00	 ret	 8
?GetLineAngle@CSelectableRegionCalculator@@ABENABVCPoint@@0@Z ENDP ; CSelectableRegionCalculator::GetLineAngle
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\CoordinateCalculator.cpp
;	COMDAT ?GetVerticalPointsFromLength@CSelectableRegionCalculator@@ABEXABVCPoint@@0AAV2@1@Z
_TEXT	SEGMENT
_lineAngle$1$ = -16					; size = 8
_x$1$ = -8						; size = 8
tv237 = -8						; size = 8
_pt1$ = 8						; size = 4
_pt2$ = 12						; size = 4
_selectableRegionPt1$ = 16				; size = 4
_selectableRegionPt2$ = 20				; size = 4
?GetVerticalPointsFromLength@CSelectableRegionCalculator@@ABEXABVCPoint@@0AAV2@1@Z PROC ; CSelectableRegionCalculator::GetVerticalPointsFromLength, COMDAT
; _this$ = ecx

; 304  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 14	 sub	 esp, 20			; 00000014H

; 320  : 	return ((double)(point2.y - point1.y) / (double)(point2.x - point1.x));

  00009	8b 55 08	 mov	 edx, DWORD PTR _pt1$[ebp]

; 304  : {

  0000c	56		 push	 esi

; 320  : 	return ((double)(point2.y - point1.y) / (double)(point2.x - point1.x));

  0000d	8b 75 0c	 mov	 esi, DWORD PTR _pt2$[ebp]
  00010	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00013	2b 42 04	 sub	 eax, DWORD PTR [edx+4]
  00016	66 0f 6e c8	 movd	 xmm1, eax
  0001a	8b 06		 mov	 eax, DWORD PTR [esi]
  0001c	2b 02		 sub	 eax, DWORD PTR [edx]
  0001e	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1
  00022	66 0f 6e c0	 movd	 xmm0, eax
  00026	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  0002a	f2 0f 5e c8	 divsd	 xmm1, xmm0

; 328  : 	return (-1.0/dAngle);

  0002e	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@bff0000000000000
  00036	f2 0f 5e c1	 divsd	 xmm0, xmm1

; 305  : 	// 두점의 수직기울기 구한다. == 현재 구할 두 좌표의 기울기
; 306  : 	double lineAngle = GetLineVerticalAngle(GetLineAngle(pt1, pt2));
; 307  : 
; 308  : 	double x = 0.0;
; 309  : 	x = sqrt(fabs(pow(m_nProximityRange, 2) / (pow(lineAngle, 2) +1)));

  0003a	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@4000000000000000

; 328  : 	return (-1.0/dAngle);

  00042	f2 0f 11 44 24
	08		 movsd	 QWORD PTR _lineAngle$1$[esp+24], xmm0
  00048	66 0f 6e 01	 movd	 xmm0, DWORD PTR [ecx]

; 305  : 	// 두점의 수직기울기 구한다. == 현재 구할 두 좌표의 기울기
; 306  : 	double lineAngle = GetLineVerticalAngle(GetLineAngle(pt1, pt2));
; 307  : 
; 308  : 	double x = 0.0;
; 309  : 	x = sqrt(fabs(pow(m_nProximityRange, 2) / (pow(lineAngle, 2) +1)));

  0004c	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00050	e8 00 00 00 00	 call	 __libm_sse2_pow_precise
  00055	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@4000000000000000
  0005d	f2 0f 11 44 24
	10		 movsd	 QWORD PTR tv237[esp+24], xmm0
  00063	f2 0f 10 44 24
	08		 movsd	 xmm0, QWORD PTR _lineAngle$1$[esp+24]
  00069	e8 00 00 00 00	 call	 __libm_sse2_pow_precise
  0006e	f2 0f 58 05 00
	00 00 00	 addsd	 xmm0, QWORD PTR __real@3ff0000000000000
  00076	f2 0f 10 54 24
	10		 movsd	 xmm2, QWORD PTR tv237[esp+24]
  0007c	0f 57 c9	 xorps	 xmm1, xmm1
  0007f	f2 0f 5e d0	 divsd	 xmm2, xmm0
  00083	0f 54 15 00 00
	00 00		 andps	 xmm2, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
  0008a	0f 28 c2	 movaps	 xmm0, xmm2
  0008d	66 0f 2e c8	 ucomisd xmm1, xmm0
  00091	77 06		 ja	 SHORT $LN11@GetVertica
  00093	f2 0f 51 c0	 sqrtsd	 xmm0, xmm0
  00097	eb 05		 jmp	 SHORT $LN12@GetVertica
$LN11@GetVertica:
  00099	e8 00 00 00 00	 call	 __libm_sse2_sqrt_precise
$LN12@GetVertica:

; 310  : 
; 311  : 	selectableRegionPt1 = CPoint(CMath::Round(x), CMath::Round(lineAngle * x));

  0009e	0f 28 c8	 movaps	 xmm1, xmm0
  000a1	f2 0f 11 44 24
	10		 movsd	 QWORD PTR _x$1$[esp+24], xmm0
  000a7	f2 0f 59 4c 24
	08		 mulsd	 xmm1, QWORD PTR _lineAngle$1$[esp+24]
  000ad	83 ec 08	 sub	 esp, 8
  000b0	f2 0f 11 0c 24	 movsd	 QWORD PTR [esp], xmm1
  000b5	e8 00 00 00 00	 call	 ?Round@CMath@@SAHN@Z	; CMath::Round
  000ba	f2 0f 10 44 24
	18		 movsd	 xmm0, QWORD PTR _x$1$[esp+32]
  000c0	8b f0		 mov	 esi, eax
  000c2	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  000c7	e8 00 00 00 00	 call	 ?Round@CMath@@SAHN@Z	; CMath::Round
  000cc	8b 4d 10	 mov	 ecx, DWORD PTR _selectableRegionPt1$[ebp]

; 312  : 	selectableRegionPt2 = CPoint(-selectableRegionPt1.x, -selectableRegionPt1.y);

  000cf	8b d0		 mov	 edx, eax
  000d1	83 c4 08	 add	 esp, 8
  000d4	f7 da		 neg	 edx
  000d6	89 01		 mov	 DWORD PTR [ecx], eax
  000d8	8b 45 14	 mov	 eax, DWORD PTR _selectableRegionPt2$[ebp]
  000db	89 71 04	 mov	 DWORD PTR [ecx+4], esi
  000de	f7 de		 neg	 esi
  000e0	89 70 04	 mov	 DWORD PTR [eax+4], esi
  000e3	89 10		 mov	 DWORD PTR [eax], edx

; 313  : }

  000e5	5e		 pop	 esi
  000e6	8b e5		 mov	 esp, ebp
  000e8	5d		 pop	 ebp
  000e9	c2 10 00	 ret	 16			; 00000010H
?GetVerticalPointsFromLength@CSelectableRegionCalculator@@ABEXABVCPoint@@0AAV2@1@Z ENDP ; CSelectableRegionCalculator::GetVerticalPointsFromLength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\CoordinateCalculator.cpp
;	COMDAT ?GetPointOnMovedOrigin@CSelectableRegionCalculator@@ABE?AUtagPOINT@@ABVCPoint@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_origin$ = 12						; size = 4
_point$ = 16						; size = 4
?GetPointOnMovedOrigin@CSelectableRegionCalculator@@ABE?AUtagPOINT@@ABVCPoint@@0@Z PROC ; CSelectableRegionCalculator::GetPointOnMovedOrigin, COMDAT
; _this$ = ecx

; 291  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 292  : 	POINT movePoint;
; 293  : 	movePoint.x = origin.x + point.x;

  00003	8b 55 10	 mov	 edx, DWORD PTR _point$[ebp]
  00006	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00009	56		 push	 esi
  0000a	8b 75 0c	 mov	 esi, DWORD PTR _origin$[ebp]
  0000d	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0000f	03 0a		 add	 ecx, DWORD PTR [edx]
  00011	89 08		 mov	 DWORD PTR [eax], ecx

; 294  : 	movePoint.y = origin.y + point.y;

  00013	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00016	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  00019	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 295  : 
; 296  : 	return movePoint;

  0001c	5e		 pop	 esi

; 297  : }

  0001d	5d		 pop	 ebp
  0001e	c2 0c 00	 ret	 12			; 0000000cH
?GetPointOnMovedOrigin@CSelectableRegionCalculator@@ABE?AUtagPOINT@@ABVCPoint@@0@Z ENDP ; CSelectableRegionCalculator::GetPointOnMovedOrigin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\CoordinateCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\CoordinateCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\CoordinateCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin1.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\CoordinateCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin1.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\CoordinateCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin1.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\CoordinateCalculator.cpp
;	COMDAT ?GetAngleLineRegion@CSelectableRegionCalculator@@ABEXABVCPoint@@0AAVCRgn@@@Z
_TEXT	SEGMENT
_x$1$ = -72						; size = 8
$T2$sroa$195$1$ = -72					; size = 4
tv454 = -64						; size = 8
_initY$1$ = -64						; size = 4
_lineAngle$1$ = -56					; size = 8
$T1$sroa$362$1$ = -56					; size = 4
_point1$GSCopy$1$ = -48					; size = 4
_point2$GSCopy$1$ = -44					; size = 4
_region$GSCopy$1$ = -40					; size = 4
_selectableRegionPoints$ = -36				; size = 32
__$ArrayPad$ = -4					; size = 4
_point1$ = 8						; size = 4
_point2$ = 12						; size = 4
_region$ = 16						; size = 4
?GetAngleLineRegion@CSelectableRegionCalculator@@ABEXABVCPoint@@0AAVCRgn@@@Z PROC ; CSelectableRegionCalculator::GetAngleLineRegion, COMDAT
; _this$ = ecx

; 272  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 48	 sub	 esp, 72			; 00000048H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c4		 xor	 eax, esp
  00010	89 44 24 44	 mov	 DWORD PTR __$ArrayPad$[esp+72], eax
  00014	8b 55 08	 mov	 edx, DWORD PTR _point1$[ebp]
  00017	8b 45 10	 mov	 eax, DWORD PTR _region$[ebp]
  0001a	56		 push	 esi
  0001b	8b 75 0c	 mov	 esi, DWORD PTR _point2$[ebp]
  0001e	89 44 24 24	 mov	 DWORD PTR _region$GSCopy$1$[esp+76], eax
  00022	57		 push	 edi
  00023	89 54 24 20	 mov	 DWORD PTR _point1$GSCopy$1$[esp+80], edx

; 320  : 	return ((double)(point2.y - point1.y) / (double)(point2.x - point1.x));

  00027	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002a	2b 42 04	 sub	 eax, DWORD PTR [edx+4]

; 272  : {

  0002d	89 74 24 24	 mov	 DWORD PTR _point2$GSCopy$1$[esp+80], esi
  00031	66 0f 6e c8	 movd	 xmm1, eax

; 320  : 	return ((double)(point2.y - point1.y) / (double)(point2.x - point1.x));

  00035	8b 06		 mov	 eax, DWORD PTR [esi]
  00037	2b 02		 sub	 eax, DWORD PTR [edx]
  00039	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1
  0003d	66 0f 6e c0	 movd	 xmm0, eax
  00041	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00045	f2 0f 5e c8	 divsd	 xmm1, xmm0

; 328  : 	return (-1.0/dAngle);

  00049	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@bff0000000000000
  00051	f2 0f 5e c1	 divsd	 xmm0, xmm1

; 309  : 	x = sqrt(fabs(pow(m_nProximityRange, 2) / (pow(lineAngle, 2) +1)));

  00055	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@4000000000000000

; 328  : 	return (-1.0/dAngle);

  0005d	f2 0f 11 44 24
	18		 movsd	 QWORD PTR _lineAngle$1$[esp+80], xmm0
  00063	66 0f 6e 01	 movd	 xmm0, DWORD PTR [ecx]

; 309  : 	x = sqrt(fabs(pow(m_nProximityRange, 2) / (pow(lineAngle, 2) +1)));

  00067	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  0006b	e8 00 00 00 00	 call	 __libm_sse2_pow_precise
  00070	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@4000000000000000
  00078	f2 0f 11 44 24
	10		 movsd	 QWORD PTR tv454[esp+80], xmm0
  0007e	f2 0f 10 44 24
	18		 movsd	 xmm0, QWORD PTR _lineAngle$1$[esp+80]
  00084	e8 00 00 00 00	 call	 __libm_sse2_pow_precise
  00089	f2 0f 58 05 00
	00 00 00	 addsd	 xmm0, QWORD PTR __real@3ff0000000000000
  00091	f2 0f 10 54 24
	10		 movsd	 xmm2, QWORD PTR tv454[esp+80]
  00097	0f 57 c9	 xorps	 xmm1, xmm1
  0009a	f2 0f 5e d0	 divsd	 xmm2, xmm0
  0009e	0f 54 15 00 00
	00 00		 andps	 xmm2, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
  000a5	0f 28 c2	 movaps	 xmm0, xmm2
  000a8	66 0f 2e c8	 ucomisd xmm1, xmm0
  000ac	77 06		 ja	 SHORT $LN27@GetAngleLi
  000ae	f2 0f 51 c0	 sqrtsd	 xmm0, xmm0
  000b2	eb 05		 jmp	 SHORT $LN28@GetAngleLi
$LN27@GetAngleLi:
  000b4	e8 00 00 00 00	 call	 __libm_sse2_sqrt_precise
$LN28@GetAngleLi:

; 310  : 
; 311  : 	selectableRegionPt1 = CPoint(CMath::Round(x), CMath::Round(lineAngle * x));

  000b9	0f 28 c8	 movaps	 xmm1, xmm0
  000bc	f2 0f 11 44 24
	08		 movsd	 QWORD PTR _x$1$[esp+80], xmm0
  000c2	f2 0f 59 4c 24
	18		 mulsd	 xmm1, QWORD PTR _lineAngle$1$[esp+80]
  000c8	83 ec 08	 sub	 esp, 8
  000cb	f2 0f 11 0c 24	 movsd	 QWORD PTR [esp], xmm1
  000d0	e8 00 00 00 00	 call	 ?Round@CMath@@SAHN@Z	; CMath::Round
  000d5	f2 0f 10 44 24
	10		 movsd	 xmm0, QWORD PTR _x$1$[esp+88]
  000db	8b f0		 mov	 esi, eax
  000dd	89 74 24 18	 mov	 DWORD PTR _initY$1$[esp+88], esi
  000e1	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  000e6	e8 00 00 00 00	 call	 ?Round@CMath@@SAHN@Z	; CMath::Round

; 293  : 	movePoint.x = origin.x + point.x;

  000eb	8b 54 24 28	 mov	 edx, DWORD PTR _point1$GSCopy$1$[esp+88]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h

; 408  : 	x = initX;

  000ef	8b c8		 mov	 ecx, eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\CoordinateCalculator.cpp

; 294  : 	movePoint.y = origin.y + point.y;

  000f1	8b 44 24 18	 mov	 eax, DWORD PTR _initY$1$[esp+88]

; 312  : 	selectableRegionPt2 = CPoint(-selectableRegionPt1.x, -selectableRegionPt1.y);

  000f5	8b f9		 mov	 edi, ecx
  000f7	f7 de		 neg	 esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h

; 408  : 	x = initX;

  000f9	89 4c 24 20	 mov	 DWORD PTR $T1$sroa$362$1$[esp+88], ecx
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\CoordinateCalculator.cpp

; 312  : 	selectableRegionPt2 = CPoint(-selectableRegionPt1.x, -selectableRegionPt1.y);

  000fd	89 74 24 10	 mov	 DWORD PTR $T2$sroa$195$1$[esp+88], esi
  00101	f7 df		 neg	 edi

; 293  : 	movePoint.x = origin.x + point.x;

  00103	8b 32		 mov	 esi, DWORD PTR [edx]

; 311  : 	selectableRegionPt1 = CPoint(CMath::Round(x), CMath::Round(lineAngle * x));

  00105	83 c4 08	 add	 esp, 8

; 294  : 	movePoint.y = origin.y + point.y;

  00108	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  0010b	03 ce		 add	 ecx, esi
  0010d	03 c2		 add	 eax, edx

; 273  : 	assert(point1.x != point2.x && point1.y != point2.y);
; 274  : 
; 275  : 	// (0, 0)을 기준으로 한 ProximityRange 떨어진 두개의 좌표 구하기.
; 276  : 	CPoint basePt1, basePt2;
; 277  : 	GetVerticalPointsFromLength(point1, point2, basePt1, basePt2);
; 278  : 
; 279  : 	POINT selectableRegionPoints[4];
; 280  : 	selectableRegionPoints[0] = GetPointOnMovedOrigin(point1, basePt1);

  0010f	89 4c 24 2c	 mov	 DWORD PTR _selectableRegionPoints$[esp+80], ecx
  00113	89 44 24 30	 mov	 DWORD PTR _selectableRegionPoints$[esp+84], eax

; 294  : 	movePoint.y = origin.y + point.y;

  00117	8b 44 24 08	 mov	 eax, DWORD PTR $T2$sroa$195$1$[esp+80]
  0011b	8d 0c 3e	 lea	 ecx, DWORD PTR [esi+edi]

; 293  : 	movePoint.x = origin.x + point.x;

  0011e	8b 74 24 24	 mov	 esi, DWORD PTR _point2$GSCopy$1$[esp+80]

; 294  : 	movePoint.y = origin.y + point.y;

  00122	03 c2		 add	 eax, edx

; 281  : 	selectableRegionPoints[1] = GetPointOnMovedOrigin(point1, basePt2);

  00124	89 44 24 38	 mov	 DWORD PTR _selectableRegionPoints$[esp+92], eax

; 294  : 	movePoint.y = origin.y + point.y;

  00128	8b 44 24 08	 mov	 eax, DWORD PTR $T2$sroa$195$1$[esp+80]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin1.inl

; 276  : 	{ return Attach(::CreatePolygonRgn(lpPoints, nCount, nMode)); }

  0012c	6a 01		 push	 1
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\CoordinateCalculator.cpp

; 293  : 	movePoint.x = origin.x + point.x;

  0012e	8b 16		 mov	 edx, DWORD PTR [esi]

; 294  : 	movePoint.y = origin.y + point.y;

  00130	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
  00133	03 c6		 add	 eax, esi

; 282  : 	selectableRegionPoints[2] = GetPointOnMovedOrigin(point2, basePt2);

  00135	89 44 24 44	 mov	 DWORD PTR _selectableRegionPoints$[esp+104], eax

; 294  : 	movePoint.y = origin.y + point.y;

  00139	8b 44 24 14	 mov	 eax, DWORD PTR _initY$1$[esp+84]
  0013d	03 c6		 add	 eax, esi

; 281  : 	selectableRegionPoints[1] = GetPointOnMovedOrigin(point1, basePt2);

  0013f	89 4c 24 38	 mov	 DWORD PTR _selectableRegionPoints$[esp+92], ecx

; 293  : 	movePoint.x = origin.x + point.x;

  00143	8d 0c 3a	 lea	 ecx, DWORD PTR [edx+edi]

; 283  : 	selectableRegionPoints[3] = GetPointOnMovedOrigin(point2, basePt1);

  00146	89 44 24 4c	 mov	 DWORD PTR _selectableRegionPoints$[esp+112], eax

; 293  : 	movePoint.x = origin.x + point.x;

  0014a	03 54 24 1c	 add	 edx, DWORD PTR $T1$sroa$362$1$[esp+84]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin1.inl

; 276  : 	{ return Attach(::CreatePolygonRgn(lpPoints, nCount, nMode)); }

  0014e	8d 44 24 30	 lea	 eax, DWORD PTR _selectableRegionPoints$[esp+84]
  00152	6a 04		 push	 4
  00154	50		 push	 eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\CoordinateCalculator.cpp

; 282  : 	selectableRegionPoints[2] = GetPointOnMovedOrigin(point2, basePt2);

  00155	89 4c 24 48	 mov	 DWORD PTR _selectableRegionPoints$[esp+108], ecx

; 283  : 	selectableRegionPoints[3] = GetPointOnMovedOrigin(point2, basePt1);

  00159	89 54 24 50	 mov	 DWORD PTR _selectableRegionPoints$[esp+116], edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin1.inl

; 276  : 	{ return Attach(::CreatePolygonRgn(lpPoints, nCount, nMode)); }

  0015d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreatePolygonRgn@12
  00163	8b 4c 24 28	 mov	 ecx, DWORD PTR _region$GSCopy$1$[esp+80]
  00167	50		 push	 eax
  00168	e8 00 00 00 00	 call	 ?Attach@CGdiObject@@QAEHPAX@Z ; CGdiObject::Attach
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\CoordinateCalculator.cpp

; 286  : }

  0016d	8b 4c 24 4c	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+80]
  00171	5f		 pop	 edi
  00172	5e		 pop	 esi
  00173	33 cc		 xor	 ecx, esp
  00175	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0017a	8b e5		 mov	 esp, ebp
  0017c	5d		 pop	 ebp
  0017d	c2 0c 00	 ret	 12			; 0000000cH
?GetAngleLineRegion@CSelectableRegionCalculator@@ABEXABVCPoint@@0AAVCRgn@@@Z ENDP ; CSelectableRegionCalculator::GetAngleLineRegion
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\CoordinateCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\CoordinateCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\CoordinateCalculator.cpp
;	COMDAT ?GetVertLineRegion@CSelectableRegionCalculator@@ABE?AVCRect@@ABVCPoint@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_point1$ = 12						; size = 4
_point2$ = 16						; size = 4
?GetVertLineRegion@CSelectableRegionCalculator@@ABE?AVCRect@@ABVCPoint@@0@Z PROC ; CSelectableRegionCalculator::GetVertLineRegion, COMDAT
; _this$ = ecx

; 261  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 264  : 	CRect selectableRegion((point1.x - m_nProximityRange), point1.y, (point1.x + m_nProximityRange +1), point2.y);

  00003	8b 45 0c	 mov	 eax, DWORD PTR _point1$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	53		 push	 ebx
  00009	56		 push	 esi
  0000a	8b 18		 mov	 ebx, DWORD PTR [eax]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h

; 540  : 	left = l;

  0000c	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\CoordinateCalculator.cpp

; 264  : 	CRect selectableRegion((point1.x - m_nProximityRange), point1.y, (point1.x + m_nProximityRange +1), point2.y);

  0000f	2b d9		 sub	 ebx, ecx
  00011	41		 inc	 ecx
  00012	03 08		 add	 ecx, DWORD PTR [eax]
  00014	57		 push	 edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h

; 541  : 	top = t;

  00015	8b 78 04	 mov	 edi, DWORD PTR [eax+4]

; 542  : 	right = r;
; 543  : 	bottom = b;

  00018	8b 45 10	 mov	 eax, DWORD PTR _point2$[ebp]
  0001b	89 1e		 mov	 DWORD PTR [esi], ebx
  0001d	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  00020	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00023	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00026	89 46 0c	 mov	 DWORD PTR [esi+12], eax

; 884  : 	if (left > right)

  00029	3b d9		 cmp	 ebx, ecx
  0002b	7e 05		 jle	 SHORT $LN6@GetVertLin

; 885  : 	{
; 886  : 		nTemp = left;
; 887  : 		left = right;

  0002d	89 0e		 mov	 DWORD PTR [esi], ecx

; 888  : 		right = nTemp;

  0002f	89 5e 08	 mov	 DWORD PTR [esi+8], ebx
$LN6@GetVertLin:

; 889  : 	}
; 890  : 	if (top > bottom)

  00032	3b f8		 cmp	 edi, eax
  00034	7e 06		 jle	 SHORT $LN9@GetVertLin

; 891  : 	{
; 892  : 		nTemp = top;
; 893  : 		top = bottom;

  00036	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 894  : 		bottom = nTemp;

  00039	89 7e 0c	 mov	 DWORD PTR [esi+12], edi
$LN9@GetVertLin:
  0003c	5f		 pop	 edi
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\CoordinateCalculator.cpp

; 268  : }

  0003d	8b c6		 mov	 eax, esi
  0003f	5e		 pop	 esi
  00040	5b		 pop	 ebx
  00041	5d		 pop	 ebp
  00042	c2 0c 00	 ret	 12			; 0000000cH
?GetVertLineRegion@CSelectableRegionCalculator@@ABE?AVCRect@@ABVCPoint@@0@Z ENDP ; CSelectableRegionCalculator::GetVertLineRegion
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\CoordinateCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\CoordinateCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\CoordinateCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\CoordinateCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\CoordinateCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\CoordinateCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\CoordinateCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\CoordinateCalculator.cpp
;	COMDAT ?GetHorzLineRegion@CSelectableRegionCalculator@@ABE?AVCRect@@ABVCPoint@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_nTemp$1$ = 12						; size = 4
_point1$ = 12						; size = 4
_point2$ = 16						; size = 4
?GetHorzLineRegion@CSelectableRegionCalculator@@ABE?AVCRect@@ABVCPoint@@0@Z PROC ; CSelectableRegionCalculator::GetHorzLineRegion, COMDAT
; _this$ = ecx

; 250  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h

; 540  : 	left = l;

  00003	8b 45 0c	 mov	 eax, DWORD PTR _point1$[ebp]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\CoordinateCalculator.cpp

; 253  : 	CRect selectableRegion(point1.x, (point1.y - m_nProximityRange), point2.x, (point1.y + m_nProximityRange +1));

  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	53		 push	 ebx
  00009	56		 push	 esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h

; 540  : 	left = l;

  0000a	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  0000d	8b 10		 mov	 edx, DWORD PTR [eax]
  0000f	89 55 0c	 mov	 DWORD PTR _nTemp$1$[ebp], edx
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\CoordinateCalculator.cpp

; 250  : {

  00012	57		 push	 edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h

; 540  : 	left = l;

  00013	89 16		 mov	 DWORD PTR [esi], edx
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\CoordinateCalculator.cpp

; 253  : 	CRect selectableRegion(point1.x, (point1.y - m_nProximityRange), point2.x, (point1.y + m_nProximityRange +1));

  00015	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00018	8b fa		 mov	 edi, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h

; 542  : 	right = r;

  0001a	8b 45 10	 mov	 eax, DWORD PTR _point2$[ebp]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\CoordinateCalculator.cpp

; 253  : 	CRect selectableRegion(point1.x, (point1.y - m_nProximityRange), point2.x, (point1.y + m_nProximityRange +1));

  0001d	2b f9		 sub	 edi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h

; 541  : 	top = t;

  0001f	89 7e 04	 mov	 DWORD PTR [esi+4], edi

; 542  : 	right = r;

  00022	8b 18		 mov	 ebx, DWORD PTR [eax]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\CoordinateCalculator.cpp

; 253  : 	CRect selectableRegion(point1.x, (point1.y - m_nProximityRange), point2.x, (point1.y + m_nProximityRange +1));

  00024	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h

; 884  : 	if (left > right)

  00027	8b 4d 0c	 mov	 ecx, DWORD PTR _nTemp$1$[ebp]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\CoordinateCalculator.cpp

; 253  : 	CRect selectableRegion(point1.x, (point1.y - m_nProximityRange), point2.x, (point1.y + m_nProximityRange +1));

  0002a	03 c2		 add	 eax, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h

; 542  : 	right = r;

  0002c	89 5e 08	 mov	 DWORD PTR [esi+8], ebx

; 543  : 	bottom = b;

  0002f	89 46 0c	 mov	 DWORD PTR [esi+12], eax

; 884  : 	if (left > right)

  00032	3b cb		 cmp	 ecx, ebx
  00034	7e 05		 jle	 SHORT $LN6@GetHorzLin

; 885  : 	{
; 886  : 		nTemp = left;
; 887  : 		left = right;

  00036	89 1e		 mov	 DWORD PTR [esi], ebx

; 888  : 		right = nTemp;

  00038	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
$LN6@GetHorzLin:

; 889  : 	}
; 890  : 	if (top > bottom)

  0003b	3b f8		 cmp	 edi, eax
  0003d	7e 06		 jle	 SHORT $LN9@GetHorzLin

; 891  : 	{
; 892  : 		nTemp = top;
; 893  : 		top = bottom;

  0003f	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 894  : 		bottom = nTemp;

  00042	89 7e 0c	 mov	 DWORD PTR [esi+12], edi
$LN9@GetHorzLin:
  00045	5f		 pop	 edi
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\CoordinateCalculator.cpp

; 257  : }

  00046	8b c6		 mov	 eax, esi
  00048	5e		 pop	 esi
  00049	5b		 pop	 ebx
  0004a	5d		 pop	 ebp
  0004b	c2 0c 00	 ret	 12			; 0000000cH
?GetHorzLineRegion@CSelectableRegionCalculator@@ABE?AVCRect@@ABVCPoint@@0@Z ENDP ; CSelectableRegionCalculator::GetHorzLineRegion
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\CoordinateCalculator.cpp
;	COMDAT ?IsPointInCircle@CSelectableRegionCalculator@@QBE_NABVCPoint@@H0@Z
_TEXT	SEGMENT
tv172 = -16						; size = 8
tv171 = -8						; size = 8
_origin$ = 8						; size = 4
_nRadius$ = 12						; size = 4
_point$ = 16						; size = 4
?IsPointInCircle@CSelectableRegionCalculator@@QBE_NABVCPoint@@H0@Z PROC ; CSelectableRegionCalculator::IsPointInCircle, COMDAT
; _this$ = ecx

; 242  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	66 0f 6e 45 0c	 movd	 xmm0, DWORD PTR _nRadius$[ebp]

; 243  : 	return (pow(nRadius, 2) >= (pow(origin.x - point.x, 2) + pow(origin.y - point.y, 2)));

  0000b	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@4000000000000000
  00013	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00017	56		 push	 esi
  00018	57		 push	 edi
  00019	e8 00 00 00 00	 call	 __libm_sse2_pow_precise
  0001e	8b 7d 08	 mov	 edi, DWORD PTR _origin$[ebp]
  00021	8b 75 10	 mov	 esi, DWORD PTR _point$[ebp]
  00024	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@4000000000000000
  0002c	f2 0f 11 45 f0	 movsd	 QWORD PTR tv172[ebp], xmm0
  00031	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00034	2b 46 04	 sub	 eax, DWORD PTR [esi+4]
  00037	66 0f 6e c0	 movd	 xmm0, eax
  0003b	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  0003f	e8 00 00 00 00	 call	 __libm_sse2_pow_precise
  00044	8b 07		 mov	 eax, DWORD PTR [edi]
  00046	2b 06		 sub	 eax, DWORD PTR [esi]
  00048	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@4000000000000000
  00050	f2 0f 11 45 f8	 movsd	 QWORD PTR tv171[ebp], xmm0
  00055	66 0f 6e c0	 movd	 xmm0, eax
  00059	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  0005d	e8 00 00 00 00	 call	 __libm_sse2_pow_precise
  00062	f2 0f 10 4d f8	 movsd	 xmm1, QWORD PTR tv171[ebp]
  00067	f2 0f 58 c8	 addsd	 xmm1, xmm0
  0006b	f2 0f 10 45 f0	 movsd	 xmm0, QWORD PTR tv172[ebp]
  00070	5f		 pop	 edi
  00071	5e		 pop	 esi
  00072	66 0f 2f c1	 comisd	 xmm0, xmm1
  00076	0f 93 c0	 setae	 al

; 244  : }

  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c2 0c 00	 ret	 12			; 0000000cH
?IsPointInCircle@CSelectableRegionCalculator@@QBE_NABVCPoint@@H0@Z ENDP ; CSelectableRegionCalculator::IsPointInCircle
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\CoordinateCalculator.cpp
;	COMDAT ?IsPointInCircle@CSelectableRegionCalculator@@QBE_NABVCPoint@@0@Z
_TEXT	SEGMENT
tv173 = -16						; size = 8
tv172 = -8						; size = 8
_origin$ = 8						; size = 4
_point$ = 12						; size = 4
?IsPointInCircle@CSelectableRegionCalculator@@QBE_NABVCPoint@@0@Z PROC ; CSelectableRegionCalculator::IsPointInCircle, COMDAT
; _this$ = ecx

; 237  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 238  : 	return (pow(m_nProximityRange*2, 2) >= (pow(origin.x - point.x, 2) + pow(origin.y - point.y, 2)));

  00006	8b 01		 mov	 eax, DWORD PTR [ecx]
  00008	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@4000000000000000
  00010	03 c0		 add	 eax, eax
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	66 0f 6e c0	 movd	 xmm0, eax
  00018	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  0001c	e8 00 00 00 00	 call	 __libm_sse2_pow_precise
  00021	8b 7d 08	 mov	 edi, DWORD PTR _origin$[ebp]
  00024	8b 75 0c	 mov	 esi, DWORD PTR _point$[ebp]
  00027	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@4000000000000000
  0002f	f2 0f 11 45 f0	 movsd	 QWORD PTR tv173[ebp], xmm0
  00034	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00037	2b 46 04	 sub	 eax, DWORD PTR [esi+4]
  0003a	66 0f 6e c0	 movd	 xmm0, eax
  0003e	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00042	e8 00 00 00 00	 call	 __libm_sse2_pow_precise
  00047	8b 07		 mov	 eax, DWORD PTR [edi]
  00049	2b 06		 sub	 eax, DWORD PTR [esi]
  0004b	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@4000000000000000
  00053	f2 0f 11 45 f8	 movsd	 QWORD PTR tv172[ebp], xmm0
  00058	66 0f 6e c0	 movd	 xmm0, eax
  0005c	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00060	e8 00 00 00 00	 call	 __libm_sse2_pow_precise
  00065	f2 0f 10 4d f8	 movsd	 xmm1, QWORD PTR tv172[ebp]
  0006a	f2 0f 58 c8	 addsd	 xmm1, xmm0
  0006e	f2 0f 10 45 f0	 movsd	 xmm0, QWORD PTR tv173[ebp]
  00073	5f		 pop	 edi
  00074	5e		 pop	 esi
  00075	66 0f 2f c1	 comisd	 xmm0, xmm1
  00079	0f 93 c0	 setae	 al

; 239  : }

  0007c	8b e5		 mov	 esp, ebp
  0007e	5d		 pop	 ebp
  0007f	c2 08 00	 ret	 8
?IsPointInCircle@CSelectableRegionCalculator@@QBE_NABVCPoint@@0@Z ENDP ; CSelectableRegionCalculator::IsPointInCircle
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\CoordinateCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\CoordinateCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\CoordinateCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin1.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin1.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin1.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin1.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin1.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\CoordinateCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin1.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin1.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin1.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin1.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin1.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\CoordinateCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\CoordinateCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\CoordinateCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin1.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\CoordinateCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin1.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\CoordinateCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin1.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\CoordinateCalculator.cpp
;	COMDAT ?GetLineRegion@CSelectableRegionCalculator@@QBEXABVCPoint@@0AAVCRgn@@@Z
_TEXT	SEGMENT
_region$GSCopy$1$ = -76					; size = 4
_x$1$ = -72						; size = 8
$T3$sroa$493$1$ = -72					; size = 4
_this$GSCopy$1$ = -72					; size = 4
_initY$1$ = -64						; size = 4
tv893 = -64						; size = 8
tv874 = -64						; size = 4
_point1$GSCopy$1$ = -52					; size = 4
_lineAngle$1$ = -48					; size = 8
$T1$sroa$497$1$ = -48					; size = 4
_point2$GSCopy$1$ = -40					; size = 4
_selectableRegionPoints$5 = -36				; size = 32
__$ArrayPad$ = -4					; size = 4
_point1$ = 8						; size = 4
_point2$ = 12						; size = 4
_region$ = 16						; size = 4
?GetLineRegion@CSelectableRegionCalculator@@QBEXABVCPoint@@0AAVCRgn@@@Z PROC ; CSelectableRegionCalculator::GetLineRegion, COMDAT
; _this$ = ecx

; 219  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 50	 sub	 esp, 80			; 00000050H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c4		 xor	 eax, esp
  00010	89 44 24 4c	 mov	 DWORD PTR __$ArrayPad$[esp+80], eax
  00014	8b 45 08	 mov	 eax, DWORD PTR _point1$[ebp]
  00017	8b 55 0c	 mov	 edx, DWORD PTR _point2$[ebp]
  0001a	89 4c 24 08	 mov	 DWORD PTR _this$GSCopy$1$[esp+80], ecx
  0001e	8b 4d 10	 mov	 ecx, DWORD PTR _region$[ebp]
  00021	56		 push	 esi

; 220  : 	// 수평선
; 221  : 	if(point1.y == point2.y){

  00022	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  00025	57		 push	 edi
  00026	8b 78 04	 mov	 edi, DWORD PTR [eax+4]
  00029	89 44 24 24	 mov	 DWORD PTR _point1$GSCopy$1$[esp+88], eax
  0002d	89 4c 24 0c	 mov	 DWORD PTR _region$GSCopy$1$[esp+88], ecx
  00031	8b 08		 mov	 ecx, DWORD PTR [eax]
  00033	8b 44 24 10	 mov	 eax, DWORD PTR _this$GSCopy$1$[esp+88]
  00037	89 54 24 30	 mov	 DWORD PTR _point2$GSCopy$1$[esp+88], edx
  0003b	89 4c 24 18	 mov	 DWORD PTR tv874[esp+88], ecx
  0003f	8b 00		 mov	 eax, DWORD PTR [eax]
  00041	3b fe		 cmp	 edi, esi
  00043	75 3b		 jne	 SHORT $LN2@GetLineReg

; 253  : 	CRect selectableRegion(point1.x, (point1.y - m_nProximityRange), point2.x, (point1.y + m_nProximityRange +1));

  00045	8b 4c 24 24	 mov	 ecx, DWORD PTR _point1$GSCopy$1$[esp+88]
  00049	8b f7		 mov	 esi, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h

; 541  : 	top = t;

  0004b	8b 3a		 mov	 edi, DWORD PTR [edx]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\CoordinateCalculator.cpp

; 253  : 	CRect selectableRegion(point1.x, (point1.y - m_nProximityRange), point2.x, (point1.y + m_nProximityRange +1));

  0004d	2b f0		 sub	 esi, eax
  0004f	40		 inc	 eax
  00050	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h

; 890  : 	if (top > bottom)

  00053	8b 4c 24 18	 mov	 ecx, DWORD PTR tv874[esp+88]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\CoordinateCalculator.cpp

; 253  : 	CRect selectableRegion(point1.x, (point1.y - m_nProximityRange), point2.x, (point1.y + m_nProximityRange +1));

  00057	03 d0		 add	 edx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin1.inl

; 268  : 	{ return Attach(::CreateRectRgn(x1, y1, x2, y2)); }

  00059	3b f2		 cmp	 esi, edx
  0005b	8b c6		 mov	 eax, esi
  0005d	0f 4e c2	 cmovle	 eax, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h

; 890  : 	if (top > bottom)

  00060	3b cf		 cmp	 ecx, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin1.inl

; 268  : 	{ return Attach(::CreateRectRgn(x1, y1, x2, y2)); }

  00062	50		 push	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h

; 890  : 	if (top > bottom)

  00063	8b c1		 mov	 eax, ecx
  00065	0f 4e c7	 cmovle	 eax, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin1.inl

; 268  : 	{ return Attach(::CreateRectRgn(x1, y1, x2, y2)); }

  00068	3b f2		 cmp	 esi, edx
  0006a	50		 push	 eax
  0006b	0f 4e d6	 cmovle	 edx, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h

; 890  : 	if (top > bottom)

  0006e	3b cf		 cmp	 ecx, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin1.inl

; 268  : 	{ return Attach(::CreateRectRgn(x1, y1, x2, y2)); }

  00070	52		 push	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h

; 890  : 	if (top > bottom)

  00071	0f 4e f9	 cmovle	 edi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin1.inl

; 268  : 	{ return Attach(::CreateRectRgn(x1, y1, x2, y2)); }

  00074	57		 push	 edi
  00075	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateRectRgn@16
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\CoordinateCalculator.cpp

; 224  : 	}

  0007b	e9 65 01 00 00	 jmp	 $LN55@GetLineReg
$LN2@GetLineReg:

; 225  : 	// 수직선
; 226  : 	else if(point1.x == point2.x){

  00080	8b 12		 mov	 edx, DWORD PTR [edx]
  00082	3b ca		 cmp	 ecx, edx
  00084	75 2e		 jne	 SHORT $LN4@GetLineReg

; 264  : 	CRect selectableRegion((point1.x - m_nProximityRange), point1.y, (point1.x + m_nProximityRange +1), point2.y);

  00086	8b d1		 mov	 edx, ecx
  00088	2b d0		 sub	 edx, eax
  0008a	40		 inc	 eax
  0008b	03 c8		 add	 ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin1.inl

; 268  : 	{ return Attach(::CreateRectRgn(x1, y1, x2, y2)); }

  0008d	3b fe		 cmp	 edi, esi
  0008f	8b c7		 mov	 eax, edi
  00091	0f 4e c6	 cmovle	 eax, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h

; 890  : 	if (top > bottom)

  00094	3b d1		 cmp	 edx, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin1.inl

; 268  : 	{ return Attach(::CreateRectRgn(x1, y1, x2, y2)); }

  00096	50		 push	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h

; 890  : 	if (top > bottom)

  00097	8b c2		 mov	 eax, edx
  00099	0f 4e c1	 cmovle	 eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin1.inl

; 268  : 	{ return Attach(::CreateRectRgn(x1, y1, x2, y2)); }

  0009c	3b fe		 cmp	 edi, esi
  0009e	50		 push	 eax
  0009f	0f 4e f7	 cmovle	 esi, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h

; 890  : 	if (top > bottom)

  000a2	3b d1		 cmp	 edx, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin1.inl

; 268  : 	{ return Attach(::CreateRectRgn(x1, y1, x2, y2)); }

  000a4	56		 push	 esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h

; 890  : 	if (top > bottom)

  000a5	0f 4e ca	 cmovle	 ecx, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin1.inl

; 268  : 	{ return Attach(::CreateRectRgn(x1, y1, x2, y2)); }

  000a8	51		 push	 ecx
  000a9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateRectRgn@16
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\CoordinateCalculator.cpp

; 229  : 	}

  000af	e9 31 01 00 00	 jmp	 $LN55@GetLineReg
$LN4@GetLineReg:
  000b4	0f 57 c0	 xorps	 xmm0, xmm0

; 320  : 	return ((double)(point2.y - point1.y) / (double)(point2.x - point1.x));

  000b7	2b d1		 sub	 edx, ecx
  000b9	2b f7		 sub	 esi, edi
  000bb	0f 57 c9	 xorps	 xmm1, xmm1
  000be	f2 0f 2a c2	 cvtsi2sd xmm0, edx
  000c2	f2 0f 2a ce	 cvtsi2sd xmm1, esi
  000c6	f2 0f 5e c8	 divsd	 xmm1, xmm0

; 328  : 	return (-1.0/dAngle);

  000ca	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@bff0000000000000
  000d2	f2 0f 5e c1	 divsd	 xmm0, xmm1

; 309  : 	x = sqrt(fabs(pow(m_nProximityRange, 2) / (pow(lineAngle, 2) +1)));

  000d6	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@4000000000000000

; 328  : 	return (-1.0/dAngle);

  000de	f2 0f 11 44 24
	28		 movsd	 QWORD PTR _lineAngle$1$[esp+88], xmm0
  000e4	0f 57 c0	 xorps	 xmm0, xmm0

; 309  : 	x = sqrt(fabs(pow(m_nProximityRange, 2) / (pow(lineAngle, 2) +1)));

  000e7	f2 0f 2a c0	 cvtsi2sd xmm0, eax
  000eb	e8 00 00 00 00	 call	 __libm_sse2_pow_precise
  000f0	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@4000000000000000
  000f8	f2 0f 11 44 24
	18		 movsd	 QWORD PTR tv893[esp+88], xmm0
  000fe	f2 0f 10 44 24
	28		 movsd	 xmm0, QWORD PTR _lineAngle$1$[esp+88]
  00104	e8 00 00 00 00	 call	 __libm_sse2_pow_precise
  00109	f2 0f 58 05 00
	00 00 00	 addsd	 xmm0, QWORD PTR __real@3ff0000000000000
  00111	f2 0f 10 54 24
	18		 movsd	 xmm2, QWORD PTR tv893[esp+88]
  00117	0f 57 c9	 xorps	 xmm1, xmm1
  0011a	f2 0f 5e d0	 divsd	 xmm2, xmm0
  0011e	0f 54 15 00 00
	00 00		 andps	 xmm2, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
  00125	0f 28 c2	 movaps	 xmm0, xmm2
  00128	66 0f 2e c8	 ucomisd xmm1, xmm0
  0012c	77 06		 ja	 SHORT $LN53@GetLineReg
  0012e	f2 0f 51 c0	 sqrtsd	 xmm0, xmm0
  00132	eb 05		 jmp	 SHORT $LN54@GetLineReg
$LN53@GetLineReg:
  00134	e8 00 00 00 00	 call	 __libm_sse2_sqrt_precise
$LN54@GetLineReg:

; 311  : 	selectableRegionPt1 = CPoint(CMath::Round(x), CMath::Round(lineAngle * x));

  00139	0f 28 c8	 movaps	 xmm1, xmm0
  0013c	f2 0f 11 44 24
	10		 movsd	 QWORD PTR _x$1$[esp+88], xmm0
  00142	f2 0f 59 4c 24
	28		 mulsd	 xmm1, QWORD PTR _lineAngle$1$[esp+88]
  00148	83 ec 08	 sub	 esp, 8
  0014b	f2 0f 11 0c 24	 movsd	 QWORD PTR [esp], xmm1
  00150	e8 00 00 00 00	 call	 ?Round@CMath@@SAHN@Z	; CMath::Round
  00155	f2 0f 10 44 24
	18		 movsd	 xmm0, QWORD PTR _x$1$[esp+96]
  0015b	8b f0		 mov	 esi, eax
  0015d	89 74 24 20	 mov	 DWORD PTR _initY$1$[esp+96], esi
  00161	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00166	e8 00 00 00 00	 call	 ?Round@CMath@@SAHN@Z	; CMath::Round
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h

; 408  : 	x = initX;

  0016b	8b c8		 mov	 ecx, eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\CoordinateCalculator.cpp

; 312  : 	selectableRegionPt2 = CPoint(-selectableRegionPt1.x, -selectableRegionPt1.y);

  0016d	f7 de		 neg	 esi

; 293  : 	movePoint.x = origin.x + point.x;

  0016f	8b 44 24 2c	 mov	 eax, DWORD PTR _point1$GSCopy$1$[esp+96]

; 312  : 	selectableRegionPt2 = CPoint(-selectableRegionPt1.x, -selectableRegionPt1.y);

  00173	8b f9		 mov	 edi, ecx
  00175	89 74 24 18	 mov	 DWORD PTR $T3$sroa$493$1$[esp+96], esi
  00179	f7 df		 neg	 edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h

; 408  : 	x = initX;

  0017b	89 4c 24 30	 mov	 DWORD PTR $T1$sroa$497$1$[esp+96], ecx
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\CoordinateCalculator.cpp

; 311  : 	selectableRegionPt1 = CPoint(CMath::Round(x), CMath::Round(lineAngle * x));

  0017f	83 c4 08	 add	 esp, 8

; 293  : 	movePoint.x = origin.x + point.x;

  00182	8b 30		 mov	 esi, DWORD PTR [eax]
  00184	03 ce		 add	 ecx, esi

; 294  : 	movePoint.y = origin.y + point.y;

  00186	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00189	8b 44 24 18	 mov	 eax, DWORD PTR _initY$1$[esp+88]
  0018d	03 c2		 add	 eax, edx

; 280  : 	selectableRegionPoints[0] = GetPointOnMovedOrigin(point1, basePt1);

  0018f	89 4c 24 34	 mov	 DWORD PTR _selectableRegionPoints$5[esp+88], ecx
  00193	89 44 24 38	 mov	 DWORD PTR _selectableRegionPoints$5[esp+92], eax

; 293  : 	movePoint.x = origin.x + point.x;

  00197	8d 0c 3e	 lea	 ecx, DWORD PTR [esi+edi]

; 294  : 	movePoint.y = origin.y + point.y;

  0019a	8b 44 24 10	 mov	 eax, DWORD PTR $T3$sroa$493$1$[esp+88]
  0019e	03 c2		 add	 eax, edx

; 281  : 	selectableRegionPoints[1] = GetPointOnMovedOrigin(point1, basePt2);

  001a0	89 4c 24 3c	 mov	 DWORD PTR _selectableRegionPoints$5[esp+96], ecx

; 293  : 	movePoint.x = origin.x + point.x;

  001a4	8b 54 24 30	 mov	 edx, DWORD PTR _point2$GSCopy$1$[esp+88]

; 281  : 	selectableRegionPoints[1] = GetPointOnMovedOrigin(point1, basePt2);

  001a8	89 44 24 40	 mov	 DWORD PTR _selectableRegionPoints$5[esp+100], eax

; 294  : 	movePoint.y = origin.y + point.y;

  001ac	8b 44 24 10	 mov	 eax, DWORD PTR $T3$sroa$493$1$[esp+88]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin1.inl

; 276  : 	{ return Attach(::CreatePolygonRgn(lpPoints, nCount, nMode)); }

  001b0	6a 01		 push	 1
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\CoordinateCalculator.cpp

; 293  : 	movePoint.x = origin.x + point.x;

  001b2	8b 32		 mov	 esi, DWORD PTR [edx]

; 294  : 	movePoint.y = origin.y + point.y;

  001b4	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  001b7	03 c2		 add	 eax, edx

; 282  : 	selectableRegionPoints[2] = GetPointOnMovedOrigin(point2, basePt2);

  001b9	89 44 24 4c	 mov	 DWORD PTR _selectableRegionPoints$5[esp+112], eax

; 294  : 	movePoint.y = origin.y + point.y;

  001bd	8b 44 24 1c	 mov	 eax, DWORD PTR _initY$1$[esp+92]

; 293  : 	movePoint.x = origin.x + point.x;

  001c1	8d 0c 3e	 lea	 ecx, DWORD PTR [esi+edi]

; 294  : 	movePoint.y = origin.y + point.y;

  001c4	03 c2		 add	 eax, edx

; 282  : 	selectableRegionPoints[2] = GetPointOnMovedOrigin(point2, basePt2);

  001c6	89 4c 24 48	 mov	 DWORD PTR _selectableRegionPoints$5[esp+108], ecx

; 293  : 	movePoint.x = origin.x + point.x;

  001ca	8b 4c 24 2c	 mov	 ecx, DWORD PTR $T1$sroa$497$1$[esp+92]

; 283  : 	selectableRegionPoints[3] = GetPointOnMovedOrigin(point2, basePt1);

  001ce	89 44 24 54	 mov	 DWORD PTR _selectableRegionPoints$5[esp+120], eax

; 293  : 	movePoint.x = origin.x + point.x;

  001d2	03 ce		 add	 ecx, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin1.inl

; 276  : 	{ return Attach(::CreatePolygonRgn(lpPoints, nCount, nMode)); }

  001d4	6a 04		 push	 4
  001d6	8d 44 24 3c	 lea	 eax, DWORD PTR _selectableRegionPoints$5[esp+96]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\CoordinateCalculator.cpp

; 283  : 	selectableRegionPoints[3] = GetPointOnMovedOrigin(point2, basePt1);

  001da	89 4c 24 54	 mov	 DWORD PTR _selectableRegionPoints$5[esp+120], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin1.inl

; 276  : 	{ return Attach(::CreatePolygonRgn(lpPoints, nCount, nMode)); }

  001de	50		 push	 eax
  001df	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreatePolygonRgn@12
$LN55@GetLineReg:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\CoordinateCalculator.cpp

; 233  : }

  001e5	8b 4c 24 0c	 mov	 ecx, DWORD PTR _region$GSCopy$1$[esp+88]
  001e9	50		 push	 eax
  001ea	e8 00 00 00 00	 call	 ?Attach@CGdiObject@@QAEHPAX@Z ; CGdiObject::Attach
  001ef	8b 4c 24 54	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+88]
  001f3	5f		 pop	 edi
  001f4	5e		 pop	 esi
  001f5	33 cc		 xor	 ecx, esp
  001f7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001fc	8b e5		 mov	 esp, ebp
  001fe	5d		 pop	 ebp
  001ff	c2 0c 00	 ret	 12			; 0000000cH
?GetLineRegion@CSelectableRegionCalculator@@QBEXABVCPoint@@0AAVCRgn@@@Z ENDP ; CSelectableRegionCalculator::GetLineRegion
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\CoordinateCalculator.cpp
;	COMDAT ?GetProximityRange@CSelectableRegionCalculator@@QBEHXZ
_TEXT	SEGMENT
?GetProximityRange@CSelectableRegionCalculator@@QBEHXZ PROC ; CSelectableRegionCalculator::GetProximityRange, COMDAT
; _this$ = ecx

; 214  : 	return m_nProximityRange;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 215  : }

  00002	c3		 ret	 0
?GetProximityRange@CSelectableRegionCalculator@@QBEHXZ ENDP ; CSelectableRegionCalculator::GetProximityRange
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\CoordinateCalculator.cpp
;	COMDAT ??0CSelectableRegionCalculator@@QAE@XZ
_TEXT	SEGMENT
??0CSelectableRegionCalculator@@QAE@XZ PROC		; CSelectableRegionCalculator::CSelectableRegionCalculator, COMDAT
; _this$ = ecx

; 207  : 	m_nProximityRange(4)

  00000	c7 01 04 00 00
	00		 mov	 DWORD PTR [ecx], 4

; 209  : }

  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0CSelectableRegionCalculator@@QAE@XZ ENDP		; CSelectableRegionCalculator::CSelectableRegionCalculator
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\CoordinateCalculator.cpp
;	COMDAT ?GetDisplayDataCurrentIndex@CCoordinateCalculator@@ABEHPAUIPacket133101@@H@Z
_TEXT	SEGMENT
_pPacket$ = 8						; size = 4
_nData$ = 12						; size = 4
?GetDisplayDataCurrentIndex@CCoordinateCalculator@@ABEHPAUIPacket133101@@H@Z PROC ; CCoordinateCalculator::GetDisplayDataCurrentIndex, COMDAT
; _this$ = ecx

; 195  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 196  : 	if(pPacket == NULL)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _pPacket$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	75 07		 jne	 SHORT $LN2@GetDisplay

; 197  : 		return -1;

  0000a	83 c8 ff	 or	 eax, -1

; 200  : }

  0000d	5d		 pop	 ebp
  0000e	c2 08 00	 ret	 8
$LN2@GetDisplay:
  00011	66 0f 6e 45 0c	 movd	 xmm0, DWORD PTR _nData$[ebp]

; 198  : 	
; 199  : 	return pPacket->GetIndexFromData(nData);

  00016	83 ec 08	 sub	 esp, 8
  00019	8b 01		 mov	 eax, DWORD PTR [ecx]
  0001b	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  0001f	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00024	ff 50 34	 call	 DWORD PTR [eax+52]

; 200  : }

  00027	5d		 pop	 ebp
  00028	c2 08 00	 ret	 8
?GetDisplayDataCurrentIndex@CCoordinateCalculator@@ABEHPAUIPacket133101@@H@Z ENDP ; CCoordinateCalculator::GetDisplayDataCurrentIndex
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\CoordinateCalculator.cpp
;	COMDAT ?IsCalculator@CCoordinateCalculator@@ABE_NPAUIPacket133101@@@Z
_TEXT	SEGMENT
_pPacket$ = 8						; size = 4
?IsCalculator@CCoordinateCalculator@@ABE_NPAUIPacket133101@@@Z PROC ; CCoordinateCalculator::IsCalculator, COMDAT
; _this$ = ecx

; 189  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 190  : 	return (pPacket != NULL && pPacket->GetDataCount() > 0);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _pPacket$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 0f		 je	 SHORT $LN3@IsCalculat
  0000a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000c	ff 50 2c	 call	 DWORD PTR [eax+44]
  0000f	85 c0		 test	 eax, eax
  00011	7e 06		 jle	 SHORT $LN3@IsCalculat
  00013	b0 01		 mov	 al, 1

; 191  : }

  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
$LN3@IsCalculat:

; 190  : 	return (pPacket != NULL && pPacket->GetDataCount() > 0);

  00019	32 c0		 xor	 al, al

; 191  : }

  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
?IsCalculator@CCoordinateCalculator@@ABE_NPAUIPacket133101@@@Z ENDP ; CCoordinateCalculator::IsCalculator
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\CoordinateCalculator.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Include_Analysis\CoordinateCalculatorData.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\CoordinateCalculator.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Include_Analysis\CoordinateCalculatorData.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\CoordinateCalculator.cpp
;	COMDAT ?GetData_X@CCoordinateCalculator@@QBENABVCCoordinateCalculatorData@@ABVCPoint@@H@Z
_TEXT	SEGMENT
_dReturn$ = -12						; size = 8
_nBlockColumn$ = -8					; size = 4
_nCenter_x$ = -4					; size = 4
_nCol$ = 8						; size = 4
_calData$ = 8						; size = 4
_nRow$ = 12						; size = 4
_point$ = 12						; size = 4
___formal$ = 16						; size = 4
?GetData_X@CCoordinateCalculator@@QBENABVCCoordinateCalculatorData@@ABVCPoint@@H@Z PROC ; CCoordinateCalculator::GetData_X, COMDAT
; _this$ = ecx

; 175  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	57		 push	 edi
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Include_Analysis\CoordinateCalculatorData.h

; 128  : 							{	return m_pIChartManager && m_pIChartOCX && m_pIPacketListManager && m_pIDefaultPacketManager;	}

  00007	8b 7d 08	 mov	 edi, DWORD PTR _calData$[ebp]
  0000a	0f 57 c0	 xorps	 xmm0, xmm0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\CoordinateCalculator.cpp

; 178  : 	double dReturn = 0;

  0000d	f2 0f 11 45 f4	 movsd	 QWORD PTR _dReturn$[ebp], xmm0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Include_Analysis\CoordinateCalculatorData.h

; 128  : 							{	return m_pIChartManager && m_pIChartOCX && m_pIPacketListManager && m_pIDefaultPacketManager;	}

  00012	8b 4f 48	 mov	 ecx, DWORD PTR [edi+72]
  00015	85 c9		 test	 ecx, ecx
  00017	74 52		 je	 SHORT $LN9@GetData_X
  00019	83 7f 4c 00	 cmp	 DWORD PTR [edi+76], 0
  0001d	74 4c		 je	 SHORT $LN9@GetData_X
  0001f	83 7f 50 00	 cmp	 DWORD PTR [edi+80], 0
  00023	74 46		 je	 SHORT $LN9@GetData_X
  00025	83 7f 54 00	 cmp	 DWORD PTR [edi+84], 0
  00029	74 40		 je	 SHORT $LN9@GetData_X
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\CoordinateCalculator.cpp

; 181  : 		calData.m_pIChartManager->GetBlockIndex(point, nRow, nCol);

  0002b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0002d	8d 55 08	 lea	 edx, DWORD PTR _nCol$[ebp]
  00030	56		 push	 esi
  00031	8b 75 0c	 mov	 esi, DWORD PTR _point$[ebp]
  00034	52		 push	 edx
  00035	8d 55 0c	 lea	 edx, DWORD PTR _nRow$[ebp]
  00038	52		 push	 edx
  00039	ff 76 04	 push	 DWORD PTR [esi+4]
  0003c	ff 36		 push	 DWORD PTR [esi]
  0003e	ff 90 8c 00 00
	00		 call	 DWORD PTR [eax+140]

; 182  : 		dReturn = calData.m_pIChartManager->GetDoubleFromX(nRow, nCol, point.x, &nBlockColumn, nCenter_x);

  00044	8b 4f 48	 mov	 ecx, DWORD PTR [edi+72]
  00047	8d 55 fc	 lea	 edx, DWORD PTR _nCenter_x$[ebp]
  0004a	6a 00		 push	 0
  0004c	52		 push	 edx
  0004d	8d 55 f8	 lea	 edx, DWORD PTR _nBlockColumn$[ebp]
  00050	8b 01		 mov	 eax, DWORD PTR [ecx]
  00052	52		 push	 edx
  00053	ff 36		 push	 DWORD PTR [esi]
  00055	ff 75 08	 push	 DWORD PTR _nCol$[ebp]
  00058	8b 80 10 01 00
	00		 mov	 eax, DWORD PTR [eax+272]
  0005e	ff 75 0c	 push	 DWORD PTR _nRow$[ebp]
  00061	ff d0		 call	 eax

; 183  : 	}
; 184  : 	return dReturn;

  00063	5e		 pop	 esi
  00064	5f		 pop	 edi

; 185  : }

  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c2 0c 00	 ret	 12			; 0000000cH
$LN9@GetData_X:
  0006b	dd 45 f4	 fld	 QWORD PTR _dReturn$[ebp]
  0006e	5f		 pop	 edi
  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c2 0c 00	 ret	 12			; 0000000cH
?GetData_X@CCoordinateCalculator@@QBENABVCCoordinateCalculatorData@@ABVCPoint@@H@Z ENDP ; CCoordinateCalculator::GetData_X
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\CoordinateCalculator.cpp
;	COMDAT ?GetGap@CCoordinateCalculator@@QBE?AVCCoordinate@@ABVCCoordinateCalculatorData@@ABVCPoint@@1@Z
_TEXT	SEGMENT
$T1 = -144						; size = 24
$T2 = -144						; size = 24
_AbsolutePt1$3 = -120					; size = 24
_AbsolutePt2$4 = -96					; size = 24
_relativePt1$5 = -72					; size = 24
_relativePt2$6 = -48					; size = 24
$T7 = -24						; size = 8
$T8 = -24						; size = 8
$T9 = -16						; size = 8
$T10 = -16						; size = 8
$T11 = -16						; size = 8
$T12 = -16						; size = 8
tv181 = -8						; size = 8
tv132 = -8						; size = 8
_this$1$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_calData$ = 12						; size = 4
_point1$ = 16						; size = 4
_point2$ = 20						; size = 4
?GetGap@CCoordinateCalculator@@QBE?AVCCoordinate@@ABVCCoordinateCalculatorData@@ABVCPoint@@1@Z PROC ; CCoordinateCalculator::GetGap, COMDAT
; _this$ = ecx

; 123  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 90 00 00
	00		 sub	 esp, 144		; 00000090H
  00009	53		 push	 ebx
  0000a	56		 push	 esi

; 124  : //	CCoordinate cdResult;
; 125  : //	// packet 이 없을 경우엔 그냥 좌표로 한다!!
; 126  : //	IPacket *pIPacket = calData.GetPacket_X();
; 127  : //	if(!IsCalculator( pIPacket)) cdResult = CCoordinate((double)(point2.x - point1.x), (double)(point2.y - point1.y));
; 128  : //	else
; 129  : //	{
; 130  : //		CCoordinate relativePt1 = AbsoluteToRelative(calData, point1);
; 131  : //		CCoordinate relativePt2 = AbsoluteToRelative(calData, point2);
; 132  : //		int nIndex = GetDisplayDataCurrentIndex( pIPacket, (int)relativePt2.GetX()) - GetDisplayDataCurrentIndex( pIPacket, (int)relativePt1.GetX());
; 133  : //		cdResult = CCoordinate((double)nIndex, (relativePt2.GetY() - relativePt1.GetY()));
; 134  : //	}
; 135  : //	if( pIPacket) pIPacket->Release();
; 136  : //	return cdResult;
; 137  : 
; 138  : 	CCoordinate cdResult;

  0000b	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  0000e	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx
  00011	8b ce		 mov	 ecx, esi
  00013	e8 00 00 00 00	 call	 ??0CCoordinate@@QAE@XZ	; CCoordinate::CCoordinate

; 139  : 	// packet 이 없을 경우엔 그냥 좌표로 한다!!
; 140  : 	IPacket *pIPacket = calData.GetPacket_X();

  00018	8b 4d 0c	 mov	 ecx, DWORD PTR _calData$[ebp]
  0001b	e8 00 00 00 00	 call	 ?GetPacket_X@CCoordinateCalculatorData@@QBEPAUIPacket133101@@XZ ; CCoordinateCalculatorData::GetPacket_X
  00020	8b d8		 mov	 ebx, eax

; 190  : 	return (pPacket != NULL && pPacket->GetDataCount() > 0);

  00022	85 db		 test	 ebx, ebx
  00024	0f 84 ba 00 00
	00		 je	 $LN8@GetGap
  0002a	8b 03		 mov	 eax, DWORD PTR [ebx]
  0002c	8b cb		 mov	 ecx, ebx
  0002e	ff 50 2c	 call	 DWORD PTR [eax+44]
  00031	85 c0		 test	 eax, eax
  00033	0f 8e ab 00 00
	00		 jle	 $LN8@GetGap

; 143  : 	else
; 144  : 	{
; 145  : 		// XScale : 관련 Interface로 사용 - vntsorl(20070327)
; 146  : 		CCoordinate AbsolutePt1 = AbsoluteToAbsolute(calData, point1);

  00039	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
  0003c	8d 45 f0	 lea	 eax, DWORD PTR $T11[ebp]
  0003f	57		 push	 edi
  00040	8b 7d 10	 mov	 edi, DWORD PTR _point1$[ebp]
  00043	57		 push	 edi
  00044	ff 75 0c	 push	 DWORD PTR _calData$[ebp]
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 ?AbsoluteToAbsolute@CCoordinateCalculator@@QBE?AVCPoint@@ABVCCoordinateCalculatorData@@ABV2@@Z ; CCoordinateCalculator::AbsoluteToAbsolute
  0004d	50		 push	 eax
  0004e	8d 4d 88	 lea	 ecx, DWORD PTR _AbsolutePt1$3[ebp]
  00051	e8 00 00 00 00	 call	 ??0CCoordinate@@QAE@ABVCPoint@@@Z ; CCoordinate::CCoordinate

; 147  : 		CCoordinate AbsolutePt2 = AbsoluteToAbsolute(calData, point2);

  00056	8b 75 14	 mov	 esi, DWORD PTR _point2$[ebp]
  00059	8d 45 f0	 lea	 eax, DWORD PTR $T10[ebp]
  0005c	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
  0005f	56		 push	 esi
  00060	ff 75 0c	 push	 DWORD PTR _calData$[ebp]
  00063	50		 push	 eax
  00064	e8 00 00 00 00	 call	 ?AbsoluteToAbsolute@CCoordinateCalculator@@QBE?AVCPoint@@ABVCCoordinateCalculatorData@@ABV2@@Z ; CCoordinateCalculator::AbsoluteToAbsolute
  00069	50		 push	 eax
  0006a	8d 4d a0	 lea	 ecx, DWORD PTR _AbsolutePt2$4[ebp]
  0006d	e8 00 00 00 00	 call	 ??0CCoordinate@@QAE@ABVCPoint@@@Z ; CCoordinate::CCoordinate

; 148  : 		CCoordinate relativePt1 = AbsoluteToRelative(calData, point1);

  00072	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
  00075	8d 45 b8	 lea	 eax, DWORD PTR _relativePt1$5[ebp]
  00078	57		 push	 edi
  00079	8b 7d 0c	 mov	 edi, DWORD PTR _calData$[ebp]
  0007c	57		 push	 edi
  0007d	50		 push	 eax
  0007e	e8 00 00 00 00	 call	 ?AbsoluteToRelative@CCoordinateCalculator@@QBE?AVCCoordinate@@ABVCCoordinateCalculatorData@@ABVCPoint@@@Z ; CCoordinateCalculator::AbsoluteToRelative

; 149  : 		CCoordinate relativePt2 = AbsoluteToRelative(calData, point2);

  00083	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
  00086	8d 45 d0	 lea	 eax, DWORD PTR _relativePt2$6[ebp]
  00089	56		 push	 esi
  0008a	57		 push	 edi
  0008b	50		 push	 eax
  0008c	e8 00 00 00 00	 call	 ?AbsoluteToRelative@CCoordinateCalculator@@QBE?AVCCoordinate@@ABVCCoordinateCalculatorData@@ABVCPoint@@@Z ; CCoordinateCalculator::AbsoluteToRelative

; 150  : 		cdResult = CCoordinate((AbsolutePt2.GetX() - AbsolutePt1.GetX()), (relativePt2.GetY() - relativePt1.GetY()), pIPacket->GetBaseTimeDifference());

  00091	8d 4d d0	 lea	 ecx, DWORD PTR _relativePt2$6[ebp]
  00094	e8 00 00 00 00	 call	 ?GetY@CCoordinate@@QBENXZ ; CCoordinate::GetY
  00099	dd 5d f8	 fstp	 QWORD PTR tv181[ebp]
  0009c	8d 4d b8	 lea	 ecx, DWORD PTR _relativePt1$5[ebp]
  0009f	e8 00 00 00 00	 call	 ?GetY@CCoordinate@@QBENXZ ; CCoordinate::GetY
  000a4	dc 6d f8	 fsubr	 QWORD PTR tv181[ebp]
  000a7	8d 4d a0	 lea	 ecx, DWORD PTR _AbsolutePt2$4[ebp]
  000aa	dd 5d e8	 fstp	 QWORD PTR $T7[ebp]
  000ad	e8 00 00 00 00	 call	 ?GetX@CCoordinate@@QBENXZ ; CCoordinate::GetX
  000b2	dd 5d f8	 fstp	 QWORD PTR tv132[ebp]
  000b5	8d 4d 88	 lea	 ecx, DWORD PTR _AbsolutePt1$3[ebp]
  000b8	e8 00 00 00 00	 call	 ?GetX@CCoordinate@@QBENXZ ; CCoordinate::GetX
  000bd	dc 6d f8	 fsubr	 QWORD PTR tv132[ebp]
  000c0	8b 03		 mov	 eax, DWORD PTR [ebx]
  000c2	8b cb		 mov	 ecx, ebx
  000c4	dd 5d f0	 fstp	 QWORD PTR $T9[ebp]
  000c7	ff 50 60	 call	 DWORD PTR [eax+96]
  000ca	50		 push	 eax
  000cb	8d 45 e8	 lea	 eax, DWORD PTR $T7[ebp]
  000ce	50		 push	 eax
  000cf	8d 45 f0	 lea	 eax, DWORD PTR $T9[ebp]
  000d2	50		 push	 eax
  000d3	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  000d9	e8 00 00 00 00	 call	 ??0CCoordinate@@QAE@ABN0H@Z ; CCoordinate::CCoordinate
  000de	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  000e1	5f		 pop	 edi
  000e2	eb 45		 jmp	 SHORT $LN11@GetGap
$LN8@GetGap:

; 141  : 	// 20081007 JS.Kim	사용자시간대 선택
; 142  : 	if( !IsCalculator( pIPacket)) cdResult = CCoordinate((double)(point2.x - point1.x), (double)(point2.y - point1.y), pIPacket->GetBaseTimeDifference());

  000e4	8b 55 14	 mov	 edx, DWORD PTR _point2$[ebp]
  000e7	8b 4d 10	 mov	 ecx, DWORD PTR _point1$[ebp]
  000ea	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000ed	2b 41 04	 sub	 eax, DWORD PTR [ecx+4]
  000f0	66 0f 6e c0	 movd	 xmm0, eax
  000f4	8b 02		 mov	 eax, DWORD PTR [edx]
  000f6	2b 01		 sub	 eax, DWORD PTR [ecx]
  000f8	8b cb		 mov	 ecx, ebx
  000fa	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  000fe	f2 0f 11 45 f0	 movsd	 QWORD PTR $T12[ebp], xmm0
  00103	66 0f 6e c0	 movd	 xmm0, eax
  00107	8b 03		 mov	 eax, DWORD PTR [ebx]
  00109	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  0010d	f2 0f 11 45 e8	 movsd	 QWORD PTR $T8[ebp], xmm0
  00112	ff 50 60	 call	 DWORD PTR [eax+96]
  00115	50		 push	 eax
  00116	8d 45 f0	 lea	 eax, DWORD PTR $T12[ebp]
  00119	50		 push	 eax
  0011a	8d 45 e8	 lea	 eax, DWORD PTR $T8[ebp]
  0011d	50		 push	 eax
  0011e	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  00124	e8 00 00 00 00	 call	 ??0CCoordinate@@QAE@ABN0H@Z ; CCoordinate::CCoordinate
$LN11@GetGap:

; 151  : 	}
; 152  : 	if( pIPacket) pIPacket->Release();

  00129	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  0012c	53		 push	 ebx
  0012d	0f 11 06	 movups	 XMMWORD PTR [esi], xmm0
  00130	f3 0f 7e 40 10	 movq	 xmm0, QWORD PTR [eax+16]
  00135	66 0f d6 46 10	 movq	 QWORD PTR [esi+16], xmm0
  0013a	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0013c	ff 51 08	 call	 DWORD PTR [ecx+8]

; 153  : 	return cdResult;

  0013f	8b c6		 mov	 eax, esi
  00141	5e		 pop	 esi
  00142	5b		 pop	 ebx

; 154  : }

  00143	8b e5		 mov	 esp, ebp
  00145	5d		 pop	 ebp
  00146	c2 10 00	 ret	 16			; 00000010H
?GetGap@CCoordinateCalculator@@QBE?AVCCoordinate@@ABVCCoordinateCalculatorData@@ABVCPoint@@1@Z ENDP ; CCoordinateCalculator::GetGap
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\CoordinateCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\CoordinateCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\CoordinateCalculator.cpp
;	COMDAT ?AbsoluteToAbsolute@CCoordinateCalculator@@QBE?AVCPoint@@ABVCCoordinateCalculatorData@@ABV2@@Z
_TEXT	SEGMENT
_relativePt$1 = -36					; size = 24
_drawingPoint$2 = -12					; size = 8
_this$1$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_calData$ = 12						; size = 4
_point$ = 16						; size = 4
?AbsoluteToAbsolute@CCoordinateCalculator@@QBE?AVCPoint@@ABVCCoordinateCalculatorData@@ABV2@@Z PROC ; CCoordinateCalculator::AbsoluteToAbsolute, COMDAT
; _this$ = ecx

; 107  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	53		 push	 ebx

; 109  : 	IPacket *pIPacket = calData.GetPacket_X();

  00007	8b 5d 0c	 mov	 ebx, DWORD PTR _calData$[ebp]
  0000a	56		 push	 esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h

; 400  : 	x = 0;

  0000b	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\CoordinateCalculator.cpp

; 107  : {

  0000e	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx

; 109  : 	IPacket *pIPacket = calData.GetPacket_X();

  00011	8b cb		 mov	 ecx, ebx
  00013	57		 push	 edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h

; 400  : 	x = 0;

  00014	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 401  : 	y = 0;

  0001a	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\CoordinateCalculator.cpp

; 109  : 	IPacket *pIPacket = calData.GetPacket_X();

  00021	e8 00 00 00 00	 call	 ?GetPacket_X@CCoordinateCalculatorData@@QBEPAUIPacket133101@@XZ ; CCoordinateCalculatorData::GetPacket_X
  00026	8b f8		 mov	 edi, eax

; 190  : 	return (pPacket != NULL && pPacket->GetDataCount() > 0);

  00028	85 ff		 test	 edi, edi
  0002a	74 48		 je	 SHORT $LN10@AbsoluteTo
  0002c	8b 07		 mov	 eax, DWORD PTR [edi]
  0002e	8b cf		 mov	 ecx, edi
  00030	ff 50 2c	 call	 DWORD PTR [eax+44]
  00033	85 c0		 test	 eax, eax
  00035	7e 3d		 jle	 SHORT $LN10@AbsoluteTo

; 111  : 	else
; 112  : 	{
; 113  : 		CCoordinate relativePt = AbsoluteToRelative(calData, point);

  00037	ff 75 10	 push	 DWORD PTR _point$[ebp]
  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
  0003d	8d 45 dc	 lea	 eax, DWORD PTR _relativePt$1[ebp]
  00040	53		 push	 ebx
  00041	50		 push	 eax
  00042	e8 00 00 00 00	 call	 ?AbsoluteToRelative@CCoordinateCalculator@@QBE?AVCCoordinate@@ABVCCoordinateCalculatorData@@ABVCPoint@@@Z ; CCoordinateCalculator::AbsoluteToRelative

; 114  : 		CPoint drawingPoint = RelativeToAbsolute(calData, relativePt);

  00047	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
  0004a	8d 45 dc	 lea	 eax, DWORD PTR _relativePt$1[ebp]
  0004d	50		 push	 eax
  0004e	53		 push	 ebx
  0004f	8d 45 f4	 lea	 eax, DWORD PTR _drawingPoint$2[ebp]
  00052	50		 push	 eax
  00053	e8 00 00 00 00	 call	 ?RelativeToAbsolute@CCoordinateCalculator@@QBE?AVCPoint@@ABVCCoordinateCalculatorData@@ABVCCoordinate@@@Z ; CCoordinateCalculator::RelativeToAbsolute

; 115  : 		ptResult = drawingPoint;

  00058	8b 4d f8	 mov	 ecx, DWORD PTR _drawingPoint$2[ebp+4]
  0005b	8b 45 f4	 mov	 eax, DWORD PTR _drawingPoint$2[ebp]
  0005e	89 4e 04	 mov	 DWORD PTR [esi+4], ecx

; 116  : 	}
; 117  : 	if( pIPacket) pIPacket->Release();

  00061	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00063	57		 push	 edi
  00064	89 06		 mov	 DWORD PTR [esi], eax
  00066	ff 51 08	 call	 DWORD PTR [ecx+8]
  00069	5f		 pop	 edi

; 118  : 	return ptResult;
; 119  : }

  0006a	8b c6		 mov	 eax, esi
  0006c	5e		 pop	 esi
  0006d	5b		 pop	 ebx
  0006e	8b e5		 mov	 esp, ebp
  00070	5d		 pop	 ebp
  00071	c2 0c 00	 ret	 12			; 0000000cH
$LN10@AbsoluteTo:

; 110  : 	if( !IsCalculator( pIPacket)) ptResult = point;

  00074	8b 45 10	 mov	 eax, DWORD PTR _point$[ebp]
  00077	8b 08		 mov	 ecx, DWORD PTR [eax]
  00079	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0007c	89 0e		 mov	 DWORD PTR [esi], ecx
  0007e	89 56 04	 mov	 DWORD PTR [esi+4], edx

; 116  : 	}
; 117  : 	if( pIPacket) pIPacket->Release();

  00081	85 ff		 test	 edi, edi
  00083	74 06		 je	 SHORT $LN14@AbsoluteTo
  00085	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00087	57		 push	 edi
  00088	ff 51 08	 call	 DWORD PTR [ecx+8]
$LN14@AbsoluteTo:

; 118  : 	return ptResult;
; 119  : }

  0008b	5f		 pop	 edi
  0008c	8b c6		 mov	 eax, esi
  0008e	5e		 pop	 esi
  0008f	5b		 pop	 ebx
  00090	8b e5		 mov	 esp, ebp
  00092	5d		 pop	 ebp
  00093	c2 0c 00	 ret	 12			; 0000000cH
?AbsoluteToAbsolute@CCoordinateCalculator@@QBE?AVCPoint@@ABVCCoordinateCalculatorData@@ABV2@@Z ENDP ; CCoordinateCalculator::AbsoluteToAbsolute
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\CoordinateCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\CoordinateCalculator.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\CoordinateCalculator.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Include_Analysis\CoordinateCalculatorData.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\CoordinateCalculator.cpp
;	COMDAT ?RelativeToAbsolute@CCoordinateCalculator@@QBE?AVCPoint@@ABVCCoordinateCalculatorData@@ABVCCoordinate@@@Z
_TEXT	SEGMENT
_nCenter_x$1 = -76					; size = 4
$T2 = -72						; size = 8
$T3 = -72						; size = 8
___$ReturnUdt$GSCopy$1$ = -64				; size = 4
$T4 = -60						; size = 8
_ptResult$1$ = -56					; size = 4
_nPckTimeDiff$1$ = -56					; size = 4
$T5 = -52						; size = 8
$T6 = -52						; size = 8
_ptResult$2$ = -48					; size = 4
$T7 = -44						; size = 8
_calData$GSCopy$1$ = -40				; size = 4
$T8 = -36						; size = 8
_point$GSCopy$1$ = -32					; size = 4
tv383 = -28						; size = 8
tv376 = -28						; size = 8
$T9 = -28						; size = 8
_dX$10 = -28						; size = 8
$T11 = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_calData$ = 12						; size = 4
_point$ = 16						; size = 4
?RelativeToAbsolute@CCoordinateCalculator@@QBE?AVCPoint@@ABVCCoordinateCalculatorData@@ABVCCoordinate@@@Z PROC ; CCoordinateCalculator::RelativeToAbsolute, COMDAT
; _this$ = ecx

; 68   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 10	 mov	 ebx, DWORD PTR _point$[ebp]
  00014	56		 push	 esi
  00015	8b 75 0c	 mov	 esi, DWORD PTR _calData$[ebp]

; 69   : 	// (2007/5/10 - Seung-Won, Bae) Check No Y Scale Min/Max.
; 70   : 	if( -HUGE_VAL == calData.GetDisplayDataMax_ScaleType() || -HUGE_VAL == calData.GetDisplayDataMin_ScaleType()) return point.GetPixel();

  00018	8b ce		 mov	 ecx, esi
  0001a	57		 push	 edi
  0001b	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  0001e	89 7d c0	 mov	 DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp], edi
  00021	89 75 d8	 mov	 DWORD PTR _calData$GSCopy$1$[ebp], esi
  00024	89 5d e0	 mov	 DWORD PTR _point$GSCopy$1$[ebp], ebx
  00027	e8 00 00 00 00	 call	 ?GetDisplayDataMax_ScaleType@CCoordinateCalculatorData@@QBENXZ ; CCoordinateCalculatorData::GetDisplayDataMax_ScaleType
  0002c	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@fff0000000000000
  00034	dd 5d e4	 fstp	 QWORD PTR tv383[ebp]
  00037	66 0f 2e 45 e4	 ucomisd xmm0, QWORD PTR tv383[ebp]
  0003c	9f		 lahf
  0003d	f6 c4 44	 test	 ah, 68			; 00000044H
  00040	0f 8b ce 01 00
	00		 jnp	 $LN3@RelativeTo
  00046	8b ce		 mov	 ecx, esi
  00048	e8 00 00 00 00	 call	 ?GetDisplayDataMin_ScaleType@CCoordinateCalculatorData@@QBENXZ ; CCoordinateCalculatorData::GetDisplayDataMin_ScaleType
  0004d	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@fff0000000000000
  00055	dd 5d e4	 fstp	 QWORD PTR tv376[ebp]
  00058	66 0f 2e 45 e4	 ucomisd xmm0, QWORD PTR tv376[ebp]
  0005d	9f		 lahf
  0005e	f6 c4 44	 test	 ah, 68			; 00000044H
  00061	0f 8b ad 01 00
	00		 jnp	 $LN3@RelativeTo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h

; 401  : 	y = 0;

  00067	33 c0		 xor	 eax, eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\CoordinateCalculator.cpp

; 73   : 	IPacket *pIPacket = calData.GetPacket_X();

  00069	8b ce		 mov	 ecx, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h

; 401  : 	y = 0;

  0006b	89 45 d0	 mov	 DWORD PTR _ptResult$2$[ebp], eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\CoordinateCalculator.cpp

; 73   : 	IPacket *pIPacket = calData.GetPacket_X();

  0006e	e8 00 00 00 00	 call	 ?GetPacket_X@CCoordinateCalculatorData@@QBEPAUIPacket133101@@XZ ; CCoordinateCalculatorData::GetPacket_X
  00073	8b d8		 mov	 ebx, eax

; 190  : 	return (pPacket != NULL && pPacket->GetDataCount() > 0);

  00075	85 db		 test	 ebx, ebx
  00077	0f 84 5d 01 00
	00		 je	 $LN14@RelativeTo
  0007d	8b 03		 mov	 eax, DWORD PTR [ebx]
  0007f	8b cb		 mov	 ecx, ebx
  00081	ff 50 2c	 call	 DWORD PTR [eax+44]
  00084	85 c0		 test	 eax, eax
  00086	0f 8e 4e 01 00
	00		 jle	 $LN14@RelativeTo

; 77   : 	}
; 78   : 	else
; 79   : 	{
; 80   : 		int nCenter_x;
; 81   : 		double dX = 0.0;
; 82   : 		dX = point.GetX();

  0008c	8b 4d e0	 mov	 ecx, DWORD PTR _point$GSCopy$1$[ebp]
  0008f	e8 00 00 00 00	 call	 ?GetX@CCoordinate@@QBENXZ ; CCoordinate::GetX

; 83   : 		// 20081007 JS.Kim	사용자시간대 선택<<
; 84   : 		int nPckTimeDiff = pIPacket->GetBaseTimeDifference();

  00094	8b 03		 mov	 eax, DWORD PTR [ebx]
  00096	8b cb		 mov	 ecx, ebx
  00098	dd 5d e4	 fstp	 QWORD PTR _dX$10[ebp]
  0009b	ff 50 60	 call	 DWORD PTR [eax+96]

; 85   : 		if( nPckTimeDiff != point.GetTimeDiff() )

  0009e	8b 4d e0	 mov	 ecx, DWORD PTR _point$GSCopy$1$[ebp]
  000a1	89 45 c8	 mov	 DWORD PTR _nPckTimeDiff$1$[ebp], eax
  000a4	e8 00 00 00 00	 call	 ?GetTimeDiff@CCoordinate@@QBEHXZ ; CCoordinate::GetTimeDiff
  000a9	39 45 c8	 cmp	 DWORD PTR _nPckTimeDiff$1$[ebp], eax
  000ac	74 2a		 je	 SHORT $LN6@RelativeTo

; 86   : 			dX = pIPacket->CalcTimeDiff(dX, nPckTimeDiff - point.GetTimeDiff());

  000ae	8b 4d e0	 mov	 ecx, DWORD PTR _point$GSCopy$1$[ebp]
  000b1	8b 33		 mov	 esi, DWORD PTR [ebx]
  000b3	e8 00 00 00 00	 call	 ?GetTimeDiff@CCoordinate@@QBEHXZ ; CCoordinate::GetTimeDiff
  000b8	8b 4d c8	 mov	 ecx, DWORD PTR _nPckTimeDiff$1$[ebp]
  000bb	f2 0f 10 45 e4	 movsd	 xmm0, QWORD PTR _dX$10[ebp]
  000c0	2b c8		 sub	 ecx, eax
  000c2	8b 46 68	 mov	 eax, DWORD PTR [esi+104]
  000c5	51		 push	 ecx
  000c6	83 ec 08	 sub	 esp, 8
  000c9	8b cb		 mov	 ecx, ebx
  000cb	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  000d0	ff d0		 call	 eax
  000d2	8b 75 d8	 mov	 esi, DWORD PTR _calData$GSCopy$1$[ebp]
  000d5	dd 5d e4	 fstp	 QWORD PTR _dX$10[ebp]
$LN6@RelativeTo:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Include_Analysis\CoordinateCalculatorData.h

; 128  : 							{	return m_pIChartManager && m_pIChartOCX && m_pIPacketListManager && m_pIDefaultPacketManager;	}

  000d8	8b 46 48	 mov	 eax, DWORD PTR [esi+72]
  000db	85 c0		 test	 eax, eax
  000dd	0f 84 1f 01 00
	00		 je	 $LN26@RelativeTo
  000e3	83 7e 4c 00	 cmp	 DWORD PTR [esi+76], 0
  000e7	0f 84 15 01 00
	00		 je	 $LN26@RelativeTo
  000ed	83 7e 50 00	 cmp	 DWORD PTR [esi+80], 0
  000f1	0f 84 0b 01 00
	00		 je	 $LN26@RelativeTo
  000f7	83 7e 54 00	 cmp	 DWORD PTR [esi+84], 0
  000fb	0f 84 01 01 00
	00		 je	 $LN26@RelativeTo
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\CoordinateCalculator.cpp

; 91   : 			int nXPos = calData.m_pIChartManager->GetXFromDouble(calData.GetBlockIndex().GetRow(), calData.GetBlockIndex().GetColumn(), dX, nCenter_x);

  00101	8b 38		 mov	 edi, DWORD PTR [eax]
  00103	8b ce		 mov	 ecx, esi
  00105	8d 45 c4	 lea	 eax, DWORD PTR $T4[ebp]
  00108	50		 push	 eax
  00109	e8 00 00 00 00	 call	 ?GetBlockIndex@CCoordinateCalculatorData@@QBE?AVCBlockIndex@@XZ ; CCoordinateCalculatorData::GetBlockIndex
  0010e	8b 4d d8	 mov	 ecx, DWORD PTR _calData$GSCopy$1$[ebp]
  00111	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  00114	8d 45 cc	 lea	 eax, DWORD PTR $T6[ebp]
  00117	50		 push	 eax
  00118	e8 00 00 00 00	 call	 ?GetBlockIndex@CCoordinateCalculatorData@@QBE?AVCBlockIndex@@XZ ; CCoordinateCalculatorData::GetBlockIndex
  0011d	f2 0f 10 45 e4	 movsd	 xmm0, QWORD PTR _dX$10[ebp]
  00122	8d 4d b4	 lea	 ecx, DWORD PTR _nCenter_x$1[ebp]
  00125	51		 push	 ecx
  00126	83 ec 08	 sub	 esp, 8
  00129	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0012e	56		 push	 esi
  0012f	ff 30		 push	 DWORD PTR [eax]
  00131	8b 45 d8	 mov	 eax, DWORD PTR _calData$GSCopy$1$[ebp]
  00134	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  00137	ff 97 14 01 00
	00		 call	 DWORD PTR [edi+276]

; 92   : 			int nIndex = calData.m_pIChartManager->FindViewDataIndex_Pt("DEFAULT", nXPos);

  0013d	8b 7d d8	 mov	 edi, DWORD PTR _calData$GSCopy$1$[ebp]
  00140	8b d0		 mov	 edx, eax
  00142	6a 00		 push	 0
  00144	6a 00		 push	 0
  00146	52		 push	 edx
  00147	8b 4f 48	 mov	 ecx, DWORD PTR [edi+72]
  0014a	68 00 00 00 00	 push	 OFFSET ??_C@_07MGCPDNLD@DEFAULT@
  0014f	89 55 c8	 mov	 DWORD PTR _ptResult$1$[ebp], edx
  00152	8b 01		 mov	 eax, DWORD PTR [ecx]
  00154	ff 90 04 01 00
	00		 call	 DWORD PTR [eax+260]

; 93   : 			ptResult = CDataConversion::RelativeToAbsolute(calData.GetRegion(), 

  0015a	8b 4d e0	 mov	 ecx, DWORD PTR _point$GSCopy$1$[ebp]
  0015d	8b f0		 mov	 esi, eax
  0015f	e8 00 00 00 00	 call	 ?GetY@CCoordinate@@QBENXZ ; CCoordinate::GetY
  00164	8d 45 e4	 lea	 eax, DWORD PTR $T9[ebp]
  00167	8b cf		 mov	 ecx, edi
  00169	dd 5d e4	 fstp	 QWORD PTR $T9[ebp]
  0016c	50		 push	 eax
  0016d	e8 00 00 00 00	 call	 ?ApplyLog@CCoordinateCalculatorData@@QBENABN@Z ; CCoordinateCalculatorData::ApplyLog
  00172	dd 5d cc	 fstp	 QWORD PTR $T5[ebp]
  00175	8b cf		 mov	 ecx, edi
  00177	e8 00 00 00 00	 call	 ?GetDisplayDataMax_ScaleType@CCoordinateCalculatorData@@QBENXZ ; CCoordinateCalculatorData::GetDisplayDataMax_ScaleType
  0017c	dd 5d d4	 fstp	 QWORD PTR $T7[ebp]
  0017f	8b cf		 mov	 ecx, edi
  00181	e8 00 00 00 00	 call	 ?GetDisplayDataMin_ScaleType@CCoordinateCalculatorData@@QBENXZ ; CCoordinateCalculatorData::GetDisplayDataMin_ScaleType
  00186	8d 45 cc	 lea	 eax, DWORD PTR $T5[ebp]
  00189	8b cf		 mov	 ecx, edi
  0018b	50		 push	 eax
  0018c	56		 push	 esi
  0018d	8d 45 d4	 lea	 eax, DWORD PTR $T7[ebp]
  00190	50		 push	 eax
  00191	8d 45 dc	 lea	 eax, DWORD PTR $T8[ebp]
  00194	50		 push	 eax
  00195	dd 5d dc	 fstp	 QWORD PTR $T8[ebp]
  00198	e8 00 00 00 00	 call	 ?GetDisplayDataEnd@CCoordinateCalculatorData@@QBEHXZ ; CCoordinateCalculatorData::GetDisplayDataEnd
  0019d	50		 push	 eax
  0019e	8b cf		 mov	 ecx, edi
  001a0	e8 00 00 00 00	 call	 ?GetDisplayDataStart@CCoordinateCalculatorData@@QBEHXZ ; CCoordinateCalculatorData::GetDisplayDataStart
  001a5	50		 push	 eax
  001a6	8d 45 ec	 lea	 eax, DWORD PTR $T11[ebp]
  001a9	8b cf		 mov	 ecx, edi
  001ab	50		 push	 eax
  001ac	e8 00 00 00 00	 call	 ?GetRegion@CCoordinateCalculatorData@@QBE?AVCRect@@XZ ; CCoordinateCalculatorData::GetRegion
  001b1	50		 push	 eax
  001b2	8d 45 b8	 lea	 eax, DWORD PTR $T2[ebp]
  001b5	50		 push	 eax
  001b6	e8 00 00 00 00	 call	 ?RelativeToAbsolute@CDataConversion@@SA?AVCPoint@@ABVCRect@@HHABN1H1@Z ; CDataConversion::RelativeToAbsolute

; 94   : 					calData.GetDisplayDataStart(), calData.GetDisplayDataEnd(), 
; 95   : 					calData.GetDisplayDataMin_ScaleType(), calData.GetDisplayDataMax_ScaleType(), 
; 96   : 					nIndex,	calData.ApplyLog(point.GetY()));
; 97   : 			ptResult.x = nXPos;
; 98   : 		}
; 99   : 		//<< (2008/12/26 - Seung-Lyong, Park) 메모리릭 제거
; 100  : 	}
; 101  : 	if( pIPacket) pIPacket->Release();

  001bb	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  001bd	83 c4 20	 add	 esp, 32			; 00000020H
  001c0	8b 7d c0	 mov	 edi, DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp]
  001c3	8b 75 c8	 mov	 esi, DWORD PTR _ptResult$1$[ebp]
  001c6	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001c9	53		 push	 ebx
  001ca	89 45 d0	 mov	 DWORD PTR _ptResult$2$[ebp], eax
  001cd	ff 51 08	 call	 DWORD PTR [ecx+8]
  001d0	8b 45 d0	 mov	 eax, DWORD PTR _ptResult$2$[ebp]

; 102  : 	return ptResult;

  001d3	89 37		 mov	 DWORD PTR [edi], esi
  001d5	89 47 04	 mov	 DWORD PTR [edi+4], eax
  001d8	eb 42		 jmp	 SHORT $LN28@RelativeTo
$LN14@RelativeTo:

; 74   : 	if(!IsCalculator( pIPacket)) 
; 75   : 	{
; 76   : 		ptResult = point.GetPixel();

  001da	8b 4d e0	 mov	 ecx, DWORD PTR _point$GSCopy$1$[ebp]
  001dd	8d 45 b8	 lea	 eax, DWORD PTR $T3[ebp]
  001e0	50		 push	 eax
  001e1	e8 00 00 00 00	 call	 ?GetPixel@CCoordinate@@QBE?AVCPoint@@XZ ; CCoordinate::GetPixel
  001e6	8b 30		 mov	 esi, DWORD PTR [eax]
  001e8	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001eb	89 45 d0	 mov	 DWORD PTR _ptResult$2$[ebp], eax

; 94   : 					calData.GetDisplayDataStart(), calData.GetDisplayDataEnd(), 
; 95   : 					calData.GetDisplayDataMin_ScaleType(), calData.GetDisplayDataMax_ScaleType(), 
; 96   : 					nIndex,	calData.ApplyLog(point.GetY()));
; 97   : 			ptResult.x = nXPos;
; 98   : 		}
; 99   : 		//<< (2008/12/26 - Seung-Lyong, Park) 메모리릭 제거
; 100  : 	}
; 101  : 	if( pIPacket) pIPacket->Release();

  001ee	85 db		 test	 ebx, ebx
  001f0	74 1b		 je	 SHORT $LN8@RelativeTo
  001f2	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  001f4	53		 push	 ebx
  001f5	ff 51 08	 call	 DWORD PTR [ecx+8]
  001f8	8b 45 d0	 mov	 eax, DWORD PTR _ptResult$2$[ebp]

; 102  : 	return ptResult;

  001fb	89 37		 mov	 DWORD PTR [edi], esi
  001fd	89 47 04	 mov	 DWORD PTR [edi+4], eax
  00200	eb 1a		 jmp	 SHORT $LN28@RelativeTo
$LN26@RelativeTo:

; 94   : 					calData.GetDisplayDataStart(), calData.GetDisplayDataEnd(), 
; 95   : 					calData.GetDisplayDataMin_ScaleType(), calData.GetDisplayDataMax_ScaleType(), 
; 96   : 					nIndex,	calData.ApplyLog(point.GetY()));
; 97   : 			ptResult.x = nXPos;
; 98   : 		}
; 99   : 		//<< (2008/12/26 - Seung-Lyong, Park) 메모리릭 제거
; 100  : 	}
; 101  : 	if( pIPacket) pIPacket->Release();

  00202	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00204	33 f6		 xor	 esi, esi
  00206	53		 push	 ebx
  00207	ff 51 08	 call	 DWORD PTR [ecx+8]
  0020a	8b 45 d0	 mov	 eax, DWORD PTR _ptResult$2$[ebp]
$LN8@RelativeTo:

; 102  : 	return ptResult;

  0020d	89 37		 mov	 DWORD PTR [edi], esi
  0020f	89 47 04	 mov	 DWORD PTR [edi+4], eax
  00212	eb 08		 jmp	 SHORT $LN28@RelativeTo
$LN3@RelativeTo:

; 69   : 	// (2007/5/10 - Seung-Won, Bae) Check No Y Scale Min/Max.
; 70   : 	if( -HUGE_VAL == calData.GetDisplayDataMax_ScaleType() || -HUGE_VAL == calData.GetDisplayDataMin_ScaleType()) return point.GetPixel();

  00214	57		 push	 edi
  00215	8b cb		 mov	 ecx, ebx
  00217	e8 00 00 00 00	 call	 ?GetPixel@CCoordinate@@QBE?AVCPoint@@XZ ; CCoordinate::GetPixel
$LN28@RelativeTo:

; 103  : }

  0021c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0021f	8b c7		 mov	 eax, edi
  00221	5f		 pop	 edi
  00222	5e		 pop	 esi
  00223	33 cd		 xor	 ecx, ebp
  00225	5b		 pop	 ebx
  00226	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0022b	8b e5		 mov	 esp, ebp
  0022d	5d		 pop	 ebp
  0022e	c2 0c 00	 ret	 12			; 0000000cH
?RelativeToAbsolute@CCoordinateCalculator@@QBE?AVCPoint@@ABVCCoordinateCalculatorData@@ABVCCoordinate@@@Z ENDP ; CCoordinateCalculator::RelativeToAbsolute
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\CoordinateCalculator.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Include_Analysis\CoordinateCalculatorData.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\CoordinateCalculator.cpp
;	COMDAT ?AbsoluteToRelative@CCoordinateCalculator@@QBE?AVCCoordinate@@ABVCCoordinateCalculatorData@@ABVCPoint@@@Z
_TEXT	SEGMENT
_x$1 = -72						; size = 8
_temp$2 = -64						; size = 8
$T3 = -56						; size = 8
_nCenter_x$4 = -52					; size = 4
_nRow$5 = -48						; size = 4
_nCol$6 = -44						; size = 4
_dReturn$7 = -40					; size = 8
_y$8 = -40						; size = 8
$T9 = -40						; size = 8
_nBlockColumn$10 = -36					; size = 4
_point$GSCopy$1$ = -32					; size = 4
$T11 = -28						; size = 24
$T12 = -28						; size = 24
$T13 = -28						; size = 24
$T14 = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_calData$ = 12						; size = 4
_point$ = 16						; size = 4
?AbsoluteToRelative@CCoordinateCalculator@@QBE?AVCCoordinate@@ABVCCoordinateCalculatorData@@ABVCPoint@@@Z PROC ; CCoordinateCalculator::AbsoluteToRelative, COMDAT
; _this$ = ecx

; 30   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 10	 mov	 eax, DWORD PTR _point$[ebp]
  00013	53		 push	 ebx
  00014	8b 5d 0c	 mov	 ebx, DWORD PTR _calData$[ebp]
  00017	56		 push	 esi
  00018	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]

; 31   : 	CCoordinate cdResult;

  0001b	8b ce		 mov	 ecx, esi
  0001d	57		 push	 edi
  0001e	89 45 e0	 mov	 DWORD PTR _point$GSCopy$1$[ebp], eax
  00021	e8 00 00 00 00	 call	 ??0CCoordinate@@QAE@XZ	; CCoordinate::CCoordinate

; 32   : 	IPacket *pIPacket = calData.GetPacket_X();

  00026	8b cb		 mov	 ecx, ebx
  00028	e8 00 00 00 00	 call	 ?GetPacket_X@CCoordinateCalculatorData@@QBEPAUIPacket133101@@XZ ; CCoordinateCalculatorData::GetPacket_X
  0002d	8b f8		 mov	 edi, eax

; 190  : 	return (pPacket != NULL && pPacket->GetDataCount() > 0);

  0002f	85 ff		 test	 edi, edi
  00031	0f 84 05 01 00
	00		 je	 $LN10@AbsoluteTo
  00037	8b 07		 mov	 eax, DWORD PTR [edi]
  00039	8b cf		 mov	 ecx, edi
  0003b	ff 50 2c	 call	 DWORD PTR [eax+44]
  0003e	85 c0		 test	 eax, eax
  00040	0f 8e f6 00 00
	00		 jle	 $LN10@AbsoluteTo
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Include_Analysis\CoordinateCalculatorData.h

; 128  : 							{	return m_pIChartManager && m_pIChartOCX && m_pIPacketListManager && m_pIDefaultPacketManager;	}

  00046	8b 53 48	 mov	 edx, DWORD PTR [ebx+72]
  00049	0f 57 c0	 xorps	 xmm0, xmm0
  0004c	85 d2		 test	 edx, edx
  0004e	74 56		 je	 SHORT $LN13@AbsoluteTo
  00050	83 7b 4c 00	 cmp	 DWORD PTR [ebx+76], 0
  00054	74 50		 je	 SHORT $LN13@AbsoluteTo
  00056	83 7b 50 00	 cmp	 DWORD PTR [ebx+80], 0
  0005a	74 4a		 je	 SHORT $LN13@AbsoluteTo
  0005c	83 7b 54 00	 cmp	 DWORD PTR [ebx+84], 0
  00060	74 44		 je	 SHORT $LN13@AbsoluteTo
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\CoordinateCalculator.cpp

; 181  : 		calData.m_pIChartManager->GetBlockIndex(point, nRow, nCol);

  00062	8b 02		 mov	 eax, DWORD PTR [edx]
  00064	8d 4d d4	 lea	 ecx, DWORD PTR _nCol$6[ebp]
  00067	51		 push	 ecx
  00068	8d 4d d0	 lea	 ecx, DWORD PTR _nRow$5[ebp]
  0006b	51		 push	 ecx
  0006c	8b 4d e0	 mov	 ecx, DWORD PTR _point$GSCopy$1$[ebp]
  0006f	ff 71 04	 push	 DWORD PTR [ecx+4]
  00072	ff 31		 push	 DWORD PTR [ecx]
  00074	8b ca		 mov	 ecx, edx
  00076	ff 90 8c 00 00
	00		 call	 DWORD PTR [eax+140]

; 182  : 		dReturn = calData.m_pIChartManager->GetDoubleFromX(nRow, nCol, point.x, &nBlockColumn, nCenter_x);

  0007c	8b 4b 48	 mov	 ecx, DWORD PTR [ebx+72]
  0007f	8d 55 cc	 lea	 edx, DWORD PTR _nCenter_x$4[ebp]
  00082	6a 00		 push	 0
  00084	52		 push	 edx
  00085	8d 55 dc	 lea	 edx, DWORD PTR _nBlockColumn$10[ebp]
  00088	8b 01		 mov	 eax, DWORD PTR [ecx]
  0008a	52		 push	 edx
  0008b	8b 55 e0	 mov	 edx, DWORD PTR _point$GSCopy$1$[ebp]
  0008e	8b 80 10 01 00
	00		 mov	 eax, DWORD PTR [eax+272]
  00094	ff 32		 push	 DWORD PTR [edx]
  00096	ff 75 d4	 push	 DWORD PTR _nCol$6[ebp]
  00099	ff 75 d0	 push	 DWORD PTR _nRow$5[ebp]
  0009c	ff d0		 call	 eax
  0009e	dd 5d d8	 fstp	 QWORD PTR _dReturn$7[ebp]
  000a1	f2 0f 10 45 d8	 movsd	 xmm0, QWORD PTR _dReturn$7[ebp]
$LN13@AbsoluteTo:

; 36   : 	}
; 37   : 	else
; 38   : 	{
; 39   : 		// XScale : 관련 Interface로 사용 - vntsorl(20070327)
; 40   : //		int index = CDataConversion::GetPacketDataIndex_Date( calData.GetRegion(), point, 
; 41   : //					calData.GetDisplayDataStart(), calData.GetDisplayDataEnd());
; 42   : 
; 43   : 		//>> (2008/12/26 - Seung-Lyong, Park) 메모리릭 제거
; 44   : //		int nIndex = calData.GetIChartManager()->FindViewDataIndex_Pt("DEFAULT", point.x);
; 45   : 		//<< (2008/12/26 - Seung-Lyong, Park) 메모리릭 제거
; 46   : 		
; 47   : 		double x = 0.0;
; 48   : //		pIPacket->GetDataPastandFuture(nIndex, x);
; 49   : 		x = GetData_X(calData, point, 0);
; 50   : 		double temp = CDataConversion::AbsoluteToRelative_Y(calData.GetRegion(), point.y, 

  000a6	8b cb		 mov	 ecx, ebx
  000a8	f2 0f 11 45 b8	 movsd	 QWORD PTR _x$1[ebp], xmm0
  000ad	e8 00 00 00 00	 call	 ?GetDisplayDataMax_ScaleType@CCoordinateCalculatorData@@QBENXZ ; CCoordinateCalculatorData::GetDisplayDataMax_ScaleType
  000b2	dd 5d d8	 fstp	 QWORD PTR $T9[ebp]
  000b5	8b cb		 mov	 ecx, ebx
  000b7	e8 00 00 00 00	 call	 ?GetDisplayDataMin_ScaleType@CCoordinateCalculatorData@@QBENXZ ; CCoordinateCalculatorData::GetDisplayDataMin_ScaleType
  000bc	8d 45 d8	 lea	 eax, DWORD PTR $T9[ebp]
  000bf	8b cb		 mov	 ecx, ebx
  000c1	50		 push	 eax
  000c2	8d 45 c8	 lea	 eax, DWORD PTR $T3[ebp]
  000c5	50		 push	 eax
  000c6	8b 45 e0	 mov	 eax, DWORD PTR _point$GSCopy$1$[ebp]
  000c9	dd 5d c8	 fstp	 QWORD PTR $T3[ebp]
  000cc	ff 70 04	 push	 DWORD PTR [eax+4]
  000cf	8d 45 ec	 lea	 eax, DWORD PTR $T14[ebp]
  000d2	50		 push	 eax
  000d3	e8 00 00 00 00	 call	 ?GetRegion@CCoordinateCalculatorData@@QBE?AVCRect@@XZ ; CCoordinateCalculatorData::GetRegion
  000d8	50		 push	 eax
  000d9	e8 00 00 00 00	 call	 ?AbsoluteToRelative_Y@CDataConversion@@SANABVCRect@@HABN1@Z ; CDataConversion::AbsoluteToRelative_Y

; 51   : 					calData.GetDisplayDataMin_ScaleType(), calData.GetDisplayDataMax_ScaleType());
; 52   : 
; 53   : 		// (2007/5/10 - Seung-Won, Bae) Check No Y Scale Min/Max.
; 54   : 		if( -HUGE_VAL == temp) cdResult = CCoordinate(point);

  000de	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@fff0000000000000
  000e6	83 c4 10	 add	 esp, 16			; 00000010H
  000e9	dd 5d c0	 fstp	 QWORD PTR _temp$2[ebp]
  000ec	66 0f 2e 45 c0	 ucomisd xmm0, QWORD PTR _temp$2[ebp]
  000f1	9f		 lahf
  000f2	f6 c4 44	 test	 ah, 68			; 00000044H
  000f5	7a 1d		 jp	 SHORT $LN4@AbsoluteTo
  000f7	ff 75 e0	 push	 DWORD PTR _point$GSCopy$1$[ebp]
  000fa	8d 4d e4	 lea	 ecx, DWORD PTR $T12[ebp]
  000fd	e8 00 00 00 00	 call	 ??0CCoordinate@@QAE@ABVCPoint@@@Z ; CCoordinate::CCoordinate
$LN23@AbsoluteTo:

; 60   : 		}
; 61   : 	}
; 62   : 	if( pIPacket) pIPacket->Release();

  00102	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00105	0f 11 06	 movups	 XMMWORD PTR [esi], xmm0
  00108	f3 0f 7e 40 10	 movq	 xmm0, QWORD PTR [eax+16]
  0010d	66 0f d6 46 10	 movq	 QWORD PTR [esi+16], xmm0
  00112	eb 47		 jmp	 SHORT $LN21@AbsoluteTo
$LN4@AbsoluteTo:

; 55   : 		else
; 56   : 		{
; 57   : 			double y = calData.ApplyExp(temp);

  00114	8d 45 c0	 lea	 eax, DWORD PTR _temp$2[ebp]
  00117	8b cb		 mov	 ecx, ebx
  00119	50		 push	 eax
  0011a	e8 00 00 00 00	 call	 ?ApplyExp@CCoordinateCalculatorData@@QBENABN@Z ; CCoordinateCalculatorData::ApplyExp

; 58   : 			// 20081007 JS.Kim	사용자시간대 선택
; 59   : 			cdResult = CCoordinate(x, y, pIPacket->GetBaseTimeDifference());

  0011f	8b 07		 mov	 eax, DWORD PTR [edi]
  00121	8b cf		 mov	 ecx, edi
  00123	dd 5d d8	 fstp	 QWORD PTR _y$8[ebp]
  00126	ff 50 60	 call	 DWORD PTR [eax+96]
  00129	50		 push	 eax
  0012a	8d 45 d8	 lea	 eax, DWORD PTR _y$8[ebp]
  0012d	50		 push	 eax
  0012e	8d 45 b8	 lea	 eax, DWORD PTR _x$1[ebp]
  00131	50		 push	 eax
  00132	8d 4d e4	 lea	 ecx, DWORD PTR $T11[ebp]
  00135	e8 00 00 00 00	 call	 ??0CCoordinate@@QAE@ABN0H@Z ; CCoordinate::CCoordinate
  0013a	eb c6		 jmp	 SHORT $LN23@AbsoluteTo
$LN10@AbsoluteTo:

; 33   : 	if( !IsCalculator( pIPacket)) 
; 34   : 	{
; 35   : 		cdResult = CCoordinate(point);

  0013c	ff 75 e0	 push	 DWORD PTR _point$GSCopy$1$[ebp]
  0013f	8d 4d e4	 lea	 ecx, DWORD PTR $T13[ebp]
  00142	e8 00 00 00 00	 call	 ??0CCoordinate@@QAE@ABVCPoint@@@Z ; CCoordinate::CCoordinate
  00147	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  0014a	0f 11 06	 movups	 XMMWORD PTR [esi], xmm0
  0014d	f3 0f 7e 40 10	 movq	 xmm0, QWORD PTR [eax+16]
  00152	66 0f d6 46 10	 movq	 QWORD PTR [esi+16], xmm0

; 60   : 		}
; 61   : 	}
; 62   : 	if( pIPacket) pIPacket->Release();

  00157	85 ff		 test	 edi, edi
  00159	74 06		 je	 SHORT $LN22@AbsoluteTo
$LN21@AbsoluteTo:
  0015b	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0015d	57		 push	 edi
  0015e	ff 51 08	 call	 DWORD PTR [ecx+8]
$LN22@AbsoluteTo:

; 63   : 	return cdResult;
; 64   : }

  00161	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00164	8b c6		 mov	 eax, esi
  00166	5f		 pop	 edi
  00167	5e		 pop	 esi
  00168	33 cd		 xor	 ecx, ebp
  0016a	5b		 pop	 ebx
  0016b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00170	8b e5		 mov	 esp, ebp
  00172	5d		 pop	 ebp
  00173	c2 0c 00	 ret	 12			; 0000000cH
?AbsoluteToRelative@CCoordinateCalculator@@QBE?AVCCoordinate@@ABVCCoordinateCalculatorData@@ABVCPoint@@@Z ENDP ; CCoordinateCalculator::AbsoluteToRelative
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\CoordinateCalculator.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	c2 00 00	 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartAddIn\ChartAnalysisToolAddIn\Symbol\CoordinateCalculator.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

  00000	c2 00 00	 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
