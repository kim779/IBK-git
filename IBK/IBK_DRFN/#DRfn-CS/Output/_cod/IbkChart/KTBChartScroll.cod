; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30145.0 

	TITLE	D:\git\src\IBK\IBK_DRFN\#DRfn-CS\_Obj\KTBChart\KTBChartScroll.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

CONST	SEGMENT
?_Fake_alloc@std@@3U_Fake_allocator@1@B	ORG $+1		; std::_Fake_alloc
CONST	ENDS
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	?OnMouseWheel@CKTBChartCtrl@@IAEHIFVCPoint@@@Z	; CKTBChartCtrl::OnMouseWheel
PUBLIC	?OnnOnePageDataCountChanged@CKTBChartCtrl@@IAEXXZ ; CKTBChartCtrl::OnnOnePageDataCountChanged
PUBLIC	?GetNCurrentDrawCount@CKTBChartCtrl@@IAEJXZ	; CKTBChartCtrl::GetNCurrentDrawCount
PUBLIC	?SetOnePageDataCount@CKTBChartCtrl@@IAEXJ@Z	; CKTBChartCtrl::SetOnePageDataCount
PUBLIC	?GetOnePageDataCount@CKTBChartCtrl@@IAEJXZ	; CKTBChartCtrl::GetOnePageDataCount
PUBLIC	?GetStartEndDateOnView@CKTBChartCtrl@@IAEHPAN0@Z ; CKTBChartCtrl::GetStartEndDateOnView
PUBLIC	?SetStartEndDateOfView@CKTBChartCtrl@@IAEHNN@Z	; CKTBChartCtrl::SetStartEndDateOfView
PUBLIC	?ScrollToDataOfEnd@CKTBChartCtrl@@IAEHN@Z	; CKTBChartCtrl::ScrollToDataOfEnd
PUBLIC	?ZoomToWithRightFix@CKTBChartCtrl@@IAEFFH@Z	; CKTBChartCtrl::ZoomToWithRightFix
PUBLIC	?SetOnePageDataCount2@CKTBChartCtrl@@IAEXJH@Z	; CKTBChartCtrl::SetOnePageDataCount2
PUBLIC	?ZoomTo@CKTBChartCtrl@@IAEHJH@Z			; CKTBChartCtrl::ZoomTo
PUBLIC	?GetCurrentScrollPos@CKTBChartCtrl@@QAEHXZ	; CKTBChartCtrl::GetCurrentScrollPos
PUBLIC	?SetScrollPosToNextPage@CKTBChartCtrl@@QAEHH@Z	; CKTBChartCtrl::SetScrollPosToNextPage
PUBLIC	?ResetScroll@CKTBChartCtrl@@QAEXH@Z		; CKTBChartCtrl::ResetScroll
PUBLIC	?GetOnePageDataCountForScroll@CKTBChartCtrl@@QBEHXZ ; CKTBChartCtrl::GetOnePageDataCountForScroll
PUBLIC	?GetScrollRange@CKTBChartCtrl@@QAEHAAH@Z	; CKTBChartCtrl::GetScrollRange
PUBLIC	?GetDataStartEnd@CKTBChartCtrl@@QAEHAAH0@Z	; CKTBChartCtrl::GetDataStartEnd
PUBLIC	?ScrollTo@CKTBChartCtrl@@QAEHHH@Z		; CKTBChartCtrl::ScrollTo
PUBLIC	?SetWholeView@CKTBChartCtrl@@QAEXH@Z		; CKTBChartCtrl::SetWholeView
PUBLIC	?GetFullDataCount@CKTBChartCtrl@@ABEH_N@Z	; CKTBChartCtrl::GetFullDataCount
PUBLIC	?IsScrollInHorzScaleData@CKTBChartCtrl@@ABE_NXZ	; CKTBChartCtrl::IsScrollInHorzScaleData
PUBLIC	?UpdateZoomAndScrollInfo@CKTBChartCtrl@@UAEXHHH@Z ; CKTBChartCtrl::UpdateZoomAndScrollInfo
PUBLIC	?DragZoomIn@CKTBChartCtrl@@IAEXABVCPoint@@0@Z	; CKTBChartCtrl::DragZoomIn
PUBLIC	__real@ffefffffffffffff
EXTRN	__imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z:PROC
EXTRN	__imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ:PROC
EXTRN	?Default@CWnd@@IAEJXZ:PROC			; CWnd::Default
EXTRN	?SetModifiedFlag@COleControl@@QAEXH@Z:PROC	; COleControl::SetModifiedFlag
EXTRN	?BoundPropertyChanged@COleControl@@QAEXJ@Z:PROC	; COleControl::BoundPropertyChanged
EXTRN	?IsSpecialGroupGraph@IMetaTable@@QAE_NPBD@Z:PROC ; IMetaTable::IsSpecialGroupGraph
EXTRN	?SendEventMsgToDLL@CKTBChartCtrl@@QAEJIIJ@Z:PROC ; CKTBChartCtrl::SendEventMsgToDLL
EXTRN	?IsRunningNoZoomChart@CKTBChartCtrl@@QAEHXZ:PROC ; CKTBChartCtrl::IsRunningNoZoomChart
EXTRN	?IsUseToolScrollBar@CKTBChartCtrl@@AAE_NXZ:PROC	; CKTBChartCtrl::IsUseToolScrollBar
EXTRN	?GetMaxRange@CKTBChartCtrl@@QAEHXZ:PROC		; CKTBChartCtrl::GetMaxRange
EXTRN	?NeoChangeOnePageDataCount@CKTBChartCtrl@@IAEXH@Z:PROC ; CKTBChartCtrl::NeoChangeOnePageDataCount
EXTRN	?OnUserZoomChanged@CKTBChartCtrl@@QAEXH@Z:PROC	; CKTBChartCtrl::OnUserZoomChanged
EXTRN	?InvalidateControl@CKTBChartCtrl@@QAEXPBUtagRECT@@H@Z:PROC ; CKTBChartCtrl::InvalidateControl
EXTRN	__imp_?GetIndexFromData@CPacket@@QAEHN@Z:PROC
EXTRN	__imp_?GetData@CPacket@@QAENH@Z:PROC
EXTRN	__imp_?GetMaxCount@CPacketList@@QAEHXZ:PROC
EXTRN	__imp_?GetCount@CPacketList@@QAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z:PROC
EXTRN	__imp_?GetBaseData@CPacketList@@QAEPAVCPacket@@V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@_N@Z:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	?g_iMetaTable@@3VIMetaTable@@A:BYTE		; g_iMetaTable
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT __real@ffefffffffffffff
CONST	SEGMENT
__real@ffefffffffffffff DQ 0ffefffffffffffffr	; -1.79769e+308
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?IsScrollInHorzScaleData@CKTBChartCtrl@@ABE_NXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?IsScrollInHorzScaleData@CKTBChartCtrl@@ABE_NXZ$0
__ehfuncinfo$?IsScrollInHorzScaleData@CKTBChartCtrl@@ABE_NXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?IsScrollInHorzScaleData@CKTBChartCtrl@@ABE_NXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?GetFullDataCount@CKTBChartCtrl@@ABEH_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetFullDataCount@CKTBChartCtrl@@ABEH_N@Z$1
__ehfuncinfo$?GetFullDataCount@CKTBChartCtrl@@ABEH_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetFullDataCount@CKTBChartCtrl@@ABEH_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\KTBChart\KTBChartScroll.cpp
;	COMDAT ?DragZoomIn@CKTBChartCtrl@@IAEXABVCPoint@@0@Z
_TEXT	SEGMENT
_p_ptStart$ = 8						; size = 4
_p_ptEnd$ = 12						; size = 4
?DragZoomIn@CKTBChartCtrl@@IAEXABVCPoint@@0@Z PROC	; CKTBChartCtrl::DragZoomIn, COMDAT
; _this$ = ecx

; 117  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 118  : 	// 1. Get Start and End DRI
; 119  : 	int nStartDRIOfView = -1;
; 120  : 	int nEndDRIOfView = -1;
; 121  : 	// 1.1 Zoom out to Full View
; 122  : 	if( p_ptEnd.x < p_ptStart.x)

  00003	8b 45 08	 mov	 eax, DWORD PTR _p_ptStart$[ebp]
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]
  0000c	57		 push	 edi
  0000d	8b 7d 0c	 mov	 edi, DWORD PTR _p_ptEnd$[ebp]
  00010	8b 8e 38 03 00
	00		 mov	 ecx, DWORD PTR [esi+824]
  00016	8b 11		 mov	 edx, DWORD PTR [ecx]
  00018	39 07		 cmp	 DWORD PTR [edi], eax
  0001a	7d 0d		 jge	 SHORT $LN2@DragZoomIn

; 123  : 	{
; 124  : 		nStartDRIOfView		= 0;

  0001c	33 db		 xor	 ebx, ebx

; 125  : 		nEndDRIOfView		= m_pxScaleManager->GetCount() - 1;

  0001e	ff 92 84 00 00
	00		 call	 DWORD PTR [edx+132]
  00024	8d 50 ff	 lea	 edx, DWORD PTR [eax-1]

; 126  : 	}

  00027	eb 2b		 jmp	 SHORT $LN3@DragZoomIn
$LN2@DragZoomIn:

; 127  : 	// 1.3 X Scale Manager Version.
; 128  : 	else
; 129  : 	{
; 130  : 		nStartDRIOfView		= m_pxScaleManager->GetDRInFromPt( p_ptStart.x);

  00029	6a 00		 push	 0
  0002b	6a 00		 push	 0
  0002d	6a 00		 push	 0
  0002f	6a 00		 push	 0
  00031	50		 push	 eax
  00032	ff 92 14 01 00
	00		 call	 DWORD PTR [edx+276]

; 131  : 		nEndDRIOfView		= m_pxScaleManager->GetDRInFromPt( p_ptEnd.x);

  00038	8b 8e 38 03 00
	00		 mov	 ecx, DWORD PTR [esi+824]
  0003e	8b d8		 mov	 ebx, eax
  00040	6a 00		 push	 0
  00042	6a 00		 push	 0
  00044	6a 00		 push	 0
  00046	8b 11		 mov	 edx, DWORD PTR [ecx]
  00048	6a 00		 push	 0
  0004a	ff 37		 push	 DWORD PTR [edi]
  0004c	ff 92 14 01 00
	00		 call	 DWORD PTR [edx+276]
  00052	8b d0		 mov	 edx, eax
$LN3@DragZoomIn:

; 132  : 	}
; 133  : 	// 1.4 Check reverse state.
; 134  : 	if( nEndDRIOfView < nStartDRIOfView)
; 135  : 	{
; 136  : 		int nDRI		= nStartDRIOfView;
; 137  : 		nStartDRIOfView	= nEndDRIOfView;
; 138  : 		nEndDRIOfView	= nDRI;
; 139  : 	}
; 140  : 
; 141  : 	// 1.5 Check minimum data count on page.
; 142  : 	if( nEndDRIOfView - nStartDRIOfView + 1 < m_nMinDataCountOnOnePage)

  00054	0f bf 8e d4 02
	00 00		 movsx	 ecx, WORD PTR [esi+724]
  0005b	3b d3		 cmp	 edx, ebx
  0005d	8b fb		 mov	 edi, ebx
  0005f	0f 4d fa	 cmovge	 edi, edx
  00062	0f 4d d3	 cmovge	 edx, ebx
  00065	8b c7		 mov	 eax, edi
  00067	2b c2		 sub	 eax, edx
  00069	40		 inc	 eax
  0006a	3b c1		 cmp	 eax, ecx
  0006c	7d 13		 jge	 SHORT $LN5@DragZoomIn

; 143  : 	{
; 144  : 		// (2009/5/18 - Seung-Won, Bae) Zoom to min
; 145  : 		nEndDRIOfView += ( m_nMinDataCountOnOnePage - ( nEndDRIOfView - nStartDRIOfView + 1)) / 2;

  0006e	4a		 dec	 edx
  0006f	8b c1		 mov	 eax, ecx
  00071	2b c7		 sub	 eax, edi
  00073	03 c2		 add	 eax, edx
  00075	99		 cdq
  00076	2b c2		 sub	 eax, edx
  00078	d1 f8		 sar	 eax, 1
  0007a	03 f8		 add	 edi, eax

; 146  : 		nStartDRIOfView = nEndDRIOfView - m_nMinDataCountOnOnePage + 1;

  0007c	8b d7		 mov	 edx, edi
  0007e	2b d1		 sub	 edx, ecx
  00080	42		 inc	 edx
$LN5@DragZoomIn:

; 147  : 	}
; 148  : 
; 149  : 	// 2. Update Info.
; 150  : 	// 2.1 Uncheck WholeView option.
; 151  : 	m_bWholeView = FALSE;
; 152  : 	// 2.2 One Page Data Count by User with fixed Item Width option.
; 153  : 	m_nOnePageDataCount = nEndDRIOfView - nStartDRIOfView + 1;
; 154  : 
; 155  : 	// 3. Update X Scale Manager
; 156  : 	m_pxScaleManager->SetStartEndDrawIdx_Cur( nStartDRIOfView, nEndDRIOfView);

  00081	8b 8e 38 03 00
	00		 mov	 ecx, DWORD PTR [esi+824]
  00087	8b c7		 mov	 eax, edi
  00089	2b c2		 sub	 eax, edx
  0008b	c7 86 44 02 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+580], 0
  00095	40		 inc	 eax
  00096	6a 00		 push	 0
  00098	89 86 48 02 00
	00		 mov	 DWORD PTR [esi+584], eax
  0009e	8b 01		 mov	 eax, DWORD PTR [ecx]
  000a0	57		 push	 edi
  000a1	52		 push	 edx
  000a2	ff 90 94 00 00
	00		 call	 DWORD PTR [eax+148]

; 157  : 
; 158  : 	// 5. Update View
; 159  : 	InvalidateControl();

  000a8	6a 01		 push	 1
  000aa	6a 00		 push	 0
  000ac	8b ce		 mov	 ecx, esi
  000ae	e8 00 00 00 00	 call	 ?InvalidateControl@CKTBChartCtrl@@QAEXPBUtagRECT@@H@Z ; CKTBChartCtrl::InvalidateControl

; 160  : 
; 161  : 	// (2006/11/18 - Seung-Won, Bae) Notify the User Zoom State to MultiChart
; 162  : 	OnUserZoomChanged( m_nOnePageDataCount);

  000b3	ff b6 48 02 00
	00		 push	 DWORD PTR [esi+584]
  000b9	8b ce		 mov	 ecx, esi
  000bb	e8 00 00 00 00	 call	 ?OnUserZoomChanged@CKTBChartCtrl@@QAEXH@Z ; CKTBChartCtrl::OnUserZoomChanged
  000c0	5f		 pop	 edi
  000c1	5e		 pop	 esi
  000c2	5b		 pop	 ebx

; 163  : }

  000c3	5d		 pop	 ebp
  000c4	c2 08 00	 ret	 8
?DragZoomIn@CKTBChartCtrl@@IAEXABVCPoint@@0@Z ENDP	; CKTBChartCtrl::DragZoomIn
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\KTBChart\KTBChartScroll.cpp
;	COMDAT ?UpdateZoomAndScrollInfo@CKTBChartCtrl@@UAEXHHH@Z
_TEXT	SEGMENT
_p_nFullRange$ = 8					; size = 4
_p_nStartPos$ = 12					; size = 4
_p_nViewCount$ = 16					; size = 4
?UpdateZoomAndScrollInfo@CKTBChartCtrl@@UAEXHHH@Z PROC	; CKTBChartCtrl::UpdateZoomAndScrollInfo, COMDAT
; _this$ = ecx

; 578  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 579  : 	// (2009/5/19 - Seung-Won, Bae) for Auto Resize of Print and Image Capture
; 580  : 	if( m_bLockScrollUIUpdate) return;

  00006	83 be 0c 06 00
	00 00		 cmp	 DWORD PTR [esi+1548], 0
  0000d	75 58		 jne	 SHORT $LN1@UpdateZoom

; 581  : 
; 582  : 	if( m_pMainBlock) m_pMainBlock->SetDataRegionInBlock2( p_nStartPos, p_nStartPos + p_nViewCount - 1);

  0000f	8b 8e 34 03 00
	00		 mov	 ecx, DWORD PTR [esi+820]
  00015	53		 push	 ebx
  00016	8b 5d 0c	 mov	 ebx, DWORD PTR _p_nStartPos$[ebp]
  00019	57		 push	 edi
  0001a	8b 7d 10	 mov	 edi, DWORD PTR _p_nViewCount$[ebp]
  0001d	85 c9		 test	 ecx, ecx
  0001f	74 0f		 je	 SHORT $LN3@UpdateZoom
  00021	8b 11		 mov	 edx, DWORD PTR [ecx]
  00023	8d 47 ff	 lea	 eax, DWORD PTR [edi-1]
  00026	03 c3		 add	 eax, ebx
  00028	50		 push	 eax
  00029	53		 push	 ebx
  0002a	ff 92 f0 02 00
	00		 call	 DWORD PTR [edx+752]
$LN3@UpdateZoom:

; 583  : 	if( m_pToolBarManager) m_pToolBarManager->UpdateZoomAndScrollInfo( p_nFullRange, p_nStartPos, p_nViewCount, m_bWholeView);

  00030	8b 8e 04 05 00
	00		 mov	 ecx, DWORD PTR [esi+1284]
  00036	8b 55 08	 mov	 edx, DWORD PTR _p_nFullRange$[ebp]
  00039	85 c9		 test	 ecx, ecx
  0003b	74 11		 je	 SHORT $LN4@UpdateZoom
  0003d	ff b6 44 02 00
	00		 push	 DWORD PTR [esi+580]
  00043	8b 01		 mov	 eax, DWORD PTR [ecx]
  00045	57		 push	 edi
  00046	53		 push	 ebx
  00047	52		 push	 edx
  00048	ff 50 50	 call	 DWORD PTR [eax+80]
  0004b	8b 55 08	 mov	 edx, DWORD PTR _p_nFullRange$[ebp]
$LN4@UpdateZoom:

; 584  : 
; 585  : 	// 복수종목의 Total Count를 멀티차트에 알려줌 : 복수종목 - ojtaso (20070704)
; 586  : 	SendEventMsgToDLL( UWM_MULTITOTALCOUNT, 0, p_nFullRange);

  0004e	52		 push	 edx
  0004f	6a 00		 push	 0
  00051	68 47 31 00 00	 push	 12615			; 00003147H
  00056	8b ce		 mov	 ecx, esi
  00058	e8 00 00 00 00	 call	 ?SendEventMsgToDLL@CKTBChartCtrl@@QAEJIIJ@Z ; CKTBChartCtrl::SendEventMsgToDLL

; 587  : 
; 588  : 	// 4. Notify DLL to manage of the user set, the one page data count.
; 589  : 	// (2007/5/23 - Seung-Won, Bae) Notify Data Count with '자료일자' Priority for Special Chart.
; 590  : 	NeoChangeOnePageDataCount( p_nViewCount);

  0005d	57		 push	 edi
  0005e	8b ce		 mov	 ecx, esi
  00060	e8 00 00 00 00	 call	 ?NeoChangeOnePageDataCount@CKTBChartCtrl@@IAEXH@Z ; CKTBChartCtrl::NeoChangeOnePageDataCount
  00065	5f		 pop	 edi
  00066	5b		 pop	 ebx
$LN1@UpdateZoom:
  00067	5e		 pop	 esi

; 591  : }

  00068	5d		 pop	 ebp
  00069	c2 0c 00	 ret	 12			; 0000000cH
?UpdateZoomAndScrollInfo@CKTBChartCtrl@@UAEXHHH@Z ENDP	; CKTBChartCtrl::UpdateZoomAndScrollInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\KTBChart\KTBChartScroll.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\BlockBaseData.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\KTBChart\KTBChartScroll.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\KTBChart\KTBChartScroll.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\KTBChart\KTBChartScroll.cpp
;	COMDAT ?IsScrollInHorzScaleData@CKTBChartCtrl@@ABE_NXZ
_TEXT	SEGMENT
$T2 = -24						; size = 8
_strIndicatorName$ = -16				; size = 4
__$EHRec$ = -12						; size = 12
?IsScrollInHorzScaleData@CKTBChartCtrl@@ABE_NXZ PROC	; CKTBChartCtrl::IsScrollInHorzScaleData, COMDAT
; _this$ = ecx

; 433  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?IsScrollInHorzScaleData@CKTBChartCtrl@@ABE_NXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	53		 push	 ebx
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 434  : 	if(m_pMainBlock == NULL)

  00026	8b 89 34 03 00
	00		 mov	 ecx, DWORD PTR [ecx+820]
  0002c	85 c9		 test	 ecx, ecx
  0002e	75 12		 jne	 SHORT $LN2@IsScrollIn

; 435  : 		return false;

  00030	32 c0		 xor	 al, al

; 442  : }

  00032	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00035	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0003c	59		 pop	 ecx
  0003d	5b		 pop	 ebx
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
$LN2@IsScrollIn:

; 437  : 	CString strIndicatorName = m_pMainBlock->GetIndicatorName(CBlockIndex(0, 0), 0, 0);

  00042	6a 00		 push	 0
  00044	6a 00		 push	 0
  00046	8d 55 e8	 lea	 edx, DWORD PTR $T2[ebp]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\BlockBaseData.h

; 20   : 	CBlockIndex( const int row, const int column)		{	m_nRow = row;	m_nColumn = column;		}

  00049	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0
  00050	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR $T2[ebp+4], 0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\KTBChart\KTBChartScroll.cpp

; 437  : 	CString strIndicatorName = m_pMainBlock->GetIndicatorName(CBlockIndex(0, 0), 0, 0);

  00057	8b 01		 mov	 eax, DWORD PTR [ecx]
  00059	52		 push	 edx
  0005a	8d 55 f0	 lea	 edx, DWORD PTR _strIndicatorName$[ebp]
  0005d	52		 push	 edx
  0005e	ff 90 c8 01 00
	00		 call	 DWORD PTR [eax+456]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h

; 533  : 		return( GetLength() == 0 );

  00064	8b 45 f0	 mov	 eax, DWORD PTR _strIndicatorName$[ebp]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\KTBChart\KTBChartScroll.cpp

; 437  : 	CString strIndicatorName = m_pMainBlock->GetIndicatorName(CBlockIndex(0, 0), 0, 0);

  00067	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h

; 533  : 		return( GetLength() == 0 );

  0006e	83 78 f4 00	 cmp	 DWORD PTR [eax-12], 0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\KTBChart\KTBChartScroll.cpp

; 438  : 	if(strIndicatorName.IsEmpty())

  00072	75 04		 jne	 SHORT $LN3@IsScrollIn
  00074	32 db		 xor	 bl, bl
  00076	eb 0d		 jmp	 SHORT $LN6@IsScrollIn
$LN3@IsScrollIn:

; 439  : 		return false;
; 440  : 
; 441  : 	return g_iMetaTable.IsSpecialGroupGraph(strIndicatorName);

  00078	50		 push	 eax
  00079	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_iMetaTable@@3VIMetaTable@@A ; g_iMetaTable
  0007e	e8 00 00 00 00	 call	 ?IsSpecialGroupGraph@IMetaTable@@QAE_NPBD@Z ; IMetaTable::IsSpecialGroupGraph
  00083	8a d8		 mov	 bl, al
$LN6@IsScrollIn:
  00085	8d 4d f0	 lea	 ecx, DWORD PTR _strIndicatorName$[ebp]
  00088	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0008e	8a c3		 mov	 al, bl

; 442  : }

  00090	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00093	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0009a	59		 pop	 ecx
  0009b	5b		 pop	 ebx
  0009c	8b e5		 mov	 esp, ebp
  0009e	5d		 pop	 ebp
  0009f	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?IsScrollInHorzScaleData@CKTBChartCtrl@@ABE_NXZ$0:
  00000	8d 4d f0	 lea	 ecx, DWORD PTR _strIndicatorName$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
  0000d	cc		 int	 3
__ehhandler$?IsScrollInHorzScaleData@CKTBChartCtrl@@ABE_NXZ:
  0000e	90		 npad	 1
  0000f	90		 npad	 1
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?IsScrollInHorzScaleData@CKTBChartCtrl@@ABE_NXZ
  00026	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?IsScrollInHorzScaleData@CKTBChartCtrl@@ABE_NXZ ENDP	; CKTBChartCtrl::IsScrollInHorzScaleData
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\KTBChart\KTBChartScroll.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\BlockBaseData.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\KTBChart\KTBChartScroll.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\KTBChart\KTBChartScroll.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\KTBChart\KTBChartScroll.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\BlockBaseData.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\KTBChart\KTBChartScroll.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\BlockBaseData.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\KTBChart\KTBChartScroll.cpp
;	COMDAT ?GetFullDataCount@CKTBChartCtrl@@ABEH_N@Z
_TEXT	SEGMENT
$T2 = -28						; size = 8
$T3 = -20						; size = 8
__$EHRec$ = -12						; size = 12
_strIndicatorName$4 = 8					; size = 4
_bIsHorzScaleDataCheck$ = 8				; size = 1
?GetFullDataCount@CKTBChartCtrl@@ABEH_N@Z PROC		; CKTBChartCtrl::GetFullDataCount, COMDAT
; _this$ = ecx

; 417  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?GetFullDataCount@CKTBChartCtrl@@ABEH_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	50		 push	 eax
  0001e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00027	8b f1		 mov	 esi, ecx

; 418  : 	if(m_pPacketList == NULL)

  00029	83 be 3c 03 00
	00 00		 cmp	 DWORD PTR [esi+828], 0
  00030	75 15		 jne	 SHORT $LN2@GetFullDat

; 419  : 		return 0;

  00032	33 c0		 xor	 eax, eax

; 427  : 		return nCount;
; 428  : 
; 429  : 	return m_pPacketList->GetMaxCount();
; 430  : }

  00034	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00037	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0003e	59		 pop	 ecx
  0003f	5e		 pop	 esi
  00040	5b		 pop	 ebx
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
$LN2@GetFullDat:

; 420  : 
; 421  : 	if(!bIsHorzScaleDataCheck || !IsScrollInHorzScaleData())

  00047	80 7d 08 00	 cmp	 BYTE PTR _bIsHorzScaleDataCheck$[ebp], 0
  0004b	0f 84 a7 00 00
	00		 je	 $LN25@GetFullDat

; 434  : 	if(m_pMainBlock == NULL)

  00051	8b 8e 34 03 00
	00		 mov	 ecx, DWORD PTR [esi+820]
  00057	85 c9		 test	 ecx, ecx
  00059	0f 84 99 00 00
	00		 je	 $LN25@GetFullDat

; 437  : 	CString strIndicatorName = m_pMainBlock->GetIndicatorName(CBlockIndex(0, 0), 0, 0);

  0005f	6a 00		 push	 0
  00061	6a 00		 push	 0
  00063	8d 55 ec	 lea	 edx, DWORD PTR $T3[ebp]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\BlockBaseData.h

; 20   : 	CBlockIndex( const int row, const int column)		{	m_nRow = row;	m_nColumn = column;		}

  00066	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR $T3[ebp], 0
  0006d	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T3[ebp+4], 0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\KTBChart\KTBChartScroll.cpp

; 437  : 	CString strIndicatorName = m_pMainBlock->GetIndicatorName(CBlockIndex(0, 0), 0, 0);

  00074	8b 01		 mov	 eax, DWORD PTR [ecx]
  00076	52		 push	 edx
  00077	8d 55 08	 lea	 edx, DWORD PTR _strIndicatorName$4[ebp]
  0007a	52		 push	 edx
  0007b	ff 90 c8 01 00
	00		 call	 DWORD PTR [eax+456]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h

; 519  : 		return( GetData()->nDataLength );

  00081	8b 45 08	 mov	 eax, DWORD PTR _strIndicatorName$4[ebp]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\KTBChart\KTBChartScroll.cpp

; 437  : 	CString strIndicatorName = m_pMainBlock->GetIndicatorName(CBlockIndex(0, 0), 0, 0);

  00084	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h

; 533  : 		return( GetLength() == 0 );

  0008b	83 78 f4 00	 cmp	 DWORD PTR [eax-12], 0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\KTBChart\KTBChartScroll.cpp

; 438  : 	if(strIndicatorName.IsEmpty())

  0008f	75 12		 jne	 SHORT $LN10@GetFullDat

; 439  : 		return false;

  00091	8d 4d 08	 lea	 ecx, DWORD PTR _strIndicatorName$4[ebp]
  00094	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0009b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  000a1	eb 55		 jmp	 SHORT $LN25@GetFullDat
$LN10@GetFullDat:

; 440  : 
; 441  : 	return g_iMetaTable.IsSpecialGroupGraph(strIndicatorName);

  000a3	50		 push	 eax
  000a4	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_iMetaTable@@3VIMetaTable@@A ; g_iMetaTable
  000a9	e8 00 00 00 00	 call	 ?IsSpecialGroupGraph@IMetaTable@@QAE_NPBD@Z ; IMetaTable::IsSpecialGroupGraph
  000ae	8d 4d 08	 lea	 ecx, DWORD PTR _strIndicatorName$4[ebp]
  000b1	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000b8	8a d8		 mov	 bl, al
  000ba	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 420  : 
; 421  : 	if(!bIsHorzScaleDataCheck || !IsScrollInHorzScaleData())

  000c0	84 db		 test	 bl, bl
  000c2	74 34		 je	 SHORT $LN25@GetFullDat

; 425  : 	int nCount = m_pPacketList->GetCount(m_pMainBlock->GetHorzScaleData(CBlockIndex(0, 0)));

  000c4	8b 8e 34 03 00
	00		 mov	 ecx, DWORD PTR [esi+820]
  000ca	8d 55 e4	 lea	 edx, DWORD PTR $T2[ebp]
  000cd	51		 push	 ecx
  000ce	8b c4		 mov	 eax, esp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\BlockBaseData.h

; 20   : 	CBlockIndex( const int row, const int column)		{	m_nRow = row;	m_nColumn = column;		}

  000d0	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\KTBChart\KTBChartScroll.cpp

; 425  : 	int nCount = m_pPacketList->GetCount(m_pMainBlock->GetHorzScaleData(CBlockIndex(0, 0)));

  000d7	52		 push	 edx
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\Include_Chart\BlockBaseData.h

; 20   : 	CBlockIndex( const int row, const int column)		{	m_nRow = row;	m_nColumn = column;		}

  000d8	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T2[ebp+4], 0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\KTBChart\KTBChartScroll.cpp

; 425  : 	int nCount = m_pPacketList->GetCount(m_pMainBlock->GetHorzScaleData(CBlockIndex(0, 0)));

  000df	50		 push	 eax
  000e0	8b 01		 mov	 eax, DWORD PTR [ecx]
  000e2	ff 90 f4 01 00
	00		 call	 DWORD PTR [eax+500]
  000e8	8b 8e 3c 03 00
	00		 mov	 ecx, DWORD PTR [esi+828]
  000ee	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetCount@CPacketList@@QAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z

; 426  : 	if(nCount > 0)

  000f4	85 c0		 test	 eax, eax
  000f6	7f 0c		 jg	 SHORT $LN1@GetFullDat
$LN25@GetFullDat:

; 427  : 		return nCount;
; 428  : 
; 429  : 	return m_pPacketList->GetMaxCount();
; 430  : }

  000f8	8b 8e 3c 03 00
	00		 mov	 ecx, DWORD PTR [esi+828]
  000fe	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetMaxCount@CPacketList@@QAEHXZ
$LN1@GetFullDat:
  00104	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00107	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0010e	59		 pop	 ecx
  0010f	5e		 pop	 esi
  00110	5b		 pop	 ebx
  00111	8b e5		 mov	 esp, ebp
  00113	5d		 pop	 ebp
  00114	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetFullDataCount@CKTBChartCtrl@@ABEH_N@Z$1:
  00000	8d 4d 08	 lea	 ecx, DWORD PTR _strIndicatorName$4[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
  0000d	cc		 int	 3
__ehhandler$?GetFullDataCount@CKTBChartCtrl@@ABEH_N@Z:
  0000e	90		 npad	 1
  0000f	90		 npad	 1
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?GetFullDataCount@CKTBChartCtrl@@ABEH_N@Z
  00026	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?GetFullDataCount@CKTBChartCtrl@@ABEH_N@Z ENDP		; CKTBChartCtrl::GetFullDataCount
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\KTBChart\KTBChartScroll.cpp
;	COMDAT ?SetWholeView@CKTBChartCtrl@@QAEXH@Z
_TEXT	SEGMENT
_bWholeView$ = 8					; size = 4
?SetWholeView@CKTBChartCtrl@@QAEXH@Z PROC		; CKTBChartCtrl::SetWholeView, COMDAT
; _this$ = ecx

; 205  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 206  : 	if( m_bWholeView && bWholeView
; 207  : 		|| !m_bWholeView && !bWholeView) return;

  00004	8b 75 08	 mov	 esi, DWORD PTR _bWholeView$[ebp]
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
  0000a	83 bf 44 02 00
	00 00		 cmp	 DWORD PTR [edi+580], 0
  00011	74 06		 je	 SHORT $LN8@SetWholeVi
  00013	85 f6		 test	 esi, esi
  00015	75 58		 jne	 SHORT $LN1@SetWholeVi
  00017	eb 04		 jmp	 SHORT $LN2@SetWholeVi
$LN8@SetWholeVi:
  00019	85 f6		 test	 esi, esi
  0001b	74 52		 je	 SHORT $LN1@SetWholeVi
$LN2@SetWholeVi:

; 208  : 
; 209  : 	// 1. Get Start and End DRI
; 210  : 	int nStartDRIOfView = 0;
; 211  : 	int nEndDRIOfView = m_pxScaleManager->GetCount() - 1;

  0001d	8b 8f 38 03 00
	00		 mov	 ecx, DWORD PTR [edi+824]
  00023	53		 push	 ebx
  00024	33 db		 xor	 ebx, ebx
  00026	8b 01		 mov	 eax, DWORD PTR [ecx]
  00028	ff 90 84 00 00
	00		 call	 DWORD PTR [eax+132]
  0002e	8d 50 ff	 lea	 edx, DWORD PTR [eax-1]

; 212  : 	if( !bWholeView) nStartDRIOfView = nEndDRIOfView - m_nOnePageDataCount + 1;

  00031	85 f6		 test	 esi, esi
  00033	75 09		 jne	 SHORT $LN9@SetWholeVi
  00035	8b da		 mov	 ebx, edx
  00037	2b 9f 48 02 00
	00		 sub	 ebx, DWORD PTR [edi+584]
  0003d	43		 inc	 ebx
$LN9@SetWholeVi:

; 213  : 
; 214  : 	// 2. Update Info.
; 215  : 	// 2.1 Update WholeView option.
; 216  : 	m_bWholeView = bWholeView;
; 217  : 
; 218  : 	// 3. Update X Scale Manager
; 219  : 	m_pxScaleManager->SetStartEndDrawIdx_Cur( nStartDRIOfView, nEndDRIOfView);

  0003e	8b 8f 38 03 00
	00		 mov	 ecx, DWORD PTR [edi+824]
  00044	6a 00		 push	 0
  00046	89 b7 44 02 00
	00		 mov	 DWORD PTR [edi+580], esi
  0004c	52		 push	 edx
  0004d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0004f	53		 push	 ebx
  00050	ff 90 94 00 00
	00		 call	 DWORD PTR [eax+148]

; 220  : 
; 221  : 	// 5. Update View
; 222  : 	InvalidateControl();

  00056	6a 01		 push	 1
  00058	6a 00		 push	 0
  0005a	8b cf		 mov	 ecx, edi
  0005c	e8 00 00 00 00	 call	 ?InvalidateControl@CKTBChartCtrl@@QAEXPBUtagRECT@@H@Z ; CKTBChartCtrl::InvalidateControl

; 223  : 
; 224  : 	// (2009/5/12 - Seung-Won, Bae) for Fixed Item Width
; 225  : 	OnUserZoomChanged( m_nOnePageDataCount);

  00061	ff b7 48 02 00
	00		 push	 DWORD PTR [edi+584]
  00067	8b cf		 mov	 ecx, edi
  00069	e8 00 00 00 00	 call	 ?OnUserZoomChanged@CKTBChartCtrl@@QAEXH@Z ; CKTBChartCtrl::OnUserZoomChanged
  0006e	5b		 pop	 ebx
$LN1@SetWholeVi:

; 226  : }

  0006f	5f		 pop	 edi
  00070	5e		 pop	 esi
  00071	5d		 pop	 ebp
  00072	c2 04 00	 ret	 4
?SetWholeView@CKTBChartCtrl@@QAEXH@Z ENDP		; CKTBChartCtrl::SetWholeView
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\KTBChart\KTBChartScroll.cpp
;	COMDAT ?ScrollTo@CKTBChartCtrl@@QAEHHH@Z
_TEXT	SEGMENT
_p_nScrollValue$ = 8					; size = 4
_p_bRelative$ = 12					; size = 4
?ScrollTo@CKTBChartCtrl@@QAEHHH@Z PROC			; CKTBChartCtrl::ScrollTo, COMDAT
; _this$ = ecx

; 26   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 27   : 	// 0. Check WholeView
; 28   : 	if( m_bWholeView) return FALSE;

  00006	83 be 44 02 00
	00 00		 cmp	 DWORD PTR [esi+580], 0
  0000d	74 07		 je	 SHORT $LN2@ScrollTo
  0000f	33 c0		 xor	 eax, eax
  00011	5e		 pop	 esi

; 50   : }

  00012	5d		 pop	 ebp
  00013	c2 08 00	 ret	 8
$LN2@ScrollTo:

; 29   : 
; 30   : 	// 1. Get Start and End DRI
; 31   : 	// 1.0 Get Base DRI
; 32   : 	int nStartDRIOfView	= p_nScrollValue;
; 33   : 	int nEndDRIOfView	= p_nScrollValue + m_pxScaleManager->GetDrawCount_Cur() - 1;

  00016	8b 8e 38 03 00
	00		 mov	 ecx, DWORD PTR [esi+824]
  0001c	53		 push	 ebx
  0001d	57		 push	 edi
  0001e	8b 7d 08	 mov	 edi, DWORD PTR _p_nScrollValue$[ebp]
  00021	8b 01		 mov	 eax, DWORD PTR [ecx]
  00023	ff 90 88 00 00
	00		 call	 DWORD PTR [eax+136]
  00029	8d 5f ff	 lea	 ebx, DWORD PTR [edi-1]
  0002c	03 d8		 add	 ebx, eax

; 34   : 	// 1.1 Update Relative
; 35   : 	if( p_bRelative)

  0002e	83 7d 0c 00	 cmp	 DWORD PTR _p_bRelative$[ebp], 0
  00032	74 20		 je	 SHORT $LN3@ScrollTo

; 36   : 	{
; 37   : 		nStartDRIOfView	+= m_pxScaleManager->GetStartDrawIdx_Cur();

  00034	8b 8e 38 03 00
	00		 mov	 ecx, DWORD PTR [esi+824]
  0003a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0003c	ff 90 8c 00 00
	00		 call	 DWORD PTR [eax+140]

; 38   : 		nEndDRIOfView	+= m_pxScaleManager->GetStartDrawIdx_Cur();

  00042	8b 8e 38 03 00
	00		 mov	 ecx, DWORD PTR [esi+824]
  00048	03 f8		 add	 edi, eax
  0004a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0004c	ff 90 8c 00 00
	00		 call	 DWORD PTR [eax+140]
  00052	03 d8		 add	 ebx, eax
$LN3@ScrollTo:

; 39   : 	}
; 40   : 
; 41   : 	// 2. Do not update managed Info.
; 42   : 
; 43   : 	// 3. Update X Scale Manager
; 44   : 	m_pxScaleManager->SetStartEndDrawIdx_Cur( nStartDRIOfView, nEndDRIOfView);

  00054	8b 8e 38 03 00
	00		 mov	 ecx, DWORD PTR [esi+824]
  0005a	6a 00		 push	 0
  0005c	53		 push	 ebx
  0005d	57		 push	 edi
  0005e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00060	ff 90 94 00 00
	00		 call	 DWORD PTR [eax+148]

; 45   : 
; 46   : 	// 5. Update View
; 47   : 	InvalidateControl();

  00066	6a 01		 push	 1
  00068	6a 00		 push	 0
  0006a	8b ce		 mov	 ecx, esi
  0006c	e8 00 00 00 00	 call	 ?InvalidateControl@CKTBChartCtrl@@QAEXPBUtagRECT@@H@Z ; CKTBChartCtrl::InvalidateControl

; 48   : 
; 49   : 	return TRUE;

  00071	5f		 pop	 edi
  00072	5b		 pop	 ebx
  00073	b8 01 00 00 00	 mov	 eax, 1
  00078	5e		 pop	 esi

; 50   : }

  00079	5d		 pop	 ebp
  0007a	c2 08 00	 ret	 8
?ScrollTo@CKTBChartCtrl@@QAEHHH@Z ENDP			; CKTBChartCtrl::ScrollTo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\KTBChart\KTBChartScroll.cpp
;	COMDAT ?GetDataStartEnd@CKTBChartCtrl@@QAEHAAH0@Z
_TEXT	SEGMENT
_p_nStartIndex$ = 8					; size = 4
_p_nEndIndex$ = 12					; size = 4
?GetDataStartEnd@CKTBChartCtrl@@QAEHAAH0@Z PROC		; CKTBChartCtrl::GetDataStartEnd, COMDAT
; _this$ = ecx

; 479  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 480  : 	// 0. 처리 환경을 확인한다.
; 481  : 	if( !m_pToolBarManager || !m_pMainBlock) return FALSE;

  00006	83 be 04 05 00
	00 00		 cmp	 DWORD PTR [esi+1284], 0
  0000d	0f 84 c4 00 00
	00		 je	 $LN3@GetDataSta
  00013	83 be 34 03 00
	00 00		 cmp	 DWORD PTR [esi+820], 0
  0001a	0f 84 b7 00 00
	00		 je	 $LN3@GetDataSta

; 482  : 
; 483  : 	// 1. 먼저 전체 보기인 경우를 Check 한다.
; 484  : 	if( IsWholeView())

  00020	8b 06		 mov	 eax, DWORD PTR [esi]
  00022	8b 80 08 03 00
	00		 mov	 eax, DWORD PTR [eax+776]
  00028	ff d0		 call	 eax
  0002a	84 c0		 test	 al, al
  0002c	74 1e		 je	 SHORT $LN4@GetDataSta

; 485  : 	{
; 486  : 		m_pMainBlock->GetDisplayDataIndex( p_nStartIndex, p_nEndIndex);

  0002e	8b 8e 34 03 00
	00		 mov	 ecx, DWORD PTR [esi+820]
  00034	ff 75 0c	 push	 DWORD PTR _p_nEndIndex$[ebp]
  00037	ff 75 08	 push	 DWORD PTR _p_nStartIndex$[ebp]
  0003a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0003c	ff 90 b0 01 00
	00		 call	 DWORD PTR [eax+432]

; 487  : 		// 1.1 GetDisplayDataIndex()는 0 Base로 조회하여 조정한다.
; 488  : //		p_nStartIndex++;
; 489  : //		p_nEndIndex++;
; 490  : 		return TRUE;

  00042	b8 01 00 00 00	 mov	 eax, 1
  00047	5e		 pop	 esi

; 524  : }

  00048	5d		 pop	 ebp
  00049	c2 08 00	 ret	 8
$LN4@GetDataSta:
  0004c	53		 push	 ebx
  0004d	57		 push	 edi

; 491  : 	}
; 492  : 
; 493  : 	// 2. ScrollBar를 통하여 Scrolling을 처리하는 경우를 확인한다.
; 494  : 	// 종찬(04/11/16) 조건문 수정
; 495  : 	if(IsUseToolScrollBar())

  0004e	8b ce		 mov	 ecx, esi
  00050	e8 00 00 00 00	 call	 ?IsUseToolScrollBar@CKTBChartCtrl@@AAE_NXZ ; CKTBChartCtrl::IsUseToolScrollBar
  00055	8b 7d 0c	 mov	 edi, DWORD PTR _p_nEndIndex$[ebp]
  00058	8b 5d 08	 mov	 ebx, DWORD PTR _p_nStartIndex$[ebp]
  0005b	84 c0		 test	 al, al
  0005d	74 5c		 je	 SHORT $LN6@GetDataSta

; 496  : 	if( m_pToolBarManager->GetStartEndIndex(p_nStartIndex, p_nEndIndex))

  0005f	8b 8e 04 05 00
	00		 mov	 ecx, DWORD PTR [esi+1284]
  00065	57		 push	 edi
  00066	53		 push	 ebx
  00067	8b 01		 mov	 eax, DWORD PTR [ecx]
  00069	8b 40 28	 mov	 eax, DWORD PTR [eax+40]
  0006c	ff d0		 call	 eax
  0006e	84 c0		 test	 al, al
  00070	74 49		 je	 SHORT $LN6@GetDataSta

; 497  : 	{
; 498  : 		// (2004.07.01, 배승원) Index값이 잘못 조회되어 나오는 경우를 대비한다.
; 499  : 		if( p_nStartIndex < 0 || p_nEndIndex < 0 || p_nEndIndex < p_nStartIndex || (p_nStartIndex == 0 && p_nEndIndex == 0))

  00072	8b 03		 mov	 eax, DWORD PTR [ebx]
  00074	85 c0		 test	 eax, eax
  00076	78 12		 js	 SHORT $LN8@GetDataSta
  00078	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0007a	85 c9		 test	 ecx, ecx
  0007c	78 0c		 js	 SHORT $LN8@GetDataSta
  0007e	3b c8		 cmp	 ecx, eax
  00080	7c 08		 jl	 SHORT $LN8@GetDataSta
  00082	85 c0		 test	 eax, eax
  00084	75 45		 jne	 SHORT $LN10@GetDataSta
  00086	85 c9		 test	 ecx, ecx
  00088	75 41		 jne	 SHORT $LN10@GetDataSta
$LN8@GetDataSta:

; 500  : 		{
; 501  : 			//sy 2004.09.15.
; 502  : 			//-> Map에 스크롤이 없을 경우 start, end 를 0 로 넘기기 때문에
; 503  : 			//   올바른 start, end를 가져올수 없다.
; 504  : 			//   이때 MainBlock에서 정보를 가져온다.
; 505  : 			m_pMainBlock->GetDisplayDataIndex(p_nStartIndex, p_nEndIndex);

  0008a	8b 8e 34 03 00
	00		 mov	 ecx, DWORD PTR [esi+820]
  00090	57		 push	 edi
  00091	53		 push	 ebx
  00092	8b 01		 mov	 eax, DWORD PTR [ecx]
  00094	ff 90 b0 01 00
	00		 call	 DWORD PTR [eax+432]

; 506  : //			if(p_nStartIndex >= 0)
; 507  : //				p_nStartIndex++;
; 508  : //			if(p_nEndIndex >= 0)
; 509  : //				p_nEndIndex++;
; 510  : 			return (p_nStartIndex < 0 || p_nEndIndex < 0 || p_nEndIndex < p_nStartIndex || (p_nStartIndex == 0 && p_nEndIndex == 0));

  0009a	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0009c	85 c9		 test	 ecx, ecx
  0009e	78 2b		 js	 SHORT $LN10@GetDataSta
  000a0	8b 07		 mov	 eax, DWORD PTR [edi]
  000a2	85 c0		 test	 eax, eax
  000a4	78 25		 js	 SHORT $LN10@GetDataSta
  000a6	3b c1		 cmp	 eax, ecx
  000a8	7c 21		 jl	 SHORT $LN10@GetDataSta
  000aa	85 c9		 test	 ecx, ecx
  000ac	75 04		 jne	 SHORT $LN11@GetDataSta
  000ae	85 c0		 test	 eax, eax
  000b0	74 19		 je	 SHORT $LN10@GetDataSta
$LN11@GetDataSta:
  000b2	5f		 pop	 edi
  000b3	5b		 pop	 ebx
  000b4	33 c0		 xor	 eax, eax
  000b6	5e		 pop	 esi

; 524  : }

  000b7	5d		 pop	 ebp
  000b8	c2 08 00	 ret	 8
$LN6@GetDataSta:

; 511  : 			//sy end
; 512  : 		}
; 513  : 		return TRUE;
; 514  : 	}
; 515  : 
; 516  : 	// 3. ScrollBar 없이 없는 경우, 직접 Scrolling을 처리한다.
; 517  : 	m_pMainBlock->GetDisplayDataIndex( p_nStartIndex, p_nEndIndex);

  000bb	8b 8e 34 03 00
	00		 mov	 ecx, DWORD PTR [esi+820]
  000c1	57		 push	 edi
  000c2	53		 push	 ebx
  000c3	8b 01		 mov	 eax, DWORD PTR [ecx]
  000c5	ff 90 b0 01 00
	00		 call	 DWORD PTR [eax+432]
$LN10@GetDataSta:

; 518  : 	// 종찬(04/09/20) ScrollBar쪽도 0 Base로 바꿈.
; 519  : //	if(p_nStartIndex >= 0)
; 520  : //		p_nStartIndex++;
; 521  : //	if(p_nEndIndex >= 0)
; 522  : //		p_nEndIndex++;
; 523  : 	return TRUE;

  000cb	5f		 pop	 edi
  000cc	5b		 pop	 ebx
  000cd	b8 01 00 00 00	 mov	 eax, 1
  000d2	5e		 pop	 esi

; 524  : }

  000d3	5d		 pop	 ebp
  000d4	c2 08 00	 ret	 8
$LN3@GetDataSta:

; 480  : 	// 0. 처리 환경을 확인한다.
; 481  : 	if( !m_pToolBarManager || !m_pMainBlock) return FALSE;

  000d7	33 c0		 xor	 eax, eax
  000d9	5e		 pop	 esi

; 524  : }

  000da	5d		 pop	 ebp
  000db	c2 08 00	 ret	 8
?GetDataStartEnd@CKTBChartCtrl@@QAEHAAH0@Z ENDP		; CKTBChartCtrl::GetDataStartEnd
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\KTBChart\KTBChartScroll.cpp
;	COMDAT ?GetScrollRange@CKTBChartCtrl@@QAEHAAH@Z
_TEXT	SEGMENT
_nStartIndex$1 = 8					; size = 4
_p_nRange$ = 8						; size = 4
?GetScrollRange@CKTBChartCtrl@@QAEHAAH@Z PROC		; CKTBChartCtrl::GetScrollRange, COMDAT
; _this$ = ecx

; 452  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 453  : 	// 0. 처리 환경을 확인한다.
; 454  : 	if( !m_pToolBarManager || !m_pMainBlock) return FALSE;

  00006	83 be 04 05 00
	00 00		 cmp	 DWORD PTR [esi+1284], 0
  0000d	74 4d		 je	 SHORT $LN3@GetScrollR
  0000f	83 be 34 03 00
	00 00		 cmp	 DWORD PTR [esi+820], 0
  00016	74 44		 je	 SHORT $LN3@GetScrollR

; 455  : 
; 456  : 	// 1. 먼저 전체 보기인 경우를 Check 한다.
; 457  : 	if( IsWholeView())

  00018	8b 06		 mov	 eax, DWORD PTR [esi]
  0001a	8b 80 08 03 00
	00		 mov	 eax, DWORD PTR [eax+776]
  00020	ff d0		 call	 eax
  00022	84 c0		 test	 al, al
  00024	74 1f		 je	 SHORT $LN4@GetScrollR

; 458  : 	{
; 459  : 		int nStartIndex;
; 460  : 		m_pMainBlock->GetDisplayDataIndex( nStartIndex, p_nRange);

  00026	8b 8e 34 03 00
	00		 mov	 ecx, DWORD PTR [esi+820]
  0002c	8d 55 08	 lea	 edx, DWORD PTR _nStartIndex$1[ebp]
  0002f	ff 75 08	 push	 DWORD PTR _p_nRange$[ebp]
  00032	52		 push	 edx
  00033	8b 01		 mov	 eax, DWORD PTR [ecx]
  00035	ff 90 b0 01 00
	00		 call	 DWORD PTR [eax+432]

; 461  : 		// 1.1 GetDisplayDataIndex()는 0 Base로 조회하여 조정한다.
; 462  : 		// 종찬(04/09/20) 미니툴바의 Scroll부분도 0 Base이므로 그대로 보낸다.
; 463  : //		p_nRange++;
; 464  : 		return TRUE;

  0003b	b8 01 00 00 00	 mov	 eax, 1
  00040	5e		 pop	 esi

; 474  : }

  00041	5d		 pop	 ebp
  00042	c2 04 00	 ret	 4
$LN4@GetScrollR:

; 465  : 	}
; 466  : 
; 467  : 	// 2. ScrollBar를 통하여 Scrolling을 처리하는 경우를 확인한다.
; 468  : 	// 종찬(04/11/16) MaxRange 구해오는 함수를 제공하므로 그걸 사용함.
; 469  : 	p_nRange = GetMaxRange();

  00045	8b ce		 mov	 ecx, esi
  00047	e8 00 00 00 00	 call	 ?GetMaxRange@CKTBChartCtrl@@QAEHXZ ; CKTBChartCtrl::GetMaxRange

; 470  : 	// 종찬(04/09/20) 미니툴바의 Scroll부분도 0 Base이므로 한개를 빼서...
; 471  : 	p_nRange--;

  0004c	8b 4d 08	 mov	 ecx, DWORD PTR _p_nRange$[ebp]
  0004f	48		 dec	 eax
  00050	5e		 pop	 esi
  00051	89 01		 mov	 DWORD PTR [ecx], eax

; 472  : 
; 473  : 	return TRUE;

  00053	b8 01 00 00 00	 mov	 eax, 1

; 474  : }

  00058	5d		 pop	 ebp
  00059	c2 04 00	 ret	 4
$LN3@GetScrollR:

; 453  : 	// 0. 처리 환경을 확인한다.
; 454  : 	if( !m_pToolBarManager || !m_pMainBlock) return FALSE;

  0005c	33 c0		 xor	 eax, eax
  0005e	5e		 pop	 esi

; 474  : }

  0005f	5d		 pop	 ebp
  00060	c2 04 00	 ret	 4
?GetScrollRange@CKTBChartCtrl@@QAEHAAH@Z ENDP		; CKTBChartCtrl::GetScrollRange
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\KTBChart\KTBChartScroll.cpp
;	COMDAT ?GetOnePageDataCountForScroll@CKTBChartCtrl@@QBEHXZ
_TEXT	SEGMENT
?GetOnePageDataCountForScroll@CKTBChartCtrl@@QBEHXZ PROC ; CKTBChartCtrl::GetOnePageDataCountForScroll, COMDAT
; _this$ = ecx

; 406  : 	//오른쪽 여백 봉수 포함하지 않은 경우.
; 407  : //	if(!m_bIncludeBongCountMargin && m_nBongCountMargin > 0)
; 408  : //	{
; 409  : //		return (m_nOnePageDataCount + m_nBongCountMargin);
; 410  : //	}
; 411  : 
; 412  : 	return m_nOnePageDataCount;

  00000	8b 81 48 02 00
	00		 mov	 eax, DWORD PTR [ecx+584]

; 413  : }

  00006	c3		 ret	 0
?GetOnePageDataCountForScroll@CKTBChartCtrl@@QBEHXZ ENDP ; CKTBChartCtrl::GetOnePageDataCountForScroll
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\KTBChart\KTBChartScroll.cpp
;	COMDAT ?ResetScroll@CKTBChartCtrl@@QAEXH@Z
_TEXT	SEGMENT
_p_bWithCalcDRI$ = 8					; size = 4
?ResetScroll@CKTBChartCtrl@@QAEXH@Z PROC		; CKTBChartCtrl::ResetScroll, COMDAT
; _this$ = ecx

; 596  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 597  : 	if( !m_pxScaleManager) return;

  00006	8b 8e 38 03 00
	00		 mov	 ecx, DWORD PTR [esi+824]
  0000c	85 c9		 test	 ecx, ecx
  0000e	74 59		 je	 SHORT $LN1@ResetScrol

; 598  : 	if( p_bWithCalcDRI) m_pxScaleManager->Calc_DRI();

  00010	83 7d 08 00	 cmp	 DWORD PTR _p_bWithCalcDRI$[ebp], 0
  00014	74 0d		 je	 SHORT $LN3@ResetScrol
  00016	8b 01		 mov	 eax, DWORD PTR [ecx]
  00018	6a 01		 push	 1
  0001a	ff 50 6c	 call	 DWORD PTR [eax+108]
  0001d	8b 8e 38 03 00
	00		 mov	 ecx, DWORD PTR [esi+824]
$LN3@ResetScrol:

; 599  : 
; 600  : 	// assume that Calc_DRI() was finished.
; 601  : 	// 1. Get Start and End DRI
; 602  : 	int nEndDRIOfView = m_pxScaleManager->GetCount() - 1;

  00023	8b 01		 mov	 eax, DWORD PTR [ecx]
  00025	57		 push	 edi
  00026	ff 90 84 00 00
	00		 call	 DWORD PTR [eax+132]
  0002c	8d 78 ff	 lea	 edi, DWORD PTR [eax-1]

; 603  : 	int nStartDRIOfView = nEndDRIOfView - m_nOnePageDataCount + 1;

  0002f	8b d7		 mov	 edx, edi
  00031	2b 96 48 02 00
	00		 sub	 edx, DWORD PTR [esi+584]
  00037	42		 inc	 edx

; 604  : 	if( m_bWholeView || nStartDRIOfView < 0) nStartDRIOfView = 0;

  00038	83 be 44 02 00
	00 00		 cmp	 DWORD PTR [esi+580], 0
  0003f	75 04		 jne	 SHORT $LN5@ResetScrol
  00041	85 d2		 test	 edx, edx
  00043	79 02		 jns	 SHORT $LN4@ResetScrol
$LN5@ResetScrol:
  00045	33 d2		 xor	 edx, edx
$LN4@ResetScrol:

; 605  : 	if( 0 <= nEndDRIOfView) m_pxScaleManager->SetStartEndDrawIdx_Cur( nStartDRIOfView, nEndDRIOfView);

  00047	85 ff		 test	 edi, edi
  00049	78 12		 js	 SHORT $LN6@ResetScrol
  0004b	8b 8e 38 03 00
	00		 mov	 ecx, DWORD PTR [esi+824]
  00051	6a 00		 push	 0
  00053	57		 push	 edi
  00054	52		 push	 edx
  00055	8b 01		 mov	 eax, DWORD PTR [ecx]
  00057	ff 90 94 00 00
	00		 call	 DWORD PTR [eax+148]
$LN6@ResetScrol:

; 606  : 	
; 607  : 	InvalidateControl();

  0005d	6a 01		 push	 1
  0005f	6a 00		 push	 0
  00061	8b ce		 mov	 ecx, esi
  00063	e8 00 00 00 00	 call	 ?InvalidateControl@CKTBChartCtrl@@QAEXPBUtagRECT@@H@Z ; CKTBChartCtrl::InvalidateControl
  00068	5f		 pop	 edi
$LN1@ResetScrol:
  00069	5e		 pop	 esi

; 608  : }

  0006a	5d		 pop	 ebp
  0006b	c2 04 00	 ret	 4
?ResetScroll@CKTBChartCtrl@@QAEXH@Z ENDP		; CKTBChartCtrl::ResetScroll
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\KTBChart\KTBChartScroll.cpp
;	COMDAT ?SetScrollPosToNextPage@CKTBChartCtrl@@QAEHH@Z
_TEXT	SEGMENT
_p_bBackward$ = 8					; size = 4
?SetScrollPosToNextPage@CKTBChartCtrl@@QAEHH@Z PROC	; CKTBChartCtrl::SetScrollPosToNextPage, COMDAT
; _this$ = ecx

; 272  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	57		 push	 edi

; 273  : 	int nScrollPos = m_pxScaleManager->GetStartDrawIdx_Cur();

  00008	8b 8e 38 03 00
	00		 mov	 ecx, DWORD PTR [esi+824]
  0000e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00010	ff 90 8c 00 00
	00		 call	 DWORD PTR [eax+140]

; 274  : 	int nPrevScrollPos = nScrollPos;
; 275  : 	int nDrawCount = m_pxScaleManager->GetDrawCount_Cur();

  00016	8b 8e 38 03 00
	00		 mov	 ecx, DWORD PTR [esi+824]
  0001c	8b d8		 mov	 ebx, eax
  0001e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00020	ff 92 88 00 00
	00		 call	 DWORD PTR [edx+136]

; 28   : 	if( m_bWholeView) return FALSE;

  00026	8b fb		 mov	 edi, ebx
  00028	2b f8		 sub	 edi, eax
  0002a	83 7d 08 00	 cmp	 DWORD PTR _p_bBackward$[ebp], 0
  0002e	8d 0c 18	 lea	 ecx, DWORD PTR [eax+ebx]
  00031	0f 44 f9	 cmove	 edi, ecx
  00034	83 be 44 02 00
	00 00		 cmp	 DWORD PTR [esi+580], 0
  0003b	75 2e		 jne	 SHORT $LN5@SetScrollP

; 29   : 
; 30   : 	// 1. Get Start and End DRI
; 31   : 	// 1.0 Get Base DRI
; 32   : 	int nStartDRIOfView	= p_nScrollValue;
; 33   : 	int nEndDRIOfView	= p_nScrollValue + m_pxScaleManager->GetDrawCount_Cur() - 1;

  0003d	8b 8e 38 03 00
	00		 mov	 ecx, DWORD PTR [esi+824]
  00043	8b 01		 mov	 eax, DWORD PTR [ecx]
  00045	ff 90 88 00 00
	00		 call	 DWORD PTR [eax+136]

; 34   : 	// 1.1 Update Relative
; 35   : 	if( p_bRelative)
; 36   : 	{
; 37   : 		nStartDRIOfView	+= m_pxScaleManager->GetStartDrawIdx_Cur();
; 38   : 		nEndDRIOfView	+= m_pxScaleManager->GetStartDrawIdx_Cur();
; 39   : 	}
; 40   : 
; 41   : 	// 2. Do not update managed Info.
; 42   : 
; 43   : 	// 3. Update X Scale Manager
; 44   : 	m_pxScaleManager->SetStartEndDrawIdx_Cur( nStartDRIOfView, nEndDRIOfView);

  0004b	8b 8e 38 03 00
	00		 mov	 ecx, DWORD PTR [esi+824]
  00051	48		 dec	 eax
  00052	6a 00		 push	 0
  00054	03 c7		 add	 eax, edi
  00056	50		 push	 eax
  00057	8b 11		 mov	 edx, DWORD PTR [ecx]
  00059	57		 push	 edi
  0005a	ff 92 94 00 00
	00		 call	 DWORD PTR [edx+148]

; 45   : 
; 46   : 	// 5. Update View
; 47   : 	InvalidateControl();

  00060	6a 01		 push	 1
  00062	6a 00		 push	 0
  00064	8b ce		 mov	 ecx, esi
  00066	e8 00 00 00 00	 call	 ?InvalidateControl@CKTBChartCtrl@@QAEXPBUtagRECT@@H@Z ; CKTBChartCtrl::InvalidateControl
$LN5@SetScrollP:

; 276  : 
; 277  : 	if( p_bBackward)	nScrollPos -= nDrawCount;
; 278  : 	else				nScrollPos += nDrawCount;
; 279  : 	ScrollTo( nScrollPos, FALSE);
; 280  : 
; 281  : 	int nNextScrollPos = m_pxScaleManager->GetStartDrawIdx_Cur();

  0006b	8b 8e 38 03 00
	00		 mov	 ecx, DWORD PTR [esi+824]
  00071	8b 01		 mov	 eax, DWORD PTR [ecx]
  00073	ff 90 8c 00 00
	00		 call	 DWORD PTR [eax+140]

; 282  : 	return nNextScrollPos != nPrevScrollPos;

  00079	33 c9		 xor	 ecx, ecx
  0007b	3b c3		 cmp	 eax, ebx
  0007d	5f		 pop	 edi
  0007e	0f 95 c1	 setne	 cl
  00081	5e		 pop	 esi
  00082	8b c1		 mov	 eax, ecx
  00084	5b		 pop	 ebx

; 283  : }

  00085	5d		 pop	 ebp
  00086	c2 04 00	 ret	 4
?SetScrollPosToNextPage@CKTBChartCtrl@@QAEHH@Z ENDP	; CKTBChartCtrl::SetScrollPosToNextPage
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\KTBChart\KTBChartScroll.cpp
;	COMDAT ?GetCurrentScrollPos@CKTBChartCtrl@@QAEHXZ
_TEXT	SEGMENT
?GetCurrentScrollPos@CKTBChartCtrl@@QAEHXZ PROC		; CKTBChartCtrl::GetCurrentScrollPos, COMDAT
; _this$ = ecx

; 286  : 	return m_pxScaleManager->GetStartDrawIdx_Cur();

  00000	8b 89 38 03 00
	00		 mov	 ecx, DWORD PTR [ecx+824]
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]
  00008	ff a0 8c 00 00
	00		 jmp	 DWORD PTR [eax+140]
?GetCurrentScrollPos@CKTBChartCtrl@@QAEHXZ ENDP		; CKTBChartCtrl::GetCurrentScrollPos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\KTBChart\KTBChartScroll.cpp
;	COMDAT ?ZoomTo@CKTBChartCtrl@@IAEHJH@Z
_TEXT	SEGMENT
tv500 = -4						; size = 4
tv502 = 8						; size = 4
_p_nZoomValue$ = 8					; size = 4
_p_bRelative$ = 12					; size = 4
?ZoomTo@CKTBChartCtrl@@IAEHJH@Z PROC			; CKTBChartCtrl::ZoomTo, COMDAT
; _this$ = ecx

; 56   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	8b f9		 mov	 edi, ecx

; 57   : 	if( !m_pxScaleManager) return FALSE;

  00009	83 bf 38 03 00
	00 00		 cmp	 DWORD PTR [edi+824], 0
  00010	0f 84 42 01 00
	00		 je	 $LN14@ZoomTo

; 58   : 
; 59   : 	// TODO: Add your dispatch handler code here
; 60   : 	if( IsRunningNoZoomChart() && p_nZoomValue != m_pxScaleManager->GetCount()) return FALSE;

  00016	e8 00 00 00 00	 call	 ?IsRunningNoZoomChart@CKTBChartCtrl@@QAEHXZ ; CKTBChartCtrl::IsRunningNoZoomChart
  0001b	85 c0		 test	 eax, eax
  0001d	74 17		 je	 SHORT $LN3@ZoomTo
  0001f	8b 8f 38 03 00
	00		 mov	 ecx, DWORD PTR [edi+824]
  00025	8b 01		 mov	 eax, DWORD PTR [ecx]
  00027	ff 90 84 00 00
	00		 call	 DWORD PTR [eax+132]
  0002d	39 45 08	 cmp	 DWORD PTR _p_nZoomValue$[ebp], eax
  00030	0f 85 22 01 00
	00		 jne	 $LN14@ZoomTo
$LN3@ZoomTo:

; 61   : 
; 62   : 	// 1. Get Start and End DRI
; 63   : 	// 1.0 Get Base DRI
; 64   : 	int nStartDRIOfView	= m_pxScaleManager->GetStartDrawIdx_Cur();

  00036	8b 8f 38 03 00
	00		 mov	 ecx, DWORD PTR [edi+824]
  0003c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0003e	ff 90 8c 00 00
	00		 call	 DWORD PTR [eax+140]

; 65   : 	int nEndDRIOfView	= m_pxScaleManager->GetStartDrawIdx_Cur() + m_pxScaleManager->GetDrawCount_Cur() - 1;

  00044	8b 8f 38 03 00
	00		 mov	 ecx, DWORD PTR [edi+824]
  0004a	8b d8		 mov	 ebx, eax
  0004c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0004e	ff 92 8c 00 00
	00		 call	 DWORD PTR [edx+140]
  00054	8b 8f 38 03 00
	00		 mov	 ecx, DWORD PTR [edi+824]
  0005a	8d 70 ff	 lea	 esi, DWORD PTR [eax-1]
  0005d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0005f	ff 92 88 00 00
	00		 call	 DWORD PTR [edx+136]
  00065	2b 5d 08	 sub	 ebx, DWORD PTR _p_nZoomValue$[ebp]
  00068	03 f0		 add	 esi, eax

; 66   : 	// 1.1 Modify DRI
; 67   : 	if( p_bRelative)	nStartDRIOfView	-= p_nZoomValue;

  0006a	83 7d 0c 00	 cmp	 DWORD PTR _p_bRelative$[ebp], 0
  0006e	75 10		 jne	 SHORT $LN5@ZoomTo

; 68   : 	else				nStartDRIOfView	-= ( p_nZoomValue - m_pxScaleManager->GetDrawCount_Cur());

  00070	8b 8f 38 03 00
	00		 mov	 ecx, DWORD PTR [edi+824]
  00076	8b 01		 mov	 eax, DWORD PTR [ecx]
  00078	ff 90 88 00 00
	00		 call	 DWORD PTR [eax+136]
  0007e	03 d8		 add	 ebx, eax
$LN5@ZoomTo:

; 69   : 	// 1.2 Check validation.
; 70   : 	int nZoomCount = ( nEndDRIOfView - nStartDRIOfView + 1);
; 71   : 	if( nZoomCount < m_nMinDataCountOnOnePage) nZoomCount = m_nMinDataCountOnOnePage;

  00080	0f bf 8f d4 02
	00 00		 movsx	 ecx, WORD PTR [edi+724]
  00087	8b c6		 mov	 eax, esi
  00089	2b c3		 sub	 eax, ebx
  0008b	40		 inc	 eax

; 72   : 	nStartDRIOfView = nEndDRIOfView - nZoomCount + 1;

  0008c	3b c1		 cmp	 eax, ecx
  0008e	0f 4d c8	 cmovge	 ecx, eax
  00091	8b c6		 mov	 eax, esi
  00093	2b c1		 sub	 eax, ecx
  00095	89 4d 08	 mov	 DWORD PTR tv502[ebp], ecx
  00098	83 c0 01	 add	 eax, 1

; 73   : 	if( nStartDRIOfView < 0)
; 74   : 	{
; 75   : 		nStartDRIOfView = 0;
; 76   : 		nEndDRIOfView = nStartDRIOfView + nZoomCount - 1;
; 77   : 	}
; 78   : 	// (2009/2/19 - Seung-Won, Bae) If no-data, Set view range to (0:ZoomValue) for accepting of ZoomValue.
; 79   : 	if( 0 < m_pxScaleManager->GetCount() && m_pxScaleManager->GetCount() <= nEndDRIOfView)

  0009b	8d 51 ff	 lea	 edx, DWORD PTR [ecx-1]
  0009e	8b 8f 38 03 00
	00		 mov	 ecx, DWORD PTR [edi+824]
  000a4	0f 49 d6	 cmovns	 edx, esi
  000a7	33 f6		 xor	 esi, esi
  000a9	85 c0		 test	 eax, eax
  000ab	89 55 fc	 mov	 DWORD PTR tv500[ebp], edx
  000ae	8b da		 mov	 ebx, edx
  000b0	0f 49 f0	 cmovns	 esi, eax
  000b3	8b 01		 mov	 eax, DWORD PTR [ecx]
  000b5	ff 90 84 00 00
	00		 call	 DWORD PTR [eax+132]
  000bb	85 c0		 test	 eax, eax
  000bd	7e 2d		 jle	 SHORT $LN16@ZoomTo
  000bf	8b 8f 38 03 00
	00		 mov	 ecx, DWORD PTR [edi+824]
  000c5	8b 01		 mov	 eax, DWORD PTR [ecx]
  000c7	ff 90 84 00 00
	00		 call	 DWORD PTR [eax+132]
  000cd	3b c3		 cmp	 eax, ebx
  000cf	7f 1b		 jg	 SHORT $LN16@ZoomTo

; 80   : 	{
; 81   : 		nEndDRIOfView = m_pxScaleManager->GetCount() - 1;

  000d1	8b 8f 38 03 00
	00		 mov	 ecx, DWORD PTR [edi+824]
  000d7	8b 01		 mov	 eax, DWORD PTR [ecx]
  000d9	ff 90 84 00 00
	00		 call	 DWORD PTR [eax+132]
  000df	8d 58 ff	 lea	 ebx, DWORD PTR [eax-1]

; 82   : 		nStartDRIOfView = nEndDRIOfView - nZoomCount + 1;

  000e2	8b 45 08	 mov	 eax, DWORD PTR tv502[ebp]
  000e5	8b f3		 mov	 esi, ebx
  000e7	2b f0		 sub	 esi, eax
  000e9	46		 inc	 esi
  000ea	eb 03		 jmp	 SHORT $LN8@ZoomTo
$LN16@ZoomTo:

; 83   : 	}
; 84   : 	if( nStartDRIOfView < 0) nStartDRIOfView = 0;
; 85   : 	if( nEndDRIOfView < 0) return FALSE;

  000ec	8b 45 08	 mov	 eax, DWORD PTR tv502[ebp]
$LN8@ZoomTo:
  000ef	85 db		 test	 ebx, ebx
  000f1	78 65		 js	 SHORT $LN14@ZoomTo

; 86   : 
; 87   : 	// 2. Update Info.
; 88   : 	// 2.1 Uncheck WholeView option.
; 89   : 	m_bWholeView = FALSE;
; 90   : 
; 91   : 	// 2.2 One Page Data Count by User with fixed Item Width option.
; 92   : 	m_nOnePageDataCount = nZoomCount;
; 93   : 
; 94   : 	// 3. Update X Scale Manager
; 95   : 	m_pxScaleManager->SetStartEndDrawIdx_Cur( nStartDRIOfView, nEndDRIOfView, p_bRelative);

  000f3	8b 8f 38 03 00
	00		 mov	 ecx, DWORD PTR [edi+824]
  000f9	ff 75 0c	 push	 DWORD PTR _p_bRelative$[ebp]
  000fc	89 87 48 02 00
	00		 mov	 DWORD PTR [edi+584], eax
  00102	33 c0		 xor	 eax, eax
  00104	c7 87 44 02 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+580], 0
  0010e	85 f6		 test	 esi, esi
  00110	8b 11		 mov	 edx, DWORD PTR [ecx]
  00112	53		 push	 ebx
  00113	0f 49 c6	 cmovns	 eax, esi
  00116	50		 push	 eax
  00117	ff 92 94 00 00
	00		 call	 DWORD PTR [edx+148]

; 96   : 
; 97   : 	// (2009/6/2 - Seung-Won, Bae) Zoom to adjusted zoom value on relative.
; 98   : 	if( p_bRelative) m_nOnePageDataCount = m_pxScaleManager->GetDrawCount_Cur();

  0011d	83 7d 0c 00	 cmp	 DWORD PTR _p_bRelative$[ebp], 0
  00121	74 1c		 je	 SHORT $LN12@ZoomTo
  00123	8b 8f 38 03 00
	00		 mov	 ecx, DWORD PTR [edi+824]
  00129	8b 01		 mov	 eax, DWORD PTR [ecx]
  0012b	ff 90 88 00 00
	00		 call	 DWORD PTR [eax+136]

; 99   : 
; 100  : 	// (2006/11/18 - Seung-Won, Bae) Notify the User Zoom State to MultiChart
; 101  : 	//>>JS.Kim_20101001. 사용자 스크롤 조작시에만 MultiChart로 이벤트 준다.
; 102  : 	if( p_bRelative )
; 103  : 	//<<
; 104  : 		OnUserZoomChanged( m_nOnePageDataCount);

  00131	50		 push	 eax
  00132	8b cf		 mov	 ecx, edi
  00134	89 87 48 02 00
	00		 mov	 DWORD PTR [edi+584], eax
  0013a	e8 00 00 00 00	 call	 ?OnUserZoomChanged@CKTBChartCtrl@@QAEXH@Z ; CKTBChartCtrl::OnUserZoomChanged
$LN12@ZoomTo:

; 105  : 
; 106  : 	// 5. Update View
; 107  : 	InvalidateControl();

  0013f	6a 01		 push	 1
  00141	6a 00		 push	 0
  00143	8b cf		 mov	 ecx, edi
  00145	e8 00 00 00 00	 call	 ?InvalidateControl@CKTBChartCtrl@@QAEXPBUtagRECT@@H@Z ; CKTBChartCtrl::InvalidateControl
  0014a	5f		 pop	 edi

; 108  : 
; 109  : 	return TRUE;
; 110  : }

  0014b	5e		 pop	 esi
  0014c	b8 01 00 00 00	 mov	 eax, 1
  00151	5b		 pop	 ebx
  00152	8b e5		 mov	 esp, ebp
  00154	5d		 pop	 ebp
  00155	c2 08 00	 ret	 8
$LN14@ZoomTo:
  00158	5f		 pop	 edi
  00159	5e		 pop	 esi
  0015a	33 c0		 xor	 eax, eax
  0015c	5b		 pop	 ebx
  0015d	8b e5		 mov	 esp, ebp
  0015f	5d		 pop	 ebp
  00160	c2 08 00	 ret	 8
?ZoomTo@CKTBChartCtrl@@IAEHJH@Z ENDP			; CKTBChartCtrl::ZoomTo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\KTBChart\KTBChartScroll.cpp
;	COMDAT ?SetOnePageDataCount2@CKTBChartCtrl@@IAEXJH@Z
_TEXT	SEGMENT
_nOnePageDataCount$ = 8					; size = 4
_bIncludeBongCountMargin$ = 12				; size = 4
?SetOnePageDataCount2@CKTBChartCtrl@@IAEXJH@Z PROC	; CKTBChartCtrl::SetOnePageDataCount2, COMDAT
; _this$ = ecx

; 244  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 245  : 	m_bIncludeBongCountMargin = (bIncludeBongCountMargin ? true: false);

  00003	83 7d 0c 00	 cmp	 DWORD PTR _bIncludeBongCountMargin$[ebp], 0
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	0f 95 c0	 setne	 al
  0000d	57		 push	 edi

; 246  : 
; 247  : 	SetOnePageDataCount(nOnePageDataCount);

  0000e	8b 7d 08	 mov	 edi, DWORD PTR _nOnePageDataCount$[ebp]
  00011	88 86 30 05 00
	00		 mov	 BYTE PTR [esi+1328], al

; 195  : 	if( IsWholeView())

  00017	8b 06		 mov	 eax, DWORD PTR [esi]
  00019	8b 80 08 03 00
	00		 mov	 eax, DWORD PTR [eax+776]
  0001f	ff d0		 call	 eax
  00021	84 c0		 test	 al, al
  00023	74 3a		 je	 SHORT $LN4@SetOnePage

; 196  : 	{
; 197  : 		if( nOnePageDataCount < m_nMinDataCountOnOnePage) nOnePageDataCount = m_nMinDataCountOnOnePage;

  00025	0f bf 86 d4 02
	00 00		 movsx	 eax, WORD PTR [esi+724]

; 198  : 		if( m_pxScaleManager->GetCount() <= nOnePageDataCount)	nOnePageDataCount = m_pxScaleManager->GetCount();

  0002c	8b 8e 38 03 00
	00		 mov	 ecx, DWORD PTR [esi+824]
  00032	3b f8		 cmp	 edi, eax
  00034	0f 4c f8	 cmovl	 edi, eax
  00037	8b 01		 mov	 eax, DWORD PTR [ecx]
  00039	ff 90 84 00 00
	00		 call	 DWORD PTR [eax+132]
  0003f	3b c7		 cmp	 eax, edi
  00041	7f 10		 jg	 SHORT $LN7@SetOnePage
  00043	8b 8e 38 03 00
	00		 mov	 ecx, DWORD PTR [esi+824]
  00049	8b 01		 mov	 eax, DWORD PTR [ecx]
  0004b	ff 90 84 00 00
	00		 call	 DWORD PTR [eax+132]
  00051	8b f8		 mov	 edi, eax
$LN7@SetOnePage:

; 199  : 		m_nOnePageDataCount = nOnePageDataCount;

  00053	89 be 48 02 00
	00		 mov	 DWORD PTR [esi+584], edi
  00059	5f		 pop	 edi

; 248  : }

  0005a	5e		 pop	 esi
  0005b	5d		 pop	 ebp
  0005c	c2 08 00	 ret	 8
$LN4@SetOnePage:

; 201  : 	else ZoomTo( nOnePageDataCount, FALSE);

  0005f	6a 00		 push	 0
  00061	57		 push	 edi
  00062	8b ce		 mov	 ecx, esi
  00064	e8 00 00 00 00	 call	 ?ZoomTo@CKTBChartCtrl@@IAEHJH@Z ; CKTBChartCtrl::ZoomTo
  00069	5f		 pop	 edi

; 248  : }

  0006a	5e		 pop	 esi
  0006b	5d		 pop	 ebp
  0006c	c2 08 00	 ret	 8
?SetOnePageDataCount2@CKTBChartCtrl@@IAEXJH@Z ENDP	; CKTBChartCtrl::SetOnePageDataCount2
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\KTBChart\KTBChartScroll.cpp
;	COMDAT ?ZoomToWithRightFix@CKTBChartCtrl@@IAEFFH@Z
_TEXT	SEGMENT
_nStartIndex$ = -8					; size = 4
_nEndIndex$ = -4					; size = 4
_p_nZoomValue$ = 8					; size = 2
_nScrollRange$1 = 8					; size = 4
_p_bWithRightFix$ = 12					; size = 4
?ZoomToWithRightFix@CKTBChartCtrl@@IAEFFH@Z PROC	; CKTBChartCtrl::ZoomToWithRightFix, COMDAT
; _this$ = ecx

; 539  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 540  : 	// TODO: Add your dispatch handler code here
; 541  : 
; 542  : 	// (2004.05.18, 배승원) 한 화면에 보이는 Data 수 (ZoomValue)의 조정을 반영한다.
; 543  : 	// (2004.07.02, 배승원) 한 화면에 보이는 수가 바뀌는 경우에도, ScrollBar를 중심으로 처리한다.
; 544  : 	// 1. 현재 View의 Start/End Index를 구한다.
; 545  : 	int nStartIndex, nEndIndex;
; 546  : 	if( !GetDataStartEnd( nStartIndex, nEndIndex)) return FALSE;

  00006	8d 45 fc	 lea	 eax, DWORD PTR _nEndIndex$[ebp]
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	50		 push	 eax
  0000d	8d 45 f8	 lea	 eax, DWORD PTR _nStartIndex$[ebp]
  00010	8b f9		 mov	 edi, ecx
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ?GetDataStartEnd@CKTBChartCtrl@@QAEHAAH0@Z ; CKTBChartCtrl::GetDataStartEnd
  00018	85 c0		 test	 eax, eax
  0001a	74 62		 je	 SHORT $LN8@ZoomToWith

; 547  : 	// 2. 조정된 한 화면의 Data수에 맞춰 Start Index를 조정한다.
; 548  : 	nStartIndex = nEndIndex - p_nZoomValue + 1;

  0001c	8b 5d 08	 mov	 ebx, DWORD PTR _p_nZoomValue$[ebp]
  0001f	8b 75 fc	 mov	 esi, DWORD PTR _nEndIndex$[ebp]
  00022	8b ce		 mov	 ecx, esi
  00024	0f bf c3	 movsx	 eax, bx
  00027	2b c8		 sub	 ecx, eax
  00029	83 c1 01	 add	 ecx, 1
  0002c	89 4d f8	 mov	 DWORD PTR _nStartIndex$[ebp], ecx

; 549  : 	// 3. StartIndex의 유효성을 확인하고, 문제시 End Index를 조정한다.
; 550  : 	if( nStartIndex < 0)	// 종찬(04/09/20): 0 Base

  0002f	79 35		 jns	 SHORT $LN3@ZoomToWith

; 551  : 	{
; 552  : 		nStartIndex = 0;

  00031	33 c9		 xor	 ecx, ecx
  00033	89 4d f8	 mov	 DWORD PTR _nStartIndex$[ebp], ecx

; 553  : 		// (2004.07.05, 배승원) EndIndex의 조정은 p_bWithRightFix의 값이 False인 경우에만 처리한다.
; 554  : 		if( !p_bWithRightFix)

  00036	39 4d 0c	 cmp	 DWORD PTR _p_bWithRightFix$[ebp], ecx
  00039	75 23		 jne	 SHORT $LN6@ZoomToWith

; 555  : 		{
; 556  : 			nEndIndex = nStartIndex + p_nZoomValue - 1;

  0003b	48		 dec	 eax

; 557  : 			// 4. End Index가 전체 Index보다 넘어서는 문제가 발생시에는 한 화면의 Data 수를 보정한다.
; 558  : 			int nScrollRange;
; 559  : 			if( !GetScrollRange( nScrollRange)) return FALSE;

  0003c	8b cf		 mov	 ecx, edi
  0003e	89 45 fc	 mov	 DWORD PTR _nEndIndex$[ebp], eax
  00041	8d 45 08	 lea	 eax, DWORD PTR _nScrollRange$1[ebp]
  00044	50		 push	 eax
  00045	e8 00 00 00 00	 call	 ?GetScrollRange@CKTBChartCtrl@@QAEHAAH@Z ; CKTBChartCtrl::GetScrollRange
  0004a	85 c0		 test	 eax, eax
  0004c	74 30		 je	 SHORT $LN8@ZoomToWith

; 560  : 			if( nScrollRange < nEndIndex) nEndIndex = nScrollRange;

  0004e	8b 75 fc	 mov	 esi, DWORD PTR _nEndIndex$[ebp]
  00051	39 75 08	 cmp	 DWORD PTR _nScrollRange$1[ebp], esi
  00054	8b 4d f8	 mov	 ecx, DWORD PTR _nStartIndex$[ebp]
  00057	0f 4c 75 08	 cmovl	 esi, DWORD PTR _nScrollRange$1[ebp]
  0005b	89 75 fc	 mov	 DWORD PTR _nEndIndex$[ebp], esi
$LN6@ZoomToWith:

; 561  : 		}
; 562  : 		// 4.5 End Index의 조정이 되었건 그렇지 않건 간에, Zoom Value를 새로이 구하여 (전과 같을 수 있다.)
; 563  : 		//		변경되는 경우의 Zoom Value를 구한다.
; 564  : 		p_nZoomValue = nEndIndex - nStartIndex + 1;

  0005e	8b c6		 mov	 eax, esi
  00060	2b c1		 sub	 eax, ecx
  00062	40		 inc	 eax
  00063	0f b7 d8	 movzx	 ebx, ax
$LN3@ZoomToWith:

; 565  : 	}
; 566  : 	// 5. 보정된 Start/End Index를 설정한다.
; 567  : 	SetStartEndIndex( nStartIndex, nEndIndex);

  00066	8b 17		 mov	 edx, DWORD PTR [edi]
  00068	56		 push	 esi
  00069	51		 push	 ecx
  0006a	8b cf		 mov	 ecx, edi
  0006c	ff 92 10 03 00
	00		 call	 DWORD PTR [edx+784]
  00072	5f		 pop	 edi

; 568  : 
; 569  : 	return p_nZoomValue;
; 570  : }

  00073	5e		 pop	 esi
  00074	66 8b c3	 mov	 ax, bx
  00077	5b		 pop	 ebx
  00078	8b e5		 mov	 esp, ebp
  0007a	5d		 pop	 ebp
  0007b	c2 08 00	 ret	 8
$LN8@ZoomToWith:
  0007e	5f		 pop	 edi
  0007f	5e		 pop	 esi
  00080	33 c0		 xor	 eax, eax
  00082	5b		 pop	 ebx
  00083	8b e5		 mov	 esp, ebp
  00085	5d		 pop	 ebp
  00086	c2 08 00	 ret	 8
?ZoomToWithRightFix@CKTBChartCtrl@@IAEFFH@Z ENDP	; CKTBChartCtrl::ZoomToWithRightFix
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\KTBChart\KTBChartScroll.cpp
;	COMDAT ?ScrollToDataOfEnd@CKTBChartCtrl@@IAEHN@Z
_TEXT	SEGMENT
_nFullRange$ = -12					; size = 4
_nStartIndex$ = -8					; size = 4
_nEndIndex$ = -4					; size = 4
_p_dData$ = 8						; size = 8
?ScrollToDataOfEnd@CKTBChartCtrl@@IAEHN@Z PROC		; CKTBChartCtrl::ScrollToDataOfEnd, COMDAT
; _this$ = ecx

; 360  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	57		 push	 edi

; 361  : 	// TODO: Add your dispatch handler code here
; 362  : 
; 363  : 	// 0. Pointer를 확인한다.
; 364  : 	if( !m_pPacketList) return FALSE;

  0000b	83 be 3c 03 00
	00 00		 cmp	 DWORD PTR [esi+828], 0
  00012	0f 84 b0 00 00
	00		 je	 $LN11@ScrollToDa

; 365  : 
; 366  : 	// 1. 먼저 현재의 한 화면에 보이는 Data 수를 구한다.
; 367  : 	// 1.1 현재 보이는 Data의 Start/End Index를 구한다. (종찬 04/09/20: 0 Based)
; 368  : 	int nStartIndex, nEndIndex;
; 369  : 	if( !GetDataStartEnd( nStartIndex, nEndIndex)) return FALSE;

  00018	8d 45 fc	 lea	 eax, DWORD PTR _nEndIndex$[ebp]
  0001b	50		 push	 eax
  0001c	8d 45 f8	 lea	 eax, DWORD PTR _nStartIndex$[ebp]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ?GetDataStartEnd@CKTBChartCtrl@@QAEHAAH0@Z ; CKTBChartCtrl::GetDataStartEnd
  00025	85 c0		 test	 eax, eax
  00027	0f 84 9b 00 00
	00		 je	 $LN11@ScrollToDa

; 370  : 	// 1.2 한 화면에 보이는 Data수를 구한다.
; 371  : 	int nPageDataCount = nEndIndex - nStartIndex + 1;
; 372  : 
; 373  : 	// 2. 주어진 일자 정보를 이용하여 Data Index를 구한다.
; 374  : 	// 2.1 먼저 자료일자 Packet을 구한다.
; 375  : 	CPacket *pPacket = m_pPacketList->GetBaseData( _MTEXT( C0_DATE_TIME));

  0002d	a1 54 00 00 00	 mov	 eax, DWORD PTR ?g_iMetaTable@@3VIMetaTable@@A+84
  00032	8b 7d fc	 mov	 edi, DWORD PTR _nEndIndex$[ebp]
  00035	2b 7d f8	 sub	 edi, DWORD PTR _nStartIndex$[ebp]
  00038	6a 01		 push	 1
  0003a	51		 push	 ecx
  0003b	8b cc		 mov	 ecx, esp
  0003d	47		 inc	 edi
  0003e	ff 30		 push	 DWORD PTR [eax]
  00040	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  00046	8b 8e 3c 03 00
	00		 mov	 ecx, DWORD PTR [esi+828]
  0004c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetBaseData@CPacketList@@QAEPAVCPacket@@V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@_N@Z

; 376  : 	if( !pPacket) return FALSE;

  00052	85 c0		 test	 eax, eax
  00054	74 72		 je	 SHORT $LN11@ScrollToDa

; 377  : 	// (2004.06.28, 배승원) 주어진 자료일자는 View의 우측끝으로 지정되도록 수정한다.
; 378  : 	// 2.2 끝 자료일자에 대한 Data Index를 구한다. (0 Based Index)
; 379  : 	nEndIndex = pPacket->GetIndexFromData( p_dData);

  00056	f2 0f 10 45 08	 movsd	 xmm0, QWORD PTR _p_dData$[ebp]
  0005b	83 ec 08	 sub	 esp, 8
  0005e	8b c8		 mov	 ecx, eax
  00060	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00065	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetIndexFromData@CPacket@@QAEHN@Z
  0006b	89 45 fc	 mov	 DWORD PTR _nEndIndex$[ebp], eax

; 380  : 	if( nEndIndex < 0) return FALSE;

  0006e	85 c0		 test	 eax, eax
  00070	78 56		 js	 SHORT $LN11@ScrollToDa

; 381  : //	nEndIndex++; // 종찬(04/09/20) 0-Base
; 382  : 	// (2004.07.06, 배승원) 구해진 Data Index가 화면에 보이는 영역이 아닌 경우를 제외한다.
; 383  : 	// 2.2.5 전체 ScrollRange를 구한다.
; 384  : 	int nFullRange;
; 385  : 	if( !GetScrollRange( nFullRange)) return FALSE;

  00072	8d 45 f4	 lea	 eax, DWORD PTR _nFullRange$[ebp]
  00075	8b ce		 mov	 ecx, esi
  00077	50		 push	 eax
  00078	e8 00 00 00 00	 call	 ?GetScrollRange@CKTBChartCtrl@@QAEHAAH@Z ; CKTBChartCtrl::GetScrollRange
  0007d	85 c0		 test	 eax, eax
  0007f	74 47		 je	 SHORT $LN11@ScrollToDa

; 386  : 	// 2.2.6 전체 ScrollRange보다 우측의 경우, False로 return한다.
; 387  : 	if( nFullRange < nEndIndex) return FALSE;

  00081	8b 55 f4	 mov	 edx, DWORD PTR _nFullRange$[ebp]
  00084	8b 4d fc	 mov	 ecx, DWORD PTR _nEndIndex$[ebp]
  00087	3b d1		 cmp	 edx, ecx
  00089	7c 3d		 jl	 SHORT $LN11@ScrollToDa

; 388  : 	// 2.3 시작 자료일자를 구한다.
; 389  : 	nStartIndex	= nEndIndex - nPageDataCount + 1;

  0008b	2b cf		 sub	 ecx, edi

; 390  : 
; 391  : 	// 3. 한 화면에 보이는 Data수를 감안하여 nStartIndex를 보정한다.
; 392  : 	// 3.2 새로운 StartIndex에 의한 EndIndex의 OverFlow를 확인하여 조정한다.
; 393  : 	if( nFullRange < nStartIndex + nPageDataCount - 1) nStartIndex = nFullRange - nPageDataCount + 1;

  0008d	8d 47 ff	 lea	 eax, DWORD PTR [edi-1]
  00090	41		 inc	 ecx
  00091	03 c1		 add	 eax, ecx
  00093	89 4d f8	 mov	 DWORD PTR _nStartIndex$[ebp], ecx
  00096	8b d9		 mov	 ebx, ecx
  00098	3b d0		 cmp	 edx, eax
  0009a	7d 0a		 jge	 SHORT $LN8@ScrollToDa
  0009c	2b d7		 sub	 edx, edi
  0009e	8d 4a 01	 lea	 ecx, DWORD PTR [edx+1]
  000a1	89 4d f8	 mov	 DWORD PTR _nStartIndex$[ebp], ecx
  000a4	8b d9		 mov	 ebx, ecx
$LN8@ScrollToDa:

; 394  : 	// 3.3 새로운 StartIndex에 대한 EndIndex를 보정한다.
; 395  : 	nEndIndex = nStartIndex + nPageDataCount - 1;
; 396  : 
; 397  : 	// 4. 구해진 Data Index를 기준으로 Scrolling을 처리한다. (종찬 04/09/20: 0 Based Index)
; 398  : 	SetStartEndIndex( nStartIndex, nEndIndex);

  000a6	8b 16		 mov	 edx, DWORD PTR [esi]
  000a8	8d 47 ff	 lea	 eax, DWORD PTR [edi-1]
  000ab	03 c3		 add	 eax, ebx
  000ad	50		 push	 eax
  000ae	51		 push	 ecx
  000af	8b ce		 mov	 ecx, esi
  000b1	89 45 fc	 mov	 DWORD PTR _nEndIndex$[ebp], eax
  000b4	ff 92 10 03 00
	00		 call	 DWORD PTR [edx+784]

; 399  : 
; 400  : 	return TRUE;

  000ba	b8 01 00 00 00	 mov	 eax, 1

; 401  : }

  000bf	5f		 pop	 edi
  000c0	5e		 pop	 esi
  000c1	5b		 pop	 ebx
  000c2	8b e5		 mov	 esp, ebp
  000c4	5d		 pop	 ebp
  000c5	c2 08 00	 ret	 8
$LN11@ScrollToDa:
  000c8	5f		 pop	 edi
  000c9	5e		 pop	 esi
  000ca	33 c0		 xor	 eax, eax
  000cc	5b		 pop	 ebx
  000cd	8b e5		 mov	 esp, ebp
  000cf	5d		 pop	 ebp
  000d0	c2 08 00	 ret	 8
?ScrollToDataOfEnd@CKTBChartCtrl@@IAEHN@Z ENDP		; CKTBChartCtrl::ScrollToDataOfEnd
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\KTBChart\KTBChartScroll.cpp
;	COMDAT ?SetStartEndDateOfView@CKTBChartCtrl@@IAEHNN@Z
_TEXT	SEGMENT
_p_dStartDate$ = 8					; size = 8
_nStartIndex$1$ = 12					; size = 4
_p_dEndDate$ = 16					; size = 8
?SetStartEndDateOfView@CKTBChartCtrl@@IAEHNN@Z PROC	; CKTBChartCtrl::SetStartEndDateOfView, COMDAT
; _this$ = ecx

; 335  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	57		 push	 edi
  00006	8b f9		 mov	 edi, ecx

; 336  : 	// TODO: Add your dispatch handler code here
; 337  : 
; 338  : 	// 0. Pointer를 확인한다.
; 339  : 	if( !m_pPacketList) return FALSE;

  00008	83 bf 3c 03 00
	00 00		 cmp	 DWORD PTR [edi+828], 0
  0000f	74 75		 je	 SHORT $LN5@SetStartEn

; 340  : 
; 341  : 	// 1. 주어진 일자 정보를 이용하여 Data Index를 구한다.
; 342  : 	// 1.1 먼저 자료일자 Packet을 구한다.
; 343  : 	CPacket *pPacket = m_pPacketList->GetBaseData( _MTEXT( C0_DATE_TIME));

  00011	a1 54 00 00 00	 mov	 eax, DWORD PTR ?g_iMetaTable@@3VIMetaTable@@A+84
  00016	6a 01		 push	 1
  00018	51		 push	 ecx
  00019	8b cc		 mov	 ecx, esp
  0001b	ff 30		 push	 DWORD PTR [eax]
  0001d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  00023	8b 8f 3c 03 00
	00		 mov	 ecx, DWORD PTR [edi+828]
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetBaseData@CPacketList@@QAEPAVCPacket@@V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@_N@Z
  0002f	8b d8		 mov	 ebx, eax

; 344  : 	if( !pPacket) return FALSE;

  00031	85 db		 test	 ebx, ebx
  00033	74 51		 je	 SHORT $LN5@SetStartEn

; 345  : 	// 1.2 각 자료일자에 대한 Data Index를 구한다. (0 Based Index)
; 346  : 	int nStartIndex	= pPacket->GetIndexFromData( p_dStartDate);

  00035	f2 0f 10 45 08	 movsd	 xmm0, QWORD PTR _p_dStartDate$[ebp]
  0003a	83 ec 08	 sub	 esp, 8
  0003d	8b cb		 mov	 ecx, ebx
  0003f	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetIndexFromData@CPacket@@QAEHN@Z

; 347  : 	int nEndIndex	= pPacket->GetIndexFromData( p_dEndDate);

  0004a	f2 0f 10 45 10	 movsd	 xmm0, QWORD PTR _p_dEndDate$[ebp]
  0004f	83 ec 08	 sub	 esp, 8
  00052	8b cb		 mov	 ecx, ebx
  00054	89 45 0c	 mov	 DWORD PTR _nStartIndex$1$[ebp], eax
  00057	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0005c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetIndexFromData@CPacket@@QAEHN@Z

; 348  : 	if( nStartIndex < 0 || nEndIndex < 0) return FALSE;

  00062	8b 4d 0c	 mov	 ecx, DWORD PTR _nStartIndex$1$[ebp]
  00065	85 c9		 test	 ecx, ecx
  00067	78 1d		 js	 SHORT $LN5@SetStartEn
  00069	85 c0		 test	 eax, eax
  0006b	78 19		 js	 SHORT $LN5@SetStartEn

; 349  : 
; 350  : 	// 2. 구해진 Data Index를 기준으로 Scrolling을 처리한다. (종찬 04/09/20: 0 Based Index)
; 351  : 	SetStartEndIndex( nStartIndex, nEndIndex);

  0006d	8b 17		 mov	 edx, DWORD PTR [edi]
  0006f	50		 push	 eax
  00070	51		 push	 ecx
  00071	8b cf		 mov	 ecx, edi
  00073	ff 92 10 03 00
	00		 call	 DWORD PTR [edx+784]

; 352  : 
; 353  : 	return TRUE;

  00079	b8 01 00 00 00	 mov	 eax, 1

; 354  : }

  0007e	5f		 pop	 edi
  0007f	5b		 pop	 ebx
  00080	8b e5		 mov	 esp, ebp
  00082	5d		 pop	 ebp
  00083	c2 10 00	 ret	 16			; 00000010H
$LN5@SetStartEn:
  00086	5f		 pop	 edi
  00087	33 c0		 xor	 eax, eax
  00089	5b		 pop	 ebx
  0008a	8b e5		 mov	 esp, ebp
  0008c	5d		 pop	 ebp
  0008d	c2 10 00	 ret	 16			; 00000010H
?SetStartEndDateOfView@CKTBChartCtrl@@IAEHNN@Z ENDP	; CKTBChartCtrl::SetStartEndDateOfView
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\KTBChart\KTBChartScroll.cpp
;	COMDAT ?GetStartEndDateOnView@CKTBChartCtrl@@IAEHPAN0@Z
_TEXT	SEGMENT
tv130 = -8						; size = 8
_dLastDate$1 = -8					; size = 8
_nStartIndex$ = 8					; size = 4
_p_pStartDate$ = 8					; size = 4
_nEndIndex$ = 12					; size = 4
_p_pEndDate$ = 12					; size = 4
?GetStartEndDateOnView@CKTBChartCtrl@@IAEHPAN0@Z PROC	; CKTBChartCtrl::GetStartEndDateOnView, COMDAT
; _this$ = ecx

; 296  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 297  : 	// TODO: Add your dispatch handler code here
; 298  : 	
; 299  : 	// 0. Pointer를 확인한다.
; 300  : 	if( !p_pStartDate || !p_pEndDate || !m_pPacketList) return FALSE;

  00008	8b 75 08	 mov	 esi, DWORD PTR _p_pStartDate$[ebp]
  0000b	57		 push	 edi
  0000c	8b f9		 mov	 edi, ecx
  0000e	85 f6		 test	 esi, esi
  00010	0f 84 cc 00 00
	00		 je	 $LN3@GetStartEn
  00016	8b 5d 0c	 mov	 ebx, DWORD PTR _p_pEndDate$[ebp]
  00019	85 db		 test	 ebx, ebx
  0001b	0f 84 c1 00 00
	00		 je	 $LN3@GetStartEn
  00021	83 bf 3c 03 00
	00 00		 cmp	 DWORD PTR [edi+828], 0
  00028	0f 84 b4 00 00
	00		 je	 $LN3@GetStartEn

; 301  : 
; 302  : 	// 1. 먼저 Start/End Index를 구한다. (종찬 04/09/20: 0 Based)
; 303  : 	int nStartIndex, nEndIndex;
; 304  : 	if( !GetDataStartEnd( nStartIndex, nEndIndex)) return FALSE;

  0002e	8d 45 0c	 lea	 eax, DWORD PTR _nEndIndex$[ebp]
  00031	50		 push	 eax
  00032	8d 45 08	 lea	 eax, DWORD PTR _nStartIndex$[ebp]
  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 ?GetDataStartEnd@CKTBChartCtrl@@QAEHAAH0@Z ; CKTBChartCtrl::GetDataStartEnd
  0003b	85 c0		 test	 eax, eax
  0003d	0f 84 9f 00 00
	00		 je	 $LN3@GetStartEn

; 305  : 
; 306  : 	// 2. 각 Index에 해당하는 Data를 추출한다.
; 307  : 	// 2.1 자료일자 Packet을 구한다.
; 308  : 	CPacket *pPacket = m_pPacketList->GetBaseData( _MTEXT( C0_DATE_TIME));

  00043	a1 54 00 00 00	 mov	 eax, DWORD PTR ?g_iMetaTable@@3VIMetaTable@@A+84
  00048	6a 01		 push	 1
  0004a	51		 push	 ecx
  0004b	8b cc		 mov	 ecx, esp
  0004d	ff 30		 push	 DWORD PTR [eax]
  0004f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  00055	8b 8f 3c 03 00
	00		 mov	 ecx, DWORD PTR [edi+828]
  0005b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetBaseData@CPacketList@@QAEPAVCPacket@@V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@_N@Z
  00061	8b f8		 mov	 edi, eax

; 309  : 	if( !pPacket) return FALSE;

  00063	85 ff		 test	 edi, edi
  00065	74 7b		 je	 SHORT $LN3@GetStartEn

; 310  : 	// 2.2 '자료일자'로부터 해당 Index의 Data를 구한다. (0 Based)
; 311  : 	*p_pStartDate	= pPacket->GetData( nStartIndex);

  00067	ff 75 08	 push	 DWORD PTR _nStartIndex$[ebp]
  0006a	8b cf		 mov	 ecx, edi
  0006c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetData@CPacket@@QAENH@Z

; 312  :     *p_pEndDate		= pPacket->GetData( nEndIndex);

  00072	ff 75 0c	 push	 DWORD PTR _nEndIndex$[ebp]
  00075	dd 1e		 fstp	 QWORD PTR [esi]
  00077	8b cf		 mov	 ecx, edi
  00079	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetData@CPacket@@QAENH@Z
  0007f	dd 5d f8	 fstp	 QWORD PTR tv130[ebp]
  00082	f2 0f 10 45 f8	 movsd	 xmm0, QWORD PTR tv130[ebp]

; 313  : 
; 314  : 	// (2004.07.06, 배승원) 검색된 자료일자가 유효하지 않는 경우,
; 315  : 	//		마지막 Data의 자료일자로 처리한다.
; 316  : 	if( *p_pEndDate == -DBL_MAX)	// 하나라도 유효하지 않는가?

  00087	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@ffefffffffffffff
  0008f	f2 0f 11 03	 movsd	 QWORD PTR [ebx], xmm0
  00093	9f		 lahf
  00094	f6 c4 44	 test	 ah, 68			; 00000044H
  00097	7a 3b		 jp	 SHORT $LN8@GetStartEn

; 317  : 	{
; 318  : 		// 3.0 먼저 마지막 Data로 Update하기 위한 마지막 일자를 확보한다.
; 319  : 		int nDataCount = pPacket->GetCount();

  00099	8b 07		 mov	 eax, DWORD PTR [edi]
  0009b	8b cf		 mov	 ecx, edi
  0009d	ff 50 14	 call	 DWORD PTR [eax+20]
  000a0	0f 57 c9	 xorps	 xmm1, xmm1

; 320  : 		double dLastDate = 0;
; 321  : 		if( 1 <= nDataCount) dLastDate = pPacket->GetData( nDataCount - 1);

  000a3	83 f8 01	 cmp	 eax, 1
  000a6	7c 12		 jl	 SHORT $LN7@GetStartEn
  000a8	48		 dec	 eax
  000a9	8b cf		 mov	 ecx, edi
  000ab	50		 push	 eax
  000ac	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetData@CPacket@@QAENH@Z
  000b2	dd 5d f8	 fstp	 QWORD PTR _dLastDate$1[ebp]
  000b5	f2 0f 10 4d f8	 movsd	 xmm1, QWORD PTR _dLastDate$1[ebp]
$LN7@GetStartEn:

; 322  : 		
; 323  : 		// 3.1 End Date값을 확보한다.
; 324  : 		*p_pEndDate = dLastDate;

  000ba	f2 0f 11 0b	 movsd	 QWORD PTR [ebx], xmm1

; 325  : 
; 326  : 		// 3.2 Start Date도 없는 경우를 처리한다.
; 327  : 		if( *p_pStartDate == -DBL_MAX) *p_pStartDate = dLastDate;

  000be	f2 0f 10 06	 movsd	 xmm0, QWORD PTR [esi]
  000c2	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@ffefffffffffffff
  000ca	9f		 lahf
  000cb	f6 c4 44	 test	 ah, 68			; 00000044H
  000ce	7a 04		 jp	 SHORT $LN8@GetStartEn
  000d0	f2 0f 11 0e	 movsd	 QWORD PTR [esi], xmm1
$LN8@GetStartEn:

; 328  : 	}
; 329  : 
; 330  : 	return TRUE;

  000d4	b8 01 00 00 00	 mov	 eax, 1

; 331  : }

  000d9	5f		 pop	 edi
  000da	5e		 pop	 esi
  000db	5b		 pop	 ebx
  000dc	8b e5		 mov	 esp, ebp
  000de	5d		 pop	 ebp
  000df	c2 08 00	 ret	 8
$LN3@GetStartEn:
  000e2	5f		 pop	 edi
  000e3	5e		 pop	 esi
  000e4	33 c0		 xor	 eax, eax
  000e6	5b		 pop	 ebx
  000e7	8b e5		 mov	 esp, ebp
  000e9	5d		 pop	 ebp
  000ea	c2 08 00	 ret	 8
?GetStartEndDateOnView@CKTBChartCtrl@@IAEHPAN0@Z ENDP	; CKTBChartCtrl::GetStartEndDateOnView
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\KTBChart\KTBChartScroll.cpp
;	COMDAT ?GetOnePageDataCount@CKTBChartCtrl@@IAEJXZ
_TEXT	SEGMENT
?GetOnePageDataCount@CKTBChartCtrl@@IAEJXZ PROC		; CKTBChartCtrl::GetOnePageDataCount, COMDAT
; _this$ = ecx

; 255  : 	return m_nOnePageDataCount;

  00000	8b 81 48 02 00
	00		 mov	 eax, DWORD PTR [ecx+584]

; 256  : }

  00006	c3		 ret	 0
?GetOnePageDataCount@CKTBChartCtrl@@IAEJXZ ENDP		; CKTBChartCtrl::GetOnePageDataCount
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\KTBChart\KTBChartScroll.cpp
;	COMDAT ?SetOnePageDataCount@CKTBChartCtrl@@IAEXJ@Z
_TEXT	SEGMENT
_nOnePageDataCount$ = 8					; size = 4
?SetOnePageDataCount@CKTBChartCtrl@@IAEXJ@Z PROC	; CKTBChartCtrl::SetOnePageDataCount, COMDAT
; _this$ = ecx

; 193  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 194  : 	// (2009/5/18 - Seung-Won, Bae) Do not zoom on whole-view.
; 195  : 	if( IsWholeView())

  00006	8b 06		 mov	 eax, DWORD PTR [esi]
  00008	8b 80 08 03 00
	00		 mov	 eax, DWORD PTR [eax+776]
  0000e	ff d0		 call	 eax
  00010	84 c0		 test	 al, al
  00012	74 3e		 je	 SHORT $LN2@SetOnePage

; 196  : 	{
; 197  : 		if( nOnePageDataCount < m_nMinDataCountOnOnePage) nOnePageDataCount = m_nMinDataCountOnOnePage;

  00014	0f bf 86 d4 02
	00 00		 movsx	 eax, WORD PTR [esi+724]

; 198  : 		if( m_pxScaleManager->GetCount() <= nOnePageDataCount)	nOnePageDataCount = m_pxScaleManager->GetCount();

  0001b	8b 8e 38 03 00
	00		 mov	 ecx, DWORD PTR [esi+824]
  00021	57		 push	 edi
  00022	8b 7d 08	 mov	 edi, DWORD PTR _nOnePageDataCount$[ebp]
  00025	3b f8		 cmp	 edi, eax
  00027	0f 4c f8	 cmovl	 edi, eax
  0002a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0002c	ff 90 84 00 00
	00		 call	 DWORD PTR [eax+132]
  00032	3b c7		 cmp	 eax, edi
  00034	7f 10		 jg	 SHORT $LN5@SetOnePage
  00036	8b 8e 38 03 00
	00		 mov	 ecx, DWORD PTR [esi+824]
  0003c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0003e	ff 90 84 00 00
	00		 call	 DWORD PTR [eax+132]
  00044	8b f8		 mov	 edi, eax
$LN5@SetOnePage:

; 199  : 		m_nOnePageDataCount = nOnePageDataCount;

  00046	89 be 48 02 00
	00		 mov	 DWORD PTR [esi+584], edi
  0004c	5f		 pop	 edi
  0004d	5e		 pop	 esi

; 202  : }

  0004e	5d		 pop	 ebp
  0004f	c2 04 00	 ret	 4
$LN2@SetOnePage:

; 200  : 	}
; 201  : 	else ZoomTo( nOnePageDataCount, FALSE);

  00052	6a 00		 push	 0
  00054	ff 75 08	 push	 DWORD PTR _nOnePageDataCount$[ebp]
  00057	8b ce		 mov	 ecx, esi
  00059	e8 00 00 00 00	 call	 ?ZoomTo@CKTBChartCtrl@@IAEHJH@Z ; CKTBChartCtrl::ZoomTo
  0005e	5e		 pop	 esi

; 202  : }

  0005f	5d		 pop	 ebp
  00060	c2 04 00	 ret	 4
?SetOnePageDataCount@CKTBChartCtrl@@IAEXJ@Z ENDP	; CKTBChartCtrl::SetOnePageDataCount
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\KTBChart\KTBChartScroll.cpp
;	COMDAT ?GetNCurrentDrawCount@CKTBChartCtrl@@IAEJXZ
_TEXT	SEGMENT
?GetNCurrentDrawCount@CKTBChartCtrl@@IAEJXZ PROC	; CKTBChartCtrl::GetNCurrentDrawCount, COMDAT
; _this$ = ecx

; 261  : 	// TODO: Add your property handler here
; 262  : 	if( m_pxScaleManager) return m_pxScaleManager->GetDrawCount_Cur();

  00000	8b 91 38 03 00
	00		 mov	 edx, DWORD PTR [ecx+824]
  00006	85 d2		 test	 edx, edx
  00008	74 0a		 je	 SHORT $LN2@GetNCurren
  0000a	8b 02		 mov	 eax, DWORD PTR [edx]
  0000c	8b ca		 mov	 ecx, edx
  0000e	ff a0 88 00 00
	00		 jmp	 DWORD PTR [eax+136]
$LN2@GetNCurren:

; 263  : 	return m_nOnePageDataCount;

  00014	8b 81 48 02 00
	00		 mov	 eax, DWORD PTR [ecx+584]

; 264  : }

  0001a	c3		 ret	 0
?GetNCurrentDrawCount@CKTBChartCtrl@@IAEJXZ ENDP	; CKTBChartCtrl::GetNCurrentDrawCount
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\KTBChart\KTBChartScroll.cpp
;	COMDAT ?OnnOnePageDataCountChanged@CKTBChartCtrl@@IAEXXZ
_TEXT	SEGMENT
?OnnOnePageDataCountChanged@CKTBChartCtrl@@IAEXXZ PROC	; CKTBChartCtrl::OnnOnePageDataCountChanged, COMDAT
; _this$ = ecx

; 232  : {

  00000	56		 push	 esi

; 233  : 	BoundPropertyChanged(dispidNOnePageDataCount);

  00001	6a 0d		 push	 13			; 0000000dH
  00003	8b f1		 mov	 esi, ecx
  00005	e8 00 00 00 00	 call	 ?BoundPropertyChanged@COleControl@@QAEXJ@Z ; COleControl::BoundPropertyChanged

; 234  : 
; 235  : 	//sy 2005.11.17. 속성값만 바꾸는거지 화면에 반영을 하진 않는다!!
; 236  : 	//-> file 저장시 page count 를 바꿔서 저장하는 경우가 있기 때문에 스크롤에 반영하면 화면이 꿈뻑하고 움직임.
; 237  : 	//SetScrollData(SETSCROLL_TR, true, true);
; 238  : 
; 239  : 	SetModifiedFlag();

  0000a	6a 01		 push	 1
  0000c	8b ce		 mov	 ecx, esi
  0000e	e8 00 00 00 00	 call	 ?SetModifiedFlag@COleControl@@QAEXH@Z ; COleControl::SetModifiedFlag
  00013	5e		 pop	 esi

; 240  : }

  00014	c3		 ret	 0
?OnnOnePageDataCountChanged@CKTBChartCtrl@@IAEXXZ ENDP	; CKTBChartCtrl::OnnOnePageDataCountChanged
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\KTBChart\KTBChartScroll.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\KTBChart\KTBChartScroll.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\KTBChart\KTBChartScroll.cpp
;	COMDAT ?OnMouseWheel@CKTBChartCtrl@@IAEHIFVCPoint@@@Z
_TEXT	SEGMENT
_nFlags$ = 8						; size = 4
_zDelta$ = 12						; size = 2
_pt$ = 16						; size = 8
?OnMouseWheel@CKTBChartCtrl@@IAEHIFVCPoint@@@Z PROC	; CKTBChartCtrl::OnMouseWheel, COMDAT
; _this$ = ecx

; 172  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 173  : 	int nScrollValue = 5;
; 174  : 	if( zDelta < 0 && !m_pxScaleManager->GetReverse()
; 175  : 		|| 0 < zDelta && m_pxScaleManager->GetReverse())

  00003	66 83 7d 0c 00	 cmp	 WORD PTR _zDelta$[ebp], 0
  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	8b f9		 mov	 edi, ecx
  0000c	be 05 00 00 00	 mov	 esi, 5
  00011	7d 0f		 jge	 SHORT $LN4@OnMouseWhe
  00013	8b 8f 38 03 00
	00		 mov	 ecx, DWORD PTR [edi+824]
  00019	8b 01		 mov	 eax, DWORD PTR [ecx]
  0001b	ff 50 20	 call	 DWORD PTR [eax+32]
  0001e	85 c0		 test	 eax, eax
  00020	74 17		 je	 SHORT $LN3@OnMouseWhe
$LN4@OnMouseWhe:
  00022	33 c0		 xor	 eax, eax
  00024	66 3b 45 0c	 cmp	 ax, WORD PTR _zDelta$[ebp]
  00028	7d 14		 jge	 SHORT $LN2@OnMouseWhe
  0002a	8b 8f 38 03 00
	00		 mov	 ecx, DWORD PTR [edi+824]
  00030	8b 01		 mov	 eax, DWORD PTR [ecx]
  00032	ff 50 20	 call	 DWORD PTR [eax+32]
  00035	85 c0		 test	 eax, eax
  00037	74 05		 je	 SHORT $LN2@OnMouseWhe
$LN3@OnMouseWhe:

; 176  : 			nScrollValue = -5;

  00039	be fb ff ff ff	 mov	 esi, -5			; fffffffbH
$LN2@OnMouseWhe:

; 177  : 
; 178  : 	if(m_nMouseWheelIndex == 0)

  0003e	8b 45 08	 mov	 eax, DWORD PTR _nFlags$[ebp]
  00041	8b cf		 mov	 ecx, edi
  00043	83 e0 04	 and	 eax, 4
  00046	83 bf 2c 06 00
	00 00		 cmp	 DWORD PTR [edi+1580], 0
  0004d	6a 01		 push	 1
  0004f	75 17		 jne	 SHORT $LN5@OnMouseWhe

; 179  : 	{
; 180  : 		if( nFlags & MK_SHIFT)	ZoomTo( -nScrollValue, TRUE);

  00051	85 c0		 test	 eax, eax
  00053	75 17		 jne	 SHORT $LN14@OnMouseWhe
$LN15@OnMouseWhe:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl

; 458  : 	{ return (BOOL)Default(); }

  00055	56		 push	 esi
  00056	e8 00 00 00 00	 call	 ?ScrollTo@CKTBChartCtrl@@QAEHHH@Z ; CKTBChartCtrl::ScrollTo
  0005b	8b cf		 mov	 ecx, edi
  0005d	e8 00 00 00 00	 call	 ?Default@CWnd@@IAEJXZ	; CWnd::Default
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\KTBChart\KTBChartScroll.cpp

; 189  : 	return COleControl::OnMouseWheel(nFlags, zDelta, pt);

  00062	5f		 pop	 edi
  00063	5e		 pop	 esi

; 190  : }

  00064	5d		 pop	 ebp
  00065	c2 10 00	 ret	 16			; 00000010H
$LN5@OnMouseWhe:

; 181  : 		else					ScrollTo( nScrollValue, TRUE);
; 182  : 	}
; 183  : 	else
; 184  : 	{
; 185  : 		if( nFlags & MK_SHIFT)	ScrollTo( nScrollValue, TRUE);

  00068	85 c0		 test	 eax, eax
  0006a	75 e9		 jne	 SHORT $LN15@OnMouseWhe
$LN14@OnMouseWhe:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl

; 458  : 	{ return (BOOL)Default(); }

  0006c	f7 de		 neg	 esi
  0006e	56		 push	 esi
  0006f	e8 00 00 00 00	 call	 ?ZoomTo@CKTBChartCtrl@@IAEHJH@Z ; CKTBChartCtrl::ZoomTo
  00074	8b cf		 mov	 ecx, edi
  00076	e8 00 00 00 00	 call	 ?Default@CWnd@@IAEJXZ	; CWnd::Default
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\KTBChart\KTBChartScroll.cpp

; 189  : 	return COleControl::OnMouseWheel(nFlags, zDelta, pt);

  0007b	5f		 pop	 edi
  0007c	5e		 pop	 esi

; 190  : }

  0007d	5d		 pop	 ebp
  0007e	c2 10 00	 ret	 16			; 00000010H
?OnMouseWheel@CKTBChartCtrl@@IAEHIFVCPoint@@@Z ENDP	; CKTBChartCtrl::OnMouseWheel
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\KTBChart\KTBChartScroll.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	c2 00 00	 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\KTBChart\KTBChartScroll.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

  00000	c2 00 00	 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
