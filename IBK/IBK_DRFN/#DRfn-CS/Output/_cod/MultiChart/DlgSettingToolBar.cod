; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30145.0 

	TITLE	D:\git\src\IBK\IBK_DRFN\#DRfn-CS\_Obj\MultiChart\DlgSettingToolBar.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	___local_stdio_printf_options
PUBLIC	___local_stdio_scanf_options
PUBLIC	_sprintf
PUBLIC	_sscanf
PUBLIC	?AfxCrtErrorCheck@@YAHH@Z			; AfxCrtErrorCheck
PUBLIC	??1CObject@@UAE@XZ				; CObject::~CObject
PUBLIC	?Serialize@CObject@@UAEXAAVCArchive@@@Z		; CObject::Serialize
PUBLIC	?AssertValid@CObject@@UBEXXZ			; CObject::AssertValid
PUBLIC	?Dump@CObject@@UBEXAAVCDumpContext@@@Z		; CObject::Dump
PUBLIC	?DoDataExchange@CWnd@@MAEXPAVCDataExchange@@@Z	; CWnd::DoDataExchange
PUBLIC	?BeginModalState@CWnd@@UAEXXZ			; CWnd::BeginModalState
PUBLIC	?EndModalState@CWnd@@UAEXXZ			; CWnd::EndModalState
PUBLIC	?Create@CDialog@@UAEHIPAVCWnd@@@Z		; CDialog::Create
PUBLIC	??_GCListBox@@UAEPAXI@Z				; CListBox::`scalar deleting destructor'
PUBLIC	??_GCComboBox@@UAEPAXI@Z			; CComboBox::`scalar deleting destructor'
PUBLIC	??0?$CArray@HH@@QAE@XZ				; CArray<int,int>::CArray<int,int>
PUBLIC	?SetSize@?$CArray@HH@@QAEXHH@Z			; CArray<int,int>::SetSize
PUBLIC	?GetAt@?$CArray@HH@@QAEAAHH@Z			; CArray<int,int>::GetAt
PUBLIC	?SetAtGrow@?$CArray@HH@@QAEXHH@Z		; CArray<int,int>::SetAtGrow
PUBLIC	?InsertAt@?$CArray@HH@@QAEXHHH@Z		; CArray<int,int>::InsertAt
PUBLIC	?RemoveAt@?$CArray@HH@@QAEXHH@Z			; CArray<int,int>::RemoveAt
PUBLIC	??1?$CArray@HH@@UAE@XZ				; CArray<int,int>::~CArray<int,int>
PUBLIC	?Serialize@?$CArray@HH@@UAEXAAVCArchive@@@Z	; CArray<int,int>::Serialize
PUBLIC	??_G?$CArray@HH@@UAEPAXI@Z			; CArray<int,int>::`scalar deleting destructor'
PUBLIC	??0?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@QAE@H@Z ; CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >::CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >
PUBLIC	?Lookup@?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@QBEHHAAV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ; CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >::Lookup
PUBLIC	??A?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@QAEAAV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z ; CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >::operator[]
PUBLIC	?SetAt@?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@QAEXHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ; CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >::SetAt
PUBLIC	?RemoveKey@?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@QAEHH@Z ; CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >::RemoveKey
PUBLIC	?RemoveAll@?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@QAEXXZ ; CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >::RemoveAll
PUBLIC	?InitHashTable@?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@QAEXIH@Z ; CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >::InitHashTable
PUBLIC	?NewAssoc@?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@IAEPAVCAssoc@1@H@Z ; CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >::NewAssoc
PUBLIC	?FreeAssoc@?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@IAEXPAVCAssoc@1@@Z ; CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >::FreeAssoc
PUBLIC	?GetAssocAt@?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@IBEPAVCAssoc@1@HAAI0@Z ; CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >::GetAssocAt
PUBLIC	??1?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@UAE@XZ ; CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >::~CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >
PUBLIC	?Serialize@?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@UAEXAAVCArchive@@@Z ; CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >::Serialize
PUBLIC	??_G?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@UAEPAXI@Z ; CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >::`scalar deleting destructor'
PUBLIC	?GetFieldData@CDlgSettingToolBar@@AAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAHAAV23@@Z ; CDlgSettingToolBar::GetFieldData
PUBLIC	?ReadIniFile@CDlgSettingToolBar@@AAEXH@Z	; CDlgSettingToolBar::ReadIniFile
PUBLIC	?FillShowList@CDlgSettingToolBar@@AAEXAAV?$CArray@HH@@AAV?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@@Z ; CDlgSettingToolBar::FillShowList
PUBLIC	?FillAvailableList@CDlgSettingToolBar@@AAEXAAV?$CArray@HH@@AAV?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@@Z ; CDlgSettingToolBar::FillAvailableList
PUBLIC	??0CDlgSettingToolBar@@QAE@PAVCWnd@@@Z		; CDlgSettingToolBar::CDlgSettingToolBar
PUBLIC	?DoDataExchange@CDlgSettingToolBar@@MAEXPAVCDataExchange@@@Z ; CDlgSettingToolBar::DoDataExchange
PUBLIC	?OnInitDialog@CDlgSettingToolBar@@MAEHXZ	; CDlgSettingToolBar::OnInitDialog
PUBLIC	?OnOK@CDlgSettingToolBar@@MAEXXZ		; CDlgSettingToolBar::OnOK
PUBLIC	?OnCancel@CDlgSettingToolBar@@MAEXXZ		; CDlgSettingToolBar::OnCancel
PUBLIC	?OnApply@CDlgSettingToolBar@@IAEXXZ		; CDlgSettingToolBar::OnApply
PUBLIC	?OnSelchangeCmbAvailable@CDlgSettingToolBar@@IAEXXZ ; CDlgSettingToolBar::OnSelchangeCmbAvailable
PUBLIC	?OnSelchangeCmbShow@CDlgSettingToolBar@@IAEXXZ	; CDlgSettingToolBar::OnSelchangeCmbShow
PUBLIC	?OnBtnAdd@CDlgSettingToolBar@@IAEXXZ		; CDlgSettingToolBar::OnBtnAdd
PUBLIC	?OnBtnInit@CDlgSettingToolBar@@IAEXXZ		; CDlgSettingToolBar::OnBtnInit
PUBLIC	?OnBtnMovedown@CDlgSettingToolBar@@IAEXXZ	; CDlgSettingToolBar::OnBtnMovedown
PUBLIC	?OnBtnMovsyp@CDlgSettingToolBar@@IAEXXZ		; CDlgSettingToolBar::OnBtnMovsyp
PUBLIC	?OnBtnRemove@CDlgSettingToolBar@@IAEXXZ		; CDlgSettingToolBar::OnBtnRemove
PUBLIC	?OnBtnRemoveall@CDlgSettingToolBar@@IAEXXZ	; CDlgSettingToolBar::OnBtnRemoveall
PUBLIC	?OnBtnAddall@CDlgSettingToolBar@@IAEXXZ		; CDlgSettingToolBar::OnBtnAddall
PUBLIC	?OnDblclkListAdd@CDlgSettingToolBar@@IAEXXZ	; CDlgSettingToolBar::OnDblclkListAdd
PUBLIC	?OnDblclkListRemove@CDlgSettingToolBar@@IAEXXZ	; CDlgSettingToolBar::OnDblclkListRemove
PUBLIC	?GetThisMessageMap@CDlgSettingToolBar@@KGPBUAFX_MSGMAP@@XZ ; CDlgSettingToolBar::GetThisMessageMap
PUBLIC	?GetMessageMap@CDlgSettingToolBar@@MBEPBUAFX_MSGMAP@@XZ ; CDlgSettingToolBar::GetMessageMap
PUBLIC	??_GCDlgSettingToolBar@@UAEPAXI@Z		; CDlgSettingToolBar::`scalar deleting destructor'
PUBLIC	??$SerializeElements@H@@YGXAAVCArchive@@PAHH@Z	; SerializeElements<int>
PUBLIC	??$CompareElements@HH@@YGHPBH0@Z		; CompareElements<int,int>
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	?_OptionsStorage@?1??__local_stdio_scanf_options@@9@4_KA ; `__local_stdio_scanf_options'::`2'::_OptionsStorage
PUBLIC	??_C@_02DPKJAMEF@?$CFd@				; `string'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_7CListBox@@6B@				; CListBox::`vftable'
PUBLIC	??_7CComboBox@@6B@				; CComboBox::`vftable'
PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
PUBLIC	??_C@_0M@CBBNGGHM@PcTrMng?4dll@			; `string'
PUBLIC	??_C@_06NDLAHCHE@?$CFs?$CF08X@			; `string'
PUBLIC	??_C@_02EMFKHFLK@?$CFX@				; `string'
PUBLIC	??_R0?AVCObject@@@8				; CObject `RTTI Type Descriptor'
PUBLIC	??_R3CObject@@8					; CObject::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CObject@@8					; CObject::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CObject@@8			; CObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@CWnd@@8				; CWnd::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCWnd@@@8				; CWnd `RTTI Type Descriptor'
PUBLIC	??_R3CWnd@@8					; CWnd::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CWnd@@8					; CWnd::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CCmdTarget@@8			; CCmdTarget::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCCmdTarget@@@8				; CCmdTarget `RTTI Type Descriptor'
PUBLIC	??_R3CCmdTarget@@8				; CCmdTarget::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CCmdTarget@@8				; CCmdTarget::`RTTI Base Class Array'
PUBLIC	??_R4CListBox@@6B@				; CListBox::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCListBox@@@8				; CListBox `RTTI Type Descriptor'
PUBLIC	??_R3CListBox@@8				; CListBox::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CListBox@@8				; CListBox::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CListBox@@8			; CListBox::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4CComboBox@@6B@				; CComboBox::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCComboBox@@@8				; CComboBox `RTTI Type Descriptor'
PUBLIC	??_R3CComboBox@@8				; CComboBox::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CComboBox@@8				; CComboBox::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CComboBox@@8			; CComboBox::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@CDialog@@8			; CDialog::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCDialog@@@8				; CDialog `RTTI Type Descriptor'
PUBLIC	??_R3CDialog@@8					; CDialog::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CDialog@@8					; CDialog::`RTTI Base Class Array'
PUBLIC	??_7?$CArray@HH@@6B@				; CArray<int,int>::`vftable'
PUBLIC	??_7?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@6B@ ; CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >::`vftable'
PUBLIC	??_7CDlgSettingToolBar@@6B@			; CDlgSettingToolBar::`vftable'
PUBLIC	??_C@_0BD@CMCCCNBF@HANAROIGATEMANAGER@		; `string'
PUBLIC	??_C@_06DJNEHHKG@?2Chart@			; `string'
PUBLIC	??_C@_0BI@OIIEJFGC@ChartToolBarSetting?4dat@	; `string'
PUBLIC	??_C@_05BMGBEOOC@?$CFs?2?$CFs@			; `string'
PUBLIC	??_C@_07NCHCCDCP@VERSION@			; `string'
PUBLIC	??_C@_05GKHKKECO@TOTAL@				; `string'
PUBLIC	??_C@_09NBFPFBIM@ANAL?5LIST@			; `string'
PUBLIC	??_C@_05EFFCCOAM@COUNT@				; `string'
PUBLIC	??_C@_04OGKJMPGK@?$CF02d@			; `string'
PUBLIC	??_C@_05KFJOKFOM@?$CFd?0?$CFs@			; `string'
PUBLIC	??_C@_0O@PLHPCCBM@ADDITION?5LIST@		; `string'
PUBLIC	??_C@_09BBDODMFB@USER?5LIST@			; `string'
PUBLIC	??_C@_0CE@IAFEBKKH@?G?X?$LE?g?5?G?W?$LI?q?$MA?$LK?5?$MA?L?$LJ?L?5?$LI?q?$LH?O?$LP?$KB?5?A?$LI?$MA?g?G?U?$LE@ ; `string'
PUBLIC	??_C@_0CA@JNNFKBLA@?G?X?$LE?g?5?G?W?$LI?q?$MA?$LK?5?$LL?h?A?$KG?G?R?5?$LM?v?5?$LO?x?$LN?$MA?$LE?O?$LE?Y?4@ ; `string'
PUBLIC	??_C@_0L@PPOMAPHP@?B?w?F?$KO?E?x?F?m?A?$PN@	; `string'
PUBLIC	??_C@_0BL@NGMPOBLI@?$LE?u?$MA?L?$LL?s?5?$MA?L?$LF?$LP?G?R?5?$LM?v?5?$LO?x?$LN?$MA?$LE?O?$LE?Y?4@ ; `string'
PUBLIC	??_R4CDlgSettingToolBar@@6B@			; CDlgSettingToolBar::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCDlgSettingToolBar@@@8			; CDlgSettingToolBar `RTTI Type Descriptor'
PUBLIC	??_R3CDlgSettingToolBar@@8			; CDlgSettingToolBar::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CDlgSettingToolBar@@8			; CDlgSettingToolBar::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CDlgSettingToolBar@@8		; CDlgSettingToolBar::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CArray@HH@@6B@				; CArray<int,int>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CArray@HH@@@8				; CArray<int,int> `RTTI Type Descriptor'
PUBLIC	??_R3?$CArray@HH@@8				; CArray<int,int>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CArray@HH@@8				; CArray<int,int>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CArray@HH@@8			; CArray<int,int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@6B@ ; CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@@8 ; CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > > `RTTI Type Descriptor'
PUBLIC	??_R3?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@8 ; CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@8 ; CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@8 ; CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_L@YGXPAXIIP6EX0@Z1@Z:PROC			; `eh vector constructor iterator'
EXTRN	??_M@YGXPAXIIP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	?__global_delete@@YAXPAXI@Z:PROC		; __global_delete
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	___std_terminate:PROC
EXTRN	__imp___invalid_parameter_noinfo:PROC
EXTRN	__imp___errno:PROC
EXTRN	__imp__GetEnvironmentVariableA@12:PROC
EXTRN	__imp__GetModuleHandleA@4:PROC
EXTRN	__imp__GetPrivateProfileIntA@16:PROC
EXTRN	__imp__GetPrivateProfileStringA@24:PROC
EXTRN	__imp__WritePrivateProfileStringA@16:PROC
EXTRN	__imp__SendMessageA@16:PROC
EXTRN	__imp__EnableWindow@8:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	__imp____stdio_common_vsscanf:PROC
EXTRN	__imp__atoi:PROC
EXTRN	?AfxThrowMemoryException@@YGXXZ:PROC		; AfxThrowMemoryException
EXTRN	?AfxThrowInvalidArgException@@YGXXZ:PROC	; AfxThrowInvalidArgException
EXTRN	?AfxThrowArchiveException@@YGXHPBD@Z:PROC	; AfxThrowArchiveException
EXTRN	?GetRuntimeClass@CObject@@UBEPAUCRuntimeClass@@XZ:PROC ; CObject::GetRuntimeClass
EXTRN	__imp_?GetBuffer@?$CSimpleStringT@D$00@ATL@@QAEPADH@Z:PROC
EXTRN	__imp_?ReleaseBuffer@?$CSimpleStringT@D$00@ATL@@QAEXH@Z:PROC
EXTRN	__imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ:PROC
EXTRN	__imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z:PROC
EXTRN	__imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z:PROC
EXTRN	__imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ:PROC
EXTRN	__imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z:PROC
EXTRN	__imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z:PROC
EXTRN	__imp_??Y?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z:PROC
EXTRN	__imp_?Delete@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEHHH@Z:PROC
EXTRN	__imp_?Find@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEHDH@Z:PROC
EXTRN	__imp_?Left@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBE?AV12@H@Z:PROC
EXTRN	__imp_?Format@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAAXPBDZZ:PROC
EXTRN	??0CFileFind@@QAE@XZ:PROC			; CFileFind::CFileFind
EXTRN	??1CFileFind@@UAE@XZ:PROC			; CFileFind::~CFileFind
EXTRN	?FindFile@CFileFind@@UAEHPBDK@Z:PROC		; CFileFind::FindFile
EXTRN	?Read@CArchive@@QAEIPAXI@Z:PROC			; CArchive::Read
EXTRN	?Write@CArchive@@QAEXPBXI@Z:PROC		; CArchive::Write
EXTRN	?ReadCount@CArchive@@QAEKXZ:PROC		; CArchive::ReadCount
EXTRN	?WriteCount@CArchive@@QAEXK@Z:PROC		; CArchive::WriteCount
EXTRN	?Create@CPlex@@SGPAU1@AAPAU1@II@Z:PROC		; CPlex::Create
EXTRN	?FreeDataChain@CPlex@@QAEXXZ:PROC		; CPlex::FreeDataChain
EXTRN	??$SerializeElements@V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@@YGXAAVCArchive@@PAV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z:PROC ; SerializeElements<ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >
EXTRN	?DDX_Control@@YGXPAVCDataExchange@@HAAVCWnd@@@Z:PROC ; DDX_Control
EXTRN	?OnCmdMsg@CCmdTarget@@UAEHIHPAXPAUAFX_CMDHANDLERINFO@@@Z:PROC ; CCmdTarget::OnCmdMsg
EXTRN	?IsInvokeAllowed@CCmdTarget@@UAEHJ@Z:PROC	; CCmdTarget::IsInvokeAllowed
EXTRN	?GetDispatchIID@CCmdTarget@@UAEHPAU_GUID@@@Z:PROC ; CCmdTarget::GetDispatchIID
EXTRN	?GetTypeInfoCount@CCmdTarget@@UAEIXZ:PROC	; CCmdTarget::GetTypeInfoCount
EXTRN	?GetTypeLibCache@CCmdTarget@@UAEPAVCTypeLibCache@@XZ:PROC ; CCmdTarget::GetTypeLibCache
EXTRN	?GetTypeLib@CCmdTarget@@UAEJKPAPAUITypeLib@@@Z:PROC ; CCmdTarget::GetTypeLib
EXTRN	?GetCommandMap@CCmdTarget@@MBEPBUAFX_OLECMDMAP@@XZ:PROC ; CCmdTarget::GetCommandMap
EXTRN	?GetDispatchMap@CCmdTarget@@MBEPBUAFX_DISPMAP@@XZ:PROC ; CCmdTarget::GetDispatchMap
EXTRN	?GetConnectionMap@CCmdTarget@@MBEPBUAFX_CONNECTIONMAP@@XZ:PROC ; CCmdTarget::GetConnectionMap
EXTRN	?GetEventSinkMap@CCmdTarget@@MBEPBUAFX_EVENTSINKMAP@@XZ:PROC ; CCmdTarget::GetEventSinkMap
EXTRN	?OnCreateAggregates@CCmdTarget@@UAEHXZ:PROC	; CCmdTarget::OnCreateAggregates
EXTRN	?GetInterfaceHook@CCmdTarget@@UAEPAUIUnknown@@PBX@Z:PROC ; CCmdTarget::GetInterfaceHook
EXTRN	?GetExtraConnectionPoints@CCmdTarget@@MAEHPAVCPtrArray@@@Z:PROC ; CCmdTarget::GetExtraConnectionPoints
EXTRN	?GetConnectionHook@CCmdTarget@@MAEPAUIConnectionPoint@@ABU_GUID@@@Z:PROC ; CCmdTarget::GetConnectionHook
EXTRN	??0CWnd@@QAE@XZ:PROC				; CWnd::CWnd
EXTRN	?PreSubclassWindow@CWnd@@UAEXXZ:PROC		; CWnd::PreSubclassWindow
EXTRN	?Create@CWnd@@UAEHPBD0KABUtagRECT@@PAV1@IPAUCCreateContext@@@Z:PROC ; CWnd::Create
EXTRN	?CreateEx@CWnd@@UAEHKPBD0KHHHHPAUHWND__@@PAUHMENU__@@PAX@Z:PROC ; CWnd::CreateEx
EXTRN	?CreateEx@CWnd@@UAEHKPBD0KABUtagRECT@@PAV1@IPAX@Z:PROC ; CWnd::CreateEx
EXTRN	?DestroyWindow@CWnd@@UAEHXZ:PROC		; CWnd::DestroyWindow
EXTRN	?PreCreateWindow@CWnd@@UAEHAAUtagCREATESTRUCTA@@@Z:PROC ; CWnd::PreCreateWindow
EXTRN	?CalcWindowRect@CWnd@@UAEXPAUtagRECT@@I@Z:PROC	; CWnd::CalcWindowRect
EXTRN	?GetDlgItem@CWnd@@QBEPAV1@H@Z:PROC		; CWnd::GetDlgItem
EXTRN	?GetMenu@CWnd@@UBEPAVCMenu@@XZ:PROC		; CWnd::GetMenu
EXTRN	?SetMenu@CWnd@@UAEHPAVCMenu@@@Z:PROC		; CWnd::SetMenu
EXTRN	?OnToolHitTest@CWnd@@UBEHVCPoint@@PAUtagTOOLINFOA@@@Z:PROC ; CWnd::OnToolHitTest
EXTRN	?EnableWindow@CWnd@@QAEHH@Z:PROC		; CWnd::EnableWindow
EXTRN	?GetScrollBarCtrl@CWnd@@UBEPAVCScrollBar@@H@Z:PROC ; CWnd::GetScrollBarCtrl
EXTRN	?WinHelpA@CWnd@@UAEXKI@Z:PROC			; CWnd::WinHelpA
EXTRN	?HtmlHelpA@CWnd@@UAEXKI@Z:PROC			; CWnd::HtmlHelpA
EXTRN	?WinHelpInternal@CWnd@@UAEXKI@Z:PROC		; CWnd::WinHelpInternal
EXTRN	?ContinueModal@CWnd@@UAEHXZ:PROC		; CWnd::ContinueModal
EXTRN	?EndModalLoop@CWnd@@UAEXH@Z:PROC		; CWnd::EndModalLoop
EXTRN	?OnDrawIconicThumbnailOrLivePreview@CWnd@@UAEXAAVCDC@@VCRect@@VCSize@@HAAH@Z:PROC ; CWnd::OnDrawIconicThumbnailOrLivePreview
EXTRN	?GetInterfaceMap@CWnd@@MBEPBUAFX_INTERFACEMAP@@XZ:PROC ; CWnd::GetInterfaceMap
EXTRN	?EnsureStdObj@CWnd@@UAEJXZ:PROC			; CWnd::EnsureStdObj
EXTRN	?get_accParent@CWnd@@UAEJPAPAUIDispatch@@@Z:PROC ; CWnd::get_accParent
EXTRN	?get_accChildCount@CWnd@@UAEJPAJ@Z:PROC		; CWnd::get_accChildCount
EXTRN	?get_accChild@CWnd@@UAEJUtagVARIANT@@PAPAUIDispatch@@@Z:PROC ; CWnd::get_accChild
EXTRN	?get_accName@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z:PROC ; CWnd::get_accName
EXTRN	?get_accValue@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z:PROC ; CWnd::get_accValue
EXTRN	?get_accDescription@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z:PROC ; CWnd::get_accDescription
EXTRN	?get_accRole@CWnd@@UAEJUtagVARIANT@@PAU2@@Z:PROC ; CWnd::get_accRole
EXTRN	?get_accState@CWnd@@UAEJUtagVARIANT@@PAU2@@Z:PROC ; CWnd::get_accState
EXTRN	?get_accHelp@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z:PROC ; CWnd::get_accHelp
EXTRN	?get_accHelpTopic@CWnd@@UAEJPAPA_WUtagVARIANT@@PAJ@Z:PROC ; CWnd::get_accHelpTopic
EXTRN	?get_accKeyboardShortcut@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z:PROC ; CWnd::get_accKeyboardShortcut
EXTRN	?get_accFocus@CWnd@@UAEJPAUtagVARIANT@@@Z:PROC	; CWnd::get_accFocus
EXTRN	?get_accSelection@CWnd@@UAEJPAUtagVARIANT@@@Z:PROC ; CWnd::get_accSelection
EXTRN	?get_accDefaultAction@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z:PROC ; CWnd::get_accDefaultAction
EXTRN	?accSelect@CWnd@@UAEJJUtagVARIANT@@@Z:PROC	; CWnd::accSelect
EXTRN	?accLocation@CWnd@@UAEJPAJ000UtagVARIANT@@@Z:PROC ; CWnd::accLocation
EXTRN	?accNavigate@CWnd@@UAEJJUtagVARIANT@@PAU2@@Z:PROC ; CWnd::accNavigate
EXTRN	?accHitTest@CWnd@@UAEJJJPAUtagVARIANT@@@Z:PROC	; CWnd::accHitTest
EXTRN	?accDoDefaultAction@CWnd@@UAEJUtagVARIANT@@@Z:PROC ; CWnd::accDoDefaultAction
EXTRN	?put_accName@CWnd@@UAEJUtagVARIANT@@PA_W@Z:PROC	; CWnd::put_accName
EXTRN	?put_accValue@CWnd@@UAEJUtagVARIANT@@PA_W@Z:PROC ; CWnd::put_accValue
EXTRN	?SetProxy@CWnd@@UAEJPAUIAccessibleProxy@@@Z:PROC ; CWnd::SetProxy
EXTRN	?CreateAccessibleProxy@CWnd@@UAEJIJPAJ@Z:PROC	; CWnd::CreateAccessibleProxy
EXTRN	?OnCommand@CWnd@@MAEHIJ@Z:PROC			; CWnd::OnCommand
EXTRN	?OnNotify@CWnd@@MAEHIJPAJ@Z:PROC		; CWnd::OnNotify
EXTRN	?GetSuperWndProcAddr@CWnd@@MAEPAP6GJPAUHWND__@@IIJ@ZXZ:PROC ; CWnd::GetSuperWndProcAddr
EXTRN	?PreTranslateMessage@CWnd@@UAEHPAUtagMSG@@@Z:PROC ; CWnd::PreTranslateMessage
EXTRN	?OnAmbientProperty@CWnd@@UAEHPAVCOleControlSite@@JPAUtagVARIANT@@@Z:PROC ; CWnd::OnAmbientProperty
EXTRN	?WindowProc@CWnd@@MAEJIIJ@Z:PROC		; CWnd::WindowProc
EXTRN	?OnWndMsg@CWnd@@MAEHIIJPAJ@Z:PROC		; CWnd::OnWndMsg
EXTRN	?DefWindowProcA@CWnd@@MAEJIIJ@Z:PROC		; CWnd::DefWindowProcA
EXTRN	?PostNcDestroy@CWnd@@MAEXXZ:PROC		; CWnd::PostNcDestroy
EXTRN	?OnChildNotify@CWnd@@MAEHIIJPAJ@Z:PROC		; CWnd::OnChildNotify
EXTRN	?OnTouchInputs@CWnd@@MAEHIPAUtagTOUCHINPUT@@@Z:PROC ; CWnd::OnTouchInputs
EXTRN	?OnTouchInput@CWnd@@MAEHVCPoint@@HHPAUtagTOUCHINPUT@@@Z:PROC ; CWnd::OnTouchInput
EXTRN	?GetGestureStatus@CWnd@@MAEKVCPoint@@@Z:PROC	; CWnd::GetGestureStatus
EXTRN	?OnGestureZoom@CWnd@@MAEHVCPoint@@J@Z:PROC	; CWnd::OnGestureZoom
EXTRN	?OnGesturePan@CWnd@@MAEHVCPoint@@0@Z:PROC	; CWnd::OnGesturePan
EXTRN	?OnGestureRotate@CWnd@@MAEHVCPoint@@N@Z:PROC	; CWnd::OnGestureRotate
EXTRN	?OnGestureTwoFingerTap@CWnd@@MAEHVCPoint@@@Z:PROC ; CWnd::OnGestureTwoFingerTap
EXTRN	?OnGesturePressAndTap@CWnd@@MAEHVCPoint@@J@Z:PROC ; CWnd::OnGesturePressAndTap
EXTRN	?ResizeDynamicLayout@CWnd@@MAEXXZ:PROC		; CWnd::ResizeDynamicLayout
EXTRN	?CheckAutoCenter@CWnd@@UAEHXZ:PROC		; CWnd::CheckAutoCenter
EXTRN	?IsFrameWnd@CWnd@@UBEHXZ:PROC			; CWnd::IsFrameWnd
EXTRN	?OnFinalRelease@CWnd@@UAEXXZ:PROC		; CWnd::OnFinalRelease
EXTRN	?CreateControlContainer@CWnd@@MAEHPAPAVCOleControlContainer@@@Z:PROC ; CWnd::CreateControlContainer
EXTRN	?CreateControlSite@CWnd@@MAEHPAVCOleControlContainer@@PAPAVCOleControlSite@@IABU_GUID@@@Z:PROC ; CWnd::CreateControlSite
EXTRN	?SetOccDialogInfo@CWnd@@MAEHPAU_AFX_OCC_DIALOG_INFO@@@Z:PROC ; CWnd::SetOccDialogInfo
EXTRN	?GetOccDialogInfo@CWnd@@MAEPAU_AFX_OCC_DIALOG_INFO@@XZ:PROC ; CWnd::GetOccDialogInfo
EXTRN	?GetMessageMap@CWnd@@MBEPBUAFX_MSGMAP@@XZ:PROC	; CWnd::GetMessageMap
EXTRN	?GetRuntimeClass@CDialog@@UBEPAUCRuntimeClass@@XZ:PROC ; CDialog::GetRuntimeClass
EXTRN	?Create@CDialog@@UAEHPBDPAVCWnd@@@Z:PROC	; CDialog::Create
EXTRN	?CreateIndirect@CDialog@@UAEHPBUDLGTEMPLATE@@PAVCWnd@@PAX@Z:PROC ; CDialog::CreateIndirect
EXTRN	?CreateIndirect@CDialog@@UAEHPAXPAVCWnd@@@Z:PROC ; CDialog::CreateIndirect
EXTRN	??0CDialog@@QAE@IPAVCWnd@@@Z:PROC		; CDialog::CDialog
EXTRN	?DoModal@CDialog@@UAEHXZ:PROC			; CDialog::DoModal
EXTRN	?OnInitDialog@CDialog@@UAEHXZ:PROC		; CDialog::OnInitDialog
EXTRN	?OnSetFont@CDialog@@UAEXPAVCFont@@@Z:PROC	; CDialog::OnSetFont
EXTRN	?OnOK@CDialog@@MAEXXZ:PROC			; CDialog::OnOK
EXTRN	?OnCancel@CDialog@@MAEXXZ:PROC			; CDialog::OnCancel
EXTRN	??1CDialog@@UAE@XZ:PROC				; CDialog::~CDialog
EXTRN	?PreTranslateMessage@CDialog@@UAEHPAUtagMSG@@@Z:PROC ; CDialog::PreTranslateMessage
EXTRN	?OnCmdMsg@CDialog@@UAEHIHPAXPAUAFX_CMDHANDLERINFO@@@Z:PROC ; CDialog::OnCmdMsg
EXTRN	?CheckAutoCenter@CDialog@@UAEHXZ:PROC		; CDialog::CheckAutoCenter
EXTRN	?SetOccDialogInfo@CDialog@@MAEHPAU_AFX_OCC_DIALOG_INFO@@@Z:PROC ; CDialog::SetOccDialogInfo
EXTRN	?GetOccDialogInfo@CDialog@@MAEPAU_AFX_OCC_DIALOG_INFO@@XZ:PROC ; CDialog::GetOccDialogInfo
EXTRN	?PreInitDialog@CDialog@@MAEXXZ:PROC		; CDialog::PreInitDialog
EXTRN	?GetThisMessageMap@CDialog@@KGPBUAFX_MSGMAP@@XZ:PROC ; CDialog::GetThisMessageMap
EXTRN	?GetRuntimeClass@CListBox@@UBEPAUCRuntimeClass@@XZ:PROC ; CListBox::GetRuntimeClass
EXTRN	?Create@CListBox@@UAEHKABUtagRECT@@PAVCWnd@@I@Z:PROC ; CListBox::Create
EXTRN	?DrawItem@CListBox@@UAEXPAUtagDRAWITEMSTRUCT@@@Z:PROC ; CListBox::DrawItem
EXTRN	?MeasureItem@CListBox@@UAEXPAUtagMEASUREITEMSTRUCT@@@Z:PROC ; CListBox::MeasureItem
EXTRN	?CompareItem@CListBox@@UAEHPAUtagCOMPAREITEMSTRUCT@@@Z:PROC ; CListBox::CompareItem
EXTRN	?DeleteItem@CListBox@@UAEXPAUtagDELETEITEMSTRUCT@@@Z:PROC ; CListBox::DeleteItem
EXTRN	?VKeyToItem@CListBox@@UAEHII@Z:PROC		; CListBox::VKeyToItem
EXTRN	?CharToItem@CListBox@@UAEHII@Z:PROC		; CListBox::CharToItem
EXTRN	??1CListBox@@UAE@XZ:PROC			; CListBox::~CListBox
EXTRN	?OnChildNotify@CListBox@@MAEHIIJPAJ@Z:PROC	; CListBox::OnChildNotify
EXTRN	??_ECListBox@@UAEPAXI@Z:PROC			; CListBox::`vector deleting destructor'
EXTRN	?GetRuntimeClass@CComboBox@@UBEPAUCRuntimeClass@@XZ:PROC ; CComboBox::GetRuntimeClass
EXTRN	?Create@CComboBox@@UAEHKABUtagRECT@@PAVCWnd@@I@Z:PROC ; CComboBox::Create
EXTRN	?DrawItem@CComboBox@@UAEXPAUtagDRAWITEMSTRUCT@@@Z:PROC ; CComboBox::DrawItem
EXTRN	?MeasureItem@CComboBox@@UAEXPAUtagMEASUREITEMSTRUCT@@@Z:PROC ; CComboBox::MeasureItem
EXTRN	?CompareItem@CComboBox@@UAEHPAUtagCOMPAREITEMSTRUCT@@@Z:PROC ; CComboBox::CompareItem
EXTRN	?DeleteItem@CComboBox@@UAEXPAUtagDELETEITEMSTRUCT@@@Z:PROC ; CComboBox::DeleteItem
EXTRN	??1CComboBox@@UAE@XZ:PROC			; CComboBox::~CComboBox
EXTRN	?OnChildNotify@CComboBox@@MAEHIIJPAJ@Z:PROC	; CComboBox::OnChildNotify
EXTRN	??_ECComboBox@@UAEPAXI@Z:PROC			; CComboBox::`vector deleting destructor'
EXTRN	?AfxMessageBox@@YGHPBDII@Z:PROC			; AfxMessageBox
EXTRN	??_E?$CArray@HH@@UAEPAXI@Z:PROC			; CArray<int,int>::`vector deleting destructor'
EXTRN	??_E?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@UAEPAXI@Z:PROC ; CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >::`vector deleting destructor'
EXTRN	??_ECDlgSettingToolBar@@UAEPAXI@Z:PROC		; CDlgSettingToolBar::`vector deleting destructor'
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	_memset:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___security_cookie:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ?_OptionsStorage@?1??__local_stdio_scanf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_scanf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_scanf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@8 DD FLAT:??_R0?AV?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@@8 ; CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@8
rdata$r	SEGMENT
??_R2?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@8 DD FLAT:??_R1A@?0A@EA@?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@8 ; CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CObject@@8
rdata$r	ENDS
;	COMDAT ??_R3?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@8
rdata$r	SEGMENT
??_R3?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@8 DD 00H ; CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@@8
data$rs	SEGMENT
??_R0?AV?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@@8 DD FLAT:??_7type_info@@6B@ ; CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTrait'
	DB	'sCRT@D@ATL@@@@@ATL@@V12@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@6B@
rdata$r	SEGMENT
??_R4?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@6B@ DD 00H ; CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@@8
	DD	FLAT:??_R3?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CArray@HH@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CArray@HH@@8 DD FLAT:??_R0?AV?$CArray@HH@@@8 ; CArray<int,int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CArray@HH@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CArray@HH@@8
rdata$r	SEGMENT
??_R2?$CArray@HH@@8 DD FLAT:??_R1A@?0A@EA@?$CArray@HH@@8 ; CArray<int,int>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CObject@@8
rdata$r	ENDS
;	COMDAT ??_R3?$CArray@HH@@8
rdata$r	SEGMENT
??_R3?$CArray@HH@@8 DD 00H				; CArray<int,int>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$CArray@HH@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CArray@HH@@@8
data$rs	SEGMENT
??_R0?AV?$CArray@HH@@@8 DD FLAT:??_7type_info@@6B@	; CArray<int,int> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CArray@HH@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CArray@HH@@6B@
rdata$r	SEGMENT
??_R4?$CArray@HH@@6B@ DD 00H				; CArray<int,int>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CArray@HH@@@8
	DD	FLAT:??_R3?$CArray@HH@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CDlgSettingToolBar@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CDlgSettingToolBar@@8 DD FLAT:??_R0?AVCDlgSettingToolBar@@@8 ; CDlgSettingToolBar::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CDlgSettingToolBar@@8
rdata$r	ENDS
;	COMDAT ??_R2CDlgSettingToolBar@@8
rdata$r	SEGMENT
??_R2CDlgSettingToolBar@@8 DD FLAT:??_R1A@?0A@EA@CDlgSettingToolBar@@8 ; CDlgSettingToolBar::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CDialog@@8
	DD	FLAT:??_R1A@?0A@EA@CWnd@@8
	DD	FLAT:??_R1A@?0A@EA@CCmdTarget@@8
	DD	FLAT:??_R1A@?0A@EA@CObject@@8
rdata$r	ENDS
;	COMDAT ??_R3CDlgSettingToolBar@@8
rdata$r	SEGMENT
??_R3CDlgSettingToolBar@@8 DD 00H			; CDlgSettingToolBar::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	05H
	DD	FLAT:??_R2CDlgSettingToolBar@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCDlgSettingToolBar@@@8
data$rs	SEGMENT
??_R0?AVCDlgSettingToolBar@@@8 DD FLAT:??_7type_info@@6B@ ; CDlgSettingToolBar `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCDlgSettingToolBar@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CDlgSettingToolBar@@6B@
rdata$r	SEGMENT
??_R4CDlgSettingToolBar@@6B@ DD 00H			; CDlgSettingToolBar::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCDlgSettingToolBar@@@8
	DD	FLAT:??_R3CDlgSettingToolBar@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BL@NGMPOBLI@?$LE?u?$MA?L?$LL?s?5?$MA?L?$LF?$LP?G?R?5?$LM?v?5?$LO?x?$LN?$MA?$LE?O?$LE?Y?4@
CONST	SEGMENT
??_C@_0BL@NGMPOBLI@?$LE?u?$MA?L?$LL?s?5?$MA?L?$LF?$LP?G?R?5?$LM?v?5?$LO?x?$LN?$MA?$LE?O?$LE?Y?4@ DB 0b4H
	DB	0f5H, 0c0H, 0ccH, 0bbH, 0f3H, ' ', 0c0H, 0ccH, 0b5H, 0bfH, 0c7H
	DB	0d2H, ' ', 0bcH, 0f6H, ' ', 0beH, 0f8H, 0bdH, 0c0H, 0b4H, 0cfH
	DB	0b4H, 0d9H, '.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PPOMAPHP@?B?w?F?$KO?E?x?F?m?A?$PN@
CONST	SEGMENT
??_C@_0L@PPOMAPHP@?B?w?F?$KO?E?x?F?m?A?$PN@ DB 0c2H, 0f7H, 0c6H, 0aeH, 0c5H
	DB	0f8H, 0c6H, 0edH, 0c1H, 0fdH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@JNNFKBLA@?G?X?$LE?g?5?G?W?$LI?q?$MA?$LK?5?$LL?h?A?$KG?G?R?5?$LM?v?5?$LO?x?$LN?$MA?$LE?O?$LE?Y?4@
CONST	SEGMENT
??_C@_0CA@JNNFKBLA@?G?X?$LE?g?5?G?W?$LI?q?$MA?$LK?5?$LL?h?A?$KG?G?R?5?$LM?v?5?$LO?x?$LN?$MA?$LE?O?$LE?Y?4@ DB 0c7H
	DB	0d8H, 0b4H, 0e7H, ' ', 0c7H, 0d7H, 0b8H, 0f1H, 0c0H, 0baH, ' ', 0bbH
	DB	0e8H, 0c1H, 0a6H, 0c7H, 0d2H, ' ', 0bcH, 0f6H, ' ', 0beH, 0f8H
	DB	0bdH, 0c0H, 0b4H, 0cfH, 0b4H, 0d9H, '.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@IAFEBKKH@?G?X?$LE?g?5?G?W?$LI?q?$MA?$LK?5?$MA?L?$LJ?L?5?$LI?q?$LH?O?$LP?$KB?5?A?$LI?$MA?g?G?U?$LE@
CONST	SEGMENT
??_C@_0CE@IAFEBKKH@?G?X?$LE?g?5?G?W?$LI?q?$MA?$LK?5?$MA?L?$LJ?L?5?$LI?q?$LH?O?$LP?$KB?5?A?$LI?$MA?g?G?U?$LE@ DB 0c7H
	DB	0d8H, 0b4H, 0e7H, ' ', 0c7H, 0d7H, 0b8H, 0f1H, 0c0H, 0baH, ' ', 0c0H
	DB	0ccH, 0b9H, 0ccH, ' ', 0b8H, 0f1H, 0b7H, 0cfH, 0bfH, 0a1H, ' ', 0c1H
	DB	0b8H, 0c0H, 0e7H, 0c7H, 0d5H, 0b4H, 0cfH, 0b4H, 0d9H, '.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09BBDODMFB@USER?5LIST@
CONST	SEGMENT
??_C@_09BBDODMFB@USER?5LIST@ DB 'USER LIST', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@PLHPCCBM@ADDITION?5LIST@
CONST	SEGMENT
??_C@_0O@PLHPCCBM@ADDITION?5LIST@ DB 'ADDITION LIST', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05KFJOKFOM@?$CFd?0?$CFs@
CONST	SEGMENT
??_C@_05KFJOKFOM@?$CFd?0?$CFs@ DB '%d,%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04OGKJMPGK@?$CF02d@
CONST	SEGMENT
??_C@_04OGKJMPGK@?$CF02d@ DB '%02d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05EFFCCOAM@COUNT@
CONST	SEGMENT
??_C@_05EFFCCOAM@COUNT@ DB 'COUNT', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09NBFPFBIM@ANAL?5LIST@
CONST	SEGMENT
??_C@_09NBFPFBIM@ANAL?5LIST@ DB 'ANAL LIST', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05GKHKKECO@TOTAL@
CONST	SEGMENT
??_C@_05GKHKKECO@TOTAL@ DB 'TOTAL', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07NCHCCDCP@VERSION@
CONST	SEGMENT
??_C@_07NCHCCDCP@VERSION@ DB 'VERSION', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05BMGBEOOC@?$CFs?2?$CFs@
CONST	SEGMENT
??_C@_05BMGBEOOC@?$CFs?2?$CFs@ DB '%s\%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@OIIEJFGC@ChartToolBarSetting?4dat@
CONST	SEGMENT
??_C@_0BI@OIIEJFGC@ChartToolBarSetting?4dat@ DB 'ChartToolBarSetting.dat', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06DJNEHHKG@?2Chart@
CONST	SEGMENT
??_C@_06DJNEHHKG@?2Chart@ DB '\Chart', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@CMCCCNBF@HANAROIGATEMANAGER@
CONST	SEGMENT
??_C@_0BD@CMCCCNBF@HANAROIGATEMANAGER@ DB 'HANAROIGATEMANAGER', 00H ; `string'
CONST	ENDS
;	COMDAT ?messageMap@?1??GetThisMessageMap@CDlgSettingToolBar@@KGPBUAFX_MSGMAP@@XZ@4U3@B
CONST	SEGMENT
?messageMap@?1??GetThisMessageMap@CDlgSettingToolBar@@KGPBUAFX_MSGMAP@@XZ@4U3@B DD FLAT:?GetThisMessageMap@CDialog@@KGPBUAFX_MSGMAP@@XZ ; `CDlgSettingToolBar::GetThisMessageMap'::`2'::messageMap
	DD	FLAT:?_messageEntries@?1??GetThisMessageMap@CDlgSettingToolBar@@KGPBUAFX_MSGMAP@@XZ@4QBUAFX_MSGMAP_ENTRY@@B
CONST	ENDS
;	COMDAT ?_messageEntries@?1??GetThisMessageMap@CDlgSettingToolBar@@KGPBUAFX_MSGMAP@@XZ@4QBUAFX_MSGMAP_ENTRY@@B
CONST	SEGMENT
?_messageEntries@?1??GetThisMessageMap@CDlgSettingToolBar@@KGPBUAFX_MSGMAP@@XZ@4QBUAFX_MSGMAP_ENTRY@@B DD 0111H ; `CDlgSettingToolBar::GetThisMessageMap'::`2'::_messageEntries
	DD	00H
	DD	03H
	DD	03H
	DD	03aH
	DD	FLAT:?OnApply@CDlgSettingToolBar@@IAEXXZ
	DD	0111H
	DD	01H
	DD	01876H
	DD	01876H
	DD	03aH
	DD	FLAT:?OnSelchangeCmbAvailable@CDlgSettingToolBar@@IAEXXZ
	DD	0111H
	DD	01H
	DD	01877H
	DD	01877H
	DD	03aH
	DD	FLAT:?OnSelchangeCmbShow@CDlgSettingToolBar@@IAEXXZ
	DD	0111H
	DD	00H
	DD	02b01H
	DD	02b01H
	DD	03aH
	DD	FLAT:?OnBtnAdd@CDlgSettingToolBar@@IAEXXZ
	DD	0111H
	DD	00H
	DD	02b02H
	DD	02b02H
	DD	03aH
	DD	FLAT:?OnBtnInit@CDlgSettingToolBar@@IAEXXZ
	DD	0111H
	DD	00H
	DD	02b07H
	DD	02b07H
	DD	03aH
	DD	FLAT:?OnBtnMovedown@CDlgSettingToolBar@@IAEXXZ
	DD	0111H
	DD	00H
	DD	02b06H
	DD	02b06H
	DD	03aH
	DD	FLAT:?OnBtnMovsyp@CDlgSettingToolBar@@IAEXXZ
	DD	0111H
	DD	00H
	DD	02b03H
	DD	02b03H
	DD	03aH
	DD	FLAT:?OnBtnRemove@CDlgSettingToolBar@@IAEXXZ
	DD	0111H
	DD	00H
	DD	02b04H
	DD	02b04H
	DD	03aH
	DD	FLAT:?OnBtnRemoveall@CDlgSettingToolBar@@IAEXXZ
	DD	0111H
	DD	00H
	DD	02b08H
	DD	02b08H
	DD	03aH
	DD	FLAT:?OnBtnAddall@CDlgSettingToolBar@@IAEXXZ
	DD	0111H
	DD	02H
	DD	02b00H
	DD	02b00H
	DD	03aH
	DD	FLAT:?OnDblclkListAdd@CDlgSettingToolBar@@IAEXXZ
	DD	0111H
	DD	02H
	DD	02b05H
	DD	02b05H
	DD	03aH
	DD	FLAT:?OnDblclkListRemove@CDlgSettingToolBar@@IAEXXZ
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT ??_7CDlgSettingToolBar@@6B@
CONST	SEGMENT
??_7CDlgSettingToolBar@@6B@ DD FLAT:??_R4CDlgSettingToolBar@@6B@ ; CDlgSettingToolBar::`vftable'
	DD	FLAT:?GetRuntimeClass@CDialog@@UBEPAUCRuntimeClass@@XZ
	DD	FLAT:??_ECDlgSettingToolBar@@UAEPAXI@Z
	DD	FLAT:?Serialize@CObject@@UAEXAAVCArchive@@@Z
	DD	FLAT:?AssertValid@CObject@@UBEXXZ
	DD	FLAT:?Dump@CObject@@UBEXAAVCDumpContext@@@Z
	DD	FLAT:?OnCmdMsg@CDialog@@UAEHIHPAXPAUAFX_CMDHANDLERINFO@@@Z
	DD	FLAT:?OnFinalRelease@CWnd@@UAEXXZ
	DD	FLAT:?IsInvokeAllowed@CCmdTarget@@UAEHJ@Z
	DD	FLAT:?GetDispatchIID@CCmdTarget@@UAEHPAU_GUID@@@Z
	DD	FLAT:?GetTypeInfoCount@CCmdTarget@@UAEIXZ
	DD	FLAT:?GetTypeLibCache@CCmdTarget@@UAEPAVCTypeLibCache@@XZ
	DD	FLAT:?GetTypeLib@CCmdTarget@@UAEJKPAPAUITypeLib@@@Z
	DD	FLAT:?GetMessageMap@CDlgSettingToolBar@@MBEPBUAFX_MSGMAP@@XZ
	DD	FLAT:?GetCommandMap@CCmdTarget@@MBEPBUAFX_OLECMDMAP@@XZ
	DD	FLAT:?GetDispatchMap@CCmdTarget@@MBEPBUAFX_DISPMAP@@XZ
	DD	FLAT:?GetConnectionMap@CCmdTarget@@MBEPBUAFX_CONNECTIONMAP@@XZ
	DD	FLAT:?GetInterfaceMap@CWnd@@MBEPBUAFX_INTERFACEMAP@@XZ
	DD	FLAT:?GetEventSinkMap@CCmdTarget@@MBEPBUAFX_EVENTSINKMAP@@XZ
	DD	FLAT:?OnCreateAggregates@CCmdTarget@@UAEHXZ
	DD	FLAT:?GetInterfaceHook@CCmdTarget@@UAEPAUIUnknown@@PBX@Z
	DD	FLAT:?GetExtraConnectionPoints@CCmdTarget@@MAEHPAVCPtrArray@@@Z
	DD	FLAT:?GetConnectionHook@CCmdTarget@@MAEPAUIConnectionPoint@@ABU_GUID@@@Z
	DD	FLAT:?PreSubclassWindow@CWnd@@UAEXXZ
	DD	FLAT:?Create@CWnd@@UAEHPBD0KABUtagRECT@@PAV1@IPAUCCreateContext@@@Z
	DD	FLAT:?CreateEx@CWnd@@UAEHKPBD0KABUtagRECT@@PAV1@IPAX@Z
	DD	FLAT:?CreateEx@CWnd@@UAEHKPBD0KHHHHPAUHWND__@@PAUHMENU__@@PAX@Z
	DD	FLAT:?DestroyWindow@CWnd@@UAEHXZ
	DD	FLAT:?PreCreateWindow@CWnd@@UAEHAAUtagCREATESTRUCTA@@@Z
	DD	FLAT:?CalcWindowRect@CWnd@@UAEXPAUtagRECT@@I@Z
	DD	FLAT:?GetMenu@CWnd@@UBEPAVCMenu@@XZ
	DD	FLAT:?SetMenu@CWnd@@UAEHPAVCMenu@@@Z
	DD	FLAT:?OnToolHitTest@CWnd@@UBEHVCPoint@@PAUtagTOOLINFOA@@@Z
	DD	FLAT:?GetScrollBarCtrl@CWnd@@UBEPAVCScrollBar@@H@Z
	DD	FLAT:?WinHelpA@CWnd@@UAEXKI@Z
	DD	FLAT:?HtmlHelpA@CWnd@@UAEXKI@Z
	DD	FLAT:?WinHelpInternal@CWnd@@UAEXKI@Z
	DD	FLAT:?ContinueModal@CWnd@@UAEHXZ
	DD	FLAT:?EndModalLoop@CWnd@@UAEXH@Z
	DD	FLAT:?OnDrawIconicThumbnailOrLivePreview@CWnd@@UAEXAAVCDC@@VCRect@@VCSize@@HAAH@Z
	DD	FLAT:?EnsureStdObj@CWnd@@UAEJXZ
	DD	FLAT:?get_accParent@CWnd@@UAEJPAPAUIDispatch@@@Z
	DD	FLAT:?get_accChildCount@CWnd@@UAEJPAJ@Z
	DD	FLAT:?get_accChild@CWnd@@UAEJUtagVARIANT@@PAPAUIDispatch@@@Z
	DD	FLAT:?get_accName@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z
	DD	FLAT:?get_accValue@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z
	DD	FLAT:?get_accDescription@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z
	DD	FLAT:?get_accRole@CWnd@@UAEJUtagVARIANT@@PAU2@@Z
	DD	FLAT:?get_accState@CWnd@@UAEJUtagVARIANT@@PAU2@@Z
	DD	FLAT:?get_accHelp@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z
	DD	FLAT:?get_accHelpTopic@CWnd@@UAEJPAPA_WUtagVARIANT@@PAJ@Z
	DD	FLAT:?get_accKeyboardShortcut@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z
	DD	FLAT:?get_accFocus@CWnd@@UAEJPAUtagVARIANT@@@Z
	DD	FLAT:?get_accSelection@CWnd@@UAEJPAUtagVARIANT@@@Z
	DD	FLAT:?get_accDefaultAction@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z
	DD	FLAT:?accSelect@CWnd@@UAEJJUtagVARIANT@@@Z
	DD	FLAT:?accLocation@CWnd@@UAEJPAJ000UtagVARIANT@@@Z
	DD	FLAT:?accNavigate@CWnd@@UAEJJUtagVARIANT@@PAU2@@Z
	DD	FLAT:?accHitTest@CWnd@@UAEJJJPAUtagVARIANT@@@Z
	DD	FLAT:?accDoDefaultAction@CWnd@@UAEJUtagVARIANT@@@Z
	DD	FLAT:?put_accName@CWnd@@UAEJUtagVARIANT@@PA_W@Z
	DD	FLAT:?put_accValue@CWnd@@UAEJUtagVARIANT@@PA_W@Z
	DD	FLAT:?SetProxy@CWnd@@UAEJPAUIAccessibleProxy@@@Z
	DD	FLAT:?CreateAccessibleProxy@CWnd@@UAEJIJPAJ@Z
	DD	FLAT:?OnCommand@CWnd@@MAEHIJ@Z
	DD	FLAT:?OnNotify@CWnd@@MAEHIJPAJ@Z
	DD	FLAT:?GetSuperWndProcAddr@CWnd@@MAEPAP6GJPAUHWND__@@IIJ@ZXZ
	DD	FLAT:?DoDataExchange@CDlgSettingToolBar@@MAEXPAVCDataExchange@@@Z
	DD	FLAT:?BeginModalState@CWnd@@UAEXXZ
	DD	FLAT:?EndModalState@CWnd@@UAEXXZ
	DD	FLAT:?PreTranslateMessage@CDialog@@UAEHPAUtagMSG@@@Z
	DD	FLAT:?OnAmbientProperty@CWnd@@UAEHPAVCOleControlSite@@JPAUtagVARIANT@@@Z
	DD	FLAT:?WindowProc@CWnd@@MAEJIIJ@Z
	DD	FLAT:?OnWndMsg@CWnd@@MAEHIIJPAJ@Z
	DD	FLAT:?DefWindowProcA@CWnd@@MAEJIIJ@Z
	DD	FLAT:?PostNcDestroy@CWnd@@MAEXXZ
	DD	FLAT:?OnChildNotify@CWnd@@MAEHIIJPAJ@Z
	DD	FLAT:?OnTouchInputs@CWnd@@MAEHIPAUtagTOUCHINPUT@@@Z
	DD	FLAT:?OnTouchInput@CWnd@@MAEHVCPoint@@HHPAUtagTOUCHINPUT@@@Z
	DD	FLAT:?GetGestureStatus@CWnd@@MAEKVCPoint@@@Z
	DD	FLAT:?OnGestureZoom@CWnd@@MAEHVCPoint@@J@Z
	DD	FLAT:?OnGesturePan@CWnd@@MAEHVCPoint@@0@Z
	DD	FLAT:?OnGestureRotate@CWnd@@MAEHVCPoint@@N@Z
	DD	FLAT:?OnGestureTwoFingerTap@CWnd@@MAEHVCPoint@@@Z
	DD	FLAT:?OnGesturePressAndTap@CWnd@@MAEHVCPoint@@J@Z
	DD	FLAT:?ResizeDynamicLayout@CWnd@@MAEXXZ
	DD	FLAT:?CheckAutoCenter@CDialog@@UAEHXZ
	DD	FLAT:?IsFrameWnd@CWnd@@UBEHXZ
	DD	FLAT:?CreateControlContainer@CWnd@@MAEHPAPAVCOleControlContainer@@@Z
	DD	FLAT:?CreateControlSite@CWnd@@MAEHPAVCOleControlContainer@@PAPAVCOleControlSite@@IABU_GUID@@@Z
	DD	FLAT:?SetOccDialogInfo@CDialog@@MAEHPAU_AFX_OCC_DIALOG_INFO@@@Z
	DD	FLAT:?GetOccDialogInfo@CDialog@@MAEPAU_AFX_OCC_DIALOG_INFO@@XZ
	DD	FLAT:?Create@CDialog@@UAEHIPAVCWnd@@@Z
	DD	FLAT:?Create@CDialog@@UAEHPBDPAVCWnd@@@Z
	DD	FLAT:?CreateIndirect@CDialog@@UAEHPAXPAVCWnd@@@Z
	DD	FLAT:?CreateIndirect@CDialog@@UAEHPBUDLGTEMPLATE@@PAVCWnd@@PAX@Z
	DD	FLAT:?DoModal@CDialog@@UAEHXZ
	DD	FLAT:?OnInitDialog@CDlgSettingToolBar@@MAEHXZ
	DD	FLAT:?OnSetFont@CDialog@@UAEXPAVCFont@@@Z
	DD	FLAT:?OnOK@CDlgSettingToolBar@@MAEXXZ
	DD	FLAT:?OnCancel@CDlgSettingToolBar@@MAEXXZ
	DD	FLAT:?PreInitDialog@CDialog@@MAEXXZ
CONST	ENDS
;	COMDAT ??_7?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@6B@
CONST	SEGMENT
??_7?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@6B@ DD FLAT:??_R4?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@6B@ ; CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >::`vftable'
	DD	FLAT:?GetRuntimeClass@CObject@@UBEPAUCRuntimeClass@@XZ
	DD	FLAT:??_E?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@UAEPAXI@Z
	DD	FLAT:?Serialize@?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@UAEXAAVCArchive@@@Z
	DD	FLAT:?AssertValid@CObject@@UBEXXZ
	DD	FLAT:?Dump@CObject@@UBEXAAVCDumpContext@@@Z
CONST	ENDS
;	COMDAT ??_7?$CArray@HH@@6B@
CONST	SEGMENT
??_7?$CArray@HH@@6B@ DD FLAT:??_R4?$CArray@HH@@6B@	; CArray<int,int>::`vftable'
	DD	FLAT:?GetRuntimeClass@CObject@@UBEPAUCRuntimeClass@@XZ
	DD	FLAT:??_E?$CArray@HH@@UAEPAXI@Z
	DD	FLAT:?Serialize@?$CArray@HH@@UAEXAAVCArchive@@@Z
	DD	FLAT:?AssertValid@CObject@@UBEXXZ
	DD	FLAT:?Dump@CObject@@UBEXAAVCDumpContext@@@Z
CONST	ENDS
;	COMDAT ??_R2CDialog@@8
rdata$r	SEGMENT
??_R2CDialog@@8 DD FLAT:??_R1A@?0A@EA@CDialog@@8	; CDialog::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CWnd@@8
	DD	FLAT:??_R1A@?0A@EA@CCmdTarget@@8
	DD	FLAT:??_R1A@?0A@EA@CObject@@8
rdata$r	ENDS
;	COMDAT ??_R3CDialog@@8
rdata$r	SEGMENT
??_R3CDialog@@8 DD 00H					; CDialog::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2CDialog@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCDialog@@@8
data$rs	SEGMENT
??_R0?AVCDialog@@@8 DD FLAT:??_7type_info@@6B@		; CDialog `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCDialog@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@CDialog@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CDialog@@8 DD FLAT:??_R0?AVCDialog@@@8	; CDialog::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CDialog@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CComboBox@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CComboBox@@8 DD FLAT:??_R0?AVCComboBox@@@8 ; CComboBox::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CComboBox@@8
rdata$r	ENDS
;	COMDAT ??_R2CComboBox@@8
rdata$r	SEGMENT
??_R2CComboBox@@8 DD FLAT:??_R1A@?0A@EA@CComboBox@@8	; CComboBox::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CWnd@@8
	DD	FLAT:??_R1A@?0A@EA@CCmdTarget@@8
	DD	FLAT:??_R1A@?0A@EA@CObject@@8
rdata$r	ENDS
;	COMDAT ??_R3CComboBox@@8
rdata$r	SEGMENT
??_R3CComboBox@@8 DD 00H				; CComboBox::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2CComboBox@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCComboBox@@@8
data$rs	SEGMENT
??_R0?AVCComboBox@@@8 DD FLAT:??_7type_info@@6B@	; CComboBox `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCComboBox@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CComboBox@@6B@
rdata$r	SEGMENT
??_R4CComboBox@@6B@ DD 00H				; CComboBox::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCComboBox@@@8
	DD	FLAT:??_R3CComboBox@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CListBox@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CListBox@@8 DD FLAT:??_R0?AVCListBox@@@8	; CListBox::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CListBox@@8
rdata$r	ENDS
;	COMDAT ??_R2CListBox@@8
rdata$r	SEGMENT
??_R2CListBox@@8 DD FLAT:??_R1A@?0A@EA@CListBox@@8	; CListBox::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CWnd@@8
	DD	FLAT:??_R1A@?0A@EA@CCmdTarget@@8
	DD	FLAT:??_R1A@?0A@EA@CObject@@8
rdata$r	ENDS
;	COMDAT ??_R3CListBox@@8
rdata$r	SEGMENT
??_R3CListBox@@8 DD 00H					; CListBox::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2CListBox@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCListBox@@@8
data$rs	SEGMENT
??_R0?AVCListBox@@@8 DD FLAT:??_7type_info@@6B@		; CListBox `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCListBox@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CListBox@@6B@
rdata$r	SEGMENT
??_R4CListBox@@6B@ DD 00H				; CListBox::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCListBox@@@8
	DD	FLAT:??_R3CListBox@@8
rdata$r	ENDS
;	COMDAT ??_R2CCmdTarget@@8
rdata$r	SEGMENT
??_R2CCmdTarget@@8 DD FLAT:??_R1A@?0A@EA@CCmdTarget@@8	; CCmdTarget::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CObject@@8
rdata$r	ENDS
;	COMDAT ??_R3CCmdTarget@@8
rdata$r	SEGMENT
??_R3CCmdTarget@@8 DD 00H				; CCmdTarget::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CCmdTarget@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCCmdTarget@@@8
data$rs	SEGMENT
??_R0?AVCCmdTarget@@@8 DD FLAT:??_7type_info@@6B@	; CCmdTarget `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCCmdTarget@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@CCmdTarget@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CCmdTarget@@8 DD FLAT:??_R0?AVCCmdTarget@@@8 ; CCmdTarget::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CCmdTarget@@8
rdata$r	ENDS
;	COMDAT ??_R2CWnd@@8
rdata$r	SEGMENT
??_R2CWnd@@8 DD	FLAT:??_R1A@?0A@EA@CWnd@@8		; CWnd::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CCmdTarget@@8
	DD	FLAT:??_R1A@?0A@EA@CObject@@8
rdata$r	ENDS
;	COMDAT ??_R3CWnd@@8
rdata$r	SEGMENT
??_R3CWnd@@8 DD	00H					; CWnd::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2CWnd@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCWnd@@@8
data$rs	SEGMENT
??_R0?AVCWnd@@@8 DD FLAT:??_7type_info@@6B@		; CWnd `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCWnd@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@CWnd@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CWnd@@8 DD FLAT:??_R0?AVCWnd@@@8		; CWnd::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CWnd@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CObject@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CObject@@8 DD FLAT:??_R0?AVCObject@@@8	; CObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CObject@@8
rdata$r	ENDS
;	COMDAT ??_R2CObject@@8
rdata$r	SEGMENT
??_R2CObject@@8 DD FLAT:??_R1A@?0A@EA@CObject@@8	; CObject::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CObject@@8
rdata$r	SEGMENT
??_R3CObject@@8 DD 00H					; CObject::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CObject@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCObject@@@8
data$rs	SEGMENT
??_R0?AVCObject@@@8 DD FLAT:??_7type_info@@6B@		; CObject `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCObject@@', 00H
data$rs	ENDS
;	COMDAT ??_C@_02EMFKHFLK@?$CFX@
CONST	SEGMENT
??_C@_02EMFKHFLK@?$CFX@ DB '%X', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06NDLAHCHE@?$CFs?$CF08X@
CONST	SEGMENT
??_C@_06NDLAHCHE@?$CFs?$CF08X@ DB '%s%08X', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CBBNGGHM@PcTrMng?4dll@
CONST	SEGMENT
??_C@_0M@CBBNGGHM@PcTrMng?4dll@ DB 'PcTrMng.dll', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_7CComboBox@@6B@
CONST	SEGMENT
??_7CComboBox@@6B@ DD FLAT:??_R4CComboBox@@6B@		; CComboBox::`vftable'
	DD	FLAT:?GetRuntimeClass@CComboBox@@UBEPAUCRuntimeClass@@XZ
	DD	FLAT:??_ECComboBox@@UAEPAXI@Z
	DD	FLAT:?Serialize@CObject@@UAEXAAVCArchive@@@Z
	DD	FLAT:?AssertValid@CObject@@UBEXXZ
	DD	FLAT:?Dump@CObject@@UBEXAAVCDumpContext@@@Z
	DD	FLAT:?OnCmdMsg@CCmdTarget@@UAEHIHPAXPAUAFX_CMDHANDLERINFO@@@Z
	DD	FLAT:?OnFinalRelease@CWnd@@UAEXXZ
	DD	FLAT:?IsInvokeAllowed@CCmdTarget@@UAEHJ@Z
	DD	FLAT:?GetDispatchIID@CCmdTarget@@UAEHPAU_GUID@@@Z
	DD	FLAT:?GetTypeInfoCount@CCmdTarget@@UAEIXZ
	DD	FLAT:?GetTypeLibCache@CCmdTarget@@UAEPAVCTypeLibCache@@XZ
	DD	FLAT:?GetTypeLib@CCmdTarget@@UAEJKPAPAUITypeLib@@@Z
	DD	FLAT:?GetMessageMap@CWnd@@MBEPBUAFX_MSGMAP@@XZ
	DD	FLAT:?GetCommandMap@CCmdTarget@@MBEPBUAFX_OLECMDMAP@@XZ
	DD	FLAT:?GetDispatchMap@CCmdTarget@@MBEPBUAFX_DISPMAP@@XZ
	DD	FLAT:?GetConnectionMap@CCmdTarget@@MBEPBUAFX_CONNECTIONMAP@@XZ
	DD	FLAT:?GetInterfaceMap@CWnd@@MBEPBUAFX_INTERFACEMAP@@XZ
	DD	FLAT:?GetEventSinkMap@CCmdTarget@@MBEPBUAFX_EVENTSINKMAP@@XZ
	DD	FLAT:?OnCreateAggregates@CCmdTarget@@UAEHXZ
	DD	FLAT:?GetInterfaceHook@CCmdTarget@@UAEPAUIUnknown@@PBX@Z
	DD	FLAT:?GetExtraConnectionPoints@CCmdTarget@@MAEHPAVCPtrArray@@@Z
	DD	FLAT:?GetConnectionHook@CCmdTarget@@MAEPAUIConnectionPoint@@ABU_GUID@@@Z
	DD	FLAT:?PreSubclassWindow@CWnd@@UAEXXZ
	DD	FLAT:?Create@CWnd@@UAEHPBD0KABUtagRECT@@PAV1@IPAUCCreateContext@@@Z
	DD	FLAT:?CreateEx@CWnd@@UAEHKPBD0KABUtagRECT@@PAV1@IPAX@Z
	DD	FLAT:?CreateEx@CWnd@@UAEHKPBD0KHHHHPAUHWND__@@PAUHMENU__@@PAX@Z
	DD	FLAT:?DestroyWindow@CWnd@@UAEHXZ
	DD	FLAT:?PreCreateWindow@CWnd@@UAEHAAUtagCREATESTRUCTA@@@Z
	DD	FLAT:?CalcWindowRect@CWnd@@UAEXPAUtagRECT@@I@Z
	DD	FLAT:?GetMenu@CWnd@@UBEPAVCMenu@@XZ
	DD	FLAT:?SetMenu@CWnd@@UAEHPAVCMenu@@@Z
	DD	FLAT:?OnToolHitTest@CWnd@@UBEHVCPoint@@PAUtagTOOLINFOA@@@Z
	DD	FLAT:?GetScrollBarCtrl@CWnd@@UBEPAVCScrollBar@@H@Z
	DD	FLAT:?WinHelpA@CWnd@@UAEXKI@Z
	DD	FLAT:?HtmlHelpA@CWnd@@UAEXKI@Z
	DD	FLAT:?WinHelpInternal@CWnd@@UAEXKI@Z
	DD	FLAT:?ContinueModal@CWnd@@UAEHXZ
	DD	FLAT:?EndModalLoop@CWnd@@UAEXH@Z
	DD	FLAT:?OnDrawIconicThumbnailOrLivePreview@CWnd@@UAEXAAVCDC@@VCRect@@VCSize@@HAAH@Z
	DD	FLAT:?EnsureStdObj@CWnd@@UAEJXZ
	DD	FLAT:?get_accParent@CWnd@@UAEJPAPAUIDispatch@@@Z
	DD	FLAT:?get_accChildCount@CWnd@@UAEJPAJ@Z
	DD	FLAT:?get_accChild@CWnd@@UAEJUtagVARIANT@@PAPAUIDispatch@@@Z
	DD	FLAT:?get_accName@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z
	DD	FLAT:?get_accValue@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z
	DD	FLAT:?get_accDescription@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z
	DD	FLAT:?get_accRole@CWnd@@UAEJUtagVARIANT@@PAU2@@Z
	DD	FLAT:?get_accState@CWnd@@UAEJUtagVARIANT@@PAU2@@Z
	DD	FLAT:?get_accHelp@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z
	DD	FLAT:?get_accHelpTopic@CWnd@@UAEJPAPA_WUtagVARIANT@@PAJ@Z
	DD	FLAT:?get_accKeyboardShortcut@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z
	DD	FLAT:?get_accFocus@CWnd@@UAEJPAUtagVARIANT@@@Z
	DD	FLAT:?get_accSelection@CWnd@@UAEJPAUtagVARIANT@@@Z
	DD	FLAT:?get_accDefaultAction@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z
	DD	FLAT:?accSelect@CWnd@@UAEJJUtagVARIANT@@@Z
	DD	FLAT:?accLocation@CWnd@@UAEJPAJ000UtagVARIANT@@@Z
	DD	FLAT:?accNavigate@CWnd@@UAEJJUtagVARIANT@@PAU2@@Z
	DD	FLAT:?accHitTest@CWnd@@UAEJJJPAUtagVARIANT@@@Z
	DD	FLAT:?accDoDefaultAction@CWnd@@UAEJUtagVARIANT@@@Z
	DD	FLAT:?put_accName@CWnd@@UAEJUtagVARIANT@@PA_W@Z
	DD	FLAT:?put_accValue@CWnd@@UAEJUtagVARIANT@@PA_W@Z
	DD	FLAT:?SetProxy@CWnd@@UAEJPAUIAccessibleProxy@@@Z
	DD	FLAT:?CreateAccessibleProxy@CWnd@@UAEJIJPAJ@Z
	DD	FLAT:?OnCommand@CWnd@@MAEHIJ@Z
	DD	FLAT:?OnNotify@CWnd@@MAEHIJPAJ@Z
	DD	FLAT:?GetSuperWndProcAddr@CWnd@@MAEPAP6GJPAUHWND__@@IIJ@ZXZ
	DD	FLAT:?DoDataExchange@CWnd@@MAEXPAVCDataExchange@@@Z
	DD	FLAT:?BeginModalState@CWnd@@UAEXXZ
	DD	FLAT:?EndModalState@CWnd@@UAEXXZ
	DD	FLAT:?PreTranslateMessage@CWnd@@UAEHPAUtagMSG@@@Z
	DD	FLAT:?OnAmbientProperty@CWnd@@UAEHPAVCOleControlSite@@JPAUtagVARIANT@@@Z
	DD	FLAT:?WindowProc@CWnd@@MAEJIIJ@Z
	DD	FLAT:?OnWndMsg@CWnd@@MAEHIIJPAJ@Z
	DD	FLAT:?DefWindowProcA@CWnd@@MAEJIIJ@Z
	DD	FLAT:?PostNcDestroy@CWnd@@MAEXXZ
	DD	FLAT:?OnChildNotify@CComboBox@@MAEHIIJPAJ@Z
	DD	FLAT:?OnTouchInputs@CWnd@@MAEHIPAUtagTOUCHINPUT@@@Z
	DD	FLAT:?OnTouchInput@CWnd@@MAEHVCPoint@@HHPAUtagTOUCHINPUT@@@Z
	DD	FLAT:?GetGestureStatus@CWnd@@MAEKVCPoint@@@Z
	DD	FLAT:?OnGestureZoom@CWnd@@MAEHVCPoint@@J@Z
	DD	FLAT:?OnGesturePan@CWnd@@MAEHVCPoint@@0@Z
	DD	FLAT:?OnGestureRotate@CWnd@@MAEHVCPoint@@N@Z
	DD	FLAT:?OnGestureTwoFingerTap@CWnd@@MAEHVCPoint@@@Z
	DD	FLAT:?OnGesturePressAndTap@CWnd@@MAEHVCPoint@@J@Z
	DD	FLAT:?ResizeDynamicLayout@CWnd@@MAEXXZ
	DD	FLAT:?CheckAutoCenter@CWnd@@UAEHXZ
	DD	FLAT:?IsFrameWnd@CWnd@@UBEHXZ
	DD	FLAT:?CreateControlContainer@CWnd@@MAEHPAPAVCOleControlContainer@@@Z
	DD	FLAT:?CreateControlSite@CWnd@@MAEHPAVCOleControlContainer@@PAPAVCOleControlSite@@IABU_GUID@@@Z
	DD	FLAT:?SetOccDialogInfo@CWnd@@MAEHPAU_AFX_OCC_DIALOG_INFO@@@Z
	DD	FLAT:?GetOccDialogInfo@CWnd@@MAEPAU_AFX_OCC_DIALOG_INFO@@XZ
	DD	FLAT:?Create@CComboBox@@UAEHKABUtagRECT@@PAVCWnd@@I@Z
	DD	FLAT:?DrawItem@CComboBox@@UAEXPAUtagDRAWITEMSTRUCT@@@Z
	DD	FLAT:?MeasureItem@CComboBox@@UAEXPAUtagMEASUREITEMSTRUCT@@@Z
	DD	FLAT:?CompareItem@CComboBox@@UAEHPAUtagCOMPAREITEMSTRUCT@@@Z
	DD	FLAT:?DeleteItem@CComboBox@@UAEXPAUtagDELETEITEMSTRUCT@@@Z
CONST	ENDS
;	COMDAT ??_7CListBox@@6B@
CONST	SEGMENT
??_7CListBox@@6B@ DD FLAT:??_R4CListBox@@6B@		; CListBox::`vftable'
	DD	FLAT:?GetRuntimeClass@CListBox@@UBEPAUCRuntimeClass@@XZ
	DD	FLAT:??_ECListBox@@UAEPAXI@Z
	DD	FLAT:?Serialize@CObject@@UAEXAAVCArchive@@@Z
	DD	FLAT:?AssertValid@CObject@@UBEXXZ
	DD	FLAT:?Dump@CObject@@UBEXAAVCDumpContext@@@Z
	DD	FLAT:?OnCmdMsg@CCmdTarget@@UAEHIHPAXPAUAFX_CMDHANDLERINFO@@@Z
	DD	FLAT:?OnFinalRelease@CWnd@@UAEXXZ
	DD	FLAT:?IsInvokeAllowed@CCmdTarget@@UAEHJ@Z
	DD	FLAT:?GetDispatchIID@CCmdTarget@@UAEHPAU_GUID@@@Z
	DD	FLAT:?GetTypeInfoCount@CCmdTarget@@UAEIXZ
	DD	FLAT:?GetTypeLibCache@CCmdTarget@@UAEPAVCTypeLibCache@@XZ
	DD	FLAT:?GetTypeLib@CCmdTarget@@UAEJKPAPAUITypeLib@@@Z
	DD	FLAT:?GetMessageMap@CWnd@@MBEPBUAFX_MSGMAP@@XZ
	DD	FLAT:?GetCommandMap@CCmdTarget@@MBEPBUAFX_OLECMDMAP@@XZ
	DD	FLAT:?GetDispatchMap@CCmdTarget@@MBEPBUAFX_DISPMAP@@XZ
	DD	FLAT:?GetConnectionMap@CCmdTarget@@MBEPBUAFX_CONNECTIONMAP@@XZ
	DD	FLAT:?GetInterfaceMap@CWnd@@MBEPBUAFX_INTERFACEMAP@@XZ
	DD	FLAT:?GetEventSinkMap@CCmdTarget@@MBEPBUAFX_EVENTSINKMAP@@XZ
	DD	FLAT:?OnCreateAggregates@CCmdTarget@@UAEHXZ
	DD	FLAT:?GetInterfaceHook@CCmdTarget@@UAEPAUIUnknown@@PBX@Z
	DD	FLAT:?GetExtraConnectionPoints@CCmdTarget@@MAEHPAVCPtrArray@@@Z
	DD	FLAT:?GetConnectionHook@CCmdTarget@@MAEPAUIConnectionPoint@@ABU_GUID@@@Z
	DD	FLAT:?PreSubclassWindow@CWnd@@UAEXXZ
	DD	FLAT:?Create@CWnd@@UAEHPBD0KABUtagRECT@@PAV1@IPAUCCreateContext@@@Z
	DD	FLAT:?CreateEx@CWnd@@UAEHKPBD0KABUtagRECT@@PAV1@IPAX@Z
	DD	FLAT:?CreateEx@CWnd@@UAEHKPBD0KHHHHPAUHWND__@@PAUHMENU__@@PAX@Z
	DD	FLAT:?DestroyWindow@CWnd@@UAEHXZ
	DD	FLAT:?PreCreateWindow@CWnd@@UAEHAAUtagCREATESTRUCTA@@@Z
	DD	FLAT:?CalcWindowRect@CWnd@@UAEXPAUtagRECT@@I@Z
	DD	FLAT:?GetMenu@CWnd@@UBEPAVCMenu@@XZ
	DD	FLAT:?SetMenu@CWnd@@UAEHPAVCMenu@@@Z
	DD	FLAT:?OnToolHitTest@CWnd@@UBEHVCPoint@@PAUtagTOOLINFOA@@@Z
	DD	FLAT:?GetScrollBarCtrl@CWnd@@UBEPAVCScrollBar@@H@Z
	DD	FLAT:?WinHelpA@CWnd@@UAEXKI@Z
	DD	FLAT:?HtmlHelpA@CWnd@@UAEXKI@Z
	DD	FLAT:?WinHelpInternal@CWnd@@UAEXKI@Z
	DD	FLAT:?ContinueModal@CWnd@@UAEHXZ
	DD	FLAT:?EndModalLoop@CWnd@@UAEXH@Z
	DD	FLAT:?OnDrawIconicThumbnailOrLivePreview@CWnd@@UAEXAAVCDC@@VCRect@@VCSize@@HAAH@Z
	DD	FLAT:?EnsureStdObj@CWnd@@UAEJXZ
	DD	FLAT:?get_accParent@CWnd@@UAEJPAPAUIDispatch@@@Z
	DD	FLAT:?get_accChildCount@CWnd@@UAEJPAJ@Z
	DD	FLAT:?get_accChild@CWnd@@UAEJUtagVARIANT@@PAPAUIDispatch@@@Z
	DD	FLAT:?get_accName@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z
	DD	FLAT:?get_accValue@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z
	DD	FLAT:?get_accDescription@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z
	DD	FLAT:?get_accRole@CWnd@@UAEJUtagVARIANT@@PAU2@@Z
	DD	FLAT:?get_accState@CWnd@@UAEJUtagVARIANT@@PAU2@@Z
	DD	FLAT:?get_accHelp@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z
	DD	FLAT:?get_accHelpTopic@CWnd@@UAEJPAPA_WUtagVARIANT@@PAJ@Z
	DD	FLAT:?get_accKeyboardShortcut@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z
	DD	FLAT:?get_accFocus@CWnd@@UAEJPAUtagVARIANT@@@Z
	DD	FLAT:?get_accSelection@CWnd@@UAEJPAUtagVARIANT@@@Z
	DD	FLAT:?get_accDefaultAction@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z
	DD	FLAT:?accSelect@CWnd@@UAEJJUtagVARIANT@@@Z
	DD	FLAT:?accLocation@CWnd@@UAEJPAJ000UtagVARIANT@@@Z
	DD	FLAT:?accNavigate@CWnd@@UAEJJUtagVARIANT@@PAU2@@Z
	DD	FLAT:?accHitTest@CWnd@@UAEJJJPAUtagVARIANT@@@Z
	DD	FLAT:?accDoDefaultAction@CWnd@@UAEJUtagVARIANT@@@Z
	DD	FLAT:?put_accName@CWnd@@UAEJUtagVARIANT@@PA_W@Z
	DD	FLAT:?put_accValue@CWnd@@UAEJUtagVARIANT@@PA_W@Z
	DD	FLAT:?SetProxy@CWnd@@UAEJPAUIAccessibleProxy@@@Z
	DD	FLAT:?CreateAccessibleProxy@CWnd@@UAEJIJPAJ@Z
	DD	FLAT:?OnCommand@CWnd@@MAEHIJ@Z
	DD	FLAT:?OnNotify@CWnd@@MAEHIJPAJ@Z
	DD	FLAT:?GetSuperWndProcAddr@CWnd@@MAEPAP6GJPAUHWND__@@IIJ@ZXZ
	DD	FLAT:?DoDataExchange@CWnd@@MAEXPAVCDataExchange@@@Z
	DD	FLAT:?BeginModalState@CWnd@@UAEXXZ
	DD	FLAT:?EndModalState@CWnd@@UAEXXZ
	DD	FLAT:?PreTranslateMessage@CWnd@@UAEHPAUtagMSG@@@Z
	DD	FLAT:?OnAmbientProperty@CWnd@@UAEHPAVCOleControlSite@@JPAUtagVARIANT@@@Z
	DD	FLAT:?WindowProc@CWnd@@MAEJIIJ@Z
	DD	FLAT:?OnWndMsg@CWnd@@MAEHIIJPAJ@Z
	DD	FLAT:?DefWindowProcA@CWnd@@MAEJIIJ@Z
	DD	FLAT:?PostNcDestroy@CWnd@@MAEXXZ
	DD	FLAT:?OnChildNotify@CListBox@@MAEHIIJPAJ@Z
	DD	FLAT:?OnTouchInputs@CWnd@@MAEHIPAUtagTOUCHINPUT@@@Z
	DD	FLAT:?OnTouchInput@CWnd@@MAEHVCPoint@@HHPAUtagTOUCHINPUT@@@Z
	DD	FLAT:?GetGestureStatus@CWnd@@MAEKVCPoint@@@Z
	DD	FLAT:?OnGestureZoom@CWnd@@MAEHVCPoint@@J@Z
	DD	FLAT:?OnGesturePan@CWnd@@MAEHVCPoint@@0@Z
	DD	FLAT:?OnGestureRotate@CWnd@@MAEHVCPoint@@N@Z
	DD	FLAT:?OnGestureTwoFingerTap@CWnd@@MAEHVCPoint@@@Z
	DD	FLAT:?OnGesturePressAndTap@CWnd@@MAEHVCPoint@@J@Z
	DD	FLAT:?ResizeDynamicLayout@CWnd@@MAEXXZ
	DD	FLAT:?CheckAutoCenter@CWnd@@UAEHXZ
	DD	FLAT:?IsFrameWnd@CWnd@@UBEHXZ
	DD	FLAT:?CreateControlContainer@CWnd@@MAEHPAPAVCOleControlContainer@@@Z
	DD	FLAT:?CreateControlSite@CWnd@@MAEHPAVCOleControlContainer@@PAPAVCOleControlSite@@IABU_GUID@@@Z
	DD	FLAT:?SetOccDialogInfo@CWnd@@MAEHPAU_AFX_OCC_DIALOG_INFO@@@Z
	DD	FLAT:?GetOccDialogInfo@CWnd@@MAEPAU_AFX_OCC_DIALOG_INFO@@XZ
	DD	FLAT:?Create@CListBox@@UAEHKABUtagRECT@@PAVCWnd@@I@Z
	DD	FLAT:?DrawItem@CListBox@@UAEXPAUtagDRAWITEMSTRUCT@@@Z
	DD	FLAT:?MeasureItem@CListBox@@UAEXPAUtagMEASUREITEMSTRUCT@@@Z
	DD	FLAT:?CompareItem@CListBox@@UAEHPAUtagCOMPAREITEMSTRUCT@@@Z
	DD	FLAT:?DeleteItem@CListBox@@UAEXPAUtagDELETEITEMSTRUCT@@@Z
	DD	FLAT:?VKeyToItem@CListBox@@UAEHII@Z
	DD	FLAT:?CharToItem@CListBox@@UAEHII@Z
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd@ DB '%d', 00H			; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_GCDlgSettingToolBar@@UAEPAXI@Z DD 0ffffffffH
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??_GCDlgSettingToolBar@@UAEPAXI@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??_GCDlgSettingToolBar@@UAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1CDlgSettingToolBar@@UAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??1CDlgSettingToolBar@@UAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??1CDlgSettingToolBar@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?OnBtnAddall@CDlgSettingToolBar@@IAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?OnBtnAddall@CDlgSettingToolBar@@IAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?OnBtnAddall@CDlgSettingToolBar@@IAEXXZ$4
	DD	00H
	DD	FLAT:__unwindfunclet$?OnBtnAddall@CDlgSettingToolBar@@IAEXXZ$5
__ehfuncinfo$?OnBtnAddall@CDlgSettingToolBar@@IAEXXZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?OnBtnAddall@CDlgSettingToolBar@@IAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?OnBtnAdd@CDlgSettingToolBar@@IAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?OnBtnAdd@CDlgSettingToolBar@@IAEXXZ$0
__ehfuncinfo$?OnBtnAdd@CDlgSettingToolBar@@IAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?OnBtnAdd@CDlgSettingToolBar@@IAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?OnApply@CDlgSettingToolBar@@IAEXXZ DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$?OnApply@CDlgSettingToolBar@@IAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?OnApply@CDlgSettingToolBar@@IAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?OnApply@CDlgSettingToolBar@@IAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?OnApply@CDlgSettingToolBar@@IAEXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?OnApply@CDlgSettingToolBar@@IAEXXZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$?OnApply@CDlgSettingToolBar@@IAEXXZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$?OnApply@CDlgSettingToolBar@@IAEXXZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$?OnApply@CDlgSettingToolBar@@IAEXXZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$?OnApply@CDlgSettingToolBar@@IAEXXZ$6
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?OnInitDialog@CDlgSettingToolBar@@MAEHXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?OnInitDialog@CDlgSettingToolBar@@MAEHXZ$0
__ehfuncinfo$?OnInitDialog@CDlgSettingToolBar@@MAEHXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?OnInitDialog@CDlgSettingToolBar@@MAEHXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0CDlgSettingToolBar@@QAE@PAVCWnd@@@Z DD 019930522H
	DD	0aH
	DD	FLAT:__unwindtable$??0CDlgSettingToolBar@@QAE@PAVCWnd@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0CDlgSettingToolBar@@QAE@PAVCWnd@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CDlgSettingToolBar@@QAE@PAVCWnd@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CDlgSettingToolBar@@QAE@PAVCWnd@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0CDlgSettingToolBar@@QAE@PAVCWnd@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0CDlgSettingToolBar@@QAE@PAVCWnd@@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0CDlgSettingToolBar@@QAE@PAVCWnd@@@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$??0CDlgSettingToolBar@@QAE@PAVCWnd@@@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$??0CDlgSettingToolBar@@QAE@PAVCWnd@@@Z$6
	DD	06H
	DD	FLAT:__unwindfunclet$??0CDlgSettingToolBar@@QAE@PAVCWnd@@@Z$7
	DD	07H
	DD	FLAT:__unwindfunclet$??0CDlgSettingToolBar@@QAE@PAVCWnd@@@Z$8
	DD	08H
	DD	FLAT:__unwindfunclet$??0CDlgSettingToolBar@@QAE@PAVCWnd@@@Z$9
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?FillAvailableList@CDlgSettingToolBar@@AAEXAAV?$CArray@HH@@AAV?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?FillAvailableList@CDlgSettingToolBar@@AAEXAAV?$CArray@HH@@AAV?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@@Z$0
__ehfuncinfo$?FillAvailableList@CDlgSettingToolBar@@AAEXAAV?$CArray@HH@@AAV?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?FillAvailableList@CDlgSettingToolBar@@AAEXAAV?$CArray@HH@@AAV?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?FillShowList@CDlgSettingToolBar@@AAEXAAV?$CArray@HH@@AAV?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?FillShowList@CDlgSettingToolBar@@AAEXAAV?$CArray@HH@@AAV?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@@Z$0
__ehfuncinfo$?FillShowList@CDlgSettingToolBar@@AAEXAAV?$CArray@HH@@AAV?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?FillShowList@CDlgSettingToolBar@@AAEXAAV?$CArray@HH@@AAV?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?ReadIniFile@CDlgSettingToolBar@@AAEXH@Z DD 019930522H
	DD	0eH
	DD	FLAT:__unwindtable$?ReadIniFile@CDlgSettingToolBar@@AAEXH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?ReadIniFile@CDlgSettingToolBar@@AAEXH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ReadIniFile@CDlgSettingToolBar@@AAEXH@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ReadIniFile@CDlgSettingToolBar@@AAEXH@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?ReadIniFile@CDlgSettingToolBar@@AAEXH@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?ReadIniFile@CDlgSettingToolBar@@AAEXH@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?ReadIniFile@CDlgSettingToolBar@@AAEXH@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?ReadIniFile@CDlgSettingToolBar@@AAEXH@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$?ReadIniFile@CDlgSettingToolBar@@AAEXH@Z$6
	DD	06H
	DD	FLAT:__unwindfunclet$?ReadIniFile@CDlgSettingToolBar@@AAEXH@Z$7
	DD	07H
	DD	FLAT:__unwindfunclet$?ReadIniFile@CDlgSettingToolBar@@AAEXH@Z$8
	DD	08H
	DD	FLAT:__unwindfunclet$?ReadIniFile@CDlgSettingToolBar@@AAEXH@Z$9
	DD	09H
	DD	FLAT:__unwindfunclet$?ReadIniFile@CDlgSettingToolBar@@AAEXH@Z$10
	DD	0aH
	DD	FLAT:__unwindfunclet$?ReadIniFile@CDlgSettingToolBar@@AAEXH@Z$17
	DD	0aH
	DD	FLAT:__unwindfunclet$?ReadIniFile@CDlgSettingToolBar@@AAEXH@Z$18
	DD	0aH
	DD	FLAT:__unwindfunclet$?ReadIniFile@CDlgSettingToolBar@@AAEXH@Z$19
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?GetFieldData@CDlgSettingToolBar@@AAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAHAAV23@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetFieldData@CDlgSettingToolBar@@AAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAHAAV23@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?GetFieldData@CDlgSettingToolBar@@AAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAHAAV23@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?GetFieldData@CDlgSettingToolBar@@AAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAHAAV23@@Z$2
__ehfuncinfo$?GetFieldData@CDlgSettingToolBar@@AAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAHAAV23@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?GetFieldData@CDlgSettingToolBar@@AAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAHAAV23@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_G?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@UAEPAXI@Z DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??_G?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@UAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_G?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@UAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Serialize@?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@UAEXAAVCArchive@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Serialize@?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@UAEXAAVCArchive@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?Serialize@?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@UAEXAAVCArchive@@@Z$2
__ehfuncinfo$?Serialize@?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@UAEXAAVCArchive@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?Serialize@?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@UAEXAAVCArchive@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?SetAt@?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@QAEXHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SetAt@?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@QAEXHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z$0
__ehfuncinfo$?SetAt@?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@QAEXHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SetAt@?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@QAEXHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ??$CompareElements@HH@@YGHPBH0@Z
_TEXT	SEGMENT
_pElement1$ = 8						; size = 4
_pElement2$ = 12					; size = 4
??$CompareElements@HH@@YGHPBH0@Z PROC			; CompareElements<int,int>, COMDAT

; 151  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 152  : 	ENSURE(pElement1 != NULL && pElement2 != NULL);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _pElement1$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 14		 je	 SHORT $LN7@CompareEle
  0000a	8b 55 0c	 mov	 edx, DWORD PTR _pElement2$[ebp]
  0000d	85 d2		 test	 edx, edx
  0000f	74 0d		 je	 SHORT $LN7@CompareEle

; 153  : 	ASSERT(AfxIsValidAddress(pElement1, sizeof(TYPE), FALSE));
; 154  : 	ASSERT(AfxIsValidAddress(pElement2, sizeof(ARG_TYPE), FALSE));
; 155  : 
; 156  : 	return *pElement1 == *pElement2;

  00011	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00013	33 c0		 xor	 eax, eax
  00015	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  00017	0f 94 c0	 sete	 al

; 157  : }

  0001a	5d		 pop	 ebp
  0001b	c2 08 00	 ret	 8
$LN7@CompareEle:

; 152  : 	ENSURE(pElement1 != NULL && pElement2 != NULL);

  0001e	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN10@CompareEle:
  00023	cc		 int	 3
??$CompareElements@HH@@YGHPBH0@Z ENDP			; CompareElements<int,int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ??$SerializeElements@H@@YGXAAVCArchive@@PAHH@Z
_TEXT	SEGMENT
_ar$ = 8						; size = 4
_pElements$ = 12					; size = 4
_nCount$ = 16						; size = 4
??$SerializeElements@H@@YGXAAVCArchive@@PAHH@Z PROC	; SerializeElements<int>, COMDAT

; 67   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 68   : 	ENSURE(nCount == 0 || pElements != NULL);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR _pElements$[ebp]
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b 75 10	 mov	 esi, DWORD PTR _nCount$[ebp]
  0000b	57		 push	 edi
  0000c	85 f6		 test	 esi, esi
  0000e	74 08		 je	 SHORT $LN2@SerializeE
  00010	85 c9		 test	 ecx, ecx
  00012	0f 84 89 00 00
	00		 je	 $LN34@SerializeE
$LN2@SerializeE:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 212  : 	{ return (m_nMode & CArchive::load) == 0; }

  00018	8b 55 08	 mov	 edx, DWORD PTR _ar$[ebp]
  0001b	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0001e	f7 d0		 not	 eax
  00020	a8 01		 test	 al, 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 73   : 	if (ar.IsStoring())

  00022	74 3c		 je	 SHORT $LN10@SerializeE

; 74   : 	{
; 75   : 		TYPE* pData;
; 76   : 		UINT_PTR nElementsLeft;
; 77   : 
; 78   : 		nElementsLeft = nCount;
; 79   : 		pData = pElements;
; 80   : 		while( nElementsLeft > 0 )

  00024	85 f6		 test	 esi, esi
  00026	74 31		 je	 SHORT $LN8@SerializeE
  00028	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL5@SerializeE:

; 81   : 		{
; 82   : 			UINT nElementsToWrite;
; 83   : 
; 84   : 			nElementsToWrite = UINT(__min(nElementsLeft, INT_MAX/sizeof(TYPE)));

  00030	bb ff ff ff 1f	 mov	 ebx, 536870911		; 1fffffffH
  00035	3b f3		 cmp	 esi, ebx
  00037	0f 42 de	 cmovb	 ebx, esi

; 85   : 			ar.Write(pData, nElementsToWrite*sizeof(TYPE));

  0003a	8d 3c 9d 00 00
	00 00		 lea	 edi, DWORD PTR [ebx*4]
  00041	57		 push	 edi
  00042	51		 push	 ecx
  00043	8b ca		 mov	 ecx, edx
  00045	e8 00 00 00 00	 call	 ?Write@CArchive@@QAEXPBXI@Z ; CArchive::Write

; 86   : 			nElementsLeft -= nElementsToWrite;
; 87   : 			pData += nElementsToWrite;

  0004a	8b 4d 0c	 mov	 ecx, DWORD PTR _pElements$[ebp]
  0004d	8b 55 08	 mov	 edx, DWORD PTR _ar$[ebp]
  00050	03 cf		 add	 ecx, edi
  00052	89 4d 0c	 mov	 DWORD PTR _pElements$[ebp], ecx
  00055	2b f3		 sub	 esi, ebx
  00057	75 d7		 jne	 SHORT $LL5@SerializeE
$LN8@SerializeE:
  00059	5f		 pop	 edi

; 105  : 		}
; 106  : 	}
; 107  : }

  0005a	5e		 pop	 esi
  0005b	5b		 pop	 ebx
  0005c	5d		 pop	 ebp
  0005d	c2 0c 00	 ret	 12			; 0000000cH
$LN10@SerializeE:

; 97   : 		while( nElementsLeft > 0 )

  00060	85 f6		 test	 esi, esi
  00062	74 f5		 je	 SHORT $LN8@SerializeE
$LL7@SerializeE:

; 98   : 		{
; 99   : 			UINT nElementsToRead;
; 100  : 
; 101  : 			nElementsToRead = UINT(__min(nElementsLeft, INT_MAX/sizeof(TYPE)));

  00064	bf ff ff ff 1f	 mov	 edi, 536870911		; 1fffffffH
  00069	3b f7		 cmp	 esi, edi
  0006b	0f 42 fe	 cmovb	 edi, esi

; 102  : 			ar.EnsureRead(pData, nElementsToRead*sizeof(TYPE));

  0006e	8d 1c bd 00 00
	00 00		 lea	 ebx, DWORD PTR [edi*4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 399  : 	UINT nRead=Read(lpBuf, nCount);

  00075	53		 push	 ebx
  00076	51		 push	 ecx
  00077	8b ca		 mov	 ecx, edx
  00079	e8 00 00 00 00	 call	 ?Read@CArchive@@QAEIPAXI@Z ; CArchive::Read

; 400  : 	if(nRead!=nCount)

  0007e	3b c3		 cmp	 eax, ebx
  00080	75 16		 jne	 SHORT $LN23@SerializeE
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 97   : 		while( nElementsLeft > 0 )

  00082	8b 4d 0c	 mov	 ecx, DWORD PTR _pElements$[ebp]
  00085	8b 55 08	 mov	 edx, DWORD PTR _ar$[ebp]

; 103  : 			nElementsLeft -= nElementsToRead;
; 104  : 			pData += nElementsToRead;

  00088	03 cb		 add	 ecx, ebx
  0008a	89 4d 0c	 mov	 DWORD PTR _pElements$[ebp], ecx
  0008d	2b f7		 sub	 esi, edi
  0008f	75 d3		 jne	 SHORT $LL7@SerializeE

; 105  : 		}
; 106  : 	}
; 107  : }

  00091	5f		 pop	 edi
  00092	5e		 pop	 esi
  00093	5b		 pop	 ebx
  00094	5d		 pop	 ebp
  00095	c2 0c 00	 ret	 12			; 0000000cH
$LN23@SerializeE:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 402  : 		AfxThrowArchiveException(CArchiveException::endOfFile);

  00098	6a 00		 push	 0
  0009a	6a 03		 push	 3
  0009c	e8 00 00 00 00	 call	 ?AfxThrowArchiveException@@YGXHPBD@Z ; AfxThrowArchiveException
$LN34@SerializeE:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 68   : 	ENSURE(nCount == 0 || pElements != NULL);

  000a1	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN32@SerializeE:
  000a6	cc		 int	 3
??$SerializeElements@H@@YGXAAVCArchive@@PAHH@Z ENDP	; SerializeElements<int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
;	COMDAT ??_GCDlgSettingToolBar@@UAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_GCDlgSettingToolBar@@UAEPAXI@Z PROC			; CDlgSettingToolBar::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_GCDlgSettingToolBar@@UAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx
  00025	8d 8e c8 02 00
	00		 lea	 ecx, DWORD PTR [esi+712]
  0002b	e8 00 00 00 00	 call	 ??1CComboBox@@UAE@XZ	; CComboBox::~CComboBox
  00030	8d 8e 48 02 00
	00		 lea	 ecx, DWORD PTR [esi+584]
  00036	e8 00 00 00 00	 call	 ??1CComboBox@@UAE@XZ	; CComboBox::~CComboBox
  0003b	8d 8e c8 01 00
	00		 lea	 ecx, DWORD PTR [esi+456]
  00041	e8 00 00 00 00	 call	 ??1CListBox@@UAE@XZ	; CListBox::~CListBox
  00046	8d 8e 48 01 00
	00		 lea	 ecx, DWORD PTR [esi+328]
  0004c	e8 00 00 00 00	 call	 ??1CListBox@@UAE@XZ	; CListBox::~CListBox
  00051	8d 8e 20 01 00
	00		 lea	 ecx, DWORD PTR [esi+288]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 1472 : {

  00057	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0005e	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@6B@

; 1473 : 	RemoveAll();

  00064	e8 00 00 00 00	 call	 ?RemoveAll@?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@QAEXXZ ; CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >::RemoveAll
  00069	8d 8e 04 01 00
	00		 lea	 ecx, DWORD PTR [esi+260]

; 1472 : {

  0006f	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00076	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@6B@

; 1473 : 	RemoveAll();

  0007c	e8 00 00 00 00	 call	 ?RemoveAll@?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@QAEXXZ ; CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >::RemoveAll
  00081	8d 8e e8 00 00
	00		 lea	 ecx, DWORD PTR [esi+232]

; 1472 : {

  00087	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  0008e	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@6B@

; 1473 : 	RemoveAll();

  00094	e8 00 00 00 00	 call	 ?RemoveAll@?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@QAEXXZ ; CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >::RemoveAll

; 358  : 	if (m_pData != NULL)

  00099	8b 86 d8 00 00
	00		 mov	 eax, DWORD PTR [esi+216]
  0009f	c7 86 d4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+212], OFFSET ??_7?$CArray@HH@@6B@
  000a9	85 c0		 test	 eax, eax
  000ab	74 13		 je	 SHORT $LN23@scalar

; 359  : 	{
; 360  : 		for( int i = 0; i < m_nSize; i++ )

  000ad	83 be dc 00 00
	00 00		 cmp	 DWORD PTR [esi+220], 0
  000b4	0f 4f c0	 cmovg	 eax, eax

; 361  : 			(m_pData + i)->~TYPE();
; 362  : 		delete[] (BYTE*)m_pData;

  000b7	50		 push	 eax
  000b8	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  000bd	83 c4 04	 add	 esp, 4
$LN23@scalar:

; 358  : 	if (m_pData != NULL)

  000c0	8b 86 c4 00 00
	00		 mov	 eax, DWORD PTR [esi+196]
  000c6	c7 86 c0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+192], OFFSET ??_7?$CArray@HH@@6B@
  000d0	85 c0		 test	 eax, eax
  000d2	74 13		 je	 SHORT $LN30@scalar

; 359  : 	{
; 360  : 		for( int i = 0; i < m_nSize; i++ )

  000d4	83 be c8 00 00
	00 00		 cmp	 DWORD PTR [esi+200], 0
  000db	0f 4f c0	 cmovg	 eax, eax

; 361  : 			(m_pData + i)->~TYPE();
; 362  : 		delete[] (BYTE*)m_pData;

  000de	50		 push	 eax
  000df	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  000e4	83 c4 04	 add	 esp, 4
$LN30@scalar:

; 358  : 	if (m_pData != NULL)

  000e7	8b 86 b0 00 00
	00		 mov	 eax, DWORD PTR [esi+176]
  000ed	c7 86 ac 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+172], OFFSET ??_7?$CArray@HH@@6B@
  000f7	85 c0		 test	 eax, eax
  000f9	74 13		 je	 SHORT $LN37@scalar

; 359  : 	{
; 360  : 		for( int i = 0; i < m_nSize; i++ )

  000fb	83 be b4 00 00
	00 00		 cmp	 DWORD PTR [esi+180], 0
  00102	0f 4f c0	 cmovg	 eax, eax

; 361  : 			(m_pData + i)->~TYPE();
; 362  : 		delete[] (BYTE*)m_pData;

  00105	50		 push	 eax
  00106	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0010b	83 c4 04	 add	 esp, 4
$LN37@scalar:
  0010e	8b ce		 mov	 ecx, esi
  00110	e8 00 00 00 00	 call	 ??1CDialog@@UAE@XZ	; CDialog::~CDialog
  00115	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00118	a8 01		 test	 al, 1
  0011a	74 2f		 je	 SHORT $LN54@scalar
  0011c	a8 04		 test	 al, 4
  0011e	75 1d		 jne	 SHORT $LN3@scalar
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 112  : 	{ ::operator delete(p); }

  00120	56		 push	 esi
  00121	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00126	83 c4 04	 add	 esp, 4
  00129	8b c6		 mov	 eax, esi
  0012b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0012e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00135	59		 pop	 ecx
  00136	5e		 pop	 esi
  00137	8b e5		 mov	 esp, ebp
  00139	5d		 pop	 ebp
  0013a	c2 04 00	 ret	 4
$LN3@scalar:
  0013d	68 48 03 00 00	 push	 840			; 00000348H
  00142	56		 push	 esi
  00143	e8 00 00 00 00	 call	 ?__global_delete@@YAXPAXI@Z ; __global_delete
  00148	83 c4 08	 add	 esp, 8
$LN54@scalar:
  0014b	8b c6		 mov	 eax, esi
  0014d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00150	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00157	59		 pop	 ecx
  00158	5e		 pop	 esi
  00159	8b e5		 mov	 esp, ebp
  0015b	5d		 pop	 ebp
  0015c	c2 04 00	 ret	 4
  0015f	cc		 int	 3
  00160	cc		 int	 3
  00161	cc		 int	 3
  00162	cc		 int	 3
  00163	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??_GCDlgSettingToolBar@@UAEPAXI@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_GCDlgSettingToolBar@@UAEPAXI@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_GCDlgSettingToolBar@@UAEPAXI@Z ENDP			; CDlgSettingToolBar::`scalar deleting destructor'
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
;	COMDAT ?GetMessageMap@CDlgSettingToolBar@@MBEPBUAFX_MSGMAP@@XZ
_TEXT	SEGMENT
?GetMessageMap@CDlgSettingToolBar@@MBEPBUAFX_MSGMAP@@XZ PROC ; CDlgSettingToolBar::GetMessageMap, COMDAT
; _this$ = ecx

; 42   : BEGIN_MESSAGE_MAP(CDlgSettingToolBar, CDialog)

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?messageMap@?1??GetThisMessageMap@CDlgSettingToolBar@@KGPBUAFX_MSGMAP@@XZ@4U3@B
  00005	c3		 ret	 0
?GetMessageMap@CDlgSettingToolBar@@MBEPBUAFX_MSGMAP@@XZ ENDP ; CDlgSettingToolBar::GetMessageMap
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
;	COMDAT ?GetThisMessageMap@CDlgSettingToolBar@@KGPBUAFX_MSGMAP@@XZ
_TEXT	SEGMENT
?GetThisMessageMap@CDlgSettingToolBar@@KGPBUAFX_MSGMAP@@XZ PROC ; CDlgSettingToolBar::GetThisMessageMap, COMDAT

; 43   : 	//{{AFX_MSG_MAP(CDlgSettingToolBar)
; 44   : 	ON_BN_CLICKED(IDC_APPLY, OnApply)
; 45   : 	ON_CBN_SELCHANGE(IDC_CMB_AVAILABLE, OnSelchangeCmbAvailable)
; 46   : 	ON_CBN_SELCHANGE(IDC_CMB_SHOW, OnSelchangeCmbShow)
; 47   : 	ON_BN_CLICKED(IDC_BTN_ADD, OnBtnAdd)
; 48   : 	ON_BN_CLICKED(IDC_BTN_INIT, OnBtnInit)
; 49   : 	ON_BN_CLICKED(IDC_BTN_MOVEDOWN, OnBtnMovedown)
; 50   : 	ON_BN_CLICKED(IDC_BTN_MOVSYP, OnBtnMovsyp)
; 51   : 	ON_BN_CLICKED(IDC_BTN_REMOVE, OnBtnRemove)
; 52   : 	ON_BN_CLICKED(IDC_BTN_REMOVEALL, OnBtnRemoveall)
; 53   : 	ON_BN_CLICKED(IDC_BTN_ADDALL, OnBtnAddall)
; 54   : 	ON_LBN_DBLCLK(IDC_LIST_AVAILABLE, OnDblclkListAdd)
; 55   : 	ON_LBN_DBLCLK(IDC_LIST_SHOW, OnDblclkListRemove)
; 56   : 	//}}AFX_MSG_MAP
; 57   : END_MESSAGE_MAP()

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?messageMap@?1??GetThisMessageMap@CDlgSettingToolBar@@KGPBUAFX_MSGMAP@@XZ@4U3@B
  00005	c3		 ret	 0
?GetThisMessageMap@CDlgSettingToolBar@@KGPBUAFX_MSGMAP@@XZ ENDP ; CDlgSettingToolBar::GetThisMessageMap
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
;	COMDAT ?OnDblclkListRemove@CDlgSettingToolBar@@IAEXXZ
_TEXT	SEGMENT
?OnDblclkListRemove@CDlgSettingToolBar@@IAEXXZ PROC	; CDlgSettingToolBar::OnDblclkListRemove, COMDAT
; _this$ = ecx

; 656  : {

  00000	56		 push	 esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl

; 765  : 	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, CB_GETCURSEL, 0, 0); }

  00001	6a 00		 push	 0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 656  : {

  00003	8b f1		 mov	 esi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl

; 765  : 	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, CB_GETCURSEL, 0, 0); }

  00005	6a 00		 push	 0
  00007	68 47 01 00 00	 push	 327			; 00000147H
  0000c	ff b6 68 02 00
	00		 push	 DWORD PTR [esi+616]
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 659  : 	if(nCurSel == 0)

  00018	85 c0		 test	 eax, eax
  0001a	75 08		 jne	 SHORT $LN2@OnDblclkLi

; 660  : 		OnBtnRemove();

  0001c	8b ce		 mov	 ecx, esi
  0001e	5e		 pop	 esi
  0001f	e9 00 00 00 00	 jmp	 ?OnBtnRemove@CDlgSettingToolBar@@IAEXXZ ; CDlgSettingToolBar::OnBtnRemove
$LN2@OnDblclkLi:
  00024	5e		 pop	 esi

; 661  : }

  00025	c3		 ret	 0
?OnDblclkListRemove@CDlgSettingToolBar@@IAEXXZ ENDP	; CDlgSettingToolBar::OnDblclkListRemove
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
;	COMDAT ?OnDblclkListAdd@CDlgSettingToolBar@@IAEXXZ
_TEXT	SEGMENT
?OnDblclkListAdd@CDlgSettingToolBar@@IAEXXZ PROC	; CDlgSettingToolBar::OnDblclkListAdd, COMDAT
; _this$ = ecx

; 648  : {

  00000	56		 push	 esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl

; 765  : 	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, CB_GETCURSEL, 0, 0); }

  00001	6a 00		 push	 0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 648  : {

  00003	8b f1		 mov	 esi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl

; 765  : 	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, CB_GETCURSEL, 0, 0); }

  00005	6a 00		 push	 0
  00007	68 47 01 00 00	 push	 327			; 00000147H
  0000c	ff b6 68 02 00
	00		 push	 DWORD PTR [esi+616]
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 651  : 	if(nCurSel == 0)

  00018	85 c0		 test	 eax, eax
  0001a	75 08		 jne	 SHORT $LN2@OnDblclkLi

; 652  : 		OnBtnAdd();

  0001c	8b ce		 mov	 ecx, esi
  0001e	5e		 pop	 esi
  0001f	e9 00 00 00 00	 jmp	 ?OnBtnAdd@CDlgSettingToolBar@@IAEXXZ ; CDlgSettingToolBar::OnBtnAdd
$LN2@OnDblclkLi:
  00024	5e		 pop	 esi

; 653  : }

  00025	c3		 ret	 0
?OnDblclkListAdd@CDlgSettingToolBar@@IAEXXZ ENDP	; CDlgSettingToolBar::OnDblclkListAdd
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
;	COMDAT ?OnBtnAddall@CDlgSettingToolBar@@IAEXXZ
_TEXT	SEGMENT
_nHashValue$2 = -52					; size = 4
_nHashBucket$3 = -52					; size = 4
_nHashBucket$4 = -48					; size = 4
_nHashValue$5 = -48					; size = 4
_nHashValue$6 = -44					; size = 4
_nHashBucket$7 = -44					; size = 4
_nHashBucket$8 = -40					; size = 4
_nHashValue$9 = -40					; size = 4
_this$1$ = -36						; size = 4
_this$1$ = -32						; size = 4
_nIndex$1$ = -28					; size = 4
_nIdx$1$ = -28						; size = 4
$T10 = -28						; size = 4
_nIdx$1$ = -24						; size = 4
$T11 = -24						; size = 4
_nKey$1$ = -20						; size = 4
_nKey$2$ = -20						; size = 4
_strFieldName$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?OnBtnAddall@CDlgSettingToolBar@@IAEXXZ PROC		; CDlgSettingToolBar::OnBtnAddall, COMDAT
; _this$ = ecx

; 608  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?OnBtnAddall@CDlgSettingToolBar@@IAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 28	 sub	 esp, 40			; 00000028H
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	50		 push	 eax
  0001e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00027	8b f9		 mov	 edi, ecx
  00029	89 7d dc	 mov	 DWORD PTR _this$1$[ebp], edi

; 610  : 	CString strFieldName;

  0002c	8d 4d f0	 lea	 ecx, DWORD PTR _strFieldName$[ebp]
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 381  : 		if (m_pData != NULL)

  00035	8b 87 d8 00 00
	00		 mov	 eax, DWORD PTR [edi+216]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 610  : 	CString strFieldName;

  0003b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 381  : 		if (m_pData != NULL)

  00042	85 c0		 test	 eax, eax
  00044	74 13		 je	 SHORT $LN38@OnBtnAddal

; 382  : 		{
; 383  : 			for( int i = 0; i < m_nSize; i++ )
; 384  : 				(m_pData + i)->~TYPE();
; 385  : 			delete[] (BYTE*)m_pData;

  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0004c	83 c4 04	 add	 esp, 4

; 386  : 			m_pData = NULL;

  0004f	c7 87 d8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+216], 0
$LN38@OnBtnAddal:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 614  : 	m_mapUserList.RemoveAll();

  00059	8d b7 20 01 00
	00		 lea	 esi, DWORD PTR [edi+288]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 388  : 		m_nSize = m_nMaxSize = 0;

  0005f	c7 87 e0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+224], 0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 614  : 	m_mapUserList.RemoveAll();

  00069	8b ce		 mov	 ecx, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 388  : 		m_nSize = m_nMaxSize = 0;

  0006b	c7 87 dc 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+220], 0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 614  : 	m_mapUserList.RemoveAll();

  00075	e8 00 00 00 00	 call	 ?RemoveAll@?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@QAEXXZ ; CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >::RemoveAll
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 333  : 	{ INT_PTR nIndex = m_nSize;

  0007a	8b 87 dc 00 00
	00		 mov	 eax, DWORD PTR [edi+220]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 617  : 	m_arrayUserIdx.Add(CHART_TOOL);	//

  00080	8d 8f d4 00 00
	00		 lea	 ecx, DWORD PTR [edi+212]
  00086	89 4d e0	 mov	 DWORD PTR _this$1$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 333  : 	{ INT_PTR nIndex = m_nSize;

  00089	89 45 e4	 mov	 DWORD PTR _nIndex$1$[ebp], eax

; 538  : 	if(nIndex < 0)

  0008c	85 c0		 test	 eax, eax
  0008e	0f 88 ea 03 00
	00		 js	 $LN180@OnBtnAddal

; 539  : 		AfxThrowInvalidArgException();
; 540  : 
; 541  : 	if (nIndex >= m_nSize)
; 542  : 		SetSize(nIndex+1, -1);

  00094	6a ff		 push	 -1
  00096	40		 inc	 eax
  00097	50		 push	 eax
  00098	e8 00 00 00 00	 call	 ?SetSize@?$CArray@HH@@QAEXHH@Z ; CArray<int,int>::SetSize

; 543  : 	m_pData[nIndex] = newElement;

  0009d	8b 4d e4	 mov	 ecx, DWORD PTR _nIndex$1$[ebp]
  000a0	8b 87 d8 00 00
	00		 mov	 eax, DWORD PTR [edi+216]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 618  : 	m_mapUserList.SetAt(CHART_TOOL, "");

  000a6	51		 push	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 543  : 	m_pData[nIndex] = newElement;

  000a7	c7 04 88 03 00
	00 00		 mov	 DWORD PTR [eax+ecx*4], 3
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 618  : 	m_mapUserList.SetAt(CHART_TOOL, "");

  000ae	8b cc		 mov	 ecx, esp
  000b0	68 00 00 00 00	 push	 OFFSET ??_C@_0L@PPOMAPHP@?B?w?F?$KO?E?x?F?m?A?$PN@
  000b5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  000bb	6a 03		 push	 3
  000bd	8b ce		 mov	 ecx, esi
  000bf	e8 00 00 00 00	 call	 ?SetAt@?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@QAEXHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ; CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >::SetAt
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl

; 765  : 	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, CB_GETCURSEL, 0, 0); }

  000c4	6a 00		 push	 0
  000c6	6a 00		 push	 0
  000c8	68 47 01 00 00	 push	 327			; 00000147H
  000cd	ff b7 e8 02 00
	00		 push	 DWORD PTR [edi+744]
  000d3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 621  : 	if(0 ==nCmbCurSel)		// Anal

  000d9	85 c0		 test	 eax, eax
  000db	0f 85 b8 01 00
	00		 jne	 $LN8@OnBtnAddal

; 623  : 		for (int nIdx=0; nIdx<m_arrayAnalIdx.GetSize(); nIdx++)

  000e1	8b 87 b4 00 00
	00		 mov	 eax, DWORD PTR [edi+180]
  000e7	33 c9		 xor	 ecx, ecx
  000e9	89 4d e4	 mov	 DWORD PTR _nIdx$1$[ebp], ecx
  000ec	85 c0		 test	 eax, eax
  000ee	0f 8e 61 03 00
	00		 jle	 $LN6@OnBtnAddal
$LL4@OnBtnAddal:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 288  : 	if(nIndex >= 0 && nIndex < m_nSize)

  000f4	85 c9		 test	 ecx, ecx
  000f6	0f 88 82 03 00
	00		 js	 $LN180@OnBtnAddal
  000fc	3b c8		 cmp	 ecx, eax
  000fe	0f 8d 7a 03 00
	00		 jge	 $LN180@OnBtnAddal

; 289  : 		return m_pData[nIndex];

  00104	8b 87 b0 00 00
	00		 mov	 eax, DWORD PTR [edi+176]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 625  : 			nKey = m_arrayAnalIdx.GetAt(nIdx);

  0010a	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 1555 : 	CAssoc* pAssoc = GetAssocAt(key, nHashBucket, nHashValue);

  0010d	8d 4d d0	 lea	 ecx, DWORD PTR _nHashValue$5[ebp]
  00110	51		 push	 ecx
  00111	8d 4d cc	 lea	 ecx, DWORD PTR _nHashBucket$3[ebp]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 625  : 			nKey = m_arrayAnalIdx.GetAt(nIdx);

  00114	89 45 ec	 mov	 DWORD PTR _nKey$1$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 1555 : 	CAssoc* pAssoc = GetAssocAt(key, nHashBucket, nHashValue);

  00117	51		 push	 ecx
  00118	50		 push	 eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 626  : 			m_mapAnalList.Lookup(nKey, strFieldName);

  00119	8d 8f e8 00 00
	00		 lea	 ecx, DWORD PTR [edi+232]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 1555 : 	CAssoc* pAssoc = GetAssocAt(key, nHashBucket, nHashValue);

  0011f	e8 00 00 00 00	 call	 ?GetAssocAt@?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@IBEPAVCAssoc@1@HAAI0@Z ; CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >::GetAssocAt

; 1556 : 	if (pAssoc == NULL)

  00124	85 c0		 test	 eax, eax
  00126	74 0d		 je	 SHORT $LN79@OnBtnAddal

; 1557 : 		return FALSE;  // not in map
; 1558 : 
; 1559 : 	rValue = pAssoc->value;

  00128	83 c0 04	 add	 eax, 4
  0012b	8d 4d f0	 lea	 ecx, DWORD PTR _strFieldName$[ebp]
  0012e	50		 push	 eax
  0012f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
$LN79@OnBtnAddal:

; 333  : 	{ INT_PTR nIndex = m_nSize;

  00135	8d 8f d4 00 00
	00		 lea	 ecx, DWORD PTR [edi+212]
  0013b	8b 79 08	 mov	 edi, DWORD PTR [ecx+8]

; 538  : 	if(nIndex < 0)

  0013e	85 ff		 test	 edi, edi
  00140	0f 88 38 03 00
	00		 js	 $LN180@OnBtnAddal

; 539  : 		AfxThrowInvalidArgException();
; 540  : 
; 541  : 	if (nIndex >= m_nSize)
; 542  : 		SetSize(nIndex+1, -1);

  00146	6a ff		 push	 -1
  00148	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  0014b	50		 push	 eax
  0014c	e8 00 00 00 00	 call	 ?SetSize@?$CArray@HH@@QAEXHH@Z ; CArray<int,int>::SetSize

; 543  : 	m_pData[nIndex] = newElement;

  00151	8b 4d e0	 mov	 ecx, DWORD PTR _this$1$[ebp]
  00154	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00157	8b 4d ec	 mov	 ecx, DWORD PTR _nKey$1$[ebp]
  0015a	89 0c b8	 mov	 DWORD PTR [eax+edi*4], ecx
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 629  : 			m_mapUserList.SetAt(nKey, strFieldName);

  0015d	8d 45 f0	 lea	 eax, DWORD PTR _strFieldName$[ebp]
  00160	50		 push	 eax
  00161	8d 4d e8	 lea	 ecx, DWORD PTR $T11[ebp]
  00164	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 1590 : 	if ((pAssoc = GetAssocAt(key, nHashBucket, nHashValue)) == NULL)

  0016a	8d 45 d8	 lea	 eax, DWORD PTR _nHashValue$9[ebp]

; 1350 : 	{ (*this)[key] = newValue; }

  0016d	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 1590 : 	if ((pAssoc = GetAssocAt(key, nHashBucket, nHashValue)) == NULL)

  00171	50		 push	 eax
  00172	8d 45 d4	 lea	 eax, DWORD PTR _nHashBucket$7[ebp]
  00175	8b ce		 mov	 ecx, esi
  00177	50		 push	 eax
  00178	ff 75 ec	 push	 DWORD PTR _nKey$1$[ebp]
  0017b	e8 00 00 00 00	 call	 ?GetAssocAt@?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@IBEPAVCAssoc@1@HAAI0@Z ; CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >::GetAssocAt
  00180	8b f8		 mov	 edi, eax
  00182	85 ff		 test	 edi, edi
  00184	0f 85 d8 00 00
	00		 jne	 $LN96@OnBtnAddal

; 1591 : 	{
; 1592 : 		if (m_pHashTable == NULL)

  0018a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0018d	85 c0		 test	 eax, eax
  0018f	75 4a		 jne	 SHORT $LN205@OnBtnAddal

; 1593 : 			InitHashTable(m_nHashTableSize);

  00191	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]

; 1434 : 		m_pHashTable = new CAssoc* [nHashSize];

  00194	33 c9		 xor	 ecx, ecx
  00196	8b c7		 mov	 eax, edi
  00198	ba 04 00 00 00	 mov	 edx, 4
  0019d	f7 e2		 mul	 edx
  0019f	0f 90 c1	 seto	 cl
  001a2	f7 d9		 neg	 ecx
  001a4	0b c8		 or	 ecx, eax
  001a6	51		 push	 ecx
  001a7	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  001ac	83 c4 04	 add	 esp, 4
  001af	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 1435 : 		ENSURE(m_pHashTable != NULL);

  001b2	85 c0		 test	 eax, eax
  001b4	0f 84 c4 02 00
	00		 je	 $LN180@OnBtnAddal

; 1436 : 		memset(m_pHashTable, 0, sizeof(CAssoc*) * nHashSize);

  001ba	8d 0c bd 00 00
	00 00		 lea	 ecx, DWORD PTR [edi*4]
  001c1	51		 push	 ecx
  001c2	6a 00		 push	 0
  001c4	50		 push	 eax
  001c5	e8 00 00 00 00	 call	 _memset

; 1437 : 	}
; 1438 : 	m_nHashTableSize = nHashSize;

  001ca	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  001cd	83 c4 0c	 add	 esp, 12			; 0000000cH
  001d0	89 7e 08	 mov	 DWORD PTR [esi+8], edi

; 1595 : 		ENSURE(m_pHashTable);

  001d3	85 c0		 test	 eax, eax
  001d5	0f 84 a3 02 00
	00		 je	 $LN180@OnBtnAddal
$LN205@OnBtnAddal:

; 1481 : 	if (m_pFreeList == NULL)

  001db	83 7e 10 00	 cmp	 DWORD PTR [esi+16], 0
  001df	75 31		 jne	 SHORT $LN115@OnBtnAddal

; 1482 : 	{
; 1483 : 		// add another block
; 1484 : 		CPlex* newBlock = CPlex::Create(m_pBlocks, m_nBlockSize, sizeof(CMap::CAssoc));

  001e1	6a 10		 push	 16			; 00000010H
  001e3	ff 76 18	 push	 DWORD PTR [esi+24]
  001e6	8d 46 14	 lea	 eax, DWORD PTR [esi+20]
  001e9	50		 push	 eax
  001ea	e8 00 00 00 00	 call	 ?Create@CPlex@@SGPAU1@AAPAU1@II@Z ; CPlex::Create

; 1485 : 		// chain them into free list
; 1486 : 		CMap::CAssoc* pAssoc = (CMap::CAssoc*) newBlock->data();
; 1487 : 		// free in reverse order to make it easier to debug
; 1488 : 		pAssoc += m_nBlockSize - 1;

  001ef	8b 56 18	 mov	 edx, DWORD PTR [esi+24]
  001f2	8b ca		 mov	 ecx, edx
  001f4	c1 e1 04	 shl	 ecx, 4
  001f7	83 c1 f8	 add	 ecx, -8			; fffffff8H
  001fa	03 c8		 add	 ecx, eax

; 1489 : 		for (INT_PTR i = m_nBlockSize-1; i >= 0; i--, pAssoc--)

  001fc	83 c2 ff	 add	 edx, -1
  001ff	78 11		 js	 SHORT $LN115@OnBtnAddal
$LL112@OnBtnAddal:

; 1490 : 		{
; 1491 : 			pAssoc->pNext = m_pFreeList;

  00201	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00204	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1492 : 			m_pFreeList = pAssoc;

  00207	89 4e 10	 mov	 DWORD PTR [esi+16], ecx
  0020a	83 e9 10	 sub	 ecx, 16			; 00000010H
  0020d	83 ea 01	 sub	 edx, 1
  00210	79 ef		 jns	 SHORT $LL112@OnBtnAddal
$LN115@OnBtnAddal:

; 1493 : 		}
; 1494 : 	}
; 1495 : 	ENSURE(m_pFreeList != NULL);  // we must have something

  00212	8b 7e 10	 mov	 edi, DWORD PTR [esi+16]
  00215	85 ff		 test	 edi, edi
  00217	0f 84 61 02 00
	00		 je	 $LN180@OnBtnAddal

; 1496 : 
; 1497 : 	CMap::CAssoc* pAssoc = m_pFreeList;
; 1498 : 
; 1499 : 	// zero the memory
; 1500 : 	CMap::CAssoc* pTemp = pAssoc->pNext;

  0021d	8b 47 08	 mov	 eax, DWORD PTR [edi+8]

; 1256 : 		CPair( ARG_KEY keyval ) : key( keyval )	{}

  00220	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  00223	0f 57 c0	 xorps	 xmm0, xmm0

; 1501 : 	memset( pAssoc, 0, sizeof(CMap::CAssoc) );

  00226	0f 11 07	 movups	 XMMWORD PTR [edi], xmm0

; 1502 : 	pAssoc->pNext = pTemp;

  00229	89 47 08	 mov	 DWORD PTR [edi+8], eax

; 1503 : 
; 1504 : 	m_pFreeList = m_pFreeList->pNext;

  0022c	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0022f	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 1505 : 	m_nCount++;

  00232	ff 46 0c	 inc	 DWORD PTR [esi+12]
  00235	89 46 10	 mov	 DWORD PTR [esi+16], eax

; 1256 : 		CPair( ARG_KEY keyval ) : key( keyval )	{}

  00238	8b 45 ec	 mov	 eax, DWORD PTR _nKey$1$[ebp]
  0023b	89 07		 mov	 DWORD PTR [edi], eax
  0023d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 1598 : 		pAssoc->nHashValue = nHashValue;

  00243	8b 45 d8	 mov	 eax, DWORD PTR _nHashValue$9[ebp]
  00246	89 47 0c	 mov	 DWORD PTR [edi+12], eax

; 1599 : 		//'pAssoc->value' is a constructed object, nothing more
; 1600 : 
; 1601 : 		// put into hash table
; 1602 : 		pAssoc->pNext = m_pHashTable[nHashBucket];

  00249	8b 45 d4	 mov	 eax, DWORD PTR _nHashBucket$7[ebp]
  0024c	8d 0c 85 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*4]
  00253	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00256	8b 04 01	 mov	 eax, DWORD PTR [ecx+eax]
  00259	89 47 08	 mov	 DWORD PTR [edi+8], eax

; 1603 : 		m_pHashTable[nHashBucket] = pAssoc;

  0025c	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0025f	89 3c 01	 mov	 DWORD PTR [ecx+eax], edi
$LN96@OnBtnAddal:

; 1350 : 	{ (*this)[key] = newValue; }

  00262	8d 45 e8	 lea	 eax, DWORD PTR $T11[ebp]

; 1605 : 	return pAssoc->value;  // return new reference

  00265	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]

; 1350 : 	{ (*this)[key] = newValue; }

  00268	50		 push	 eax
  00269	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
  0026f	8d 4d e8	 lea	 ecx, DWORD PTR $T11[ebp]
  00272	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00276	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 623  : 		for (int nIdx=0; nIdx<m_arrayAnalIdx.GetSize(); nIdx++)

  0027c	8b 7d dc	 mov	 edi, DWORD PTR _this$1$[ebp]
  0027f	8b 4d e4	 mov	 ecx, DWORD PTR _nIdx$1$[ebp]
  00282	41		 inc	 ecx
  00283	89 4d e4	 mov	 DWORD PTR _nIdx$1$[ebp], ecx
  00286	8b 87 b4 00 00
	00		 mov	 eax, DWORD PTR [edi+180]
  0028c	3b c8		 cmp	 ecx, eax
  0028e	0f 8c 60 fe ff
	ff		 jl	 $LL4@OnBtnAddal
  00294	e9 bc 01 00 00	 jmp	 $LN6@OnBtnAddal
$LN8@OnBtnAddal:

; 630  : 		}
; 631  : 	}
; 632  : 	else if(1 == nCmbCurSel)	// Addition

  00299	83 f8 01	 cmp	 eax, 1
  0029c	0f 85 b3 01 00
	00		 jne	 $LN6@OnBtnAddal

; 634  : 		for (int nIdx=0; nIdx<m_arrayAdditionIdx.GetSize(); nIdx++)

  002a2	8b 87 c8 00 00
	00		 mov	 eax, DWORD PTR [edi+200]
  002a8	33 c9		 xor	 ecx, ecx
  002aa	89 4d e8	 mov	 DWORD PTR _nIdx$1$[ebp], ecx
  002ad	85 c0		 test	 eax, eax
  002af	0f 8e a0 01 00
	00		 jle	 $LN6@OnBtnAddal
$LL7@OnBtnAddal:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 288  : 	if(nIndex >= 0 && nIndex < m_nSize)

  002b5	85 c9		 test	 ecx, ecx
  002b7	0f 88 c1 01 00
	00		 js	 $LN180@OnBtnAddal
  002bd	3b c8		 cmp	 ecx, eax
  002bf	0f 8d b9 01 00
	00		 jge	 $LN180@OnBtnAddal

; 289  : 		return m_pData[nIndex];

  002c5	8b 87 c4 00 00
	00		 mov	 eax, DWORD PTR [edi+196]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 636  : 			nKey = m_arrayAdditionIdx.GetAt(nIdx);

  002cb	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 1555 : 	CAssoc* pAssoc = GetAssocAt(key, nHashBucket, nHashValue);

  002ce	8d 4d cc	 lea	 ecx, DWORD PTR _nHashValue$2[ebp]
  002d1	51		 push	 ecx
  002d2	8d 4d d0	 lea	 ecx, DWORD PTR _nHashBucket$4[ebp]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 636  : 			nKey = m_arrayAdditionIdx.GetAt(nIdx);

  002d5	89 45 ec	 mov	 DWORD PTR _nKey$2$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 1555 : 	CAssoc* pAssoc = GetAssocAt(key, nHashBucket, nHashValue);

  002d8	51		 push	 ecx
  002d9	50		 push	 eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 637  : 			m_mapAdditionList.Lookup(nKey, strFieldName);

  002da	8d 8f 04 01 00
	00		 lea	 ecx, DWORD PTR [edi+260]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 1555 : 	CAssoc* pAssoc = GetAssocAt(key, nHashBucket, nHashValue);

  002e0	e8 00 00 00 00	 call	 ?GetAssocAt@?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@IBEPAVCAssoc@1@HAAI0@Z ; CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >::GetAssocAt

; 1556 : 	if (pAssoc == NULL)

  002e5	85 c0		 test	 eax, eax
  002e7	74 0d		 je	 SHORT $LN127@OnBtnAddal

; 1557 : 		return FALSE;  // not in map
; 1558 : 
; 1559 : 	rValue = pAssoc->value;

  002e9	83 c0 04	 add	 eax, 4
  002ec	8d 4d f0	 lea	 ecx, DWORD PTR _strFieldName$[ebp]
  002ef	50		 push	 eax
  002f0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
$LN127@OnBtnAddal:

; 333  : 	{ INT_PTR nIndex = m_nSize;

  002f6	8d 8f d4 00 00
	00		 lea	 ecx, DWORD PTR [edi+212]
  002fc	8b 79 08	 mov	 edi, DWORD PTR [ecx+8]

; 538  : 	if(nIndex < 0)

  002ff	85 ff		 test	 edi, edi
  00301	0f 88 77 01 00
	00		 js	 $LN180@OnBtnAddal

; 539  : 		AfxThrowInvalidArgException();
; 540  : 
; 541  : 	if (nIndex >= m_nSize)
; 542  : 		SetSize(nIndex+1, -1);

  00307	6a ff		 push	 -1
  00309	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  0030c	50		 push	 eax
  0030d	e8 00 00 00 00	 call	 ?SetSize@?$CArray@HH@@QAEXHH@Z ; CArray<int,int>::SetSize

; 543  : 	m_pData[nIndex] = newElement;

  00312	8b 4d e0	 mov	 ecx, DWORD PTR _this$1$[ebp]
  00315	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00318	8b 4d ec	 mov	 ecx, DWORD PTR _nKey$2$[ebp]
  0031b	89 0c b8	 mov	 DWORD PTR [eax+edi*4], ecx
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 640  : 			m_mapUserList.SetAt(nKey, strFieldName);

  0031e	8d 45 f0	 lea	 eax, DWORD PTR _strFieldName$[ebp]
  00321	50		 push	 eax
  00322	8d 4d e4	 lea	 ecx, DWORD PTR $T10[ebp]
  00325	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 1590 : 	if ((pAssoc = GetAssocAt(key, nHashBucket, nHashValue)) == NULL)

  0032b	8d 45 d4	 lea	 eax, DWORD PTR _nHashValue$6[ebp]

; 1350 : 	{ (*this)[key] = newValue; }

  0032e	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2

; 1590 : 	if ((pAssoc = GetAssocAt(key, nHashBucket, nHashValue)) == NULL)

  00332	50		 push	 eax
  00333	8d 45 d8	 lea	 eax, DWORD PTR _nHashBucket$8[ebp]
  00336	8b ce		 mov	 ecx, esi
  00338	50		 push	 eax
  00339	ff 75 ec	 push	 DWORD PTR _nKey$2$[ebp]
  0033c	e8 00 00 00 00	 call	 ?GetAssocAt@?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@IBEPAVCAssoc@1@HAAI0@Z ; CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >::GetAssocAt
  00341	8b f8		 mov	 edi, eax
  00343	85 ff		 test	 edi, edi
  00345	0f 85 d8 00 00
	00		 jne	 $LN144@OnBtnAddal

; 1591 : 	{
; 1592 : 		if (m_pHashTable == NULL)

  0034b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0034e	85 c0		 test	 eax, eax
  00350	75 4a		 jne	 SHORT $LN207@OnBtnAddal

; 1593 : 			InitHashTable(m_nHashTableSize);

  00352	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]

; 1434 : 		m_pHashTable = new CAssoc* [nHashSize];

  00355	33 c9		 xor	 ecx, ecx
  00357	8b c7		 mov	 eax, edi
  00359	ba 04 00 00 00	 mov	 edx, 4
  0035e	f7 e2		 mul	 edx
  00360	0f 90 c1	 seto	 cl
  00363	f7 d9		 neg	 ecx
  00365	0b c8		 or	 ecx, eax
  00367	51		 push	 ecx
  00368	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  0036d	83 c4 04	 add	 esp, 4
  00370	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 1435 : 		ENSURE(m_pHashTable != NULL);

  00373	85 c0		 test	 eax, eax
  00375	0f 84 03 01 00
	00		 je	 $LN180@OnBtnAddal

; 1436 : 		memset(m_pHashTable, 0, sizeof(CAssoc*) * nHashSize);

  0037b	8d 0c bd 00 00
	00 00		 lea	 ecx, DWORD PTR [edi*4]
  00382	51		 push	 ecx
  00383	6a 00		 push	 0
  00385	50		 push	 eax
  00386	e8 00 00 00 00	 call	 _memset

; 1437 : 	}
; 1438 : 	m_nHashTableSize = nHashSize;

  0038b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0038e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00391	89 7e 08	 mov	 DWORD PTR [esi+8], edi

; 1595 : 		ENSURE(m_pHashTable);

  00394	85 c0		 test	 eax, eax
  00396	0f 84 e2 00 00
	00		 je	 $LN180@OnBtnAddal
$LN207@OnBtnAddal:

; 1481 : 	if (m_pFreeList == NULL)

  0039c	83 7e 10 00	 cmp	 DWORD PTR [esi+16], 0
  003a0	75 31		 jne	 SHORT $LN163@OnBtnAddal

; 1482 : 	{
; 1483 : 		// add another block
; 1484 : 		CPlex* newBlock = CPlex::Create(m_pBlocks, m_nBlockSize, sizeof(CMap::CAssoc));

  003a2	6a 10		 push	 16			; 00000010H
  003a4	ff 76 18	 push	 DWORD PTR [esi+24]
  003a7	8d 46 14	 lea	 eax, DWORD PTR [esi+20]
  003aa	50		 push	 eax
  003ab	e8 00 00 00 00	 call	 ?Create@CPlex@@SGPAU1@AAPAU1@II@Z ; CPlex::Create

; 1485 : 		// chain them into free list
; 1486 : 		CMap::CAssoc* pAssoc = (CMap::CAssoc*) newBlock->data();
; 1487 : 		// free in reverse order to make it easier to debug
; 1488 : 		pAssoc += m_nBlockSize - 1;

  003b0	8b 56 18	 mov	 edx, DWORD PTR [esi+24]
  003b3	8b ca		 mov	 ecx, edx
  003b5	c1 e1 04	 shl	 ecx, 4
  003b8	83 c1 f8	 add	 ecx, -8			; fffffff8H
  003bb	03 c8		 add	 ecx, eax

; 1489 : 		for (INT_PTR i = m_nBlockSize-1; i >= 0; i--, pAssoc--)

  003bd	83 c2 ff	 add	 edx, -1
  003c0	78 11		 js	 SHORT $LN163@OnBtnAddal
$LL160@OnBtnAddal:

; 1490 : 		{
; 1491 : 			pAssoc->pNext = m_pFreeList;

  003c2	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  003c5	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1492 : 			m_pFreeList = pAssoc;

  003c8	89 4e 10	 mov	 DWORD PTR [esi+16], ecx
  003cb	83 e9 10	 sub	 ecx, 16			; 00000010H
  003ce	83 ea 01	 sub	 edx, 1
  003d1	79 ef		 jns	 SHORT $LL160@OnBtnAddal
$LN163@OnBtnAddal:

; 1493 : 		}
; 1494 : 	}
; 1495 : 	ENSURE(m_pFreeList != NULL);  // we must have something

  003d3	8b 7e 10	 mov	 edi, DWORD PTR [esi+16]
  003d6	85 ff		 test	 edi, edi
  003d8	0f 84 a0 00 00
	00		 je	 $LN180@OnBtnAddal

; 1496 : 
; 1497 : 	CMap::CAssoc* pAssoc = m_pFreeList;
; 1498 : 
; 1499 : 	// zero the memory
; 1500 : 	CMap::CAssoc* pTemp = pAssoc->pNext;

  003de	8b 47 08	 mov	 eax, DWORD PTR [edi+8]

; 1256 : 		CPair( ARG_KEY keyval ) : key( keyval )	{}

  003e1	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  003e4	0f 57 c0	 xorps	 xmm0, xmm0

; 1501 : 	memset( pAssoc, 0, sizeof(CMap::CAssoc) );

  003e7	0f 11 07	 movups	 XMMWORD PTR [edi], xmm0

; 1502 : 	pAssoc->pNext = pTemp;

  003ea	89 47 08	 mov	 DWORD PTR [edi+8], eax

; 1503 : 
; 1504 : 	m_pFreeList = m_pFreeList->pNext;

  003ed	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  003f0	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 1505 : 	m_nCount++;

  003f3	ff 46 0c	 inc	 DWORD PTR [esi+12]
  003f6	89 46 10	 mov	 DWORD PTR [esi+16], eax

; 1256 : 		CPair( ARG_KEY keyval ) : key( keyval )	{}

  003f9	8b 45 ec	 mov	 eax, DWORD PTR _nKey$2$[ebp]
  003fc	89 07		 mov	 DWORD PTR [edi], eax
  003fe	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 1598 : 		pAssoc->nHashValue = nHashValue;

  00404	8b 45 d4	 mov	 eax, DWORD PTR _nHashValue$6[ebp]
  00407	89 47 0c	 mov	 DWORD PTR [edi+12], eax

; 1599 : 		//'pAssoc->value' is a constructed object, nothing more
; 1600 : 
; 1601 : 		// put into hash table
; 1602 : 		pAssoc->pNext = m_pHashTable[nHashBucket];

  0040a	8b 45 d8	 mov	 eax, DWORD PTR _nHashBucket$8[ebp]
  0040d	8d 0c 85 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*4]
  00414	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00417	8b 04 01	 mov	 eax, DWORD PTR [ecx+eax]
  0041a	89 47 08	 mov	 DWORD PTR [edi+8], eax

; 1603 : 		m_pHashTable[nHashBucket] = pAssoc;

  0041d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00420	89 3c 01	 mov	 DWORD PTR [ecx+eax], edi
$LN144@OnBtnAddal:

; 1350 : 	{ (*this)[key] = newValue; }

  00423	8d 45 e4	 lea	 eax, DWORD PTR $T10[ebp]

; 1605 : 	return pAssoc->value;  // return new reference

  00426	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]

; 1350 : 	{ (*this)[key] = newValue; }

  00429	50		 push	 eax
  0042a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
  00430	8d 4d e4	 lea	 ecx, DWORD PTR $T10[ebp]
  00433	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00437	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 634  : 		for (int nIdx=0; nIdx<m_arrayAdditionIdx.GetSize(); nIdx++)

  0043d	8b 7d dc	 mov	 edi, DWORD PTR _this$1$[ebp]
  00440	8b 4d e8	 mov	 ecx, DWORD PTR _nIdx$1$[ebp]
  00443	41		 inc	 ecx
  00444	89 4d e8	 mov	 DWORD PTR _nIdx$1$[ebp], ecx
  00447	8b 87 c8 00 00
	00		 mov	 eax, DWORD PTR [edi+200]
  0044d	3b c8		 cmp	 ecx, eax
  0044f	0f 8c 60 fe ff
	ff		 jl	 $LL7@OnBtnAddal
$LN6@OnBtnAddal:

; 641  : 		}
; 642  : 	}	
; 643  : 
; 644  : 	FillShowList(m_arrayUserIdx, m_mapUserList);

  00455	56		 push	 esi
  00456	8d 87 d4 00 00
	00		 lea	 eax, DWORD PTR [edi+212]
  0045c	8b cf		 mov	 ecx, edi
  0045e	50		 push	 eax
  0045f	e8 00 00 00 00	 call	 ?FillShowList@CDlgSettingToolBar@@AAEXAAV?$CArray@HH@@AAV?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@@Z ; CDlgSettingToolBar::FillShowList

; 645  : }

  00464	8d 4d f0	 lea	 ecx, DWORD PTR _strFieldName$[ebp]
  00467	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0046d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00470	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00477	59		 pop	 ecx
  00478	5f		 pop	 edi
  00479	5e		 pop	 esi
  0047a	8b e5		 mov	 esp, ebp
  0047c	5d		 pop	 ebp
  0047d	c3		 ret	 0
$LN180@OnBtnAddal:
  0047e	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN203@OnBtnAddal:
  00483	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?OnBtnAddall@CDlgSettingToolBar@@IAEXXZ$0:
  00000	8d 4d f0	 lea	 ecx, DWORD PTR _strFieldName$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?OnBtnAddall@CDlgSettingToolBar@@IAEXXZ$4:
  00009	8d 4d e8	 lea	 ecx, DWORD PTR $T11[ebp]
  0000c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?OnBtnAddall@CDlgSettingToolBar@@IAEXXZ$5:
  00012	8d 4d e4	 lea	 ecx, DWORD PTR $T10[ebp]
  00015	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0001b	cc		 int	 3
  0001c	cc		 int	 3
  0001d	cc		 int	 3
  0001e	cc		 int	 3
  0001f	cc		 int	 3
__ehhandler$?OnBtnAddall@CDlgSettingToolBar@@IAEXXZ:
  00020	90		 npad	 1
  00021	90		 npad	 1
  00022	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00026	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00029	8b 4a cc	 mov	 ecx, DWORD PTR [edx-52]
  0002c	33 c8		 xor	 ecx, eax
  0002e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00033	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?OnBtnAddall@CDlgSettingToolBar@@IAEXXZ
  00038	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?OnBtnAddall@CDlgSettingToolBar@@IAEXXZ ENDP		; CDlgSettingToolBar::OnBtnAddall
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
;	COMDAT ?OnBtnRemoveall@CDlgSettingToolBar@@IAEXXZ
_TEXT	SEGMENT
_nIndex$1$ = -4						; size = 4
?OnBtnRemoveall@CDlgSettingToolBar@@IAEXXZ PROC		; CDlgSettingToolBar::OnBtnRemoveall, COMDAT
; _this$ = ecx

; 480  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	8b f1		 mov	 esi, ecx
  00008	57		 push	 edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 381  : 		if (m_pData != NULL)

  00009	8b 86 d8 00 00
	00		 mov	 eax, DWORD PTR [esi+216]
  0000f	85 c0		 test	 eax, eax
  00011	74 13		 je	 SHORT $LN26@OnBtnRemov

; 382  : 		{
; 383  : 			for( int i = 0; i < m_nSize; i++ )
; 384  : 				(m_pData + i)->~TYPE();
; 385  : 			delete[] (BYTE*)m_pData;

  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00019	83 c4 04	 add	 esp, 4

; 386  : 			m_pData = NULL;

  0001c	c7 86 d8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+216], 0
$LN26@OnBtnRemov:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 482  : 	m_mapUserList.RemoveAll();

  00026	8d 9e 20 01 00
	00		 lea	 ebx, DWORD PTR [esi+288]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 388  : 		m_nSize = m_nMaxSize = 0;

  0002c	c7 86 e0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+224], 0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 482  : 	m_mapUserList.RemoveAll();

  00036	8b cb		 mov	 ecx, ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 388  : 		m_nSize = m_nMaxSize = 0;

  00038	c7 86 dc 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+220], 0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 482  : 	m_mapUserList.RemoveAll();

  00042	e8 00 00 00 00	 call	 ?RemoveAll@?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@QAEXXZ ; CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >::RemoveAll
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 333  : 	{ INT_PTR nIndex = m_nSize;

  00047	8b 86 dc 00 00
	00		 mov	 eax, DWORD PTR [esi+220]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 484  : 	m_arrayUserIdx.Add(CHART_TOOL);	//

  0004d	8d be d4 00 00
	00		 lea	 edi, DWORD PTR [esi+212]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 333  : 	{ INT_PTR nIndex = m_nSize;

  00053	89 45 fc	 mov	 DWORD PTR _nIndex$1$[ebp], eax

; 538  : 	if(nIndex < 0)

  00056	85 c0		 test	 eax, eax
  00058	78 3f		 js	 SHORT $LN68@OnBtnRemov

; 540  : 
; 541  : 	if (nIndex >= m_nSize)
; 542  : 		SetSize(nIndex+1, -1);

  0005a	6a ff		 push	 -1
  0005c	40		 inc	 eax
  0005d	8b cf		 mov	 ecx, edi
  0005f	50		 push	 eax
  00060	e8 00 00 00 00	 call	 ?SetSize@?$CArray@HH@@QAEXHH@Z ; CArray<int,int>::SetSize

; 543  : 	m_pData[nIndex] = newElement;

  00065	8b 4d fc	 mov	 ecx, DWORD PTR _nIndex$1$[ebp]
  00068	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 485  : 	m_mapUserList.SetAt(CHART_TOOL, "");

  0006b	51		 push	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 543  : 	m_pData[nIndex] = newElement;

  0006c	c7 04 88 03 00
	00 00		 mov	 DWORD PTR [eax+ecx*4], 3
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 485  : 	m_mapUserList.SetAt(CHART_TOOL, "");

  00073	8b cc		 mov	 ecx, esp
  00075	68 00 00 00 00	 push	 OFFSET ??_C@_0L@PPOMAPHP@?B?w?F?$KO?E?x?F?m?A?$PN@
  0007a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  00080	6a 03		 push	 3
  00082	8b cb		 mov	 ecx, ebx
  00084	e8 00 00 00 00	 call	 ?SetAt@?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@QAEXHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ; CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >::SetAt

; 486  : 
; 487  : 	FillShowList(m_arrayUserIdx, m_mapUserList);

  00089	53		 push	 ebx
  0008a	57		 push	 edi
  0008b	8b ce		 mov	 ecx, esi
  0008d	e8 00 00 00 00	 call	 ?FillShowList@CDlgSettingToolBar@@AAEXAAV?$CArray@HH@@AAV?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@@Z ; CDlgSettingToolBar::FillShowList

; 488  : }

  00092	5f		 pop	 edi
  00093	5e		 pop	 esi
  00094	5b		 pop	 ebx
  00095	8b e5		 mov	 esp, ebp
  00097	5d		 pop	 ebp
  00098	c3		 ret	 0
$LN68@OnBtnRemov:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 539  : 		AfxThrowInvalidArgException();

  00099	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN66@OnBtnRemov:
  0009e	cc		 int	 3
?OnBtnRemoveall@CDlgSettingToolBar@@IAEXXZ ENDP		; CDlgSettingToolBar::OnBtnRemoveall
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
;	COMDAT ?OnBtnRemove@CDlgSettingToolBar@@IAEXXZ
_TEXT	SEGMENT
tv383 = -12						; size = 4
_nKey$1$ = -8						; size = 4
tv377 = -4						; size = 4
?OnBtnRemove@CDlgSettingToolBar@@IAEXXZ PROC		; CDlgSettingToolBar::OnBtnRemove, COMDAT
; _this$ = ecx

; 458  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx
  00007	57		 push	 edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl

; 666  : 	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_GETCURSEL, 0, 0); }

  00008	6a 00		 push	 0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 458  : {

  0000a	8b d9		 mov	 ebx, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl

; 666  : 	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_GETCURSEL, 0, 0); }

  0000c	6a 00		 push	 0
  0000e	68 88 01 00 00	 push	 392			; 00000188H
  00013	ff b3 68 01 00
	00		 push	 DWORD PTR [ebx+360]
  00019	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 459  : 	int nCurSel = m_listShow.GetCurSel();

  0001f	8b f8		 mov	 edi, eax

; 460  : 	if(nCurSel < 0) return;

  00021	85 ff		 test	 edi, edi
  00023	78 2d		 js	 SHORT $LN1@OnBtnRemov
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 288  : 	if(nIndex >= 0 && nIndex < m_nSize)

  00025	3b bb dc 00 00
	00		 cmp	 edi, DWORD PTR [ebx+220]
  0002b	0f 8d 08 01 00
	00		 jge	 $LN10@OnBtnRemov
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 461  : 	int nKey = m_arrayUserIdx.GetAt(nCurSel);

  00031	8b 8b d8 00 00
	00		 mov	 ecx, DWORD PTR [ebx+216]
  00037	56		 push	 esi
  00038	8b 34 b9	 mov	 esi, DWORD PTR [ecx+edi*4]
  0003b	89 75 f8	 mov	 DWORD PTR _nKey$1$[ebp], esi

; 462  : 
; 463  : 	if(3 == nKey)		// 

  0003e	83 fe 03	 cmp	 esi, 3
  00041	75 15		 jne	 SHORT $LN3@OnBtnRemov

; 464  : 	{
; 465  : 		AfxMessageBox("    .");

  00043	6a 00		 push	 0
  00045	6a 00		 push	 0
  00047	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@JNNFKBLA@?G?X?$LE?g?5?G?W?$LI?q?$MA?$LK?5?$LL?h?A?$KG?G?R?5?$LM?v?5?$LO?x?$LN?$MA?$LE?O?$LE?Y?4@
  0004c	e8 00 00 00 00	 call	 ?AfxMessageBox@@YGHPBDII@Z ; AfxMessageBox
  00051	5e		 pop	 esi
$LN1@OnBtnRemov:

; 477  : }

  00052	5f		 pop	 edi
  00053	5b		 pop	 ebx
  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
$LN3@OnBtnRemov:

; 466  : 		return;
; 467  : 	}
; 468  : 	m_arrayUserIdx.RemoveAt(nCurSel);

  00058	6a 01		 push	 1
  0005a	57		 push	 edi
  0005b	8d 8b d4 00 00
	00		 lea	 ecx, DWORD PTR [ebx+212]
  00061	e8 00 00 00 00	 call	 ?RemoveAt@?$CArray@HH@@QAEXHH@Z ; CArray<int,int>::RemoveAt
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 1614 : 	if (m_pHashTable == NULL)

  00066	8b 83 24 01 00
	00		 mov	 eax, DWORD PTR [ebx+292]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 469  : 	m_mapUserList.RemoveKey(nKey);

  0006c	8d 8b 20 01 00
	00		 lea	 ecx, DWORD PTR [ebx+288]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 1614 : 	if (m_pHashTable == NULL)

  00072	89 45 fc	 mov	 DWORD PTR tv377[ebp], eax
  00075	85 c0		 test	 eax, eax
  00077	0f 84 88 00 00
	00		 je	 $LN49@OnBtnRemov

; 165  : 	ldiv_t HashVal = ldiv((long)(ARG_KEY)key, 127773);

  0007d	8b c6		 mov	 eax, esi
  0007f	b9 1d f3 01 00	 mov	 ecx, 127773		; 0001f31dH
  00084	99		 cdq
  00085	f7 f9		 idiv	 ecx

; 166  : 	HashVal.rem = 16807 * HashVal.rem - 2836 * HashVal.quot;

  00087	69 c0 14 0b 00
	00		 imul	 eax, eax, 2836
  0008d	69 ca a7 41 00
	00		 imul	 ecx, edx, 16807
  00093	2b c8		 sub	 ecx, eax

; 1620 : 	ppAssocPrev = &m_pHashTable[nHashValue%m_nHashTableSize];

  00095	8d 81 ff ff ff
	7f		 lea	 eax, DWORD PTR [ecx+2147483647]
  0009b	0f 49 c1	 cmovns	 eax, ecx
  0009e	33 d2		 xor	 edx, edx
  000a0	89 45 f4	 mov	 DWORD PTR tv383[ebp], eax
  000a3	f7 b3 28 01 00
	00		 div	 DWORD PTR [ebx+296]
  000a9	8b 45 fc	 mov	 eax, DWORD PTR tv377[ebp]

; 1621 : 
; 1622 : 	CAssoc* pAssoc;
; 1623 : 	for (pAssoc = *ppAssocPrev; pAssoc != NULL; pAssoc = pAssoc->pNext)

  000ac	8b 34 90	 mov	 esi, DWORD PTR [eax+edx*4]
  000af	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
  000b2	85 f6		 test	 esi, esi
  000b4	74 49		 je	 SHORT $LN51@OnBtnRemov
  000b6	8b 45 f8	 mov	 eax, DWORD PTR _nKey$1$[ebp]
  000b9	8b 55 f4	 mov	 edx, DWORD PTR tv383[ebp]
  000bc	0f 1f 40 00	 npad	 4
$LL16@OnBtnRemov:

; 1624 : 	{
; 1625 : 		if ((pAssoc->nHashValue == nHashValue) && CompareElements(&pAssoc->key, &key))

  000c0	39 56 0c	 cmp	 DWORD PTR [esi+12], edx
  000c3	75 04		 jne	 SHORT $LN18@OnBtnRemov

; 156  : 	return *pElement1 == *pElement2;

  000c5	39 06		 cmp	 DWORD PTR [esi], eax

; 1625 : 		if ((pAssoc->nHashValue == nHashValue) && CompareElements(&pAssoc->key, &key))

  000c7	74 0b		 je	 SHORT $LN45@OnBtnRemov
$LN18@OnBtnRemov:

; 1629 : 			FreeAssoc(pAssoc);
; 1630 : 			return TRUE;
; 1631 : 		}
; 1632 : 		ppAssocPrev = &pAssoc->pNext;

  000c9	8d 4e 08	 lea	 ecx, DWORD PTR [esi+8]
  000cc	8b 31		 mov	 esi, DWORD PTR [ecx]
  000ce	85 f6		 test	 esi, esi
  000d0	75 ee		 jne	 SHORT $LL16@OnBtnRemov

; 1621 : 
; 1622 : 	CAssoc* pAssoc;
; 1623 : 	for (pAssoc = *ppAssocPrev; pAssoc != NULL; pAssoc = pAssoc->pNext)

  000d2	eb 2b		 jmp	 SHORT $LN51@OnBtnRemov
$LN45@OnBtnRemov:

; 1626 : 		{
; 1627 : 			// remove it
; 1628 : 			*ppAssocPrev = pAssoc->pNext;  // remove from list

  000d4	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000d7	89 01		 mov	 DWORD PTR [ecx], eax
  000d9	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  000dc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 1518 : 	pAssoc->pNext = m_pFreeList;

  000e2	8b 83 30 01 00
	00		 mov	 eax, DWORD PTR [ebx+304]
  000e8	8d 8b 20 01 00
	00		 lea	 ecx, DWORD PTR [ebx+288]
  000ee	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 1519 : 	m_pFreeList = pAssoc;
; 1520 : 	m_nCount--;

  000f1	83 41 0c ff	 add	 DWORD PTR [ecx+12], -1
  000f5	89 71 10	 mov	 DWORD PTR [ecx+16], esi

; 1521 : 	ASSERT(m_nCount >= 0);  // make sure we don't underflow
; 1522 : 
; 1523 : 	// if no more elements, cleanup completely
; 1524 : 	if (m_nCount == 0)

  000f8	75 0b		 jne	 SHORT $LN49@OnBtnRemov

; 1525 : 		RemoveAll();

  000fa	e8 00 00 00 00	 call	 ?RemoveAll@?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@QAEXXZ ; CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >::RemoveAll
$LN51@OnBtnRemov:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 471  : 	FillShowList(m_arrayUserIdx, m_mapUserList);

  000ff	8d 8b 20 01 00
	00		 lea	 ecx, DWORD PTR [ebx+288]
$LN49@OnBtnRemov:
  00105	51		 push	 ecx
  00106	8d 83 d4 00 00
	00		 lea	 eax, DWORD PTR [ebx+212]
  0010c	8b cb		 mov	 ecx, ebx
  0010e	50		 push	 eax
  0010f	e8 00 00 00 00	 call	 ?FillShowList@CDlgSettingToolBar@@AAEXAAV?$CArray@HH@@AAV?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@@Z ; CDlgSettingToolBar::FillShowList

; 472  : 	if(nCurSel < 1)

  00114	83 ff 01	 cmp	 edi, 1
  00117	7d 04		 jge	 SHORT $LN4@OnBtnRemov

; 473  : 		nCurSel = 0;

  00119	33 ff		 xor	 edi, edi
  0011b	eb 01		 jmp	 SHORT $LN5@OnBtnRemov
$LN4@OnBtnRemov:

; 474  : 	else
; 475  : 		nCurSel--;

  0011d	4f		 dec	 edi
$LN5@OnBtnRemov:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl

; 668  : 	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_SETCURSEL, nSelect, 0); }

  0011e	6a 00		 push	 0
  00120	57		 push	 edi
  00121	68 86 01 00 00	 push	 390			; 00000186H
  00126	ff b3 68 01 00
	00		 push	 DWORD PTR [ebx+360]
  0012c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16
  00132	5e		 pop	 esi
  00133	5f		 pop	 edi
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 477  : }

  00134	5b		 pop	 ebx
  00135	8b e5		 mov	 esp, ebp
  00137	5d		 pop	 ebp
  00138	c3		 ret	 0
$LN10@OnBtnRemov:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 290  : 	AfxThrowInvalidArgException();

  00139	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN53@OnBtnRemov:
  0013e	cc		 int	 3
?OnBtnRemove@CDlgSettingToolBar@@IAEXXZ ENDP		; CDlgSettingToolBar::OnBtnRemove
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
;	COMDAT ?OnBtnMovsyp@CDlgSettingToolBar@@IAEXXZ
_TEXT	SEGMENT
?OnBtnMovsyp@CDlgSettingToolBar@@IAEXXZ PROC		; CDlgSettingToolBar::OnBtnMovsyp, COMDAT
; _this$ = ecx

; 566  : {

  00000	53		 push	 ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl

; 765  : 	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, CB_GETCURSEL, 0, 0); }

  00001	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__SendMessageA@16
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 566  : {

  00007	56		 push	 esi
  00008	57		 push	 edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl

; 765  : 	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, CB_GETCURSEL, 0, 0); }

  00009	6a 00		 push	 0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 566  : {

  0000b	8b f9		 mov	 edi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl

; 765  : 	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, CB_GETCURSEL, 0, 0); }

  0000d	6a 00		 push	 0
  0000f	68 47 01 00 00	 push	 327			; 00000147H
  00014	ff b7 68 02 00
	00		 push	 DWORD PTR [edi+616]
  0001a	ff d3		 call	 ebx

; 666  : 	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_GETCURSEL, 0, 0); }

  0001c	6a 00		 push	 0
  0001e	6a 00		 push	 0
  00020	68 88 01 00 00	 push	 392			; 00000188H
  00025	ff b7 68 01 00
	00		 push	 DWORD PTR [edi+360]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 569  : 	int nCurSel = m_cmbShow.GetCurSel();

  0002b	8b f0		 mov	 esi, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl

; 666  : 	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_GETCURSEL, 0, 0); }

  0002d	ff d3		 call	 ebx
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 570  : 	int nSelected = m_listShow.GetCurSel();

  0002f	8b d8		 mov	 ebx, eax

; 571  : 	if(nSelected < 1) return;

  00031	83 fb 01	 cmp	 ebx, 1
  00034	0f 8c 8e 00 00
	00		 jl	 $LN9@OnBtnMovsy

; 572  : 	if(0 == nCurSel && 1 == nSelected) 

  0003a	85 f6		 test	 esi, esi
  0003c	75 19		 jne	 SHORT $LN5@OnBtnMovsy
  0003e	83 fb 01	 cmp	 ebx, 1
  00041	0f 85 c0 00 00
	00		 jne	 $LN6@OnBtnMovsy

; 573  : 	{
; 574  : 		AfxMessageBox("   .");

  00047	56		 push	 esi
  00048	56		 push	 esi
  00049	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@NGMPOBLI@?$LE?u?$MA?L?$LL?s?5?$MA?L?$LF?$LP?G?R?5?$LM?v?5?$LO?x?$LN?$MA?$LE?O?$LE?Y?4@
  0004e	e8 00 00 00 00	 call	 ?AfxMessageBox@@YGHPBDII@Z ; AfxMessageBox
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl

; 668  : 	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_SETCURSEL, nSelect, 0); }

  00053	56		 push	 esi
  00054	53		 push	 ebx
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 576  : 		return;

  00055	eb 5f		 jmp	 SHORT $LN34@OnBtnMovsy
$LN5@OnBtnMovsy:

; 577  : 	}
; 578  : 
; 579  : 	switch(nCurSel)

  00057	83 ee 00	 sub	 esi, 0
  0005a	0f 84 a7 00 00
	00		 je	 $LN6@OnBtnMovsy
  00060	83 ee 01	 sub	 esi, 1
  00063	74 67		 je	 SHORT $LN7@OnBtnMovsy
  00065	83 ee 01	 sub	 esi, 1
  00068	75 5e		 jne	 SHORT $LN9@OnBtnMovsy

; 595  : 	case 2:		//
; 596  : 		nSelectedKey = m_arrayAdditionIdx.GetAt(nSelected);

  0006a	8d 8f c0 00 00
	00		 lea	 ecx, DWORD PTR [edi+192]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 288  : 	if(nIndex >= 0 && nIndex < m_nSize)

  00070	3b 9f c8 00 00
	00		 cmp	 ebx, DWORD PTR [edi+200]
  00076	0f 8d c9 00 00
	00		 jge	 $LN18@OnBtnMovsy
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 597  : 		m_arrayAdditionIdx.RemoveAt(nSelected);

  0007c	8b 87 c4 00 00
	00		 mov	 eax, DWORD PTR [edi+196]
  00082	6a 01		 push	 1
  00084	53		 push	 ebx
  00085	8b 34 98	 mov	 esi, DWORD PTR [eax+ebx*4]
  00088	e8 00 00 00 00	 call	 ?RemoveAt@?$CArray@HH@@QAEXHH@Z ; CArray<int,int>::RemoveAt

; 598  : 		m_arrayAdditionIdx.InsertAt(nSelected-1, nSelectedKey);

  0008d	6a 01		 push	 1
  0008f	56		 push	 esi
  00090	8d 43 ff	 lea	 eax, DWORD PTR [ebx-1]
  00093	8d b7 c0 00 00
	00		 lea	 esi, DWORD PTR [edi+192]
  00099	50		 push	 eax
  0009a	8b ce		 mov	 ecx, esi
  0009c	e8 00 00 00 00	 call	 ?InsertAt@?$CArray@HH@@QAEXHHH@Z ; CArray<int,int>::InsertAt

; 599  : 		FillShowList(m_arrayAdditionIdx, m_mapAdditionList);

  000a1	8d 87 04 01 00
	00		 lea	 eax, DWORD PTR [edi+260]
$LN35@OnBtnMovsy:

; 605  : }

  000a7	50		 push	 eax
  000a8	56		 push	 esi
  000a9	8b cf		 mov	 ecx, edi
  000ab	e8 00 00 00 00	 call	 ?FillShowList@CDlgSettingToolBar@@AAEXAAV?$CArray@HH@@AAV?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@@Z ; CDlgSettingToolBar::FillShowList
  000b0	6a 00		 push	 0
  000b2	8d 43 ff	 lea	 eax, DWORD PTR [ebx-1]
  000b5	50		 push	 eax
$LN34@OnBtnMovsy:
  000b6	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__SendMessageA@16
  000bb	68 86 01 00 00	 push	 390			; 00000186H
  000c0	ff b7 68 01 00
	00		 push	 DWORD PTR [edi+360]
  000c6	ff d0		 call	 eax
$LN9@OnBtnMovsy:
  000c8	5f		 pop	 edi
  000c9	5e		 pop	 esi
  000ca	5b		 pop	 ebx
  000cb	c3		 ret	 0
$LN7@OnBtnMovsy:

; 586  : 		m_listShow.SetCurSel(nSelected-1);
; 587  : 		break;
; 588  : 	case 1:		// 
; 589  : 		nSelectedKey = m_arrayAnalIdx.GetAt(nSelected);

  000cc	8d 8f ac 00 00
	00		 lea	 ecx, DWORD PTR [edi+172]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 288  : 	if(nIndex >= 0 && nIndex < m_nSize)

  000d2	3b 9f b4 00 00
	00		 cmp	 ebx, DWORD PTR [edi+180]
  000d8	7d 6b		 jge	 SHORT $LN18@OnBtnMovsy
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 590  : 		m_arrayAnalIdx.RemoveAt(nSelected);

  000da	8b 87 b0 00 00
	00		 mov	 eax, DWORD PTR [edi+176]
  000e0	6a 01		 push	 1
  000e2	53		 push	 ebx
  000e3	8b 34 98	 mov	 esi, DWORD PTR [eax+ebx*4]
  000e6	e8 00 00 00 00	 call	 ?RemoveAt@?$CArray@HH@@QAEXHH@Z ; CArray<int,int>::RemoveAt

; 591  : 		m_arrayAnalIdx.InsertAt(nSelected-1, nSelectedKey);

  000eb	6a 01		 push	 1
  000ed	56		 push	 esi
  000ee	8d 43 ff	 lea	 eax, DWORD PTR [ebx-1]
  000f1	8d b7 ac 00 00
	00		 lea	 esi, DWORD PTR [edi+172]
  000f7	50		 push	 eax
  000f8	8b ce		 mov	 ecx, esi
  000fa	e8 00 00 00 00	 call	 ?InsertAt@?$CArray@HH@@QAEXHHH@Z ; CArray<int,int>::InsertAt

; 592  : 		FillShowList(m_arrayAnalIdx, m_mapAnalList);

  000ff	8d 87 e8 00 00
	00		 lea	 eax, DWORD PTR [edi+232]

; 593  : 		m_listShow.SetCurSel(nSelected-1);
; 594  : 		break;

  00105	eb a0		 jmp	 SHORT $LN35@OnBtnMovsy
$LN6@OnBtnMovsy:

; 580  : 	{
; 581  : 	case 0:		// 
; 582  : 		nSelectedKey = m_arrayUserIdx.GetAt(nSelected);

  00107	8d 8f d4 00 00
	00		 lea	 ecx, DWORD PTR [edi+212]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 288  : 	if(nIndex >= 0 && nIndex < m_nSize)

  0010d	3b 9f dc 00 00
	00		 cmp	 ebx, DWORD PTR [edi+220]
  00113	7d 30		 jge	 SHORT $LN18@OnBtnMovsy
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 583  : 		m_arrayUserIdx.RemoveAt(nSelected);

  00115	8b 87 d8 00 00
	00		 mov	 eax, DWORD PTR [edi+216]
  0011b	6a 01		 push	 1
  0011d	53		 push	 ebx
  0011e	8b 34 98	 mov	 esi, DWORD PTR [eax+ebx*4]
  00121	e8 00 00 00 00	 call	 ?RemoveAt@?$CArray@HH@@QAEXHH@Z ; CArray<int,int>::RemoveAt

; 584  : 		m_arrayUserIdx.InsertAt(nSelected-1, nSelectedKey);

  00126	6a 01		 push	 1
  00128	56		 push	 esi
  00129	8d 43 ff	 lea	 eax, DWORD PTR [ebx-1]
  0012c	8d b7 d4 00 00
	00		 lea	 esi, DWORD PTR [edi+212]
  00132	50		 push	 eax
  00133	8b ce		 mov	 ecx, esi
  00135	e8 00 00 00 00	 call	 ?InsertAt@?$CArray@HH@@QAEXHHH@Z ; CArray<int,int>::InsertAt

; 585  : 		FillShowList(m_arrayUserIdx, m_mapUserList);

  0013a	8d 87 20 01 00
	00		 lea	 eax, DWORD PTR [edi+288]

; 605  : }

  00140	e9 62 ff ff ff	 jmp	 $LN35@OnBtnMovsy
$LN18@OnBtnMovsy:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 290  : 	AfxThrowInvalidArgException();

  00145	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN33@OnBtnMovsy:
  0014a	cc		 int	 3
?OnBtnMovsyp@CDlgSettingToolBar@@IAEXXZ ENDP		; CDlgSettingToolBar::OnBtnMovsyp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
;	COMDAT ?OnBtnMovedown@CDlgSettingToolBar@@IAEXXZ
_TEXT	SEGMENT
_this$1$ = -8						; size = 4
_nSelected$1$ = -4					; size = 4
?OnBtnMovedown@CDlgSettingToolBar@@IAEXXZ PROC		; CDlgSettingToolBar::OnBtnMovedown, COMDAT
; _this$ = ecx

; 520  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl

; 765  : 	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, CB_GETCURSEL, 0, 0); }

  00007	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__SendMessageA@16
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 520  : {

  0000d	56		 push	 esi
  0000e	57		 push	 edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl

; 765  : 	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, CB_GETCURSEL, 0, 0); }

  0000f	6a 00		 push	 0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 520  : {

  00011	8b f9		 mov	 edi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl

; 765  : 	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, CB_GETCURSEL, 0, 0); }

  00013	6a 00		 push	 0
  00015	68 47 01 00 00	 push	 327			; 00000147H
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 520  : {

  0001a	89 7d f8	 mov	 DWORD PTR _this$1$[ebp], edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl

; 765  : 	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, CB_GETCURSEL, 0, 0); }

  0001d	ff b7 68 02 00
	00		 push	 DWORD PTR [edi+616]
  00023	ff d3		 call	 ebx

; 666  : 	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_GETCURSEL, 0, 0); }

  00025	6a 00		 push	 0
  00027	6a 00		 push	 0
  00029	68 88 01 00 00	 push	 392			; 00000188H
  0002e	ff b7 68 01 00
	00		 push	 DWORD PTR [edi+360]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 523  : 	int nCurSel = m_cmbShow.GetCurSel();

  00034	8b f0		 mov	 esi, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl

; 666  : 	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_GETCURSEL, 0, 0); }

  00036	ff d3		 call	 ebx
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 524  : 	int nSelected = m_listShow.GetCurSel();

  00038	8b d8		 mov	 ebx, eax
  0003a	89 5d fc	 mov	 DWORD PTR _nSelected$1$[ebp], ebx

; 525  : 	if( nSelected < 0 || 

  0003d	85 db		 test	 ebx, ebx
  0003f	0f 88 18 01 00
	00		 js	 $LN5@OnBtnMoved
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl

; 664  : 	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_GETCOUNT, 0, 0); }

  00045	6a 00		 push	 0
  00047	6a 00		 push	 0
  00049	68 8b 01 00 00	 push	 395			; 0000018bH
  0004e	ff b7 68 01 00
	00		 push	 DWORD PTR [edi+360]
  00054	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 525  : 	if( nSelected < 0 || 

  0005a	48		 dec	 eax
  0005b	3b d8		 cmp	 ebx, eax
  0005d	0f 8d fa 00 00
	00		 jge	 $LN5@OnBtnMoved

; 526  : 	    nSelected >= m_listShow.GetCount()-1)	
; 527  : 	   return;
; 528  : 
; 529  : 	if(0 == nCurSel && 0 == nSelected)

  00063	85 f6		 test	 esi, esi
  00065	75 2f		 jne	 SHORT $LN6@OnBtnMoved
  00067	85 db		 test	 ebx, ebx
  00069	0f 85 a0 00 00
	00		 jne	 $LN7@OnBtnMoved

; 530  : 	{
; 531  : 		AfxMessageBox("   .");

  0006f	56		 push	 esi
  00070	56		 push	 esi
  00071	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@NGMPOBLI@?$LE?u?$MA?L?$LL?s?5?$MA?L?$LF?$LP?G?R?5?$LM?v?5?$LO?x?$LN?$MA?$LE?O?$LE?Y?4@
  00076	e8 00 00 00 00	 call	 ?AfxMessageBox@@YGHPBDII@Z ; AfxMessageBox
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl

; 668  : 	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_SETCURSEL, nSelect, 0); }

  0007b	56		 push	 esi
  0007c	6a 01		 push	 1
  0007e	68 86 01 00 00	 push	 390			; 00000186H
  00083	ff b7 68 01 00
	00		 push	 DWORD PTR [edi+360]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 563  : }

  00089	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16
  0008f	5f		 pop	 edi
  00090	5e		 pop	 esi
  00091	5b		 pop	 ebx
  00092	8b e5		 mov	 esp, ebp
  00094	5d		 pop	 ebp
  00095	c3		 ret	 0
$LN6@OnBtnMoved:

; 532  : 		m_listShow.SetCurSel(nSelected+1);
; 533  : 		return;
; 534  : 	}
; 535  : 
; 536  : 	switch(nCurSel)

  00096	83 ee 00	 sub	 esi, 0
  00099	74 74		 je	 SHORT $LN7@OnBtnMoved
  0009b	83 ee 01	 sub	 esi, 1
  0009e	74 3c		 je	 SHORT $LN8@OnBtnMoved
  000a0	83 ee 01	 sub	 esi, 1
  000a3	0f 85 b4 00 00
	00		 jne	 $LN5@OnBtnMoved

; 552  : 	case 2:		//
; 553  : 		nNextKey = m_arrayAdditionIdx.GetAt(nSelected+1);

  000a9	43		 inc	 ebx
  000aa	81 c7 c0 00 00
	00		 add	 edi, 192		; 000000c0H
  000b0	53		 push	 ebx
  000b1	8b cf		 mov	 ecx, edi
  000b3	e8 00 00 00 00	 call	 ?GetAt@?$CArray@HH@@QAEAAHH@Z ; CArray<int,int>::GetAt

; 554  : 		m_arrayAdditionIdx.RemoveAt(nSelected+1);

  000b8	6a 01		 push	 1
  000ba	53		 push	 ebx
  000bb	8b cf		 mov	 ecx, edi
  000bd	8b 30		 mov	 esi, DWORD PTR [eax]
  000bf	e8 00 00 00 00	 call	 ?RemoveAt@?$CArray@HH@@QAEXHH@Z ; CArray<int,int>::RemoveAt

; 555  : 		m_arrayAdditionIdx.InsertAt(nSelected, nNextKey);

  000c4	6a 01		 push	 1
  000c6	56		 push	 esi
  000c7	ff 75 fc	 push	 DWORD PTR _nSelected$1$[ebp]
  000ca	8b cf		 mov	 ecx, edi
  000cc	e8 00 00 00 00	 call	 ?InsertAt@?$CArray@HH@@QAEXHHH@Z ; CArray<int,int>::InsertAt

; 556  : 		FillShowList(m_arrayAdditionIdx, m_mapAdditionList);

  000d1	8b 75 f8	 mov	 esi, DWORD PTR _this$1$[ebp]
  000d4	8d 86 04 01 00
	00		 lea	 eax, DWORD PTR [esi+260]

; 557  : 		m_listShow.SetCurSel(nSelected+1);
; 558  : 		break;

  000da	eb 64		 jmp	 SHORT $LN27@OnBtnMoved
$LN8@OnBtnMoved:

; 543  : 		m_listShow.SetCurSel(nSelected+1);
; 544  : 		break;
; 545  : 	case 1:		// 
; 546  : 		nNextKey = m_arrayAnalIdx.GetAt(nSelected+1);

  000dc	43		 inc	 ebx
  000dd	81 c7 ac 00 00
	00		 add	 edi, 172		; 000000acH
  000e3	53		 push	 ebx
  000e4	8b cf		 mov	 ecx, edi
  000e6	e8 00 00 00 00	 call	 ?GetAt@?$CArray@HH@@QAEAAHH@Z ; CArray<int,int>::GetAt

; 547  : 		m_arrayAnalIdx.RemoveAt(nSelected+1);

  000eb	6a 01		 push	 1
  000ed	53		 push	 ebx
  000ee	8b cf		 mov	 ecx, edi
  000f0	8b 30		 mov	 esi, DWORD PTR [eax]
  000f2	e8 00 00 00 00	 call	 ?RemoveAt@?$CArray@HH@@QAEXHH@Z ; CArray<int,int>::RemoveAt

; 548  : 		m_arrayAnalIdx.InsertAt(nSelected, nNextKey);

  000f7	6a 01		 push	 1
  000f9	56		 push	 esi
  000fa	ff 75 fc	 push	 DWORD PTR _nSelected$1$[ebp]
  000fd	8b cf		 mov	 ecx, edi
  000ff	e8 00 00 00 00	 call	 ?InsertAt@?$CArray@HH@@QAEXHHH@Z ; CArray<int,int>::InsertAt

; 549  : 		FillShowList(m_arrayAnalIdx, m_mapAnalList);

  00104	8b 75 f8	 mov	 esi, DWORD PTR _this$1$[ebp]
  00107	8d 86 e8 00 00
	00		 lea	 eax, DWORD PTR [esi+232]

; 550  : 		m_listShow.SetCurSel(nSelected+1);
; 551  : 		break;

  0010d	eb 31		 jmp	 SHORT $LN27@OnBtnMoved
$LN7@OnBtnMoved:

; 537  : 	{
; 538  : 	case 0:		// 
; 539  : 		nNextKey = m_arrayUserIdx.GetAt(nSelected+1);

  0010f	43		 inc	 ebx
  00110	81 c7 d4 00 00
	00		 add	 edi, 212		; 000000d4H
  00116	53		 push	 ebx
  00117	8b cf		 mov	 ecx, edi
  00119	e8 00 00 00 00	 call	 ?GetAt@?$CArray@HH@@QAEAAHH@Z ; CArray<int,int>::GetAt

; 540  : 		m_arrayUserIdx.RemoveAt(nSelected+1);

  0011e	6a 01		 push	 1
  00120	53		 push	 ebx
  00121	8b cf		 mov	 ecx, edi
  00123	8b 30		 mov	 esi, DWORD PTR [eax]
  00125	e8 00 00 00 00	 call	 ?RemoveAt@?$CArray@HH@@QAEXHH@Z ; CArray<int,int>::RemoveAt

; 541  : 		m_arrayUserIdx.InsertAt(nSelected, nNextKey);

  0012a	6a 01		 push	 1
  0012c	56		 push	 esi
  0012d	ff 75 fc	 push	 DWORD PTR _nSelected$1$[ebp]
  00130	8b cf		 mov	 ecx, edi
  00132	e8 00 00 00 00	 call	 ?InsertAt@?$CArray@HH@@QAEXHHH@Z ; CArray<int,int>::InsertAt

; 542  : 		FillShowList(m_arrayUserIdx, m_mapUserList);

  00137	8b 75 f8	 mov	 esi, DWORD PTR _this$1$[ebp]
  0013a	8d 86 20 01 00
	00		 lea	 eax, DWORD PTR [esi+288]
$LN27@OnBtnMoved:

; 563  : }

  00140	50		 push	 eax
  00141	57		 push	 edi
  00142	8b ce		 mov	 ecx, esi
  00144	e8 00 00 00 00	 call	 ?FillShowList@CDlgSettingToolBar@@AAEXAAV?$CArray@HH@@AAV?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@@Z ; CDlgSettingToolBar::FillShowList
  00149	6a 00		 push	 0
  0014b	53		 push	 ebx
  0014c	68 86 01 00 00	 push	 390			; 00000186H
  00151	ff b6 68 01 00
	00		 push	 DWORD PTR [esi+360]
  00157	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16
$LN5@OnBtnMoved:
  0015d	5f		 pop	 edi
  0015e	5e		 pop	 esi
  0015f	5b		 pop	 ebx
  00160	8b e5		 mov	 esp, ebp
  00162	5d		 pop	 ebp
  00163	c3		 ret	 0
?OnBtnMovedown@CDlgSettingToolBar@@IAEXXZ ENDP		; CDlgSettingToolBar::OnBtnMovedown
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
;	COMDAT ?OnBtnInit@CDlgSettingToolBar@@IAEXXZ
_TEXT	SEGMENT
?OnBtnInit@CDlgSettingToolBar@@IAEXXZ PROC		; CDlgSettingToolBar::OnBtnInit, COMDAT
; _this$ = ecx

; 491  : {

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl

; 765  : 	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, CB_GETCURSEL, 0, 0); }

  00003	6a 00		 push	 0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 491  : {

  00005	8b f9		 mov	 edi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl

; 765  : 	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, CB_GETCURSEL, 0, 0); }

  00007	6a 00		 push	 0
  00009	68 47 01 00 00	 push	 327			; 00000147H
  0000e	ff b7 68 02 00
	00		 push	 DWORD PTR [edi+616]
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 494  : 	switch(nCurSel)

  0001a	83 e8 00	 sub	 eax, 0
  0001d	0f 84 da 00 00
	00		 je	 $LN4@OnBtnInit
  00023	83 e8 01	 sub	 eax, 1
  00026	74 6f		 je	 SHORT $LN5@OnBtnInit
  00028	83 e8 01	 sub	 eax, 1
  0002b	0f 85 2e 01 00
	00		 jne	 $LN7@OnBtnInit
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 381  : 		if (m_pData != NULL)

  00031	8b 87 c4 00 00
	00		 mov	 eax, DWORD PTR [edi+196]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 509  : 		m_arrayAdditionIdx.RemoveAll();

  00037	8d 9f c0 00 00
	00		 lea	 ebx, DWORD PTR [edi+192]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 381  : 		if (m_pData != NULL)

  0003d	85 c0		 test	 eax, eax
  0003f	74 1f		 je	 SHORT $LN134@OnBtnInit

; 382  : 		{
; 383  : 			for( int i = 0; i < m_nSize; i++ )

  00041	83 bf c8 00 00
	00 00		 cmp	 DWORD PTR [edi+200], 0
  00048	7e 03		 jle	 SHORT $LN116@OnBtnInit
  0004a	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
$LN116@OnBtnInit:

; 384  : 				(m_pData + i)->~TYPE();
; 385  : 			delete[] (BYTE*)m_pData;

  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00053	83 c4 04	 add	 esp, 4

; 386  : 			m_pData = NULL;

  00056	c7 87 c4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+196], 0
$LN134@OnBtnInit:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 510  : 		m_mapAdditionList.RemoveAll();

  00060	8d b7 04 01 00
	00		 lea	 esi, DWORD PTR [edi+260]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 388  : 		m_nSize = m_nMaxSize = 0;

  00066	c7 87 cc 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+204], 0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 510  : 		m_mapAdditionList.RemoveAll();

  00070	8b ce		 mov	 ecx, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 388  : 		m_nSize = m_nMaxSize = 0;

  00072	c7 87 c8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+200], 0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 510  : 		m_mapAdditionList.RemoveAll();

  0007c	e8 00 00 00 00	 call	 ?RemoveAll@?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@QAEXXZ ; CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >::RemoveAll

; 511  : 		ReadIniFile(nCurSel);

  00081	6a 02		 push	 2

; 512  : 		FillShowList(m_arrayAdditionIdx, m_mapAdditionList);
; 513  : 		break;
; 514  : 	default:
; 515  : 		break;
; 516  : 	}
; 517  : }

  00083	8b cf		 mov	 ecx, edi
  00085	e8 00 00 00 00	 call	 ?ReadIniFile@CDlgSettingToolBar@@AAEXH@Z ; CDlgSettingToolBar::ReadIniFile
  0008a	56		 push	 esi
  0008b	53		 push	 ebx
  0008c	8b cf		 mov	 ecx, edi
  0008e	e8 00 00 00 00	 call	 ?FillShowList@CDlgSettingToolBar@@AAEXAAV?$CArray@HH@@AAV?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@@Z ; CDlgSettingToolBar::FillShowList
  00093	5f		 pop	 edi
  00094	5e		 pop	 esi
  00095	5b		 pop	 ebx
  00096	c3		 ret	 0
$LN5@OnBtnInit:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 381  : 		if (m_pData != NULL)

  00097	8b 87 b0 00 00
	00		 mov	 eax, DWORD PTR [edi+176]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 503  : 		m_arrayAnalIdx.RemoveAll();

  0009d	8d 9f ac 00 00
	00		 lea	 ebx, DWORD PTR [edi+172]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 381  : 		if (m_pData != NULL)

  000a3	85 c0		 test	 eax, eax
  000a5	74 1f		 je	 SHORT $LN84@OnBtnInit

; 382  : 		{
; 383  : 			for( int i = 0; i < m_nSize; i++ )

  000a7	83 bf b4 00 00
	00 00		 cmp	 DWORD PTR [edi+180], 0
  000ae	7e 03		 jle	 SHORT $LN66@OnBtnInit
  000b0	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
$LN66@OnBtnInit:

; 384  : 				(m_pData + i)->~TYPE();
; 385  : 			delete[] (BYTE*)m_pData;

  000b3	50		 push	 eax
  000b4	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  000b9	83 c4 04	 add	 esp, 4

; 386  : 			m_pData = NULL;

  000bc	c7 87 b0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+176], 0
$LN84@OnBtnInit:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 504  : 		m_mapAnalList.RemoveAll();

  000c6	8d b7 e8 00 00
	00		 lea	 esi, DWORD PTR [edi+232]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 388  : 		m_nSize = m_nMaxSize = 0;

  000cc	c7 87 b8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+184], 0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 504  : 		m_mapAnalList.RemoveAll();

  000d6	8b ce		 mov	 ecx, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 388  : 		m_nSize = m_nMaxSize = 0;

  000d8	c7 87 b4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+180], 0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 504  : 		m_mapAnalList.RemoveAll();

  000e2	e8 00 00 00 00	 call	 ?RemoveAll@?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@QAEXXZ ; CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >::RemoveAll

; 505  : 		ReadIniFile(nCurSel);

  000e7	6a 01		 push	 1

; 512  : 		FillShowList(m_arrayAdditionIdx, m_mapAdditionList);
; 513  : 		break;
; 514  : 	default:
; 515  : 		break;
; 516  : 	}
; 517  : }

  000e9	8b cf		 mov	 ecx, edi
  000eb	e8 00 00 00 00	 call	 ?ReadIniFile@CDlgSettingToolBar@@AAEXH@Z ; CDlgSettingToolBar::ReadIniFile
  000f0	56		 push	 esi
  000f1	53		 push	 ebx
  000f2	8b cf		 mov	 ecx, edi
  000f4	e8 00 00 00 00	 call	 ?FillShowList@CDlgSettingToolBar@@AAEXAAV?$CArray@HH@@AAV?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@@Z ; CDlgSettingToolBar::FillShowList
  000f9	5f		 pop	 edi
  000fa	5e		 pop	 esi
  000fb	5b		 pop	 ebx
  000fc	c3		 ret	 0
$LN4@OnBtnInit:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 381  : 		if (m_pData != NULL)

  000fd	8b 87 d8 00 00
	00		 mov	 eax, DWORD PTR [edi+216]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 497  : 		m_arrayUserIdx.RemoveAll();

  00103	8d 9f d4 00 00
	00		 lea	 ebx, DWORD PTR [edi+212]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 381  : 		if (m_pData != NULL)

  00109	85 c0		 test	 eax, eax
  0010b	74 1f		 je	 SHORT $LN33@OnBtnInit

; 382  : 		{
; 383  : 			for( int i = 0; i < m_nSize; i++ )

  0010d	83 bf dc 00 00
	00 00		 cmp	 DWORD PTR [edi+220], 0
  00114	7e 03		 jle	 SHORT $LN15@OnBtnInit
  00116	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
$LN15@OnBtnInit:

; 384  : 				(m_pData + i)->~TYPE();
; 385  : 			delete[] (BYTE*)m_pData;

  00119	50		 push	 eax
  0011a	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0011f	83 c4 04	 add	 esp, 4

; 386  : 			m_pData = NULL;

  00122	c7 87 d8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+216], 0
$LN33@OnBtnInit:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 498  : 		m_mapUserList.RemoveAll();

  0012c	8d b7 20 01 00
	00		 lea	 esi, DWORD PTR [edi+288]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 388  : 		m_nSize = m_nMaxSize = 0;

  00132	c7 87 e0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+224], 0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 498  : 		m_mapUserList.RemoveAll();

  0013c	8b ce		 mov	 ecx, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 388  : 		m_nSize = m_nMaxSize = 0;

  0013e	c7 87 dc 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+220], 0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 498  : 		m_mapUserList.RemoveAll();

  00148	e8 00 00 00 00	 call	 ?RemoveAll@?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@QAEXXZ ; CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >::RemoveAll

; 499  : 		ReadIniFile(nCurSel);

  0014d	6a 00		 push	 0

; 512  : 		FillShowList(m_arrayAdditionIdx, m_mapAdditionList);
; 513  : 		break;
; 514  : 	default:
; 515  : 		break;
; 516  : 	}
; 517  : }

  0014f	8b cf		 mov	 ecx, edi
  00151	e8 00 00 00 00	 call	 ?ReadIniFile@CDlgSettingToolBar@@AAEXH@Z ; CDlgSettingToolBar::ReadIniFile
  00156	56		 push	 esi
  00157	53		 push	 ebx
  00158	8b cf		 mov	 ecx, edi
  0015a	e8 00 00 00 00	 call	 ?FillShowList@CDlgSettingToolBar@@AAEXAAV?$CArray@HH@@AAV?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@@Z ; CDlgSettingToolBar::FillShowList
$LN7@OnBtnInit:
  0015f	5f		 pop	 edi
  00160	5e		 pop	 esi
  00161	5b		 pop	 ebx
  00162	c3		 ret	 0
?OnBtnInit@CDlgSettingToolBar@@IAEXXZ ENDP		; CDlgSettingToolBar::OnBtnInit
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
;	COMDAT ?OnBtnAdd@CDlgSettingToolBar@@IAEXXZ
_TEXT	SEGMENT
_nHashValue$2 = -24					; size = 4
_nHashValue$3 = -24					; size = 4
_nHashBucket$4 = -24					; size = 4
_nKey$ = -24						; size = 4
_nIndex$1$ = -20					; size = 4
_nHashBucket$5 = -20					; size = 4
_nHashBucket$6 = -20					; size = 4
_nHashValue$7 = -20					; size = 4
_strFieldName$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?OnBtnAdd@CDlgSettingToolBar@@IAEXXZ PROC		; CDlgSettingToolBar::OnBtnAdd, COMDAT
; _this$ = ecx

; 427  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?OnBtnAdd@CDlgSettingToolBar@@IAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b f9		 mov	 edi, ecx

; 430  : 	CString strFieldName;

  0002a	8d 4d f0	 lea	 ecx, DWORD PTR _strFieldName$[ebp]
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl

; 765  : 	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, CB_GETCURSEL, 0, 0); }

  00033	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SendMessageA@16
  00039	6a 00		 push	 0
  0003b	6a 00		 push	 0
  0003d	68 47 01 00 00	 push	 327			; 00000147H
  00042	ff b7 e8 02 00
	00		 push	 DWORD PTR [edi+744]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 430  : 	CString strFieldName;

  00048	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl

; 765  : 	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, CB_GETCURSEL, 0, 0); }

  0004f	ff d6		 call	 esi

; 666  : 	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_GETCURSEL, 0, 0); }

  00051	6a 00		 push	 0
  00053	6a 00		 push	 0
  00055	68 88 01 00 00	 push	 392			; 00000188H
  0005a	ff b7 e8 01 00
	00		 push	 DWORD PTR [edi+488]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 431  : 	int nCmbCurSel = m_cmbAvailable.GetCurSel();

  00060	8b d8		 mov	 ebx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl

; 666  : 	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_GETCURSEL, 0, 0); }

  00062	ff d6		 call	 esi
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 432  : 	int nCurSel = m_listAvailable.GetCurSel();

  00064	8b f0		 mov	 esi, eax

; 433  : 	if(nCurSel < 0) return;

  00066	85 f6		 test	 esi, esi
  00068	0f 88 04 01 00
	00		 js	 $LN7@OnBtnAdd

; 434  : 	if(0 ==nCmbCurSel)		// Anal

  0006e	85 db		 test	 ebx, ebx
  00070	75 3c		 jne	 SHORT $LN3@OnBtnAdd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 288  : 	if(nIndex >= 0 && nIndex < m_nSize)

  00072	3b b7 b4 00 00
	00		 cmp	 esi, DWORD PTR [edi+180]
  00078	0f 8d 0f 01 00
	00		 jge	 $LN40@OnBtnAdd
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 437  : 		m_mapAnalList.Lookup(nKey, strFieldName);

  0007e	8b 87 b0 00 00
	00		 mov	 eax, DWORD PTR [edi+176]
  00084	8d 8f e8 00 00
	00		 lea	 ecx, DWORD PTR [edi+232]
  0008a	8b 34 b0	 mov	 esi, DWORD PTR [eax+esi*4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 1555 : 	CAssoc* pAssoc = GetAssocAt(key, nHashBucket, nHashValue);

  0008d	8d 45 ec	 lea	 eax, DWORD PTR _nHashValue$7[ebp]
  00090	50		 push	 eax
  00091	8d 45 e8	 lea	 eax, DWORD PTR _nHashBucket$4[ebp]
  00094	50		 push	 eax
  00095	56		 push	 esi
  00096	e8 00 00 00 00	 call	 ?GetAssocAt@?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@IBEPAVCAssoc@1@HAAI0@Z ; CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >::GetAssocAt

; 1556 : 	if (pAssoc == NULL)

  0009b	85 c0		 test	 eax, eax
  0009d	74 53		 je	 SHORT $LN26@OnBtnAdd

; 1557 : 		return FALSE;  // not in map
; 1558 : 
; 1559 : 	rValue = pAssoc->value;

  0009f	83 c0 04	 add	 eax, 4
  000a2	8d 4d f0	 lea	 ecx, DWORD PTR _strFieldName$[ebp]
  000a5	50		 push	 eax
  000a6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 438  : 	}

  000ac	eb 44		 jmp	 SHORT $LN26@OnBtnAdd
$LN3@OnBtnAdd:

; 439  : 	else if(1 == nCmbCurSel)	// Addition

  000ae	83 fb 01	 cmp	 ebx, 1
  000b1	75 3c		 jne	 SHORT $LN41@OnBtnAdd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 288  : 	if(nIndex >= 0 && nIndex < m_nSize)

  000b3	3b b7 c8 00 00
	00		 cmp	 esi, DWORD PTR [edi+200]
  000b9	0f 8d ce 00 00
	00		 jge	 $LN40@OnBtnAdd
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 442  : 		m_mapAdditionList.Lookup(nKey, strFieldName);

  000bf	8b 87 c4 00 00
	00		 mov	 eax, DWORD PTR [edi+196]
  000c5	8d 8f 04 01 00
	00		 lea	 ecx, DWORD PTR [edi+260]
  000cb	8b 34 b0	 mov	 esi, DWORD PTR [eax+esi*4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 1555 : 	CAssoc* pAssoc = GetAssocAt(key, nHashBucket, nHashValue);

  000ce	8d 45 e8	 lea	 eax, DWORD PTR _nHashValue$3[ebp]
  000d1	50		 push	 eax
  000d2	8d 45 ec	 lea	 eax, DWORD PTR _nHashBucket$6[ebp]
  000d5	50		 push	 eax
  000d6	56		 push	 esi
  000d7	e8 00 00 00 00	 call	 ?GetAssocAt@?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@IBEPAVCAssoc@1@HAAI0@Z ; CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >::GetAssocAt

; 1556 : 	if (pAssoc == NULL)

  000dc	85 c0		 test	 eax, eax
  000de	74 12		 je	 SHORT $LN26@OnBtnAdd

; 1557 : 		return FALSE;  // not in map
; 1558 : 
; 1559 : 	rValue = pAssoc->value;

  000e0	83 c0 04	 add	 eax, 4
  000e3	8d 4d f0	 lea	 ecx, DWORD PTR _strFieldName$[ebp]
  000e6	50		 push	 eax
  000e7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 439  : 	else if(1 == nCmbCurSel)	// Addition

  000ed	eb 03		 jmp	 SHORT $LN26@OnBtnAdd
$LN41@OnBtnAdd:
  000ef	8b 75 e8	 mov	 esi, DWORD PTR _nKey$[ebp]
$LN26@OnBtnAdd:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 1555 : 	CAssoc* pAssoc = GetAssocAt(key, nHashBucket, nHashValue);

  000f2	8d 4d e8	 lea	 ecx, DWORD PTR _nHashValue$2[ebp]
  000f5	51		 push	 ecx
  000f6	8d 4d ec	 lea	 ecx, DWORD PTR _nHashBucket$5[ebp]
  000f9	51		 push	 ecx
  000fa	56		 push	 esi
  000fb	8d 8f 20 01 00
	00		 lea	 ecx, DWORD PTR [edi+288]
  00101	e8 00 00 00 00	 call	 ?GetAssocAt@?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@IBEPAVCAssoc@1@HAAI0@Z ; CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >::GetAssocAt

; 1556 : 	if (pAssoc == NULL)

  00106	85 c0		 test	 eax, eax
  00108	74 1d		 je	 SHORT $LN39@OnBtnAdd

; 1557 : 		return FALSE;  // not in map
; 1558 : 
; 1559 : 	rValue = pAssoc->value;

  0010a	83 c0 04	 add	 eax, 4
  0010d	8d 4d f0	 lea	 ecx, DWORD PTR _strFieldName$[ebp]
  00110	50		 push	 eax
  00111	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 453  : 		AfxMessageBox("    .");

  00117	6a 00		 push	 0
  00119	6a 00		 push	 0
  0011b	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@IAFEBKKH@?G?X?$LE?g?5?G?W?$LI?q?$MA?$LK?5?$MA?L?$LJ?L?5?$LI?q?$LH?O?$LP?$KB?5?A?$LI?$MA?g?G?U?$LE@
  00120	e8 00 00 00 00	 call	 ?AfxMessageBox@@YGHPBDII@Z ; AfxMessageBox
  00125	eb 4b		 jmp	 SHORT $LN7@OnBtnAdd
$LN39@OnBtnAdd:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 333  : 	{ INT_PTR nIndex = m_nSize;

  00127	8b 87 dc 00 00
	00		 mov	 eax, DWORD PTR [edi+220]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 447  : 		m_arrayUserIdx.Add(nKey);

  0012d	8d 9f d4 00 00
	00		 lea	 ebx, DWORD PTR [edi+212]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 333  : 	{ INT_PTR nIndex = m_nSize;

  00133	89 45 ec	 mov	 DWORD PTR _nIndex$1$[ebp], eax

; 538  : 	if(nIndex < 0)

  00136	85 c0		 test	 eax, eax
  00138	78 53		 js	 SHORT $LN40@OnBtnAdd

; 540  : 
; 541  : 	if (nIndex >= m_nSize)
; 542  : 		SetSize(nIndex+1, -1);

  0013a	6a ff		 push	 -1
  0013c	40		 inc	 eax
  0013d	8b cb		 mov	 ecx, ebx
  0013f	50		 push	 eax
  00140	e8 00 00 00 00	 call	 ?SetSize@?$CArray@HH@@QAEXHH@Z ; CArray<int,int>::SetSize

; 543  : 	m_pData[nIndex] = newElement;

  00145	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00148	8b 4d ec	 mov	 ecx, DWORD PTR _nIndex$1$[ebp]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 448  : 		m_mapUserList.SetAt(nKey, strFieldName);

  0014b	51		 push	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 543  : 	m_pData[nIndex] = newElement;

  0014c	89 34 88	 mov	 DWORD PTR [eax+ecx*4], esi
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 448  : 		m_mapUserList.SetAt(nKey, strFieldName);

  0014f	8d 45 f0	 lea	 eax, DWORD PTR _strFieldName$[ebp]
  00152	8b cc		 mov	 ecx, esp
  00154	50		 push	 eax
  00155	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z
  0015b	56		 push	 esi
  0015c	8d b7 20 01 00
	00		 lea	 esi, DWORD PTR [edi+288]
  00162	8b ce		 mov	 ecx, esi
  00164	e8 00 00 00 00	 call	 ?SetAt@?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@QAEXHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ; CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >::SetAt

; 449  : 
; 450  : 		FillShowList(m_arrayUserIdx, m_mapUserList);

  00169	56		 push	 esi
  0016a	53		 push	 ebx
  0016b	8b cf		 mov	 ecx, edi
  0016d	e8 00 00 00 00	 call	 ?FillShowList@CDlgSettingToolBar@@AAEXAAV?$CArray@HH@@AAV?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@@Z ; CDlgSettingToolBar::FillShowList
$LN7@OnBtnAdd:

; 455  : }

  00172	8d 4d f0	 lea	 ecx, DWORD PTR _strFieldName$[ebp]
  00175	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0017b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0017e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00185	59		 pop	 ecx
  00186	5f		 pop	 edi
  00187	5e		 pop	 esi
  00188	5b		 pop	 ebx
  00189	8b e5		 mov	 esp, ebp
  0018b	5d		 pop	 ebp
  0018c	c3		 ret	 0
$LN40@OnBtnAdd:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 539  : 		AfxThrowInvalidArgException();

  0018d	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN43@OnBtnAdd:
  00192	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?OnBtnAdd@CDlgSettingToolBar@@IAEXXZ$0:
  00000	8d 4d f0	 lea	 ecx, DWORD PTR _strFieldName$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
  0000d	cc		 int	 3
__ehhandler$?OnBtnAdd@CDlgSettingToolBar@@IAEXXZ:
  0000e	90		 npad	 1
  0000f	90		 npad	 1
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?OnBtnAdd@CDlgSettingToolBar@@IAEXXZ
  00026	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?OnBtnAdd@CDlgSettingToolBar@@IAEXXZ ENDP		; CDlgSettingToolBar::OnBtnAdd
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
;	COMDAT ?OnSelchangeCmbShow@CDlgSettingToolBar@@IAEXXZ
_TEXT	SEGMENT
?OnSelchangeCmbShow@CDlgSettingToolBar@@IAEXXZ PROC	; CDlgSettingToolBar::OnSelchangeCmbShow, COMDAT
; _this$ = ecx

; 350  : {

  00000	56		 push	 esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl

; 765  : 	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, CB_GETCURSEL, 0, 0); }

  00001	6a 00		 push	 0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 350  : {

  00003	8b f1		 mov	 esi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl

; 765  : 	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, CB_GETCURSEL, 0, 0); }

  00005	6a 00		 push	 0
  00007	68 47 01 00 00	 push	 327			; 00000147H
  0000c	ff b6 68 02 00
	00		 push	 DWORD PTR [esi+616]
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 352  : 	switch(nCul)

  00018	83 e8 00	 sub	 eax, 0
  0001b	0f 84 3b 01 00
	00		 je	 $LN4@OnSelchang
  00021	83 e8 01	 sub	 eax, 1
  00024	0f 84 9d 00 00
	00		 je	 $LN5@OnSelchang
  0002a	83 e8 01	 sub	 eax, 1
  0002d	0f 85 bc 01 00
	00		 jne	 $LN7@OnSelchang

; 373  : 		break;
; 374  : 	case 2:		// 
; 375  : 		GetDlgItem(IDC_CMB_AVAILABLE)->EnableWindow(FALSE);

  00033	50		 push	 eax
  00034	68 76 18 00 00	 push	 6262			; 00001876H
  00039	8b ce		 mov	 ecx, esi
  0003b	e8 00 00 00 00	 call	 ?GetDlgItem@CWnd@@QBEPAV1@H@Z ; CWnd::GetDlgItem
  00040	8b c8		 mov	 ecx, eax
  00042	e8 00 00 00 00	 call	 ?EnableWindow@CWnd@@QAEHH@Z ; CWnd::EnableWindow

; 376  : 		GetDlgItem(IDC_LIST_AVAILABLE)->EnableWindow(FALSE);

  00047	6a 00		 push	 0
  00049	68 00 2b 00 00	 push	 11008			; 00002b00H
  0004e	8b ce		 mov	 ecx, esi
  00050	e8 00 00 00 00	 call	 ?GetDlgItem@CWnd@@QBEPAV1@H@Z ; CWnd::GetDlgItem
  00055	8b c8		 mov	 ecx, eax
  00057	e8 00 00 00 00	 call	 ?EnableWindow@CWnd@@QAEHH@Z ; CWnd::EnableWindow

; 377  : 		GetDlgItem(IDC_BTN_ADD)->EnableWindow(FALSE);

  0005c	6a 00		 push	 0
  0005e	68 01 2b 00 00	 push	 11009			; 00002b01H
  00063	8b ce		 mov	 ecx, esi
  00065	e8 00 00 00 00	 call	 ?GetDlgItem@CWnd@@QBEPAV1@H@Z ; CWnd::GetDlgItem
  0006a	8b c8		 mov	 ecx, eax
  0006c	e8 00 00 00 00	 call	 ?EnableWindow@CWnd@@QAEHH@Z ; CWnd::EnableWindow

; 378  : 		GetDlgItem(IDC_BTN_REMOVE)->EnableWindow(FALSE);

  00071	6a 00		 push	 0
  00073	68 03 2b 00 00	 push	 11011			; 00002b03H
  00078	8b ce		 mov	 ecx, esi
  0007a	e8 00 00 00 00	 call	 ?GetDlgItem@CWnd@@QBEPAV1@H@Z ; CWnd::GetDlgItem
  0007f	8b c8		 mov	 ecx, eax
  00081	e8 00 00 00 00	 call	 ?EnableWindow@CWnd@@QAEHH@Z ; CWnd::EnableWindow

; 379  : 		GetDlgItem(IDC_BTN_REMOVEALL)->EnableWindow(FALSE);

  00086	6a 00		 push	 0
  00088	68 04 2b 00 00	 push	 11012			; 00002b04H
  0008d	8b ce		 mov	 ecx, esi
  0008f	e8 00 00 00 00	 call	 ?GetDlgItem@CWnd@@QBEPAV1@H@Z ; CWnd::GetDlgItem
  00094	8b c8		 mov	 ecx, eax
  00096	e8 00 00 00 00	 call	 ?EnableWindow@CWnd@@QAEHH@Z ; CWnd::EnableWindow

; 380  : 		GetDlgItem(IDC_BTN_ADDALL)->EnableWindow(FALSE);

  0009b	6a 00		 push	 0
  0009d	68 08 2b 00 00	 push	 11016			; 00002b08H
  000a2	8b ce		 mov	 ecx, esi
  000a4	e8 00 00 00 00	 call	 ?GetDlgItem@CWnd@@QBEPAV1@H@Z ; CWnd::GetDlgItem
  000a9	8b c8		 mov	 ecx, eax
  000ab	e8 00 00 00 00	 call	 ?EnableWindow@CWnd@@QAEHH@Z ; CWnd::EnableWindow

; 381  : 
; 382  : 		FillShowList(m_arrayAdditionIdx, m_mapAdditionList);

  000b0	8d 86 04 01 00
	00		 lea	 eax, DWORD PTR [esi+260]

; 383  : 		break;	
; 384  : 	default:
; 385  : 		break;
; 386  : 	}
; 387  : }

  000b6	8b ce		 mov	 ecx, esi
  000b8	50		 push	 eax
  000b9	8d 86 c0 00 00
	00		 lea	 eax, DWORD PTR [esi+192]
  000bf	50		 push	 eax
  000c0	e8 00 00 00 00	 call	 ?FillShowList@CDlgSettingToolBar@@AAEXAAV?$CArray@HH@@AAV?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@@Z ; CDlgSettingToolBar::FillShowList
  000c5	5e		 pop	 esi
  000c6	c3		 ret	 0
$LN5@OnSelchang:

; 363  : 		break;
; 364  : 	case 1:		// 
; 365  : 		GetDlgItem(IDC_CMB_AVAILABLE)->EnableWindow(FALSE);

  000c7	6a 00		 push	 0
  000c9	68 76 18 00 00	 push	 6262			; 00001876H
  000ce	8b ce		 mov	 ecx, esi
  000d0	e8 00 00 00 00	 call	 ?GetDlgItem@CWnd@@QBEPAV1@H@Z ; CWnd::GetDlgItem
  000d5	8b c8		 mov	 ecx, eax
  000d7	e8 00 00 00 00	 call	 ?EnableWindow@CWnd@@QAEHH@Z ; CWnd::EnableWindow

; 366  : 		GetDlgItem(IDC_LIST_AVAILABLE)->EnableWindow(FALSE);

  000dc	6a 00		 push	 0
  000de	68 00 2b 00 00	 push	 11008			; 00002b00H
  000e3	8b ce		 mov	 ecx, esi
  000e5	e8 00 00 00 00	 call	 ?GetDlgItem@CWnd@@QBEPAV1@H@Z ; CWnd::GetDlgItem
  000ea	8b c8		 mov	 ecx, eax
  000ec	e8 00 00 00 00	 call	 ?EnableWindow@CWnd@@QAEHH@Z ; CWnd::EnableWindow

; 367  : 		GetDlgItem(IDC_BTN_ADD)->EnableWindow(FALSE);

  000f1	6a 00		 push	 0
  000f3	68 01 2b 00 00	 push	 11009			; 00002b01H
  000f8	8b ce		 mov	 ecx, esi
  000fa	e8 00 00 00 00	 call	 ?GetDlgItem@CWnd@@QBEPAV1@H@Z ; CWnd::GetDlgItem
  000ff	8b c8		 mov	 ecx, eax
  00101	e8 00 00 00 00	 call	 ?EnableWindow@CWnd@@QAEHH@Z ; CWnd::EnableWindow

; 368  : 		GetDlgItem(IDC_BTN_REMOVE)->EnableWindow(FALSE);

  00106	6a 00		 push	 0
  00108	68 03 2b 00 00	 push	 11011			; 00002b03H
  0010d	8b ce		 mov	 ecx, esi
  0010f	e8 00 00 00 00	 call	 ?GetDlgItem@CWnd@@QBEPAV1@H@Z ; CWnd::GetDlgItem
  00114	8b c8		 mov	 ecx, eax
  00116	e8 00 00 00 00	 call	 ?EnableWindow@CWnd@@QAEHH@Z ; CWnd::EnableWindow

; 369  : 		GetDlgItem(IDC_BTN_REMOVEALL)->EnableWindow(FALSE);

  0011b	6a 00		 push	 0
  0011d	68 04 2b 00 00	 push	 11012			; 00002b04H
  00122	8b ce		 mov	 ecx, esi
  00124	e8 00 00 00 00	 call	 ?GetDlgItem@CWnd@@QBEPAV1@H@Z ; CWnd::GetDlgItem
  00129	8b c8		 mov	 ecx, eax
  0012b	e8 00 00 00 00	 call	 ?EnableWindow@CWnd@@QAEHH@Z ; CWnd::EnableWindow

; 370  : 		GetDlgItem(IDC_BTN_ADDALL)->EnableWindow(FALSE);

  00130	6a 00		 push	 0
  00132	68 08 2b 00 00	 push	 11016			; 00002b08H
  00137	8b ce		 mov	 ecx, esi
  00139	e8 00 00 00 00	 call	 ?GetDlgItem@CWnd@@QBEPAV1@H@Z ; CWnd::GetDlgItem
  0013e	8b c8		 mov	 ecx, eax
  00140	e8 00 00 00 00	 call	 ?EnableWindow@CWnd@@QAEHH@Z ; CWnd::EnableWindow

; 371  : 
; 372  : 		FillShowList(m_arrayAnalIdx, m_mapAnalList);

  00145	8d 86 e8 00 00
	00		 lea	 eax, DWORD PTR [esi+232]

; 383  : 		break;	
; 384  : 	default:
; 385  : 		break;
; 386  : 	}
; 387  : }

  0014b	8b ce		 mov	 ecx, esi
  0014d	50		 push	 eax
  0014e	8d 86 ac 00 00
	00		 lea	 eax, DWORD PTR [esi+172]
  00154	50		 push	 eax
  00155	e8 00 00 00 00	 call	 ?FillShowList@CDlgSettingToolBar@@AAEXAAV?$CArray@HH@@AAV?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@@Z ; CDlgSettingToolBar::FillShowList
  0015a	5e		 pop	 esi
  0015b	c3		 ret	 0
$LN4@OnSelchang:

; 353  : 	{
; 354  : 	case 0:		// 
; 355  : 		GetDlgItem(IDC_CMB_AVAILABLE)->EnableWindow(TRUE);

  0015c	6a 01		 push	 1
  0015e	68 76 18 00 00	 push	 6262			; 00001876H
  00163	8b ce		 mov	 ecx, esi
  00165	e8 00 00 00 00	 call	 ?GetDlgItem@CWnd@@QBEPAV1@H@Z ; CWnd::GetDlgItem
  0016a	8b c8		 mov	 ecx, eax
  0016c	e8 00 00 00 00	 call	 ?EnableWindow@CWnd@@QAEHH@Z ; CWnd::EnableWindow

; 356  : 		GetDlgItem(IDC_LIST_AVAILABLE)->EnableWindow(TRUE);

  00171	6a 01		 push	 1
  00173	68 00 2b 00 00	 push	 11008			; 00002b00H
  00178	8b ce		 mov	 ecx, esi
  0017a	e8 00 00 00 00	 call	 ?GetDlgItem@CWnd@@QBEPAV1@H@Z ; CWnd::GetDlgItem
  0017f	8b c8		 mov	 ecx, eax
  00181	e8 00 00 00 00	 call	 ?EnableWindow@CWnd@@QAEHH@Z ; CWnd::EnableWindow

; 357  : 		GetDlgItem(IDC_BTN_ADD)->EnableWindow(TRUE);

  00186	6a 01		 push	 1
  00188	68 01 2b 00 00	 push	 11009			; 00002b01H
  0018d	8b ce		 mov	 ecx, esi
  0018f	e8 00 00 00 00	 call	 ?GetDlgItem@CWnd@@QBEPAV1@H@Z ; CWnd::GetDlgItem
  00194	8b c8		 mov	 ecx, eax
  00196	e8 00 00 00 00	 call	 ?EnableWindow@CWnd@@QAEHH@Z ; CWnd::EnableWindow

; 358  : 		GetDlgItem(IDC_BTN_REMOVE)->EnableWindow(TRUE);

  0019b	6a 01		 push	 1
  0019d	68 03 2b 00 00	 push	 11011			; 00002b03H
  001a2	8b ce		 mov	 ecx, esi
  001a4	e8 00 00 00 00	 call	 ?GetDlgItem@CWnd@@QBEPAV1@H@Z ; CWnd::GetDlgItem
  001a9	8b c8		 mov	 ecx, eax
  001ab	e8 00 00 00 00	 call	 ?EnableWindow@CWnd@@QAEHH@Z ; CWnd::EnableWindow

; 359  : 		GetDlgItem(IDC_BTN_REMOVEALL)->EnableWindow(TRUE);

  001b0	6a 01		 push	 1
  001b2	68 04 2b 00 00	 push	 11012			; 00002b04H
  001b7	8b ce		 mov	 ecx, esi
  001b9	e8 00 00 00 00	 call	 ?GetDlgItem@CWnd@@QBEPAV1@H@Z ; CWnd::GetDlgItem
  001be	8b c8		 mov	 ecx, eax
  001c0	e8 00 00 00 00	 call	 ?EnableWindow@CWnd@@QAEHH@Z ; CWnd::EnableWindow

; 360  : 		GetDlgItem(IDC_BTN_ADDALL)->EnableWindow(TRUE);

  001c5	6a 01		 push	 1
  001c7	68 08 2b 00 00	 push	 11016			; 00002b08H
  001cc	8b ce		 mov	 ecx, esi
  001ce	e8 00 00 00 00	 call	 ?GetDlgItem@CWnd@@QBEPAV1@H@Z ; CWnd::GetDlgItem
  001d3	8b c8		 mov	 ecx, eax
  001d5	e8 00 00 00 00	 call	 ?EnableWindow@CWnd@@QAEHH@Z ; CWnd::EnableWindow

; 361  : 
; 362  : 		FillShowList(m_arrayUserIdx, m_mapUserList);

  001da	8d 86 20 01 00
	00		 lea	 eax, DWORD PTR [esi+288]

; 383  : 		break;	
; 384  : 	default:
; 385  : 		break;
; 386  : 	}
; 387  : }

  001e0	8b ce		 mov	 ecx, esi
  001e2	50		 push	 eax
  001e3	8d 86 d4 00 00
	00		 lea	 eax, DWORD PTR [esi+212]
  001e9	50		 push	 eax
  001ea	e8 00 00 00 00	 call	 ?FillShowList@CDlgSettingToolBar@@AAEXAAV?$CArray@HH@@AAV?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@@Z ; CDlgSettingToolBar::FillShowList
$LN7@OnSelchang:
  001ef	5e		 pop	 esi
  001f0	c3		 ret	 0
?OnSelchangeCmbShow@CDlgSettingToolBar@@IAEXXZ ENDP	; CDlgSettingToolBar::OnSelchangeCmbShow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
;	COMDAT ?OnSelchangeCmbAvailable@CDlgSettingToolBar@@IAEXXZ
_TEXT	SEGMENT
?OnSelchangeCmbAvailable@CDlgSettingToolBar@@IAEXXZ PROC ; CDlgSettingToolBar::OnSelchangeCmbAvailable, COMDAT
; _this$ = ecx

; 334  : {

  00000	56		 push	 esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl

; 765  : 	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, CB_GETCURSEL, 0, 0); }

  00001	6a 00		 push	 0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 334  : {

  00003	8b f1		 mov	 esi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl

; 765  : 	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, CB_GETCURSEL, 0, 0); }

  00005	6a 00		 push	 0
  00007	68 47 01 00 00	 push	 327			; 00000147H
  0000c	ff b6 e8 02 00
	00		 push	 DWORD PTR [esi+744]
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 336  : 	switch(nCul)

  00018	83 e8 00	 sub	 eax, 0
  0001b	74 1c		 je	 SHORT $LN4@OnSelchang
  0001d	83 e8 01	 sub	 eax, 1
  00020	75 2c		 jne	 SHORT $LN6@OnSelchang

; 340  : 		break;
; 341  : 	case 1:		// 
; 342  : 		FillAvailableList(m_arrayAdditionIdx, m_mapAdditionList);

  00022	8d 86 04 01 00
	00		 lea	 eax, DWORD PTR [esi+260]

; 343  : 		break;	
; 344  : 	default:
; 345  : 		break;
; 346  : 	}
; 347  : }

  00028	8b ce		 mov	 ecx, esi
  0002a	50		 push	 eax
  0002b	8d 86 c0 00 00
	00		 lea	 eax, DWORD PTR [esi+192]
  00031	50		 push	 eax
  00032	e8 00 00 00 00	 call	 ?FillAvailableList@CDlgSettingToolBar@@AAEXAAV?$CArray@HH@@AAV?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@@Z ; CDlgSettingToolBar::FillAvailableList
  00037	5e		 pop	 esi
  00038	c3		 ret	 0
$LN4@OnSelchang:

; 337  : 	{
; 338  : 	case 0:		// 
; 339  : 		FillAvailableList(m_arrayAnalIdx, m_mapAnalList);

  00039	8d 86 e8 00 00
	00		 lea	 eax, DWORD PTR [esi+232]

; 343  : 		break;	
; 344  : 	default:
; 345  : 		break;
; 346  : 	}
; 347  : }

  0003f	8b ce		 mov	 ecx, esi
  00041	50		 push	 eax
  00042	8d 86 ac 00 00
	00		 lea	 eax, DWORD PTR [esi+172]
  00048	50		 push	 eax
  00049	e8 00 00 00 00	 call	 ?FillAvailableList@CDlgSettingToolBar@@AAEXAAV?$CArray@HH@@AAV?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@@Z ; CDlgSettingToolBar::FillAvailableList
$LN6@OnSelchang:
  0004e	5e		 pop	 esi
  0004f	c3		 ret	 0
?OnSelchangeCmbAvailable@CDlgSettingToolBar@@IAEXXZ ENDP ; CDlgSettingToolBar::OnSelchangeCmbAvailable
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
;	COMDAT ?OnApply@CDlgSettingToolBar@@IAEXXZ
_TEXT	SEGMENT
_FileFind$ = -108					; size = 28
_strVersion$ = -80					; size = 4
_strPath$ = -76						; size = 4
_str$ = -72						; size = 4
_strFieldName$ = -68					; size = 4
_nFieldKey$3$ = -64					; size = 4
_nFieldKey$2$ = -64					; size = 4
_nFieldKey$1$ = -64					; size = 4
_nCnt$3$ = -60						; size = 4
_nCnt$2$ = -60						; size = 4
_nCnt$1$ = -60						; size = 4
_strConfigPath$ = -56					; size = 4
_strValue$ = -52					; size = 4
_szKey$ = -48						; size = 30
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?OnApply@CDlgSettingToolBar@@IAEXXZ PROC		; CDlgSettingToolBar::OnApply, COMDAT
; _this$ = ecx

; 92   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?OnApply@CDlgSettingToolBar@@IAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 60	 sub	 esp, 96			; 00000060H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b f9		 mov	 edi, ecx

; 93   : 	m_bApply = FALSE;
; 94   : 	GetDlgItem(IDC_APPLY)->EnableWindow(m_bApply);

  0002d	6a 00		 push	 0
  0002f	6a 03		 push	 3
  00031	c7 87 a8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+168], 0
  0003b	e8 00 00 00 00	 call	 ?GetDlgItem@CWnd@@QBEPAV1@H@Z ; CWnd::GetDlgItem
  00040	8b c8		 mov	 ecx, eax
  00042	e8 00 00 00 00	 call	 ?EnableWindow@CWnd@@QAEHH@Z ; CWnd::EnableWindow

; 95   : 
; 96   : 	int nID = 21;
; 97   : 	IMainInfoManager* pMng = (IMainInfoManager*)m_pGMng->GetInterface(nID);

  00047	8b 87 3c 01 00
	00		 mov	 eax, DWORD PTR [edi+316]
  0004d	6a 00		 push	 0
  0004f	6a 15		 push	 21			; 00000015H
  00051	50		 push	 eax
  00052	8b 08		 mov	 ecx, DWORD PTR [eax]
  00054	ff 11		 call	 DWORD PTR [ecx]

; 98   : 	
; 99   : 	CFileFind FileFind;

  00056	8d 4d 94	 lea	 ecx, DWORD PTR _FileFind$[ebp]
  00059	8b f0		 mov	 esi, eax
  0005b	e8 00 00 00 00	 call	 ??0CFileFind@@QAE@XZ	; CFileFind::CFileFind

; 100  : 	CString strPath, strConfigPath;

  00060	8d 4d b4	 lea	 ecx, DWORD PTR _strPath$[ebp]
  00063	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0006a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00070	8d 4d c8	 lea	 ecx, DWORD PTR _strConfigPath$[ebp]
  00073	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 101  : 	strPath = pMng->GetEncUserDir();

  00079	8b 06		 mov	 eax, DWORD PTR [esi]
  0007b	6a 00		 push	 0
  0007d	56		 push	 esi
  0007e	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00082	ff 50 18	 call	 DWORD PTR [eax+24]
  00085	50		 push	 eax
  00086	8d 4d b4	 lea	 ecx, DWORD PTR _strPath$[ebp]
  00089	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z

; 102  : 	strPath += "\\Chart";

  0008f	68 00 00 00 00	 push	 OFFSET ??_C@_06DJNEHHKG@?2Chart@
  00094	8d 4d b4	 lea	 ecx, DWORD PTR _strPath$[ebp]
  00097	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z

; 103  : 	//strPath = ((CStdDialog*)m_pMultiChartWnd)->m_strUserDir;
; 104  : 	strConfigPath.Format("%s\\%s", strPath, "ChartToolBarSetting.dat");

  0009d	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp_?Format@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAAXPBDZZ
  000a3	8d 45 c8	 lea	 eax, DWORD PTR _strConfigPath$[ebp]
  000a6	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@OIIEJFGC@ChartToolBarSetting?4dat@
  000ab	ff 75 b4	 push	 DWORD PTR _strPath$[ebp]
  000ae	68 00 00 00 00	 push	 OFFSET ??_C@_05BMGBEOOC@?$CFs?2?$CFs@
  000b3	50		 push	 eax
  000b4	ff d6		 call	 esi
  000b6	83 c4 10	 add	 esp, 16			; 00000010H

; 105  : 
; 106  : 	CString strVersion;

  000b9	8d 4d b0	 lea	 ecx, DWORD PTR _strVersion$[ebp]
  000bc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 107  : 	strVersion.Format("%d", m_nDataVer);

  000c2	ff b7 40 01 00
	00		 push	 DWORD PTR [edi+320]
  000c8	8d 45 b0	 lea	 eax, DWORD PTR _strVersion$[ebp]
  000cb	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  000cf	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  000d4	50		 push	 eax
  000d5	ff d6		 call	 esi

; 108  : 	::WritePrivateProfileString("TOTAL", "VERSION", strVersion, strConfigPath);

  000d7	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__WritePrivateProfileStringA@16
  000dd	83 c4 0c	 add	 esp, 12			; 0000000cH
  000e0	ff 75 c8	 push	 DWORD PTR _strConfigPath$[ebp]
  000e3	ff 75 b0	 push	 DWORD PTR _strVersion$[ebp]
  000e6	68 00 00 00 00	 push	 OFFSET ??_C@_07NCHCCDCP@VERSION@
  000eb	68 00 00 00 00	 push	 OFFSET ??_C@_05GKHKKECO@TOTAL@
  000f0	ff d3		 call	 ebx

; 109  : 	
; 110  : 	//***********************************************************
; 111  : 	// Anal List Item User file Write
; 112  : 	//***********************************************************
; 113  : 	char szKey[30];
; 114  : 	CString str, strValue, strFieldName;

  000f2	8d 4d b8	 lea	 ecx, DWORD PTR _str$[ebp]
  000f5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  000fb	8d 4d cc	 lea	 ecx, DWORD PTR _strValue$[ebp]
  000fe	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00104	8d 4d bc	 lea	 ecx, DWORD PTR _strFieldName$[ebp]
  00107	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 115  : 	int nCnt = m_arrayAnalIdx.GetSize();

  0010d	8b 87 b4 00 00
	00		 mov	 eax, DWORD PTR [edi+180]

; 116  : 	int nFieldKey;
; 117  : 	
; 118  : 	sprintf(szKey,"%s","ANAL LIST");

  00113	68 00 00 00 00	 push	 OFFSET ??_C@_09NBFPFBIM@ANAL?5LIST@
  00118	89 45 c4	 mov	 DWORD PTR _nCnt$1$[ebp], eax
  0011b	8d 45 d0	 lea	 eax, DWORD PTR _szKey$[ebp]
  0011e	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  00123	50		 push	 eax
  00124	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  00128	e8 00 00 00 00	 call	 _sprintf

; 119  : 
; 120  : 	strValue.Format("%d",nCnt);

  0012d	ff 75 c4	 push	 DWORD PTR _nCnt$1$[ebp]
  00130	8d 45 cc	 lea	 eax, DWORD PTR _strValue$[ebp]
  00133	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  00138	50		 push	 eax
  00139	ff d6		 call	 esi
  0013b	83 c4 18	 add	 esp, 24			; 00000018H

; 121  : 	::WritePrivateProfileString(szKey, "COUNT", strValue, strConfigPath);

  0013e	ff 75 c8	 push	 DWORD PTR _strConfigPath$[ebp]
  00141	8d 45 d0	 lea	 eax, DWORD PTR _szKey$[ebp]
  00144	ff 75 cc	 push	 DWORD PTR _strValue$[ebp]
  00147	68 00 00 00 00	 push	 OFFSET ??_C@_05EFFCCOAM@COUNT@
  0014c	50		 push	 eax
  0014d	ff d3		 call	 ebx

; 122  : 	int i = 0;
; 123  : 	for ( i=0; i < nCnt ; i++)

  0014f	33 db		 xor	 ebx, ebx
  00151	39 5d c4	 cmp	 DWORD PTR _nCnt$1$[ebp], ebx
  00154	0f 8e cc 00 00
	00		 jle	 $LN3@OnApply
  0015a	66 0f 1f 44 00
	00		 npad	 6
$LL4@OnApply:

; 124  : 	{ //CListBox
; 125  : 		str.Format("%02d", i);

  00160	53		 push	 ebx
  00161	8d 45 b8	 lea	 eax, DWORD PTR _str$[ebp]
  00164	68 00 00 00 00	 push	 OFFSET ??_C@_04OGKJMPGK@?$CF02d@
  00169	50		 push	 eax
  0016a	ff d6		 call	 esi
  0016c	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 288  : 	if(nIndex >= 0 && nIndex < m_nSize)

  0016f	85 db		 test	 ebx, ebx
  00171	0f 88 25 03 00
	00		 js	 $LN101@OnApply
  00177	3b 9f b4 00 00
	00		 cmp	 ebx, DWORD PTR [edi+180]
  0017d	0f 8d 19 03 00
	00		 jge	 $LN101@OnApply
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 127  : 		nFieldKey = m_arrayAnalIdx.GetAt(i);

  00183	8b 87 b0 00 00
	00		 mov	 eax, DWORD PTR [edi+176]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 165  : 	ldiv_t HashVal = ldiv((long)(ARG_KEY)key, 127773);

  00189	b9 1d f3 01 00	 mov	 ecx, 127773		; 0001f31dH
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 127  : 		nFieldKey = m_arrayAnalIdx.GetAt(i);

  0018e	8b 04 98	 mov	 eax, DWORD PTR [eax+ebx*4]
  00191	89 45 c0	 mov	 DWORD PTR _nFieldKey$1$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 165  : 	ldiv_t HashVal = ldiv((long)(ARG_KEY)key, 127773);

  00194	99		 cdq
  00195	f7 f9		 idiv	 ecx

; 166  : 	HashVal.rem = 16807 * HashVal.rem - 2836 * HashVal.quot;

  00197	69 ca a7 41 00
	00		 imul	 ecx, edx, 16807
  0019d	69 c0 14 0b 00
	00		 imul	 eax, eax, 2836
  001a3	2b c8		 sub	 ecx, eax

; 1536 : 	if (m_pHashTable == NULL)

  001a5	8d b1 ff ff ff
	7f		 lea	 esi, DWORD PTR [ecx+2147483647]
  001ab	0f 49 f1	 cmovns	 esi, ecx
  001ae	8b 8f ec 00 00
	00		 mov	 ecx, DWORD PTR [edi+236]
  001b4	85 c9		 test	 ecx, ecx
  001b6	74 37		 je	 SHORT $LN162@OnApply

; 291  : }
; 292  : template<class TYPE, class ARG_TYPE>
; 293  : AFX_INLINE const TYPE& CArray<TYPE, ARG_TYPE>::GetAt(INT_PTR nIndex) const
; 294  : {
; 295  : 	ASSERT(nIndex >= 0 && nIndex < m_nSize);
; 296  : 	if(nIndex >= 0 && nIndex < m_nSize)
; 297  : 		return m_pData[nIndex];
; 298  : 	AfxThrowInvalidArgException();
; 299  : }
; 300  : template<class TYPE, class ARG_TYPE>
; 301  : AFX_INLINE void CArray<TYPE, ARG_TYPE>::SetAt(INT_PTR nIndex, ARG_TYPE newElement)
; 302  : {
; 303  : 	ASSERT(nIndex >= 0 && nIndex < m_nSize);
; 304  : 	if(nIndex >= 0 && nIndex < m_nSize)
; 305  : 		m_pData[nIndex] = newElement;
; 306  : 	else
; 307  : 		AfxThrowInvalidArgException();
; 308  : }
; 309  : template<class TYPE, class ARG_TYPE>
; 310  : AFX_INLINE const TYPE& CArray<TYPE, ARG_TYPE>::ElementAt(INT_PTR nIndex) const
; 311  : {
; 312  : 	ASSERT(nIndex >= 0 && nIndex < m_nSize);
; 313  : 	if(nIndex >= 0 && nIndex < m_nSize)
; 314  : 		return m_pData[nIndex];
; 315  : 	AfxThrowInvalidArgException();
; 316  : }
; 317  : template<class TYPE, class ARG_TYPE>
; 318  : AFX_INLINE TYPE& CArray<TYPE, ARG_TYPE>::ElementAt(INT_PTR nIndex)
; 319  : {
; 320  : 	ASSERT(nIndex >= 0 && nIndex < m_nSize);
; 321  : 	if(nIndex >= 0 && nIndex < m_nSize)
; 322  : 		return m_pData[nIndex];
; 323  : 	AfxThrowInvalidArgException();
; 324  : }
; 325  : template<class TYPE, class ARG_TYPE>
; 326  : AFX_INLINE const TYPE* CArray<TYPE, ARG_TYPE>::GetData() const
; 327  : 	{ return (const TYPE*)m_pData; }
; 328  : template<class TYPE, class ARG_TYPE>
; 329  : AFX_INLINE TYPE* CArray<TYPE, ARG_TYPE>::GetData()
; 330  : 	{ return (TYPE*)m_pData; }
; 331  : template<class TYPE, class ARG_TYPE>
; 332  : AFX_INLINE INT_PTR CArray<TYPE, ARG_TYPE>::Add(ARG_TYPE newElement)
; 333  : 	{ INT_PTR nIndex = m_nSize;
; 334  : 		SetAtGrow(nIndex, newElement);
; 335  : 		return nIndex; }
; 336  : template<class TYPE, class ARG_TYPE>
; 337  : AFX_INLINE const TYPE& CArray<TYPE, ARG_TYPE>::operator[](INT_PTR nIndex) const
; 338  : 	{ return GetAt(nIndex); }
; 339  : template<class TYPE, class ARG_TYPE>
; 340  : AFX_INLINE TYPE& CArray<TYPE, ARG_TYPE>::operator[](INT_PTR nIndex)
; 341  : 	{ return ElementAt(nIndex); }
; 342  : 
; 343  : /*============================================================================*/
; 344  : // CArray<TYPE, ARG_TYPE> out-of-line functions
; 345  : 
; 346  : template<class TYPE, class ARG_TYPE>
; 347  : CArray<TYPE, ARG_TYPE>::CArray()
; 348  : {
; 349  : 	m_pData = NULL;
; 350  : 	m_nSize = m_nMaxSize = m_nGrowBy = 0;
; 351  : }
; 352  : 
; 353  : template<class TYPE, class ARG_TYPE>
; 354  : CArray<TYPE, ARG_TYPE>::~CArray()
; 355  : {
; 356  : 	ASSERT_VALID(this);
; 357  : 
; 358  : 	if (m_pData != NULL)
; 359  : 	{
; 360  : 		for( int i = 0; i < m_nSize; i++ )
; 361  : 			(m_pData + i)->~TYPE();
; 362  : 		delete[] (BYTE*)m_pData;
; 363  : 	}
; 364  : }
; 365  : 
; 366  : template<class TYPE, class ARG_TYPE>
; 367  : void CArray<TYPE, ARG_TYPE>::SetSize(INT_PTR nNewSize, INT_PTR nGrowBy)
; 368  : {
; 369  : 	ASSERT_VALID(this);
; 370  : 	ASSERT(nNewSize >= 0);
; 371  : 
; 372  : 	if(nNewSize < 0 )
; 373  : 		AfxThrowInvalidArgException();
; 374  : 
; 375  : 	if (nGrowBy >= 0)
; 376  : 		m_nGrowBy = nGrowBy;  // set new size
; 377  : 
; 378  : 	if (nNewSize == 0)
; 379  : 	{
; 380  : 		// shrink to nothing
; 381  : 		if (m_pData != NULL)
; 382  : 		{
; 383  : 			for( int i = 0; i < m_nSize; i++ )
; 384  : 				(m_pData + i)->~TYPE();
; 385  : 			delete[] (BYTE*)m_pData;
; 386  : 			m_pData = NULL;
; 387  : 		}
; 388  : 		m_nSize = m_nMaxSize = 0;
; 389  : 	}
; 390  : 	else if (m_pData == NULL)
; 391  : 	{
; 392  : 		// create buffer big enough to hold number of requested elements or
; 393  : 		// m_nGrowBy elements, whichever is larger.
; 394  : #ifdef SIZE_T_MAX
; 395  : 		ASSERT(nNewSize <= SIZE_T_MAX/sizeof(TYPE));    // no overflow
; 396  : #endif
; 397  : 		size_t nAllocSize = __max(nNewSize, m_nGrowBy);
; 398  : 		m_pData = (TYPE*) new BYTE[(size_t)nAllocSize * sizeof(TYPE)];
; 399  : 		memset((void*)m_pData, 0, (size_t)nAllocSize * sizeof(TYPE));
; 400  : 		for( int i = 0; i < nNewSize; i++ )
; 401  : #pragma push_macro("new")
; 402  : #undef new
; 403  : 			::new( (void*)( m_pData + i ) ) TYPE;
; 404  : #pragma pop_macro("new")
; 405  : 		m_nSize = nNewSize;
; 406  : 		m_nMaxSize = nAllocSize;
; 407  : 	}
; 408  : 	else if (nNewSize <= m_nMaxSize)
; 409  : 	{
; 410  : 		// it fits
; 411  : 		if (nNewSize > m_nSize)
; 412  : 		{
; 413  : 			// initialize the new elements
; 414  : 			memset((void*)(m_pData + m_nSize), 0, (size_t)(nNewSize-m_nSize) * sizeof(TYPE));
; 415  : 			for( int i = 0; i < nNewSize-m_nSize; i++ )
; 416  : #pragma push_macro("new")
; 417  : #undef new
; 418  : 				::new( (void*)( m_pData + m_nSize + i ) ) TYPE;
; 419  : #pragma pop_macro("new")
; 420  : 		}
; 421  : 		else if (m_nSize > nNewSize)
; 422  : 		{
; 423  : 			// destroy the old elements
; 424  : 			for( int i = 0; i < m_nSize-nNewSize; i++ )
; 425  : 				(m_pData + nNewSize + i)->~TYPE();
; 426  : 		}
; 427  : 		m_nSize = nNewSize;
; 428  : 	}
; 429  : 	else
; 430  : 	{
; 431  : 		// otherwise, grow array
; 432  : 		nGrowBy = m_nGrowBy;
; 433  : 		if (nGrowBy == 0)
; 434  : 		{
; 435  : 			// heuristically determine growth when nGrowBy == 0
; 436  : 			//  (this avoids heap fragmentation in many situations)
; 437  : 			nGrowBy = m_nSize / 8;
; 438  : 			nGrowBy = (nGrowBy < 4) ? 4 : ((nGrowBy > 1024) ? 1024 : nGrowBy);
; 439  : 		}
; 440  : 		INT_PTR nNewMax;
; 441  : 		if (nNewSize < m_nMaxSize + nGrowBy)
; 442  : 			nNewMax = m_nMaxSize + nGrowBy;  // granularity
; 443  : 		else
; 444  : 			nNewMax = nNewSize;  // no slush
; 445  : 
; 446  : 		ASSERT(nNewMax >= m_nMaxSize);  // no wrap around
; 447  : 
; 448  : 		if(nNewMax  < m_nMaxSize)
; 449  : 			AfxThrowInvalidArgException();
; 450  : 
; 451  : #ifdef SIZE_T_MAX
; 452  : 		ASSERT(nNewMax <= SIZE_T_MAX/sizeof(TYPE)); // no overflow
; 453  : #endif
; 454  : 		TYPE* pNewData = (TYPE*) new BYTE[(size_t)nNewMax * sizeof(TYPE)];
; 455  : 
; 456  : 		// copy new data from old
; 457  : 		::ATL::Checked::memcpy_s(pNewData, (size_t)nNewMax * sizeof(TYPE),
; 458  : 			m_pData, (size_t)m_nSize * sizeof(TYPE));
; 459  : 
; 460  : 		// construct remaining elements
; 461  : 		ASSERT(nNewSize > m_nSize);
; 462  : 		memset((void*)(pNewData + m_nSize), 0, (size_t)(nNewSize-m_nSize) * sizeof(TYPE));
; 463  : 		for( int i = 0; i < nNewSize-m_nSize; i++ )
; 464  : #pragma push_macro("new")
; 465  : #undef new
; 466  : 			::new( (void*)( pNewData + m_nSize + i ) ) TYPE;
; 467  : #pragma pop_macro("new")
; 468  : 
; 469  : 		// get rid of old stuff (note: no destructors called)
; 470  : 		delete[] (BYTE*)m_pData;
; 471  : 		m_pData = pNewData;
; 472  : 		m_nSize = nNewSize;
; 473  : 		m_nMaxSize = nNewMax;
; 474  : 	}
; 475  : }
; 476  : 
; 477  : template<class TYPE, class ARG_TYPE>
; 478  : INT_PTR CArray<TYPE, ARG_TYPE>::Append(const CArray& src)
; 479  : {
; 480  : 	ASSERT_VALID(this);
; 481  : 	ASSERT(this != &src);   // cannot append to itself
; 482  : 
; 483  : 	if(this == &src)
; 484  : 		AfxThrowInvalidArgException();
; 485  : 
; 486  : 	INT_PTR nOldSize = m_nSize;
; 487  : 	SetSize(m_nSize + src.m_nSize);
; 488  : 	CopyElements<TYPE>(m_pData + nOldSize, src.m_pData, src.m_nSize);
; 489  : 	return nOldSize;
; 490  : }
; 491  : 
; 492  : template<class TYPE, class ARG_TYPE>
; 493  : void CArray<TYPE, ARG_TYPE>::Copy(const CArray& src)
; 494  : {
; 495  : 	ASSERT_VALID(this);
; 496  : 	ASSERT(this != &src);   // cannot append to itself
; 497  : 
; 498  : 	if(this != &src)
; 499  : 	{
; 500  : 		SetSize(src.m_nSize);
; 501  : 		CopyElements<TYPE>(m_pData, src.m_pData, src.m_nSize);
; 502  : 	}
; 503  : }
; 504  : 
; 505  : template<class TYPE, class ARG_TYPE>
; 506  : void CArray<TYPE, ARG_TYPE>::FreeExtra()
; 507  : {
; 508  : 	ASSERT_VALID(this);
; 509  : 
; 510  : 	if (m_nSize != m_nMaxSize)
; 511  : 	{
; 512  : 		// shrink to desired size
; 513  : #ifdef SIZE_T_MAX
; 514  : 		ASSERT(m_nSize <= SIZE_T_MAX/sizeof(TYPE)); // no overflow
; 515  : #endif
; 516  : 		TYPE* pNewData = NULL;
; 517  : 		if (m_nSize != 0)
; 518  : 		{
; 519  : 			pNewData = (TYPE*) new BYTE[m_nSize * sizeof(TYPE)];
; 520  : 			// copy new data from old
; 521  : 			::ATL::Checked::memcpy_s(pNewData, m_nSize * sizeof(TYPE),
; 522  : 				m_pData, m_nSize * sizeof(TYPE));
; 523  : 		}
; 524  : 
; 525  : 		// get rid of old stuff (note: no destructors called)
; 526  : 		delete[] (BYTE*)m_pData;
; 527  : 		m_pData = pNewData;
; 528  : 		m_nMaxSize = m_nSize;
; 529  : 	}
; 530  : }
; 531  : 
; 532  : template<class TYPE, class ARG_TYPE>
; 533  : void CArray<TYPE, ARG_TYPE>::SetAtGrow(INT_PTR nIndex, ARG_TYPE newElement)
; 534  : {
; 535  : 	ASSERT_VALID(this);
; 536  : 	ASSERT(nIndex >= 0);
; 537  : 
; 538  : 	if(nIndex < 0)
; 539  : 		AfxThrowInvalidArgException();
; 540  : 
; 541  : 	if (nIndex >= m_nSize)
; 542  : 		SetSize(nIndex+1, -1);
; 543  : 	m_pData[nIndex] = newElement;
; 544  : }
; 545  : 
; 546  : template<class TYPE, class ARG_TYPE>
; 547  : void CArray<TYPE, ARG_TYPE>::InsertAt(INT_PTR nIndex, ARG_TYPE newElement, INT_PTR nCount /*=1*/)
; 548  : {
; 549  : 	ASSERT_VALID(this);
; 550  : 	ASSERT(nIndex >= 0);    // will expand to meet need
; 551  : 	ASSERT(nCount > 0);     // zero or negative size not allowed
; 552  : 
; 553  : 	if(nIndex < 0 || nCount <= 0)
; 554  : 		AfxThrowInvalidArgException();
; 555  : 
; 556  : 	if (nIndex >= m_nSize)
; 557  : 	{
; 558  : 		// adding after the end of the array
; 559  : 		SetSize(nIndex + nCount, -1);   // grow so nIndex is valid
; 560  : 	}
; 561  : 	else
; 562  : 	{
; 563  : 		// inserting in the middle of the array
; 564  : 		INT_PTR nOldSize = m_nSize;
; 565  : 		SetSize(m_nSize + nCount, -1);  // grow it to new size
; 566  : 		// destroy intial data before copying over it
; 567  : 		for( int i = 0; i < nCount; i++ )
; 568  : 			(m_pData + nOldSize + i)->~TYPE();
; 569  : 		// shift old data up to fill gap
; 570  : 		::ATL::Checked::memmove_s(m_pData + nIndex + nCount, (nOldSize-nIndex) * sizeof(TYPE),
; 571  : 			m_pData + nIndex, (nOldSize-nIndex) * sizeof(TYPE));
; 572  : 
; 573  : 		// re-init slots we copied from
; 574  : 		memset((void*)(m_pData + nIndex), 0, (size_t)nCount * sizeof(TYPE));
; 575  : 		for( int i = 0; i < nCount; i++ )
; 576  : #pragma push_macro("new")
; 577  : #undef new
; 578  : 			::new( (void*)( m_pData + nIndex + i ) ) TYPE;
; 579  : #pragma pop_macro("new")
; 580  : 	}
; 581  : 
; 582  : 	// insert new value in the gap
; 583  : 	ASSERT(nIndex + nCount <= m_nSize);
; 584  : 	while (nCount--)
; 585  : 		m_pData[nIndex++] = newElement;
; 586  : }
; 587  : 
; 588  : template<class TYPE, class ARG_TYPE>
; 589  : void CArray<TYPE, ARG_TYPE>::RemoveAt(INT_PTR nIndex, INT_PTR nCount)
; 590  : {
; 591  : 	ASSERT_VALID(this);
; 592  : 	ASSERT(nIndex >= 0);
; 593  : 	ASSERT(nCount >= 0);
; 594  : 	INT_PTR nUpperBound = nIndex + nCount;
; 595  : 	ASSERT(nUpperBound <= m_nSize && nUpperBound >= nIndex && nUpperBound >= nCount);
; 596  : 
; 597  : 	if(nIndex < 0 || nCount < 0 || (nUpperBound > m_nSize) || (nUpperBound < nIndex) || (nUpperBound < nCount))
; 598  : 		AfxThrowInvalidArgException();
; 599  : 
; 600  : 	// just remove a range
; 601  : 	INT_PTR nMoveCount = m_nSize - (nUpperBound);
; 602  : 	for( int i = 0; i < nCount; i++ )
; 603  : 		(m_pData + nIndex + i)->~TYPE();
; 604  : 	if (nMoveCount)
; 605  : 	{
; 606  : 		::ATL::Checked::memmove_s(m_pData + nIndex, (size_t)nMoveCount * sizeof(TYPE),
; 607  : 			m_pData + nUpperBound, (size_t)nMoveCount * sizeof(TYPE));
; 608  : 	}
; 609  : 	m_nSize -= nCount;
; 610  : }
; 611  : 
; 612  : template<class TYPE, class ARG_TYPE>
; 613  : void CArray<TYPE, ARG_TYPE>::InsertAt(INT_PTR nStartIndex, CArray* pNewArray)
; 614  : {
; 615  : 	ASSERT_VALID(this);
; 616  : 	ASSERT(pNewArray != NULL);
; 617  : 	ASSERT_VALID(pNewArray);
; 618  : 	ASSERT(nStartIndex >= 0);
; 619  : 
; 620  : 	if(pNewArray == NULL || nStartIndex < 0)
; 621  : 		AfxThrowInvalidArgException();
; 622  : 
; 623  : 	if (pNewArray->GetSize() > 0)
; 624  : 	{
; 625  : 		InsertAt(nStartIndex, pNewArray->GetAt(0), pNewArray->GetSize());
; 626  : 		for (INT_PTR i = 0; i < pNewArray->GetSize(); i++)
; 627  : 			SetAt(nStartIndex + i, pNewArray->GetAt(i));
; 628  : 	}
; 629  : }
; 630  : 
; 631  : template<class TYPE, class ARG_TYPE>
; 632  : void CArray<TYPE, ARG_TYPE>::Serialize(CArchive& ar)
; 633  : {
; 634  : 	ASSERT_VALID(this);
; 635  : 
; 636  : 	CObject::Serialize(ar);
; 637  : 	if (ar.IsStoring())
; 638  : 	{
; 639  : 		ar.WriteCount(m_nSize);
; 640  : 	}
; 641  : 	else
; 642  : 	{
; 643  : 		DWORD_PTR nOldSize = ar.ReadCount();
; 644  : 		SetSize(nOldSize, -1);
; 645  : 	}
; 646  : 	SerializeElements<TYPE>(ar, m_pData, m_nSize);
; 647  : }
; 648  : 
; 649  : #ifdef _DEBUG
; 650  : template<class TYPE, class ARG_TYPE>
; 651  : void CArray<TYPE, ARG_TYPE>::Dump(CDumpContext& dc) const
; 652  : {
; 653  : 	CObject::Dump(dc);
; 654  : 
; 655  : 	dc << "with " << m_nSize << " elements";
; 656  : 	if (dc.GetDepth() > 0)
; 657  : 	{
; 658  : 		dc << "\n";
; 659  : 		DumpElements<TYPE>(dc, m_pData, m_nSize);
; 660  : 	}
; 661  : 
; 662  : 	dc << "\n";
; 663  : }
; 664  : 
; 665  : template<class TYPE, class ARG_TYPE>
; 666  : void CArray<TYPE, ARG_TYPE>::AssertValid() const
; 667  : {
; 668  : 	CObject::AssertValid();
; 669  : 
; 670  : 	if (m_pData == NULL)
; 671  : 	{
; 672  : 		ASSERT(m_nSize == 0);
; 673  : 		ASSERT(m_nMaxSize == 0);
; 674  : 	}
; 675  : 	else
; 676  : 	{
; 677  : 		ASSERT(m_nSize >= 0);
; 678  : 		ASSERT(m_nMaxSize >= 0);
; 679  : 		ASSERT(m_nSize <= m_nMaxSize);
; 680  : 		ASSERT(AfxIsValidAddress(m_pData, m_nMaxSize * sizeof(TYPE)));
; 681  : 	}
; 682  : }
; 683  : #endif //_DEBUG
; 684  : 
; 685  : /*============================================================================*/
; 686  : // CList<TYPE, ARG_TYPE>
; 687  : 
; 688  : template<class TYPE, class ARG_TYPE = const TYPE&>
; 689  : class CList : public CObject
; 690  : {
; 691  : protected:
; 692  : 	struct CNode
; 693  : 	{
; 694  : 		CNode* pNext;
; 695  : 		CNode* pPrev;
; 696  : 		TYPE data;
; 697  : 	};
; 698  : public:
; 699  : // Construction
; 700  : 	explicit CList(INT_PTR nBlockSize = 10);
; 701  : 
; 702  : // Attributes (head and tail)
; 703  : 	// count of elements
; 704  : 	INT_PTR GetCount() const;
; 705  : 	INT_PTR GetSize() const;
; 706  : 	BOOL IsEmpty() const;
; 707  : 
; 708  : 	// peek at head or tail
; 709  : 	TYPE& GetHead();
; 710  : 	const TYPE& GetHead() const;
; 711  : 	TYPE& GetTail();
; 712  : 	const TYPE& GetTail() const;
; 713  : 
; 714  : // Operations
; 715  : 	// get head or tail (and remove it) - don't call on empty list !
; 716  : 	TYPE RemoveHead();
; 717  : 	TYPE RemoveTail();
; 718  : 
; 719  : 	// add before head or after tail
; 720  : 	POSITION AddHead(ARG_TYPE newElement);
; 721  : 	POSITION AddTail(ARG_TYPE newElement);
; 722  : 
; 723  : 	// add another list of elements before head or after tail
; 724  : 	void AddHead(CList* pNewList);
; 725  : 	void AddTail(CList* pNewList);
; 726  : 
; 727  : 	// remove all elements
; 728  : 	void RemoveAll();
; 729  : 
; 730  : 	// iteration
; 731  : 	POSITION GetHeadPosition() const;
; 732  : 	POSITION GetTailPosition() const;
; 733  : 	TYPE& GetNext(POSITION& rPosition); // return *Position++
; 734  : 	const TYPE& GetNext(POSITION& rPosition) const; // return *Position++
; 735  : 	TYPE& GetPrev(POSITION& rPosition); // return *Position--
; 736  : 	const TYPE& GetPrev(POSITION& rPosition) const; // return *Position--
; 737  : 
; 738  : 	// getting/modifying an element at a given position
; 739  : 	TYPE& GetAt(POSITION position);
; 740  : 	const TYPE& GetAt(POSITION position) const;
; 741  : 	void SetAt(POSITION pos, ARG_TYPE newElement);
; 742  : 	void RemoveAt(POSITION position);
; 743  : 
; 744  : 	// inserting before or after a given position
; 745  : 	POSITION InsertBefore(POSITION position, ARG_TYPE newElement);
; 746  : 	POSITION InsertAfter(POSITION position, ARG_TYPE newElement);
; 747  : 
; 748  : 	// helper functions (note: O(n) speed)
; 749  : 	POSITION Find(ARG_TYPE searchValue, POSITION startAfter = NULL) const;
; 750  : 		// defaults to starting at the HEAD, return NULL if not found
; 751  : 	POSITION FindIndex(INT_PTR nIndex) const;
; 752  : 		// get the 'nIndex'th element (may return NULL)
; 753  : 
; 754  : // Implementation
; 755  : protected:
; 756  : 	CNode* m_pNodeHead;
; 757  : 	CNode* m_pNodeTail;
; 758  : 	INT_PTR m_nCount;
; 759  : 	CNode* m_pNodeFree;
; 760  : 	struct CPlex* m_pBlocks;
; 761  : 	INT_PTR m_nBlockSize;
; 762  : 
; 763  : 	CNode* NewNode(CNode*, CNode*);
; 764  : 	void FreeNode(CNode*);
; 765  : 
; 766  : public:
; 767  : 	~CList();
; 768  : 	void Serialize(CArchive&);
; 769  : #ifdef _DEBUG
; 770  : 	void Dump(CDumpContext&) const;
; 771  : 	void AssertValid() const;
; 772  : #endif
; 773  : };
; 774  : 
; 775  : /*============================================================================*/
; 776  : // CList<TYPE, ARG_TYPE> inline functions
; 777  : 
; 778  : template<class TYPE, class ARG_TYPE>
; 779  : AFX_INLINE INT_PTR CList<TYPE, ARG_TYPE>::GetCount() const
; 780  : 	{ return m_nCount; }
; 781  : template<class TYPE, class ARG_TYPE>
; 782  : AFX_INLINE INT_PTR CList<TYPE, ARG_TYPE>::GetSize() const
; 783  : 	{ return m_nCount; }
; 784  : template<class TYPE, class ARG_TYPE>
; 785  : AFX_INLINE BOOL CList<TYPE, ARG_TYPE>::IsEmpty() const
; 786  : 	{ return m_nCount == 0; }
; 787  : template<class TYPE, class ARG_TYPE>
; 788  : AFX_INLINE TYPE& CList<TYPE, ARG_TYPE>::GetHead()
; 789  : 	{ ENSURE(m_pNodeHead != NULL);
; 790  : 		return m_pNodeHead->data; }
; 791  : template<class TYPE, class ARG_TYPE>
; 792  : AFX_INLINE const TYPE& CList<TYPE, ARG_TYPE>::GetHead() const
; 793  : 	{ ENSURE(m_pNodeHead != NULL);
; 794  : 		return m_pNodeHead->data; }
; 795  : template<class TYPE, class ARG_TYPE>
; 796  : AFX_INLINE TYPE& CList<TYPE, ARG_TYPE>::GetTail()
; 797  : 	{ ENSURE(m_pNodeTail != NULL);
; 798  : 		return m_pNodeTail->data; }
; 799  : template<class TYPE, class ARG_TYPE>
; 800  : AFX_INLINE const TYPE& CList<TYPE, ARG_TYPE>::GetTail() const
; 801  : 	{ ENSURE(m_pNodeTail != NULL);
; 802  : 		return m_pNodeTail->data; }
; 803  : template<class TYPE, class ARG_TYPE>
; 804  : AFX_INLINE POSITION CList<TYPE, ARG_TYPE>::GetHeadPosition() const
; 805  : 	{ return (POSITION) m_pNodeHead; }
; 806  : template<class TYPE, class ARG_TYPE>
; 807  : AFX_INLINE POSITION CList<TYPE, ARG_TYPE>::GetTailPosition() const
; 808  : 	{ return (POSITION) m_pNodeTail; }
; 809  : template<class TYPE, class ARG_TYPE>
; 810  : AFX_INLINE TYPE& CList<TYPE, ARG_TYPE>::GetNext(POSITION& rPosition) // return *Position++
; 811  : 	{ CNode* pNode = (CNode*) rPosition;
; 812  : 		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 813  : 		rPosition = (POSITION) pNode->pNext;
; 814  : 		return pNode->data; }
; 815  : template<class TYPE, class ARG_TYPE>
; 816  : AFX_INLINE const TYPE& CList<TYPE, ARG_TYPE>::GetNext(POSITION& rPosition) const // return *Position++
; 817  : 	{ CNode* pNode = (CNode*) rPosition;
; 818  : 		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 819  : 		rPosition = (POSITION) pNode->pNext;
; 820  : 		return pNode->data; }
; 821  : template<class TYPE, class ARG_TYPE>
; 822  : AFX_INLINE TYPE& CList<TYPE, ARG_TYPE>::GetPrev(POSITION& rPosition) // return *Position--
; 823  : 	{ CNode* pNode = (CNode*) rPosition;
; 824  : 		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 825  : 		rPosition = (POSITION) pNode->pPrev;
; 826  : 		return pNode->data; }
; 827  : template<class TYPE, class ARG_TYPE>
; 828  : AFX_INLINE const TYPE& CList<TYPE, ARG_TYPE>::GetPrev(POSITION& rPosition) const // return *Position--
; 829  : 	{ CNode* pNode = (CNode*) rPosition;
; 830  : 		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 831  : 		rPosition = (POSITION) pNode->pPrev;
; 832  : 		return pNode->data; }
; 833  : template<class TYPE, class ARG_TYPE>
; 834  : AFX_INLINE TYPE& CList<TYPE, ARG_TYPE>::GetAt(POSITION position)
; 835  : 	{ CNode* pNode = (CNode*) position;
; 836  : 		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 837  : 		return pNode->data; }
; 838  : template<class TYPE, class ARG_TYPE>
; 839  : AFX_INLINE const TYPE& CList<TYPE, ARG_TYPE>::GetAt(POSITION position) const
; 840  : 	{ CNode* pNode = (CNode*) position;
; 841  : 		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 842  : 		return pNode->data; }
; 843  : template<class TYPE, class ARG_TYPE>
; 844  : AFX_INLINE void CList<TYPE, ARG_TYPE>::SetAt(POSITION pos, ARG_TYPE newElement)
; 845  : 	{ CNode* pNode = (CNode*) pos;
; 846  : 		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 847  : 		pNode->data = newElement; }
; 848  : 
; 849  : template<class TYPE, class ARG_TYPE>
; 850  : CList<TYPE, ARG_TYPE>::CList(INT_PTR nBlockSize)
; 851  : {
; 852  : 	ASSERT(nBlockSize > 0);
; 853  : 
; 854  : 	m_nCount = 0;
; 855  : 	m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
; 856  : 	m_pBlocks = NULL;
; 857  : 	m_nBlockSize = nBlockSize;
; 858  : }
; 859  : 
; 860  : template<class TYPE, class ARG_TYPE>
; 861  : void CList<TYPE, ARG_TYPE>::RemoveAll()
; 862  : {
; 863  : 	ASSERT_VALID(this);
; 864  : 
; 865  : 	// destroy elements
; 866  : 	CNode* pNode;
; 867  : 	for (pNode = m_pNodeHead; pNode != NULL; pNode = pNode->pNext)
; 868  : 		pNode->data.~TYPE();
; 869  : 
; 870  : 	m_nCount = 0;
; 871  : 	m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
; 872  : 	m_pBlocks->FreeDataChain();
; 873  : 	m_pBlocks = NULL;
; 874  : }
; 875  : 
; 876  : template<class TYPE, class ARG_TYPE>
; 877  : CList<TYPE, ARG_TYPE>::~CList()
; 878  : {
; 879  : 	RemoveAll();
; 880  : 	ASSERT(m_nCount == 0);
; 881  : }
; 882  : 
; 883  : /*============================================================================*/
; 884  : // Node helpers
; 885  : //
; 886  : // Implementation note: CNode's are stored in CPlex blocks and
; 887  : //  chained together. Free blocks are maintained in a singly linked list
; 888  : //  using the 'pNext' member of CNode with 'm_pNodeFree' as the head.
; 889  : //  Used blocks are maintained in a doubly linked list using both 'pNext'
; 890  : //  and 'pPrev' as links and 'm_pNodeHead' and 'm_pNodeTail'
; 891  : //   as the head/tail.
; 892  : //
; 893  : // We never free a CPlex block unless the List is destroyed or RemoveAll()
; 894  : //  is used - so the total number of CPlex blocks may grow large depending
; 895  : //  on the maximum past size of the list.
; 896  : //
; 897  : 
; 898  : template<class TYPE, class ARG_TYPE>
; 899  : typename CList<TYPE, ARG_TYPE>::CNode*
; 900  : CList<TYPE, ARG_TYPE>::NewNode(CNode* pPrev, CNode* pNext)
; 901  : {
; 902  : 	if (m_pNodeFree == NULL)
; 903  : 	{
; 904  : 		// add another block
; 905  : 		CPlex* pNewBlock = CPlex::Create(m_pBlocks, m_nBlockSize,
; 906  : 				 sizeof(CNode));
; 907  : 
; 908  : 		// chain them into free list
; 909  : 		CNode* pNode = (CNode*) pNewBlock->data();
; 910  : 		// free in reverse order to make it easier to debug
; 911  : 		pNode += m_nBlockSize - 1;
; 912  : 		for (INT_PTR i = m_nBlockSize-1; i >= 0; i--, pNode--)
; 913  : 		{
; 914  : 			pNode->pNext = m_pNodeFree;
; 915  : 			m_pNodeFree = pNode;
; 916  : 		}
; 917  : 	}
; 918  : 	ENSURE(m_pNodeFree != NULL);  // we must have something
; 919  : 
; 920  : 	CList::CNode* pNode = m_pNodeFree;
; 921  : 	m_pNodeFree = m_pNodeFree->pNext;
; 922  : 	pNode->pPrev = pPrev;
; 923  : 	pNode->pNext = pNext;
; 924  : 	m_nCount++;
; 925  : 	ASSERT(m_nCount > 0);  // make sure we don't overflow
; 926  : 
; 927  : #pragma push_macro("new")
; 928  : #undef new
; 929  : 	::new( (void*)( &pNode->data ) ) TYPE;
; 930  : #pragma pop_macro("new")
; 931  : 	return pNode;
; 932  : }
; 933  : 
; 934  : template<class TYPE, class ARG_TYPE>
; 935  : void CList<TYPE, ARG_TYPE>::FreeNode(CNode* pNode)
; 936  : {
; 937  : 	pNode->data.~TYPE();
; 938  : 	pNode->pNext = m_pNodeFree;
; 939  : 	m_pNodeFree = pNode;
; 940  : 	m_nCount--;
; 941  : 	ASSERT(m_nCount >= 0);  // make sure we don't underflow
; 942  : 
; 943  : 	// if no more elements, cleanup completely
; 944  : 	if (m_nCount == 0)
; 945  : 		RemoveAll();
; 946  : }
; 947  : 
; 948  : template<class TYPE, class ARG_TYPE>
; 949  : POSITION CList<TYPE, ARG_TYPE>::AddHead(ARG_TYPE newElement)
; 950  : {
; 951  : 	ASSERT_VALID(this);
; 952  : 
; 953  : 	CNode* pNewNode = NewNode(NULL, m_pNodeHead);
; 954  : 	pNewNode->data = newElement;
; 955  : 	if (m_pNodeHead != NULL)
; 956  : 		m_pNodeHead->pPrev = pNewNode;
; 957  : 	else
; 958  : 		m_pNodeTail = pNewNode;
; 959  : 	m_pNodeHead = pNewNode;
; 960  : 	return (POSITION) pNewNode;
; 961  : }
; 962  : 
; 963  : template<class TYPE, class ARG_TYPE>
; 964  : POSITION CList<TYPE, ARG_TYPE>::AddTail(ARG_TYPE newElement)
; 965  : {
; 966  : 	ASSERT_VALID(this);
; 967  : 
; 968  : 	CNode* pNewNode = NewNode(m_pNodeTail, NULL);
; 969  : 	pNewNode->data = newElement;
; 970  : 	if (m_pNodeTail != NULL)
; 971  : 		m_pNodeTail->pNext = pNewNode;
; 972  : 	else
; 973  : 		m_pNodeHead = pNewNode;
; 974  : 	m_pNodeTail = pNewNode;
; 975  : 	return (POSITION) pNewNode;
; 976  : }
; 977  : 
; 978  : template<class TYPE, class ARG_TYPE>
; 979  : void CList<TYPE, ARG_TYPE>::AddHead(CList* pNewList)
; 980  : {
; 981  : 	ASSERT_VALID(this);
; 982  : 
; 983  : 	ENSURE(pNewList != NULL);
; 984  : 	ASSERT_VALID(pNewList);
; 985  : 
; 986  : 	// add a list of same elements to head (maintain order)
; 987  : 	POSITION pos = pNewList->GetTailPosition();
; 988  : 	while (pos != NULL)
; 989  : 		AddHead(pNewList->GetPrev(pos));
; 990  : }
; 991  : 
; 992  : template<class TYPE, class ARG_TYPE>
; 993  : void CList<TYPE, ARG_TYPE>::AddTail(CList* pNewList)
; 994  : {
; 995  : 	ASSERT_VALID(this);
; 996  : 	ENSURE(pNewList != NULL);
; 997  : 	ASSERT_VALID(pNewList);
; 998  : 
; 999  : 	// add a list of same elements
; 1000 : 	POSITION pos = pNewList->GetHeadPosition();
; 1001 : 	while (pos != NULL)
; 1002 : 		AddTail(pNewList->GetNext(pos));
; 1003 : }
; 1004 : 
; 1005 : template<class TYPE, class ARG_TYPE>
; 1006 : TYPE CList<TYPE, ARG_TYPE>::RemoveHead()
; 1007 : {
; 1008 : 	ASSERT_VALID(this);
; 1009 : 	ENSURE(m_pNodeHead != NULL);  // don't call on empty list !!!
; 1010 : 	ASSERT(AfxIsValidAddress(m_pNodeHead, sizeof(CNode)));
; 1011 : 
; 1012 : 	CNode* pOldNode = m_pNodeHead;
; 1013 : 	TYPE returnValue = pOldNode->data;
; 1014 : 
; 1015 : 	m_pNodeHead = pOldNode->pNext;
; 1016 : 	if (m_pNodeHead != NULL)
; 1017 : 		m_pNodeHead->pPrev = NULL;
; 1018 : 	else
; 1019 : 		m_pNodeTail = NULL;
; 1020 : 	FreeNode(pOldNode);
; 1021 : 	return returnValue;
; 1022 : }
; 1023 : 
; 1024 : template<class TYPE, class ARG_TYPE>
; 1025 : TYPE CList<TYPE, ARG_TYPE>::RemoveTail()
; 1026 : {
; 1027 : 	ASSERT_VALID(this);
; 1028 : 	ENSURE(m_pNodeTail != NULL);  // don't call on empty list !!!
; 1029 : 	ASSERT(AfxIsValidAddress(m_pNodeTail, sizeof(CNode)));
; 1030 : 
; 1031 : 	CNode* pOldNode = m_pNodeTail;
; 1032 : 	TYPE returnValue = pOldNode->data;
; 1033 : 
; 1034 : 	m_pNodeTail = pOldNode->pPrev;
; 1035 : 	if (m_pNodeTail != NULL)
; 1036 : 		m_pNodeTail->pNext = NULL;
; 1037 : 	else
; 1038 : 		m_pNodeHead = NULL;
; 1039 : 	FreeNode(pOldNode);
; 1040 : 	return returnValue;
; 1041 : }
; 1042 : 
; 1043 : template<class TYPE, class ARG_TYPE>
; 1044 : POSITION CList<TYPE, ARG_TYPE>::InsertBefore(POSITION position, ARG_TYPE newElement)
; 1045 : {
; 1046 : 	ASSERT_VALID(this);
; 1047 : 
; 1048 : 	if (position == NULL)
; 1049 : 		return AddHead(newElement); // insert before nothing -> head of the list
; 1050 : 
; 1051 : 	// Insert it before position
; 1052 : 	CNode* pOldNode = (CNode*) position;
; 1053 : 	CNode* pNewNode = NewNode(pOldNode->pPrev, pOldNode);
; 1054 : 	pNewNode->data = newElement;
; 1055 : 
; 1056 : 	if (pOldNode->pPrev != NULL)
; 1057 : 	{
; 1058 : 		ASSERT(AfxIsValidAddress(pOldNode->pPrev, sizeof(CNode)));
; 1059 : 		pOldNode->pPrev->pNext = pNewNode;
; 1060 : 	}
; 1061 : 	else
; 1062 : 	{
; 1063 : 		ASSERT(pOldNode == m_pNodeHead);
; 1064 : 		m_pNodeHead = pNewNode;
; 1065 : 	}
; 1066 : 	pOldNode->pPrev = pNewNode;
; 1067 : 	return (POSITION) pNewNode;
; 1068 : }
; 1069 : 
; 1070 : template<class TYPE, class ARG_TYPE>
; 1071 : POSITION CList<TYPE, ARG_TYPE>::InsertAfter(POSITION position, ARG_TYPE newElement)
; 1072 : {
; 1073 : 	ASSERT_VALID(this);
; 1074 : 
; 1075 : 	if (position == NULL)
; 1076 : 		return AddTail(newElement); // insert after nothing -> tail of the list
; 1077 : 
; 1078 : 	// Insert it before position
; 1079 : 	CNode* pOldNode = (CNode*) position;
; 1080 : 	ASSERT(AfxIsValidAddress(pOldNode, sizeof(CNode)));
; 1081 : 	CNode* pNewNode = NewNode(pOldNode, pOldNode->pNext);
; 1082 : 	pNewNode->data = newElement;
; 1083 : 
; 1084 : 	if (pOldNode->pNext != NULL)
; 1085 : 	{
; 1086 : 		ASSERT(AfxIsValidAddress(pOldNode->pNext, sizeof(CNode)));
; 1087 : 		pOldNode->pNext->pPrev = pNewNode;
; 1088 : 	}
; 1089 : 	else
; 1090 : 	{
; 1091 : 		ASSERT(pOldNode == m_pNodeTail);
; 1092 : 		m_pNodeTail = pNewNode;
; 1093 : 	}
; 1094 : 	pOldNode->pNext = pNewNode;
; 1095 : 	return (POSITION) pNewNode;
; 1096 : }
; 1097 : 
; 1098 : template<class TYPE, class ARG_TYPE>
; 1099 : void CList<TYPE, ARG_TYPE>::RemoveAt(POSITION position)
; 1100 : {
; 1101 : 	ASSERT_VALID(this);
; 1102 : 
; 1103 : 	CNode* pOldNode = (CNode*) position;
; 1104 : 	ASSERT(AfxIsValidAddress(pOldNode, sizeof(CNode)));
; 1105 : 
; 1106 : 	// remove pOldNode from list
; 1107 : 	if (pOldNode == m_pNodeHead)
; 1108 : 	{
; 1109 : 		m_pNodeHead = pOldNode->pNext;
; 1110 : 	}
; 1111 : 	else
; 1112 : 	{
; 1113 : 		ASSERT(AfxIsValidAddress(pOldNode->pPrev, sizeof(CNode)));
; 1114 : 		pOldNode->pPrev->pNext = pOldNode->pNext;
; 1115 : 	}
; 1116 : 	if (pOldNode == m_pNodeTail)
; 1117 : 	{
; 1118 : 		m_pNodeTail = pOldNode->pPrev;
; 1119 : 	}
; 1120 : 	else
; 1121 : 	{
; 1122 : 		ASSERT(AfxIsValidAddress(pOldNode->pNext, sizeof(CNode)));
; 1123 : 		pOldNode->pNext->pPrev = pOldNode->pPrev;
; 1124 : 	}
; 1125 : 	FreeNode(pOldNode);
; 1126 : }
; 1127 : 
; 1128 : template<class TYPE, class ARG_TYPE>
; 1129 : POSITION CList<TYPE, ARG_TYPE>::FindIndex(INT_PTR nIndex) const
; 1130 : {
; 1131 : 	ASSERT_VALID(this);
; 1132 : 
; 1133 : 	if (nIndex >= m_nCount || nIndex < 0)
; 1134 : 		return NULL;  // went too far
; 1135 : 
; 1136 : 	CNode* pNode = m_pNodeHead;
; 1137 : 	while (nIndex--)
; 1138 : 	{
; 1139 : 		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 1140 : 		pNode = pNode->pNext;
; 1141 : 	}
; 1142 : 	return (POSITION) pNode;
; 1143 : }
; 1144 : 
; 1145 : template<class TYPE, class ARG_TYPE>
; 1146 : POSITION CList<TYPE, ARG_TYPE>::Find(ARG_TYPE searchValue, POSITION startAfter) const
; 1147 : {
; 1148 : 	ASSERT_VALID(this);
; 1149 : 
; 1150 : 	CNode* pNode = (CNode*) startAfter;
; 1151 : 	if (pNode == NULL)
; 1152 : 	{
; 1153 : 		pNode = m_pNodeHead;  // start at head
; 1154 : 	}
; 1155 : 	else
; 1156 : 	{
; 1157 : 		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 1158 : 		pNode = pNode->pNext;  // start after the one specified
; 1159 : 	}
; 1160 : 
; 1161 : 	for (; pNode != NULL; pNode = pNode->pNext)
; 1162 : 		if (CompareElements<TYPE>(&pNode->data, &searchValue))
; 1163 : 			return (POSITION)pNode;
; 1164 : 	return NULL;
; 1165 : }
; 1166 : 
; 1167 : template<class TYPE, class ARG_TYPE>
; 1168 : void CList<TYPE, ARG_TYPE>::Serialize(CArchive& ar)
; 1169 : {
; 1170 : 	ASSERT_VALID(this);
; 1171 : 
; 1172 : 	CObject::Serialize(ar);
; 1173 : 
; 1174 : 	if (ar.IsStoring())
; 1175 : 	{
; 1176 : 		ar.WriteCount(m_nCount);
; 1177 : 		for (CNode* pNode = m_pNodeHead; pNode != NULL; pNode = pNode->pNext)
; 1178 : 		{
; 1179 : 			ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 1180 : 			TYPE* pData;
; 1181 : 			/*
; 1182 : 			 * in some cases the & operator might be overloaded, and we cannot use it to obtain
; 1183 : 			 * the address of a given object.  We then use the following trick to get the address
; 1184 : 			 */
; 1185 : 			pData = reinterpret_cast< TYPE* >( &reinterpret_cast< int& >( static_cast< TYPE& >( pNode->data ) ) );
; 1186 : 			SerializeElements<TYPE>(ar, pData, 1);
; 1187 : 		}
; 1188 : 	}
; 1189 : 	else
; 1190 : 	{
; 1191 : 		DWORD_PTR nNewCount = ar.ReadCount();
; 1192 : 		while (nNewCount--)
; 1193 : 		{
; 1194 : 			TYPE newData[1];
; 1195 : 			SerializeElements<TYPE>(ar, newData, 1);
; 1196 : 			AddTail(newData[0]);
; 1197 : 		}
; 1198 : 	}
; 1199 : }
; 1200 : 
; 1201 : #ifdef _DEBUG
; 1202 : template<class TYPE, class ARG_TYPE>
; 1203 : void CList<TYPE, ARG_TYPE>::Dump(CDumpContext& dc) const
; 1204 : {
; 1205 : 	CObject::Dump(dc);
; 1206 : 
; 1207 : 	dc << "with " << m_nCount << " elements";
; 1208 : 	if (dc.GetDepth() > 0)
; 1209 : 	{
; 1210 : 		POSITION pos = GetHeadPosition();
; 1211 : 		while (pos != NULL)
; 1212 : 		{
; 1213 : 			TYPE temp[1];
; 1214 : 			temp[0] = ((CList*)this)->GetNext(pos);
; 1215 : 			dc << "\n";
; 1216 : 			DumpElements<TYPE>(dc, temp, 1);
; 1217 : 		}
; 1218 : 	}
; 1219 : 
; 1220 : 	dc << "\n";
; 1221 : }
; 1222 : 
; 1223 : template<class TYPE, class ARG_TYPE>
; 1224 : void CList<TYPE, ARG_TYPE>::AssertValid() const
; 1225 : {
; 1226 : 	CObject::AssertValid();
; 1227 : 
; 1228 : 	if (m_nCount == 0)
; 1229 : 	{
; 1230 : 		// empty list
; 1231 : 		ASSERT(m_pNodeHead == NULL);
; 1232 : 		ASSERT(m_pNodeTail == NULL);
; 1233 : 	}
; 1234 : 	else
; 1235 : 	{
; 1236 : 		// non-empty list
; 1237 : 		ASSERT(AfxIsValidAddress(m_pNodeHead, sizeof(CNode)));
; 1238 : 		ASSERT(AfxIsValidAddress(m_pNodeTail, sizeof(CNode)));
; 1239 : 	}
; 1240 : }
; 1241 : #endif //_DEBUG
; 1242 : 
; 1243 : /*============================================================================*/
; 1244 : // CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>
; 1245 : 
; 1246 : template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
; 1247 : class CMap : public CObject
; 1248 : {
; 1249 : public:
; 1250 : 	// CPair
; 1251 : 	struct CPair
; 1252 : 	{
; 1253 : 		const KEY key;
; 1254 : 		VALUE value;
; 1255 : 	protected:
; 1256 : 		CPair( ARG_KEY keyval ) : key( keyval )	{}
; 1257 : 	};
; 1258 : 
; 1259 : protected:
; 1260 : 	// Association
; 1261 : 	class CAssoc : public CPair
; 1262 : 	{
; 1263 : 		friend class CMap<KEY,ARG_KEY,VALUE,ARG_VALUE>;
; 1264 : 		CAssoc* pNext;
; 1265 : 		UINT nHashValue;  // needed for efficient iteration
; 1266 : 	public:
; 1267 : 		CAssoc( ARG_KEY key ) : CPair( key ) {}
; 1268 : 	};
; 1269 : 
; 1270 : public:
; 1271 : // Construction
; 1272 : 	explicit CMap(INT_PTR nBlockSize = 10);
; 1273 : 
; 1274 : // Attributes
; 1275 : 	// number of elements
; 1276 : 	INT_PTR GetCount() const;
; 1277 : 	INT_PTR GetSize() const;
; 1278 : 	BOOL IsEmpty() const;
; 1279 : 
; 1280 : 	// Lookup
; 1281 : 	BOOL Lookup(ARG_KEY key, VALUE& rValue) const;
; 1282 : 	const CPair *PLookup(ARG_KEY key) const;
; 1283 : 	CPair *PLookup(ARG_KEY key);
; 1284 : 
; 1285 : // Operations
; 1286 : 	// Lookup and add if not there
; 1287 : 	VALUE& operator[](ARG_KEY key);
; 1288 : 
; 1289 : 	// add a new (key, value) pair
; 1290 : 	void SetAt(ARG_KEY key, ARG_VALUE newValue);
; 1291 : 
; 1292 : 	// removing existing (key, ?) pair
; 1293 : 	BOOL RemoveKey(ARG_KEY key);
; 1294 : 	void RemoveAll();
; 1295 : 
; 1296 : 	// iterating all (key, value) pairs
; 1297 : 	POSITION GetStartPosition() const;
; 1298 : 
; 1299 : 	const CPair *PGetFirstAssoc() const;
; 1300 : 	CPair *PGetFirstAssoc();
; 1301 : 
; 1302 : 	void GetNextAssoc(POSITION& rNextPosition, KEY& rKey, VALUE& rValue) const;
; 1303 : 
; 1304 : 	const CPair *PGetNextAssoc(const CPair *pAssocRet) const;
; 1305 : 	CPair *PGetNextAssoc(const CPair *pAssocRet);
; 1306 : 
; 1307 : 	// advanced features for derived classes
; 1308 : 	UINT GetHashTableSize() const;
; 1309 : 	void InitHashTable(UINT hashSize, BOOL bAllocNow = TRUE);
; 1310 : 
; 1311 : // Implementation
; 1312 : protected:
; 1313 : 	CAssoc** m_pHashTable;
; 1314 : 	UINT m_nHashTableSize;
; 1315 : 	INT_PTR m_nCount;
; 1316 : 	CAssoc* m_pFreeList;
; 1317 : 	struct CPlex* m_pBlocks;
; 1318 : 	INT_PTR m_nBlockSize;
; 1319 : 
; 1320 : 	CAssoc* NewAssoc(ARG_KEY key);
; 1321 : 	void FreeAssoc(CAssoc*);
; 1322 : 	CAssoc* GetAssocAt(ARG_KEY, UINT&, UINT&) const;
; 1323 : 
; 1324 : public:
; 1325 : 	~CMap();
; 1326 : 	void Serialize(CArchive&);
; 1327 : #ifdef _DEBUG
; 1328 : 	void Dump(CDumpContext&) const;
; 1329 : 	void AssertValid() const;
; 1330 : #endif
; 1331 : };
; 1332 : 
; 1333 : /*============================================================================*/
; 1334 : // CMap<KEY, ARG_KEY, VALUE, ARG_VALUE> inline functions
; 1335 : 
; 1336 : template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
; 1337 : AFX_INLINE INT_PTR CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetCount() const
; 1338 : 	{ return m_nCount; }
; 1339 : 
; 1340 : template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
; 1341 : AFX_INLINE INT_PTR CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetSize() const
; 1342 : 	{ return m_nCount; }
; 1343 : 
; 1344 : template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
; 1345 : AFX_INLINE BOOL CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::IsEmpty() const
; 1346 : 	{ return m_nCount == 0; }
; 1347 : 
; 1348 : template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
; 1349 : AFX_INLINE void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::SetAt(ARG_KEY key, ARG_VALUE newValue)
; 1350 : 	{ (*this)[key] = newValue; }
; 1351 : 
; 1352 : template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
; 1353 : AFX_INLINE POSITION CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetStartPosition() const
; 1354 : 	{ return (m_nCount == 0) ? NULL : BEFORE_START_POSITION; }
; 1355 : 
; 1356 : template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
; 1357 : const typename CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CPair* CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::PGetFirstAssoc() const
; 1358 : {
; 1359 : 	ASSERT_VALID(this);
; 1360 : 	if(m_nCount == 0) return NULL;
; 1361 : 
; 1362 : 	AFXASSUME(m_pHashTable != NULL);  // never call on empty map
; 1363 : 
; 1364 : 	CAssoc* pAssocRet = (CAssoc*)BEFORE_START_POSITION;
; 1365 : 
; 1366 : 	// find the first association
; 1367 : 	for (UINT nBucket = 0; nBucket < m_nHashTableSize; nBucket++)
; 1368 : 		if ((pAssocRet = m_pHashTable[nBucket]) != NULL)
; 1369 : 			break;
; 1370 : 	ASSERT(pAssocRet != NULL);  // must find something
; 1371 : 
; 1372 : 	return pAssocRet;
; 1373 : }
; 1374 : 
; 1375 : template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
; 1376 : typename CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CPair* CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::PGetFirstAssoc()
; 1377 : {
; 1378 : 	ASSERT_VALID(this);
; 1379 : 	if(m_nCount == 0) return NULL;
; 1380 : 
; 1381 : 	AFXASSUME(m_pHashTable != NULL);  // never call on empty map
; 1382 : 
; 1383 : 	CAssoc* pAssocRet = (CAssoc*)BEFORE_START_POSITION;
; 1384 : 
; 1385 : 	// find the first association
; 1386 : 	for (UINT nBucket = 0; nBucket < m_nHashTableSize; nBucket++)
; 1387 : 		if ((pAssocRet = m_pHashTable[nBucket]) != NULL)
; 1388 : 			break;
; 1389 : 	ASSERT(pAssocRet != NULL);  // must find something
; 1390 : 
; 1391 : 	return pAssocRet;
; 1392 : }
; 1393 : 
; 1394 : template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
; 1395 : AFX_INLINE UINT CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetHashTableSize() const
; 1396 : 	{ return m_nHashTableSize; }
; 1397 : 
; 1398 : /*============================================================================*/
; 1399 : // CMap<KEY, ARG_KEY, VALUE, ARG_VALUE> out-of-line functions
; 1400 : 
; 1401 : template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
; 1402 : CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CMap(INT_PTR nBlockSize)
; 1403 : {
; 1404 : 	ASSERT(nBlockSize > 0);
; 1405 : 
; 1406 : 	m_pHashTable = NULL;
; 1407 : 	m_nHashTableSize = 17;  // default size
; 1408 : 	m_nCount = 0;
; 1409 : 	m_pFreeList = NULL;
; 1410 : 	m_pBlocks = NULL;
; 1411 : 	m_nBlockSize = nBlockSize;
; 1412 : }
; 1413 : 
; 1414 : template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
; 1415 : void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::InitHashTable(
; 1416 : 	UINT nHashSize, BOOL bAllocNow)
; 1417 : //
; 1418 : // Used to force allocation of a hash table or to override the default
; 1419 : //   hash table size of (which is fairly small)
; 1420 : {
; 1421 : 	ASSERT_VALID(this);
; 1422 : 	ASSERT(m_nCount == 0);
; 1423 : 	ASSERT(nHashSize > 0);
; 1424 : 
; 1425 : 	if (m_pHashTable != NULL)
; 1426 : 	{
; 1427 : 		// free hash table
; 1428 : 		delete[] m_pHashTable;
; 1429 : 		m_pHashTable = NULL;
; 1430 : 	}
; 1431 : 
; 1432 : 	if (bAllocNow)
; 1433 : 	{
; 1434 : 		m_pHashTable = new CAssoc* [nHashSize];
; 1435 : 		ENSURE(m_pHashTable != NULL);
; 1436 : 		memset(m_pHashTable, 0, sizeof(CAssoc*) * nHashSize);
; 1437 : 	}
; 1438 : 	m_nHashTableSize = nHashSize;
; 1439 : }
; 1440 : 
; 1441 : template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
; 1442 : void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::RemoveAll()
; 1443 : {
; 1444 : 	ASSERT_VALID(this);
; 1445 : 
; 1446 : 	if (m_pHashTable != NULL)
; 1447 : 	{
; 1448 : 		// destroy elements (values and keys)
; 1449 : 		for (UINT nHash = 0; nHash < m_nHashTableSize; nHash++)
; 1450 : 		{
; 1451 : 			CAssoc* pAssoc;
; 1452 : 			for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL;
; 1453 : 			  pAssoc = pAssoc->pNext)
; 1454 : 			{
; 1455 : 				pAssoc->CAssoc::~CAssoc();
; 1456 : 			}
; 1457 : 		}
; 1458 : 
; 1459 : 		// free hash table
; 1460 : 		delete[] m_pHashTable;
; 1461 : 		m_pHashTable = NULL;
; 1462 : 	}
; 1463 : 
; 1464 : 	m_nCount = 0;
; 1465 : 	m_pFreeList = NULL;
; 1466 : 	m_pBlocks->FreeDataChain();
; 1467 : 	m_pBlocks = NULL;
; 1468 : }
; 1469 : 
; 1470 : template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
; 1471 : CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::~CMap()
; 1472 : {
; 1473 : 	RemoveAll();
; 1474 : 	ASSERT(m_nCount == 0);
; 1475 : }
; 1476 : 
; 1477 : template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
; 1478 : typename CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CAssoc*
; 1479 : CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::NewAssoc(ARG_KEY key)
; 1480 : {
; 1481 : 	if (m_pFreeList == NULL)
; 1482 : 	{
; 1483 : 		// add another block
; 1484 : 		CPlex* newBlock = CPlex::Create(m_pBlocks, m_nBlockSize, sizeof(CMap::CAssoc));
; 1485 : 		// chain them into free list
; 1486 : 		CMap::CAssoc* pAssoc = (CMap::CAssoc*) newBlock->data();
; 1487 : 		// free in reverse order to make it easier to debug
; 1488 : 		pAssoc += m_nBlockSize - 1;
; 1489 : 		for (INT_PTR i = m_nBlockSize-1; i >= 0; i--, pAssoc--)
; 1490 : 		{
; 1491 : 			pAssoc->pNext = m_pFreeList;
; 1492 : 			m_pFreeList = pAssoc;
; 1493 : 		}
; 1494 : 	}
; 1495 : 	ENSURE(m_pFreeList != NULL);  // we must have something
; 1496 : 
; 1497 : 	CMap::CAssoc* pAssoc = m_pFreeList;
; 1498 : 
; 1499 : 	// zero the memory
; 1500 : 	CMap::CAssoc* pTemp = pAssoc->pNext;
; 1501 : 	memset( pAssoc, 0, sizeof(CMap::CAssoc) );
; 1502 : 	pAssoc->pNext = pTemp;
; 1503 : 
; 1504 : 	m_pFreeList = m_pFreeList->pNext;
; 1505 : 	m_nCount++;
; 1506 : 	ASSERT(m_nCount > 0);  // make sure we don't overflow
; 1507 : #pragma push_macro("new")
; 1508 : #undef new
; 1509 : 	::new(pAssoc) CMap::CAssoc(key);
; 1510 : #pragma pop_macro("new")
; 1511 : 	return pAssoc;
; 1512 : }
; 1513 : 
; 1514 : template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
; 1515 : void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::FreeAssoc(CAssoc* pAssoc)
; 1516 : {
; 1517 : 	pAssoc->CAssoc::~CAssoc();
; 1518 : 	pAssoc->pNext = m_pFreeList;
; 1519 : 	m_pFreeList = pAssoc;
; 1520 : 	m_nCount--;
; 1521 : 	ASSERT(m_nCount >= 0);  // make sure we don't underflow
; 1522 : 
; 1523 : 	// if no more elements, cleanup completely
; 1524 : 	if (m_nCount == 0)
; 1525 : 		RemoveAll();
; 1526 : }
; 1527 : 
; 1528 : template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
; 1529 : typename CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CAssoc*
; 1530 : CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetAssocAt(ARG_KEY key, UINT& nHashBucket, UINT& nHashValue) const
; 1531 : // find association (or return NULL)
; 1532 : {
; 1533 : 	nHashValue = HashKey<ARG_KEY>(key);
; 1534 : 	nHashBucket = nHashValue % m_nHashTableSize;

  001b8	33 d2		 xor	 edx, edx
  001ba	8b c6		 mov	 eax, esi
  001bc	f7 b7 f0 00 00
	00		 div	 DWORD PTR [edi+240]

; 1537 : 		return NULL;
; 1538 : 
; 1539 : 	// see if it exists
; 1540 : 	CAssoc* pAssoc;
; 1541 : 	for (pAssoc = m_pHashTable[nHashBucket]; pAssoc != NULL; pAssoc = pAssoc->pNext)

  001c2	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  001c5	85 c0		 test	 eax, eax
  001c7	74 26		 je	 SHORT $LN162@OnApply
  001c9	8b 4d c0	 mov	 ecx, DWORD PTR _nFieldKey$1$[ebp]
  001cc	0f 1f 40 00	 npad	 4
$LL37@OnApply:

; 1542 : 	{
; 1543 : 		if (pAssoc->nHashValue == nHashValue && CompareElements(&pAssoc->key, &key))

  001d0	39 70 0c	 cmp	 DWORD PTR [eax+12], esi
  001d3	75 04		 jne	 SHORT $LN35@OnApply

; 156  : 	return *pElement1 == *pElement2;

  001d5	39 08		 cmp	 DWORD PTR [eax], ecx

; 1543 : 		if (pAssoc->nHashValue == nHashValue && CompareElements(&pAssoc->key, &key))

  001d7	74 09		 je	 SHORT $LN34@OnApply
$LN35@OnApply:

; 1537 : 		return NULL;
; 1538 : 
; 1539 : 	// see if it exists
; 1540 : 	CAssoc* pAssoc;
; 1541 : 	for (pAssoc = m_pHashTable[nHashBucket]; pAssoc != NULL; pAssoc = pAssoc->pNext)

  001d9	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  001dc	85 c0		 test	 eax, eax
  001de	75 f0		 jne	 SHORT $LL37@OnApply
  001e0	eb 0d		 jmp	 SHORT $LN162@OnApply
$LN34@OnApply:

; 1559 : 	rValue = pAssoc->value;

  001e2	83 c0 04	 add	 eax, 4
  001e5	8d 4d bc	 lea	 ecx, DWORD PTR _strFieldName$[ebp]
  001e8	50		 push	 eax
  001e9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
$LN162@OnApply:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 129  : 		strValue.Format("%d,%s", nFieldKey, strFieldName);

  001ef	ff 75 bc	 push	 DWORD PTR _strFieldName$[ebp]
  001f2	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp_?Format@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAAXPBDZZ
  001f8	8d 45 cc	 lea	 eax, DWORD PTR _strValue$[ebp]
  001fb	ff 75 c0	 push	 DWORD PTR _nFieldKey$1$[ebp]
  001fe	68 00 00 00 00	 push	 OFFSET ??_C@_05KFJOKFOM@?$CFd?0?$CFs@
  00203	50		 push	 eax
  00204	ff d6		 call	 esi
  00206	83 c4 10	 add	 esp, 16			; 00000010H

; 130  : 		::WritePrivateProfileString(szKey, str, strValue, strConfigPath);

  00209	8d 45 d0	 lea	 eax, DWORD PTR _szKey$[ebp]
  0020c	ff 75 c8	 push	 DWORD PTR _strConfigPath$[ebp]
  0020f	ff 75 cc	 push	 DWORD PTR _strValue$[ebp]
  00212	ff 75 b8	 push	 DWORD PTR _str$[ebp]
  00215	50		 push	 eax
  00216	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WritePrivateProfileStringA@16
  0021c	43		 inc	 ebx
  0021d	3b 5d c4	 cmp	 ebx, DWORD PTR _nCnt$1$[ebp]
  00220	0f 8c 3a ff ff
	ff		 jl	 $LL4@OnApply
$LN3@OnApply:

; 131  : 	}
; 132  : 
; 133  : 	//***********************************************************
; 134  : 	// Addition List Item User file Write
; 135  : 	//***********************************************************
; 136  : 	nCnt = m_arrayAdditionIdx.GetSize();

  00226	8b 9f c8 00 00
	00		 mov	 ebx, DWORD PTR [edi+200]

; 137  : 	
; 138  : 	sprintf(szKey,"%s","ADDITION LIST");

  0022c	8d 45 d0	 lea	 eax, DWORD PTR _szKey$[ebp]
  0022f	68 00 00 00 00	 push	 OFFSET ??_C@_0O@PLHPCCBM@ADDITION?5LIST@
  00234	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  00239	50		 push	 eax
  0023a	89 5d c4	 mov	 DWORD PTR _nCnt$2$[ebp], ebx
  0023d	e8 00 00 00 00	 call	 _sprintf

; 139  : 
; 140  : 	strValue.Format("%d",nCnt);

  00242	53		 push	 ebx
  00243	8d 45 cc	 lea	 eax, DWORD PTR _strValue$[ebp]
  00246	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  0024b	50		 push	 eax
  0024c	ff d6		 call	 esi
  0024e	83 c4 18	 add	 esp, 24			; 00000018H

; 141  : 	::WritePrivateProfileString(szKey, "COUNT", strValue, strConfigPath);

  00251	8d 45 d0	 lea	 eax, DWORD PTR _szKey$[ebp]
  00254	ff 75 c8	 push	 DWORD PTR _strConfigPath$[ebp]
  00257	ff 75 cc	 push	 DWORD PTR _strValue$[ebp]
  0025a	68 00 00 00 00	 push	 OFFSET ??_C@_05EFFCCOAM@COUNT@
  0025f	50		 push	 eax
  00260	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WritePrivateProfileStringA@16

; 142  : 	for (i=0; i < nCnt ; i++)

  00266	33 db		 xor	 ebx, ebx
  00268	39 5d c4	 cmp	 DWORD PTR _nCnt$2$[ebp], ebx
  0026b	0f 8e c1 00 00
	00		 jle	 $LN6@OnApply
$LL7@OnApply:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 288  : 	if(nIndex >= 0 && nIndex < m_nSize)

  00271	85 db		 test	 ebx, ebx
  00273	0f 88 23 02 00
	00		 js	 $LN101@OnApply
  00279	3b 9f c8 00 00
	00		 cmp	 ebx, DWORD PTR [edi+200]
  0027f	0f 8d 17 02 00
	00		 jge	 $LN101@OnApply
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 144  : 		nFieldKey = m_arrayAdditionIdx.GetAt(i);

  00285	8b 87 c4 00 00
	00		 mov	 eax, DWORD PTR [edi+196]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 165  : 	ldiv_t HashVal = ldiv((long)(ARG_KEY)key, 127773);

  0028b	b9 1d f3 01 00	 mov	 ecx, 127773		; 0001f31dH
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 144  : 		nFieldKey = m_arrayAdditionIdx.GetAt(i);

  00290	8b 04 98	 mov	 eax, DWORD PTR [eax+ebx*4]
  00293	89 45 c0	 mov	 DWORD PTR _nFieldKey$2$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 165  : 	ldiv_t HashVal = ldiv((long)(ARG_KEY)key, 127773);

  00296	99		 cdq
  00297	f7 f9		 idiv	 ecx

; 166  : 	HashVal.rem = 16807 * HashVal.rem - 2836 * HashVal.quot;

  00299	69 ca a7 41 00
	00		 imul	 ecx, edx, 16807
  0029f	69 c0 14 0b 00
	00		 imul	 eax, eax, 2836
  002a5	2b c8		 sub	 ecx, eax

; 1536 : 	if (m_pHashTable == NULL)

  002a7	8d b1 ff ff ff
	7f		 lea	 esi, DWORD PTR [ecx+2147483647]
  002ad	0f 49 f1	 cmovns	 esi, ecx
  002b0	8b 8f 08 01 00
	00		 mov	 ecx, DWORD PTR [edi+264]
  002b6	85 c9		 test	 ecx, ecx
  002b8	74 35		 je	 SHORT $LN163@OnApply

; 291  : }
; 292  : template<class TYPE, class ARG_TYPE>
; 293  : AFX_INLINE const TYPE& CArray<TYPE, ARG_TYPE>::GetAt(INT_PTR nIndex) const
; 294  : {
; 295  : 	ASSERT(nIndex >= 0 && nIndex < m_nSize);
; 296  : 	if(nIndex >= 0 && nIndex < m_nSize)
; 297  : 		return m_pData[nIndex];
; 298  : 	AfxThrowInvalidArgException();
; 299  : }
; 300  : template<class TYPE, class ARG_TYPE>
; 301  : AFX_INLINE void CArray<TYPE, ARG_TYPE>::SetAt(INT_PTR nIndex, ARG_TYPE newElement)
; 302  : {
; 303  : 	ASSERT(nIndex >= 0 && nIndex < m_nSize);
; 304  : 	if(nIndex >= 0 && nIndex < m_nSize)
; 305  : 		m_pData[nIndex] = newElement;
; 306  : 	else
; 307  : 		AfxThrowInvalidArgException();
; 308  : }
; 309  : template<class TYPE, class ARG_TYPE>
; 310  : AFX_INLINE const TYPE& CArray<TYPE, ARG_TYPE>::ElementAt(INT_PTR nIndex) const
; 311  : {
; 312  : 	ASSERT(nIndex >= 0 && nIndex < m_nSize);
; 313  : 	if(nIndex >= 0 && nIndex < m_nSize)
; 314  : 		return m_pData[nIndex];
; 315  : 	AfxThrowInvalidArgException();
; 316  : }
; 317  : template<class TYPE, class ARG_TYPE>
; 318  : AFX_INLINE TYPE& CArray<TYPE, ARG_TYPE>::ElementAt(INT_PTR nIndex)
; 319  : {
; 320  : 	ASSERT(nIndex >= 0 && nIndex < m_nSize);
; 321  : 	if(nIndex >= 0 && nIndex < m_nSize)
; 322  : 		return m_pData[nIndex];
; 323  : 	AfxThrowInvalidArgException();
; 324  : }
; 325  : template<class TYPE, class ARG_TYPE>
; 326  : AFX_INLINE const TYPE* CArray<TYPE, ARG_TYPE>::GetData() const
; 327  : 	{ return (const TYPE*)m_pData; }
; 328  : template<class TYPE, class ARG_TYPE>
; 329  : AFX_INLINE TYPE* CArray<TYPE, ARG_TYPE>::GetData()
; 330  : 	{ return (TYPE*)m_pData; }
; 331  : template<class TYPE, class ARG_TYPE>
; 332  : AFX_INLINE INT_PTR CArray<TYPE, ARG_TYPE>::Add(ARG_TYPE newElement)
; 333  : 	{ INT_PTR nIndex = m_nSize;
; 334  : 		SetAtGrow(nIndex, newElement);
; 335  : 		return nIndex; }
; 336  : template<class TYPE, class ARG_TYPE>
; 337  : AFX_INLINE const TYPE& CArray<TYPE, ARG_TYPE>::operator[](INT_PTR nIndex) const
; 338  : 	{ return GetAt(nIndex); }
; 339  : template<class TYPE, class ARG_TYPE>
; 340  : AFX_INLINE TYPE& CArray<TYPE, ARG_TYPE>::operator[](INT_PTR nIndex)
; 341  : 	{ return ElementAt(nIndex); }
; 342  : 
; 343  : /*============================================================================*/
; 344  : // CArray<TYPE, ARG_TYPE> out-of-line functions
; 345  : 
; 346  : template<class TYPE, class ARG_TYPE>
; 347  : CArray<TYPE, ARG_TYPE>::CArray()
; 348  : {
; 349  : 	m_pData = NULL;
; 350  : 	m_nSize = m_nMaxSize = m_nGrowBy = 0;
; 351  : }
; 352  : 
; 353  : template<class TYPE, class ARG_TYPE>
; 354  : CArray<TYPE, ARG_TYPE>::~CArray()
; 355  : {
; 356  : 	ASSERT_VALID(this);
; 357  : 
; 358  : 	if (m_pData != NULL)
; 359  : 	{
; 360  : 		for( int i = 0; i < m_nSize; i++ )
; 361  : 			(m_pData + i)->~TYPE();
; 362  : 		delete[] (BYTE*)m_pData;
; 363  : 	}
; 364  : }
; 365  : 
; 366  : template<class TYPE, class ARG_TYPE>
; 367  : void CArray<TYPE, ARG_TYPE>::SetSize(INT_PTR nNewSize, INT_PTR nGrowBy)
; 368  : {
; 369  : 	ASSERT_VALID(this);
; 370  : 	ASSERT(nNewSize >= 0);
; 371  : 
; 372  : 	if(nNewSize < 0 )
; 373  : 		AfxThrowInvalidArgException();
; 374  : 
; 375  : 	if (nGrowBy >= 0)
; 376  : 		m_nGrowBy = nGrowBy;  // set new size
; 377  : 
; 378  : 	if (nNewSize == 0)
; 379  : 	{
; 380  : 		// shrink to nothing
; 381  : 		if (m_pData != NULL)
; 382  : 		{
; 383  : 			for( int i = 0; i < m_nSize; i++ )
; 384  : 				(m_pData + i)->~TYPE();
; 385  : 			delete[] (BYTE*)m_pData;
; 386  : 			m_pData = NULL;
; 387  : 		}
; 388  : 		m_nSize = m_nMaxSize = 0;
; 389  : 	}
; 390  : 	else if (m_pData == NULL)
; 391  : 	{
; 392  : 		// create buffer big enough to hold number of requested elements or
; 393  : 		// m_nGrowBy elements, whichever is larger.
; 394  : #ifdef SIZE_T_MAX
; 395  : 		ASSERT(nNewSize <= SIZE_T_MAX/sizeof(TYPE));    // no overflow
; 396  : #endif
; 397  : 		size_t nAllocSize = __max(nNewSize, m_nGrowBy);
; 398  : 		m_pData = (TYPE*) new BYTE[(size_t)nAllocSize * sizeof(TYPE)];
; 399  : 		memset((void*)m_pData, 0, (size_t)nAllocSize * sizeof(TYPE));
; 400  : 		for( int i = 0; i < nNewSize; i++ )
; 401  : #pragma push_macro("new")
; 402  : #undef new
; 403  : 			::new( (void*)( m_pData + i ) ) TYPE;
; 404  : #pragma pop_macro("new")
; 405  : 		m_nSize = nNewSize;
; 406  : 		m_nMaxSize = nAllocSize;
; 407  : 	}
; 408  : 	else if (nNewSize <= m_nMaxSize)
; 409  : 	{
; 410  : 		// it fits
; 411  : 		if (nNewSize > m_nSize)
; 412  : 		{
; 413  : 			// initialize the new elements
; 414  : 			memset((void*)(m_pData + m_nSize), 0, (size_t)(nNewSize-m_nSize) * sizeof(TYPE));
; 415  : 			for( int i = 0; i < nNewSize-m_nSize; i++ )
; 416  : #pragma push_macro("new")
; 417  : #undef new
; 418  : 				::new( (void*)( m_pData + m_nSize + i ) ) TYPE;
; 419  : #pragma pop_macro("new")
; 420  : 		}
; 421  : 		else if (m_nSize > nNewSize)
; 422  : 		{
; 423  : 			// destroy the old elements
; 424  : 			for( int i = 0; i < m_nSize-nNewSize; i++ )
; 425  : 				(m_pData + nNewSize + i)->~TYPE();
; 426  : 		}
; 427  : 		m_nSize = nNewSize;
; 428  : 	}
; 429  : 	else
; 430  : 	{
; 431  : 		// otherwise, grow array
; 432  : 		nGrowBy = m_nGrowBy;
; 433  : 		if (nGrowBy == 0)
; 434  : 		{
; 435  : 			// heuristically determine growth when nGrowBy == 0
; 436  : 			//  (this avoids heap fragmentation in many situations)
; 437  : 			nGrowBy = m_nSize / 8;
; 438  : 			nGrowBy = (nGrowBy < 4) ? 4 : ((nGrowBy > 1024) ? 1024 : nGrowBy);
; 439  : 		}
; 440  : 		INT_PTR nNewMax;
; 441  : 		if (nNewSize < m_nMaxSize + nGrowBy)
; 442  : 			nNewMax = m_nMaxSize + nGrowBy;  // granularity
; 443  : 		else
; 444  : 			nNewMax = nNewSize;  // no slush
; 445  : 
; 446  : 		ASSERT(nNewMax >= m_nMaxSize);  // no wrap around
; 447  : 
; 448  : 		if(nNewMax  < m_nMaxSize)
; 449  : 			AfxThrowInvalidArgException();
; 450  : 
; 451  : #ifdef SIZE_T_MAX
; 452  : 		ASSERT(nNewMax <= SIZE_T_MAX/sizeof(TYPE)); // no overflow
; 453  : #endif
; 454  : 		TYPE* pNewData = (TYPE*) new BYTE[(size_t)nNewMax * sizeof(TYPE)];
; 455  : 
; 456  : 		// copy new data from old
; 457  : 		::ATL::Checked::memcpy_s(pNewData, (size_t)nNewMax * sizeof(TYPE),
; 458  : 			m_pData, (size_t)m_nSize * sizeof(TYPE));
; 459  : 
; 460  : 		// construct remaining elements
; 461  : 		ASSERT(nNewSize > m_nSize);
; 462  : 		memset((void*)(pNewData + m_nSize), 0, (size_t)(nNewSize-m_nSize) * sizeof(TYPE));
; 463  : 		for( int i = 0; i < nNewSize-m_nSize; i++ )
; 464  : #pragma push_macro("new")
; 465  : #undef new
; 466  : 			::new( (void*)( pNewData + m_nSize + i ) ) TYPE;
; 467  : #pragma pop_macro("new")
; 468  : 
; 469  : 		// get rid of old stuff (note: no destructors called)
; 470  : 		delete[] (BYTE*)m_pData;
; 471  : 		m_pData = pNewData;
; 472  : 		m_nSize = nNewSize;
; 473  : 		m_nMaxSize = nNewMax;
; 474  : 	}
; 475  : }
; 476  : 
; 477  : template<class TYPE, class ARG_TYPE>
; 478  : INT_PTR CArray<TYPE, ARG_TYPE>::Append(const CArray& src)
; 479  : {
; 480  : 	ASSERT_VALID(this);
; 481  : 	ASSERT(this != &src);   // cannot append to itself
; 482  : 
; 483  : 	if(this == &src)
; 484  : 		AfxThrowInvalidArgException();
; 485  : 
; 486  : 	INT_PTR nOldSize = m_nSize;
; 487  : 	SetSize(m_nSize + src.m_nSize);
; 488  : 	CopyElements<TYPE>(m_pData + nOldSize, src.m_pData, src.m_nSize);
; 489  : 	return nOldSize;
; 490  : }
; 491  : 
; 492  : template<class TYPE, class ARG_TYPE>
; 493  : void CArray<TYPE, ARG_TYPE>::Copy(const CArray& src)
; 494  : {
; 495  : 	ASSERT_VALID(this);
; 496  : 	ASSERT(this != &src);   // cannot append to itself
; 497  : 
; 498  : 	if(this != &src)
; 499  : 	{
; 500  : 		SetSize(src.m_nSize);
; 501  : 		CopyElements<TYPE>(m_pData, src.m_pData, src.m_nSize);
; 502  : 	}
; 503  : }
; 504  : 
; 505  : template<class TYPE, class ARG_TYPE>
; 506  : void CArray<TYPE, ARG_TYPE>::FreeExtra()
; 507  : {
; 508  : 	ASSERT_VALID(this);
; 509  : 
; 510  : 	if (m_nSize != m_nMaxSize)
; 511  : 	{
; 512  : 		// shrink to desired size
; 513  : #ifdef SIZE_T_MAX
; 514  : 		ASSERT(m_nSize <= SIZE_T_MAX/sizeof(TYPE)); // no overflow
; 515  : #endif
; 516  : 		TYPE* pNewData = NULL;
; 517  : 		if (m_nSize != 0)
; 518  : 		{
; 519  : 			pNewData = (TYPE*) new BYTE[m_nSize * sizeof(TYPE)];
; 520  : 			// copy new data from old
; 521  : 			::ATL::Checked::memcpy_s(pNewData, m_nSize * sizeof(TYPE),
; 522  : 				m_pData, m_nSize * sizeof(TYPE));
; 523  : 		}
; 524  : 
; 525  : 		// get rid of old stuff (note: no destructors called)
; 526  : 		delete[] (BYTE*)m_pData;
; 527  : 		m_pData = pNewData;
; 528  : 		m_nMaxSize = m_nSize;
; 529  : 	}
; 530  : }
; 531  : 
; 532  : template<class TYPE, class ARG_TYPE>
; 533  : void CArray<TYPE, ARG_TYPE>::SetAtGrow(INT_PTR nIndex, ARG_TYPE newElement)
; 534  : {
; 535  : 	ASSERT_VALID(this);
; 536  : 	ASSERT(nIndex >= 0);
; 537  : 
; 538  : 	if(nIndex < 0)
; 539  : 		AfxThrowInvalidArgException();
; 540  : 
; 541  : 	if (nIndex >= m_nSize)
; 542  : 		SetSize(nIndex+1, -1);
; 543  : 	m_pData[nIndex] = newElement;
; 544  : }
; 545  : 
; 546  : template<class TYPE, class ARG_TYPE>
; 547  : void CArray<TYPE, ARG_TYPE>::InsertAt(INT_PTR nIndex, ARG_TYPE newElement, INT_PTR nCount /*=1*/)
; 548  : {
; 549  : 	ASSERT_VALID(this);
; 550  : 	ASSERT(nIndex >= 0);    // will expand to meet need
; 551  : 	ASSERT(nCount > 0);     // zero or negative size not allowed
; 552  : 
; 553  : 	if(nIndex < 0 || nCount <= 0)
; 554  : 		AfxThrowInvalidArgException();
; 555  : 
; 556  : 	if (nIndex >= m_nSize)
; 557  : 	{
; 558  : 		// adding after the end of the array
; 559  : 		SetSize(nIndex + nCount, -1);   // grow so nIndex is valid
; 560  : 	}
; 561  : 	else
; 562  : 	{
; 563  : 		// inserting in the middle of the array
; 564  : 		INT_PTR nOldSize = m_nSize;
; 565  : 		SetSize(m_nSize + nCount, -1);  // grow it to new size
; 566  : 		// destroy intial data before copying over it
; 567  : 		for( int i = 0; i < nCount; i++ )
; 568  : 			(m_pData + nOldSize + i)->~TYPE();
; 569  : 		// shift old data up to fill gap
; 570  : 		::ATL::Checked::memmove_s(m_pData + nIndex + nCount, (nOldSize-nIndex) * sizeof(TYPE),
; 571  : 			m_pData + nIndex, (nOldSize-nIndex) * sizeof(TYPE));
; 572  : 
; 573  : 		// re-init slots we copied from
; 574  : 		memset((void*)(m_pData + nIndex), 0, (size_t)nCount * sizeof(TYPE));
; 575  : 		for( int i = 0; i < nCount; i++ )
; 576  : #pragma push_macro("new")
; 577  : #undef new
; 578  : 			::new( (void*)( m_pData + nIndex + i ) ) TYPE;
; 579  : #pragma pop_macro("new")
; 580  : 	}
; 581  : 
; 582  : 	// insert new value in the gap
; 583  : 	ASSERT(nIndex + nCount <= m_nSize);
; 584  : 	while (nCount--)
; 585  : 		m_pData[nIndex++] = newElement;
; 586  : }
; 587  : 
; 588  : template<class TYPE, class ARG_TYPE>
; 589  : void CArray<TYPE, ARG_TYPE>::RemoveAt(INT_PTR nIndex, INT_PTR nCount)
; 590  : {
; 591  : 	ASSERT_VALID(this);
; 592  : 	ASSERT(nIndex >= 0);
; 593  : 	ASSERT(nCount >= 0);
; 594  : 	INT_PTR nUpperBound = nIndex + nCount;
; 595  : 	ASSERT(nUpperBound <= m_nSize && nUpperBound >= nIndex && nUpperBound >= nCount);
; 596  : 
; 597  : 	if(nIndex < 0 || nCount < 0 || (nUpperBound > m_nSize) || (nUpperBound < nIndex) || (nUpperBound < nCount))
; 598  : 		AfxThrowInvalidArgException();
; 599  : 
; 600  : 	// just remove a range
; 601  : 	INT_PTR nMoveCount = m_nSize - (nUpperBound);
; 602  : 	for( int i = 0; i < nCount; i++ )
; 603  : 		(m_pData + nIndex + i)->~TYPE();
; 604  : 	if (nMoveCount)
; 605  : 	{
; 606  : 		::ATL::Checked::memmove_s(m_pData + nIndex, (size_t)nMoveCount * sizeof(TYPE),
; 607  : 			m_pData + nUpperBound, (size_t)nMoveCount * sizeof(TYPE));
; 608  : 	}
; 609  : 	m_nSize -= nCount;
; 610  : }
; 611  : 
; 612  : template<class TYPE, class ARG_TYPE>
; 613  : void CArray<TYPE, ARG_TYPE>::InsertAt(INT_PTR nStartIndex, CArray* pNewArray)
; 614  : {
; 615  : 	ASSERT_VALID(this);
; 616  : 	ASSERT(pNewArray != NULL);
; 617  : 	ASSERT_VALID(pNewArray);
; 618  : 	ASSERT(nStartIndex >= 0);
; 619  : 
; 620  : 	if(pNewArray == NULL || nStartIndex < 0)
; 621  : 		AfxThrowInvalidArgException();
; 622  : 
; 623  : 	if (pNewArray->GetSize() > 0)
; 624  : 	{
; 625  : 		InsertAt(nStartIndex, pNewArray->GetAt(0), pNewArray->GetSize());
; 626  : 		for (INT_PTR i = 0; i < pNewArray->GetSize(); i++)
; 627  : 			SetAt(nStartIndex + i, pNewArray->GetAt(i));
; 628  : 	}
; 629  : }
; 630  : 
; 631  : template<class TYPE, class ARG_TYPE>
; 632  : void CArray<TYPE, ARG_TYPE>::Serialize(CArchive& ar)
; 633  : {
; 634  : 	ASSERT_VALID(this);
; 635  : 
; 636  : 	CObject::Serialize(ar);
; 637  : 	if (ar.IsStoring())
; 638  : 	{
; 639  : 		ar.WriteCount(m_nSize);
; 640  : 	}
; 641  : 	else
; 642  : 	{
; 643  : 		DWORD_PTR nOldSize = ar.ReadCount();
; 644  : 		SetSize(nOldSize, -1);
; 645  : 	}
; 646  : 	SerializeElements<TYPE>(ar, m_pData, m_nSize);
; 647  : }
; 648  : 
; 649  : #ifdef _DEBUG
; 650  : template<class TYPE, class ARG_TYPE>
; 651  : void CArray<TYPE, ARG_TYPE>::Dump(CDumpContext& dc) const
; 652  : {
; 653  : 	CObject::Dump(dc);
; 654  : 
; 655  : 	dc << "with " << m_nSize << " elements";
; 656  : 	if (dc.GetDepth() > 0)
; 657  : 	{
; 658  : 		dc << "\n";
; 659  : 		DumpElements<TYPE>(dc, m_pData, m_nSize);
; 660  : 	}
; 661  : 
; 662  : 	dc << "\n";
; 663  : }
; 664  : 
; 665  : template<class TYPE, class ARG_TYPE>
; 666  : void CArray<TYPE, ARG_TYPE>::AssertValid() const
; 667  : {
; 668  : 	CObject::AssertValid();
; 669  : 
; 670  : 	if (m_pData == NULL)
; 671  : 	{
; 672  : 		ASSERT(m_nSize == 0);
; 673  : 		ASSERT(m_nMaxSize == 0);
; 674  : 	}
; 675  : 	else
; 676  : 	{
; 677  : 		ASSERT(m_nSize >= 0);
; 678  : 		ASSERT(m_nMaxSize >= 0);
; 679  : 		ASSERT(m_nSize <= m_nMaxSize);
; 680  : 		ASSERT(AfxIsValidAddress(m_pData, m_nMaxSize * sizeof(TYPE)));
; 681  : 	}
; 682  : }
; 683  : #endif //_DEBUG
; 684  : 
; 685  : /*============================================================================*/
; 686  : // CList<TYPE, ARG_TYPE>
; 687  : 
; 688  : template<class TYPE, class ARG_TYPE = const TYPE&>
; 689  : class CList : public CObject
; 690  : {
; 691  : protected:
; 692  : 	struct CNode
; 693  : 	{
; 694  : 		CNode* pNext;
; 695  : 		CNode* pPrev;
; 696  : 		TYPE data;
; 697  : 	};
; 698  : public:
; 699  : // Construction
; 700  : 	explicit CList(INT_PTR nBlockSize = 10);
; 701  : 
; 702  : // Attributes (head and tail)
; 703  : 	// count of elements
; 704  : 	INT_PTR GetCount() const;
; 705  : 	INT_PTR GetSize() const;
; 706  : 	BOOL IsEmpty() const;
; 707  : 
; 708  : 	// peek at head or tail
; 709  : 	TYPE& GetHead();
; 710  : 	const TYPE& GetHead() const;
; 711  : 	TYPE& GetTail();
; 712  : 	const TYPE& GetTail() const;
; 713  : 
; 714  : // Operations
; 715  : 	// get head or tail (and remove it) - don't call on empty list !
; 716  : 	TYPE RemoveHead();
; 717  : 	TYPE RemoveTail();
; 718  : 
; 719  : 	// add before head or after tail
; 720  : 	POSITION AddHead(ARG_TYPE newElement);
; 721  : 	POSITION AddTail(ARG_TYPE newElement);
; 722  : 
; 723  : 	// add another list of elements before head or after tail
; 724  : 	void AddHead(CList* pNewList);
; 725  : 	void AddTail(CList* pNewList);
; 726  : 
; 727  : 	// remove all elements
; 728  : 	void RemoveAll();
; 729  : 
; 730  : 	// iteration
; 731  : 	POSITION GetHeadPosition() const;
; 732  : 	POSITION GetTailPosition() const;
; 733  : 	TYPE& GetNext(POSITION& rPosition); // return *Position++
; 734  : 	const TYPE& GetNext(POSITION& rPosition) const; // return *Position++
; 735  : 	TYPE& GetPrev(POSITION& rPosition); // return *Position--
; 736  : 	const TYPE& GetPrev(POSITION& rPosition) const; // return *Position--
; 737  : 
; 738  : 	// getting/modifying an element at a given position
; 739  : 	TYPE& GetAt(POSITION position);
; 740  : 	const TYPE& GetAt(POSITION position) const;
; 741  : 	void SetAt(POSITION pos, ARG_TYPE newElement);
; 742  : 	void RemoveAt(POSITION position);
; 743  : 
; 744  : 	// inserting before or after a given position
; 745  : 	POSITION InsertBefore(POSITION position, ARG_TYPE newElement);
; 746  : 	POSITION InsertAfter(POSITION position, ARG_TYPE newElement);
; 747  : 
; 748  : 	// helper functions (note: O(n) speed)
; 749  : 	POSITION Find(ARG_TYPE searchValue, POSITION startAfter = NULL) const;
; 750  : 		// defaults to starting at the HEAD, return NULL if not found
; 751  : 	POSITION FindIndex(INT_PTR nIndex) const;
; 752  : 		// get the 'nIndex'th element (may return NULL)
; 753  : 
; 754  : // Implementation
; 755  : protected:
; 756  : 	CNode* m_pNodeHead;
; 757  : 	CNode* m_pNodeTail;
; 758  : 	INT_PTR m_nCount;
; 759  : 	CNode* m_pNodeFree;
; 760  : 	struct CPlex* m_pBlocks;
; 761  : 	INT_PTR m_nBlockSize;
; 762  : 
; 763  : 	CNode* NewNode(CNode*, CNode*);
; 764  : 	void FreeNode(CNode*);
; 765  : 
; 766  : public:
; 767  : 	~CList();
; 768  : 	void Serialize(CArchive&);
; 769  : #ifdef _DEBUG
; 770  : 	void Dump(CDumpContext&) const;
; 771  : 	void AssertValid() const;
; 772  : #endif
; 773  : };
; 774  : 
; 775  : /*============================================================================*/
; 776  : // CList<TYPE, ARG_TYPE> inline functions
; 777  : 
; 778  : template<class TYPE, class ARG_TYPE>
; 779  : AFX_INLINE INT_PTR CList<TYPE, ARG_TYPE>::GetCount() const
; 780  : 	{ return m_nCount; }
; 781  : template<class TYPE, class ARG_TYPE>
; 782  : AFX_INLINE INT_PTR CList<TYPE, ARG_TYPE>::GetSize() const
; 783  : 	{ return m_nCount; }
; 784  : template<class TYPE, class ARG_TYPE>
; 785  : AFX_INLINE BOOL CList<TYPE, ARG_TYPE>::IsEmpty() const
; 786  : 	{ return m_nCount == 0; }
; 787  : template<class TYPE, class ARG_TYPE>
; 788  : AFX_INLINE TYPE& CList<TYPE, ARG_TYPE>::GetHead()
; 789  : 	{ ENSURE(m_pNodeHead != NULL);
; 790  : 		return m_pNodeHead->data; }
; 791  : template<class TYPE, class ARG_TYPE>
; 792  : AFX_INLINE const TYPE& CList<TYPE, ARG_TYPE>::GetHead() const
; 793  : 	{ ENSURE(m_pNodeHead != NULL);
; 794  : 		return m_pNodeHead->data; }
; 795  : template<class TYPE, class ARG_TYPE>
; 796  : AFX_INLINE TYPE& CList<TYPE, ARG_TYPE>::GetTail()
; 797  : 	{ ENSURE(m_pNodeTail != NULL);
; 798  : 		return m_pNodeTail->data; }
; 799  : template<class TYPE, class ARG_TYPE>
; 800  : AFX_INLINE const TYPE& CList<TYPE, ARG_TYPE>::GetTail() const
; 801  : 	{ ENSURE(m_pNodeTail != NULL);
; 802  : 		return m_pNodeTail->data; }
; 803  : template<class TYPE, class ARG_TYPE>
; 804  : AFX_INLINE POSITION CList<TYPE, ARG_TYPE>::GetHeadPosition() const
; 805  : 	{ return (POSITION) m_pNodeHead; }
; 806  : template<class TYPE, class ARG_TYPE>
; 807  : AFX_INLINE POSITION CList<TYPE, ARG_TYPE>::GetTailPosition() const
; 808  : 	{ return (POSITION) m_pNodeTail; }
; 809  : template<class TYPE, class ARG_TYPE>
; 810  : AFX_INLINE TYPE& CList<TYPE, ARG_TYPE>::GetNext(POSITION& rPosition) // return *Position++
; 811  : 	{ CNode* pNode = (CNode*) rPosition;
; 812  : 		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 813  : 		rPosition = (POSITION) pNode->pNext;
; 814  : 		return pNode->data; }
; 815  : template<class TYPE, class ARG_TYPE>
; 816  : AFX_INLINE const TYPE& CList<TYPE, ARG_TYPE>::GetNext(POSITION& rPosition) const // return *Position++
; 817  : 	{ CNode* pNode = (CNode*) rPosition;
; 818  : 		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 819  : 		rPosition = (POSITION) pNode->pNext;
; 820  : 		return pNode->data; }
; 821  : template<class TYPE, class ARG_TYPE>
; 822  : AFX_INLINE TYPE& CList<TYPE, ARG_TYPE>::GetPrev(POSITION& rPosition) // return *Position--
; 823  : 	{ CNode* pNode = (CNode*) rPosition;
; 824  : 		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 825  : 		rPosition = (POSITION) pNode->pPrev;
; 826  : 		return pNode->data; }
; 827  : template<class TYPE, class ARG_TYPE>
; 828  : AFX_INLINE const TYPE& CList<TYPE, ARG_TYPE>::GetPrev(POSITION& rPosition) const // return *Position--
; 829  : 	{ CNode* pNode = (CNode*) rPosition;
; 830  : 		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 831  : 		rPosition = (POSITION) pNode->pPrev;
; 832  : 		return pNode->data; }
; 833  : template<class TYPE, class ARG_TYPE>
; 834  : AFX_INLINE TYPE& CList<TYPE, ARG_TYPE>::GetAt(POSITION position)
; 835  : 	{ CNode* pNode = (CNode*) position;
; 836  : 		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 837  : 		return pNode->data; }
; 838  : template<class TYPE, class ARG_TYPE>
; 839  : AFX_INLINE const TYPE& CList<TYPE, ARG_TYPE>::GetAt(POSITION position) const
; 840  : 	{ CNode* pNode = (CNode*) position;
; 841  : 		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 842  : 		return pNode->data; }
; 843  : template<class TYPE, class ARG_TYPE>
; 844  : AFX_INLINE void CList<TYPE, ARG_TYPE>::SetAt(POSITION pos, ARG_TYPE newElement)
; 845  : 	{ CNode* pNode = (CNode*) pos;
; 846  : 		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 847  : 		pNode->data = newElement; }
; 848  : 
; 849  : template<class TYPE, class ARG_TYPE>
; 850  : CList<TYPE, ARG_TYPE>::CList(INT_PTR nBlockSize)
; 851  : {
; 852  : 	ASSERT(nBlockSize > 0);
; 853  : 
; 854  : 	m_nCount = 0;
; 855  : 	m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
; 856  : 	m_pBlocks = NULL;
; 857  : 	m_nBlockSize = nBlockSize;
; 858  : }
; 859  : 
; 860  : template<class TYPE, class ARG_TYPE>
; 861  : void CList<TYPE, ARG_TYPE>::RemoveAll()
; 862  : {
; 863  : 	ASSERT_VALID(this);
; 864  : 
; 865  : 	// destroy elements
; 866  : 	CNode* pNode;
; 867  : 	for (pNode = m_pNodeHead; pNode != NULL; pNode = pNode->pNext)
; 868  : 		pNode->data.~TYPE();
; 869  : 
; 870  : 	m_nCount = 0;
; 871  : 	m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
; 872  : 	m_pBlocks->FreeDataChain();
; 873  : 	m_pBlocks = NULL;
; 874  : }
; 875  : 
; 876  : template<class TYPE, class ARG_TYPE>
; 877  : CList<TYPE, ARG_TYPE>::~CList()
; 878  : {
; 879  : 	RemoveAll();
; 880  : 	ASSERT(m_nCount == 0);
; 881  : }
; 882  : 
; 883  : /*============================================================================*/
; 884  : // Node helpers
; 885  : //
; 886  : // Implementation note: CNode's are stored in CPlex blocks and
; 887  : //  chained together. Free blocks are maintained in a singly linked list
; 888  : //  using the 'pNext' member of CNode with 'm_pNodeFree' as the head.
; 889  : //  Used blocks are maintained in a doubly linked list using both 'pNext'
; 890  : //  and 'pPrev' as links and 'm_pNodeHead' and 'm_pNodeTail'
; 891  : //   as the head/tail.
; 892  : //
; 893  : // We never free a CPlex block unless the List is destroyed or RemoveAll()
; 894  : //  is used - so the total number of CPlex blocks may grow large depending
; 895  : //  on the maximum past size of the list.
; 896  : //
; 897  : 
; 898  : template<class TYPE, class ARG_TYPE>
; 899  : typename CList<TYPE, ARG_TYPE>::CNode*
; 900  : CList<TYPE, ARG_TYPE>::NewNode(CNode* pPrev, CNode* pNext)
; 901  : {
; 902  : 	if (m_pNodeFree == NULL)
; 903  : 	{
; 904  : 		// add another block
; 905  : 		CPlex* pNewBlock = CPlex::Create(m_pBlocks, m_nBlockSize,
; 906  : 				 sizeof(CNode));
; 907  : 
; 908  : 		// chain them into free list
; 909  : 		CNode* pNode = (CNode*) pNewBlock->data();
; 910  : 		// free in reverse order to make it easier to debug
; 911  : 		pNode += m_nBlockSize - 1;
; 912  : 		for (INT_PTR i = m_nBlockSize-1; i >= 0; i--, pNode--)
; 913  : 		{
; 914  : 			pNode->pNext = m_pNodeFree;
; 915  : 			m_pNodeFree = pNode;
; 916  : 		}
; 917  : 	}
; 918  : 	ENSURE(m_pNodeFree != NULL);  // we must have something
; 919  : 
; 920  : 	CList::CNode* pNode = m_pNodeFree;
; 921  : 	m_pNodeFree = m_pNodeFree->pNext;
; 922  : 	pNode->pPrev = pPrev;
; 923  : 	pNode->pNext = pNext;
; 924  : 	m_nCount++;
; 925  : 	ASSERT(m_nCount > 0);  // make sure we don't overflow
; 926  : 
; 927  : #pragma push_macro("new")
; 928  : #undef new
; 929  : 	::new( (void*)( &pNode->data ) ) TYPE;
; 930  : #pragma pop_macro("new")
; 931  : 	return pNode;
; 932  : }
; 933  : 
; 934  : template<class TYPE, class ARG_TYPE>
; 935  : void CList<TYPE, ARG_TYPE>::FreeNode(CNode* pNode)
; 936  : {
; 937  : 	pNode->data.~TYPE();
; 938  : 	pNode->pNext = m_pNodeFree;
; 939  : 	m_pNodeFree = pNode;
; 940  : 	m_nCount--;
; 941  : 	ASSERT(m_nCount >= 0);  // make sure we don't underflow
; 942  : 
; 943  : 	// if no more elements, cleanup completely
; 944  : 	if (m_nCount == 0)
; 945  : 		RemoveAll();
; 946  : }
; 947  : 
; 948  : template<class TYPE, class ARG_TYPE>
; 949  : POSITION CList<TYPE, ARG_TYPE>::AddHead(ARG_TYPE newElement)
; 950  : {
; 951  : 	ASSERT_VALID(this);
; 952  : 
; 953  : 	CNode* pNewNode = NewNode(NULL, m_pNodeHead);
; 954  : 	pNewNode->data = newElement;
; 955  : 	if (m_pNodeHead != NULL)
; 956  : 		m_pNodeHead->pPrev = pNewNode;
; 957  : 	else
; 958  : 		m_pNodeTail = pNewNode;
; 959  : 	m_pNodeHead = pNewNode;
; 960  : 	return (POSITION) pNewNode;
; 961  : }
; 962  : 
; 963  : template<class TYPE, class ARG_TYPE>
; 964  : POSITION CList<TYPE, ARG_TYPE>::AddTail(ARG_TYPE newElement)
; 965  : {
; 966  : 	ASSERT_VALID(this);
; 967  : 
; 968  : 	CNode* pNewNode = NewNode(m_pNodeTail, NULL);
; 969  : 	pNewNode->data = newElement;
; 970  : 	if (m_pNodeTail != NULL)
; 971  : 		m_pNodeTail->pNext = pNewNode;
; 972  : 	else
; 973  : 		m_pNodeHead = pNewNode;
; 974  : 	m_pNodeTail = pNewNode;
; 975  : 	return (POSITION) pNewNode;
; 976  : }
; 977  : 
; 978  : template<class TYPE, class ARG_TYPE>
; 979  : void CList<TYPE, ARG_TYPE>::AddHead(CList* pNewList)
; 980  : {
; 981  : 	ASSERT_VALID(this);
; 982  : 
; 983  : 	ENSURE(pNewList != NULL);
; 984  : 	ASSERT_VALID(pNewList);
; 985  : 
; 986  : 	// add a list of same elements to head (maintain order)
; 987  : 	POSITION pos = pNewList->GetTailPosition();
; 988  : 	while (pos != NULL)
; 989  : 		AddHead(pNewList->GetPrev(pos));
; 990  : }
; 991  : 
; 992  : template<class TYPE, class ARG_TYPE>
; 993  : void CList<TYPE, ARG_TYPE>::AddTail(CList* pNewList)
; 994  : {
; 995  : 	ASSERT_VALID(this);
; 996  : 	ENSURE(pNewList != NULL);
; 997  : 	ASSERT_VALID(pNewList);
; 998  : 
; 999  : 	// add a list of same elements
; 1000 : 	POSITION pos = pNewList->GetHeadPosition();
; 1001 : 	while (pos != NULL)
; 1002 : 		AddTail(pNewList->GetNext(pos));
; 1003 : }
; 1004 : 
; 1005 : template<class TYPE, class ARG_TYPE>
; 1006 : TYPE CList<TYPE, ARG_TYPE>::RemoveHead()
; 1007 : {
; 1008 : 	ASSERT_VALID(this);
; 1009 : 	ENSURE(m_pNodeHead != NULL);  // don't call on empty list !!!
; 1010 : 	ASSERT(AfxIsValidAddress(m_pNodeHead, sizeof(CNode)));
; 1011 : 
; 1012 : 	CNode* pOldNode = m_pNodeHead;
; 1013 : 	TYPE returnValue = pOldNode->data;
; 1014 : 
; 1015 : 	m_pNodeHead = pOldNode->pNext;
; 1016 : 	if (m_pNodeHead != NULL)
; 1017 : 		m_pNodeHead->pPrev = NULL;
; 1018 : 	else
; 1019 : 		m_pNodeTail = NULL;
; 1020 : 	FreeNode(pOldNode);
; 1021 : 	return returnValue;
; 1022 : }
; 1023 : 
; 1024 : template<class TYPE, class ARG_TYPE>
; 1025 : TYPE CList<TYPE, ARG_TYPE>::RemoveTail()
; 1026 : {
; 1027 : 	ASSERT_VALID(this);
; 1028 : 	ENSURE(m_pNodeTail != NULL);  // don't call on empty list !!!
; 1029 : 	ASSERT(AfxIsValidAddress(m_pNodeTail, sizeof(CNode)));
; 1030 : 
; 1031 : 	CNode* pOldNode = m_pNodeTail;
; 1032 : 	TYPE returnValue = pOldNode->data;
; 1033 : 
; 1034 : 	m_pNodeTail = pOldNode->pPrev;
; 1035 : 	if (m_pNodeTail != NULL)
; 1036 : 		m_pNodeTail->pNext = NULL;
; 1037 : 	else
; 1038 : 		m_pNodeHead = NULL;
; 1039 : 	FreeNode(pOldNode);
; 1040 : 	return returnValue;
; 1041 : }
; 1042 : 
; 1043 : template<class TYPE, class ARG_TYPE>
; 1044 : POSITION CList<TYPE, ARG_TYPE>::InsertBefore(POSITION position, ARG_TYPE newElement)
; 1045 : {
; 1046 : 	ASSERT_VALID(this);
; 1047 : 
; 1048 : 	if (position == NULL)
; 1049 : 		return AddHead(newElement); // insert before nothing -> head of the list
; 1050 : 
; 1051 : 	// Insert it before position
; 1052 : 	CNode* pOldNode = (CNode*) position;
; 1053 : 	CNode* pNewNode = NewNode(pOldNode->pPrev, pOldNode);
; 1054 : 	pNewNode->data = newElement;
; 1055 : 
; 1056 : 	if (pOldNode->pPrev != NULL)
; 1057 : 	{
; 1058 : 		ASSERT(AfxIsValidAddress(pOldNode->pPrev, sizeof(CNode)));
; 1059 : 		pOldNode->pPrev->pNext = pNewNode;
; 1060 : 	}
; 1061 : 	else
; 1062 : 	{
; 1063 : 		ASSERT(pOldNode == m_pNodeHead);
; 1064 : 		m_pNodeHead = pNewNode;
; 1065 : 	}
; 1066 : 	pOldNode->pPrev = pNewNode;
; 1067 : 	return (POSITION) pNewNode;
; 1068 : }
; 1069 : 
; 1070 : template<class TYPE, class ARG_TYPE>
; 1071 : POSITION CList<TYPE, ARG_TYPE>::InsertAfter(POSITION position, ARG_TYPE newElement)
; 1072 : {
; 1073 : 	ASSERT_VALID(this);
; 1074 : 
; 1075 : 	if (position == NULL)
; 1076 : 		return AddTail(newElement); // insert after nothing -> tail of the list
; 1077 : 
; 1078 : 	// Insert it before position
; 1079 : 	CNode* pOldNode = (CNode*) position;
; 1080 : 	ASSERT(AfxIsValidAddress(pOldNode, sizeof(CNode)));
; 1081 : 	CNode* pNewNode = NewNode(pOldNode, pOldNode->pNext);
; 1082 : 	pNewNode->data = newElement;
; 1083 : 
; 1084 : 	if (pOldNode->pNext != NULL)
; 1085 : 	{
; 1086 : 		ASSERT(AfxIsValidAddress(pOldNode->pNext, sizeof(CNode)));
; 1087 : 		pOldNode->pNext->pPrev = pNewNode;
; 1088 : 	}
; 1089 : 	else
; 1090 : 	{
; 1091 : 		ASSERT(pOldNode == m_pNodeTail);
; 1092 : 		m_pNodeTail = pNewNode;
; 1093 : 	}
; 1094 : 	pOldNode->pNext = pNewNode;
; 1095 : 	return (POSITION) pNewNode;
; 1096 : }
; 1097 : 
; 1098 : template<class TYPE, class ARG_TYPE>
; 1099 : void CList<TYPE, ARG_TYPE>::RemoveAt(POSITION position)
; 1100 : {
; 1101 : 	ASSERT_VALID(this);
; 1102 : 
; 1103 : 	CNode* pOldNode = (CNode*) position;
; 1104 : 	ASSERT(AfxIsValidAddress(pOldNode, sizeof(CNode)));
; 1105 : 
; 1106 : 	// remove pOldNode from list
; 1107 : 	if (pOldNode == m_pNodeHead)
; 1108 : 	{
; 1109 : 		m_pNodeHead = pOldNode->pNext;
; 1110 : 	}
; 1111 : 	else
; 1112 : 	{
; 1113 : 		ASSERT(AfxIsValidAddress(pOldNode->pPrev, sizeof(CNode)));
; 1114 : 		pOldNode->pPrev->pNext = pOldNode->pNext;
; 1115 : 	}
; 1116 : 	if (pOldNode == m_pNodeTail)
; 1117 : 	{
; 1118 : 		m_pNodeTail = pOldNode->pPrev;
; 1119 : 	}
; 1120 : 	else
; 1121 : 	{
; 1122 : 		ASSERT(AfxIsValidAddress(pOldNode->pNext, sizeof(CNode)));
; 1123 : 		pOldNode->pNext->pPrev = pOldNode->pPrev;
; 1124 : 	}
; 1125 : 	FreeNode(pOldNode);
; 1126 : }
; 1127 : 
; 1128 : template<class TYPE, class ARG_TYPE>
; 1129 : POSITION CList<TYPE, ARG_TYPE>::FindIndex(INT_PTR nIndex) const
; 1130 : {
; 1131 : 	ASSERT_VALID(this);
; 1132 : 
; 1133 : 	if (nIndex >= m_nCount || nIndex < 0)
; 1134 : 		return NULL;  // went too far
; 1135 : 
; 1136 : 	CNode* pNode = m_pNodeHead;
; 1137 : 	while (nIndex--)
; 1138 : 	{
; 1139 : 		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 1140 : 		pNode = pNode->pNext;
; 1141 : 	}
; 1142 : 	return (POSITION) pNode;
; 1143 : }
; 1144 : 
; 1145 : template<class TYPE, class ARG_TYPE>
; 1146 : POSITION CList<TYPE, ARG_TYPE>::Find(ARG_TYPE searchValue, POSITION startAfter) const
; 1147 : {
; 1148 : 	ASSERT_VALID(this);
; 1149 : 
; 1150 : 	CNode* pNode = (CNode*) startAfter;
; 1151 : 	if (pNode == NULL)
; 1152 : 	{
; 1153 : 		pNode = m_pNodeHead;  // start at head
; 1154 : 	}
; 1155 : 	else
; 1156 : 	{
; 1157 : 		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 1158 : 		pNode = pNode->pNext;  // start after the one specified
; 1159 : 	}
; 1160 : 
; 1161 : 	for (; pNode != NULL; pNode = pNode->pNext)
; 1162 : 		if (CompareElements<TYPE>(&pNode->data, &searchValue))
; 1163 : 			return (POSITION)pNode;
; 1164 : 	return NULL;
; 1165 : }
; 1166 : 
; 1167 : template<class TYPE, class ARG_TYPE>
; 1168 : void CList<TYPE, ARG_TYPE>::Serialize(CArchive& ar)
; 1169 : {
; 1170 : 	ASSERT_VALID(this);
; 1171 : 
; 1172 : 	CObject::Serialize(ar);
; 1173 : 
; 1174 : 	if (ar.IsStoring())
; 1175 : 	{
; 1176 : 		ar.WriteCount(m_nCount);
; 1177 : 		for (CNode* pNode = m_pNodeHead; pNode != NULL; pNode = pNode->pNext)
; 1178 : 		{
; 1179 : 			ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 1180 : 			TYPE* pData;
; 1181 : 			/*
; 1182 : 			 * in some cases the & operator might be overloaded, and we cannot use it to obtain
; 1183 : 			 * the address of a given object.  We then use the following trick to get the address
; 1184 : 			 */
; 1185 : 			pData = reinterpret_cast< TYPE* >( &reinterpret_cast< int& >( static_cast< TYPE& >( pNode->data ) ) );
; 1186 : 			SerializeElements<TYPE>(ar, pData, 1);
; 1187 : 		}
; 1188 : 	}
; 1189 : 	else
; 1190 : 	{
; 1191 : 		DWORD_PTR nNewCount = ar.ReadCount();
; 1192 : 		while (nNewCount--)
; 1193 : 		{
; 1194 : 			TYPE newData[1];
; 1195 : 			SerializeElements<TYPE>(ar, newData, 1);
; 1196 : 			AddTail(newData[0]);
; 1197 : 		}
; 1198 : 	}
; 1199 : }
; 1200 : 
; 1201 : #ifdef _DEBUG
; 1202 : template<class TYPE, class ARG_TYPE>
; 1203 : void CList<TYPE, ARG_TYPE>::Dump(CDumpContext& dc) const
; 1204 : {
; 1205 : 	CObject::Dump(dc);
; 1206 : 
; 1207 : 	dc << "with " << m_nCount << " elements";
; 1208 : 	if (dc.GetDepth() > 0)
; 1209 : 	{
; 1210 : 		POSITION pos = GetHeadPosition();
; 1211 : 		while (pos != NULL)
; 1212 : 		{
; 1213 : 			TYPE temp[1];
; 1214 : 			temp[0] = ((CList*)this)->GetNext(pos);
; 1215 : 			dc << "\n";
; 1216 : 			DumpElements<TYPE>(dc, temp, 1);
; 1217 : 		}
; 1218 : 	}
; 1219 : 
; 1220 : 	dc << "\n";
; 1221 : }
; 1222 : 
; 1223 : template<class TYPE, class ARG_TYPE>
; 1224 : void CList<TYPE, ARG_TYPE>::AssertValid() const
; 1225 : {
; 1226 : 	CObject::AssertValid();
; 1227 : 
; 1228 : 	if (m_nCount == 0)
; 1229 : 	{
; 1230 : 		// empty list
; 1231 : 		ASSERT(m_pNodeHead == NULL);
; 1232 : 		ASSERT(m_pNodeTail == NULL);
; 1233 : 	}
; 1234 : 	else
; 1235 : 	{
; 1236 : 		// non-empty list
; 1237 : 		ASSERT(AfxIsValidAddress(m_pNodeHead, sizeof(CNode)));
; 1238 : 		ASSERT(AfxIsValidAddress(m_pNodeTail, sizeof(CNode)));
; 1239 : 	}
; 1240 : }
; 1241 : #endif //_DEBUG
; 1242 : 
; 1243 : /*============================================================================*/
; 1244 : // CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>
; 1245 : 
; 1246 : template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
; 1247 : class CMap : public CObject
; 1248 : {
; 1249 : public:
; 1250 : 	// CPair
; 1251 : 	struct CPair
; 1252 : 	{
; 1253 : 		const KEY key;
; 1254 : 		VALUE value;
; 1255 : 	protected:
; 1256 : 		CPair( ARG_KEY keyval ) : key( keyval )	{}
; 1257 : 	};
; 1258 : 
; 1259 : protected:
; 1260 : 	// Association
; 1261 : 	class CAssoc : public CPair
; 1262 : 	{
; 1263 : 		friend class CMap<KEY,ARG_KEY,VALUE,ARG_VALUE>;
; 1264 : 		CAssoc* pNext;
; 1265 : 		UINT nHashValue;  // needed for efficient iteration
; 1266 : 	public:
; 1267 : 		CAssoc( ARG_KEY key ) : CPair( key ) {}
; 1268 : 	};
; 1269 : 
; 1270 : public:
; 1271 : // Construction
; 1272 : 	explicit CMap(INT_PTR nBlockSize = 10);
; 1273 : 
; 1274 : // Attributes
; 1275 : 	// number of elements
; 1276 : 	INT_PTR GetCount() const;
; 1277 : 	INT_PTR GetSize() const;
; 1278 : 	BOOL IsEmpty() const;
; 1279 : 
; 1280 : 	// Lookup
; 1281 : 	BOOL Lookup(ARG_KEY key, VALUE& rValue) const;
; 1282 : 	const CPair *PLookup(ARG_KEY key) const;
; 1283 : 	CPair *PLookup(ARG_KEY key);
; 1284 : 
; 1285 : // Operations
; 1286 : 	// Lookup and add if not there
; 1287 : 	VALUE& operator[](ARG_KEY key);
; 1288 : 
; 1289 : 	// add a new (key, value) pair
; 1290 : 	void SetAt(ARG_KEY key, ARG_VALUE newValue);
; 1291 : 
; 1292 : 	// removing existing (key, ?) pair
; 1293 : 	BOOL RemoveKey(ARG_KEY key);
; 1294 : 	void RemoveAll();
; 1295 : 
; 1296 : 	// iterating all (key, value) pairs
; 1297 : 	POSITION GetStartPosition() const;
; 1298 : 
; 1299 : 	const CPair *PGetFirstAssoc() const;
; 1300 : 	CPair *PGetFirstAssoc();
; 1301 : 
; 1302 : 	void GetNextAssoc(POSITION& rNextPosition, KEY& rKey, VALUE& rValue) const;
; 1303 : 
; 1304 : 	const CPair *PGetNextAssoc(const CPair *pAssocRet) const;
; 1305 : 	CPair *PGetNextAssoc(const CPair *pAssocRet);
; 1306 : 
; 1307 : 	// advanced features for derived classes
; 1308 : 	UINT GetHashTableSize() const;
; 1309 : 	void InitHashTable(UINT hashSize, BOOL bAllocNow = TRUE);
; 1310 : 
; 1311 : // Implementation
; 1312 : protected:
; 1313 : 	CAssoc** m_pHashTable;
; 1314 : 	UINT m_nHashTableSize;
; 1315 : 	INT_PTR m_nCount;
; 1316 : 	CAssoc* m_pFreeList;
; 1317 : 	struct CPlex* m_pBlocks;
; 1318 : 	INT_PTR m_nBlockSize;
; 1319 : 
; 1320 : 	CAssoc* NewAssoc(ARG_KEY key);
; 1321 : 	void FreeAssoc(CAssoc*);
; 1322 : 	CAssoc* GetAssocAt(ARG_KEY, UINT&, UINT&) const;
; 1323 : 
; 1324 : public:
; 1325 : 	~CMap();
; 1326 : 	void Serialize(CArchive&);
; 1327 : #ifdef _DEBUG
; 1328 : 	void Dump(CDumpContext&) const;
; 1329 : 	void AssertValid() const;
; 1330 : #endif
; 1331 : };
; 1332 : 
; 1333 : /*============================================================================*/
; 1334 : // CMap<KEY, ARG_KEY, VALUE, ARG_VALUE> inline functions
; 1335 : 
; 1336 : template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
; 1337 : AFX_INLINE INT_PTR CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetCount() const
; 1338 : 	{ return m_nCount; }
; 1339 : 
; 1340 : template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
; 1341 : AFX_INLINE INT_PTR CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetSize() const
; 1342 : 	{ return m_nCount; }
; 1343 : 
; 1344 : template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
; 1345 : AFX_INLINE BOOL CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::IsEmpty() const
; 1346 : 	{ return m_nCount == 0; }
; 1347 : 
; 1348 : template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
; 1349 : AFX_INLINE void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::SetAt(ARG_KEY key, ARG_VALUE newValue)
; 1350 : 	{ (*this)[key] = newValue; }
; 1351 : 
; 1352 : template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
; 1353 : AFX_INLINE POSITION CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetStartPosition() const
; 1354 : 	{ return (m_nCount == 0) ? NULL : BEFORE_START_POSITION; }
; 1355 : 
; 1356 : template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
; 1357 : const typename CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CPair* CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::PGetFirstAssoc() const
; 1358 : {
; 1359 : 	ASSERT_VALID(this);
; 1360 : 	if(m_nCount == 0) return NULL;
; 1361 : 
; 1362 : 	AFXASSUME(m_pHashTable != NULL);  // never call on empty map
; 1363 : 
; 1364 : 	CAssoc* pAssocRet = (CAssoc*)BEFORE_START_POSITION;
; 1365 : 
; 1366 : 	// find the first association
; 1367 : 	for (UINT nBucket = 0; nBucket < m_nHashTableSize; nBucket++)
; 1368 : 		if ((pAssocRet = m_pHashTable[nBucket]) != NULL)
; 1369 : 			break;
; 1370 : 	ASSERT(pAssocRet != NULL);  // must find something
; 1371 : 
; 1372 : 	return pAssocRet;
; 1373 : }
; 1374 : 
; 1375 : template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
; 1376 : typename CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CPair* CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::PGetFirstAssoc()
; 1377 : {
; 1378 : 	ASSERT_VALID(this);
; 1379 : 	if(m_nCount == 0) return NULL;
; 1380 : 
; 1381 : 	AFXASSUME(m_pHashTable != NULL);  // never call on empty map
; 1382 : 
; 1383 : 	CAssoc* pAssocRet = (CAssoc*)BEFORE_START_POSITION;
; 1384 : 
; 1385 : 	// find the first association
; 1386 : 	for (UINT nBucket = 0; nBucket < m_nHashTableSize; nBucket++)
; 1387 : 		if ((pAssocRet = m_pHashTable[nBucket]) != NULL)
; 1388 : 			break;
; 1389 : 	ASSERT(pAssocRet != NULL);  // must find something
; 1390 : 
; 1391 : 	return pAssocRet;
; 1392 : }
; 1393 : 
; 1394 : template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
; 1395 : AFX_INLINE UINT CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetHashTableSize() const
; 1396 : 	{ return m_nHashTableSize; }
; 1397 : 
; 1398 : /*============================================================================*/
; 1399 : // CMap<KEY, ARG_KEY, VALUE, ARG_VALUE> out-of-line functions
; 1400 : 
; 1401 : template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
; 1402 : CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CMap(INT_PTR nBlockSize)
; 1403 : {
; 1404 : 	ASSERT(nBlockSize > 0);
; 1405 : 
; 1406 : 	m_pHashTable = NULL;
; 1407 : 	m_nHashTableSize = 17;  // default size
; 1408 : 	m_nCount = 0;
; 1409 : 	m_pFreeList = NULL;
; 1410 : 	m_pBlocks = NULL;
; 1411 : 	m_nBlockSize = nBlockSize;
; 1412 : }
; 1413 : 
; 1414 : template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
; 1415 : void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::InitHashTable(
; 1416 : 	UINT nHashSize, BOOL bAllocNow)
; 1417 : //
; 1418 : // Used to force allocation of a hash table or to override the default
; 1419 : //   hash table size of (which is fairly small)
; 1420 : {
; 1421 : 	ASSERT_VALID(this);
; 1422 : 	ASSERT(m_nCount == 0);
; 1423 : 	ASSERT(nHashSize > 0);
; 1424 : 
; 1425 : 	if (m_pHashTable != NULL)
; 1426 : 	{
; 1427 : 		// free hash table
; 1428 : 		delete[] m_pHashTable;
; 1429 : 		m_pHashTable = NULL;
; 1430 : 	}
; 1431 : 
; 1432 : 	if (bAllocNow)
; 1433 : 	{
; 1434 : 		m_pHashTable = new CAssoc* [nHashSize];
; 1435 : 		ENSURE(m_pHashTable != NULL);
; 1436 : 		memset(m_pHashTable, 0, sizeof(CAssoc*) * nHashSize);
; 1437 : 	}
; 1438 : 	m_nHashTableSize = nHashSize;
; 1439 : }
; 1440 : 
; 1441 : template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
; 1442 : void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::RemoveAll()
; 1443 : {
; 1444 : 	ASSERT_VALID(this);
; 1445 : 
; 1446 : 	if (m_pHashTable != NULL)
; 1447 : 	{
; 1448 : 		// destroy elements (values and keys)
; 1449 : 		for (UINT nHash = 0; nHash < m_nHashTableSize; nHash++)
; 1450 : 		{
; 1451 : 			CAssoc* pAssoc;
; 1452 : 			for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL;
; 1453 : 			  pAssoc = pAssoc->pNext)
; 1454 : 			{
; 1455 : 				pAssoc->CAssoc::~CAssoc();
; 1456 : 			}
; 1457 : 		}
; 1458 : 
; 1459 : 		// free hash table
; 1460 : 		delete[] m_pHashTable;
; 1461 : 		m_pHashTable = NULL;
; 1462 : 	}
; 1463 : 
; 1464 : 	m_nCount = 0;
; 1465 : 	m_pFreeList = NULL;
; 1466 : 	m_pBlocks->FreeDataChain();
; 1467 : 	m_pBlocks = NULL;
; 1468 : }
; 1469 : 
; 1470 : template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
; 1471 : CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::~CMap()
; 1472 : {
; 1473 : 	RemoveAll();
; 1474 : 	ASSERT(m_nCount == 0);
; 1475 : }
; 1476 : 
; 1477 : template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
; 1478 : typename CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CAssoc*
; 1479 : CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::NewAssoc(ARG_KEY key)
; 1480 : {
; 1481 : 	if (m_pFreeList == NULL)
; 1482 : 	{
; 1483 : 		// add another block
; 1484 : 		CPlex* newBlock = CPlex::Create(m_pBlocks, m_nBlockSize, sizeof(CMap::CAssoc));
; 1485 : 		// chain them into free list
; 1486 : 		CMap::CAssoc* pAssoc = (CMap::CAssoc*) newBlock->data();
; 1487 : 		// free in reverse order to make it easier to debug
; 1488 : 		pAssoc += m_nBlockSize - 1;
; 1489 : 		for (INT_PTR i = m_nBlockSize-1; i >= 0; i--, pAssoc--)
; 1490 : 		{
; 1491 : 			pAssoc->pNext = m_pFreeList;
; 1492 : 			m_pFreeList = pAssoc;
; 1493 : 		}
; 1494 : 	}
; 1495 : 	ENSURE(m_pFreeList != NULL);  // we must have something
; 1496 : 
; 1497 : 	CMap::CAssoc* pAssoc = m_pFreeList;
; 1498 : 
; 1499 : 	// zero the memory
; 1500 : 	CMap::CAssoc* pTemp = pAssoc->pNext;
; 1501 : 	memset( pAssoc, 0, sizeof(CMap::CAssoc) );
; 1502 : 	pAssoc->pNext = pTemp;
; 1503 : 
; 1504 : 	m_pFreeList = m_pFreeList->pNext;
; 1505 : 	m_nCount++;
; 1506 : 	ASSERT(m_nCount > 0);  // make sure we don't overflow
; 1507 : #pragma push_macro("new")
; 1508 : #undef new
; 1509 : 	::new(pAssoc) CMap::CAssoc(key);
; 1510 : #pragma pop_macro("new")
; 1511 : 	return pAssoc;
; 1512 : }
; 1513 : 
; 1514 : template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
; 1515 : void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::FreeAssoc(CAssoc* pAssoc)
; 1516 : {
; 1517 : 	pAssoc->CAssoc::~CAssoc();
; 1518 : 	pAssoc->pNext = m_pFreeList;
; 1519 : 	m_pFreeList = pAssoc;
; 1520 : 	m_nCount--;
; 1521 : 	ASSERT(m_nCount >= 0);  // make sure we don't underflow
; 1522 : 
; 1523 : 	// if no more elements, cleanup completely
; 1524 : 	if (m_nCount == 0)
; 1525 : 		RemoveAll();
; 1526 : }
; 1527 : 
; 1528 : template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
; 1529 : typename CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CAssoc*
; 1530 : CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetAssocAt(ARG_KEY key, UINT& nHashBucket, UINT& nHashValue) const
; 1531 : // find association (or return NULL)
; 1532 : {
; 1533 : 	nHashValue = HashKey<ARG_KEY>(key);
; 1534 : 	nHashBucket = nHashValue % m_nHashTableSize;

  002ba	33 d2		 xor	 edx, edx
  002bc	8b c6		 mov	 eax, esi
  002be	f7 b7 0c 01 00
	00		 div	 DWORD PTR [edi+268]

; 1537 : 		return NULL;
; 1538 : 
; 1539 : 	// see if it exists
; 1540 : 	CAssoc* pAssoc;
; 1541 : 	for (pAssoc = m_pHashTable[nHashBucket]; pAssoc != NULL; pAssoc = pAssoc->pNext)

  002c4	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  002c7	85 c0		 test	 eax, eax
  002c9	74 24		 je	 SHORT $LN163@OnApply
  002cb	8b 4d c0	 mov	 ecx, DWORD PTR _nFieldKey$2$[ebp]
  002ce	66 90		 npad	 2
$LL73@OnApply:

; 1542 : 	{
; 1543 : 		if (pAssoc->nHashValue == nHashValue && CompareElements(&pAssoc->key, &key))

  002d0	39 70 0c	 cmp	 DWORD PTR [eax+12], esi
  002d3	75 04		 jne	 SHORT $LN71@OnApply

; 156  : 	return *pElement1 == *pElement2;

  002d5	39 08		 cmp	 DWORD PTR [eax], ecx

; 1543 : 		if (pAssoc->nHashValue == nHashValue && CompareElements(&pAssoc->key, &key))

  002d7	74 09		 je	 SHORT $LN70@OnApply
$LN71@OnApply:

; 1537 : 		return NULL;
; 1538 : 
; 1539 : 	// see if it exists
; 1540 : 	CAssoc* pAssoc;
; 1541 : 	for (pAssoc = m_pHashTable[nHashBucket]; pAssoc != NULL; pAssoc = pAssoc->pNext)

  002d9	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  002dc	85 c0		 test	 eax, eax
  002de	75 f0		 jne	 SHORT $LL73@OnApply
  002e0	eb 0d		 jmp	 SHORT $LN163@OnApply
$LN70@OnApply:

; 1559 : 	rValue = pAssoc->value;

  002e2	83 c0 04	 add	 eax, 4
  002e5	8d 4d bc	 lea	 ecx, DWORD PTR _strFieldName$[ebp]
  002e8	50		 push	 eax
  002e9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
$LN163@OnApply:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 146  : 		strValue.Format("%d,%s", nFieldKey, strFieldName);

  002ef	ff 75 bc	 push	 DWORD PTR _strFieldName$[ebp]
  002f2	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp_?Format@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAAXPBDZZ
  002f8	8d 45 cc	 lea	 eax, DWORD PTR _strValue$[ebp]
  002fb	ff 75 c0	 push	 DWORD PTR _nFieldKey$2$[ebp]
  002fe	68 00 00 00 00	 push	 OFFSET ??_C@_05KFJOKFOM@?$CFd?0?$CFs@
  00303	50		 push	 eax
  00304	ff d6		 call	 esi

; 147  : 
; 148  : 		str.Format("%02d", i);

  00306	53		 push	 ebx
  00307	8d 45 b8	 lea	 eax, DWORD PTR _str$[ebp]
  0030a	68 00 00 00 00	 push	 OFFSET ??_C@_04OGKJMPGK@?$CF02d@
  0030f	50		 push	 eax
  00310	ff d6		 call	 esi
  00312	83 c4 1c	 add	 esp, 28			; 0000001cH

; 149  : 		::WritePrivateProfileString(szKey, str, strValue, strConfigPath);

  00315	8d 45 d0	 lea	 eax, DWORD PTR _szKey$[ebp]
  00318	ff 75 c8	 push	 DWORD PTR _strConfigPath$[ebp]
  0031b	ff 75 cc	 push	 DWORD PTR _strValue$[ebp]
  0031e	ff 75 b8	 push	 DWORD PTR _str$[ebp]
  00321	50		 push	 eax
  00322	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WritePrivateProfileStringA@16
  00328	43		 inc	 ebx
  00329	3b 5d c4	 cmp	 ebx, DWORD PTR _nCnt$2$[ebp]
  0032c	0f 8c 3f ff ff
	ff		 jl	 $LL7@OnApply
$LN6@OnApply:

; 150  : 	}
; 151  : 
; 152  : 	//***********************************************************
; 153  : 	// User List Item User file Write
; 154  : 	//***********************************************************
; 155  : 	nCnt = m_arrayUserIdx.GetSize();

  00332	8b 9f dc 00 00
	00		 mov	 ebx, DWORD PTR [edi+220]

; 156  : 	
; 157  : 	sprintf(szKey,"%s","USER LIST");

  00338	8d 45 d0	 lea	 eax, DWORD PTR _szKey$[ebp]
  0033b	68 00 00 00 00	 push	 OFFSET ??_C@_09BBDODMFB@USER?5LIST@
  00340	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  00345	50		 push	 eax
  00346	89 5d c4	 mov	 DWORD PTR _nCnt$3$[ebp], ebx
  00349	e8 00 00 00 00	 call	 _sprintf

; 158  : 
; 159  : 	strValue.Format("%d",nCnt);

  0034e	53		 push	 ebx
  0034f	8d 45 cc	 lea	 eax, DWORD PTR _strValue$[ebp]
  00352	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  00357	50		 push	 eax
  00358	ff d6		 call	 esi
  0035a	83 c4 18	 add	 esp, 24			; 00000018H

; 160  : 	::WritePrivateProfileString(szKey, "COUNT", strValue, strConfigPath);

  0035d	8d 45 d0	 lea	 eax, DWORD PTR _szKey$[ebp]
  00360	ff 75 c8	 push	 DWORD PTR _strConfigPath$[ebp]
  00363	ff 75 cc	 push	 DWORD PTR _strValue$[ebp]
  00366	68 00 00 00 00	 push	 OFFSET ??_C@_05EFFCCOAM@COUNT@
  0036b	50		 push	 eax
  0036c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WritePrivateProfileStringA@16

; 161  : 	for (i=0; i < nCnt ; i++)

  00372	33 db		 xor	 ebx, ebx
  00374	39 5d c4	 cmp	 DWORD PTR _nCnt$3$[ebp], ebx
  00377	0f 8e c5 00 00
	00		 jle	 $LN9@OnApply
  0037d	0f 1f 00	 npad	 3
$LL10@OnApply:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 288  : 	if(nIndex >= 0 && nIndex < m_nSize)

  00380	85 db		 test	 ebx, ebx
  00382	0f 88 14 01 00
	00		 js	 $LN101@OnApply
  00388	3b 9f dc 00 00
	00		 cmp	 ebx, DWORD PTR [edi+220]
  0038e	0f 8d 08 01 00
	00		 jge	 $LN101@OnApply
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 163  : 		nFieldKey = m_arrayUserIdx.GetAt(i);

  00394	8b 87 d8 00 00
	00		 mov	 eax, DWORD PTR [edi+216]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 165  : 	ldiv_t HashVal = ldiv((long)(ARG_KEY)key, 127773);

  0039a	b9 1d f3 01 00	 mov	 ecx, 127773		; 0001f31dH
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 163  : 		nFieldKey = m_arrayUserIdx.GetAt(i);

  0039f	8b 04 98	 mov	 eax, DWORD PTR [eax+ebx*4]
  003a2	89 45 c0	 mov	 DWORD PTR _nFieldKey$3$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 165  : 	ldiv_t HashVal = ldiv((long)(ARG_KEY)key, 127773);

  003a5	99		 cdq
  003a6	f7 f9		 idiv	 ecx

; 166  : 	HashVal.rem = 16807 * HashVal.rem - 2836 * HashVal.quot;

  003a8	69 ca a7 41 00
	00		 imul	 ecx, edx, 16807
  003ae	69 c0 14 0b 00
	00		 imul	 eax, eax, 2836
  003b4	2b c8		 sub	 ecx, eax

; 1536 : 	if (m_pHashTable == NULL)

  003b6	8d b1 ff ff ff
	7f		 lea	 esi, DWORD PTR [ecx+2147483647]
  003bc	0f 49 f1	 cmovns	 esi, ecx
  003bf	8b 8f 24 01 00
	00		 mov	 ecx, DWORD PTR [edi+292]
  003c5	85 c9		 test	 ecx, ecx
  003c7	74 36		 je	 SHORT $LN164@OnApply

; 291  : }
; 292  : template<class TYPE, class ARG_TYPE>
; 293  : AFX_INLINE const TYPE& CArray<TYPE, ARG_TYPE>::GetAt(INT_PTR nIndex) const
; 294  : {
; 295  : 	ASSERT(nIndex >= 0 && nIndex < m_nSize);
; 296  : 	if(nIndex >= 0 && nIndex < m_nSize)
; 297  : 		return m_pData[nIndex];
; 298  : 	AfxThrowInvalidArgException();
; 299  : }
; 300  : template<class TYPE, class ARG_TYPE>
; 301  : AFX_INLINE void CArray<TYPE, ARG_TYPE>::SetAt(INT_PTR nIndex, ARG_TYPE newElement)
; 302  : {
; 303  : 	ASSERT(nIndex >= 0 && nIndex < m_nSize);
; 304  : 	if(nIndex >= 0 && nIndex < m_nSize)
; 305  : 		m_pData[nIndex] = newElement;
; 306  : 	else
; 307  : 		AfxThrowInvalidArgException();
; 308  : }
; 309  : template<class TYPE, class ARG_TYPE>
; 310  : AFX_INLINE const TYPE& CArray<TYPE, ARG_TYPE>::ElementAt(INT_PTR nIndex) const
; 311  : {
; 312  : 	ASSERT(nIndex >= 0 && nIndex < m_nSize);
; 313  : 	if(nIndex >= 0 && nIndex < m_nSize)
; 314  : 		return m_pData[nIndex];
; 315  : 	AfxThrowInvalidArgException();
; 316  : }
; 317  : template<class TYPE, class ARG_TYPE>
; 318  : AFX_INLINE TYPE& CArray<TYPE, ARG_TYPE>::ElementAt(INT_PTR nIndex)
; 319  : {
; 320  : 	ASSERT(nIndex >= 0 && nIndex < m_nSize);
; 321  : 	if(nIndex >= 0 && nIndex < m_nSize)
; 322  : 		return m_pData[nIndex];
; 323  : 	AfxThrowInvalidArgException();
; 324  : }
; 325  : template<class TYPE, class ARG_TYPE>
; 326  : AFX_INLINE const TYPE* CArray<TYPE, ARG_TYPE>::GetData() const
; 327  : 	{ return (const TYPE*)m_pData; }
; 328  : template<class TYPE, class ARG_TYPE>
; 329  : AFX_INLINE TYPE* CArray<TYPE, ARG_TYPE>::GetData()
; 330  : 	{ return (TYPE*)m_pData; }
; 331  : template<class TYPE, class ARG_TYPE>
; 332  : AFX_INLINE INT_PTR CArray<TYPE, ARG_TYPE>::Add(ARG_TYPE newElement)
; 333  : 	{ INT_PTR nIndex = m_nSize;
; 334  : 		SetAtGrow(nIndex, newElement);
; 335  : 		return nIndex; }
; 336  : template<class TYPE, class ARG_TYPE>
; 337  : AFX_INLINE const TYPE& CArray<TYPE, ARG_TYPE>::operator[](INT_PTR nIndex) const
; 338  : 	{ return GetAt(nIndex); }
; 339  : template<class TYPE, class ARG_TYPE>
; 340  : AFX_INLINE TYPE& CArray<TYPE, ARG_TYPE>::operator[](INT_PTR nIndex)
; 341  : 	{ return ElementAt(nIndex); }
; 342  : 
; 343  : /*============================================================================*/
; 344  : // CArray<TYPE, ARG_TYPE> out-of-line functions
; 345  : 
; 346  : template<class TYPE, class ARG_TYPE>
; 347  : CArray<TYPE, ARG_TYPE>::CArray()
; 348  : {
; 349  : 	m_pData = NULL;
; 350  : 	m_nSize = m_nMaxSize = m_nGrowBy = 0;
; 351  : }
; 352  : 
; 353  : template<class TYPE, class ARG_TYPE>
; 354  : CArray<TYPE, ARG_TYPE>::~CArray()
; 355  : {
; 356  : 	ASSERT_VALID(this);
; 357  : 
; 358  : 	if (m_pData != NULL)
; 359  : 	{
; 360  : 		for( int i = 0; i < m_nSize; i++ )
; 361  : 			(m_pData + i)->~TYPE();
; 362  : 		delete[] (BYTE*)m_pData;
; 363  : 	}
; 364  : }
; 365  : 
; 366  : template<class TYPE, class ARG_TYPE>
; 367  : void CArray<TYPE, ARG_TYPE>::SetSize(INT_PTR nNewSize, INT_PTR nGrowBy)
; 368  : {
; 369  : 	ASSERT_VALID(this);
; 370  : 	ASSERT(nNewSize >= 0);
; 371  : 
; 372  : 	if(nNewSize < 0 )
; 373  : 		AfxThrowInvalidArgException();
; 374  : 
; 375  : 	if (nGrowBy >= 0)
; 376  : 		m_nGrowBy = nGrowBy;  // set new size
; 377  : 
; 378  : 	if (nNewSize == 0)
; 379  : 	{
; 380  : 		// shrink to nothing
; 381  : 		if (m_pData != NULL)
; 382  : 		{
; 383  : 			for( int i = 0; i < m_nSize; i++ )
; 384  : 				(m_pData + i)->~TYPE();
; 385  : 			delete[] (BYTE*)m_pData;
; 386  : 			m_pData = NULL;
; 387  : 		}
; 388  : 		m_nSize = m_nMaxSize = 0;
; 389  : 	}
; 390  : 	else if (m_pData == NULL)
; 391  : 	{
; 392  : 		// create buffer big enough to hold number of requested elements or
; 393  : 		// m_nGrowBy elements, whichever is larger.
; 394  : #ifdef SIZE_T_MAX
; 395  : 		ASSERT(nNewSize <= SIZE_T_MAX/sizeof(TYPE));    // no overflow
; 396  : #endif
; 397  : 		size_t nAllocSize = __max(nNewSize, m_nGrowBy);
; 398  : 		m_pData = (TYPE*) new BYTE[(size_t)nAllocSize * sizeof(TYPE)];
; 399  : 		memset((void*)m_pData, 0, (size_t)nAllocSize * sizeof(TYPE));
; 400  : 		for( int i = 0; i < nNewSize; i++ )
; 401  : #pragma push_macro("new")
; 402  : #undef new
; 403  : 			::new( (void*)( m_pData + i ) ) TYPE;
; 404  : #pragma pop_macro("new")
; 405  : 		m_nSize = nNewSize;
; 406  : 		m_nMaxSize = nAllocSize;
; 407  : 	}
; 408  : 	else if (nNewSize <= m_nMaxSize)
; 409  : 	{
; 410  : 		// it fits
; 411  : 		if (nNewSize > m_nSize)
; 412  : 		{
; 413  : 			// initialize the new elements
; 414  : 			memset((void*)(m_pData + m_nSize), 0, (size_t)(nNewSize-m_nSize) * sizeof(TYPE));
; 415  : 			for( int i = 0; i < nNewSize-m_nSize; i++ )
; 416  : #pragma push_macro("new")
; 417  : #undef new
; 418  : 				::new( (void*)( m_pData + m_nSize + i ) ) TYPE;
; 419  : #pragma pop_macro("new")
; 420  : 		}
; 421  : 		else if (m_nSize > nNewSize)
; 422  : 		{
; 423  : 			// destroy the old elements
; 424  : 			for( int i = 0; i < m_nSize-nNewSize; i++ )
; 425  : 				(m_pData + nNewSize + i)->~TYPE();
; 426  : 		}
; 427  : 		m_nSize = nNewSize;
; 428  : 	}
; 429  : 	else
; 430  : 	{
; 431  : 		// otherwise, grow array
; 432  : 		nGrowBy = m_nGrowBy;
; 433  : 		if (nGrowBy == 0)
; 434  : 		{
; 435  : 			// heuristically determine growth when nGrowBy == 0
; 436  : 			//  (this avoids heap fragmentation in many situations)
; 437  : 			nGrowBy = m_nSize / 8;
; 438  : 			nGrowBy = (nGrowBy < 4) ? 4 : ((nGrowBy > 1024) ? 1024 : nGrowBy);
; 439  : 		}
; 440  : 		INT_PTR nNewMax;
; 441  : 		if (nNewSize < m_nMaxSize + nGrowBy)
; 442  : 			nNewMax = m_nMaxSize + nGrowBy;  // granularity
; 443  : 		else
; 444  : 			nNewMax = nNewSize;  // no slush
; 445  : 
; 446  : 		ASSERT(nNewMax >= m_nMaxSize);  // no wrap around
; 447  : 
; 448  : 		if(nNewMax  < m_nMaxSize)
; 449  : 			AfxThrowInvalidArgException();
; 450  : 
; 451  : #ifdef SIZE_T_MAX
; 452  : 		ASSERT(nNewMax <= SIZE_T_MAX/sizeof(TYPE)); // no overflow
; 453  : #endif
; 454  : 		TYPE* pNewData = (TYPE*) new BYTE[(size_t)nNewMax * sizeof(TYPE)];
; 455  : 
; 456  : 		// copy new data from old
; 457  : 		::ATL::Checked::memcpy_s(pNewData, (size_t)nNewMax * sizeof(TYPE),
; 458  : 			m_pData, (size_t)m_nSize * sizeof(TYPE));
; 459  : 
; 460  : 		// construct remaining elements
; 461  : 		ASSERT(nNewSize > m_nSize);
; 462  : 		memset((void*)(pNewData + m_nSize), 0, (size_t)(nNewSize-m_nSize) * sizeof(TYPE));
; 463  : 		for( int i = 0; i < nNewSize-m_nSize; i++ )
; 464  : #pragma push_macro("new")
; 465  : #undef new
; 466  : 			::new( (void*)( pNewData + m_nSize + i ) ) TYPE;
; 467  : #pragma pop_macro("new")
; 468  : 
; 469  : 		// get rid of old stuff (note: no destructors called)
; 470  : 		delete[] (BYTE*)m_pData;
; 471  : 		m_pData = pNewData;
; 472  : 		m_nSize = nNewSize;
; 473  : 		m_nMaxSize = nNewMax;
; 474  : 	}
; 475  : }
; 476  : 
; 477  : template<class TYPE, class ARG_TYPE>
; 478  : INT_PTR CArray<TYPE, ARG_TYPE>::Append(const CArray& src)
; 479  : {
; 480  : 	ASSERT_VALID(this);
; 481  : 	ASSERT(this != &src);   // cannot append to itself
; 482  : 
; 483  : 	if(this == &src)
; 484  : 		AfxThrowInvalidArgException();
; 485  : 
; 486  : 	INT_PTR nOldSize = m_nSize;
; 487  : 	SetSize(m_nSize + src.m_nSize);
; 488  : 	CopyElements<TYPE>(m_pData + nOldSize, src.m_pData, src.m_nSize);
; 489  : 	return nOldSize;
; 490  : }
; 491  : 
; 492  : template<class TYPE, class ARG_TYPE>
; 493  : void CArray<TYPE, ARG_TYPE>::Copy(const CArray& src)
; 494  : {
; 495  : 	ASSERT_VALID(this);
; 496  : 	ASSERT(this != &src);   // cannot append to itself
; 497  : 
; 498  : 	if(this != &src)
; 499  : 	{
; 500  : 		SetSize(src.m_nSize);
; 501  : 		CopyElements<TYPE>(m_pData, src.m_pData, src.m_nSize);
; 502  : 	}
; 503  : }
; 504  : 
; 505  : template<class TYPE, class ARG_TYPE>
; 506  : void CArray<TYPE, ARG_TYPE>::FreeExtra()
; 507  : {
; 508  : 	ASSERT_VALID(this);
; 509  : 
; 510  : 	if (m_nSize != m_nMaxSize)
; 511  : 	{
; 512  : 		// shrink to desired size
; 513  : #ifdef SIZE_T_MAX
; 514  : 		ASSERT(m_nSize <= SIZE_T_MAX/sizeof(TYPE)); // no overflow
; 515  : #endif
; 516  : 		TYPE* pNewData = NULL;
; 517  : 		if (m_nSize != 0)
; 518  : 		{
; 519  : 			pNewData = (TYPE*) new BYTE[m_nSize * sizeof(TYPE)];
; 520  : 			// copy new data from old
; 521  : 			::ATL::Checked::memcpy_s(pNewData, m_nSize * sizeof(TYPE),
; 522  : 				m_pData, m_nSize * sizeof(TYPE));
; 523  : 		}
; 524  : 
; 525  : 		// get rid of old stuff (note: no destructors called)
; 526  : 		delete[] (BYTE*)m_pData;
; 527  : 		m_pData = pNewData;
; 528  : 		m_nMaxSize = m_nSize;
; 529  : 	}
; 530  : }
; 531  : 
; 532  : template<class TYPE, class ARG_TYPE>
; 533  : void CArray<TYPE, ARG_TYPE>::SetAtGrow(INT_PTR nIndex, ARG_TYPE newElement)
; 534  : {
; 535  : 	ASSERT_VALID(this);
; 536  : 	ASSERT(nIndex >= 0);
; 537  : 
; 538  : 	if(nIndex < 0)
; 539  : 		AfxThrowInvalidArgException();
; 540  : 
; 541  : 	if (nIndex >= m_nSize)
; 542  : 		SetSize(nIndex+1, -1);
; 543  : 	m_pData[nIndex] = newElement;
; 544  : }
; 545  : 
; 546  : template<class TYPE, class ARG_TYPE>
; 547  : void CArray<TYPE, ARG_TYPE>::InsertAt(INT_PTR nIndex, ARG_TYPE newElement, INT_PTR nCount /*=1*/)
; 548  : {
; 549  : 	ASSERT_VALID(this);
; 550  : 	ASSERT(nIndex >= 0);    // will expand to meet need
; 551  : 	ASSERT(nCount > 0);     // zero or negative size not allowed
; 552  : 
; 553  : 	if(nIndex < 0 || nCount <= 0)
; 554  : 		AfxThrowInvalidArgException();
; 555  : 
; 556  : 	if (nIndex >= m_nSize)
; 557  : 	{
; 558  : 		// adding after the end of the array
; 559  : 		SetSize(nIndex + nCount, -1);   // grow so nIndex is valid
; 560  : 	}
; 561  : 	else
; 562  : 	{
; 563  : 		// inserting in the middle of the array
; 564  : 		INT_PTR nOldSize = m_nSize;
; 565  : 		SetSize(m_nSize + nCount, -1);  // grow it to new size
; 566  : 		// destroy intial data before copying over it
; 567  : 		for( int i = 0; i < nCount; i++ )
; 568  : 			(m_pData + nOldSize + i)->~TYPE();
; 569  : 		// shift old data up to fill gap
; 570  : 		::ATL::Checked::memmove_s(m_pData + nIndex + nCount, (nOldSize-nIndex) * sizeof(TYPE),
; 571  : 			m_pData + nIndex, (nOldSize-nIndex) * sizeof(TYPE));
; 572  : 
; 573  : 		// re-init slots we copied from
; 574  : 		memset((void*)(m_pData + nIndex), 0, (size_t)nCount * sizeof(TYPE));
; 575  : 		for( int i = 0; i < nCount; i++ )
; 576  : #pragma push_macro("new")
; 577  : #undef new
; 578  : 			::new( (void*)( m_pData + nIndex + i ) ) TYPE;
; 579  : #pragma pop_macro("new")
; 580  : 	}
; 581  : 
; 582  : 	// insert new value in the gap
; 583  : 	ASSERT(nIndex + nCount <= m_nSize);
; 584  : 	while (nCount--)
; 585  : 		m_pData[nIndex++] = newElement;
; 586  : }
; 587  : 
; 588  : template<class TYPE, class ARG_TYPE>
; 589  : void CArray<TYPE, ARG_TYPE>::RemoveAt(INT_PTR nIndex, INT_PTR nCount)
; 590  : {
; 591  : 	ASSERT_VALID(this);
; 592  : 	ASSERT(nIndex >= 0);
; 593  : 	ASSERT(nCount >= 0);
; 594  : 	INT_PTR nUpperBound = nIndex + nCount;
; 595  : 	ASSERT(nUpperBound <= m_nSize && nUpperBound >= nIndex && nUpperBound >= nCount);
; 596  : 
; 597  : 	if(nIndex < 0 || nCount < 0 || (nUpperBound > m_nSize) || (nUpperBound < nIndex) || (nUpperBound < nCount))
; 598  : 		AfxThrowInvalidArgException();
; 599  : 
; 600  : 	// just remove a range
; 601  : 	INT_PTR nMoveCount = m_nSize - (nUpperBound);
; 602  : 	for( int i = 0; i < nCount; i++ )
; 603  : 		(m_pData + nIndex + i)->~TYPE();
; 604  : 	if (nMoveCount)
; 605  : 	{
; 606  : 		::ATL::Checked::memmove_s(m_pData + nIndex, (size_t)nMoveCount * sizeof(TYPE),
; 607  : 			m_pData + nUpperBound, (size_t)nMoveCount * sizeof(TYPE));
; 608  : 	}
; 609  : 	m_nSize -= nCount;
; 610  : }
; 611  : 
; 612  : template<class TYPE, class ARG_TYPE>
; 613  : void CArray<TYPE, ARG_TYPE>::InsertAt(INT_PTR nStartIndex, CArray* pNewArray)
; 614  : {
; 615  : 	ASSERT_VALID(this);
; 616  : 	ASSERT(pNewArray != NULL);
; 617  : 	ASSERT_VALID(pNewArray);
; 618  : 	ASSERT(nStartIndex >= 0);
; 619  : 
; 620  : 	if(pNewArray == NULL || nStartIndex < 0)
; 621  : 		AfxThrowInvalidArgException();
; 622  : 
; 623  : 	if (pNewArray->GetSize() > 0)
; 624  : 	{
; 625  : 		InsertAt(nStartIndex, pNewArray->GetAt(0), pNewArray->GetSize());
; 626  : 		for (INT_PTR i = 0; i < pNewArray->GetSize(); i++)
; 627  : 			SetAt(nStartIndex + i, pNewArray->GetAt(i));
; 628  : 	}
; 629  : }
; 630  : 
; 631  : template<class TYPE, class ARG_TYPE>
; 632  : void CArray<TYPE, ARG_TYPE>::Serialize(CArchive& ar)
; 633  : {
; 634  : 	ASSERT_VALID(this);
; 635  : 
; 636  : 	CObject::Serialize(ar);
; 637  : 	if (ar.IsStoring())
; 638  : 	{
; 639  : 		ar.WriteCount(m_nSize);
; 640  : 	}
; 641  : 	else
; 642  : 	{
; 643  : 		DWORD_PTR nOldSize = ar.ReadCount();
; 644  : 		SetSize(nOldSize, -1);
; 645  : 	}
; 646  : 	SerializeElements<TYPE>(ar, m_pData, m_nSize);
; 647  : }
; 648  : 
; 649  : #ifdef _DEBUG
; 650  : template<class TYPE, class ARG_TYPE>
; 651  : void CArray<TYPE, ARG_TYPE>::Dump(CDumpContext& dc) const
; 652  : {
; 653  : 	CObject::Dump(dc);
; 654  : 
; 655  : 	dc << "with " << m_nSize << " elements";
; 656  : 	if (dc.GetDepth() > 0)
; 657  : 	{
; 658  : 		dc << "\n";
; 659  : 		DumpElements<TYPE>(dc, m_pData, m_nSize);
; 660  : 	}
; 661  : 
; 662  : 	dc << "\n";
; 663  : }
; 664  : 
; 665  : template<class TYPE, class ARG_TYPE>
; 666  : void CArray<TYPE, ARG_TYPE>::AssertValid() const
; 667  : {
; 668  : 	CObject::AssertValid();
; 669  : 
; 670  : 	if (m_pData == NULL)
; 671  : 	{
; 672  : 		ASSERT(m_nSize == 0);
; 673  : 		ASSERT(m_nMaxSize == 0);
; 674  : 	}
; 675  : 	else
; 676  : 	{
; 677  : 		ASSERT(m_nSize >= 0);
; 678  : 		ASSERT(m_nMaxSize >= 0);
; 679  : 		ASSERT(m_nSize <= m_nMaxSize);
; 680  : 		ASSERT(AfxIsValidAddress(m_pData, m_nMaxSize * sizeof(TYPE)));
; 681  : 	}
; 682  : }
; 683  : #endif //_DEBUG
; 684  : 
; 685  : /*============================================================================*/
; 686  : // CList<TYPE, ARG_TYPE>
; 687  : 
; 688  : template<class TYPE, class ARG_TYPE = const TYPE&>
; 689  : class CList : public CObject
; 690  : {
; 691  : protected:
; 692  : 	struct CNode
; 693  : 	{
; 694  : 		CNode* pNext;
; 695  : 		CNode* pPrev;
; 696  : 		TYPE data;
; 697  : 	};
; 698  : public:
; 699  : // Construction
; 700  : 	explicit CList(INT_PTR nBlockSize = 10);
; 701  : 
; 702  : // Attributes (head and tail)
; 703  : 	// count of elements
; 704  : 	INT_PTR GetCount() const;
; 705  : 	INT_PTR GetSize() const;
; 706  : 	BOOL IsEmpty() const;
; 707  : 
; 708  : 	// peek at head or tail
; 709  : 	TYPE& GetHead();
; 710  : 	const TYPE& GetHead() const;
; 711  : 	TYPE& GetTail();
; 712  : 	const TYPE& GetTail() const;
; 713  : 
; 714  : // Operations
; 715  : 	// get head or tail (and remove it) - don't call on empty list !
; 716  : 	TYPE RemoveHead();
; 717  : 	TYPE RemoveTail();
; 718  : 
; 719  : 	// add before head or after tail
; 720  : 	POSITION AddHead(ARG_TYPE newElement);
; 721  : 	POSITION AddTail(ARG_TYPE newElement);
; 722  : 
; 723  : 	// add another list of elements before head or after tail
; 724  : 	void AddHead(CList* pNewList);
; 725  : 	void AddTail(CList* pNewList);
; 726  : 
; 727  : 	// remove all elements
; 728  : 	void RemoveAll();
; 729  : 
; 730  : 	// iteration
; 731  : 	POSITION GetHeadPosition() const;
; 732  : 	POSITION GetTailPosition() const;
; 733  : 	TYPE& GetNext(POSITION& rPosition); // return *Position++
; 734  : 	const TYPE& GetNext(POSITION& rPosition) const; // return *Position++
; 735  : 	TYPE& GetPrev(POSITION& rPosition); // return *Position--
; 736  : 	const TYPE& GetPrev(POSITION& rPosition) const; // return *Position--
; 737  : 
; 738  : 	// getting/modifying an element at a given position
; 739  : 	TYPE& GetAt(POSITION position);
; 740  : 	const TYPE& GetAt(POSITION position) const;
; 741  : 	void SetAt(POSITION pos, ARG_TYPE newElement);
; 742  : 	void RemoveAt(POSITION position);
; 743  : 
; 744  : 	// inserting before or after a given position
; 745  : 	POSITION InsertBefore(POSITION position, ARG_TYPE newElement);
; 746  : 	POSITION InsertAfter(POSITION position, ARG_TYPE newElement);
; 747  : 
; 748  : 	// helper functions (note: O(n) speed)
; 749  : 	POSITION Find(ARG_TYPE searchValue, POSITION startAfter = NULL) const;
; 750  : 		// defaults to starting at the HEAD, return NULL if not found
; 751  : 	POSITION FindIndex(INT_PTR nIndex) const;
; 752  : 		// get the 'nIndex'th element (may return NULL)
; 753  : 
; 754  : // Implementation
; 755  : protected:
; 756  : 	CNode* m_pNodeHead;
; 757  : 	CNode* m_pNodeTail;
; 758  : 	INT_PTR m_nCount;
; 759  : 	CNode* m_pNodeFree;
; 760  : 	struct CPlex* m_pBlocks;
; 761  : 	INT_PTR m_nBlockSize;
; 762  : 
; 763  : 	CNode* NewNode(CNode*, CNode*);
; 764  : 	void FreeNode(CNode*);
; 765  : 
; 766  : public:
; 767  : 	~CList();
; 768  : 	void Serialize(CArchive&);
; 769  : #ifdef _DEBUG
; 770  : 	void Dump(CDumpContext&) const;
; 771  : 	void AssertValid() const;
; 772  : #endif
; 773  : };
; 774  : 
; 775  : /*============================================================================*/
; 776  : // CList<TYPE, ARG_TYPE> inline functions
; 777  : 
; 778  : template<class TYPE, class ARG_TYPE>
; 779  : AFX_INLINE INT_PTR CList<TYPE, ARG_TYPE>::GetCount() const
; 780  : 	{ return m_nCount; }
; 781  : template<class TYPE, class ARG_TYPE>
; 782  : AFX_INLINE INT_PTR CList<TYPE, ARG_TYPE>::GetSize() const
; 783  : 	{ return m_nCount; }
; 784  : template<class TYPE, class ARG_TYPE>
; 785  : AFX_INLINE BOOL CList<TYPE, ARG_TYPE>::IsEmpty() const
; 786  : 	{ return m_nCount == 0; }
; 787  : template<class TYPE, class ARG_TYPE>
; 788  : AFX_INLINE TYPE& CList<TYPE, ARG_TYPE>::GetHead()
; 789  : 	{ ENSURE(m_pNodeHead != NULL);
; 790  : 		return m_pNodeHead->data; }
; 791  : template<class TYPE, class ARG_TYPE>
; 792  : AFX_INLINE const TYPE& CList<TYPE, ARG_TYPE>::GetHead() const
; 793  : 	{ ENSURE(m_pNodeHead != NULL);
; 794  : 		return m_pNodeHead->data; }
; 795  : template<class TYPE, class ARG_TYPE>
; 796  : AFX_INLINE TYPE& CList<TYPE, ARG_TYPE>::GetTail()
; 797  : 	{ ENSURE(m_pNodeTail != NULL);
; 798  : 		return m_pNodeTail->data; }
; 799  : template<class TYPE, class ARG_TYPE>
; 800  : AFX_INLINE const TYPE& CList<TYPE, ARG_TYPE>::GetTail() const
; 801  : 	{ ENSURE(m_pNodeTail != NULL);
; 802  : 		return m_pNodeTail->data; }
; 803  : template<class TYPE, class ARG_TYPE>
; 804  : AFX_INLINE POSITION CList<TYPE, ARG_TYPE>::GetHeadPosition() const
; 805  : 	{ return (POSITION) m_pNodeHead; }
; 806  : template<class TYPE, class ARG_TYPE>
; 807  : AFX_INLINE POSITION CList<TYPE, ARG_TYPE>::GetTailPosition() const
; 808  : 	{ return (POSITION) m_pNodeTail; }
; 809  : template<class TYPE, class ARG_TYPE>
; 810  : AFX_INLINE TYPE& CList<TYPE, ARG_TYPE>::GetNext(POSITION& rPosition) // return *Position++
; 811  : 	{ CNode* pNode = (CNode*) rPosition;
; 812  : 		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 813  : 		rPosition = (POSITION) pNode->pNext;
; 814  : 		return pNode->data; }
; 815  : template<class TYPE, class ARG_TYPE>
; 816  : AFX_INLINE const TYPE& CList<TYPE, ARG_TYPE>::GetNext(POSITION& rPosition) const // return *Position++
; 817  : 	{ CNode* pNode = (CNode*) rPosition;
; 818  : 		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 819  : 		rPosition = (POSITION) pNode->pNext;
; 820  : 		return pNode->data; }
; 821  : template<class TYPE, class ARG_TYPE>
; 822  : AFX_INLINE TYPE& CList<TYPE, ARG_TYPE>::GetPrev(POSITION& rPosition) // return *Position--
; 823  : 	{ CNode* pNode = (CNode*) rPosition;
; 824  : 		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 825  : 		rPosition = (POSITION) pNode->pPrev;
; 826  : 		return pNode->data; }
; 827  : template<class TYPE, class ARG_TYPE>
; 828  : AFX_INLINE const TYPE& CList<TYPE, ARG_TYPE>::GetPrev(POSITION& rPosition) const // return *Position--
; 829  : 	{ CNode* pNode = (CNode*) rPosition;
; 830  : 		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 831  : 		rPosition = (POSITION) pNode->pPrev;
; 832  : 		return pNode->data; }
; 833  : template<class TYPE, class ARG_TYPE>
; 834  : AFX_INLINE TYPE& CList<TYPE, ARG_TYPE>::GetAt(POSITION position)
; 835  : 	{ CNode* pNode = (CNode*) position;
; 836  : 		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 837  : 		return pNode->data; }
; 838  : template<class TYPE, class ARG_TYPE>
; 839  : AFX_INLINE const TYPE& CList<TYPE, ARG_TYPE>::GetAt(POSITION position) const
; 840  : 	{ CNode* pNode = (CNode*) position;
; 841  : 		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 842  : 		return pNode->data; }
; 843  : template<class TYPE, class ARG_TYPE>
; 844  : AFX_INLINE void CList<TYPE, ARG_TYPE>::SetAt(POSITION pos, ARG_TYPE newElement)
; 845  : 	{ CNode* pNode = (CNode*) pos;
; 846  : 		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 847  : 		pNode->data = newElement; }
; 848  : 
; 849  : template<class TYPE, class ARG_TYPE>
; 850  : CList<TYPE, ARG_TYPE>::CList(INT_PTR nBlockSize)
; 851  : {
; 852  : 	ASSERT(nBlockSize > 0);
; 853  : 
; 854  : 	m_nCount = 0;
; 855  : 	m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
; 856  : 	m_pBlocks = NULL;
; 857  : 	m_nBlockSize = nBlockSize;
; 858  : }
; 859  : 
; 860  : template<class TYPE, class ARG_TYPE>
; 861  : void CList<TYPE, ARG_TYPE>::RemoveAll()
; 862  : {
; 863  : 	ASSERT_VALID(this);
; 864  : 
; 865  : 	// destroy elements
; 866  : 	CNode* pNode;
; 867  : 	for (pNode = m_pNodeHead; pNode != NULL; pNode = pNode->pNext)
; 868  : 		pNode->data.~TYPE();
; 869  : 
; 870  : 	m_nCount = 0;
; 871  : 	m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
; 872  : 	m_pBlocks->FreeDataChain();
; 873  : 	m_pBlocks = NULL;
; 874  : }
; 875  : 
; 876  : template<class TYPE, class ARG_TYPE>
; 877  : CList<TYPE, ARG_TYPE>::~CList()
; 878  : {
; 879  : 	RemoveAll();
; 880  : 	ASSERT(m_nCount == 0);
; 881  : }
; 882  : 
; 883  : /*============================================================================*/
; 884  : // Node helpers
; 885  : //
; 886  : // Implementation note: CNode's are stored in CPlex blocks and
; 887  : //  chained together. Free blocks are maintained in a singly linked list
; 888  : //  using the 'pNext' member of CNode with 'm_pNodeFree' as the head.
; 889  : //  Used blocks are maintained in a doubly linked list using both 'pNext'
; 890  : //  and 'pPrev' as links and 'm_pNodeHead' and 'm_pNodeTail'
; 891  : //   as the head/tail.
; 892  : //
; 893  : // We never free a CPlex block unless the List is destroyed or RemoveAll()
; 894  : //  is used - so the total number of CPlex blocks may grow large depending
; 895  : //  on the maximum past size of the list.
; 896  : //
; 897  : 
; 898  : template<class TYPE, class ARG_TYPE>
; 899  : typename CList<TYPE, ARG_TYPE>::CNode*
; 900  : CList<TYPE, ARG_TYPE>::NewNode(CNode* pPrev, CNode* pNext)
; 901  : {
; 902  : 	if (m_pNodeFree == NULL)
; 903  : 	{
; 904  : 		// add another block
; 905  : 		CPlex* pNewBlock = CPlex::Create(m_pBlocks, m_nBlockSize,
; 906  : 				 sizeof(CNode));
; 907  : 
; 908  : 		// chain them into free list
; 909  : 		CNode* pNode = (CNode*) pNewBlock->data();
; 910  : 		// free in reverse order to make it easier to debug
; 911  : 		pNode += m_nBlockSize - 1;
; 912  : 		for (INT_PTR i = m_nBlockSize-1; i >= 0; i--, pNode--)
; 913  : 		{
; 914  : 			pNode->pNext = m_pNodeFree;
; 915  : 			m_pNodeFree = pNode;
; 916  : 		}
; 917  : 	}
; 918  : 	ENSURE(m_pNodeFree != NULL);  // we must have something
; 919  : 
; 920  : 	CList::CNode* pNode = m_pNodeFree;
; 921  : 	m_pNodeFree = m_pNodeFree->pNext;
; 922  : 	pNode->pPrev = pPrev;
; 923  : 	pNode->pNext = pNext;
; 924  : 	m_nCount++;
; 925  : 	ASSERT(m_nCount > 0);  // make sure we don't overflow
; 926  : 
; 927  : #pragma push_macro("new")
; 928  : #undef new
; 929  : 	::new( (void*)( &pNode->data ) ) TYPE;
; 930  : #pragma pop_macro("new")
; 931  : 	return pNode;
; 932  : }
; 933  : 
; 934  : template<class TYPE, class ARG_TYPE>
; 935  : void CList<TYPE, ARG_TYPE>::FreeNode(CNode* pNode)
; 936  : {
; 937  : 	pNode->data.~TYPE();
; 938  : 	pNode->pNext = m_pNodeFree;
; 939  : 	m_pNodeFree = pNode;
; 940  : 	m_nCount--;
; 941  : 	ASSERT(m_nCount >= 0);  // make sure we don't underflow
; 942  : 
; 943  : 	// if no more elements, cleanup completely
; 944  : 	if (m_nCount == 0)
; 945  : 		RemoveAll();
; 946  : }
; 947  : 
; 948  : template<class TYPE, class ARG_TYPE>
; 949  : POSITION CList<TYPE, ARG_TYPE>::AddHead(ARG_TYPE newElement)
; 950  : {
; 951  : 	ASSERT_VALID(this);
; 952  : 
; 953  : 	CNode* pNewNode = NewNode(NULL, m_pNodeHead);
; 954  : 	pNewNode->data = newElement;
; 955  : 	if (m_pNodeHead != NULL)
; 956  : 		m_pNodeHead->pPrev = pNewNode;
; 957  : 	else
; 958  : 		m_pNodeTail = pNewNode;
; 959  : 	m_pNodeHead = pNewNode;
; 960  : 	return (POSITION) pNewNode;
; 961  : }
; 962  : 
; 963  : template<class TYPE, class ARG_TYPE>
; 964  : POSITION CList<TYPE, ARG_TYPE>::AddTail(ARG_TYPE newElement)
; 965  : {
; 966  : 	ASSERT_VALID(this);
; 967  : 
; 968  : 	CNode* pNewNode = NewNode(m_pNodeTail, NULL);
; 969  : 	pNewNode->data = newElement;
; 970  : 	if (m_pNodeTail != NULL)
; 971  : 		m_pNodeTail->pNext = pNewNode;
; 972  : 	else
; 973  : 		m_pNodeHead = pNewNode;
; 974  : 	m_pNodeTail = pNewNode;
; 975  : 	return (POSITION) pNewNode;
; 976  : }
; 977  : 
; 978  : template<class TYPE, class ARG_TYPE>
; 979  : void CList<TYPE, ARG_TYPE>::AddHead(CList* pNewList)
; 980  : {
; 981  : 	ASSERT_VALID(this);
; 982  : 
; 983  : 	ENSURE(pNewList != NULL);
; 984  : 	ASSERT_VALID(pNewList);
; 985  : 
; 986  : 	// add a list of same elements to head (maintain order)
; 987  : 	POSITION pos = pNewList->GetTailPosition();
; 988  : 	while (pos != NULL)
; 989  : 		AddHead(pNewList->GetPrev(pos));
; 990  : }
; 991  : 
; 992  : template<class TYPE, class ARG_TYPE>
; 993  : void CList<TYPE, ARG_TYPE>::AddTail(CList* pNewList)
; 994  : {
; 995  : 	ASSERT_VALID(this);
; 996  : 	ENSURE(pNewList != NULL);
; 997  : 	ASSERT_VALID(pNewList);
; 998  : 
; 999  : 	// add a list of same elements
; 1000 : 	POSITION pos = pNewList->GetHeadPosition();
; 1001 : 	while (pos != NULL)
; 1002 : 		AddTail(pNewList->GetNext(pos));
; 1003 : }
; 1004 : 
; 1005 : template<class TYPE, class ARG_TYPE>
; 1006 : TYPE CList<TYPE, ARG_TYPE>::RemoveHead()
; 1007 : {
; 1008 : 	ASSERT_VALID(this);
; 1009 : 	ENSURE(m_pNodeHead != NULL);  // don't call on empty list !!!
; 1010 : 	ASSERT(AfxIsValidAddress(m_pNodeHead, sizeof(CNode)));
; 1011 : 
; 1012 : 	CNode* pOldNode = m_pNodeHead;
; 1013 : 	TYPE returnValue = pOldNode->data;
; 1014 : 
; 1015 : 	m_pNodeHead = pOldNode->pNext;
; 1016 : 	if (m_pNodeHead != NULL)
; 1017 : 		m_pNodeHead->pPrev = NULL;
; 1018 : 	else
; 1019 : 		m_pNodeTail = NULL;
; 1020 : 	FreeNode(pOldNode);
; 1021 : 	return returnValue;
; 1022 : }
; 1023 : 
; 1024 : template<class TYPE, class ARG_TYPE>
; 1025 : TYPE CList<TYPE, ARG_TYPE>::RemoveTail()
; 1026 : {
; 1027 : 	ASSERT_VALID(this);
; 1028 : 	ENSURE(m_pNodeTail != NULL);  // don't call on empty list !!!
; 1029 : 	ASSERT(AfxIsValidAddress(m_pNodeTail, sizeof(CNode)));
; 1030 : 
; 1031 : 	CNode* pOldNode = m_pNodeTail;
; 1032 : 	TYPE returnValue = pOldNode->data;
; 1033 : 
; 1034 : 	m_pNodeTail = pOldNode->pPrev;
; 1035 : 	if (m_pNodeTail != NULL)
; 1036 : 		m_pNodeTail->pNext = NULL;
; 1037 : 	else
; 1038 : 		m_pNodeHead = NULL;
; 1039 : 	FreeNode(pOldNode);
; 1040 : 	return returnValue;
; 1041 : }
; 1042 : 
; 1043 : template<class TYPE, class ARG_TYPE>
; 1044 : POSITION CList<TYPE, ARG_TYPE>::InsertBefore(POSITION position, ARG_TYPE newElement)
; 1045 : {
; 1046 : 	ASSERT_VALID(this);
; 1047 : 
; 1048 : 	if (position == NULL)
; 1049 : 		return AddHead(newElement); // insert before nothing -> head of the list
; 1050 : 
; 1051 : 	// Insert it before position
; 1052 : 	CNode* pOldNode = (CNode*) position;
; 1053 : 	CNode* pNewNode = NewNode(pOldNode->pPrev, pOldNode);
; 1054 : 	pNewNode->data = newElement;
; 1055 : 
; 1056 : 	if (pOldNode->pPrev != NULL)
; 1057 : 	{
; 1058 : 		ASSERT(AfxIsValidAddress(pOldNode->pPrev, sizeof(CNode)));
; 1059 : 		pOldNode->pPrev->pNext = pNewNode;
; 1060 : 	}
; 1061 : 	else
; 1062 : 	{
; 1063 : 		ASSERT(pOldNode == m_pNodeHead);
; 1064 : 		m_pNodeHead = pNewNode;
; 1065 : 	}
; 1066 : 	pOldNode->pPrev = pNewNode;
; 1067 : 	return (POSITION) pNewNode;
; 1068 : }
; 1069 : 
; 1070 : template<class TYPE, class ARG_TYPE>
; 1071 : POSITION CList<TYPE, ARG_TYPE>::InsertAfter(POSITION position, ARG_TYPE newElement)
; 1072 : {
; 1073 : 	ASSERT_VALID(this);
; 1074 : 
; 1075 : 	if (position == NULL)
; 1076 : 		return AddTail(newElement); // insert after nothing -> tail of the list
; 1077 : 
; 1078 : 	// Insert it before position
; 1079 : 	CNode* pOldNode = (CNode*) position;
; 1080 : 	ASSERT(AfxIsValidAddress(pOldNode, sizeof(CNode)));
; 1081 : 	CNode* pNewNode = NewNode(pOldNode, pOldNode->pNext);
; 1082 : 	pNewNode->data = newElement;
; 1083 : 
; 1084 : 	if (pOldNode->pNext != NULL)
; 1085 : 	{
; 1086 : 		ASSERT(AfxIsValidAddress(pOldNode->pNext, sizeof(CNode)));
; 1087 : 		pOldNode->pNext->pPrev = pNewNode;
; 1088 : 	}
; 1089 : 	else
; 1090 : 	{
; 1091 : 		ASSERT(pOldNode == m_pNodeTail);
; 1092 : 		m_pNodeTail = pNewNode;
; 1093 : 	}
; 1094 : 	pOldNode->pNext = pNewNode;
; 1095 : 	return (POSITION) pNewNode;
; 1096 : }
; 1097 : 
; 1098 : template<class TYPE, class ARG_TYPE>
; 1099 : void CList<TYPE, ARG_TYPE>::RemoveAt(POSITION position)
; 1100 : {
; 1101 : 	ASSERT_VALID(this);
; 1102 : 
; 1103 : 	CNode* pOldNode = (CNode*) position;
; 1104 : 	ASSERT(AfxIsValidAddress(pOldNode, sizeof(CNode)));
; 1105 : 
; 1106 : 	// remove pOldNode from list
; 1107 : 	if (pOldNode == m_pNodeHead)
; 1108 : 	{
; 1109 : 		m_pNodeHead = pOldNode->pNext;
; 1110 : 	}
; 1111 : 	else
; 1112 : 	{
; 1113 : 		ASSERT(AfxIsValidAddress(pOldNode->pPrev, sizeof(CNode)));
; 1114 : 		pOldNode->pPrev->pNext = pOldNode->pNext;
; 1115 : 	}
; 1116 : 	if (pOldNode == m_pNodeTail)
; 1117 : 	{
; 1118 : 		m_pNodeTail = pOldNode->pPrev;
; 1119 : 	}
; 1120 : 	else
; 1121 : 	{
; 1122 : 		ASSERT(AfxIsValidAddress(pOldNode->pNext, sizeof(CNode)));
; 1123 : 		pOldNode->pNext->pPrev = pOldNode->pPrev;
; 1124 : 	}
; 1125 : 	FreeNode(pOldNode);
; 1126 : }
; 1127 : 
; 1128 : template<class TYPE, class ARG_TYPE>
; 1129 : POSITION CList<TYPE, ARG_TYPE>::FindIndex(INT_PTR nIndex) const
; 1130 : {
; 1131 : 	ASSERT_VALID(this);
; 1132 : 
; 1133 : 	if (nIndex >= m_nCount || nIndex < 0)
; 1134 : 		return NULL;  // went too far
; 1135 : 
; 1136 : 	CNode* pNode = m_pNodeHead;
; 1137 : 	while (nIndex--)
; 1138 : 	{
; 1139 : 		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 1140 : 		pNode = pNode->pNext;
; 1141 : 	}
; 1142 : 	return (POSITION) pNode;
; 1143 : }
; 1144 : 
; 1145 : template<class TYPE, class ARG_TYPE>
; 1146 : POSITION CList<TYPE, ARG_TYPE>::Find(ARG_TYPE searchValue, POSITION startAfter) const
; 1147 : {
; 1148 : 	ASSERT_VALID(this);
; 1149 : 
; 1150 : 	CNode* pNode = (CNode*) startAfter;
; 1151 : 	if (pNode == NULL)
; 1152 : 	{
; 1153 : 		pNode = m_pNodeHead;  // start at head
; 1154 : 	}
; 1155 : 	else
; 1156 : 	{
; 1157 : 		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 1158 : 		pNode = pNode->pNext;  // start after the one specified
; 1159 : 	}
; 1160 : 
; 1161 : 	for (; pNode != NULL; pNode = pNode->pNext)
; 1162 : 		if (CompareElements<TYPE>(&pNode->data, &searchValue))
; 1163 : 			return (POSITION)pNode;
; 1164 : 	return NULL;
; 1165 : }
; 1166 : 
; 1167 : template<class TYPE, class ARG_TYPE>
; 1168 : void CList<TYPE, ARG_TYPE>::Serialize(CArchive& ar)
; 1169 : {
; 1170 : 	ASSERT_VALID(this);
; 1171 : 
; 1172 : 	CObject::Serialize(ar);
; 1173 : 
; 1174 : 	if (ar.IsStoring())
; 1175 : 	{
; 1176 : 		ar.WriteCount(m_nCount);
; 1177 : 		for (CNode* pNode = m_pNodeHead; pNode != NULL; pNode = pNode->pNext)
; 1178 : 		{
; 1179 : 			ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 1180 : 			TYPE* pData;
; 1181 : 			/*
; 1182 : 			 * in some cases the & operator might be overloaded, and we cannot use it to obtain
; 1183 : 			 * the address of a given object.  We then use the following trick to get the address
; 1184 : 			 */
; 1185 : 			pData = reinterpret_cast< TYPE* >( &reinterpret_cast< int& >( static_cast< TYPE& >( pNode->data ) ) );
; 1186 : 			SerializeElements<TYPE>(ar, pData, 1);
; 1187 : 		}
; 1188 : 	}
; 1189 : 	else
; 1190 : 	{
; 1191 : 		DWORD_PTR nNewCount = ar.ReadCount();
; 1192 : 		while (nNewCount--)
; 1193 : 		{
; 1194 : 			TYPE newData[1];
; 1195 : 			SerializeElements<TYPE>(ar, newData, 1);
; 1196 : 			AddTail(newData[0]);
; 1197 : 		}
; 1198 : 	}
; 1199 : }
; 1200 : 
; 1201 : #ifdef _DEBUG
; 1202 : template<class TYPE, class ARG_TYPE>
; 1203 : void CList<TYPE, ARG_TYPE>::Dump(CDumpContext& dc) const
; 1204 : {
; 1205 : 	CObject::Dump(dc);
; 1206 : 
; 1207 : 	dc << "with " << m_nCount << " elements";
; 1208 : 	if (dc.GetDepth() > 0)
; 1209 : 	{
; 1210 : 		POSITION pos = GetHeadPosition();
; 1211 : 		while (pos != NULL)
; 1212 : 		{
; 1213 : 			TYPE temp[1];
; 1214 : 			temp[0] = ((CList*)this)->GetNext(pos);
; 1215 : 			dc << "\n";
; 1216 : 			DumpElements<TYPE>(dc, temp, 1);
; 1217 : 		}
; 1218 : 	}
; 1219 : 
; 1220 : 	dc << "\n";
; 1221 : }
; 1222 : 
; 1223 : template<class TYPE, class ARG_TYPE>
; 1224 : void CList<TYPE, ARG_TYPE>::AssertValid() const
; 1225 : {
; 1226 : 	CObject::AssertValid();
; 1227 : 
; 1228 : 	if (m_nCount == 0)
; 1229 : 	{
; 1230 : 		// empty list
; 1231 : 		ASSERT(m_pNodeHead == NULL);
; 1232 : 		ASSERT(m_pNodeTail == NULL);
; 1233 : 	}
; 1234 : 	else
; 1235 : 	{
; 1236 : 		// non-empty list
; 1237 : 		ASSERT(AfxIsValidAddress(m_pNodeHead, sizeof(CNode)));
; 1238 : 		ASSERT(AfxIsValidAddress(m_pNodeTail, sizeof(CNode)));
; 1239 : 	}
; 1240 : }
; 1241 : #endif //_DEBUG
; 1242 : 
; 1243 : /*============================================================================*/
; 1244 : // CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>
; 1245 : 
; 1246 : template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
; 1247 : class CMap : public CObject
; 1248 : {
; 1249 : public:
; 1250 : 	// CPair
; 1251 : 	struct CPair
; 1252 : 	{
; 1253 : 		const KEY key;
; 1254 : 		VALUE value;
; 1255 : 	protected:
; 1256 : 		CPair( ARG_KEY keyval ) : key( keyval )	{}
; 1257 : 	};
; 1258 : 
; 1259 : protected:
; 1260 : 	// Association
; 1261 : 	class CAssoc : public CPair
; 1262 : 	{
; 1263 : 		friend class CMap<KEY,ARG_KEY,VALUE,ARG_VALUE>;
; 1264 : 		CAssoc* pNext;
; 1265 : 		UINT nHashValue;  // needed for efficient iteration
; 1266 : 	public:
; 1267 : 		CAssoc( ARG_KEY key ) : CPair( key ) {}
; 1268 : 	};
; 1269 : 
; 1270 : public:
; 1271 : // Construction
; 1272 : 	explicit CMap(INT_PTR nBlockSize = 10);
; 1273 : 
; 1274 : // Attributes
; 1275 : 	// number of elements
; 1276 : 	INT_PTR GetCount() const;
; 1277 : 	INT_PTR GetSize() const;
; 1278 : 	BOOL IsEmpty() const;
; 1279 : 
; 1280 : 	// Lookup
; 1281 : 	BOOL Lookup(ARG_KEY key, VALUE& rValue) const;
; 1282 : 	const CPair *PLookup(ARG_KEY key) const;
; 1283 : 	CPair *PLookup(ARG_KEY key);
; 1284 : 
; 1285 : // Operations
; 1286 : 	// Lookup and add if not there
; 1287 : 	VALUE& operator[](ARG_KEY key);
; 1288 : 
; 1289 : 	// add a new (key, value) pair
; 1290 : 	void SetAt(ARG_KEY key, ARG_VALUE newValue);
; 1291 : 
; 1292 : 	// removing existing (key, ?) pair
; 1293 : 	BOOL RemoveKey(ARG_KEY key);
; 1294 : 	void RemoveAll();
; 1295 : 
; 1296 : 	// iterating all (key, value) pairs
; 1297 : 	POSITION GetStartPosition() const;
; 1298 : 
; 1299 : 	const CPair *PGetFirstAssoc() const;
; 1300 : 	CPair *PGetFirstAssoc();
; 1301 : 
; 1302 : 	void GetNextAssoc(POSITION& rNextPosition, KEY& rKey, VALUE& rValue) const;
; 1303 : 
; 1304 : 	const CPair *PGetNextAssoc(const CPair *pAssocRet) const;
; 1305 : 	CPair *PGetNextAssoc(const CPair *pAssocRet);
; 1306 : 
; 1307 : 	// advanced features for derived classes
; 1308 : 	UINT GetHashTableSize() const;
; 1309 : 	void InitHashTable(UINT hashSize, BOOL bAllocNow = TRUE);
; 1310 : 
; 1311 : // Implementation
; 1312 : protected:
; 1313 : 	CAssoc** m_pHashTable;
; 1314 : 	UINT m_nHashTableSize;
; 1315 : 	INT_PTR m_nCount;
; 1316 : 	CAssoc* m_pFreeList;
; 1317 : 	struct CPlex* m_pBlocks;
; 1318 : 	INT_PTR m_nBlockSize;
; 1319 : 
; 1320 : 	CAssoc* NewAssoc(ARG_KEY key);
; 1321 : 	void FreeAssoc(CAssoc*);
; 1322 : 	CAssoc* GetAssocAt(ARG_KEY, UINT&, UINT&) const;
; 1323 : 
; 1324 : public:
; 1325 : 	~CMap();
; 1326 : 	void Serialize(CArchive&);
; 1327 : #ifdef _DEBUG
; 1328 : 	void Dump(CDumpContext&) const;
; 1329 : 	void AssertValid() const;
; 1330 : #endif
; 1331 : };
; 1332 : 
; 1333 : /*============================================================================*/
; 1334 : // CMap<KEY, ARG_KEY, VALUE, ARG_VALUE> inline functions
; 1335 : 
; 1336 : template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
; 1337 : AFX_INLINE INT_PTR CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetCount() const
; 1338 : 	{ return m_nCount; }
; 1339 : 
; 1340 : template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
; 1341 : AFX_INLINE INT_PTR CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetSize() const
; 1342 : 	{ return m_nCount; }
; 1343 : 
; 1344 : template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
; 1345 : AFX_INLINE BOOL CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::IsEmpty() const
; 1346 : 	{ return m_nCount == 0; }
; 1347 : 
; 1348 : template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
; 1349 : AFX_INLINE void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::SetAt(ARG_KEY key, ARG_VALUE newValue)
; 1350 : 	{ (*this)[key] = newValue; }
; 1351 : 
; 1352 : template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
; 1353 : AFX_INLINE POSITION CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetStartPosition() const
; 1354 : 	{ return (m_nCount == 0) ? NULL : BEFORE_START_POSITION; }
; 1355 : 
; 1356 : template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
; 1357 : const typename CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CPair* CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::PGetFirstAssoc() const
; 1358 : {
; 1359 : 	ASSERT_VALID(this);
; 1360 : 	if(m_nCount == 0) return NULL;
; 1361 : 
; 1362 : 	AFXASSUME(m_pHashTable != NULL);  // never call on empty map
; 1363 : 
; 1364 : 	CAssoc* pAssocRet = (CAssoc*)BEFORE_START_POSITION;
; 1365 : 
; 1366 : 	// find the first association
; 1367 : 	for (UINT nBucket = 0; nBucket < m_nHashTableSize; nBucket++)
; 1368 : 		if ((pAssocRet = m_pHashTable[nBucket]) != NULL)
; 1369 : 			break;
; 1370 : 	ASSERT(pAssocRet != NULL);  // must find something
; 1371 : 
; 1372 : 	return pAssocRet;
; 1373 : }
; 1374 : 
; 1375 : template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
; 1376 : typename CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CPair* CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::PGetFirstAssoc()
; 1377 : {
; 1378 : 	ASSERT_VALID(this);
; 1379 : 	if(m_nCount == 0) return NULL;
; 1380 : 
; 1381 : 	AFXASSUME(m_pHashTable != NULL);  // never call on empty map
; 1382 : 
; 1383 : 	CAssoc* pAssocRet = (CAssoc*)BEFORE_START_POSITION;
; 1384 : 
; 1385 : 	// find the first association
; 1386 : 	for (UINT nBucket = 0; nBucket < m_nHashTableSize; nBucket++)
; 1387 : 		if ((pAssocRet = m_pHashTable[nBucket]) != NULL)
; 1388 : 			break;
; 1389 : 	ASSERT(pAssocRet != NULL);  // must find something
; 1390 : 
; 1391 : 	return pAssocRet;
; 1392 : }
; 1393 : 
; 1394 : template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
; 1395 : AFX_INLINE UINT CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetHashTableSize() const
; 1396 : 	{ return m_nHashTableSize; }
; 1397 : 
; 1398 : /*============================================================================*/
; 1399 : // CMap<KEY, ARG_KEY, VALUE, ARG_VALUE> out-of-line functions
; 1400 : 
; 1401 : template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
; 1402 : CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CMap(INT_PTR nBlockSize)
; 1403 : {
; 1404 : 	ASSERT(nBlockSize > 0);
; 1405 : 
; 1406 : 	m_pHashTable = NULL;
; 1407 : 	m_nHashTableSize = 17;  // default size
; 1408 : 	m_nCount = 0;
; 1409 : 	m_pFreeList = NULL;
; 1410 : 	m_pBlocks = NULL;
; 1411 : 	m_nBlockSize = nBlockSize;
; 1412 : }
; 1413 : 
; 1414 : template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
; 1415 : void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::InitHashTable(
; 1416 : 	UINT nHashSize, BOOL bAllocNow)
; 1417 : //
; 1418 : // Used to force allocation of a hash table or to override the default
; 1419 : //   hash table size of (which is fairly small)
; 1420 : {
; 1421 : 	ASSERT_VALID(this);
; 1422 : 	ASSERT(m_nCount == 0);
; 1423 : 	ASSERT(nHashSize > 0);
; 1424 : 
; 1425 : 	if (m_pHashTable != NULL)
; 1426 : 	{
; 1427 : 		// free hash table
; 1428 : 		delete[] m_pHashTable;
; 1429 : 		m_pHashTable = NULL;
; 1430 : 	}
; 1431 : 
; 1432 : 	if (bAllocNow)
; 1433 : 	{
; 1434 : 		m_pHashTable = new CAssoc* [nHashSize];
; 1435 : 		ENSURE(m_pHashTable != NULL);
; 1436 : 		memset(m_pHashTable, 0, sizeof(CAssoc*) * nHashSize);
; 1437 : 	}
; 1438 : 	m_nHashTableSize = nHashSize;
; 1439 : }
; 1440 : 
; 1441 : template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
; 1442 : void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::RemoveAll()
; 1443 : {
; 1444 : 	ASSERT_VALID(this);
; 1445 : 
; 1446 : 	if (m_pHashTable != NULL)
; 1447 : 	{
; 1448 : 		// destroy elements (values and keys)
; 1449 : 		for (UINT nHash = 0; nHash < m_nHashTableSize; nHash++)
; 1450 : 		{
; 1451 : 			CAssoc* pAssoc;
; 1452 : 			for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL;
; 1453 : 			  pAssoc = pAssoc->pNext)
; 1454 : 			{
; 1455 : 				pAssoc->CAssoc::~CAssoc();
; 1456 : 			}
; 1457 : 		}
; 1458 : 
; 1459 : 		// free hash table
; 1460 : 		delete[] m_pHashTable;
; 1461 : 		m_pHashTable = NULL;
; 1462 : 	}
; 1463 : 
; 1464 : 	m_nCount = 0;
; 1465 : 	m_pFreeList = NULL;
; 1466 : 	m_pBlocks->FreeDataChain();
; 1467 : 	m_pBlocks = NULL;
; 1468 : }
; 1469 : 
; 1470 : template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
; 1471 : CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::~CMap()
; 1472 : {
; 1473 : 	RemoveAll();
; 1474 : 	ASSERT(m_nCount == 0);
; 1475 : }
; 1476 : 
; 1477 : template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
; 1478 : typename CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CAssoc*
; 1479 : CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::NewAssoc(ARG_KEY key)
; 1480 : {
; 1481 : 	if (m_pFreeList == NULL)
; 1482 : 	{
; 1483 : 		// add another block
; 1484 : 		CPlex* newBlock = CPlex::Create(m_pBlocks, m_nBlockSize, sizeof(CMap::CAssoc));
; 1485 : 		// chain them into free list
; 1486 : 		CMap::CAssoc* pAssoc = (CMap::CAssoc*) newBlock->data();
; 1487 : 		// free in reverse order to make it easier to debug
; 1488 : 		pAssoc += m_nBlockSize - 1;
; 1489 : 		for (INT_PTR i = m_nBlockSize-1; i >= 0; i--, pAssoc--)
; 1490 : 		{
; 1491 : 			pAssoc->pNext = m_pFreeList;
; 1492 : 			m_pFreeList = pAssoc;
; 1493 : 		}
; 1494 : 	}
; 1495 : 	ENSURE(m_pFreeList != NULL);  // we must have something
; 1496 : 
; 1497 : 	CMap::CAssoc* pAssoc = m_pFreeList;
; 1498 : 
; 1499 : 	// zero the memory
; 1500 : 	CMap::CAssoc* pTemp = pAssoc->pNext;
; 1501 : 	memset( pAssoc, 0, sizeof(CMap::CAssoc) );
; 1502 : 	pAssoc->pNext = pTemp;
; 1503 : 
; 1504 : 	m_pFreeList = m_pFreeList->pNext;
; 1505 : 	m_nCount++;
; 1506 : 	ASSERT(m_nCount > 0);  // make sure we don't overflow
; 1507 : #pragma push_macro("new")
; 1508 : #undef new
; 1509 : 	::new(pAssoc) CMap::CAssoc(key);
; 1510 : #pragma pop_macro("new")
; 1511 : 	return pAssoc;
; 1512 : }
; 1513 : 
; 1514 : template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
; 1515 : void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::FreeAssoc(CAssoc* pAssoc)
; 1516 : {
; 1517 : 	pAssoc->CAssoc::~CAssoc();
; 1518 : 	pAssoc->pNext = m_pFreeList;
; 1519 : 	m_pFreeList = pAssoc;
; 1520 : 	m_nCount--;
; 1521 : 	ASSERT(m_nCount >= 0);  // make sure we don't underflow
; 1522 : 
; 1523 : 	// if no more elements, cleanup completely
; 1524 : 	if (m_nCount == 0)
; 1525 : 		RemoveAll();
; 1526 : }
; 1527 : 
; 1528 : template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
; 1529 : typename CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CAssoc*
; 1530 : CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetAssocAt(ARG_KEY key, UINT& nHashBucket, UINT& nHashValue) const
; 1531 : // find association (or return NULL)
; 1532 : {
; 1533 : 	nHashValue = HashKey<ARG_KEY>(key);
; 1534 : 	nHashBucket = nHashValue % m_nHashTableSize;

  003c9	33 d2		 xor	 edx, edx
  003cb	8b c6		 mov	 eax, esi
  003cd	f7 b7 28 01 00
	00		 div	 DWORD PTR [edi+296]

; 1537 : 		return NULL;
; 1538 : 
; 1539 : 	// see if it exists
; 1540 : 	CAssoc* pAssoc;
; 1541 : 	for (pAssoc = m_pHashTable[nHashBucket]; pAssoc != NULL; pAssoc = pAssoc->pNext)

  003d3	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  003d6	85 c0		 test	 eax, eax
  003d8	74 25		 je	 SHORT $LN164@OnApply
  003da	8b 4d c0	 mov	 ecx, DWORD PTR _nFieldKey$3$[ebp]
  003dd	0f 1f 00	 npad	 3
$LL109@OnApply:

; 1542 : 	{
; 1543 : 		if (pAssoc->nHashValue == nHashValue && CompareElements(&pAssoc->key, &key))

  003e0	39 70 0c	 cmp	 DWORD PTR [eax+12], esi
  003e3	75 04		 jne	 SHORT $LN107@OnApply

; 156  : 	return *pElement1 == *pElement2;

  003e5	39 08		 cmp	 DWORD PTR [eax], ecx

; 1543 : 		if (pAssoc->nHashValue == nHashValue && CompareElements(&pAssoc->key, &key))

  003e7	74 09		 je	 SHORT $LN106@OnApply
$LN107@OnApply:

; 1537 : 		return NULL;
; 1538 : 
; 1539 : 	// see if it exists
; 1540 : 	CAssoc* pAssoc;
; 1541 : 	for (pAssoc = m_pHashTable[nHashBucket]; pAssoc != NULL; pAssoc = pAssoc->pNext)

  003e9	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  003ec	85 c0		 test	 eax, eax
  003ee	75 f0		 jne	 SHORT $LL109@OnApply
  003f0	eb 0d		 jmp	 SHORT $LN164@OnApply
$LN106@OnApply:

; 1559 : 	rValue = pAssoc->value;

  003f2	83 c0 04	 add	 eax, 4
  003f5	8d 4d bc	 lea	 ecx, DWORD PTR _strFieldName$[ebp]
  003f8	50		 push	 eax
  003f9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
$LN164@OnApply:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 165  : 		strValue.Format("%d,%s", nFieldKey, strFieldName);

  003ff	ff 75 bc	 push	 DWORD PTR _strFieldName$[ebp]
  00402	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp_?Format@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAAXPBDZZ
  00408	8d 45 cc	 lea	 eax, DWORD PTR _strValue$[ebp]
  0040b	ff 75 c0	 push	 DWORD PTR _nFieldKey$3$[ebp]
  0040e	68 00 00 00 00	 push	 OFFSET ??_C@_05KFJOKFOM@?$CFd?0?$CFs@
  00413	50		 push	 eax
  00414	ff d6		 call	 esi

; 166  : 
; 167  : 		str.Format("%02d", i);

  00416	53		 push	 ebx
  00417	8d 45 b8	 lea	 eax, DWORD PTR _str$[ebp]
  0041a	68 00 00 00 00	 push	 OFFSET ??_C@_04OGKJMPGK@?$CF02d@
  0041f	50		 push	 eax
  00420	ff d6		 call	 esi
  00422	83 c4 1c	 add	 esp, 28			; 0000001cH

; 168  : 		::WritePrivateProfileString(szKey, str, strValue, strConfigPath);

  00425	8d 45 d0	 lea	 eax, DWORD PTR _szKey$[ebp]
  00428	ff 75 c8	 push	 DWORD PTR _strConfigPath$[ebp]
  0042b	ff 75 cc	 push	 DWORD PTR _strValue$[ebp]
  0042e	ff 75 b8	 push	 DWORD PTR _str$[ebp]
  00431	50		 push	 eax
  00432	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WritePrivateProfileStringA@16
  00438	43		 inc	 ebx
  00439	3b 5d c4	 cmp	 ebx, DWORD PTR _nCnt$3$[ebp]
  0043c	0f 8c 3e ff ff
	ff		 jl	 $LL10@OnApply
$LN9@OnApply:

; 170  : }

  00442	8d 4d bc	 lea	 ecx, DWORD PTR _strFieldName$[ebp]
  00445	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0044b	8d 4d cc	 lea	 ecx, DWORD PTR _strValue$[ebp]
  0044e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00454	8d 4d b8	 lea	 ecx, DWORD PTR _str$[ebp]
  00457	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0045d	8d 4d b0	 lea	 ecx, DWORD PTR _strVersion$[ebp]
  00460	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00466	8d 4d c8	 lea	 ecx, DWORD PTR _strConfigPath$[ebp]
  00469	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0046f	8d 4d b4	 lea	 ecx, DWORD PTR _strPath$[ebp]
  00472	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00478	8d 4d 94	 lea	 ecx, DWORD PTR _FileFind$[ebp]
  0047b	e8 00 00 00 00	 call	 ??1CFileFind@@UAE@XZ	; CFileFind::~CFileFind
  00480	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00483	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0048a	59		 pop	 ecx
  0048b	5f		 pop	 edi
  0048c	5e		 pop	 esi
  0048d	5b		 pop	 ebx
  0048e	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00491	33 cd		 xor	 ecx, ebp
  00493	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00498	8b e5		 mov	 esp, ebp
  0049a	5d		 pop	 ebp
  0049b	c3		 ret	 0
$LN101@OnApply:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 290  : 	AfxThrowInvalidArgException();

  0049c	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN166@OnApply:
  004a1	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?OnApply@CDlgSettingToolBar@@IAEXXZ$0:
  00000	8d 4d 94	 lea	 ecx, DWORD PTR _FileFind$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CFileFind@@UAE@XZ	; CFileFind::~CFileFind
__unwindfunclet$?OnApply@CDlgSettingToolBar@@IAEXXZ$1:
  00008	8d 4d b4	 lea	 ecx, DWORD PTR _strPath$[ebp]
  0000b	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?OnApply@CDlgSettingToolBar@@IAEXXZ$2:
  00011	8d 4d c8	 lea	 ecx, DWORD PTR _strConfigPath$[ebp]
  00014	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?OnApply@CDlgSettingToolBar@@IAEXXZ$3:
  0001a	8d 4d b0	 lea	 ecx, DWORD PTR _strVersion$[ebp]
  0001d	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?OnApply@CDlgSettingToolBar@@IAEXXZ$4:
  00023	8d 4d b8	 lea	 ecx, DWORD PTR _str$[ebp]
  00026	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?OnApply@CDlgSettingToolBar@@IAEXXZ$5:
  0002c	8d 4d cc	 lea	 ecx, DWORD PTR _strValue$[ebp]
  0002f	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?OnApply@CDlgSettingToolBar@@IAEXXZ$6:
  00035	8d 4d bc	 lea	 ecx, DWORD PTR _strFieldName$[ebp]
  00038	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0003e	cc		 int	 3
  0003f	cc		 int	 3
  00040	cc		 int	 3
  00041	cc		 int	 3
  00042	cc		 int	 3
__ehhandler$?OnApply@CDlgSettingToolBar@@IAEXXZ:
  00043	90		 npad	 1
  00044	90		 npad	 1
  00045	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00049	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0004c	8b 4a 90	 mov	 ecx, DWORD PTR [edx-112]
  0004f	33 c8		 xor	 ecx, eax
  00051	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00056	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00059	33 c8		 xor	 ecx, eax
  0005b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00060	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?OnApply@CDlgSettingToolBar@@IAEXXZ
  00065	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?OnApply@CDlgSettingToolBar@@IAEXXZ ENDP		; CDlgSettingToolBar::OnApply
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
;	COMDAT ?OnCancel@CDlgSettingToolBar@@MAEXXZ
_TEXT	SEGMENT
?OnCancel@CDlgSettingToolBar@@MAEXXZ PROC		; CDlgSettingToolBar::OnCancel, COMDAT
; _this$ = ecx

; 88   : 	CDialog::OnCancel();

  00000	e9 00 00 00 00	 jmp	 ?OnCancel@CDialog@@MAEXXZ ; CDialog::OnCancel
?OnCancel@CDlgSettingToolBar@@MAEXXZ ENDP		; CDlgSettingToolBar::OnCancel
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
;	COMDAT ?OnOK@CDlgSettingToolBar@@MAEXXZ
_TEXT	SEGMENT
?OnOK@CDlgSettingToolBar@@MAEXXZ PROC			; CDlgSettingToolBar::OnOK, COMDAT
; _this$ = ecx

; 80   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 81   : 	OnApply();

  00003	e8 00 00 00 00	 call	 ?OnApply@CDlgSettingToolBar@@IAEXXZ ; CDlgSettingToolBar::OnApply

; 82   : 	
; 83   : 	CDialog::OnOK();

  00008	8b ce		 mov	 ecx, esi
  0000a	5e		 pop	 esi
  0000b	e9 00 00 00 00	 jmp	 ?OnOK@CDialog@@MAEXXZ	; CDialog::OnOK
?OnOK@CDlgSettingToolBar@@MAEXXZ ENDP			; CDlgSettingToolBar::OnOK
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
;	COMDAT ?OnInitDialog@CDlgSettingToolBar@@MAEHXZ
_TEXT	SEGMENT
_szClipFormat$2 = -32					; size = 4
_aBufWnd$3 = -28					; size = 9
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?OnInitDialog@CDlgSettingToolBar@@MAEHXZ PROC		; CDlgSettingToolBar::OnInitDialog, COMDAT
; _this$ = ecx

; 63   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?OnInitDialog@CDlgSettingToolBar@@MAEHXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 14	 sub	 esp, 20			; 00000014H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	56		 push	 esi
  0001f	57		 push	 edi
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	8b f9		 mov	 edi, ecx

; 64   : 	CDialog::OnInitDialog();

  0002c	e8 00 00 00 00	 call	 ?OnInitDialog@CDialog@@UAEHXZ ; CDialog::OnInitDialog
  00031	0f 57 c0	 xorps	 xmm0, xmm0

; 65   : 
; 66   : 	AfxGetIGateManager(m_pGMng);

  00034	c7 87 3c 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+316], 0
  0003e	8d b7 3c 01 00
	00		 lea	 esi, DWORD PTR [edi+316]
  00044	66 0f d6 45 e4	 movq	 QWORD PTR _aBufWnd$3[ebp], xmm0
  00049	8d 4d e0	 lea	 ecx, DWORD PTR _szClipFormat$2[ebp]
  0004c	c6 45 ec 00	 mov	 BYTE PTR _aBufWnd$3[ebp+8], 0
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00056	68 00 00 00 00	 push	 OFFSET ??_C@_0M@CBBNGGHM@PcTrMng?4dll@
  0005b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00062	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleHandleA@4
  00068	50		 push	 eax
  00069	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@CMCCCNBF@HANAROIGATEMANAGER@
  0006e	8d 45 e0	 lea	 eax, DWORD PTR _szClipFormat$2[ebp]
  00071	68 00 00 00 00	 push	 OFFSET ??_C@_06NDLAHCHE@?$CFs?$CF08X@
  00076	50		 push	 eax
  00077	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Format@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAAXPBDZZ
  0007d	83 c4 10	 add	 esp, 16			; 00000010H
  00080	8d 45 e4	 lea	 eax, DWORD PTR _aBufWnd$3[ebp]
  00083	6a 09		 push	 9
  00085	50		 push	 eax
  00086	ff 75 e0	 push	 DWORD PTR _szClipFormat$2[ebp]
  00089	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetEnvironmentVariableA@12
  0008f	56		 push	 esi
  00090	8d 45 e4	 lea	 eax, DWORD PTR _aBufWnd$3[ebp]
  00093	68 00 00 00 00	 push	 OFFSET ??_C@_02EMFKHFLK@?$CFX@
  00098	50		 push	 eax
  00099	e8 00 00 00 00	 call	 _sscanf
  0009e	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a1	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000a8	8d 4d e0	 lea	 ecx, DWORD PTR _szClipFormat$2[ebp]
  000ab	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 67   : 	ReadIniFile();		// File Read

  000b1	6a 03		 push	 3
  000b3	8b cf		 mov	 ecx, edi
  000b5	e8 00 00 00 00	 call	 ?ReadIniFile@CDlgSettingToolBar@@AAEXH@Z ; CDlgSettingToolBar::ReadIniFile
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl

; 767  : 	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, CB_SETCURSEL, nSelect, 0); }

  000ba	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SendMessageA@16
  000c0	6a 00		 push	 0
  000c2	6a 00		 push	 0
  000c4	68 4e 01 00 00	 push	 334			; 0000014eH
  000c9	ff b7 e8 02 00
	00		 push	 DWORD PTR [edi+744]
  000cf	ff d6		 call	 esi
  000d1	6a 00		 push	 0
  000d3	6a 00		 push	 0
  000d5	68 4e 01 00 00	 push	 334			; 0000014eH
  000da	ff b7 68 02 00
	00		 push	 DWORD PTR [edi+616]
  000e0	ff d6		 call	 esi
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 72   : 	FillAvailableList(m_arrayAnalIdx, m_mapAnalList);

  000e2	8d 87 e8 00 00
	00		 lea	 eax, DWORD PTR [edi+232]
  000e8	8b cf		 mov	 ecx, edi
  000ea	50		 push	 eax
  000eb	8d 87 ac 00 00
	00		 lea	 eax, DWORD PTR [edi+172]
  000f1	50		 push	 eax
  000f2	e8 00 00 00 00	 call	 ?FillAvailableList@CDlgSettingToolBar@@AAEXAAV?$CArray@HH@@AAV?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@@Z ; CDlgSettingToolBar::FillAvailableList

; 73   : 	FillShowList(m_arrayUserIdx, m_mapUserList);

  000f7	8d 87 20 01 00
	00		 lea	 eax, DWORD PTR [edi+288]
  000fd	8b cf		 mov	 ecx, edi
  000ff	50		 push	 eax
  00100	8d 87 d4 00 00
	00		 lea	 eax, DWORD PTR [edi+212]
  00106	50		 push	 eax
  00107	e8 00 00 00 00	 call	 ?FillShowList@CDlgSettingToolBar@@AAEXAAV?$CArray@HH@@AAV?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@@Z ; CDlgSettingToolBar::FillShowList

; 74   : 	
; 75   : 	return TRUE;  // return TRUE unless you set the focus to a control

  0010c	b8 01 00 00 00	 mov	 eax, 1

; 76   : 	              // EXCEPTION: OCX Property Pages should return FALSE
; 77   : }

  00111	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00114	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0011b	59		 pop	 ecx
  0011c	5f		 pop	 edi
  0011d	5e		 pop	 esi
  0011e	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00121	33 cd		 xor	 ecx, ebp
  00123	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00128	8b e5		 mov	 esp, ebp
  0012a	5d		 pop	 ebp
  0012b	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?OnInitDialog@CDlgSettingToolBar@@MAEHXZ$0:
  00000	8d 4d e0	 lea	 ecx, DWORD PTR _szClipFormat$2[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
  0000d	cc		 int	 3
__ehhandler$?OnInitDialog@CDlgSettingToolBar@@MAEHXZ:
  0000e	90		 npad	 1
  0000f	90		 npad	 1
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00024	33 c8		 xor	 ecx, eax
  00026	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?OnInitDialog@CDlgSettingToolBar@@MAEHXZ
  00030	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?OnInitDialog@CDlgSettingToolBar@@MAEHXZ ENDP		; CDlgSettingToolBar::OnInitDialog
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
;	COMDAT ?DoDataExchange@CDlgSettingToolBar@@MAEXPAVCDataExchange@@@Z
_TEXT	SEGMENT
_pDX$ = 8						; size = 4
?DoDataExchange@CDlgSettingToolBar@@MAEXPAVCDataExchange@@@Z PROC ; CDlgSettingToolBar::DoDataExchange, COMDAT
; _this$ = ecx

; 31   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 32   : 	CDialog::DoDataExchange(pDX);
; 33   : 	//{{AFX_DATA_MAP(CDlgSettingToolBar)
; 34   : 	DDX_Control(pDX, IDC_LIST_SHOW, m_listShow);

  00004	8b 75 08	 mov	 esi, DWORD PTR _pDX$[ebp]
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
  0000a	8d 87 48 01 00
	00		 lea	 eax, DWORD PTR [edi+328]
  00010	50		 push	 eax
  00011	68 05 2b 00 00	 push	 11013			; 00002b05H
  00016	56		 push	 esi
  00017	e8 00 00 00 00	 call	 ?DDX_Control@@YGXPAVCDataExchange@@HAAVCWnd@@@Z ; DDX_Control

; 35   : 	DDX_Control(pDX, IDC_LIST_AVAILABLE, m_listAvailable);

  0001c	8d 87 c8 01 00
	00		 lea	 eax, DWORD PTR [edi+456]
  00022	50		 push	 eax
  00023	68 00 2b 00 00	 push	 11008			; 00002b00H
  00028	56		 push	 esi
  00029	e8 00 00 00 00	 call	 ?DDX_Control@@YGXPAVCDataExchange@@HAAVCWnd@@@Z ; DDX_Control

; 36   : 	DDX_Control(pDX, IDC_CMB_SHOW, m_cmbShow);

  0002e	8d 87 48 02 00
	00		 lea	 eax, DWORD PTR [edi+584]
  00034	50		 push	 eax
  00035	68 77 18 00 00	 push	 6263			; 00001877H
  0003a	56		 push	 esi
  0003b	e8 00 00 00 00	 call	 ?DDX_Control@@YGXPAVCDataExchange@@HAAVCWnd@@@Z ; DDX_Control

; 37   : 	DDX_Control(pDX, IDC_CMB_AVAILABLE, m_cmbAvailable);

  00040	8d 87 c8 02 00
	00		 lea	 eax, DWORD PTR [edi+712]
  00046	50		 push	 eax
  00047	68 76 18 00 00	 push	 6262			; 00001876H
  0004c	56		 push	 esi
  0004d	e8 00 00 00 00	 call	 ?DDX_Control@@YGXPAVCDataExchange@@HAAVCWnd@@@Z ; DDX_Control
  00052	5f		 pop	 edi
  00053	5e		 pop	 esi

; 38   : 	//}}AFX_DATA_MAP
; 39   : }

  00054	5d		 pop	 ebp
  00055	c2 04 00	 ret	 4
?DoDataExchange@CDlgSettingToolBar@@MAEXPAVCDataExchange@@@Z ENDP ; CDlgSettingToolBar::DoDataExchange
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
;	COMDAT ??0CDlgSettingToolBar@@QAE@PAVCWnd@@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_this$ = 8						; size = 4
_this$ = 8						; size = 4
_this$ = 8						; size = 4
_pParent$ = 8						; size = 4
??0CDlgSettingToolBar@@QAE@PAVCWnd@@@Z PROC		; CDlgSettingToolBar::CDlgSettingToolBar, COMDAT
; _this$ = ecx

; 21   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CDlgSettingToolBar@@QAE@PAVCWnd@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f9		 mov	 edi, ecx
  00027	89 7d f0	 mov	 DWORD PTR _this$[ebp], edi

; 20   : 	: CDialog(CDlgSettingToolBar::IDD, pParent)

  0002a	ff 75 08	 push	 DWORD PTR _pParent$[ebp]
  0002d	68 b9 17 00 00	 push	 6073			; 000017b9H
  00032	e8 00 00 00 00	 call	 ??0CDialog@@QAE@IPAVCWnd@@@Z ; CDialog::CDialog

; 21   : {

  00037	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7CDlgSettingToolBar@@6B@
  0003d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 348  : {

  00044	c7 87 ac 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+172], OFFSET ??_7?$CArray@HH@@6B@

; 349  : 	m_pData = NULL;

  0004e	c7 87 b0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+176], 0

; 350  : 	m_nSize = m_nMaxSize = m_nGrowBy = 0;

  00058	c7 87 bc 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+188], 0
  00062	c7 87 b8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+184], 0
  0006c	c7 87 b4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+180], 0

; 348  : {

  00076	c7 87 c0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+192], OFFSET ??_7?$CArray@HH@@6B@

; 349  : 	m_pData = NULL;

  00080	c7 87 c4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+196], 0

; 350  : 	m_nSize = m_nMaxSize = m_nGrowBy = 0;

  0008a	c7 87 d0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+208], 0
  00094	c7 87 cc 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+204], 0
  0009e	c7 87 c8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+200], 0

; 348  : {

  000a8	c7 87 d4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+212], OFFSET ??_7?$CArray@HH@@6B@

; 349  : 	m_pData = NULL;

  000b2	c7 87 d8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+216], 0

; 350  : 	m_nSize = m_nMaxSize = m_nGrowBy = 0;

  000bc	c7 87 e4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+228], 0
  000c6	c7 87 e0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+224], 0
  000d0	c7 87 dc 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+220], 0

; 1403 : {

  000da	c7 87 e8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+232], OFFSET ??_7?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@6B@

; 1404 : 	ASSERT(nBlockSize > 0);
; 1405 : 
; 1406 : 	m_pHashTable = NULL;

  000e4	c7 87 ec 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+236], 0

; 1407 : 	m_nHashTableSize = 17;  // default size

  000ee	c7 87 f0 00 00
	00 11 00 00 00	 mov	 DWORD PTR [edi+240], 17	; 00000011H

; 1408 : 	m_nCount = 0;

  000f8	c7 87 f4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+244], 0

; 1409 : 	m_pFreeList = NULL;

  00102	c7 87 f8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+248], 0

; 1410 : 	m_pBlocks = NULL;

  0010c	c7 87 fc 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+252], 0

; 1411 : 	m_nBlockSize = nBlockSize;

  00116	c7 87 00 01 00
	00 0a 00 00 00	 mov	 DWORD PTR [edi+256], 10	; 0000000aH

; 1403 : {

  00120	c7 87 04 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+260], OFFSET ??_7?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@6B@

; 1404 : 	ASSERT(nBlockSize > 0);
; 1405 : 
; 1406 : 	m_pHashTable = NULL;

  0012a	c7 87 08 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+264], 0

; 1407 : 	m_nHashTableSize = 17;  // default size

  00134	c7 87 0c 01 00
	00 11 00 00 00	 mov	 DWORD PTR [edi+268], 17	; 00000011H

; 1408 : 	m_nCount = 0;

  0013e	c7 87 10 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+272], 0

; 1409 : 	m_pFreeList = NULL;

  00148	c7 87 14 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+276], 0

; 1410 : 	m_pBlocks = NULL;

  00152	c7 87 18 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+280], 0

; 1411 : 	m_nBlockSize = nBlockSize;

  0015c	c7 87 1c 01 00
	00 0a 00 00 00	 mov	 DWORD PTR [edi+284], 10	; 0000000aH

; 1403 : {

  00166	c7 87 20 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+288], OFFSET ??_7?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@6B@

; 1404 : 	ASSERT(nBlockSize > 0);
; 1405 : 
; 1406 : 	m_pHashTable = NULL;

  00170	c7 87 24 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+292], 0

; 1407 : 	m_nHashTableSize = 17;  // default size

  0017a	c7 87 28 01 00
	00 11 00 00 00	 mov	 DWORD PTR [edi+296], 17	; 00000011H

; 1408 : 	m_nCount = 0;

  00184	c7 87 2c 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+300], 0

; 1409 : 	m_pFreeList = NULL;

  0018e	c7 87 30 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+304], 0

; 1410 : 	m_pBlocks = NULL;

  00198	c7 87 34 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+308], 0

; 1411 : 	m_nBlockSize = nBlockSize;

  001a2	c7 87 38 01 00
	00 0a 00 00 00	 mov	 DWORD PTR [edi+312], 10	; 0000000aH
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 21   : {

  001ac	8d b7 48 01 00
	00		 lea	 esi, DWORD PTR [edi+328]
  001b2	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl

; 662  : 	{ }

  001b6	8b ce		 mov	 ecx, esi
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 21   : {

  001b8	89 75 08	 mov	 DWORD PTR _this$[ebp], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl

; 662  : 	{ }

  001bb	e8 00 00 00 00	 call	 ??0CWnd@@QAE@XZ		; CWnd::CWnd
  001c0	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CListBox@@6B@
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 21   : {

  001c6	8d b7 c8 01 00
	00		 lea	 esi, DWORD PTR [edi+456]
  001cc	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl

; 662  : 	{ }

  001d0	8b ce		 mov	 ecx, esi
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 21   : {

  001d2	89 75 08	 mov	 DWORD PTR _this$[ebp], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl

; 662  : 	{ }

  001d5	e8 00 00 00 00	 call	 ??0CWnd@@QAE@XZ		; CWnd::CWnd
  001da	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CListBox@@6B@
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 21   : {

  001e0	8d b7 48 02 00
	00		 lea	 esi, DWORD PTR [edi+584]
  001e6	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl

; 761  : 	{ }

  001ea	8b ce		 mov	 ecx, esi
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 21   : {

  001ec	89 75 08	 mov	 DWORD PTR _this$[ebp], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl

; 761  : 	{ }

  001ef	e8 00 00 00 00	 call	 ??0CWnd@@QAE@XZ		; CWnd::CWnd
  001f4	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CComboBox@@6B@
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 21   : {

  001fa	8d b7 c8 02 00
	00		 lea	 esi, DWORD PTR [edi+712]
  00200	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+8], 9
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl

; 761  : 	{ }

  00204	8b ce		 mov	 ecx, esi
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 21   : {

  00206	89 75 08	 mov	 DWORD PTR _this$[ebp], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl

; 761  : 	{ }

  00209	e8 00 00 00 00	 call	 ??0CWnd@@QAE@XZ		; CWnd::CWnd
  0020e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CComboBox@@6B@
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 27   : }

  00214	8b c7		 mov	 eax, edi
  00216	c7 87 a8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+168], 0
  00220	c7 87 40 01 00
	00 55 1b 32 01	 mov	 DWORD PTR [edi+320], 20061013 ; 01321b55H
  0022a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0022d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00234	59		 pop	 ecx
  00235	5f		 pop	 edi
  00236	5e		 pop	 esi
  00237	8b e5		 mov	 esp, ebp
  00239	5d		 pop	 ebp
  0023a	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CDlgSettingToolBar@@QAE@PAVCWnd@@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CDialog@@UAE@XZ	; CDialog::~CDialog
__unwindfunclet$??0CDlgSettingToolBar@@QAE@PAVCWnd@@@Z$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	81 c1 ac 00 00
	00		 add	 ecx, 172		; 000000acH
  00011	e9 00 00 00 00	 jmp	 ??1?$CArray@HH@@UAE@XZ	; CArray<int,int>::~CArray<int,int>
__unwindfunclet$??0CDlgSettingToolBar@@QAE@PAVCWnd@@@Z$2:
  00016	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	81 c1 c0 00 00
	00		 add	 ecx, 192		; 000000c0H
  0001f	e9 00 00 00 00	 jmp	 ??1?$CArray@HH@@UAE@XZ	; CArray<int,int>::~CArray<int,int>
__unwindfunclet$??0CDlgSettingToolBar@@QAE@PAVCWnd@@@Z$3:
  00024	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	81 c1 d4 00 00
	00		 add	 ecx, 212		; 000000d4H
  0002d	e9 00 00 00 00	 jmp	 ??1?$CArray@HH@@UAE@XZ	; CArray<int,int>::~CArray<int,int>
__unwindfunclet$??0CDlgSettingToolBar@@QAE@PAVCWnd@@@Z$4:
  00032	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	81 c1 e8 00 00
	00		 add	 ecx, 232		; 000000e8H
  0003b	e9 00 00 00 00	 jmp	 ??1?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@UAE@XZ ; CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >::~CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >
__unwindfunclet$??0CDlgSettingToolBar@@QAE@PAVCWnd@@@Z$5:
  00040	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	81 c1 04 01 00
	00		 add	 ecx, 260		; 00000104H
  00049	e9 00 00 00 00	 jmp	 ??1?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@UAE@XZ ; CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >::~CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >
__unwindfunclet$??0CDlgSettingToolBar@@QAE@PAVCWnd@@@Z$6:
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	81 c1 20 01 00
	00		 add	 ecx, 288		; 00000120H
  00057	e9 00 00 00 00	 jmp	 ??1?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@UAE@XZ ; CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >::~CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >
__unwindfunclet$??0CDlgSettingToolBar@@QAE@PAVCWnd@@@Z$7:
  0005c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0005f	81 c1 48 01 00
	00		 add	 ecx, 328		; 00000148H
  00065	e9 00 00 00 00	 jmp	 ??1CListBox@@UAE@XZ	; CListBox::~CListBox
__unwindfunclet$??0CDlgSettingToolBar@@QAE@PAVCWnd@@@Z$8:
  0006a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0006d	81 c1 c8 01 00
	00		 add	 ecx, 456		; 000001c8H
  00073	e9 00 00 00 00	 jmp	 ??1CListBox@@UAE@XZ	; CListBox::~CListBox
__unwindfunclet$??0CDlgSettingToolBar@@QAE@PAVCWnd@@@Z$9:
  00078	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0007b	81 c1 48 02 00
	00		 add	 ecx, 584		; 00000248H
  00081	e9 00 00 00 00	 jmp	 ??1CComboBox@@UAE@XZ	; CComboBox::~CComboBox
  00086	cc		 int	 3
  00087	cc		 int	 3
  00088	cc		 int	 3
  00089	cc		 int	 3
  0008a	cc		 int	 3
__ehhandler$??0CDlgSettingToolBar@@QAE@PAVCWnd@@@Z:
  0008b	90		 npad	 1
  0008c	90		 npad	 1
  0008d	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00091	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00094	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00097	33 c8		 xor	 ecx, eax
  00099	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0009e	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CDlgSettingToolBar@@QAE@PAVCWnd@@@Z
  000a3	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CDlgSettingToolBar@@QAE@PAVCWnd@@@Z ENDP		; CDlgSettingToolBar::CDlgSettingToolBar
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
;	COMDAT ?FillAvailableList@CDlgSettingToolBar@@AAEXAAV?$CArray@HH@@AAV?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@@Z
_TEXT	SEGMENT
_this$1$ = -24						; size = 4
_key$1$ = -20						; size = 4
_strFieldName$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_arrayList$ = 8						; size = 4
_mapList$ = 12						; size = 4
?FillAvailableList@CDlgSettingToolBar@@AAEXAAV?$CArray@HH@@AAV?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@@Z PROC ; CDlgSettingToolBar::FillAvailableList, COMDAT
; _this$ = ecx

; 410  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?FillAvailableList@CDlgSettingToolBar@@AAEXAAV?$CArray@HH@@AAV?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b d9		 mov	 ebx, ecx
  0002a	89 5d e8	 mov	 DWORD PTR _this$1$[ebp], ebx

; 415  : 	CString strFieldName;

  0002d	8d 4d f0	 lea	 ecx, DWORD PTR _strFieldName$[ebp]
  00030	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl

; 731  : 	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, LB_RESETCONTENT, 0, 0); }

  00036	6a 00		 push	 0
  00038	6a 00		 push	 0
  0003a	68 84 01 00 00	 push	 388			; 00000184H
  0003f	ff b3 e8 01 00
	00		 push	 DWORD PTR [ebx+488]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 415  : 	CString strFieldName;

  00045	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl

; 731  : 	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, LB_RESETCONTENT, 0, 0); }

  0004c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 418  : 	for(int i=0; i< arrayList.GetSize(); i++)

  00052	8b 4d 08	 mov	 ecx, DWORD PTR _arrayList$[ebp]
  00055	33 ff		 xor	 edi, edi
  00057	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0005a	85 c0		 test	 eax, eax
  0005c	0f 8e aa 00 00
	00		 jle	 $LN3@FillAvaila
  00062	be 1d f3 01 00	 mov	 esi, 127773		; 0001f31dH
$LL4@FillAvaila:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 288  : 	if(nIndex >= 0 && nIndex < m_nSize)

  00067	85 ff		 test	 edi, edi
  00069	0f 88 ba 00 00
	00		 js	 $LN10@FillAvaila
  0006f	3b f8		 cmp	 edi, eax
  00071	0f 8d b2 00 00
	00		 jge	 $LN10@FillAvaila

; 1555 : 	CAssoc* pAssoc = GetAssocAt(key, nHashBucket, nHashValue);

  00077	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0007a	8b 1c b8	 mov	 ebx, DWORD PTR [eax+edi*4]

; 165  : 	ldiv_t HashVal = ldiv((long)(ARG_KEY)key, 127773);

  0007d	8b c3		 mov	 eax, ebx
  0007f	99		 cdq
  00080	f7 fe		 idiv	 esi

; 1555 : 	CAssoc* pAssoc = GetAssocAt(key, nHashBucket, nHashValue);

  00082	89 5d ec	 mov	 DWORD PTR _key$1$[ebp], ebx

; 166  : 	HashVal.rem = 16807 * HashVal.rem - 2836 * HashVal.quot;

  00085	69 c0 14 0b 00
	00		 imul	 eax, eax, 2836
  0008b	69 ca a7 41 00
	00		 imul	 ecx, edx, 16807
  00091	2b c8		 sub	 ecx, eax

; 1536 : 	if (m_pHashTable == NULL)

  00093	8b 45 0c	 mov	 eax, DWORD PTR _mapList$[ebp]
  00096	8d b1 ff ff ff
	7f		 lea	 esi, DWORD PTR [ecx+2147483647]
  0009c	0f 49 f1	 cmovns	 esi, ecx
  0009f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000a2	85 c9		 test	 ecx, ecx
  000a4	74 39		 je	 SHORT $LN50@FillAvaila

; 291  : }
; 292  : template<class TYPE, class ARG_TYPE>
; 293  : AFX_INLINE const TYPE& CArray<TYPE, ARG_TYPE>::GetAt(INT_PTR nIndex) const
; 294  : {
; 295  : 	ASSERT(nIndex >= 0 && nIndex < m_nSize);
; 296  : 	if(nIndex >= 0 && nIndex < m_nSize)
; 297  : 		return m_pData[nIndex];
; 298  : 	AfxThrowInvalidArgException();
; 299  : }
; 300  : template<class TYPE, class ARG_TYPE>
; 301  : AFX_INLINE void CArray<TYPE, ARG_TYPE>::SetAt(INT_PTR nIndex, ARG_TYPE newElement)
; 302  : {
; 303  : 	ASSERT(nIndex >= 0 && nIndex < m_nSize);
; 304  : 	if(nIndex >= 0 && nIndex < m_nSize)
; 305  : 		m_pData[nIndex] = newElement;
; 306  : 	else
; 307  : 		AfxThrowInvalidArgException();
; 308  : }
; 309  : template<class TYPE, class ARG_TYPE>
; 310  : AFX_INLINE const TYPE& CArray<TYPE, ARG_TYPE>::ElementAt(INT_PTR nIndex) const
; 311  : {
; 312  : 	ASSERT(nIndex >= 0 && nIndex < m_nSize);
; 313  : 	if(nIndex >= 0 && nIndex < m_nSize)
; 314  : 		return m_pData[nIndex];
; 315  : 	AfxThrowInvalidArgException();
; 316  : }
; 317  : template<class TYPE, class ARG_TYPE>
; 318  : AFX_INLINE TYPE& CArray<TYPE, ARG_TYPE>::ElementAt(INT_PTR nIndex)
; 319  : {
; 320  : 	ASSERT(nIndex >= 0 && nIndex < m_nSize);
; 321  : 	if(nIndex >= 0 && nIndex < m_nSize)
; 322  : 		return m_pData[nIndex];
; 323  : 	AfxThrowInvalidArgException();
; 324  : }
; 325  : template<class TYPE, class ARG_TYPE>
; 326  : AFX_INLINE const TYPE* CArray<TYPE, ARG_TYPE>::GetData() const
; 327  : 	{ return (const TYPE*)m_pData; }
; 328  : template<class TYPE, class ARG_TYPE>
; 329  : AFX_INLINE TYPE* CArray<TYPE, ARG_TYPE>::GetData()
; 330  : 	{ return (TYPE*)m_pData; }
; 331  : template<class TYPE, class ARG_TYPE>
; 332  : AFX_INLINE INT_PTR CArray<TYPE, ARG_TYPE>::Add(ARG_TYPE newElement)
; 333  : 	{ INT_PTR nIndex = m_nSize;
; 334  : 		SetAtGrow(nIndex, newElement);
; 335  : 		return nIndex; }
; 336  : template<class TYPE, class ARG_TYPE>
; 337  : AFX_INLINE const TYPE& CArray<TYPE, ARG_TYPE>::operator[](INT_PTR nIndex) const
; 338  : 	{ return GetAt(nIndex); }
; 339  : template<class TYPE, class ARG_TYPE>
; 340  : AFX_INLINE TYPE& CArray<TYPE, ARG_TYPE>::operator[](INT_PTR nIndex)
; 341  : 	{ return ElementAt(nIndex); }
; 342  : 
; 343  : /*============================================================================*/
; 344  : // CArray<TYPE, ARG_TYPE> out-of-line functions
; 345  : 
; 346  : template<class TYPE, class ARG_TYPE>
; 347  : CArray<TYPE, ARG_TYPE>::CArray()
; 348  : {
; 349  : 	m_pData = NULL;
; 350  : 	m_nSize = m_nMaxSize = m_nGrowBy = 0;
; 351  : }
; 352  : 
; 353  : template<class TYPE, class ARG_TYPE>
; 354  : CArray<TYPE, ARG_TYPE>::~CArray()
; 355  : {
; 356  : 	ASSERT_VALID(this);
; 357  : 
; 358  : 	if (m_pData != NULL)
; 359  : 	{
; 360  : 		for( int i = 0; i < m_nSize; i++ )
; 361  : 			(m_pData + i)->~TYPE();
; 362  : 		delete[] (BYTE*)m_pData;
; 363  : 	}
; 364  : }
; 365  : 
; 366  : template<class TYPE, class ARG_TYPE>
; 367  : void CArray<TYPE, ARG_TYPE>::SetSize(INT_PTR nNewSize, INT_PTR nGrowBy)
; 368  : {
; 369  : 	ASSERT_VALID(this);
; 370  : 	ASSERT(nNewSize >= 0);
; 371  : 
; 372  : 	if(nNewSize < 0 )
; 373  : 		AfxThrowInvalidArgException();
; 374  : 
; 375  : 	if (nGrowBy >= 0)
; 376  : 		m_nGrowBy = nGrowBy;  // set new size
; 377  : 
; 378  : 	if (nNewSize == 0)
; 379  : 	{
; 380  : 		// shrink to nothing
; 381  : 		if (m_pData != NULL)
; 382  : 		{
; 383  : 			for( int i = 0; i < m_nSize; i++ )
; 384  : 				(m_pData + i)->~TYPE();
; 385  : 			delete[] (BYTE*)m_pData;
; 386  : 			m_pData = NULL;
; 387  : 		}
; 388  : 		m_nSize = m_nMaxSize = 0;
; 389  : 	}
; 390  : 	else if (m_pData == NULL)
; 391  : 	{
; 392  : 		// create buffer big enough to hold number of requested elements or
; 393  : 		// m_nGrowBy elements, whichever is larger.
; 394  : #ifdef SIZE_T_MAX
; 395  : 		ASSERT(nNewSize <= SIZE_T_MAX/sizeof(TYPE));    // no overflow
; 396  : #endif
; 397  : 		size_t nAllocSize = __max(nNewSize, m_nGrowBy);
; 398  : 		m_pData = (TYPE*) new BYTE[(size_t)nAllocSize * sizeof(TYPE)];
; 399  : 		memset((void*)m_pData, 0, (size_t)nAllocSize * sizeof(TYPE));
; 400  : 		for( int i = 0; i < nNewSize; i++ )
; 401  : #pragma push_macro("new")
; 402  : #undef new
; 403  : 			::new( (void*)( m_pData + i ) ) TYPE;
; 404  : #pragma pop_macro("new")
; 405  : 		m_nSize = nNewSize;
; 406  : 		m_nMaxSize = nAllocSize;
; 407  : 	}
; 408  : 	else if (nNewSize <= m_nMaxSize)
; 409  : 	{
; 410  : 		// it fits
; 411  : 		if (nNewSize > m_nSize)
; 412  : 		{
; 413  : 			// initialize the new elements
; 414  : 			memset((void*)(m_pData + m_nSize), 0, (size_t)(nNewSize-m_nSize) * sizeof(TYPE));
; 415  : 			for( int i = 0; i < nNewSize-m_nSize; i++ )
; 416  : #pragma push_macro("new")
; 417  : #undef new
; 418  : 				::new( (void*)( m_pData + m_nSize + i ) ) TYPE;
; 419  : #pragma pop_macro("new")
; 420  : 		}
; 421  : 		else if (m_nSize > nNewSize)
; 422  : 		{
; 423  : 			// destroy the old elements
; 424  : 			for( int i = 0; i < m_nSize-nNewSize; i++ )
; 425  : 				(m_pData + nNewSize + i)->~TYPE();
; 426  : 		}
; 427  : 		m_nSize = nNewSize;
; 428  : 	}
; 429  : 	else
; 430  : 	{
; 431  : 		// otherwise, grow array
; 432  : 		nGrowBy = m_nGrowBy;
; 433  : 		if (nGrowBy == 0)
; 434  : 		{
; 435  : 			// heuristically determine growth when nGrowBy == 0
; 436  : 			//  (this avoids heap fragmentation in many situations)
; 437  : 			nGrowBy = m_nSize / 8;
; 438  : 			nGrowBy = (nGrowBy < 4) ? 4 : ((nGrowBy > 1024) ? 1024 : nGrowBy);
; 439  : 		}
; 440  : 		INT_PTR nNewMax;
; 441  : 		if (nNewSize < m_nMaxSize + nGrowBy)
; 442  : 			nNewMax = m_nMaxSize + nGrowBy;  // granularity
; 443  : 		else
; 444  : 			nNewMax = nNewSize;  // no slush
; 445  : 
; 446  : 		ASSERT(nNewMax >= m_nMaxSize);  // no wrap around
; 447  : 
; 448  : 		if(nNewMax  < m_nMaxSize)
; 449  : 			AfxThrowInvalidArgException();
; 450  : 
; 451  : #ifdef SIZE_T_MAX
; 452  : 		ASSERT(nNewMax <= SIZE_T_MAX/sizeof(TYPE)); // no overflow
; 453  : #endif
; 454  : 		TYPE* pNewData = (TYPE*) new BYTE[(size_t)nNewMax * sizeof(TYPE)];
; 455  : 
; 456  : 		// copy new data from old
; 457  : 		::ATL::Checked::memcpy_s(pNewData, (size_t)nNewMax * sizeof(TYPE),
; 458  : 			m_pData, (size_t)m_nSize * sizeof(TYPE));
; 459  : 
; 460  : 		// construct remaining elements
; 461  : 		ASSERT(nNewSize > m_nSize);
; 462  : 		memset((void*)(pNewData + m_nSize), 0, (size_t)(nNewSize-m_nSize) * sizeof(TYPE));
; 463  : 		for( int i = 0; i < nNewSize-m_nSize; i++ )
; 464  : #pragma push_macro("new")
; 465  : #undef new
; 466  : 			::new( (void*)( pNewData + m_nSize + i ) ) TYPE;
; 467  : #pragma pop_macro("new")
; 468  : 
; 469  : 		// get rid of old stuff (note: no destructors called)
; 470  : 		delete[] (BYTE*)m_pData;
; 471  : 		m_pData = pNewData;
; 472  : 		m_nSize = nNewSize;
; 473  : 		m_nMaxSize = nNewMax;
; 474  : 	}
; 475  : }
; 476  : 
; 477  : template<class TYPE, class ARG_TYPE>
; 478  : INT_PTR CArray<TYPE, ARG_TYPE>::Append(const CArray& src)
; 479  : {
; 480  : 	ASSERT_VALID(this);
; 481  : 	ASSERT(this != &src);   // cannot append to itself
; 482  : 
; 483  : 	if(this == &src)
; 484  : 		AfxThrowInvalidArgException();
; 485  : 
; 486  : 	INT_PTR nOldSize = m_nSize;
; 487  : 	SetSize(m_nSize + src.m_nSize);
; 488  : 	CopyElements<TYPE>(m_pData + nOldSize, src.m_pData, src.m_nSize);
; 489  : 	return nOldSize;
; 490  : }
; 491  : 
; 492  : template<class TYPE, class ARG_TYPE>
; 493  : void CArray<TYPE, ARG_TYPE>::Copy(const CArray& src)
; 494  : {
; 495  : 	ASSERT_VALID(this);
; 496  : 	ASSERT(this != &src);   // cannot append to itself
; 497  : 
; 498  : 	if(this != &src)
; 499  : 	{
; 500  : 		SetSize(src.m_nSize);
; 501  : 		CopyElements<TYPE>(m_pData, src.m_pData, src.m_nSize);
; 502  : 	}
; 503  : }
; 504  : 
; 505  : template<class TYPE, class ARG_TYPE>
; 506  : void CArray<TYPE, ARG_TYPE>::FreeExtra()
; 507  : {
; 508  : 	ASSERT_VALID(this);
; 509  : 
; 510  : 	if (m_nSize != m_nMaxSize)
; 511  : 	{
; 512  : 		// shrink to desired size
; 513  : #ifdef SIZE_T_MAX
; 514  : 		ASSERT(m_nSize <= SIZE_T_MAX/sizeof(TYPE)); // no overflow
; 515  : #endif
; 516  : 		TYPE* pNewData = NULL;
; 517  : 		if (m_nSize != 0)
; 518  : 		{
; 519  : 			pNewData = (TYPE*) new BYTE[m_nSize * sizeof(TYPE)];
; 520  : 			// copy new data from old
; 521  : 			::ATL::Checked::memcpy_s(pNewData, m_nSize * sizeof(TYPE),
; 522  : 				m_pData, m_nSize * sizeof(TYPE));
; 523  : 		}
; 524  : 
; 525  : 		// get rid of old stuff (note: no destructors called)
; 526  : 		delete[] (BYTE*)m_pData;
; 527  : 		m_pData = pNewData;
; 528  : 		m_nMaxSize = m_nSize;
; 529  : 	}
; 530  : }
; 531  : 
; 532  : template<class TYPE, class ARG_TYPE>
; 533  : void CArray<TYPE, ARG_TYPE>::SetAtGrow(INT_PTR nIndex, ARG_TYPE newElement)
; 534  : {
; 535  : 	ASSERT_VALID(this);
; 536  : 	ASSERT(nIndex >= 0);
; 537  : 
; 538  : 	if(nIndex < 0)
; 539  : 		AfxThrowInvalidArgException();
; 540  : 
; 541  : 	if (nIndex >= m_nSize)
; 542  : 		SetSize(nIndex+1, -1);
; 543  : 	m_pData[nIndex] = newElement;
; 544  : }
; 545  : 
; 546  : template<class TYPE, class ARG_TYPE>
; 547  : void CArray<TYPE, ARG_TYPE>::InsertAt(INT_PTR nIndex, ARG_TYPE newElement, INT_PTR nCount /*=1*/)
; 548  : {
; 549  : 	ASSERT_VALID(this);
; 550  : 	ASSERT(nIndex >= 0);    // will expand to meet need
; 551  : 	ASSERT(nCount > 0);     // zero or negative size not allowed
; 552  : 
; 553  : 	if(nIndex < 0 || nCount <= 0)
; 554  : 		AfxThrowInvalidArgException();
; 555  : 
; 556  : 	if (nIndex >= m_nSize)
; 557  : 	{
; 558  : 		// adding after the end of the array
; 559  : 		SetSize(nIndex + nCount, -1);   // grow so nIndex is valid
; 560  : 	}
; 561  : 	else
; 562  : 	{
; 563  : 		// inserting in the middle of the array
; 564  : 		INT_PTR nOldSize = m_nSize;
; 565  : 		SetSize(m_nSize + nCount, -1);  // grow it to new size
; 566  : 		// destroy intial data before copying over it
; 567  : 		for( int i = 0; i < nCount; i++ )
; 568  : 			(m_pData + nOldSize + i)->~TYPE();
; 569  : 		// shift old data up to fill gap
; 570  : 		::ATL::Checked::memmove_s(m_pData + nIndex + nCount, (nOldSize-nIndex) * sizeof(TYPE),
; 571  : 			m_pData + nIndex, (nOldSize-nIndex) * sizeof(TYPE));
; 572  : 
; 573  : 		// re-init slots we copied from
; 574  : 		memset((void*)(m_pData + nIndex), 0, (size_t)nCount * sizeof(TYPE));
; 575  : 		for( int i = 0; i < nCount; i++ )
; 576  : #pragma push_macro("new")
; 577  : #undef new
; 578  : 			::new( (void*)( m_pData + nIndex + i ) ) TYPE;
; 579  : #pragma pop_macro("new")
; 580  : 	}
; 581  : 
; 582  : 	// insert new value in the gap
; 583  : 	ASSERT(nIndex + nCount <= m_nSize);
; 584  : 	while (nCount--)
; 585  : 		m_pData[nIndex++] = newElement;
; 586  : }
; 587  : 
; 588  : template<class TYPE, class ARG_TYPE>
; 589  : void CArray<TYPE, ARG_TYPE>::RemoveAt(INT_PTR nIndex, INT_PTR nCount)
; 590  : {
; 591  : 	ASSERT_VALID(this);
; 592  : 	ASSERT(nIndex >= 0);
; 593  : 	ASSERT(nCount >= 0);
; 594  : 	INT_PTR nUpperBound = nIndex + nCount;
; 595  : 	ASSERT(nUpperBound <= m_nSize && nUpperBound >= nIndex && nUpperBound >= nCount);
; 596  : 
; 597  : 	if(nIndex < 0 || nCount < 0 || (nUpperBound > m_nSize) || (nUpperBound < nIndex) || (nUpperBound < nCount))
; 598  : 		AfxThrowInvalidArgException();
; 599  : 
; 600  : 	// just remove a range
; 601  : 	INT_PTR nMoveCount = m_nSize - (nUpperBound);
; 602  : 	for( int i = 0; i < nCount; i++ )
; 603  : 		(m_pData + nIndex + i)->~TYPE();
; 604  : 	if (nMoveCount)
; 605  : 	{
; 606  : 		::ATL::Checked::memmove_s(m_pData + nIndex, (size_t)nMoveCount * sizeof(TYPE),
; 607  : 			m_pData + nUpperBound, (size_t)nMoveCount * sizeof(TYPE));
; 608  : 	}
; 609  : 	m_nSize -= nCount;
; 610  : }
; 611  : 
; 612  : template<class TYPE, class ARG_TYPE>
; 613  : void CArray<TYPE, ARG_TYPE>::InsertAt(INT_PTR nStartIndex, CArray* pNewArray)
; 614  : {
; 615  : 	ASSERT_VALID(this);
; 616  : 	ASSERT(pNewArray != NULL);
; 617  : 	ASSERT_VALID(pNewArray);
; 618  : 	ASSERT(nStartIndex >= 0);
; 619  : 
; 620  : 	if(pNewArray == NULL || nStartIndex < 0)
; 621  : 		AfxThrowInvalidArgException();
; 622  : 
; 623  : 	if (pNewArray->GetSize() > 0)
; 624  : 	{
; 625  : 		InsertAt(nStartIndex, pNewArray->GetAt(0), pNewArray->GetSize());
; 626  : 		for (INT_PTR i = 0; i < pNewArray->GetSize(); i++)
; 627  : 			SetAt(nStartIndex + i, pNewArray->GetAt(i));
; 628  : 	}
; 629  : }
; 630  : 
; 631  : template<class TYPE, class ARG_TYPE>
; 632  : void CArray<TYPE, ARG_TYPE>::Serialize(CArchive& ar)
; 633  : {
; 634  : 	ASSERT_VALID(this);
; 635  : 
; 636  : 	CObject::Serialize(ar);
; 637  : 	if (ar.IsStoring())
; 638  : 	{
; 639  : 		ar.WriteCount(m_nSize);
; 640  : 	}
; 641  : 	else
; 642  : 	{
; 643  : 		DWORD_PTR nOldSize = ar.ReadCount();
; 644  : 		SetSize(nOldSize, -1);
; 645  : 	}
; 646  : 	SerializeElements<TYPE>(ar, m_pData, m_nSize);
; 647  : }
; 648  : 
; 649  : #ifdef _DEBUG
; 650  : template<class TYPE, class ARG_TYPE>
; 651  : void CArray<TYPE, ARG_TYPE>::Dump(CDumpContext& dc) const
; 652  : {
; 653  : 	CObject::Dump(dc);
; 654  : 
; 655  : 	dc << "with " << m_nSize << " elements";
; 656  : 	if (dc.GetDepth() > 0)
; 657  : 	{
; 658  : 		dc << "\n";
; 659  : 		DumpElements<TYPE>(dc, m_pData, m_nSize);
; 660  : 	}
; 661  : 
; 662  : 	dc << "\n";
; 663  : }
; 664  : 
; 665  : template<class TYPE, class ARG_TYPE>
; 666  : void CArray<TYPE, ARG_TYPE>::AssertValid() const
; 667  : {
; 668  : 	CObject::AssertValid();
; 669  : 
; 670  : 	if (m_pData == NULL)
; 671  : 	{
; 672  : 		ASSERT(m_nSize == 0);
; 673  : 		ASSERT(m_nMaxSize == 0);
; 674  : 	}
; 675  : 	else
; 676  : 	{
; 677  : 		ASSERT(m_nSize >= 0);
; 678  : 		ASSERT(m_nMaxSize >= 0);
; 679  : 		ASSERT(m_nSize <= m_nMaxSize);
; 680  : 		ASSERT(AfxIsValidAddress(m_pData, m_nMaxSize * sizeof(TYPE)));
; 681  : 	}
; 682  : }
; 683  : #endif //_DEBUG
; 684  : 
; 685  : /*============================================================================*/
; 686  : // CList<TYPE, ARG_TYPE>
; 687  : 
; 688  : template<class TYPE, class ARG_TYPE = const TYPE&>
; 689  : class CList : public CObject
; 690  : {
; 691  : protected:
; 692  : 	struct CNode
; 693  : 	{
; 694  : 		CNode* pNext;
; 695  : 		CNode* pPrev;
; 696  : 		TYPE data;
; 697  : 	};
; 698  : public:
; 699  : // Construction
; 700  : 	explicit CList(INT_PTR nBlockSize = 10);
; 701  : 
; 702  : // Attributes (head and tail)
; 703  : 	// count of elements
; 704  : 	INT_PTR GetCount() const;
; 705  : 	INT_PTR GetSize() const;
; 706  : 	BOOL IsEmpty() const;
; 707  : 
; 708  : 	// peek at head or tail
; 709  : 	TYPE& GetHead();
; 710  : 	const TYPE& GetHead() const;
; 711  : 	TYPE& GetTail();
; 712  : 	const TYPE& GetTail() const;
; 713  : 
; 714  : // Operations
; 715  : 	// get head or tail (and remove it) - don't call on empty list !
; 716  : 	TYPE RemoveHead();
; 717  : 	TYPE RemoveTail();
; 718  : 
; 719  : 	// add before head or after tail
; 720  : 	POSITION AddHead(ARG_TYPE newElement);
; 721  : 	POSITION AddTail(ARG_TYPE newElement);
; 722  : 
; 723  : 	// add another list of elements before head or after tail
; 724  : 	void AddHead(CList* pNewList);
; 725  : 	void AddTail(CList* pNewList);
; 726  : 
; 727  : 	// remove all elements
; 728  : 	void RemoveAll();
; 729  : 
; 730  : 	// iteration
; 731  : 	POSITION GetHeadPosition() const;
; 732  : 	POSITION GetTailPosition() const;
; 733  : 	TYPE& GetNext(POSITION& rPosition); // return *Position++
; 734  : 	const TYPE& GetNext(POSITION& rPosition) const; // return *Position++
; 735  : 	TYPE& GetPrev(POSITION& rPosition); // return *Position--
; 736  : 	const TYPE& GetPrev(POSITION& rPosition) const; // return *Position--
; 737  : 
; 738  : 	// getting/modifying an element at a given position
; 739  : 	TYPE& GetAt(POSITION position);
; 740  : 	const TYPE& GetAt(POSITION position) const;
; 741  : 	void SetAt(POSITION pos, ARG_TYPE newElement);
; 742  : 	void RemoveAt(POSITION position);
; 743  : 
; 744  : 	// inserting before or after a given position
; 745  : 	POSITION InsertBefore(POSITION position, ARG_TYPE newElement);
; 746  : 	POSITION InsertAfter(POSITION position, ARG_TYPE newElement);
; 747  : 
; 748  : 	// helper functions (note: O(n) speed)
; 749  : 	POSITION Find(ARG_TYPE searchValue, POSITION startAfter = NULL) const;
; 750  : 		// defaults to starting at the HEAD, return NULL if not found
; 751  : 	POSITION FindIndex(INT_PTR nIndex) const;
; 752  : 		// get the 'nIndex'th element (may return NULL)
; 753  : 
; 754  : // Implementation
; 755  : protected:
; 756  : 	CNode* m_pNodeHead;
; 757  : 	CNode* m_pNodeTail;
; 758  : 	INT_PTR m_nCount;
; 759  : 	CNode* m_pNodeFree;
; 760  : 	struct CPlex* m_pBlocks;
; 761  : 	INT_PTR m_nBlockSize;
; 762  : 
; 763  : 	CNode* NewNode(CNode*, CNode*);
; 764  : 	void FreeNode(CNode*);
; 765  : 
; 766  : public:
; 767  : 	~CList();
; 768  : 	void Serialize(CArchive&);
; 769  : #ifdef _DEBUG
; 770  : 	void Dump(CDumpContext&) const;
; 771  : 	void AssertValid() const;
; 772  : #endif
; 773  : };
; 774  : 
; 775  : /*============================================================================*/
; 776  : // CList<TYPE, ARG_TYPE> inline functions
; 777  : 
; 778  : template<class TYPE, class ARG_TYPE>
; 779  : AFX_INLINE INT_PTR CList<TYPE, ARG_TYPE>::GetCount() const
; 780  : 	{ return m_nCount; }
; 781  : template<class TYPE, class ARG_TYPE>
; 782  : AFX_INLINE INT_PTR CList<TYPE, ARG_TYPE>::GetSize() const
; 783  : 	{ return m_nCount; }
; 784  : template<class TYPE, class ARG_TYPE>
; 785  : AFX_INLINE BOOL CList<TYPE, ARG_TYPE>::IsEmpty() const
; 786  : 	{ return m_nCount == 0; }
; 787  : template<class TYPE, class ARG_TYPE>
; 788  : AFX_INLINE TYPE& CList<TYPE, ARG_TYPE>::GetHead()
; 789  : 	{ ENSURE(m_pNodeHead != NULL);
; 790  : 		return m_pNodeHead->data; }
; 791  : template<class TYPE, class ARG_TYPE>
; 792  : AFX_INLINE const TYPE& CList<TYPE, ARG_TYPE>::GetHead() const
; 793  : 	{ ENSURE(m_pNodeHead != NULL);
; 794  : 		return m_pNodeHead->data; }
; 795  : template<class TYPE, class ARG_TYPE>
; 796  : AFX_INLINE TYPE& CList<TYPE, ARG_TYPE>::GetTail()
; 797  : 	{ ENSURE(m_pNodeTail != NULL);
; 798  : 		return m_pNodeTail->data; }
; 799  : template<class TYPE, class ARG_TYPE>
; 800  : AFX_INLINE const TYPE& CList<TYPE, ARG_TYPE>::GetTail() const
; 801  : 	{ ENSURE(m_pNodeTail != NULL);
; 802  : 		return m_pNodeTail->data; }
; 803  : template<class TYPE, class ARG_TYPE>
; 804  : AFX_INLINE POSITION CList<TYPE, ARG_TYPE>::GetHeadPosition() const
; 805  : 	{ return (POSITION) m_pNodeHead; }
; 806  : template<class TYPE, class ARG_TYPE>
; 807  : AFX_INLINE POSITION CList<TYPE, ARG_TYPE>::GetTailPosition() const
; 808  : 	{ return (POSITION) m_pNodeTail; }
; 809  : template<class TYPE, class ARG_TYPE>
; 810  : AFX_INLINE TYPE& CList<TYPE, ARG_TYPE>::GetNext(POSITION& rPosition) // return *Position++
; 811  : 	{ CNode* pNode = (CNode*) rPosition;
; 812  : 		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 813  : 		rPosition = (POSITION) pNode->pNext;
; 814  : 		return pNode->data; }
; 815  : template<class TYPE, class ARG_TYPE>
; 816  : AFX_INLINE const TYPE& CList<TYPE, ARG_TYPE>::GetNext(POSITION& rPosition) const // return *Position++
; 817  : 	{ CNode* pNode = (CNode*) rPosition;
; 818  : 		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 819  : 		rPosition = (POSITION) pNode->pNext;
; 820  : 		return pNode->data; }
; 821  : template<class TYPE, class ARG_TYPE>
; 822  : AFX_INLINE TYPE& CList<TYPE, ARG_TYPE>::GetPrev(POSITION& rPosition) // return *Position--
; 823  : 	{ CNode* pNode = (CNode*) rPosition;
; 824  : 		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 825  : 		rPosition = (POSITION) pNode->pPrev;
; 826  : 		return pNode->data; }
; 827  : template<class TYPE, class ARG_TYPE>
; 828  : AFX_INLINE const TYPE& CList<TYPE, ARG_TYPE>::GetPrev(POSITION& rPosition) const // return *Position--
; 829  : 	{ CNode* pNode = (CNode*) rPosition;
; 830  : 		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 831  : 		rPosition = (POSITION) pNode->pPrev;
; 832  : 		return pNode->data; }
; 833  : template<class TYPE, class ARG_TYPE>
; 834  : AFX_INLINE TYPE& CList<TYPE, ARG_TYPE>::GetAt(POSITION position)
; 835  : 	{ CNode* pNode = (CNode*) position;
; 836  : 		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 837  : 		return pNode->data; }
; 838  : template<class TYPE, class ARG_TYPE>
; 839  : AFX_INLINE const TYPE& CList<TYPE, ARG_TYPE>::GetAt(POSITION position) const
; 840  : 	{ CNode* pNode = (CNode*) position;
; 841  : 		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 842  : 		return pNode->data; }
; 843  : template<class TYPE, class ARG_TYPE>
; 844  : AFX_INLINE void CList<TYPE, ARG_TYPE>::SetAt(POSITION pos, ARG_TYPE newElement)
; 845  : 	{ CNode* pNode = (CNode*) pos;
; 846  : 		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 847  : 		pNode->data = newElement; }
; 848  : 
; 849  : template<class TYPE, class ARG_TYPE>
; 850  : CList<TYPE, ARG_TYPE>::CList(INT_PTR nBlockSize)
; 851  : {
; 852  : 	ASSERT(nBlockSize > 0);
; 853  : 
; 854  : 	m_nCount = 0;
; 855  : 	m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
; 856  : 	m_pBlocks = NULL;
; 857  : 	m_nBlockSize = nBlockSize;
; 858  : }
; 859  : 
; 860  : template<class TYPE, class ARG_TYPE>
; 861  : void CList<TYPE, ARG_TYPE>::RemoveAll()
; 862  : {
; 863  : 	ASSERT_VALID(this);
; 864  : 
; 865  : 	// destroy elements
; 866  : 	CNode* pNode;
; 867  : 	for (pNode = m_pNodeHead; pNode != NULL; pNode = pNode->pNext)
; 868  : 		pNode->data.~TYPE();
; 869  : 
; 870  : 	m_nCount = 0;
; 871  : 	m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
; 872  : 	m_pBlocks->FreeDataChain();
; 873  : 	m_pBlocks = NULL;
; 874  : }
; 875  : 
; 876  : template<class TYPE, class ARG_TYPE>
; 877  : CList<TYPE, ARG_TYPE>::~CList()
; 878  : {
; 879  : 	RemoveAll();
; 880  : 	ASSERT(m_nCount == 0);
; 881  : }
; 882  : 
; 883  : /*============================================================================*/
; 884  : // Node helpers
; 885  : //
; 886  : // Implementation note: CNode's are stored in CPlex blocks and
; 887  : //  chained together. Free blocks are maintained in a singly linked list
; 888  : //  using the 'pNext' member of CNode with 'm_pNodeFree' as the head.
; 889  : //  Used blocks are maintained in a doubly linked list using both 'pNext'
; 890  : //  and 'pPrev' as links and 'm_pNodeHead' and 'm_pNodeTail'
; 891  : //   as the head/tail.
; 892  : //
; 893  : // We never free a CPlex block unless the List is destroyed or RemoveAll()
; 894  : //  is used - so the total number of CPlex blocks may grow large depending
; 895  : //  on the maximum past size of the list.
; 896  : //
; 897  : 
; 898  : template<class TYPE, class ARG_TYPE>
; 899  : typename CList<TYPE, ARG_TYPE>::CNode*
; 900  : CList<TYPE, ARG_TYPE>::NewNode(CNode* pPrev, CNode* pNext)
; 901  : {
; 902  : 	if (m_pNodeFree == NULL)
; 903  : 	{
; 904  : 		// add another block
; 905  : 		CPlex* pNewBlock = CPlex::Create(m_pBlocks, m_nBlockSize,
; 906  : 				 sizeof(CNode));
; 907  : 
; 908  : 		// chain them into free list
; 909  : 		CNode* pNode = (CNode*) pNewBlock->data();
; 910  : 		// free in reverse order to make it easier to debug
; 911  : 		pNode += m_nBlockSize - 1;
; 912  : 		for (INT_PTR i = m_nBlockSize-1; i >= 0; i--, pNode--)
; 913  : 		{
; 914  : 			pNode->pNext = m_pNodeFree;
; 915  : 			m_pNodeFree = pNode;
; 916  : 		}
; 917  : 	}
; 918  : 	ENSURE(m_pNodeFree != NULL);  // we must have something
; 919  : 
; 920  : 	CList::CNode* pNode = m_pNodeFree;
; 921  : 	m_pNodeFree = m_pNodeFree->pNext;
; 922  : 	pNode->pPrev = pPrev;
; 923  : 	pNode->pNext = pNext;
; 924  : 	m_nCount++;
; 925  : 	ASSERT(m_nCount > 0);  // make sure we don't overflow
; 926  : 
; 927  : #pragma push_macro("new")
; 928  : #undef new
; 929  : 	::new( (void*)( &pNode->data ) ) TYPE;
; 930  : #pragma pop_macro("new")
; 931  : 	return pNode;
; 932  : }
; 933  : 
; 934  : template<class TYPE, class ARG_TYPE>
; 935  : void CList<TYPE, ARG_TYPE>::FreeNode(CNode* pNode)
; 936  : {
; 937  : 	pNode->data.~TYPE();
; 938  : 	pNode->pNext = m_pNodeFree;
; 939  : 	m_pNodeFree = pNode;
; 940  : 	m_nCount--;
; 941  : 	ASSERT(m_nCount >= 0);  // make sure we don't underflow
; 942  : 
; 943  : 	// if no more elements, cleanup completely
; 944  : 	if (m_nCount == 0)
; 945  : 		RemoveAll();
; 946  : }
; 947  : 
; 948  : template<class TYPE, class ARG_TYPE>
; 949  : POSITION CList<TYPE, ARG_TYPE>::AddHead(ARG_TYPE newElement)
; 950  : {
; 951  : 	ASSERT_VALID(this);
; 952  : 
; 953  : 	CNode* pNewNode = NewNode(NULL, m_pNodeHead);
; 954  : 	pNewNode->data = newElement;
; 955  : 	if (m_pNodeHead != NULL)
; 956  : 		m_pNodeHead->pPrev = pNewNode;
; 957  : 	else
; 958  : 		m_pNodeTail = pNewNode;
; 959  : 	m_pNodeHead = pNewNode;
; 960  : 	return (POSITION) pNewNode;
; 961  : }
; 962  : 
; 963  : template<class TYPE, class ARG_TYPE>
; 964  : POSITION CList<TYPE, ARG_TYPE>::AddTail(ARG_TYPE newElement)
; 965  : {
; 966  : 	ASSERT_VALID(this);
; 967  : 
; 968  : 	CNode* pNewNode = NewNode(m_pNodeTail, NULL);
; 969  : 	pNewNode->data = newElement;
; 970  : 	if (m_pNodeTail != NULL)
; 971  : 		m_pNodeTail->pNext = pNewNode;
; 972  : 	else
; 973  : 		m_pNodeHead = pNewNode;
; 974  : 	m_pNodeTail = pNewNode;
; 975  : 	return (POSITION) pNewNode;
; 976  : }
; 977  : 
; 978  : template<class TYPE, class ARG_TYPE>
; 979  : void CList<TYPE, ARG_TYPE>::AddHead(CList* pNewList)
; 980  : {
; 981  : 	ASSERT_VALID(this);
; 982  : 
; 983  : 	ENSURE(pNewList != NULL);
; 984  : 	ASSERT_VALID(pNewList);
; 985  : 
; 986  : 	// add a list of same elements to head (maintain order)
; 987  : 	POSITION pos = pNewList->GetTailPosition();
; 988  : 	while (pos != NULL)
; 989  : 		AddHead(pNewList->GetPrev(pos));
; 990  : }
; 991  : 
; 992  : template<class TYPE, class ARG_TYPE>
; 993  : void CList<TYPE, ARG_TYPE>::AddTail(CList* pNewList)
; 994  : {
; 995  : 	ASSERT_VALID(this);
; 996  : 	ENSURE(pNewList != NULL);
; 997  : 	ASSERT_VALID(pNewList);
; 998  : 
; 999  : 	// add a list of same elements
; 1000 : 	POSITION pos = pNewList->GetHeadPosition();
; 1001 : 	while (pos != NULL)
; 1002 : 		AddTail(pNewList->GetNext(pos));
; 1003 : }
; 1004 : 
; 1005 : template<class TYPE, class ARG_TYPE>
; 1006 : TYPE CList<TYPE, ARG_TYPE>::RemoveHead()
; 1007 : {
; 1008 : 	ASSERT_VALID(this);
; 1009 : 	ENSURE(m_pNodeHead != NULL);  // don't call on empty list !!!
; 1010 : 	ASSERT(AfxIsValidAddress(m_pNodeHead, sizeof(CNode)));
; 1011 : 
; 1012 : 	CNode* pOldNode = m_pNodeHead;
; 1013 : 	TYPE returnValue = pOldNode->data;
; 1014 : 
; 1015 : 	m_pNodeHead = pOldNode->pNext;
; 1016 : 	if (m_pNodeHead != NULL)
; 1017 : 		m_pNodeHead->pPrev = NULL;
; 1018 : 	else
; 1019 : 		m_pNodeTail = NULL;
; 1020 : 	FreeNode(pOldNode);
; 1021 : 	return returnValue;
; 1022 : }
; 1023 : 
; 1024 : template<class TYPE, class ARG_TYPE>
; 1025 : TYPE CList<TYPE, ARG_TYPE>::RemoveTail()
; 1026 : {
; 1027 : 	ASSERT_VALID(this);
; 1028 : 	ENSURE(m_pNodeTail != NULL);  // don't call on empty list !!!
; 1029 : 	ASSERT(AfxIsValidAddress(m_pNodeTail, sizeof(CNode)));
; 1030 : 
; 1031 : 	CNode* pOldNode = m_pNodeTail;
; 1032 : 	TYPE returnValue = pOldNode->data;
; 1033 : 
; 1034 : 	m_pNodeTail = pOldNode->pPrev;
; 1035 : 	if (m_pNodeTail != NULL)
; 1036 : 		m_pNodeTail->pNext = NULL;
; 1037 : 	else
; 1038 : 		m_pNodeHead = NULL;
; 1039 : 	FreeNode(pOldNode);
; 1040 : 	return returnValue;
; 1041 : }
; 1042 : 
; 1043 : template<class TYPE, class ARG_TYPE>
; 1044 : POSITION CList<TYPE, ARG_TYPE>::InsertBefore(POSITION position, ARG_TYPE newElement)
; 1045 : {
; 1046 : 	ASSERT_VALID(this);
; 1047 : 
; 1048 : 	if (position == NULL)
; 1049 : 		return AddHead(newElement); // insert before nothing -> head of the list
; 1050 : 
; 1051 : 	// Insert it before position
; 1052 : 	CNode* pOldNode = (CNode*) position;
; 1053 : 	CNode* pNewNode = NewNode(pOldNode->pPrev, pOldNode);
; 1054 : 	pNewNode->data = newElement;
; 1055 : 
; 1056 : 	if (pOldNode->pPrev != NULL)
; 1057 : 	{
; 1058 : 		ASSERT(AfxIsValidAddress(pOldNode->pPrev, sizeof(CNode)));
; 1059 : 		pOldNode->pPrev->pNext = pNewNode;
; 1060 : 	}
; 1061 : 	else
; 1062 : 	{
; 1063 : 		ASSERT(pOldNode == m_pNodeHead);
; 1064 : 		m_pNodeHead = pNewNode;
; 1065 : 	}
; 1066 : 	pOldNode->pPrev = pNewNode;
; 1067 : 	return (POSITION) pNewNode;
; 1068 : }
; 1069 : 
; 1070 : template<class TYPE, class ARG_TYPE>
; 1071 : POSITION CList<TYPE, ARG_TYPE>::InsertAfter(POSITION position, ARG_TYPE newElement)
; 1072 : {
; 1073 : 	ASSERT_VALID(this);
; 1074 : 
; 1075 : 	if (position == NULL)
; 1076 : 		return AddTail(newElement); // insert after nothing -> tail of the list
; 1077 : 
; 1078 : 	// Insert it before position
; 1079 : 	CNode* pOldNode = (CNode*) position;
; 1080 : 	ASSERT(AfxIsValidAddress(pOldNode, sizeof(CNode)));
; 1081 : 	CNode* pNewNode = NewNode(pOldNode, pOldNode->pNext);
; 1082 : 	pNewNode->data = newElement;
; 1083 : 
; 1084 : 	if (pOldNode->pNext != NULL)
; 1085 : 	{
; 1086 : 		ASSERT(AfxIsValidAddress(pOldNode->pNext, sizeof(CNode)));
; 1087 : 		pOldNode->pNext->pPrev = pNewNode;
; 1088 : 	}
; 1089 : 	else
; 1090 : 	{
; 1091 : 		ASSERT(pOldNode == m_pNodeTail);
; 1092 : 		m_pNodeTail = pNewNode;
; 1093 : 	}
; 1094 : 	pOldNode->pNext = pNewNode;
; 1095 : 	return (POSITION) pNewNode;
; 1096 : }
; 1097 : 
; 1098 : template<class TYPE, class ARG_TYPE>
; 1099 : void CList<TYPE, ARG_TYPE>::RemoveAt(POSITION position)
; 1100 : {
; 1101 : 	ASSERT_VALID(this);
; 1102 : 
; 1103 : 	CNode* pOldNode = (CNode*) position;
; 1104 : 	ASSERT(AfxIsValidAddress(pOldNode, sizeof(CNode)));
; 1105 : 
; 1106 : 	// remove pOldNode from list
; 1107 : 	if (pOldNode == m_pNodeHead)
; 1108 : 	{
; 1109 : 		m_pNodeHead = pOldNode->pNext;
; 1110 : 	}
; 1111 : 	else
; 1112 : 	{
; 1113 : 		ASSERT(AfxIsValidAddress(pOldNode->pPrev, sizeof(CNode)));
; 1114 : 		pOldNode->pPrev->pNext = pOldNode->pNext;
; 1115 : 	}
; 1116 : 	if (pOldNode == m_pNodeTail)
; 1117 : 	{
; 1118 : 		m_pNodeTail = pOldNode->pPrev;
; 1119 : 	}
; 1120 : 	else
; 1121 : 	{
; 1122 : 		ASSERT(AfxIsValidAddress(pOldNode->pNext, sizeof(CNode)));
; 1123 : 		pOldNode->pNext->pPrev = pOldNode->pPrev;
; 1124 : 	}
; 1125 : 	FreeNode(pOldNode);
; 1126 : }
; 1127 : 
; 1128 : template<class TYPE, class ARG_TYPE>
; 1129 : POSITION CList<TYPE, ARG_TYPE>::FindIndex(INT_PTR nIndex) const
; 1130 : {
; 1131 : 	ASSERT_VALID(this);
; 1132 : 
; 1133 : 	if (nIndex >= m_nCount || nIndex < 0)
; 1134 : 		return NULL;  // went too far
; 1135 : 
; 1136 : 	CNode* pNode = m_pNodeHead;
; 1137 : 	while (nIndex--)
; 1138 : 	{
; 1139 : 		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 1140 : 		pNode = pNode->pNext;
; 1141 : 	}
; 1142 : 	return (POSITION) pNode;
; 1143 : }
; 1144 : 
; 1145 : template<class TYPE, class ARG_TYPE>
; 1146 : POSITION CList<TYPE, ARG_TYPE>::Find(ARG_TYPE searchValue, POSITION startAfter) const
; 1147 : {
; 1148 : 	ASSERT_VALID(this);
; 1149 : 
; 1150 : 	CNode* pNode = (CNode*) startAfter;
; 1151 : 	if (pNode == NULL)
; 1152 : 	{
; 1153 : 		pNode = m_pNodeHead;  // start at head
; 1154 : 	}
; 1155 : 	else
; 1156 : 	{
; 1157 : 		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 1158 : 		pNode = pNode->pNext;  // start after the one specified
; 1159 : 	}
; 1160 : 
; 1161 : 	for (; pNode != NULL; pNode = pNode->pNext)
; 1162 : 		if (CompareElements<TYPE>(&pNode->data, &searchValue))
; 1163 : 			return (POSITION)pNode;
; 1164 : 	return NULL;
; 1165 : }
; 1166 : 
; 1167 : template<class TYPE, class ARG_TYPE>
; 1168 : void CList<TYPE, ARG_TYPE>::Serialize(CArchive& ar)
; 1169 : {
; 1170 : 	ASSERT_VALID(this);
; 1171 : 
; 1172 : 	CObject::Serialize(ar);
; 1173 : 
; 1174 : 	if (ar.IsStoring())
; 1175 : 	{
; 1176 : 		ar.WriteCount(m_nCount);
; 1177 : 		for (CNode* pNode = m_pNodeHead; pNode != NULL; pNode = pNode->pNext)
; 1178 : 		{
; 1179 : 			ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 1180 : 			TYPE* pData;
; 1181 : 			/*
; 1182 : 			 * in some cases the & operator might be overloaded, and we cannot use it to obtain
; 1183 : 			 * the address of a given object.  We then use the following trick to get the address
; 1184 : 			 */
; 1185 : 			pData = reinterpret_cast< TYPE* >( &reinterpret_cast< int& >( static_cast< TYPE& >( pNode->data ) ) );
; 1186 : 			SerializeElements<TYPE>(ar, pData, 1);
; 1187 : 		}
; 1188 : 	}
; 1189 : 	else
; 1190 : 	{
; 1191 : 		DWORD_PTR nNewCount = ar.ReadCount();
; 1192 : 		while (nNewCount--)
; 1193 : 		{
; 1194 : 			TYPE newData[1];
; 1195 : 			SerializeElements<TYPE>(ar, newData, 1);
; 1196 : 			AddTail(newData[0]);
; 1197 : 		}
; 1198 : 	}
; 1199 : }
; 1200 : 
; 1201 : #ifdef _DEBUG
; 1202 : template<class TYPE, class ARG_TYPE>
; 1203 : void CList<TYPE, ARG_TYPE>::Dump(CDumpContext& dc) const
; 1204 : {
; 1205 : 	CObject::Dump(dc);
; 1206 : 
; 1207 : 	dc << "with " << m_nCount << " elements";
; 1208 : 	if (dc.GetDepth() > 0)
; 1209 : 	{
; 1210 : 		POSITION pos = GetHeadPosition();
; 1211 : 		while (pos != NULL)
; 1212 : 		{
; 1213 : 			TYPE temp[1];
; 1214 : 			temp[0] = ((CList*)this)->GetNext(pos);
; 1215 : 			dc << "\n";
; 1216 : 			DumpElements<TYPE>(dc, temp, 1);
; 1217 : 		}
; 1218 : 	}
; 1219 : 
; 1220 : 	dc << "\n";
; 1221 : }
; 1222 : 
; 1223 : template<class TYPE, class ARG_TYPE>
; 1224 : void CList<TYPE, ARG_TYPE>::AssertValid() const
; 1225 : {
; 1226 : 	CObject::AssertValid();
; 1227 : 
; 1228 : 	if (m_nCount == 0)
; 1229 : 	{
; 1230 : 		// empty list
; 1231 : 		ASSERT(m_pNodeHead == NULL);
; 1232 : 		ASSERT(m_pNodeTail == NULL);
; 1233 : 	}
; 1234 : 	else
; 1235 : 	{
; 1236 : 		// non-empty list
; 1237 : 		ASSERT(AfxIsValidAddress(m_pNodeHead, sizeof(CNode)));
; 1238 : 		ASSERT(AfxIsValidAddress(m_pNodeTail, sizeof(CNode)));
; 1239 : 	}
; 1240 : }
; 1241 : #endif //_DEBUG
; 1242 : 
; 1243 : /*============================================================================*/
; 1244 : // CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>
; 1245 : 
; 1246 : template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
; 1247 : class CMap : public CObject
; 1248 : {
; 1249 : public:
; 1250 : 	// CPair
; 1251 : 	struct CPair
; 1252 : 	{
; 1253 : 		const KEY key;
; 1254 : 		VALUE value;
; 1255 : 	protected:
; 1256 : 		CPair( ARG_KEY keyval ) : key( keyval )	{}
; 1257 : 	};
; 1258 : 
; 1259 : protected:
; 1260 : 	// Association
; 1261 : 	class CAssoc : public CPair
; 1262 : 	{
; 1263 : 		friend class CMap<KEY,ARG_KEY,VALUE,ARG_VALUE>;
; 1264 : 		CAssoc* pNext;
; 1265 : 		UINT nHashValue;  // needed for efficient iteration
; 1266 : 	public:
; 1267 : 		CAssoc( ARG_KEY key ) : CPair( key ) {}
; 1268 : 	};
; 1269 : 
; 1270 : public:
; 1271 : // Construction
; 1272 : 	explicit CMap(INT_PTR nBlockSize = 10);
; 1273 : 
; 1274 : // Attributes
; 1275 : 	// number of elements
; 1276 : 	INT_PTR GetCount() const;
; 1277 : 	INT_PTR GetSize() const;
; 1278 : 	BOOL IsEmpty() const;
; 1279 : 
; 1280 : 	// Lookup
; 1281 : 	BOOL Lookup(ARG_KEY key, VALUE& rValue) const;
; 1282 : 	const CPair *PLookup(ARG_KEY key) const;
; 1283 : 	CPair *PLookup(ARG_KEY key);
; 1284 : 
; 1285 : // Operations
; 1286 : 	// Lookup and add if not there
; 1287 : 	VALUE& operator[](ARG_KEY key);
; 1288 : 
; 1289 : 	// add a new (key, value) pair
; 1290 : 	void SetAt(ARG_KEY key, ARG_VALUE newValue);
; 1291 : 
; 1292 : 	// removing existing (key, ?) pair
; 1293 : 	BOOL RemoveKey(ARG_KEY key);
; 1294 : 	void RemoveAll();
; 1295 : 
; 1296 : 	// iterating all (key, value) pairs
; 1297 : 	POSITION GetStartPosition() const;
; 1298 : 
; 1299 : 	const CPair *PGetFirstAssoc() const;
; 1300 : 	CPair *PGetFirstAssoc();
; 1301 : 
; 1302 : 	void GetNextAssoc(POSITION& rNextPosition, KEY& rKey, VALUE& rValue) const;
; 1303 : 
; 1304 : 	const CPair *PGetNextAssoc(const CPair *pAssocRet) const;
; 1305 : 	CPair *PGetNextAssoc(const CPair *pAssocRet);
; 1306 : 
; 1307 : 	// advanced features for derived classes
; 1308 : 	UINT GetHashTableSize() const;
; 1309 : 	void InitHashTable(UINT hashSize, BOOL bAllocNow = TRUE);
; 1310 : 
; 1311 : // Implementation
; 1312 : protected:
; 1313 : 	CAssoc** m_pHashTable;
; 1314 : 	UINT m_nHashTableSize;
; 1315 : 	INT_PTR m_nCount;
; 1316 : 	CAssoc* m_pFreeList;
; 1317 : 	struct CPlex* m_pBlocks;
; 1318 : 	INT_PTR m_nBlockSize;
; 1319 : 
; 1320 : 	CAssoc* NewAssoc(ARG_KEY key);
; 1321 : 	void FreeAssoc(CAssoc*);
; 1322 : 	CAssoc* GetAssocAt(ARG_KEY, UINT&, UINT&) const;
; 1323 : 
; 1324 : public:
; 1325 : 	~CMap();
; 1326 : 	void Serialize(CArchive&);
; 1327 : #ifdef _DEBUG
; 1328 : 	void Dump(CDumpContext&) const;
; 1329 : 	void AssertValid() const;
; 1330 : #endif
; 1331 : };
; 1332 : 
; 1333 : /*============================================================================*/
; 1334 : // CMap<KEY, ARG_KEY, VALUE, ARG_VALUE> inline functions
; 1335 : 
; 1336 : template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
; 1337 : AFX_INLINE INT_PTR CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetCount() const
; 1338 : 	{ return m_nCount; }
; 1339 : 
; 1340 : template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
; 1341 : AFX_INLINE INT_PTR CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetSize() const
; 1342 : 	{ return m_nCount; }
; 1343 : 
; 1344 : template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
; 1345 : AFX_INLINE BOOL CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::IsEmpty() const
; 1346 : 	{ return m_nCount == 0; }
; 1347 : 
; 1348 : template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
; 1349 : AFX_INLINE void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::SetAt(ARG_KEY key, ARG_VALUE newValue)
; 1350 : 	{ (*this)[key] = newValue; }
; 1351 : 
; 1352 : template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
; 1353 : AFX_INLINE POSITION CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetStartPosition() const
; 1354 : 	{ return (m_nCount == 0) ? NULL : BEFORE_START_POSITION; }
; 1355 : 
; 1356 : template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
; 1357 : const typename CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CPair* CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::PGetFirstAssoc() const
; 1358 : {
; 1359 : 	ASSERT_VALID(this);
; 1360 : 	if(m_nCount == 0) return NULL;
; 1361 : 
; 1362 : 	AFXASSUME(m_pHashTable != NULL);  // never call on empty map
; 1363 : 
; 1364 : 	CAssoc* pAssocRet = (CAssoc*)BEFORE_START_POSITION;
; 1365 : 
; 1366 : 	// find the first association
; 1367 : 	for (UINT nBucket = 0; nBucket < m_nHashTableSize; nBucket++)
; 1368 : 		if ((pAssocRet = m_pHashTable[nBucket]) != NULL)
; 1369 : 			break;
; 1370 : 	ASSERT(pAssocRet != NULL);  // must find something
; 1371 : 
; 1372 : 	return pAssocRet;
; 1373 : }
; 1374 : 
; 1375 : template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
; 1376 : typename CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CPair* CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::PGetFirstAssoc()
; 1377 : {
; 1378 : 	ASSERT_VALID(this);
; 1379 : 	if(m_nCount == 0) return NULL;
; 1380 : 
; 1381 : 	AFXASSUME(m_pHashTable != NULL);  // never call on empty map
; 1382 : 
; 1383 : 	CAssoc* pAssocRet = (CAssoc*)BEFORE_START_POSITION;
; 1384 : 
; 1385 : 	// find the first association
; 1386 : 	for (UINT nBucket = 0; nBucket < m_nHashTableSize; nBucket++)
; 1387 : 		if ((pAssocRet = m_pHashTable[nBucket]) != NULL)
; 1388 : 			break;
; 1389 : 	ASSERT(pAssocRet != NULL);  // must find something
; 1390 : 
; 1391 : 	return pAssocRet;
; 1392 : }
; 1393 : 
; 1394 : template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
; 1395 : AFX_INLINE UINT CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetHashTableSize() const
; 1396 : 	{ return m_nHashTableSize; }
; 1397 : 
; 1398 : /*============================================================================*/
; 1399 : // CMap<KEY, ARG_KEY, VALUE, ARG_VALUE> out-of-line functions
; 1400 : 
; 1401 : template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
; 1402 : CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CMap(INT_PTR nBlockSize)
; 1403 : {
; 1404 : 	ASSERT(nBlockSize > 0);
; 1405 : 
; 1406 : 	m_pHashTable = NULL;
; 1407 : 	m_nHashTableSize = 17;  // default size
; 1408 : 	m_nCount = 0;
; 1409 : 	m_pFreeList = NULL;
; 1410 : 	m_pBlocks = NULL;
; 1411 : 	m_nBlockSize = nBlockSize;
; 1412 : }
; 1413 : 
; 1414 : template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
; 1415 : void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::InitHashTable(
; 1416 : 	UINT nHashSize, BOOL bAllocNow)
; 1417 : //
; 1418 : // Used to force allocation of a hash table or to override the default
; 1419 : //   hash table size of (which is fairly small)
; 1420 : {
; 1421 : 	ASSERT_VALID(this);
; 1422 : 	ASSERT(m_nCount == 0);
; 1423 : 	ASSERT(nHashSize > 0);
; 1424 : 
; 1425 : 	if (m_pHashTable != NULL)
; 1426 : 	{
; 1427 : 		// free hash table
; 1428 : 		delete[] m_pHashTable;
; 1429 : 		m_pHashTable = NULL;
; 1430 : 	}
; 1431 : 
; 1432 : 	if (bAllocNow)
; 1433 : 	{
; 1434 : 		m_pHashTable = new CAssoc* [nHashSize];
; 1435 : 		ENSURE(m_pHashTable != NULL);
; 1436 : 		memset(m_pHashTable, 0, sizeof(CAssoc*) * nHashSize);
; 1437 : 	}
; 1438 : 	m_nHashTableSize = nHashSize;
; 1439 : }
; 1440 : 
; 1441 : template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
; 1442 : void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::RemoveAll()
; 1443 : {
; 1444 : 	ASSERT_VALID(this);
; 1445 : 
; 1446 : 	if (m_pHashTable != NULL)
; 1447 : 	{
; 1448 : 		// destroy elements (values and keys)
; 1449 : 		for (UINT nHash = 0; nHash < m_nHashTableSize; nHash++)
; 1450 : 		{
; 1451 : 			CAssoc* pAssoc;
; 1452 : 			for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL;
; 1453 : 			  pAssoc = pAssoc->pNext)
; 1454 : 			{
; 1455 : 				pAssoc->CAssoc::~CAssoc();
; 1456 : 			}
; 1457 : 		}
; 1458 : 
; 1459 : 		// free hash table
; 1460 : 		delete[] m_pHashTable;
; 1461 : 		m_pHashTable = NULL;
; 1462 : 	}
; 1463 : 
; 1464 : 	m_nCount = 0;
; 1465 : 	m_pFreeList = NULL;
; 1466 : 	m_pBlocks->FreeDataChain();
; 1467 : 	m_pBlocks = NULL;
; 1468 : }
; 1469 : 
; 1470 : template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
; 1471 : CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::~CMap()
; 1472 : {
; 1473 : 	RemoveAll();
; 1474 : 	ASSERT(m_nCount == 0);
; 1475 : }
; 1476 : 
; 1477 : template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
; 1478 : typename CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CAssoc*
; 1479 : CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::NewAssoc(ARG_KEY key)
; 1480 : {
; 1481 : 	if (m_pFreeList == NULL)
; 1482 : 	{
; 1483 : 		// add another block
; 1484 : 		CPlex* newBlock = CPlex::Create(m_pBlocks, m_nBlockSize, sizeof(CMap::CAssoc));
; 1485 : 		// chain them into free list
; 1486 : 		CMap::CAssoc* pAssoc = (CMap::CAssoc*) newBlock->data();
; 1487 : 		// free in reverse order to make it easier to debug
; 1488 : 		pAssoc += m_nBlockSize - 1;
; 1489 : 		for (INT_PTR i = m_nBlockSize-1; i >= 0; i--, pAssoc--)
; 1490 : 		{
; 1491 : 			pAssoc->pNext = m_pFreeList;
; 1492 : 			m_pFreeList = pAssoc;
; 1493 : 		}
; 1494 : 	}
; 1495 : 	ENSURE(m_pFreeList != NULL);  // we must have something
; 1496 : 
; 1497 : 	CMap::CAssoc* pAssoc = m_pFreeList;
; 1498 : 
; 1499 : 	// zero the memory
; 1500 : 	CMap::CAssoc* pTemp = pAssoc->pNext;
; 1501 : 	memset( pAssoc, 0, sizeof(CMap::CAssoc) );
; 1502 : 	pAssoc->pNext = pTemp;
; 1503 : 
; 1504 : 	m_pFreeList = m_pFreeList->pNext;
; 1505 : 	m_nCount++;
; 1506 : 	ASSERT(m_nCount > 0);  // make sure we don't overflow
; 1507 : #pragma push_macro("new")
; 1508 : #undef new
; 1509 : 	::new(pAssoc) CMap::CAssoc(key);
; 1510 : #pragma pop_macro("new")
; 1511 : 	return pAssoc;
; 1512 : }
; 1513 : 
; 1514 : template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
; 1515 : void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::FreeAssoc(CAssoc* pAssoc)
; 1516 : {
; 1517 : 	pAssoc->CAssoc::~CAssoc();
; 1518 : 	pAssoc->pNext = m_pFreeList;
; 1519 : 	m_pFreeList = pAssoc;
; 1520 : 	m_nCount--;
; 1521 : 	ASSERT(m_nCount >= 0);  // make sure we don't underflow
; 1522 : 
; 1523 : 	// if no more elements, cleanup completely
; 1524 : 	if (m_nCount == 0)
; 1525 : 		RemoveAll();
; 1526 : }
; 1527 : 
; 1528 : template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
; 1529 : typename CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CAssoc*
; 1530 : CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetAssocAt(ARG_KEY key, UINT& nHashBucket, UINT& nHashValue) const
; 1531 : // find association (or return NULL)
; 1532 : {
; 1533 : 	nHashValue = HashKey<ARG_KEY>(key);
; 1534 : 	nHashBucket = nHashValue % m_nHashTableSize;

  000a6	8b 5d 0c	 mov	 ebx, DWORD PTR _mapList$[ebp]
  000a9	33 d2		 xor	 edx, edx
  000ab	8b c6		 mov	 eax, esi
  000ad	f7 73 08	 div	 DWORD PTR [ebx+8]

; 1537 : 		return NULL;
; 1538 : 
; 1539 : 	// see if it exists
; 1540 : 	CAssoc* pAssoc;
; 1541 : 	for (pAssoc = m_pHashTable[nHashBucket]; pAssoc != NULL; pAssoc = pAssoc->pNext)

  000b0	8b 5d ec	 mov	 ebx, DWORD PTR _key$1$[ebp]
  000b3	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  000b6	85 c0		 test	 eax, eax
  000b8	74 25		 je	 SHORT $LN50@FillAvaila
  000ba	66 0f 1f 44 00
	00		 npad	 6
$LL19@FillAvaila:

; 1542 : 	{
; 1543 : 		if (pAssoc->nHashValue == nHashValue && CompareElements(&pAssoc->key, &key))

  000c0	39 70 0c	 cmp	 DWORD PTR [eax+12], esi
  000c3	75 04		 jne	 SHORT $LN17@FillAvaila

; 156  : 	return *pElement1 == *pElement2;

  000c5	39 18		 cmp	 DWORD PTR [eax], ebx

; 1543 : 		if (pAssoc->nHashValue == nHashValue && CompareElements(&pAssoc->key, &key))

  000c7	74 09		 je	 SHORT $LN16@FillAvaila
$LN17@FillAvaila:

; 1537 : 		return NULL;
; 1538 : 
; 1539 : 	// see if it exists
; 1540 : 	CAssoc* pAssoc;
; 1541 : 	for (pAssoc = m_pHashTable[nHashBucket]; pAssoc != NULL; pAssoc = pAssoc->pNext)

  000c9	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000cc	85 c0		 test	 eax, eax
  000ce	75 f0		 jne	 SHORT $LL19@FillAvaila
  000d0	eb 0d		 jmp	 SHORT $LN50@FillAvaila
$LN16@FillAvaila:

; 1559 : 	rValue = pAssoc->value;

  000d2	83 c0 04	 add	 eax, 4
  000d5	8d 4d f0	 lea	 ecx, DWORD PTR _strFieldName$[ebp]
  000d8	50		 push	 eax
  000d9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
$LN50@FillAvaila:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl

; 725  : 	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_ADDSTRING, 0, (LPARAM)lpszItem); }

  000df	ff 75 f0	 push	 DWORD PTR _strFieldName$[ebp]
  000e2	8b 45 e8	 mov	 eax, DWORD PTR _this$1$[ebp]
  000e5	6a 00		 push	 0
  000e7	68 80 01 00 00	 push	 384			; 00000180H
  000ec	ff b0 e8 01 00
	00		 push	 DWORD PTR [eax+488]
  000f2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 418  : 	for(int i=0; i< arrayList.GetSize(); i++)

  000f8	8b 4d 08	 mov	 ecx, DWORD PTR _arrayList$[ebp]
  000fb	47		 inc	 edi
  000fc	be 1d f3 01 00	 mov	 esi, 127773		; 0001f31dH
  00101	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00104	3b f8		 cmp	 edi, eax
  00106	0f 8c 5b ff ff
	ff		 jl	 $LL4@FillAvaila
$LN3@FillAvaila:

; 424  : }

  0010c	8d 4d f0	 lea	 ecx, DWORD PTR _strFieldName$[ebp]
  0010f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00115	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00118	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0011f	59		 pop	 ecx
  00120	5f		 pop	 edi
  00121	5e		 pop	 esi
  00122	5b		 pop	 ebx
  00123	8b e5		 mov	 esp, ebp
  00125	5d		 pop	 ebp
  00126	c2 08 00	 ret	 8
$LN10@FillAvaila:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 290  : 	AfxThrowInvalidArgException();

  00129	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN52@FillAvaila:
  0012e	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?FillAvailableList@CDlgSettingToolBar@@AAEXAAV?$CArray@HH@@AAV?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@@Z$0:
  00000	8d 4d f0	 lea	 ecx, DWORD PTR _strFieldName$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
  0000d	cc		 int	 3
__ehhandler$?FillAvailableList@CDlgSettingToolBar@@AAEXAAV?$CArray@HH@@AAV?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@@Z:
  0000e	90		 npad	 1
  0000f	90		 npad	 1
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?FillAvailableList@CDlgSettingToolBar@@AAEXAAV?$CArray@HH@@AAV?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@@Z
  00026	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?FillAvailableList@CDlgSettingToolBar@@AAEXAAV?$CArray@HH@@AAV?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@@Z ENDP ; CDlgSettingToolBar::FillAvailableList
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
;	COMDAT ?FillShowList@CDlgSettingToolBar@@AAEXAAV?$CArray@HH@@AAV?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@@Z
_TEXT	SEGMENT
_this$1$ = -24						; size = 4
_key$1$ = -20						; size = 4
_strFieldName$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_arrayList$ = 8						; size = 4
_mapList$ = 12						; size = 4
?FillShowList@CDlgSettingToolBar@@AAEXAAV?$CArray@HH@@AAV?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@@Z PROC ; CDlgSettingToolBar::FillShowList, COMDAT
; _this$ = ecx

; 390  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?FillShowList@CDlgSettingToolBar@@AAEXAAV?$CArray@HH@@AAV?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b d9		 mov	 ebx, ecx
  0002a	89 5d e8	 mov	 DWORD PTR _this$1$[ebp], ebx

; 392  : 	CString strFieldName;

  0002d	8d 4d f0	 lea	 ecx, DWORD PTR _strFieldName$[ebp]
  00030	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl

; 731  : 	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, LB_RESETCONTENT, 0, 0); }

  00036	6a 00		 push	 0
  00038	6a 00		 push	 0
  0003a	68 84 01 00 00	 push	 388			; 00000184H
  0003f	ff b3 68 01 00
	00		 push	 DWORD PTR [ebx+360]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 392  : 	CString strFieldName;

  00045	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl

; 731  : 	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, LB_RESETCONTENT, 0, 0); }

  0004c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 395  : 	for(int i=0; i< arrayList.GetSize(); i++)

  00052	8b 4d 08	 mov	 ecx, DWORD PTR _arrayList$[ebp]
  00055	33 ff		 xor	 edi, edi
  00057	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0005a	85 c0		 test	 eax, eax
  0005c	0f 8e aa 00 00
	00		 jle	 $LN3@FillShowLi
  00062	be 1d f3 01 00	 mov	 esi, 127773		; 0001f31dH
$LL4@FillShowLi:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 288  : 	if(nIndex >= 0 && nIndex < m_nSize)

  00067	85 ff		 test	 edi, edi
  00069	0f 88 df 00 00
	00		 js	 $LN11@FillShowLi
  0006f	3b f8		 cmp	 edi, eax
  00071	0f 8d d7 00 00
	00		 jge	 $LN11@FillShowLi

; 1555 : 	CAssoc* pAssoc = GetAssocAt(key, nHashBucket, nHashValue);

  00077	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0007a	8b 1c b8	 mov	 ebx, DWORD PTR [eax+edi*4]

; 165  : 	ldiv_t HashVal = ldiv((long)(ARG_KEY)key, 127773);

  0007d	8b c3		 mov	 eax, ebx
  0007f	99		 cdq
  00080	f7 fe		 idiv	 esi

; 1555 : 	CAssoc* pAssoc = GetAssocAt(key, nHashBucket, nHashValue);

  00082	89 5d ec	 mov	 DWORD PTR _key$1$[ebp], ebx

; 166  : 	HashVal.rem = 16807 * HashVal.rem - 2836 * HashVal.quot;

  00085	69 c0 14 0b 00
	00		 imul	 eax, eax, 2836
  0008b	69 ca a7 41 00
	00		 imul	 ecx, edx, 16807
  00091	2b c8		 sub	 ecx, eax

; 1536 : 	if (m_pHashTable == NULL)

  00093	8b 45 0c	 mov	 eax, DWORD PTR _mapList$[ebp]
  00096	8d b1 ff ff ff
	7f		 lea	 esi, DWORD PTR [ecx+2147483647]
  0009c	0f 49 f1	 cmovns	 esi, ecx
  0009f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000a2	85 c9		 test	 ecx, ecx
  000a4	74 39		 je	 SHORT $LN51@FillShowLi

; 291  : }
; 292  : template<class TYPE, class ARG_TYPE>
; 293  : AFX_INLINE const TYPE& CArray<TYPE, ARG_TYPE>::GetAt(INT_PTR nIndex) const
; 294  : {
; 295  : 	ASSERT(nIndex >= 0 && nIndex < m_nSize);
; 296  : 	if(nIndex >= 0 && nIndex < m_nSize)
; 297  : 		return m_pData[nIndex];
; 298  : 	AfxThrowInvalidArgException();
; 299  : }
; 300  : template<class TYPE, class ARG_TYPE>
; 301  : AFX_INLINE void CArray<TYPE, ARG_TYPE>::SetAt(INT_PTR nIndex, ARG_TYPE newElement)
; 302  : {
; 303  : 	ASSERT(nIndex >= 0 && nIndex < m_nSize);
; 304  : 	if(nIndex >= 0 && nIndex < m_nSize)
; 305  : 		m_pData[nIndex] = newElement;
; 306  : 	else
; 307  : 		AfxThrowInvalidArgException();
; 308  : }
; 309  : template<class TYPE, class ARG_TYPE>
; 310  : AFX_INLINE const TYPE& CArray<TYPE, ARG_TYPE>::ElementAt(INT_PTR nIndex) const
; 311  : {
; 312  : 	ASSERT(nIndex >= 0 && nIndex < m_nSize);
; 313  : 	if(nIndex >= 0 && nIndex < m_nSize)
; 314  : 		return m_pData[nIndex];
; 315  : 	AfxThrowInvalidArgException();
; 316  : }
; 317  : template<class TYPE, class ARG_TYPE>
; 318  : AFX_INLINE TYPE& CArray<TYPE, ARG_TYPE>::ElementAt(INT_PTR nIndex)
; 319  : {
; 320  : 	ASSERT(nIndex >= 0 && nIndex < m_nSize);
; 321  : 	if(nIndex >= 0 && nIndex < m_nSize)
; 322  : 		return m_pData[nIndex];
; 323  : 	AfxThrowInvalidArgException();
; 324  : }
; 325  : template<class TYPE, class ARG_TYPE>
; 326  : AFX_INLINE const TYPE* CArray<TYPE, ARG_TYPE>::GetData() const
; 327  : 	{ return (const TYPE*)m_pData; }
; 328  : template<class TYPE, class ARG_TYPE>
; 329  : AFX_INLINE TYPE* CArray<TYPE, ARG_TYPE>::GetData()
; 330  : 	{ return (TYPE*)m_pData; }
; 331  : template<class TYPE, class ARG_TYPE>
; 332  : AFX_INLINE INT_PTR CArray<TYPE, ARG_TYPE>::Add(ARG_TYPE newElement)
; 333  : 	{ INT_PTR nIndex = m_nSize;
; 334  : 		SetAtGrow(nIndex, newElement);
; 335  : 		return nIndex; }
; 336  : template<class TYPE, class ARG_TYPE>
; 337  : AFX_INLINE const TYPE& CArray<TYPE, ARG_TYPE>::operator[](INT_PTR nIndex) const
; 338  : 	{ return GetAt(nIndex); }
; 339  : template<class TYPE, class ARG_TYPE>
; 340  : AFX_INLINE TYPE& CArray<TYPE, ARG_TYPE>::operator[](INT_PTR nIndex)
; 341  : 	{ return ElementAt(nIndex); }
; 342  : 
; 343  : /*============================================================================*/
; 344  : // CArray<TYPE, ARG_TYPE> out-of-line functions
; 345  : 
; 346  : template<class TYPE, class ARG_TYPE>
; 347  : CArray<TYPE, ARG_TYPE>::CArray()
; 348  : {
; 349  : 	m_pData = NULL;
; 350  : 	m_nSize = m_nMaxSize = m_nGrowBy = 0;
; 351  : }
; 352  : 
; 353  : template<class TYPE, class ARG_TYPE>
; 354  : CArray<TYPE, ARG_TYPE>::~CArray()
; 355  : {
; 356  : 	ASSERT_VALID(this);
; 357  : 
; 358  : 	if (m_pData != NULL)
; 359  : 	{
; 360  : 		for( int i = 0; i < m_nSize; i++ )
; 361  : 			(m_pData + i)->~TYPE();
; 362  : 		delete[] (BYTE*)m_pData;
; 363  : 	}
; 364  : }
; 365  : 
; 366  : template<class TYPE, class ARG_TYPE>
; 367  : void CArray<TYPE, ARG_TYPE>::SetSize(INT_PTR nNewSize, INT_PTR nGrowBy)
; 368  : {
; 369  : 	ASSERT_VALID(this);
; 370  : 	ASSERT(nNewSize >= 0);
; 371  : 
; 372  : 	if(nNewSize < 0 )
; 373  : 		AfxThrowInvalidArgException();
; 374  : 
; 375  : 	if (nGrowBy >= 0)
; 376  : 		m_nGrowBy = nGrowBy;  // set new size
; 377  : 
; 378  : 	if (nNewSize == 0)
; 379  : 	{
; 380  : 		// shrink to nothing
; 381  : 		if (m_pData != NULL)
; 382  : 		{
; 383  : 			for( int i = 0; i < m_nSize; i++ )
; 384  : 				(m_pData + i)->~TYPE();
; 385  : 			delete[] (BYTE*)m_pData;
; 386  : 			m_pData = NULL;
; 387  : 		}
; 388  : 		m_nSize = m_nMaxSize = 0;
; 389  : 	}
; 390  : 	else if (m_pData == NULL)
; 391  : 	{
; 392  : 		// create buffer big enough to hold number of requested elements or
; 393  : 		// m_nGrowBy elements, whichever is larger.
; 394  : #ifdef SIZE_T_MAX
; 395  : 		ASSERT(nNewSize <= SIZE_T_MAX/sizeof(TYPE));    // no overflow
; 396  : #endif
; 397  : 		size_t nAllocSize = __max(nNewSize, m_nGrowBy);
; 398  : 		m_pData = (TYPE*) new BYTE[(size_t)nAllocSize * sizeof(TYPE)];
; 399  : 		memset((void*)m_pData, 0, (size_t)nAllocSize * sizeof(TYPE));
; 400  : 		for( int i = 0; i < nNewSize; i++ )
; 401  : #pragma push_macro("new")
; 402  : #undef new
; 403  : 			::new( (void*)( m_pData + i ) ) TYPE;
; 404  : #pragma pop_macro("new")
; 405  : 		m_nSize = nNewSize;
; 406  : 		m_nMaxSize = nAllocSize;
; 407  : 	}
; 408  : 	else if (nNewSize <= m_nMaxSize)
; 409  : 	{
; 410  : 		// it fits
; 411  : 		if (nNewSize > m_nSize)
; 412  : 		{
; 413  : 			// initialize the new elements
; 414  : 			memset((void*)(m_pData + m_nSize), 0, (size_t)(nNewSize-m_nSize) * sizeof(TYPE));
; 415  : 			for( int i = 0; i < nNewSize-m_nSize; i++ )
; 416  : #pragma push_macro("new")
; 417  : #undef new
; 418  : 				::new( (void*)( m_pData + m_nSize + i ) ) TYPE;
; 419  : #pragma pop_macro("new")
; 420  : 		}
; 421  : 		else if (m_nSize > nNewSize)
; 422  : 		{
; 423  : 			// destroy the old elements
; 424  : 			for( int i = 0; i < m_nSize-nNewSize; i++ )
; 425  : 				(m_pData + nNewSize + i)->~TYPE();
; 426  : 		}
; 427  : 		m_nSize = nNewSize;
; 428  : 	}
; 429  : 	else
; 430  : 	{
; 431  : 		// otherwise, grow array
; 432  : 		nGrowBy = m_nGrowBy;
; 433  : 		if (nGrowBy == 0)
; 434  : 		{
; 435  : 			// heuristically determine growth when nGrowBy == 0
; 436  : 			//  (this avoids heap fragmentation in many situations)
; 437  : 			nGrowBy = m_nSize / 8;
; 438  : 			nGrowBy = (nGrowBy < 4) ? 4 : ((nGrowBy > 1024) ? 1024 : nGrowBy);
; 439  : 		}
; 440  : 		INT_PTR nNewMax;
; 441  : 		if (nNewSize < m_nMaxSize + nGrowBy)
; 442  : 			nNewMax = m_nMaxSize + nGrowBy;  // granularity
; 443  : 		else
; 444  : 			nNewMax = nNewSize;  // no slush
; 445  : 
; 446  : 		ASSERT(nNewMax >= m_nMaxSize);  // no wrap around
; 447  : 
; 448  : 		if(nNewMax  < m_nMaxSize)
; 449  : 			AfxThrowInvalidArgException();
; 450  : 
; 451  : #ifdef SIZE_T_MAX
; 452  : 		ASSERT(nNewMax <= SIZE_T_MAX/sizeof(TYPE)); // no overflow
; 453  : #endif
; 454  : 		TYPE* pNewData = (TYPE*) new BYTE[(size_t)nNewMax * sizeof(TYPE)];
; 455  : 
; 456  : 		// copy new data from old
; 457  : 		::ATL::Checked::memcpy_s(pNewData, (size_t)nNewMax * sizeof(TYPE),
; 458  : 			m_pData, (size_t)m_nSize * sizeof(TYPE));
; 459  : 
; 460  : 		// construct remaining elements
; 461  : 		ASSERT(nNewSize > m_nSize);
; 462  : 		memset((void*)(pNewData + m_nSize), 0, (size_t)(nNewSize-m_nSize) * sizeof(TYPE));
; 463  : 		for( int i = 0; i < nNewSize-m_nSize; i++ )
; 464  : #pragma push_macro("new")
; 465  : #undef new
; 466  : 			::new( (void*)( pNewData + m_nSize + i ) ) TYPE;
; 467  : #pragma pop_macro("new")
; 468  : 
; 469  : 		// get rid of old stuff (note: no destructors called)
; 470  : 		delete[] (BYTE*)m_pData;
; 471  : 		m_pData = pNewData;
; 472  : 		m_nSize = nNewSize;
; 473  : 		m_nMaxSize = nNewMax;
; 474  : 	}
; 475  : }
; 476  : 
; 477  : template<class TYPE, class ARG_TYPE>
; 478  : INT_PTR CArray<TYPE, ARG_TYPE>::Append(const CArray& src)
; 479  : {
; 480  : 	ASSERT_VALID(this);
; 481  : 	ASSERT(this != &src);   // cannot append to itself
; 482  : 
; 483  : 	if(this == &src)
; 484  : 		AfxThrowInvalidArgException();
; 485  : 
; 486  : 	INT_PTR nOldSize = m_nSize;
; 487  : 	SetSize(m_nSize + src.m_nSize);
; 488  : 	CopyElements<TYPE>(m_pData + nOldSize, src.m_pData, src.m_nSize);
; 489  : 	return nOldSize;
; 490  : }
; 491  : 
; 492  : template<class TYPE, class ARG_TYPE>
; 493  : void CArray<TYPE, ARG_TYPE>::Copy(const CArray& src)
; 494  : {
; 495  : 	ASSERT_VALID(this);
; 496  : 	ASSERT(this != &src);   // cannot append to itself
; 497  : 
; 498  : 	if(this != &src)
; 499  : 	{
; 500  : 		SetSize(src.m_nSize);
; 501  : 		CopyElements<TYPE>(m_pData, src.m_pData, src.m_nSize);
; 502  : 	}
; 503  : }
; 504  : 
; 505  : template<class TYPE, class ARG_TYPE>
; 506  : void CArray<TYPE, ARG_TYPE>::FreeExtra()
; 507  : {
; 508  : 	ASSERT_VALID(this);
; 509  : 
; 510  : 	if (m_nSize != m_nMaxSize)
; 511  : 	{
; 512  : 		// shrink to desired size
; 513  : #ifdef SIZE_T_MAX
; 514  : 		ASSERT(m_nSize <= SIZE_T_MAX/sizeof(TYPE)); // no overflow
; 515  : #endif
; 516  : 		TYPE* pNewData = NULL;
; 517  : 		if (m_nSize != 0)
; 518  : 		{
; 519  : 			pNewData = (TYPE*) new BYTE[m_nSize * sizeof(TYPE)];
; 520  : 			// copy new data from old
; 521  : 			::ATL::Checked::memcpy_s(pNewData, m_nSize * sizeof(TYPE),
; 522  : 				m_pData, m_nSize * sizeof(TYPE));
; 523  : 		}
; 524  : 
; 525  : 		// get rid of old stuff (note: no destructors called)
; 526  : 		delete[] (BYTE*)m_pData;
; 527  : 		m_pData = pNewData;
; 528  : 		m_nMaxSize = m_nSize;
; 529  : 	}
; 530  : }
; 531  : 
; 532  : template<class TYPE, class ARG_TYPE>
; 533  : void CArray<TYPE, ARG_TYPE>::SetAtGrow(INT_PTR nIndex, ARG_TYPE newElement)
; 534  : {
; 535  : 	ASSERT_VALID(this);
; 536  : 	ASSERT(nIndex >= 0);
; 537  : 
; 538  : 	if(nIndex < 0)
; 539  : 		AfxThrowInvalidArgException();
; 540  : 
; 541  : 	if (nIndex >= m_nSize)
; 542  : 		SetSize(nIndex+1, -1);
; 543  : 	m_pData[nIndex] = newElement;
; 544  : }
; 545  : 
; 546  : template<class TYPE, class ARG_TYPE>
; 547  : void CArray<TYPE, ARG_TYPE>::InsertAt(INT_PTR nIndex, ARG_TYPE newElement, INT_PTR nCount /*=1*/)
; 548  : {
; 549  : 	ASSERT_VALID(this);
; 550  : 	ASSERT(nIndex >= 0);    // will expand to meet need
; 551  : 	ASSERT(nCount > 0);     // zero or negative size not allowed
; 552  : 
; 553  : 	if(nIndex < 0 || nCount <= 0)
; 554  : 		AfxThrowInvalidArgException();
; 555  : 
; 556  : 	if (nIndex >= m_nSize)
; 557  : 	{
; 558  : 		// adding after the end of the array
; 559  : 		SetSize(nIndex + nCount, -1);   // grow so nIndex is valid
; 560  : 	}
; 561  : 	else
; 562  : 	{
; 563  : 		// inserting in the middle of the array
; 564  : 		INT_PTR nOldSize = m_nSize;
; 565  : 		SetSize(m_nSize + nCount, -1);  // grow it to new size
; 566  : 		// destroy intial data before copying over it
; 567  : 		for( int i = 0; i < nCount; i++ )
; 568  : 			(m_pData + nOldSize + i)->~TYPE();
; 569  : 		// shift old data up to fill gap
; 570  : 		::ATL::Checked::memmove_s(m_pData + nIndex + nCount, (nOldSize-nIndex) * sizeof(TYPE),
; 571  : 			m_pData + nIndex, (nOldSize-nIndex) * sizeof(TYPE));
; 572  : 
; 573  : 		// re-init slots we copied from
; 574  : 		memset((void*)(m_pData + nIndex), 0, (size_t)nCount * sizeof(TYPE));
; 575  : 		for( int i = 0; i < nCount; i++ )
; 576  : #pragma push_macro("new")
; 577  : #undef new
; 578  : 			::new( (void*)( m_pData + nIndex + i ) ) TYPE;
; 579  : #pragma pop_macro("new")
; 580  : 	}
; 581  : 
; 582  : 	// insert new value in the gap
; 583  : 	ASSERT(nIndex + nCount <= m_nSize);
; 584  : 	while (nCount--)
; 585  : 		m_pData[nIndex++] = newElement;
; 586  : }
; 587  : 
; 588  : template<class TYPE, class ARG_TYPE>
; 589  : void CArray<TYPE, ARG_TYPE>::RemoveAt(INT_PTR nIndex, INT_PTR nCount)
; 590  : {
; 591  : 	ASSERT_VALID(this);
; 592  : 	ASSERT(nIndex >= 0);
; 593  : 	ASSERT(nCount >= 0);
; 594  : 	INT_PTR nUpperBound = nIndex + nCount;
; 595  : 	ASSERT(nUpperBound <= m_nSize && nUpperBound >= nIndex && nUpperBound >= nCount);
; 596  : 
; 597  : 	if(nIndex < 0 || nCount < 0 || (nUpperBound > m_nSize) || (nUpperBound < nIndex) || (nUpperBound < nCount))
; 598  : 		AfxThrowInvalidArgException();
; 599  : 
; 600  : 	// just remove a range
; 601  : 	INT_PTR nMoveCount = m_nSize - (nUpperBound);
; 602  : 	for( int i = 0; i < nCount; i++ )
; 603  : 		(m_pData + nIndex + i)->~TYPE();
; 604  : 	if (nMoveCount)
; 605  : 	{
; 606  : 		::ATL::Checked::memmove_s(m_pData + nIndex, (size_t)nMoveCount * sizeof(TYPE),
; 607  : 			m_pData + nUpperBound, (size_t)nMoveCount * sizeof(TYPE));
; 608  : 	}
; 609  : 	m_nSize -= nCount;
; 610  : }
; 611  : 
; 612  : template<class TYPE, class ARG_TYPE>
; 613  : void CArray<TYPE, ARG_TYPE>::InsertAt(INT_PTR nStartIndex, CArray* pNewArray)
; 614  : {
; 615  : 	ASSERT_VALID(this);
; 616  : 	ASSERT(pNewArray != NULL);
; 617  : 	ASSERT_VALID(pNewArray);
; 618  : 	ASSERT(nStartIndex >= 0);
; 619  : 
; 620  : 	if(pNewArray == NULL || nStartIndex < 0)
; 621  : 		AfxThrowInvalidArgException();
; 622  : 
; 623  : 	if (pNewArray->GetSize() > 0)
; 624  : 	{
; 625  : 		InsertAt(nStartIndex, pNewArray->GetAt(0), pNewArray->GetSize());
; 626  : 		for (INT_PTR i = 0; i < pNewArray->GetSize(); i++)
; 627  : 			SetAt(nStartIndex + i, pNewArray->GetAt(i));
; 628  : 	}
; 629  : }
; 630  : 
; 631  : template<class TYPE, class ARG_TYPE>
; 632  : void CArray<TYPE, ARG_TYPE>::Serialize(CArchive& ar)
; 633  : {
; 634  : 	ASSERT_VALID(this);
; 635  : 
; 636  : 	CObject::Serialize(ar);
; 637  : 	if (ar.IsStoring())
; 638  : 	{
; 639  : 		ar.WriteCount(m_nSize);
; 640  : 	}
; 641  : 	else
; 642  : 	{
; 643  : 		DWORD_PTR nOldSize = ar.ReadCount();
; 644  : 		SetSize(nOldSize, -1);
; 645  : 	}
; 646  : 	SerializeElements<TYPE>(ar, m_pData, m_nSize);
; 647  : }
; 648  : 
; 649  : #ifdef _DEBUG
; 650  : template<class TYPE, class ARG_TYPE>
; 651  : void CArray<TYPE, ARG_TYPE>::Dump(CDumpContext& dc) const
; 652  : {
; 653  : 	CObject::Dump(dc);
; 654  : 
; 655  : 	dc << "with " << m_nSize << " elements";
; 656  : 	if (dc.GetDepth() > 0)
; 657  : 	{
; 658  : 		dc << "\n";
; 659  : 		DumpElements<TYPE>(dc, m_pData, m_nSize);
; 660  : 	}
; 661  : 
; 662  : 	dc << "\n";
; 663  : }
; 664  : 
; 665  : template<class TYPE, class ARG_TYPE>
; 666  : void CArray<TYPE, ARG_TYPE>::AssertValid() const
; 667  : {
; 668  : 	CObject::AssertValid();
; 669  : 
; 670  : 	if (m_pData == NULL)
; 671  : 	{
; 672  : 		ASSERT(m_nSize == 0);
; 673  : 		ASSERT(m_nMaxSize == 0);
; 674  : 	}
; 675  : 	else
; 676  : 	{
; 677  : 		ASSERT(m_nSize >= 0);
; 678  : 		ASSERT(m_nMaxSize >= 0);
; 679  : 		ASSERT(m_nSize <= m_nMaxSize);
; 680  : 		ASSERT(AfxIsValidAddress(m_pData, m_nMaxSize * sizeof(TYPE)));
; 681  : 	}
; 682  : }
; 683  : #endif //_DEBUG
; 684  : 
; 685  : /*============================================================================*/
; 686  : // CList<TYPE, ARG_TYPE>
; 687  : 
; 688  : template<class TYPE, class ARG_TYPE = const TYPE&>
; 689  : class CList : public CObject
; 690  : {
; 691  : protected:
; 692  : 	struct CNode
; 693  : 	{
; 694  : 		CNode* pNext;
; 695  : 		CNode* pPrev;
; 696  : 		TYPE data;
; 697  : 	};
; 698  : public:
; 699  : // Construction
; 700  : 	explicit CList(INT_PTR nBlockSize = 10);
; 701  : 
; 702  : // Attributes (head and tail)
; 703  : 	// count of elements
; 704  : 	INT_PTR GetCount() const;
; 705  : 	INT_PTR GetSize() const;
; 706  : 	BOOL IsEmpty() const;
; 707  : 
; 708  : 	// peek at head or tail
; 709  : 	TYPE& GetHead();
; 710  : 	const TYPE& GetHead() const;
; 711  : 	TYPE& GetTail();
; 712  : 	const TYPE& GetTail() const;
; 713  : 
; 714  : // Operations
; 715  : 	// get head or tail (and remove it) - don't call on empty list !
; 716  : 	TYPE RemoveHead();
; 717  : 	TYPE RemoveTail();
; 718  : 
; 719  : 	// add before head or after tail
; 720  : 	POSITION AddHead(ARG_TYPE newElement);
; 721  : 	POSITION AddTail(ARG_TYPE newElement);
; 722  : 
; 723  : 	// add another list of elements before head or after tail
; 724  : 	void AddHead(CList* pNewList);
; 725  : 	void AddTail(CList* pNewList);
; 726  : 
; 727  : 	// remove all elements
; 728  : 	void RemoveAll();
; 729  : 
; 730  : 	// iteration
; 731  : 	POSITION GetHeadPosition() const;
; 732  : 	POSITION GetTailPosition() const;
; 733  : 	TYPE& GetNext(POSITION& rPosition); // return *Position++
; 734  : 	const TYPE& GetNext(POSITION& rPosition) const; // return *Position++
; 735  : 	TYPE& GetPrev(POSITION& rPosition); // return *Position--
; 736  : 	const TYPE& GetPrev(POSITION& rPosition) const; // return *Position--
; 737  : 
; 738  : 	// getting/modifying an element at a given position
; 739  : 	TYPE& GetAt(POSITION position);
; 740  : 	const TYPE& GetAt(POSITION position) const;
; 741  : 	void SetAt(POSITION pos, ARG_TYPE newElement);
; 742  : 	void RemoveAt(POSITION position);
; 743  : 
; 744  : 	// inserting before or after a given position
; 745  : 	POSITION InsertBefore(POSITION position, ARG_TYPE newElement);
; 746  : 	POSITION InsertAfter(POSITION position, ARG_TYPE newElement);
; 747  : 
; 748  : 	// helper functions (note: O(n) speed)
; 749  : 	POSITION Find(ARG_TYPE searchValue, POSITION startAfter = NULL) const;
; 750  : 		// defaults to starting at the HEAD, return NULL if not found
; 751  : 	POSITION FindIndex(INT_PTR nIndex) const;
; 752  : 		// get the 'nIndex'th element (may return NULL)
; 753  : 
; 754  : // Implementation
; 755  : protected:
; 756  : 	CNode* m_pNodeHead;
; 757  : 	CNode* m_pNodeTail;
; 758  : 	INT_PTR m_nCount;
; 759  : 	CNode* m_pNodeFree;
; 760  : 	struct CPlex* m_pBlocks;
; 761  : 	INT_PTR m_nBlockSize;
; 762  : 
; 763  : 	CNode* NewNode(CNode*, CNode*);
; 764  : 	void FreeNode(CNode*);
; 765  : 
; 766  : public:
; 767  : 	~CList();
; 768  : 	void Serialize(CArchive&);
; 769  : #ifdef _DEBUG
; 770  : 	void Dump(CDumpContext&) const;
; 771  : 	void AssertValid() const;
; 772  : #endif
; 773  : };
; 774  : 
; 775  : /*============================================================================*/
; 776  : // CList<TYPE, ARG_TYPE> inline functions
; 777  : 
; 778  : template<class TYPE, class ARG_TYPE>
; 779  : AFX_INLINE INT_PTR CList<TYPE, ARG_TYPE>::GetCount() const
; 780  : 	{ return m_nCount; }
; 781  : template<class TYPE, class ARG_TYPE>
; 782  : AFX_INLINE INT_PTR CList<TYPE, ARG_TYPE>::GetSize() const
; 783  : 	{ return m_nCount; }
; 784  : template<class TYPE, class ARG_TYPE>
; 785  : AFX_INLINE BOOL CList<TYPE, ARG_TYPE>::IsEmpty() const
; 786  : 	{ return m_nCount == 0; }
; 787  : template<class TYPE, class ARG_TYPE>
; 788  : AFX_INLINE TYPE& CList<TYPE, ARG_TYPE>::GetHead()
; 789  : 	{ ENSURE(m_pNodeHead != NULL);
; 790  : 		return m_pNodeHead->data; }
; 791  : template<class TYPE, class ARG_TYPE>
; 792  : AFX_INLINE const TYPE& CList<TYPE, ARG_TYPE>::GetHead() const
; 793  : 	{ ENSURE(m_pNodeHead != NULL);
; 794  : 		return m_pNodeHead->data; }
; 795  : template<class TYPE, class ARG_TYPE>
; 796  : AFX_INLINE TYPE& CList<TYPE, ARG_TYPE>::GetTail()
; 797  : 	{ ENSURE(m_pNodeTail != NULL);
; 798  : 		return m_pNodeTail->data; }
; 799  : template<class TYPE, class ARG_TYPE>
; 800  : AFX_INLINE const TYPE& CList<TYPE, ARG_TYPE>::GetTail() const
; 801  : 	{ ENSURE(m_pNodeTail != NULL);
; 802  : 		return m_pNodeTail->data; }
; 803  : template<class TYPE, class ARG_TYPE>
; 804  : AFX_INLINE POSITION CList<TYPE, ARG_TYPE>::GetHeadPosition() const
; 805  : 	{ return (POSITION) m_pNodeHead; }
; 806  : template<class TYPE, class ARG_TYPE>
; 807  : AFX_INLINE POSITION CList<TYPE, ARG_TYPE>::GetTailPosition() const
; 808  : 	{ return (POSITION) m_pNodeTail; }
; 809  : template<class TYPE, class ARG_TYPE>
; 810  : AFX_INLINE TYPE& CList<TYPE, ARG_TYPE>::GetNext(POSITION& rPosition) // return *Position++
; 811  : 	{ CNode* pNode = (CNode*) rPosition;
; 812  : 		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 813  : 		rPosition = (POSITION) pNode->pNext;
; 814  : 		return pNode->data; }
; 815  : template<class TYPE, class ARG_TYPE>
; 816  : AFX_INLINE const TYPE& CList<TYPE, ARG_TYPE>::GetNext(POSITION& rPosition) const // return *Position++
; 817  : 	{ CNode* pNode = (CNode*) rPosition;
; 818  : 		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 819  : 		rPosition = (POSITION) pNode->pNext;
; 820  : 		return pNode->data; }
; 821  : template<class TYPE, class ARG_TYPE>
; 822  : AFX_INLINE TYPE& CList<TYPE, ARG_TYPE>::GetPrev(POSITION& rPosition) // return *Position--
; 823  : 	{ CNode* pNode = (CNode*) rPosition;
; 824  : 		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 825  : 		rPosition = (POSITION) pNode->pPrev;
; 826  : 		return pNode->data; }
; 827  : template<class TYPE, class ARG_TYPE>
; 828  : AFX_INLINE const TYPE& CList<TYPE, ARG_TYPE>::GetPrev(POSITION& rPosition) const // return *Position--
; 829  : 	{ CNode* pNode = (CNode*) rPosition;
; 830  : 		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 831  : 		rPosition = (POSITION) pNode->pPrev;
; 832  : 		return pNode->data; }
; 833  : template<class TYPE, class ARG_TYPE>
; 834  : AFX_INLINE TYPE& CList<TYPE, ARG_TYPE>::GetAt(POSITION position)
; 835  : 	{ CNode* pNode = (CNode*) position;
; 836  : 		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 837  : 		return pNode->data; }
; 838  : template<class TYPE, class ARG_TYPE>
; 839  : AFX_INLINE const TYPE& CList<TYPE, ARG_TYPE>::GetAt(POSITION position) const
; 840  : 	{ CNode* pNode = (CNode*) position;
; 841  : 		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 842  : 		return pNode->data; }
; 843  : template<class TYPE, class ARG_TYPE>
; 844  : AFX_INLINE void CList<TYPE, ARG_TYPE>::SetAt(POSITION pos, ARG_TYPE newElement)
; 845  : 	{ CNode* pNode = (CNode*) pos;
; 846  : 		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 847  : 		pNode->data = newElement; }
; 848  : 
; 849  : template<class TYPE, class ARG_TYPE>
; 850  : CList<TYPE, ARG_TYPE>::CList(INT_PTR nBlockSize)
; 851  : {
; 852  : 	ASSERT(nBlockSize > 0);
; 853  : 
; 854  : 	m_nCount = 0;
; 855  : 	m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
; 856  : 	m_pBlocks = NULL;
; 857  : 	m_nBlockSize = nBlockSize;
; 858  : }
; 859  : 
; 860  : template<class TYPE, class ARG_TYPE>
; 861  : void CList<TYPE, ARG_TYPE>::RemoveAll()
; 862  : {
; 863  : 	ASSERT_VALID(this);
; 864  : 
; 865  : 	// destroy elements
; 866  : 	CNode* pNode;
; 867  : 	for (pNode = m_pNodeHead; pNode != NULL; pNode = pNode->pNext)
; 868  : 		pNode->data.~TYPE();
; 869  : 
; 870  : 	m_nCount = 0;
; 871  : 	m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
; 872  : 	m_pBlocks->FreeDataChain();
; 873  : 	m_pBlocks = NULL;
; 874  : }
; 875  : 
; 876  : template<class TYPE, class ARG_TYPE>
; 877  : CList<TYPE, ARG_TYPE>::~CList()
; 878  : {
; 879  : 	RemoveAll();
; 880  : 	ASSERT(m_nCount == 0);
; 881  : }
; 882  : 
; 883  : /*============================================================================*/
; 884  : // Node helpers
; 885  : //
; 886  : // Implementation note: CNode's are stored in CPlex blocks and
; 887  : //  chained together. Free blocks are maintained in a singly linked list
; 888  : //  using the 'pNext' member of CNode with 'm_pNodeFree' as the head.
; 889  : //  Used blocks are maintained in a doubly linked list using both 'pNext'
; 890  : //  and 'pPrev' as links and 'm_pNodeHead' and 'm_pNodeTail'
; 891  : //   as the head/tail.
; 892  : //
; 893  : // We never free a CPlex block unless the List is destroyed or RemoveAll()
; 894  : //  is used - so the total number of CPlex blocks may grow large depending
; 895  : //  on the maximum past size of the list.
; 896  : //
; 897  : 
; 898  : template<class TYPE, class ARG_TYPE>
; 899  : typename CList<TYPE, ARG_TYPE>::CNode*
; 900  : CList<TYPE, ARG_TYPE>::NewNode(CNode* pPrev, CNode* pNext)
; 901  : {
; 902  : 	if (m_pNodeFree == NULL)
; 903  : 	{
; 904  : 		// add another block
; 905  : 		CPlex* pNewBlock = CPlex::Create(m_pBlocks, m_nBlockSize,
; 906  : 				 sizeof(CNode));
; 907  : 
; 908  : 		// chain them into free list
; 909  : 		CNode* pNode = (CNode*) pNewBlock->data();
; 910  : 		// free in reverse order to make it easier to debug
; 911  : 		pNode += m_nBlockSize - 1;
; 912  : 		for (INT_PTR i = m_nBlockSize-1; i >= 0; i--, pNode--)
; 913  : 		{
; 914  : 			pNode->pNext = m_pNodeFree;
; 915  : 			m_pNodeFree = pNode;
; 916  : 		}
; 917  : 	}
; 918  : 	ENSURE(m_pNodeFree != NULL);  // we must have something
; 919  : 
; 920  : 	CList::CNode* pNode = m_pNodeFree;
; 921  : 	m_pNodeFree = m_pNodeFree->pNext;
; 922  : 	pNode->pPrev = pPrev;
; 923  : 	pNode->pNext = pNext;
; 924  : 	m_nCount++;
; 925  : 	ASSERT(m_nCount > 0);  // make sure we don't overflow
; 926  : 
; 927  : #pragma push_macro("new")
; 928  : #undef new
; 929  : 	::new( (void*)( &pNode->data ) ) TYPE;
; 930  : #pragma pop_macro("new")
; 931  : 	return pNode;
; 932  : }
; 933  : 
; 934  : template<class TYPE, class ARG_TYPE>
; 935  : void CList<TYPE, ARG_TYPE>::FreeNode(CNode* pNode)
; 936  : {
; 937  : 	pNode->data.~TYPE();
; 938  : 	pNode->pNext = m_pNodeFree;
; 939  : 	m_pNodeFree = pNode;
; 940  : 	m_nCount--;
; 941  : 	ASSERT(m_nCount >= 0);  // make sure we don't underflow
; 942  : 
; 943  : 	// if no more elements, cleanup completely
; 944  : 	if (m_nCount == 0)
; 945  : 		RemoveAll();
; 946  : }
; 947  : 
; 948  : template<class TYPE, class ARG_TYPE>
; 949  : POSITION CList<TYPE, ARG_TYPE>::AddHead(ARG_TYPE newElement)
; 950  : {
; 951  : 	ASSERT_VALID(this);
; 952  : 
; 953  : 	CNode* pNewNode = NewNode(NULL, m_pNodeHead);
; 954  : 	pNewNode->data = newElement;
; 955  : 	if (m_pNodeHead != NULL)
; 956  : 		m_pNodeHead->pPrev = pNewNode;
; 957  : 	else
; 958  : 		m_pNodeTail = pNewNode;
; 959  : 	m_pNodeHead = pNewNode;
; 960  : 	return (POSITION) pNewNode;
; 961  : }
; 962  : 
; 963  : template<class TYPE, class ARG_TYPE>
; 964  : POSITION CList<TYPE, ARG_TYPE>::AddTail(ARG_TYPE newElement)
; 965  : {
; 966  : 	ASSERT_VALID(this);
; 967  : 
; 968  : 	CNode* pNewNode = NewNode(m_pNodeTail, NULL);
; 969  : 	pNewNode->data = newElement;
; 970  : 	if (m_pNodeTail != NULL)
; 971  : 		m_pNodeTail->pNext = pNewNode;
; 972  : 	else
; 973  : 		m_pNodeHead = pNewNode;
; 974  : 	m_pNodeTail = pNewNode;
; 975  : 	return (POSITION) pNewNode;
; 976  : }
; 977  : 
; 978  : template<class TYPE, class ARG_TYPE>
; 979  : void CList<TYPE, ARG_TYPE>::AddHead(CList* pNewList)
; 980  : {
; 981  : 	ASSERT_VALID(this);
; 982  : 
; 983  : 	ENSURE(pNewList != NULL);
; 984  : 	ASSERT_VALID(pNewList);
; 985  : 
; 986  : 	// add a list of same elements to head (maintain order)
; 987  : 	POSITION pos = pNewList->GetTailPosition();
; 988  : 	while (pos != NULL)
; 989  : 		AddHead(pNewList->GetPrev(pos));
; 990  : }
; 991  : 
; 992  : template<class TYPE, class ARG_TYPE>
; 993  : void CList<TYPE, ARG_TYPE>::AddTail(CList* pNewList)
; 994  : {
; 995  : 	ASSERT_VALID(this);
; 996  : 	ENSURE(pNewList != NULL);
; 997  : 	ASSERT_VALID(pNewList);
; 998  : 
; 999  : 	// add a list of same elements
; 1000 : 	POSITION pos = pNewList->GetHeadPosition();
; 1001 : 	while (pos != NULL)
; 1002 : 		AddTail(pNewList->GetNext(pos));
; 1003 : }
; 1004 : 
; 1005 : template<class TYPE, class ARG_TYPE>
; 1006 : TYPE CList<TYPE, ARG_TYPE>::RemoveHead()
; 1007 : {
; 1008 : 	ASSERT_VALID(this);
; 1009 : 	ENSURE(m_pNodeHead != NULL);  // don't call on empty list !!!
; 1010 : 	ASSERT(AfxIsValidAddress(m_pNodeHead, sizeof(CNode)));
; 1011 : 
; 1012 : 	CNode* pOldNode = m_pNodeHead;
; 1013 : 	TYPE returnValue = pOldNode->data;
; 1014 : 
; 1015 : 	m_pNodeHead = pOldNode->pNext;
; 1016 : 	if (m_pNodeHead != NULL)
; 1017 : 		m_pNodeHead->pPrev = NULL;
; 1018 : 	else
; 1019 : 		m_pNodeTail = NULL;
; 1020 : 	FreeNode(pOldNode);
; 1021 : 	return returnValue;
; 1022 : }
; 1023 : 
; 1024 : template<class TYPE, class ARG_TYPE>
; 1025 : TYPE CList<TYPE, ARG_TYPE>::RemoveTail()
; 1026 : {
; 1027 : 	ASSERT_VALID(this);
; 1028 : 	ENSURE(m_pNodeTail != NULL);  // don't call on empty list !!!
; 1029 : 	ASSERT(AfxIsValidAddress(m_pNodeTail, sizeof(CNode)));
; 1030 : 
; 1031 : 	CNode* pOldNode = m_pNodeTail;
; 1032 : 	TYPE returnValue = pOldNode->data;
; 1033 : 
; 1034 : 	m_pNodeTail = pOldNode->pPrev;
; 1035 : 	if (m_pNodeTail != NULL)
; 1036 : 		m_pNodeTail->pNext = NULL;
; 1037 : 	else
; 1038 : 		m_pNodeHead = NULL;
; 1039 : 	FreeNode(pOldNode);
; 1040 : 	return returnValue;
; 1041 : }
; 1042 : 
; 1043 : template<class TYPE, class ARG_TYPE>
; 1044 : POSITION CList<TYPE, ARG_TYPE>::InsertBefore(POSITION position, ARG_TYPE newElement)
; 1045 : {
; 1046 : 	ASSERT_VALID(this);
; 1047 : 
; 1048 : 	if (position == NULL)
; 1049 : 		return AddHead(newElement); // insert before nothing -> head of the list
; 1050 : 
; 1051 : 	// Insert it before position
; 1052 : 	CNode* pOldNode = (CNode*) position;
; 1053 : 	CNode* pNewNode = NewNode(pOldNode->pPrev, pOldNode);
; 1054 : 	pNewNode->data = newElement;
; 1055 : 
; 1056 : 	if (pOldNode->pPrev != NULL)
; 1057 : 	{
; 1058 : 		ASSERT(AfxIsValidAddress(pOldNode->pPrev, sizeof(CNode)));
; 1059 : 		pOldNode->pPrev->pNext = pNewNode;
; 1060 : 	}
; 1061 : 	else
; 1062 : 	{
; 1063 : 		ASSERT(pOldNode == m_pNodeHead);
; 1064 : 		m_pNodeHead = pNewNode;
; 1065 : 	}
; 1066 : 	pOldNode->pPrev = pNewNode;
; 1067 : 	return (POSITION) pNewNode;
; 1068 : }
; 1069 : 
; 1070 : template<class TYPE, class ARG_TYPE>
; 1071 : POSITION CList<TYPE, ARG_TYPE>::InsertAfter(POSITION position, ARG_TYPE newElement)
; 1072 : {
; 1073 : 	ASSERT_VALID(this);
; 1074 : 
; 1075 : 	if (position == NULL)
; 1076 : 		return AddTail(newElement); // insert after nothing -> tail of the list
; 1077 : 
; 1078 : 	// Insert it before position
; 1079 : 	CNode* pOldNode = (CNode*) position;
; 1080 : 	ASSERT(AfxIsValidAddress(pOldNode, sizeof(CNode)));
; 1081 : 	CNode* pNewNode = NewNode(pOldNode, pOldNode->pNext);
; 1082 : 	pNewNode->data = newElement;
; 1083 : 
; 1084 : 	if (pOldNode->pNext != NULL)
; 1085 : 	{
; 1086 : 		ASSERT(AfxIsValidAddress(pOldNode->pNext, sizeof(CNode)));
; 1087 : 		pOldNode->pNext->pPrev = pNewNode;
; 1088 : 	}
; 1089 : 	else
; 1090 : 	{
; 1091 : 		ASSERT(pOldNode == m_pNodeTail);
; 1092 : 		m_pNodeTail = pNewNode;
; 1093 : 	}
; 1094 : 	pOldNode->pNext = pNewNode;
; 1095 : 	return (POSITION) pNewNode;
; 1096 : }
; 1097 : 
; 1098 : template<class TYPE, class ARG_TYPE>
; 1099 : void CList<TYPE, ARG_TYPE>::RemoveAt(POSITION position)
; 1100 : {
; 1101 : 	ASSERT_VALID(this);
; 1102 : 
; 1103 : 	CNode* pOldNode = (CNode*) position;
; 1104 : 	ASSERT(AfxIsValidAddress(pOldNode, sizeof(CNode)));
; 1105 : 
; 1106 : 	// remove pOldNode from list
; 1107 : 	if (pOldNode == m_pNodeHead)
; 1108 : 	{
; 1109 : 		m_pNodeHead = pOldNode->pNext;
; 1110 : 	}
; 1111 : 	else
; 1112 : 	{
; 1113 : 		ASSERT(AfxIsValidAddress(pOldNode->pPrev, sizeof(CNode)));
; 1114 : 		pOldNode->pPrev->pNext = pOldNode->pNext;
; 1115 : 	}
; 1116 : 	if (pOldNode == m_pNodeTail)
; 1117 : 	{
; 1118 : 		m_pNodeTail = pOldNode->pPrev;
; 1119 : 	}
; 1120 : 	else
; 1121 : 	{
; 1122 : 		ASSERT(AfxIsValidAddress(pOldNode->pNext, sizeof(CNode)));
; 1123 : 		pOldNode->pNext->pPrev = pOldNode->pPrev;
; 1124 : 	}
; 1125 : 	FreeNode(pOldNode);
; 1126 : }
; 1127 : 
; 1128 : template<class TYPE, class ARG_TYPE>
; 1129 : POSITION CList<TYPE, ARG_TYPE>::FindIndex(INT_PTR nIndex) const
; 1130 : {
; 1131 : 	ASSERT_VALID(this);
; 1132 : 
; 1133 : 	if (nIndex >= m_nCount || nIndex < 0)
; 1134 : 		return NULL;  // went too far
; 1135 : 
; 1136 : 	CNode* pNode = m_pNodeHead;
; 1137 : 	while (nIndex--)
; 1138 : 	{
; 1139 : 		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 1140 : 		pNode = pNode->pNext;
; 1141 : 	}
; 1142 : 	return (POSITION) pNode;
; 1143 : }
; 1144 : 
; 1145 : template<class TYPE, class ARG_TYPE>
; 1146 : POSITION CList<TYPE, ARG_TYPE>::Find(ARG_TYPE searchValue, POSITION startAfter) const
; 1147 : {
; 1148 : 	ASSERT_VALID(this);
; 1149 : 
; 1150 : 	CNode* pNode = (CNode*) startAfter;
; 1151 : 	if (pNode == NULL)
; 1152 : 	{
; 1153 : 		pNode = m_pNodeHead;  // start at head
; 1154 : 	}
; 1155 : 	else
; 1156 : 	{
; 1157 : 		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 1158 : 		pNode = pNode->pNext;  // start after the one specified
; 1159 : 	}
; 1160 : 
; 1161 : 	for (; pNode != NULL; pNode = pNode->pNext)
; 1162 : 		if (CompareElements<TYPE>(&pNode->data, &searchValue))
; 1163 : 			return (POSITION)pNode;
; 1164 : 	return NULL;
; 1165 : }
; 1166 : 
; 1167 : template<class TYPE, class ARG_TYPE>
; 1168 : void CList<TYPE, ARG_TYPE>::Serialize(CArchive& ar)
; 1169 : {
; 1170 : 	ASSERT_VALID(this);
; 1171 : 
; 1172 : 	CObject::Serialize(ar);
; 1173 : 
; 1174 : 	if (ar.IsStoring())
; 1175 : 	{
; 1176 : 		ar.WriteCount(m_nCount);
; 1177 : 		for (CNode* pNode = m_pNodeHead; pNode != NULL; pNode = pNode->pNext)
; 1178 : 		{
; 1179 : 			ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 1180 : 			TYPE* pData;
; 1181 : 			/*
; 1182 : 			 * in some cases the & operator might be overloaded, and we cannot use it to obtain
; 1183 : 			 * the address of a given object.  We then use the following trick to get the address
; 1184 : 			 */
; 1185 : 			pData = reinterpret_cast< TYPE* >( &reinterpret_cast< int& >( static_cast< TYPE& >( pNode->data ) ) );
; 1186 : 			SerializeElements<TYPE>(ar, pData, 1);
; 1187 : 		}
; 1188 : 	}
; 1189 : 	else
; 1190 : 	{
; 1191 : 		DWORD_PTR nNewCount = ar.ReadCount();
; 1192 : 		while (nNewCount--)
; 1193 : 		{
; 1194 : 			TYPE newData[1];
; 1195 : 			SerializeElements<TYPE>(ar, newData, 1);
; 1196 : 			AddTail(newData[0]);
; 1197 : 		}
; 1198 : 	}
; 1199 : }
; 1200 : 
; 1201 : #ifdef _DEBUG
; 1202 : template<class TYPE, class ARG_TYPE>
; 1203 : void CList<TYPE, ARG_TYPE>::Dump(CDumpContext& dc) const
; 1204 : {
; 1205 : 	CObject::Dump(dc);
; 1206 : 
; 1207 : 	dc << "with " << m_nCount << " elements";
; 1208 : 	if (dc.GetDepth() > 0)
; 1209 : 	{
; 1210 : 		POSITION pos = GetHeadPosition();
; 1211 : 		while (pos != NULL)
; 1212 : 		{
; 1213 : 			TYPE temp[1];
; 1214 : 			temp[0] = ((CList*)this)->GetNext(pos);
; 1215 : 			dc << "\n";
; 1216 : 			DumpElements<TYPE>(dc, temp, 1);
; 1217 : 		}
; 1218 : 	}
; 1219 : 
; 1220 : 	dc << "\n";
; 1221 : }
; 1222 : 
; 1223 : template<class TYPE, class ARG_TYPE>
; 1224 : void CList<TYPE, ARG_TYPE>::AssertValid() const
; 1225 : {
; 1226 : 	CObject::AssertValid();
; 1227 : 
; 1228 : 	if (m_nCount == 0)
; 1229 : 	{
; 1230 : 		// empty list
; 1231 : 		ASSERT(m_pNodeHead == NULL);
; 1232 : 		ASSERT(m_pNodeTail == NULL);
; 1233 : 	}
; 1234 : 	else
; 1235 : 	{
; 1236 : 		// non-empty list
; 1237 : 		ASSERT(AfxIsValidAddress(m_pNodeHead, sizeof(CNode)));
; 1238 : 		ASSERT(AfxIsValidAddress(m_pNodeTail, sizeof(CNode)));
; 1239 : 	}
; 1240 : }
; 1241 : #endif //_DEBUG
; 1242 : 
; 1243 : /*============================================================================*/
; 1244 : // CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>
; 1245 : 
; 1246 : template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
; 1247 : class CMap : public CObject
; 1248 : {
; 1249 : public:
; 1250 : 	// CPair
; 1251 : 	struct CPair
; 1252 : 	{
; 1253 : 		const KEY key;
; 1254 : 		VALUE value;
; 1255 : 	protected:
; 1256 : 		CPair( ARG_KEY keyval ) : key( keyval )	{}
; 1257 : 	};
; 1258 : 
; 1259 : protected:
; 1260 : 	// Association
; 1261 : 	class CAssoc : public CPair
; 1262 : 	{
; 1263 : 		friend class CMap<KEY,ARG_KEY,VALUE,ARG_VALUE>;
; 1264 : 		CAssoc* pNext;
; 1265 : 		UINT nHashValue;  // needed for efficient iteration
; 1266 : 	public:
; 1267 : 		CAssoc( ARG_KEY key ) : CPair( key ) {}
; 1268 : 	};
; 1269 : 
; 1270 : public:
; 1271 : // Construction
; 1272 : 	explicit CMap(INT_PTR nBlockSize = 10);
; 1273 : 
; 1274 : // Attributes
; 1275 : 	// number of elements
; 1276 : 	INT_PTR GetCount() const;
; 1277 : 	INT_PTR GetSize() const;
; 1278 : 	BOOL IsEmpty() const;
; 1279 : 
; 1280 : 	// Lookup
; 1281 : 	BOOL Lookup(ARG_KEY key, VALUE& rValue) const;
; 1282 : 	const CPair *PLookup(ARG_KEY key) const;
; 1283 : 	CPair *PLookup(ARG_KEY key);
; 1284 : 
; 1285 : // Operations
; 1286 : 	// Lookup and add if not there
; 1287 : 	VALUE& operator[](ARG_KEY key);
; 1288 : 
; 1289 : 	// add a new (key, value) pair
; 1290 : 	void SetAt(ARG_KEY key, ARG_VALUE newValue);
; 1291 : 
; 1292 : 	// removing existing (key, ?) pair
; 1293 : 	BOOL RemoveKey(ARG_KEY key);
; 1294 : 	void RemoveAll();
; 1295 : 
; 1296 : 	// iterating all (key, value) pairs
; 1297 : 	POSITION GetStartPosition() const;
; 1298 : 
; 1299 : 	const CPair *PGetFirstAssoc() const;
; 1300 : 	CPair *PGetFirstAssoc();
; 1301 : 
; 1302 : 	void GetNextAssoc(POSITION& rNextPosition, KEY& rKey, VALUE& rValue) const;
; 1303 : 
; 1304 : 	const CPair *PGetNextAssoc(const CPair *pAssocRet) const;
; 1305 : 	CPair *PGetNextAssoc(const CPair *pAssocRet);
; 1306 : 
; 1307 : 	// advanced features for derived classes
; 1308 : 	UINT GetHashTableSize() const;
; 1309 : 	void InitHashTable(UINT hashSize, BOOL bAllocNow = TRUE);
; 1310 : 
; 1311 : // Implementation
; 1312 : protected:
; 1313 : 	CAssoc** m_pHashTable;
; 1314 : 	UINT m_nHashTableSize;
; 1315 : 	INT_PTR m_nCount;
; 1316 : 	CAssoc* m_pFreeList;
; 1317 : 	struct CPlex* m_pBlocks;
; 1318 : 	INT_PTR m_nBlockSize;
; 1319 : 
; 1320 : 	CAssoc* NewAssoc(ARG_KEY key);
; 1321 : 	void FreeAssoc(CAssoc*);
; 1322 : 	CAssoc* GetAssocAt(ARG_KEY, UINT&, UINT&) const;
; 1323 : 
; 1324 : public:
; 1325 : 	~CMap();
; 1326 : 	void Serialize(CArchive&);
; 1327 : #ifdef _DEBUG
; 1328 : 	void Dump(CDumpContext&) const;
; 1329 : 	void AssertValid() const;
; 1330 : #endif
; 1331 : };
; 1332 : 
; 1333 : /*============================================================================*/
; 1334 : // CMap<KEY, ARG_KEY, VALUE, ARG_VALUE> inline functions
; 1335 : 
; 1336 : template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
; 1337 : AFX_INLINE INT_PTR CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetCount() const
; 1338 : 	{ return m_nCount; }
; 1339 : 
; 1340 : template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
; 1341 : AFX_INLINE INT_PTR CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetSize() const
; 1342 : 	{ return m_nCount; }
; 1343 : 
; 1344 : template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
; 1345 : AFX_INLINE BOOL CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::IsEmpty() const
; 1346 : 	{ return m_nCount == 0; }
; 1347 : 
; 1348 : template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
; 1349 : AFX_INLINE void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::SetAt(ARG_KEY key, ARG_VALUE newValue)
; 1350 : 	{ (*this)[key] = newValue; }
; 1351 : 
; 1352 : template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
; 1353 : AFX_INLINE POSITION CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetStartPosition() const
; 1354 : 	{ return (m_nCount == 0) ? NULL : BEFORE_START_POSITION; }
; 1355 : 
; 1356 : template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
; 1357 : const typename CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CPair* CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::PGetFirstAssoc() const
; 1358 : {
; 1359 : 	ASSERT_VALID(this);
; 1360 : 	if(m_nCount == 0) return NULL;
; 1361 : 
; 1362 : 	AFXASSUME(m_pHashTable != NULL);  // never call on empty map
; 1363 : 
; 1364 : 	CAssoc* pAssocRet = (CAssoc*)BEFORE_START_POSITION;
; 1365 : 
; 1366 : 	// find the first association
; 1367 : 	for (UINT nBucket = 0; nBucket < m_nHashTableSize; nBucket++)
; 1368 : 		if ((pAssocRet = m_pHashTable[nBucket]) != NULL)
; 1369 : 			break;
; 1370 : 	ASSERT(pAssocRet != NULL);  // must find something
; 1371 : 
; 1372 : 	return pAssocRet;
; 1373 : }
; 1374 : 
; 1375 : template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
; 1376 : typename CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CPair* CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::PGetFirstAssoc()
; 1377 : {
; 1378 : 	ASSERT_VALID(this);
; 1379 : 	if(m_nCount == 0) return NULL;
; 1380 : 
; 1381 : 	AFXASSUME(m_pHashTable != NULL);  // never call on empty map
; 1382 : 
; 1383 : 	CAssoc* pAssocRet = (CAssoc*)BEFORE_START_POSITION;
; 1384 : 
; 1385 : 	// find the first association
; 1386 : 	for (UINT nBucket = 0; nBucket < m_nHashTableSize; nBucket++)
; 1387 : 		if ((pAssocRet = m_pHashTable[nBucket]) != NULL)
; 1388 : 			break;
; 1389 : 	ASSERT(pAssocRet != NULL);  // must find something
; 1390 : 
; 1391 : 	return pAssocRet;
; 1392 : }
; 1393 : 
; 1394 : template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
; 1395 : AFX_INLINE UINT CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetHashTableSize() const
; 1396 : 	{ return m_nHashTableSize; }
; 1397 : 
; 1398 : /*============================================================================*/
; 1399 : // CMap<KEY, ARG_KEY, VALUE, ARG_VALUE> out-of-line functions
; 1400 : 
; 1401 : template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
; 1402 : CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CMap(INT_PTR nBlockSize)
; 1403 : {
; 1404 : 	ASSERT(nBlockSize > 0);
; 1405 : 
; 1406 : 	m_pHashTable = NULL;
; 1407 : 	m_nHashTableSize = 17;  // default size
; 1408 : 	m_nCount = 0;
; 1409 : 	m_pFreeList = NULL;
; 1410 : 	m_pBlocks = NULL;
; 1411 : 	m_nBlockSize = nBlockSize;
; 1412 : }
; 1413 : 
; 1414 : template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
; 1415 : void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::InitHashTable(
; 1416 : 	UINT nHashSize, BOOL bAllocNow)
; 1417 : //
; 1418 : // Used to force allocation of a hash table or to override the default
; 1419 : //   hash table size of (which is fairly small)
; 1420 : {
; 1421 : 	ASSERT_VALID(this);
; 1422 : 	ASSERT(m_nCount == 0);
; 1423 : 	ASSERT(nHashSize > 0);
; 1424 : 
; 1425 : 	if (m_pHashTable != NULL)
; 1426 : 	{
; 1427 : 		// free hash table
; 1428 : 		delete[] m_pHashTable;
; 1429 : 		m_pHashTable = NULL;
; 1430 : 	}
; 1431 : 
; 1432 : 	if (bAllocNow)
; 1433 : 	{
; 1434 : 		m_pHashTable = new CAssoc* [nHashSize];
; 1435 : 		ENSURE(m_pHashTable != NULL);
; 1436 : 		memset(m_pHashTable, 0, sizeof(CAssoc*) * nHashSize);
; 1437 : 	}
; 1438 : 	m_nHashTableSize = nHashSize;
; 1439 : }
; 1440 : 
; 1441 : template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
; 1442 : void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::RemoveAll()
; 1443 : {
; 1444 : 	ASSERT_VALID(this);
; 1445 : 
; 1446 : 	if (m_pHashTable != NULL)
; 1447 : 	{
; 1448 : 		// destroy elements (values and keys)
; 1449 : 		for (UINT nHash = 0; nHash < m_nHashTableSize; nHash++)
; 1450 : 		{
; 1451 : 			CAssoc* pAssoc;
; 1452 : 			for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL;
; 1453 : 			  pAssoc = pAssoc->pNext)
; 1454 : 			{
; 1455 : 				pAssoc->CAssoc::~CAssoc();
; 1456 : 			}
; 1457 : 		}
; 1458 : 
; 1459 : 		// free hash table
; 1460 : 		delete[] m_pHashTable;
; 1461 : 		m_pHashTable = NULL;
; 1462 : 	}
; 1463 : 
; 1464 : 	m_nCount = 0;
; 1465 : 	m_pFreeList = NULL;
; 1466 : 	m_pBlocks->FreeDataChain();
; 1467 : 	m_pBlocks = NULL;
; 1468 : }
; 1469 : 
; 1470 : template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
; 1471 : CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::~CMap()
; 1472 : {
; 1473 : 	RemoveAll();
; 1474 : 	ASSERT(m_nCount == 0);
; 1475 : }
; 1476 : 
; 1477 : template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
; 1478 : typename CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CAssoc*
; 1479 : CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::NewAssoc(ARG_KEY key)
; 1480 : {
; 1481 : 	if (m_pFreeList == NULL)
; 1482 : 	{
; 1483 : 		// add another block
; 1484 : 		CPlex* newBlock = CPlex::Create(m_pBlocks, m_nBlockSize, sizeof(CMap::CAssoc));
; 1485 : 		// chain them into free list
; 1486 : 		CMap::CAssoc* pAssoc = (CMap::CAssoc*) newBlock->data();
; 1487 : 		// free in reverse order to make it easier to debug
; 1488 : 		pAssoc += m_nBlockSize - 1;
; 1489 : 		for (INT_PTR i = m_nBlockSize-1; i >= 0; i--, pAssoc--)
; 1490 : 		{
; 1491 : 			pAssoc->pNext = m_pFreeList;
; 1492 : 			m_pFreeList = pAssoc;
; 1493 : 		}
; 1494 : 	}
; 1495 : 	ENSURE(m_pFreeList != NULL);  // we must have something
; 1496 : 
; 1497 : 	CMap::CAssoc* pAssoc = m_pFreeList;
; 1498 : 
; 1499 : 	// zero the memory
; 1500 : 	CMap::CAssoc* pTemp = pAssoc->pNext;
; 1501 : 	memset( pAssoc, 0, sizeof(CMap::CAssoc) );
; 1502 : 	pAssoc->pNext = pTemp;
; 1503 : 
; 1504 : 	m_pFreeList = m_pFreeList->pNext;
; 1505 : 	m_nCount++;
; 1506 : 	ASSERT(m_nCount > 0);  // make sure we don't overflow
; 1507 : #pragma push_macro("new")
; 1508 : #undef new
; 1509 : 	::new(pAssoc) CMap::CAssoc(key);
; 1510 : #pragma pop_macro("new")
; 1511 : 	return pAssoc;
; 1512 : }
; 1513 : 
; 1514 : template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
; 1515 : void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::FreeAssoc(CAssoc* pAssoc)
; 1516 : {
; 1517 : 	pAssoc->CAssoc::~CAssoc();
; 1518 : 	pAssoc->pNext = m_pFreeList;
; 1519 : 	m_pFreeList = pAssoc;
; 1520 : 	m_nCount--;
; 1521 : 	ASSERT(m_nCount >= 0);  // make sure we don't underflow
; 1522 : 
; 1523 : 	// if no more elements, cleanup completely
; 1524 : 	if (m_nCount == 0)
; 1525 : 		RemoveAll();
; 1526 : }
; 1527 : 
; 1528 : template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
; 1529 : typename CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CAssoc*
; 1530 : CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetAssocAt(ARG_KEY key, UINT& nHashBucket, UINT& nHashValue) const
; 1531 : // find association (or return NULL)
; 1532 : {
; 1533 : 	nHashValue = HashKey<ARG_KEY>(key);
; 1534 : 	nHashBucket = nHashValue % m_nHashTableSize;

  000a6	8b 5d 0c	 mov	 ebx, DWORD PTR _mapList$[ebp]
  000a9	33 d2		 xor	 edx, edx
  000ab	8b c6		 mov	 eax, esi
  000ad	f7 73 08	 div	 DWORD PTR [ebx+8]

; 1537 : 		return NULL;
; 1538 : 
; 1539 : 	// see if it exists
; 1540 : 	CAssoc* pAssoc;
; 1541 : 	for (pAssoc = m_pHashTable[nHashBucket]; pAssoc != NULL; pAssoc = pAssoc->pNext)

  000b0	8b 5d ec	 mov	 ebx, DWORD PTR _key$1$[ebp]
  000b3	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  000b6	85 c0		 test	 eax, eax
  000b8	74 25		 je	 SHORT $LN51@FillShowLi
  000ba	66 0f 1f 44 00
	00		 npad	 6
$LL20@FillShowLi:

; 1542 : 	{
; 1543 : 		if (pAssoc->nHashValue == nHashValue && CompareElements(&pAssoc->key, &key))

  000c0	39 70 0c	 cmp	 DWORD PTR [eax+12], esi
  000c3	75 04		 jne	 SHORT $LN18@FillShowLi

; 156  : 	return *pElement1 == *pElement2;

  000c5	39 18		 cmp	 DWORD PTR [eax], ebx

; 1543 : 		if (pAssoc->nHashValue == nHashValue && CompareElements(&pAssoc->key, &key))

  000c7	74 09		 je	 SHORT $LN17@FillShowLi
$LN18@FillShowLi:

; 1537 : 		return NULL;
; 1538 : 
; 1539 : 	// see if it exists
; 1540 : 	CAssoc* pAssoc;
; 1541 : 	for (pAssoc = m_pHashTable[nHashBucket]; pAssoc != NULL; pAssoc = pAssoc->pNext)

  000c9	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000cc	85 c0		 test	 eax, eax
  000ce	75 f0		 jne	 SHORT $LL20@FillShowLi
  000d0	eb 0d		 jmp	 SHORT $LN51@FillShowLi
$LN17@FillShowLi:

; 1559 : 	rValue = pAssoc->value;

  000d2	83 c0 04	 add	 eax, 4
  000d5	8d 4d f0	 lea	 ecx, DWORD PTR _strFieldName$[ebp]
  000d8	50		 push	 eax
  000d9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
$LN51@FillShowLi:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl

; 725  : 	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_ADDSTRING, 0, (LPARAM)lpszItem); }

  000df	ff 75 f0	 push	 DWORD PTR _strFieldName$[ebp]
  000e2	8b 5d e8	 mov	 ebx, DWORD PTR _this$1$[ebp]
  000e5	6a 00		 push	 0
  000e7	68 80 01 00 00	 push	 384			; 00000180H
  000ec	ff b3 68 01 00
	00		 push	 DWORD PTR [ebx+360]
  000f2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 395  : 	for(int i=0; i< arrayList.GetSize(); i++)

  000f8	8b 4d 08	 mov	 ecx, DWORD PTR _arrayList$[ebp]
  000fb	47		 inc	 edi
  000fc	be 1d f3 01 00	 mov	 esi, 127773		; 0001f31dH
  00101	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00104	3b f8		 cmp	 edi, eax
  00106	0f 8c 5b ff ff
	ff		 jl	 $LL4@FillShowLi
$LN3@FillShowLi:

; 396  : 	{
; 397  : 		nIdx = arrayList.GetAt(i);
; 398  : 		mapList.Lookup(nIdx,strFieldName);
; 399  : 		m_listShow.AddString(strFieldName);
; 400  : 	}
; 401  : 
; 402  : 	if(!m_bApply)

  0010c	83 bb a8 00 00
	00 00		 cmp	 DWORD PTR [ebx+168], 0
  00113	75 1c		 jne	 SHORT $LN5@FillShowLi

; 403  : 	{
; 404  : 		m_bApply = TRUE;
; 405  : 		GetDlgItem(IDC_APPLY)->EnableWindow(m_bApply);

  00115	6a 01		 push	 1
  00117	6a 03		 push	 3
  00119	8b cb		 mov	 ecx, ebx
  0011b	c7 83 a8 00 00
	00 01 00 00 00	 mov	 DWORD PTR [ebx+168], 1
  00125	e8 00 00 00 00	 call	 ?GetDlgItem@CWnd@@QBEPAV1@H@Z ; CWnd::GetDlgItem
  0012a	8b c8		 mov	 ecx, eax
  0012c	e8 00 00 00 00	 call	 ?EnableWindow@CWnd@@QAEHH@Z ; CWnd::EnableWindow
$LN5@FillShowLi:

; 407  : }

  00131	8d 4d f0	 lea	 ecx, DWORD PTR _strFieldName$[ebp]
  00134	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0013a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0013d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00144	59		 pop	 ecx
  00145	5f		 pop	 edi
  00146	5e		 pop	 esi
  00147	5b		 pop	 ebx
  00148	8b e5		 mov	 esp, ebp
  0014a	5d		 pop	 ebp
  0014b	c2 08 00	 ret	 8
$LN11@FillShowLi:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 290  : 	AfxThrowInvalidArgException();

  0014e	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN53@FillShowLi:
  00153	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?FillShowList@CDlgSettingToolBar@@AAEXAAV?$CArray@HH@@AAV?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@@Z$0:
  00000	8d 4d f0	 lea	 ecx, DWORD PTR _strFieldName$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
  0000d	cc		 int	 3
__ehhandler$?FillShowList@CDlgSettingToolBar@@AAEXAAV?$CArray@HH@@AAV?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@@Z:
  0000e	90		 npad	 1
  0000f	90		 npad	 1
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?FillShowList@CDlgSettingToolBar@@AAEXAAV?$CArray@HH@@AAV?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@@Z
  00026	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?FillShowList@CDlgSettingToolBar@@AAEXAAV?$CArray@HH@@AAV?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@@Z ENDP ; CDlgSettingToolBar::FillShowList
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
;	COMDAT ?ReadIniFile@CDlgSettingToolBar@@AAEXH@Z
_TEXT	SEGMENT
_FileFind$ = -144					; size = 28
_szIndex$ = -116					; size = 4
_szFieldKey$ = -112					; size = 4
_nHashValue$6 = -108					; size = 4
_strTemp$ = -104					; size = 4
_nColCount$3$ = -100					; size = 4
_nColCount$2$ = -100					; size = 4
_nHashBucket$7 = -100					; size = 4
_strPath$ = -96						; size = 4
_strUserPath$ = -92					; size = 4
_strDataPath$ = -88					; size = 4
_szColNum$ = -84					; size = 4
_szFieldName$ = -80					; size = 4
tv2149 = -76						; size = 4
tv2148 = -76						; size = 4
_i$1$ = -76						; size = 4
$T8 = -72						; size = 4
$T9 = -72						; size = 4
$T10 = -72						; size = 4
_strConfigPath$ = -68					; size = 4
_nHashBucket$1$ = -64					; size = 4
_nIndex$1$ = -64					; size = 4
_nHashBucket$1$ = -64					; size = 4
_nIndex$1$ = -64					; size = 4
_nColCount$1$ = -64					; size = 4
_nFieldKey$ = -60					; size = 4
_nHashSize$1$ = -56					; size = 4
_pAssoc$1$ = -56					; size = 4
_nIndex$1$ = -56					; size = 4
_i$1$ = -56						; size = 4
_i$1$ = -56						; size = 4
_szColInfo$ = -52					; size = 4
_szKey$ = -48						; size = 30
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_nCulSel$ = 8						; size = 4
?ReadIniFile@CDlgSettingToolBar@@AAEXH@Z PROC		; CDlgSettingToolBar::ReadIniFile, COMDAT
; _this$ = ecx

; 191  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?ReadIniFile@CDlgSettingToolBar@@AAEXH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 84 00 00
	00		 sub	 esp, 132		; 00000084H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	56		 push	 esi
  00022	57		 push	 edi
  00023	50		 push	 eax
  00024	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00027	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002d	8b f1		 mov	 esi, ecx

; 192  : 
; 193  : 	int nID = 21;
; 194  : 	IMainInfoManager* pMng = (IMainInfoManager*)m_pGMng->GetInterface(nID);

  0002f	8b 86 3c 01 00
	00		 mov	 eax, DWORD PTR [esi+316]
  00035	6a 00		 push	 0
  00037	6a 15		 push	 21			; 00000015H
  00039	50		 push	 eax
  0003a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003c	ff 11		 call	 DWORD PTR [ecx]

; 195  : 	
; 196  : 	CFileFind FileFind;

  0003e	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR _FileFind$[ebp]
  00044	8b f8		 mov	 edi, eax
  00046	e8 00 00 00 00	 call	 ??0CFileFind@@QAE@XZ	; CFileFind::CFileFind

; 197  : 	CString strPath, strDataPath, strUserPath, strConfigPath, strTemp;

  0004b	8d 4d a0	 lea	 ecx, DWORD PTR _strPath$[ebp]
  0004e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0005b	8d 4d a8	 lea	 ecx, DWORD PTR _strDataPath$[ebp]
  0005e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00064	8d 4d a4	 lea	 ecx, DWORD PTR _strUserPath$[ebp]
  00067	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0006d	8d 4d bc	 lea	 ecx, DWORD PTR _strConfigPath$[ebp]
  00070	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00076	8d 4d 98	 lea	 ecx, DWORD PTR _strTemp$[ebp]
  00079	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 198  : 	char szKey[30];
; 199  : 
; 200  : 	//# User Folder
; 201  : 	strPath = pMng->GetEncUserDir();

  0007f	8b 07		 mov	 eax, DWORD PTR [edi]
  00081	6a 00		 push	 0
  00083	57		 push	 edi
  00084	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  00088	ff 50 18	 call	 DWORD PTR [eax+24]
  0008b	50		 push	 eax
  0008c	8d 4d a0	 lea	 ecx, DWORD PTR _strPath$[ebp]
  0008f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z

; 202  : 	strPath += "\\Chart";

  00095	68 00 00 00 00	 push	 OFFSET ??_C@_06DJNEHHKG@?2Chart@
  0009a	8d 4d a0	 lea	 ecx, DWORD PTR _strPath$[ebp]
  0009d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z

; 203  : 	//strPath = ((CStdDialog*)m_pMultiChartWnd)->m_strUserDir;
; 204  : 	strUserPath.Format("%s\\%s", strPath, "ChartToolBarSetting.dat");

  000a3	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@OIIEJFGC@ChartToolBarSetting?4dat@
  000a8	ff 75 a0	 push	 DWORD PTR _strPath$[ebp]
  000ab	8d 45 a4	 lea	 eax, DWORD PTR _strUserPath$[ebp]
  000ae	68 00 00 00 00	 push	 OFFSET ??_C@_05BMGBEOOC@?$CFs?2?$CFs@
  000b3	50		 push	 eax
  000b4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Format@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAAXPBDZZ

; 205  : 	//# Data Folder
; 206  : 	strPath = pMng->GetDataDir();

  000ba	8b 07		 mov	 eax, DWORD PTR [edi]
  000bc	83 c4 10	 add	 esp, 16			; 00000010H
  000bf	57		 push	 edi
  000c0	ff 50 14	 call	 DWORD PTR [eax+20]
  000c3	50		 push	 eax
  000c4	8d 4d a0	 lea	 ecx, DWORD PTR _strPath$[ebp]
  000c7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z

; 207  : 	strDataPath.Format("%s\\%s", strPath, "ChartToolBarSetting.dat");	

  000cd	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@OIIEJFGC@ChartToolBarSetting?4dat@
  000d2	ff 75 a0	 push	 DWORD PTR _strPath$[ebp]
  000d5	8d 45 a8	 lea	 eax, DWORD PTR _strDataPath$[ebp]
  000d8	68 00 00 00 00	 push	 OFFSET ??_C@_05BMGBEOOC@?$CFs?2?$CFs@
  000dd	50		 push	 eax
  000de	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Format@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAAXPBDZZ

; 208  : 
; 209  : 	//# Version
; 210  : 	int nUserCnt, nDataCnt, nUserVer, nDataVer;
; 211  : 	sprintf(szKey,"%s","TOTAL");

  000e4	68 00 00 00 00	 push	 OFFSET ??_C@_05GKHKKECO@TOTAL@
  000e9	8d 45 d0	 lea	 eax, DWORD PTR _szKey$[ebp]
  000ec	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  000f1	50		 push	 eax
  000f2	e8 00 00 00 00	 call	 _sprintf
  000f7	83 c4 1c	 add	 esp, 28			; 0000001cH

; 212  : 	m_nDataVer = ::GetPrivateProfileInt(szKey, "VERSION", -1, strDataPath);

  000fa	8d 45 d0	 lea	 eax, DWORD PTR _szKey$[ebp]
  000fd	ff 75 a8	 push	 DWORD PTR _strDataPath$[ebp]
  00100	6a ff		 push	 -1
  00102	68 00 00 00 00	 push	 OFFSET ??_C@_07NCHCCDCP@VERSION@
  00107	50		 push	 eax
  00108	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16

; 213  : 
; 214  : 	if (!FileFind.FindFile(strUserPath) || nCulSel != 3 )		//# Data 

  0010e	6a 00		 push	 0
  00110	ff 75 a4	 push	 DWORD PTR _strUserPath$[ebp]
  00113	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR _FileFind$[ebp]
  00119	89 86 40 01 00
	00		 mov	 DWORD PTR [esi+320], eax
  0011f	e8 00 00 00 00	 call	 ?FindFile@CFileFind@@UAEHPBDK@Z ; CFileFind::FindFile
  00124	8b 7d 08	 mov	 edi, DWORD PTR _nCulSel$[ebp]
  00127	85 c0		 test	 eax, eax
  00129	74 76		 je	 SHORT $LN13@ReadIniFil
  0012b	83 ff 03	 cmp	 edi, 3
  0012e	75 71		 jne	 SHORT $LN13@ReadIniFil

; 217  : 	}
; 218  : 	else										//# User 
; 219  : 	{
; 220  : 		//# Count
; 221  : 		nUserCnt	= ::GetPrivateProfileInt(szKey, "COUNT", -1, strDataPath);

  00130	ff 75 a8	 push	 DWORD PTR _strDataPath$[ebp]
  00133	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetPrivateProfileIntA@16
  00139	8d 45 d0	 lea	 eax, DWORD PTR _szKey$[ebp]
  0013c	6a ff		 push	 -1
  0013e	68 00 00 00 00	 push	 OFFSET ??_C@_05EFFCCOAM@COUNT@
  00143	50		 push	 eax
  00144	ff d7		 call	 edi

; 222  : 		nDataCnt	= ::GetPrivateProfileInt(szKey, "COUNT", -1, strUserPath);

  00146	ff 75 a4	 push	 DWORD PTR _strUserPath$[ebp]
  00149	8d 45 d0	 lea	 eax, DWORD PTR _szKey$[ebp]
  0014c	6a ff		 push	 -1
  0014e	68 00 00 00 00	 push	 OFFSET ??_C@_05EFFCCOAM@COUNT@
  00153	50		 push	 eax
  00154	ff d7		 call	 edi

; 223  : 		//# Version
; 224  : 		nUserVer = ::GetPrivateProfileInt(szKey, "VERSION", -1, strDataPath);	

  00156	ff 75 a8	 push	 DWORD PTR _strDataPath$[ebp]
  00159	8d 45 d0	 lea	 eax, DWORD PTR _szKey$[ebp]
  0015c	6a ff		 push	 -1
  0015e	68 00 00 00 00	 push	 OFFSET ??_C@_07NCHCCDCP@VERSION@
  00163	50		 push	 eax
  00164	ff d7		 call	 edi

; 225  : 		nDataVer = ::GetPrivateProfileInt(szKey, "VERSION", -1, strUserPath);

  00166	ff 75 a4	 push	 DWORD PTR _strUserPath$[ebp]
  00169	8b f8		 mov	 edi, eax
  0016b	8d 45 d0	 lea	 eax, DWORD PTR _szKey$[ebp]
  0016e	6a ff		 push	 -1
  00170	68 00 00 00 00	 push	 OFFSET ??_C@_07NCHCCDCP@VERSION@
  00175	50		 push	 eax
  00176	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16

; 226  : 
; 227  : 		if(nUserVer != nDataVer)

  0017c	8d 4d bc	 lea	 ecx, DWORD PTR _strConfigPath$[ebp]
  0017f	3b f8		 cmp	 edi, eax
  00181	74 0f		 je	 SHORT $LN14@ReadIniFil

; 228  : 			strConfigPath = strDataPath;

  00183	8d 45 a8	 lea	 eax, DWORD PTR _strDataPath$[ebp]
  00186	50		 push	 eax
  00187	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
  0018d	8b 7d 08	 mov	 edi, DWORD PTR _nCulSel$[ebp]
  00190	eb 26		 jmp	 SHORT $LN15@ReadIniFil
$LN14@ReadIniFil:

; 229  : 		else // 
; 230  : 			strConfigPath = strUserPath;

  00192	8d 45 a4	 lea	 eax, DWORD PTR _strUserPath$[ebp]
  00195	50		 push	 eax
  00196	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
  0019c	8b 7d 08	 mov	 edi, DWORD PTR _nCulSel$[ebp]
  0019f	eb 17		 jmp	 SHORT $LN15@ReadIniFil
$LN13@ReadIniFil:

; 215  : 	{
; 216  : 		strTemp = strConfigPath = strDataPath;		

  001a1	8d 45 a8	 lea	 eax, DWORD PTR _strDataPath$[ebp]
  001a4	50		 push	 eax
  001a5	8d 4d bc	 lea	 ecx, DWORD PTR _strConfigPath$[ebp]
  001a8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
  001ae	50		 push	 eax
  001af	8d 4d 98	 lea	 ecx, DWORD PTR _strTemp$[ebp]
  001b2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
$LN15@ReadIniFil:

; 231  : 	}
; 232  : 
; 233  : 	CString szIndex, szColNum, szColInfo, szFieldKey, szFieldName;

  001b8	8d 4d 8c	 lea	 ecx, DWORD PTR _szIndex$[ebp]
  001bb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  001c1	8d 4d ac	 lea	 ecx, DWORD PTR _szColNum$[ebp]
  001c4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  001ca	8d 4d cc	 lea	 ecx, DWORD PTR _szColInfo$[ebp]
  001cd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  001d3	8d 4d 90	 lea	 ecx, DWORD PTR _szFieldKey$[ebp]
  001d6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  001dc	8d 4d b0	 lea	 ecx, DWORD PTR _szFieldName$[ebp]
  001df	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  001e5	c6 45 fc 0a	 mov	 BYTE PTR __$EHRec$[ebp+8], 10 ; 0000000aH

; 234  : 	int nColCount, nFieldKey;;
; 235  : 
; 236  : 	//************************************************
; 237  : 	//  
; 238  : 	//************************************************
; 239  : 	if(1 == nCulSel || 3 == nCulSel)

  001e9	83 ff 01	 cmp	 edi, 1
  001ec	74 09		 je	 SHORT $LN17@ReadIniFil
  001ee	83 ff 03	 cmp	 edi, 3
  001f1	0f 85 1d 02 00
	00		 jne	 $LN304@ReadIniFil
$LN17@ReadIniFil:

; 240  : 	{
; 241  : 		sprintf(szKey,"%s","ANAL LIST");

  001f7	68 00 00 00 00	 push	 OFFSET ??_C@_09NBFPFBIM@ANAL?5LIST@
  001fc	8d 45 d0	 lea	 eax, DWORD PTR _szKey$[ebp]
  001ff	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  00204	50		 push	 eax
  00205	e8 00 00 00 00	 call	 _sprintf
  0020a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 242  : 		nColCount = ::GetPrivateProfileInt(szKey, "COUNT", -1, strConfigPath);

  0020d	8d 45 d0	 lea	 eax, DWORD PTR _szKey$[ebp]
  00210	ff 75 bc	 push	 DWORD PTR _strConfigPath$[ebp]
  00213	6a ff		 push	 -1
  00215	68 00 00 00 00	 push	 OFFSET ??_C@_05EFFCCOAM@COUNT@
  0021a	50		 push	 eax
  0021b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  00221	8b c8		 mov	 ecx, eax

; 244  : 		for(int i=0;i < nColCount; i++)

  00223	33 c0		 xor	 eax, eax
  00225	89 4d c0	 mov	 DWORD PTR _nColCount$1$[ebp], ecx
  00228	89 45 b4	 mov	 DWORD PTR _i$1$[ebp], eax
  0022b	85 c9		 test	 ecx, ecx
  0022d	0f 8e e1 01 00
	00		 jle	 $LN304@ReadIniFil
$LL4@ReadIniFil:

; 245  : 		{
; 246  : 			szColNum.Format("%02d", i);

  00233	50		 push	 eax
  00234	8d 45 ac	 lea	 eax, DWORD PTR _szColNum$[ebp]
  00237	68 00 00 00 00	 push	 OFFSET ??_C@_04OGKJMPGK@?$CF02d@
  0023c	50		 push	 eax
  0023d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Format@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAAXPBDZZ
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h

; 377  : 		return( m_pszData );

  00243	8b 7d ac	 mov	 edi, DWORD PTR _szColNum$[ebp]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 247  : 			::GetPrivateProfileString(szKey, szColNum, "", szColInfo.GetBuffer(MAX_PATH), MAX_PATH, strConfigPath);	

  00246	8d 4d cc	 lea	 ecx, DWORD PTR _szColInfo$[ebp]
  00249	83 c4 0c	 add	 esp, 12			; 0000000cH
  0024c	ff 75 bc	 push	 DWORD PTR _strConfigPath$[ebp]
  0024f	68 04 01 00 00	 push	 260			; 00000104H
  00254	68 04 01 00 00	 push	 260			; 00000104H
  00259	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetBuffer@?$CSimpleStringT@D$00@ATL@@QAEPADH@Z
  0025f	50		 push	 eax
  00260	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@@
  00265	57		 push	 edi
  00266	8d 45 d0	 lea	 eax, DWORD PTR _szKey$[ebp]
  00269	50		 push	 eax
  0026a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileStringA@24

; 248  : 			szColInfo.ReleaseBuffer();

  00270	6a ff		 push	 -1
  00272	8d 4d cc	 lea	 ecx, DWORD PTR _szColInfo$[ebp]
  00275	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?ReleaseBuffer@?$CSimpleStringT@D$00@ATL@@QAEXH@Z
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h

; 519  : 		return( GetData()->nDataLength );

  0027b	8b 45 cc	 mov	 eax, DWORD PTR _szColInfo$[ebp]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 250  : 			if (szColInfo.GetLength() == 0)

  0027e	83 78 f4 00	 cmp	 DWORD PTR [eax-12], 0
  00282	0f 84 79 01 00
	00		 je	 $LN2@ReadIniFil

; 251  : 				continue;
; 252  : 
; 253  : 			GetFieldData(szColInfo, nFieldKey, szFieldName);

  00288	8d 45 b0	 lea	 eax, DWORD PTR _szFieldName$[ebp]
  0028b	50		 push	 eax
  0028c	8d 45 c4	 lea	 eax, DWORD PTR _nFieldKey$[ebp]
  0028f	50		 push	 eax
  00290	51		 push	 ecx
  00291	8d 45 cc	 lea	 eax, DWORD PTR _szColInfo$[ebp]
  00294	8b cc		 mov	 ecx, esp
  00296	50		 push	 eax
  00297	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z
  0029d	8b ce		 mov	 ecx, esi
  0029f	e8 00 00 00 00	 call	 ?GetFieldData@CDlgSettingToolBar@@AAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAHAAV23@@Z ; CDlgSettingToolBar::GetFieldData
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 333  : 	{ INT_PTR nIndex = m_nSize;

  002a4	8b 86 b4 00 00
	00		 mov	 eax, DWORD PTR [esi+180]
  002aa	89 45 c8	 mov	 DWORD PTR _nIndex$1$[ebp], eax

; 538  : 	if(nIndex < 0)

  002ad	85 c0		 test	 eax, eax
  002af	0f 88 f9 06 00
	00		 js	 $LN261@ReadIniFil

; 539  : 		AfxThrowInvalidArgException();
; 540  : 
; 541  : 	if (nIndex >= m_nSize)
; 542  : 		SetSize(nIndex+1, -1);

  002b5	6a ff		 push	 -1
  002b7	40		 inc	 eax
  002b8	8d 8e ac 00 00
	00		 lea	 ecx, DWORD PTR [esi+172]
  002be	50		 push	 eax
  002bf	e8 00 00 00 00	 call	 ?SetSize@?$CArray@HH@@QAEXHH@Z ; CArray<int,int>::SetSize

; 543  : 	m_pData[nIndex] = newElement;

  002c4	8b 86 b0 00 00
	00		 mov	 eax, DWORD PTR [esi+176]
  002ca	8b 4d c8	 mov	 ecx, DWORD PTR _nIndex$1$[ebp]
  002cd	8b 55 c4	 mov	 edx, DWORD PTR _nFieldKey$[ebp]
  002d0	89 14 88	 mov	 DWORD PTR [eax+ecx*4], edx
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 256  : 			m_mapAnalList.SetAt(nFieldKey, szFieldName);

  002d3	8d 45 b0	 lea	 eax, DWORD PTR _szFieldName$[ebp]
  002d6	50		 push	 eax
  002d7	8d 4d b8	 lea	 ecx, DWORD PTR $T10[ebp]
  002da	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z
  002e0	8d be e8 00 00
	00		 lea	 edi, DWORD PTR [esi+232]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 1590 : 	if ((pAssoc = GetAssocAt(key, nHashBucket, nHashValue)) == NULL)

  002e6	8d 45 94	 lea	 eax, DWORD PTR _nHashValue$6[ebp]

; 1350 : 	{ (*this)[key] = newValue; }

  002e9	c6 45 fc 0b	 mov	 BYTE PTR __$EHRec$[ebp+8], 11 ; 0000000bH

; 1590 : 	if ((pAssoc = GetAssocAt(key, nHashBucket, nHashValue)) == NULL)

  002ed	50		 push	 eax
  002ee	8d 45 9c	 lea	 eax, DWORD PTR _nHashBucket$7[ebp]
  002f1	8b cf		 mov	 ecx, edi
  002f3	50		 push	 eax
  002f4	ff 75 c4	 push	 DWORD PTR _nFieldKey$[ebp]
  002f7	e8 00 00 00 00	 call	 ?GetAssocAt@?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@IBEPAVCAssoc@1@HAAI0@Z ; CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >::GetAssocAt
  002fc	8b d0		 mov	 edx, eax
  002fe	85 d2		 test	 edx, edx
  00300	0f 85 e1 00 00
	00		 jne	 $LN80@ReadIniFil

; 1591 : 	{
; 1592 : 		if (m_pHashTable == NULL)

  00306	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00309	85 c0		 test	 eax, eax
  0030b	75 4d		 jne	 SHORT $LN314@ReadIniFil

; 1593 : 			InitHashTable(m_nHashTableSize);

  0030d	8b 47 08	 mov	 eax, DWORD PTR [edi+8]

; 1434 : 		m_pHashTable = new CAssoc* [nHashSize];

  00310	33 c9		 xor	 ecx, ecx

; 1593 : 			InitHashTable(m_nHashTableSize);

  00312	89 45 c8	 mov	 DWORD PTR _nHashSize$1$[ebp], eax

; 1434 : 		m_pHashTable = new CAssoc* [nHashSize];

  00315	ba 04 00 00 00	 mov	 edx, 4
  0031a	f7 e2		 mul	 edx
  0031c	0f 90 c1	 seto	 cl
  0031f	f7 d9		 neg	 ecx
  00321	0b c8		 or	 ecx, eax
  00323	51		 push	 ecx
  00324	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00329	83 c4 04	 add	 esp, 4
  0032c	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 1435 : 		ENSURE(m_pHashTable != NULL);

  0032f	85 c0		 test	 eax, eax
  00331	0f 84 77 06 00
	00		 je	 $LN261@ReadIniFil

; 1436 : 		memset(m_pHashTable, 0, sizeof(CAssoc*) * nHashSize);

  00337	8b 4d c8	 mov	 ecx, DWORD PTR _nHashSize$1$[ebp]
  0033a	c1 e1 02	 shl	 ecx, 2
  0033d	51		 push	 ecx
  0033e	6a 00		 push	 0
  00340	50		 push	 eax
  00341	e8 00 00 00 00	 call	 _memset

; 1437 : 	}
; 1438 : 	m_nHashTableSize = nHashSize;

  00346	8b 45 c8	 mov	 eax, DWORD PTR _nHashSize$1$[ebp]
  00349	83 c4 0c	 add	 esp, 12			; 0000000cH
  0034c	89 47 08	 mov	 DWORD PTR [edi+8], eax
  0034f	8b 47 04	 mov	 eax, DWORD PTR [edi+4]

; 1595 : 		ENSURE(m_pHashTable);

  00352	85 c0		 test	 eax, eax
  00354	0f 84 54 06 00
	00		 je	 $LN261@ReadIniFil
$LN314@ReadIniFil:

; 1481 : 	if (m_pFreeList == NULL)

  0035a	83 7f 10 00	 cmp	 DWORD PTR [edi+16], 0
  0035e	75 31		 jne	 SHORT $LN99@ReadIniFil

; 1482 : 	{
; 1483 : 		// add another block
; 1484 : 		CPlex* newBlock = CPlex::Create(m_pBlocks, m_nBlockSize, sizeof(CMap::CAssoc));

  00360	6a 10		 push	 16			; 00000010H
  00362	ff 77 18	 push	 DWORD PTR [edi+24]
  00365	8d 47 14	 lea	 eax, DWORD PTR [edi+20]
  00368	50		 push	 eax
  00369	e8 00 00 00 00	 call	 ?Create@CPlex@@SGPAU1@AAPAU1@II@Z ; CPlex::Create

; 1485 : 		// chain them into free list
; 1486 : 		CMap::CAssoc* pAssoc = (CMap::CAssoc*) newBlock->data();
; 1487 : 		// free in reverse order to make it easier to debug
; 1488 : 		pAssoc += m_nBlockSize - 1;

  0036e	8b 57 18	 mov	 edx, DWORD PTR [edi+24]
  00371	8b ca		 mov	 ecx, edx
  00373	c1 e1 04	 shl	 ecx, 4
  00376	83 c1 f8	 add	 ecx, -8			; fffffff8H
  00379	03 c8		 add	 ecx, eax

; 1489 : 		for (INT_PTR i = m_nBlockSize-1; i >= 0; i--, pAssoc--)

  0037b	83 c2 ff	 add	 edx, -1
  0037e	78 11		 js	 SHORT $LN99@ReadIniFil
$LL96@ReadIniFil:

; 1490 : 		{
; 1491 : 			pAssoc->pNext = m_pFreeList;

  00380	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00383	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1492 : 			m_pFreeList = pAssoc;

  00386	89 4f 10	 mov	 DWORD PTR [edi+16], ecx
  00389	83 e9 10	 sub	 ecx, 16			; 00000010H
  0038c	83 ea 01	 sub	 edx, 1
  0038f	79 ef		 jns	 SHORT $LL96@ReadIniFil
$LN99@ReadIniFil:

; 1493 : 		}
; 1494 : 	}
; 1495 : 	ENSURE(m_pFreeList != NULL);  // we must have something

  00391	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  00394	89 4d c8	 mov	 DWORD PTR _pAssoc$1$[ebp], ecx
  00397	85 c9		 test	 ecx, ecx
  00399	0f 84 0f 06 00
	00		 je	 $LN261@ReadIniFil

; 1496 : 
; 1497 : 	CMap::CAssoc* pAssoc = m_pFreeList;
; 1498 : 
; 1499 : 	// zero the memory
; 1500 : 	CMap::CAssoc* pTemp = pAssoc->pNext;

  0039f	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  003a2	0f 57 c0	 xorps	 xmm0, xmm0

; 1501 : 	memset( pAssoc, 0, sizeof(CMap::CAssoc) );

  003a5	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0

; 1502 : 	pAssoc->pNext = pTemp;

  003a8	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1503 : 
; 1504 : 	m_pFreeList = m_pFreeList->pNext;

  003ab	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  003ae	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 1505 : 	m_nCount++;

  003b1	ff 47 0c	 inc	 DWORD PTR [edi+12]
  003b4	89 47 10	 mov	 DWORD PTR [edi+16], eax

; 1256 : 		CPair( ARG_KEY keyval ) : key( keyval )	{}

  003b7	8b 45 c4	 mov	 eax, DWORD PTR _nFieldKey$[ebp]
  003ba	89 01		 mov	 DWORD PTR [ecx], eax
  003bc	83 c1 04	 add	 ecx, 4
  003bf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 1598 : 		pAssoc->nHashValue = nHashValue;

  003c5	8b 55 c8	 mov	 edx, DWORD PTR _pAssoc$1$[ebp]
  003c8	8b 45 94	 mov	 eax, DWORD PTR _nHashValue$6[ebp]
  003cb	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 1599 : 		//'pAssoc->value' is a constructed object, nothing more
; 1600 : 
; 1601 : 		// put into hash table
; 1602 : 		pAssoc->pNext = m_pHashTable[nHashBucket];

  003ce	8b 45 9c	 mov	 eax, DWORD PTR _nHashBucket$7[ebp]
  003d1	8d 0c 85 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*4]
  003d8	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  003db	8b 04 01	 mov	 eax, DWORD PTR [ecx+eax]
  003de	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 1603 : 		m_pHashTable[nHashBucket] = pAssoc;

  003e1	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  003e4	89 14 01	 mov	 DWORD PTR [ecx+eax], edx
$LN80@ReadIniFil:

; 1350 : 	{ (*this)[key] = newValue; }

  003e7	8d 45 b8	 lea	 eax, DWORD PTR $T10[ebp]

; 1605 : 	return pAssoc->value;  // return new reference

  003ea	8d 4a 04	 lea	 ecx, DWORD PTR [edx+4]

; 1350 : 	{ (*this)[key] = newValue; }

  003ed	50		 push	 eax
  003ee	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
  003f4	8d 4d b8	 lea	 ecx, DWORD PTR $T10[ebp]
  003f7	c6 45 fc 0a	 mov	 BYTE PTR __$EHRec$[ebp+8], 10 ; 0000000aH
  003fb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$LN2@ReadIniFil:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 244  : 		for(int i=0;i < nColCount; i++)

  00401	8b 45 b4	 mov	 eax, DWORD PTR _i$1$[ebp]
  00404	40		 inc	 eax
  00405	89 45 b4	 mov	 DWORD PTR _i$1$[ebp], eax
  00408	3b 45 c0	 cmp	 eax, DWORD PTR _nColCount$1$[ebp]
  0040b	0f 8c 22 fe ff
	ff		 jl	 $LL4@ReadIniFil
  00411	8b 7d 08	 mov	 edi, DWORD PTR _nCulSel$[ebp]
$LN304@ReadIniFil:

; 257  : 		}
; 258  : 	}
; 259  : 	
; 260  : 		
; 261  : 	//************************************************
; 262  : 	//  
; 263  : 	//************************************************
; 264  : 	if(2 == nCulSel || 3 == nCulSel)

  00414	83 ff 02	 cmp	 edi, 2
  00417	74 09		 je	 SHORT $LN20@ReadIniFil
  00419	83 ff 03	 cmp	 edi, 3
  0041c	0f 85 7d 02 00
	00		 jne	 $LN306@ReadIniFil
$LN20@ReadIniFil:

; 265  : 	{
; 266  : 		sprintf(szKey,"%s","ADDITION LIST");

  00422	68 00 00 00 00	 push	 OFFSET ??_C@_0O@PLHPCCBM@ADDITION?5LIST@
  00427	8d 45 d0	 lea	 eax, DWORD PTR _szKey$[ebp]
  0042a	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  0042f	50		 push	 eax
  00430	e8 00 00 00 00	 call	 _sprintf
  00435	83 c4 0c	 add	 esp, 12			; 0000000cH

; 267  : 		nColCount = ::GetPrivateProfileInt(szKey, "COUNT", -1, strConfigPath);

  00438	8d 45 d0	 lea	 eax, DWORD PTR _szKey$[ebp]
  0043b	ff 75 bc	 push	 DWORD PTR _strConfigPath$[ebp]
  0043e	6a ff		 push	 -1
  00440	68 00 00 00 00	 push	 OFFSET ??_C@_05EFFCCOAM@COUNT@
  00445	50		 push	 eax
  00446	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  0044c	8b c8		 mov	 ecx, eax

; 269  : 		for(int i=0;i < nColCount; i++)

  0044e	33 c0		 xor	 eax, eax
  00450	89 4d 9c	 mov	 DWORD PTR _nColCount$2$[ebp], ecx
  00453	89 45 c8	 mov	 DWORD PTR _i$1$[ebp], eax
  00456	85 c9		 test	 ecx, ecx
  00458	0f 8e 41 02 00
	00		 jle	 $LN306@ReadIniFil
  0045e	66 90		 npad	 2
$LL7@ReadIniFil:

; 270  : 		{
; 271  : 			szColNum.Format("%02d", i);

  00460	50		 push	 eax
  00461	8d 45 ac	 lea	 eax, DWORD PTR _szColNum$[ebp]
  00464	68 00 00 00 00	 push	 OFFSET ??_C@_04OGKJMPGK@?$CF02d@
  00469	50		 push	 eax
  0046a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Format@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAAXPBDZZ
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h

; 377  : 		return( m_pszData );

  00470	8b 7d ac	 mov	 edi, DWORD PTR _szColNum$[ebp]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 272  : 			::GetPrivateProfileString(szKey, szColNum, "", szColInfo.GetBuffer(MAX_PATH), MAX_PATH, strConfigPath);	

  00473	8d 4d cc	 lea	 ecx, DWORD PTR _szColInfo$[ebp]
  00476	83 c4 0c	 add	 esp, 12			; 0000000cH
  00479	ff 75 bc	 push	 DWORD PTR _strConfigPath$[ebp]
  0047c	68 04 01 00 00	 push	 260			; 00000104H
  00481	68 04 01 00 00	 push	 260			; 00000104H
  00486	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetBuffer@?$CSimpleStringT@D$00@ATL@@QAEPADH@Z
  0048c	50		 push	 eax
  0048d	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@@
  00492	57		 push	 edi
  00493	8d 45 d0	 lea	 eax, DWORD PTR _szKey$[ebp]
  00496	50		 push	 eax
  00497	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileStringA@24

; 273  : 			szColInfo.ReleaseBuffer();

  0049d	6a ff		 push	 -1
  0049f	8d 4d cc	 lea	 ecx, DWORD PTR _szColInfo$[ebp]
  004a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?ReleaseBuffer@?$CSimpleStringT@D$00@ATL@@QAEXH@Z
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h

; 519  : 		return( GetData()->nDataLength );

  004a8	8b 45 cc	 mov	 eax, DWORD PTR _szColInfo$[ebp]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 275  : 			if (szColInfo.GetLength() == 0)

  004ab	83 78 f4 00	 cmp	 DWORD PTR [eax-12], 0
  004af	0f 84 d7 01 00
	00		 je	 $LN5@ReadIniFil

; 276  : 				continue;
; 277  : 
; 278  : 			GetFieldData(szColInfo, nFieldKey, szFieldName);

  004b5	8d 45 b0	 lea	 eax, DWORD PTR _szFieldName$[ebp]
  004b8	50		 push	 eax
  004b9	8d 45 c4	 lea	 eax, DWORD PTR _nFieldKey$[ebp]
  004bc	50		 push	 eax
  004bd	51		 push	 ecx
  004be	8d 45 cc	 lea	 eax, DWORD PTR _szColInfo$[ebp]
  004c1	8b cc		 mov	 ecx, esp
  004c3	50		 push	 eax
  004c4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z
  004ca	8b ce		 mov	 ecx, esi
  004cc	e8 00 00 00 00	 call	 ?GetFieldData@CDlgSettingToolBar@@AAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAHAAV23@@Z ; CDlgSettingToolBar::GetFieldData
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 333  : 	{ INT_PTR nIndex = m_nSize;

  004d1	8b 86 c8 00 00
	00		 mov	 eax, DWORD PTR [esi+200]
  004d7	89 45 c0	 mov	 DWORD PTR _nIndex$1$[ebp], eax

; 538  : 	if(nIndex < 0)

  004da	85 c0		 test	 eax, eax
  004dc	0f 88 cc 04 00
	00		 js	 $LN261@ReadIniFil

; 539  : 		AfxThrowInvalidArgException();
; 540  : 
; 541  : 	if (nIndex >= m_nSize)
; 542  : 		SetSize(nIndex+1, -1);

  004e2	6a ff		 push	 -1
  004e4	40		 inc	 eax
  004e5	8d 8e c0 00 00
	00		 lea	 ecx, DWORD PTR [esi+192]
  004eb	50		 push	 eax
  004ec	e8 00 00 00 00	 call	 ?SetSize@?$CArray@HH@@QAEXHH@Z ; CArray<int,int>::SetSize

; 543  : 	m_pData[nIndex] = newElement;

  004f1	8b 86 c4 00 00
	00		 mov	 eax, DWORD PTR [esi+196]
  004f7	8b 4d c0	 mov	 ecx, DWORD PTR _nIndex$1$[ebp]
  004fa	8b 7d c4	 mov	 edi, DWORD PTR _nFieldKey$[ebp]
  004fd	89 3c 88	 mov	 DWORD PTR [eax+ecx*4], edi
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 281  : 			m_mapAdditionList.SetAt(nFieldKey, szFieldName);

  00500	8d 45 b0	 lea	 eax, DWORD PTR _szFieldName$[ebp]
  00503	50		 push	 eax
  00504	8d 4d b8	 lea	 ecx, DWORD PTR $T9[ebp]
  00507	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 165  : 	ldiv_t HashVal = ldiv((long)(ARG_KEY)key, 127773);

  0050d	8b c7		 mov	 eax, edi

; 1350 : 	{ (*this)[key] = newValue; }

  0050f	c6 45 fc 0c	 mov	 BYTE PTR __$EHRec$[ebp+8], 12 ; 0000000cH

; 165  : 	ldiv_t HashVal = ldiv((long)(ARG_KEY)key, 127773);

  00513	99		 cdq
  00514	b9 1d f3 01 00	 mov	 ecx, 127773		; 0001f31dH
  00519	f7 f9		 idiv	 ecx

; 1534 : 	nHashBucket = nHashValue % m_nHashTableSize;

  0051b	8b be 0c 01 00
	00		 mov	 edi, DWORD PTR [esi+268]

; 166  : 	HashVal.rem = 16807 * HashVal.rem - 2836 * HashVal.quot;

  00521	69 c0 14 0b 00
	00		 imul	 eax, eax, 2836
  00527	69 ca a7 41 00
	00		 imul	 ecx, edx, 16807
  0052d	2b c8		 sub	 ecx, eax

; 1534 : 	nHashBucket = nHashValue % m_nHashTableSize;

  0052f	8d 81 ff ff ff
	7f		 lea	 eax, DWORD PTR [ecx+2147483647]
  00535	0f 49 c1	 cmovns	 eax, ecx
  00538	33 d2		 xor	 edx, edx
  0053a	89 45 b4	 mov	 DWORD PTR tv2149[ebp], eax
  0053d	f7 f7		 div	 edi

; 1535 : 
; 1536 : 	if (m_pHashTable == NULL)

  0053f	8b 86 08 01 00
	00		 mov	 eax, DWORD PTR [esi+264]
  00545	8b ca		 mov	 ecx, edx
  00547	89 4d c0	 mov	 DWORD PTR _nHashBucket$1$[ebp], ecx
  0054a	85 c0		 test	 eax, eax
  0054c	75 51		 jne	 SHORT $LN140@ReadIniFil

; 1434 : 		m_pHashTable = new CAssoc* [nHashSize];

  0054e	33 c9		 xor	 ecx, ecx
  00550	8b c7		 mov	 eax, edi
  00552	ba 04 00 00 00	 mov	 edx, 4
  00557	f7 e2		 mul	 edx
  00559	0f 90 c1	 seto	 cl
  0055c	f7 d9		 neg	 ecx
  0055e	0b c8		 or	 ecx, eax
  00560	51		 push	 ecx
  00561	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00566	83 c4 04	 add	 esp, 4
  00569	89 86 08 01 00
	00		 mov	 DWORD PTR [esi+264], eax

; 1435 : 		ENSURE(m_pHashTable != NULL);

  0056f	85 c0		 test	 eax, eax
  00571	0f 84 37 04 00
	00		 je	 $LN261@ReadIniFil

; 1436 : 		memset(m_pHashTable, 0, sizeof(CAssoc*) * nHashSize);

  00577	8d 0c bd 00 00
	00 00		 lea	 ecx, DWORD PTR [edi*4]
  0057e	51		 push	 ecx
  0057f	6a 00		 push	 0
  00581	50		 push	 eax
  00582	e8 00 00 00 00	 call	 _memset
  00587	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1437 : 	}
; 1438 : 	m_nHashTableSize = nHashSize;

  0058a	89 be 0c 01 00
	00		 mov	 DWORD PTR [esi+268], edi

; 1595 : 		ENSURE(m_pHashTable);

  00590	83 be 08 01 00
	00 00		 cmp	 DWORD PTR [esi+264], 0
  00597	0f 84 11 04 00
	00		 je	 $LN261@ReadIniFil
  0059d	eb 25		 jmp	 SHORT $LN305@ReadIniFil
$LN140@ReadIniFil:

; 1541 : 	for (pAssoc = m_pHashTable[nHashBucket]; pAssoc != NULL; pAssoc = pAssoc->pNext)

  0059f	8b 3c 88	 mov	 edi, DWORD PTR [eax+ecx*4]
  005a2	85 ff		 test	 edi, edi
  005a4	74 1e		 je	 SHORT $LN305@ReadIniFil
  005a6	8b 45 b4	 mov	 eax, DWORD PTR tv2149[ebp]
  005a9	8b 4d c4	 mov	 ecx, DWORD PTR _nFieldKey$[ebp]
  005ac	0f 1f 40 00	 npad	 4
$LL139@ReadIniFil:

; 1542 : 	{
; 1543 : 		if (pAssoc->nHashValue == nHashValue && CompareElements(&pAssoc->key, &key))

  005b0	39 47 0c	 cmp	 DWORD PTR [edi+12], eax
  005b3	75 08		 jne	 SHORT $LN137@ReadIniFil
  005b5	39 0f		 cmp	 DWORD PTR [edi], ecx
  005b7	0f 84 b5 00 00
	00		 je	 $LN132@ReadIniFil
$LN137@ReadIniFil:

; 1537 : 		return NULL;
; 1538 : 
; 1539 : 	// see if it exists
; 1540 : 	CAssoc* pAssoc;
; 1541 : 	for (pAssoc = m_pHashTable[nHashBucket]; pAssoc != NULL; pAssoc = pAssoc->pNext)

  005bd	8b 7f 08	 mov	 edi, DWORD PTR [edi+8]
  005c0	85 ff		 test	 edi, edi
  005c2	75 ec		 jne	 SHORT $LL139@ReadIniFil
$LN305@ReadIniFil:

; 1481 : 	if (m_pFreeList == NULL)

  005c4	83 be 14 01 00
	00 00		 cmp	 DWORD PTR [esi+276], 0
  005cb	75 4a		 jne	 SHORT $LN170@ReadIniFil

; 1482 : 	{
; 1483 : 		// add another block
; 1484 : 		CPlex* newBlock = CPlex::Create(m_pBlocks, m_nBlockSize, sizeof(CMap::CAssoc));

  005cd	6a 10		 push	 16			; 00000010H
  005cf	ff b6 1c 01 00
	00		 push	 DWORD PTR [esi+284]
  005d5	8d 86 18 01 00
	00		 lea	 eax, DWORD PTR [esi+280]
  005db	50		 push	 eax
  005dc	e8 00 00 00 00	 call	 ?Create@CPlex@@SGPAU1@AAPAU1@II@Z ; CPlex::Create

; 1485 : 		// chain them into free list
; 1486 : 		CMap::CAssoc* pAssoc = (CMap::CAssoc*) newBlock->data();
; 1487 : 		// free in reverse order to make it easier to debug
; 1488 : 		pAssoc += m_nBlockSize - 1;

  005e1	8b 96 1c 01 00
	00		 mov	 edx, DWORD PTR [esi+284]
  005e7	8b ca		 mov	 ecx, edx
  005e9	c1 e1 04	 shl	 ecx, 4
  005ec	83 c1 f8	 add	 ecx, -8			; fffffff8H
  005ef	03 c8		 add	 ecx, eax

; 1489 : 		for (INT_PTR i = m_nBlockSize-1; i >= 0; i--, pAssoc--)

  005f1	83 c2 ff	 add	 edx, -1
  005f4	78 21		 js	 SHORT $LN170@ReadIniFil
  005f6	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL167@ReadIniFil:

; 1490 : 		{
; 1491 : 			pAssoc->pNext = m_pFreeList;

  00600	8b 86 14 01 00
	00		 mov	 eax, DWORD PTR [esi+276]
  00606	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1492 : 			m_pFreeList = pAssoc;

  00609	89 8e 14 01 00
	00		 mov	 DWORD PTR [esi+276], ecx
  0060f	83 e9 10	 sub	 ecx, 16			; 00000010H
  00612	83 ea 01	 sub	 edx, 1
  00615	79 e9		 jns	 SHORT $LL167@ReadIniFil
$LN170@ReadIniFil:

; 1493 : 		}
; 1494 : 	}
; 1495 : 	ENSURE(m_pFreeList != NULL);  // we must have something

  00617	8b be 14 01 00
	00		 mov	 edi, DWORD PTR [esi+276]
  0061d	85 ff		 test	 edi, edi
  0061f	0f 84 89 03 00
	00		 je	 $LN261@ReadIniFil

; 1496 : 
; 1497 : 	CMap::CAssoc* pAssoc = m_pFreeList;
; 1498 : 
; 1499 : 	// zero the memory
; 1500 : 	CMap::CAssoc* pTemp = pAssoc->pNext;

  00625	8b 47 08	 mov	 eax, DWORD PTR [edi+8]

; 1256 : 		CPair( ARG_KEY keyval ) : key( keyval )	{}

  00628	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  0062b	0f 57 c0	 xorps	 xmm0, xmm0

; 1501 : 	memset( pAssoc, 0, sizeof(CMap::CAssoc) );

  0062e	0f 11 07	 movups	 XMMWORD PTR [edi], xmm0

; 1502 : 	pAssoc->pNext = pTemp;

  00631	89 47 08	 mov	 DWORD PTR [edi+8], eax

; 1503 : 
; 1504 : 	m_pFreeList = m_pFreeList->pNext;

  00634	8b 86 14 01 00
	00		 mov	 eax, DWORD PTR [esi+276]
  0063a	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 1505 : 	m_nCount++;

  0063d	ff 86 10 01 00
	00		 inc	 DWORD PTR [esi+272]
  00643	89 86 14 01 00
	00		 mov	 DWORD PTR [esi+276], eax

; 1256 : 		CPair( ARG_KEY keyval ) : key( keyval )	{}

  00649	8b 45 c4	 mov	 eax, DWORD PTR _nFieldKey$[ebp]
  0064c	89 07		 mov	 DWORD PTR [edi], eax
  0064e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 1598 : 		pAssoc->nHashValue = nHashValue;

  00654	8b 45 b4	 mov	 eax, DWORD PTR tv2149[ebp]

; 1599 : 		//'pAssoc->value' is a constructed object, nothing more
; 1600 : 
; 1601 : 		// put into hash table
; 1602 : 		pAssoc->pNext = m_pHashTable[nHashBucket];

  00657	8b 4d c0	 mov	 ecx, DWORD PTR _nHashBucket$1$[ebp]
  0065a	89 47 0c	 mov	 DWORD PTR [edi+12], eax
  0065d	8b 86 08 01 00
	00		 mov	 eax, DWORD PTR [esi+264]
  00663	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
  00666	89 47 08	 mov	 DWORD PTR [edi+8], eax

; 1603 : 		m_pHashTable[nHashBucket] = pAssoc;

  00669	8b 86 08 01 00
	00		 mov	 eax, DWORD PTR [esi+264]
  0066f	89 3c 88	 mov	 DWORD PTR [eax+ecx*4], edi
$LN132@ReadIniFil:

; 1350 : 	{ (*this)[key] = newValue; }

  00672	8d 45 b8	 lea	 eax, DWORD PTR $T9[ebp]

; 1605 : 	return pAssoc->value;  // return new reference

  00675	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]

; 1350 : 	{ (*this)[key] = newValue; }

  00678	50		 push	 eax
  00679	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
  0067f	8d 4d b8	 lea	 ecx, DWORD PTR $T9[ebp]
  00682	c6 45 fc 0a	 mov	 BYTE PTR __$EHRec$[ebp+8], 10 ; 0000000aH
  00686	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$LN5@ReadIniFil:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 269  : 		for(int i=0;i < nColCount; i++)

  0068c	8b 45 c8	 mov	 eax, DWORD PTR _i$1$[ebp]
  0068f	40		 inc	 eax
  00690	89 45 c8	 mov	 DWORD PTR _i$1$[ebp], eax
  00693	3b 45 9c	 cmp	 eax, DWORD PTR _nColCount$2$[ebp]
  00696	0f 8c c4 fd ff
	ff		 jl	 $LL7@ReadIniFil
  0069c	8b 7d 08	 mov	 edi, DWORD PTR _nCulSel$[ebp]
$LN306@ReadIniFil:

; 282  : 		}
; 283  : 	}
; 284  : 	
; 285  : 	//************************************************
; 286  : 	//  
; 287  : 	//************************************************
; 288  : 	if(0 == nCulSel || 3 == nCulSel)

  0069f	85 ff		 test	 edi, edi
  006a1	74 09		 je	 SHORT $LN23@ReadIniFil
  006a3	83 ff 03	 cmp	 edi, 3
  006a6	0f 85 80 02 00
	00		 jne	 $LN308@ReadIniFil
$LN23@ReadIniFil:

; 289  : 	{
; 290  : 		sprintf(szKey,"%s","USER LIST");

  006ac	68 00 00 00 00	 push	 OFFSET ??_C@_09BBDODMFB@USER?5LIST@
  006b1	8d 45 d0	 lea	 eax, DWORD PTR _szKey$[ebp]
  006b4	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  006b9	50		 push	 eax
  006ba	e8 00 00 00 00	 call	 _sprintf
  006bf	83 c4 0c	 add	 esp, 12			; 0000000cH

; 291  : 		nColCount = ::GetPrivateProfileInt(szKey, "COUNT", -1, strConfigPath);

  006c2	8d 45 d0	 lea	 eax, DWORD PTR _szKey$[ebp]
  006c5	ff 75 bc	 push	 DWORD PTR _strConfigPath$[ebp]
  006c8	6a ff		 push	 -1
  006ca	68 00 00 00 00	 push	 OFFSET ??_C@_05EFFCCOAM@COUNT@
  006cf	50		 push	 eax
  006d0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  006d6	8b c8		 mov	 ecx, eax

; 293  : 		for(int i=0;i < nColCount; i++)

  006d8	33 c0		 xor	 eax, eax
  006da	89 4d 9c	 mov	 DWORD PTR _nColCount$3$[ebp], ecx
  006dd	89 45 c8	 mov	 DWORD PTR _i$1$[ebp], eax
  006e0	85 c9		 test	 ecx, ecx
  006e2	0f 8e 44 02 00
	00		 jle	 $LN308@ReadIniFil
  006e8	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL10@ReadIniFil:

; 294  : 		{
; 295  : 			szColNum.Format("%02d", i);

  006f0	50		 push	 eax
  006f1	8d 45 ac	 lea	 eax, DWORD PTR _szColNum$[ebp]
  006f4	68 00 00 00 00	 push	 OFFSET ??_C@_04OGKJMPGK@?$CF02d@
  006f9	50		 push	 eax
  006fa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Format@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAAXPBDZZ
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h

; 377  : 		return( m_pszData );

  00700	8b 7d ac	 mov	 edi, DWORD PTR _szColNum$[ebp]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 296  : 			::GetPrivateProfileString(szKey, szColNum, "", szColInfo.GetBuffer(MAX_PATH), MAX_PATH, strConfigPath);	

  00703	8d 4d cc	 lea	 ecx, DWORD PTR _szColInfo$[ebp]
  00706	83 c4 0c	 add	 esp, 12			; 0000000cH
  00709	ff 75 bc	 push	 DWORD PTR _strConfigPath$[ebp]
  0070c	68 04 01 00 00	 push	 260			; 00000104H
  00711	68 04 01 00 00	 push	 260			; 00000104H
  00716	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetBuffer@?$CSimpleStringT@D$00@ATL@@QAEPADH@Z
  0071c	50		 push	 eax
  0071d	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@@
  00722	57		 push	 edi
  00723	8d 45 d0	 lea	 eax, DWORD PTR _szKey$[ebp]
  00726	50		 push	 eax
  00727	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileStringA@24

; 297  : 			szColInfo.ReleaseBuffer();

  0072d	6a ff		 push	 -1
  0072f	8d 4d cc	 lea	 ecx, DWORD PTR _szColInfo$[ebp]
  00732	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?ReleaseBuffer@?$CSimpleStringT@D$00@ATL@@QAEXH@Z
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h

; 519  : 		return( GetData()->nDataLength );

  00738	8b 45 cc	 mov	 eax, DWORD PTR _szColInfo$[ebp]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 299  : 			if (szColInfo.GetLength() == 0)

  0073b	83 78 f4 00	 cmp	 DWORD PTR [eax-12], 0
  0073f	0f 84 d7 01 00
	00		 je	 $LN8@ReadIniFil

; 300  : 				continue;
; 301  : 
; 302  : 			GetFieldData(szColInfo, nFieldKey, szFieldName);

  00745	8d 45 b0	 lea	 eax, DWORD PTR _szFieldName$[ebp]
  00748	50		 push	 eax
  00749	8d 45 c4	 lea	 eax, DWORD PTR _nFieldKey$[ebp]
  0074c	50		 push	 eax
  0074d	51		 push	 ecx
  0074e	8d 45 cc	 lea	 eax, DWORD PTR _szColInfo$[ebp]
  00751	8b cc		 mov	 ecx, esp
  00753	50		 push	 eax
  00754	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z
  0075a	8b ce		 mov	 ecx, esi
  0075c	e8 00 00 00 00	 call	 ?GetFieldData@CDlgSettingToolBar@@AAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAHAAV23@@Z ; CDlgSettingToolBar::GetFieldData
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 333  : 	{ INT_PTR nIndex = m_nSize;

  00761	8b 86 dc 00 00
	00		 mov	 eax, DWORD PTR [esi+220]
  00767	89 45 c0	 mov	 DWORD PTR _nIndex$1$[ebp], eax

; 538  : 	if(nIndex < 0)

  0076a	85 c0		 test	 eax, eax
  0076c	0f 88 3c 02 00
	00		 js	 $LN261@ReadIniFil

; 539  : 		AfxThrowInvalidArgException();
; 540  : 
; 541  : 	if (nIndex >= m_nSize)
; 542  : 		SetSize(nIndex+1, -1);

  00772	6a ff		 push	 -1
  00774	40		 inc	 eax
  00775	8d 8e d4 00 00
	00		 lea	 ecx, DWORD PTR [esi+212]
  0077b	50		 push	 eax
  0077c	e8 00 00 00 00	 call	 ?SetSize@?$CArray@HH@@QAEXHH@Z ; CArray<int,int>::SetSize

; 543  : 	m_pData[nIndex] = newElement;

  00781	8b 86 d8 00 00
	00		 mov	 eax, DWORD PTR [esi+216]
  00787	8b 4d c0	 mov	 ecx, DWORD PTR _nIndex$1$[ebp]
  0078a	8b 7d c4	 mov	 edi, DWORD PTR _nFieldKey$[ebp]
  0078d	89 3c 88	 mov	 DWORD PTR [eax+ecx*4], edi
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 305  : 			m_mapUserList.SetAt(nFieldKey, szFieldName);

  00790	8d 45 b0	 lea	 eax, DWORD PTR _szFieldName$[ebp]
  00793	50		 push	 eax
  00794	8d 4d b8	 lea	 ecx, DWORD PTR $T8[ebp]
  00797	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 165  : 	ldiv_t HashVal = ldiv((long)(ARG_KEY)key, 127773);

  0079d	8b c7		 mov	 eax, edi

; 1350 : 	{ (*this)[key] = newValue; }

  0079f	c6 45 fc 0d	 mov	 BYTE PTR __$EHRec$[ebp+8], 13 ; 0000000dH

; 165  : 	ldiv_t HashVal = ldiv((long)(ARG_KEY)key, 127773);

  007a3	99		 cdq
  007a4	b9 1d f3 01 00	 mov	 ecx, 127773		; 0001f31dH
  007a9	f7 f9		 idiv	 ecx

; 1534 : 	nHashBucket = nHashValue % m_nHashTableSize;

  007ab	8b be 28 01 00
	00		 mov	 edi, DWORD PTR [esi+296]

; 166  : 	HashVal.rem = 16807 * HashVal.rem - 2836 * HashVal.quot;

  007b1	69 c0 14 0b 00
	00		 imul	 eax, eax, 2836
  007b7	69 ca a7 41 00
	00		 imul	 ecx, edx, 16807
  007bd	2b c8		 sub	 ecx, eax

; 1534 : 	nHashBucket = nHashValue % m_nHashTableSize;

  007bf	8d 81 ff ff ff
	7f		 lea	 eax, DWORD PTR [ecx+2147483647]
  007c5	0f 49 c1	 cmovns	 eax, ecx
  007c8	33 d2		 xor	 edx, edx
  007ca	89 45 b4	 mov	 DWORD PTR tv2148[ebp], eax
  007cd	f7 f7		 div	 edi

; 1535 : 
; 1536 : 	if (m_pHashTable == NULL)

  007cf	8b 86 24 01 00
	00		 mov	 eax, DWORD PTR [esi+292]
  007d5	8b ca		 mov	 ecx, edx
  007d7	89 4d c0	 mov	 DWORD PTR _nHashBucket$1$[ebp], ecx
  007da	85 c0		 test	 eax, eax
  007dc	75 51		 jne	 SHORT $LN211@ReadIniFil

; 1434 : 		m_pHashTable = new CAssoc* [nHashSize];

  007de	33 c9		 xor	 ecx, ecx
  007e0	8b c7		 mov	 eax, edi
  007e2	ba 04 00 00 00	 mov	 edx, 4
  007e7	f7 e2		 mul	 edx
  007e9	0f 90 c1	 seto	 cl
  007ec	f7 d9		 neg	 ecx
  007ee	0b c8		 or	 ecx, eax
  007f0	51		 push	 ecx
  007f1	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  007f6	83 c4 04	 add	 esp, 4
  007f9	89 86 24 01 00
	00		 mov	 DWORD PTR [esi+292], eax

; 1435 : 		ENSURE(m_pHashTable != NULL);

  007ff	85 c0		 test	 eax, eax
  00801	0f 84 a7 01 00
	00		 je	 $LN261@ReadIniFil

; 1436 : 		memset(m_pHashTable, 0, sizeof(CAssoc*) * nHashSize);

  00807	8d 0c bd 00 00
	00 00		 lea	 ecx, DWORD PTR [edi*4]
  0080e	51		 push	 ecx
  0080f	6a 00		 push	 0
  00811	50		 push	 eax
  00812	e8 00 00 00 00	 call	 _memset
  00817	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1437 : 	}
; 1438 : 	m_nHashTableSize = nHashSize;

  0081a	89 be 28 01 00
	00		 mov	 DWORD PTR [esi+296], edi

; 1595 : 		ENSURE(m_pHashTable);

  00820	83 be 24 01 00
	00 00		 cmp	 DWORD PTR [esi+292], 0
  00827	0f 84 81 01 00
	00		 je	 $LN261@ReadIniFil
  0082d	eb 25		 jmp	 SHORT $LN307@ReadIniFil
$LN211@ReadIniFil:

; 1541 : 	for (pAssoc = m_pHashTable[nHashBucket]; pAssoc != NULL; pAssoc = pAssoc->pNext)

  0082f	8b 3c 88	 mov	 edi, DWORD PTR [eax+ecx*4]
  00832	85 ff		 test	 edi, edi
  00834	74 1e		 je	 SHORT $LN307@ReadIniFil
  00836	8b 45 b4	 mov	 eax, DWORD PTR tv2148[ebp]
  00839	8b 4d c4	 mov	 ecx, DWORD PTR _nFieldKey$[ebp]
  0083c	0f 1f 40 00	 npad	 4
$LL210@ReadIniFil:

; 1542 : 	{
; 1543 : 		if (pAssoc->nHashValue == nHashValue && CompareElements(&pAssoc->key, &key))

  00840	39 47 0c	 cmp	 DWORD PTR [edi+12], eax
  00843	75 08		 jne	 SHORT $LN208@ReadIniFil
  00845	39 0f		 cmp	 DWORD PTR [edi], ecx
  00847	0f 84 b5 00 00
	00		 je	 $LN203@ReadIniFil
$LN208@ReadIniFil:

; 1537 : 		return NULL;
; 1538 : 
; 1539 : 	// see if it exists
; 1540 : 	CAssoc* pAssoc;
; 1541 : 	for (pAssoc = m_pHashTable[nHashBucket]; pAssoc != NULL; pAssoc = pAssoc->pNext)

  0084d	8b 7f 08	 mov	 edi, DWORD PTR [edi+8]
  00850	85 ff		 test	 edi, edi
  00852	75 ec		 jne	 SHORT $LL210@ReadIniFil
$LN307@ReadIniFil:

; 1481 : 	if (m_pFreeList == NULL)

  00854	83 be 30 01 00
	00 00		 cmp	 DWORD PTR [esi+304], 0
  0085b	75 4a		 jne	 SHORT $LN241@ReadIniFil

; 1482 : 	{
; 1483 : 		// add another block
; 1484 : 		CPlex* newBlock = CPlex::Create(m_pBlocks, m_nBlockSize, sizeof(CMap::CAssoc));

  0085d	6a 10		 push	 16			; 00000010H
  0085f	ff b6 38 01 00
	00		 push	 DWORD PTR [esi+312]
  00865	8d 86 34 01 00
	00		 lea	 eax, DWORD PTR [esi+308]
  0086b	50		 push	 eax
  0086c	e8 00 00 00 00	 call	 ?Create@CPlex@@SGPAU1@AAPAU1@II@Z ; CPlex::Create

; 1485 : 		// chain them into free list
; 1486 : 		CMap::CAssoc* pAssoc = (CMap::CAssoc*) newBlock->data();
; 1487 : 		// free in reverse order to make it easier to debug
; 1488 : 		pAssoc += m_nBlockSize - 1;

  00871	8b 96 38 01 00
	00		 mov	 edx, DWORD PTR [esi+312]
  00877	8b ca		 mov	 ecx, edx
  00879	c1 e1 04	 shl	 ecx, 4
  0087c	83 c1 f8	 add	 ecx, -8			; fffffff8H
  0087f	03 c8		 add	 ecx, eax

; 1489 : 		for (INT_PTR i = m_nBlockSize-1; i >= 0; i--, pAssoc--)

  00881	83 c2 ff	 add	 edx, -1
  00884	78 21		 js	 SHORT $LN241@ReadIniFil
  00886	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL238@ReadIniFil:

; 1490 : 		{
; 1491 : 			pAssoc->pNext = m_pFreeList;

  00890	8b 86 30 01 00
	00		 mov	 eax, DWORD PTR [esi+304]
  00896	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1492 : 			m_pFreeList = pAssoc;

  00899	89 8e 30 01 00
	00		 mov	 DWORD PTR [esi+304], ecx
  0089f	83 e9 10	 sub	 ecx, 16			; 00000010H
  008a2	83 ea 01	 sub	 edx, 1
  008a5	79 e9		 jns	 SHORT $LL238@ReadIniFil
$LN241@ReadIniFil:

; 1493 : 		}
; 1494 : 	}
; 1495 : 	ENSURE(m_pFreeList != NULL);  // we must have something

  008a7	8b be 30 01 00
	00		 mov	 edi, DWORD PTR [esi+304]
  008ad	85 ff		 test	 edi, edi
  008af	0f 84 f9 00 00
	00		 je	 $LN261@ReadIniFil

; 1496 : 
; 1497 : 	CMap::CAssoc* pAssoc = m_pFreeList;
; 1498 : 
; 1499 : 	// zero the memory
; 1500 : 	CMap::CAssoc* pTemp = pAssoc->pNext;

  008b5	8b 47 08	 mov	 eax, DWORD PTR [edi+8]

; 1256 : 		CPair( ARG_KEY keyval ) : key( keyval )	{}

  008b8	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  008bb	0f 57 c0	 xorps	 xmm0, xmm0

; 1501 : 	memset( pAssoc, 0, sizeof(CMap::CAssoc) );

  008be	0f 11 07	 movups	 XMMWORD PTR [edi], xmm0

; 1502 : 	pAssoc->pNext = pTemp;

  008c1	89 47 08	 mov	 DWORD PTR [edi+8], eax

; 1503 : 
; 1504 : 	m_pFreeList = m_pFreeList->pNext;

  008c4	8b 86 30 01 00
	00		 mov	 eax, DWORD PTR [esi+304]
  008ca	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 1505 : 	m_nCount++;

  008cd	ff 86 2c 01 00
	00		 inc	 DWORD PTR [esi+300]
  008d3	89 86 30 01 00
	00		 mov	 DWORD PTR [esi+304], eax

; 1256 : 		CPair( ARG_KEY keyval ) : key( keyval )	{}

  008d9	8b 45 c4	 mov	 eax, DWORD PTR _nFieldKey$[ebp]
  008dc	89 07		 mov	 DWORD PTR [edi], eax
  008de	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 1598 : 		pAssoc->nHashValue = nHashValue;

  008e4	8b 45 b4	 mov	 eax, DWORD PTR tv2148[ebp]

; 1599 : 		//'pAssoc->value' is a constructed object, nothing more
; 1600 : 
; 1601 : 		// put into hash table
; 1602 : 		pAssoc->pNext = m_pHashTable[nHashBucket];

  008e7	8b 4d c0	 mov	 ecx, DWORD PTR _nHashBucket$1$[ebp]
  008ea	89 47 0c	 mov	 DWORD PTR [edi+12], eax
  008ed	8b 86 24 01 00
	00		 mov	 eax, DWORD PTR [esi+292]
  008f3	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
  008f6	89 47 08	 mov	 DWORD PTR [edi+8], eax

; 1603 : 		m_pHashTable[nHashBucket] = pAssoc;

  008f9	8b 86 24 01 00
	00		 mov	 eax, DWORD PTR [esi+292]
  008ff	89 3c 88	 mov	 DWORD PTR [eax+ecx*4], edi
$LN203@ReadIniFil:

; 1350 : 	{ (*this)[key] = newValue; }

  00902	8d 45 b8	 lea	 eax, DWORD PTR $T8[ebp]

; 1605 : 	return pAssoc->value;  // return new reference

  00905	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]

; 1350 : 	{ (*this)[key] = newValue; }

  00908	50		 push	 eax
  00909	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
  0090f	8d 4d b8	 lea	 ecx, DWORD PTR $T8[ebp]
  00912	c6 45 fc 0a	 mov	 BYTE PTR __$EHRec$[ebp+8], 10 ; 0000000aH
  00916	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$LN8@ReadIniFil:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp

; 293  : 		for(int i=0;i < nColCount; i++)

  0091c	8b 45 c8	 mov	 eax, DWORD PTR _i$1$[ebp]
  0091f	40		 inc	 eax
  00920	89 45 c8	 mov	 DWORD PTR _i$1$[ebp], eax
  00923	3b 45 9c	 cmp	 eax, DWORD PTR _nColCount$3$[ebp]
  00926	0f 8c c4 fd ff
	ff		 jl	 $LL10@ReadIniFil
$LN308@ReadIniFil:

; 306  : 		}
; 307  : 	}
; 308  : 	
; 309  : 	return ;

  0092c	8d 4d b0	 lea	 ecx, DWORD PTR _szFieldName$[ebp]
  0092f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00935	8d 4d 90	 lea	 ecx, DWORD PTR _szFieldKey$[ebp]
  00938	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0093e	8d 4d cc	 lea	 ecx, DWORD PTR _szColInfo$[ebp]
  00941	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00947	8d 4d ac	 lea	 ecx, DWORD PTR _szColNum$[ebp]
  0094a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00950	8d 4d 8c	 lea	 ecx, DWORD PTR _szIndex$[ebp]
  00953	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00959	8d 4d 98	 lea	 ecx, DWORD PTR _strTemp$[ebp]
  0095c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00962	8d 4d bc	 lea	 ecx, DWORD PTR _strConfigPath$[ebp]
  00965	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0096b	8d 4d a4	 lea	 ecx, DWORD PTR _strUserPath$[ebp]
  0096e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00974	8d 4d a8	 lea	 ecx, DWORD PTR _strDataPath$[ebp]
  00977	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0097d	8d 4d a0	 lea	 ecx, DWORD PTR _strPath$[ebp]
  00980	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00986	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR _FileFind$[ebp]
  0098c	e8 00 00 00 00	 call	 ??1CFileFind@@UAE@XZ	; CFileFind::~CFileFind

; 310  : }

  00991	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00994	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0099b	59		 pop	 ecx
  0099c	5f		 pop	 edi
  0099d	5e		 pop	 esi
  0099e	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  009a1	33 cd		 xor	 ecx, ebp
  009a3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  009a8	8b e5		 mov	 esp, ebp
  009aa	5d		 pop	 ebp
  009ab	c2 04 00	 ret	 4
$LN261@ReadIniFil:
  009ae	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN312@ReadIniFil:
  009b3	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ReadIniFile@CDlgSettingToolBar@@AAEXH@Z$0:
  00000	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR _FileFind$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CFileFind@@UAE@XZ	; CFileFind::~CFileFind
__unwindfunclet$?ReadIniFile@CDlgSettingToolBar@@AAEXH@Z$1:
  0000b	8d 4d a0	 lea	 ecx, DWORD PTR _strPath$[ebp]
  0000e	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?ReadIniFile@CDlgSettingToolBar@@AAEXH@Z$2:
  00014	8d 4d a8	 lea	 ecx, DWORD PTR _strDataPath$[ebp]
  00017	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?ReadIniFile@CDlgSettingToolBar@@AAEXH@Z$3:
  0001d	8d 4d a4	 lea	 ecx, DWORD PTR _strUserPath$[ebp]
  00020	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?ReadIniFile@CDlgSettingToolBar@@AAEXH@Z$4:
  00026	8d 4d bc	 lea	 ecx, DWORD PTR _strConfigPath$[ebp]
  00029	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?ReadIniFile@CDlgSettingToolBar@@AAEXH@Z$5:
  0002f	8d 4d 98	 lea	 ecx, DWORD PTR _strTemp$[ebp]
  00032	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?ReadIniFile@CDlgSettingToolBar@@AAEXH@Z$6:
  00038	8d 4d 8c	 lea	 ecx, DWORD PTR _szIndex$[ebp]
  0003b	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?ReadIniFile@CDlgSettingToolBar@@AAEXH@Z$7:
  00041	8d 4d ac	 lea	 ecx, DWORD PTR _szColNum$[ebp]
  00044	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?ReadIniFile@CDlgSettingToolBar@@AAEXH@Z$8:
  0004a	8d 4d cc	 lea	 ecx, DWORD PTR _szColInfo$[ebp]
  0004d	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?ReadIniFile@CDlgSettingToolBar@@AAEXH@Z$9:
  00053	8d 4d 90	 lea	 ecx, DWORD PTR _szFieldKey$[ebp]
  00056	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?ReadIniFile@CDlgSettingToolBar@@AAEXH@Z$10:
  0005c	8d 4d b0	 lea	 ecx, DWORD PTR _szFieldName$[ebp]
  0005f	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?ReadIniFile@CDlgSettingToolBar@@AAEXH@Z$17:
  00065	8d 4d b8	 lea	 ecx, DWORD PTR $T10[ebp]
  00068	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?ReadIniFile@CDlgSettingToolBar@@AAEXH@Z$18:
  0006e	8d 4d b8	 lea	 ecx, DWORD PTR $T9[ebp]
  00071	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?ReadIniFile@CDlgSettingToolBar@@AAEXH@Z$19:
  00077	8d 4d b8	 lea	 ecx, DWORD PTR $T8[ebp]
  0007a	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00080	cc		 int	 3
  00081	cc		 int	 3
  00082	cc		 int	 3
  00083	cc		 int	 3
  00084	cc		 int	 3
__ehhandler$?ReadIniFile@CDlgSettingToolBar@@AAEXH@Z:
  00085	90		 npad	 1
  00086	90		 npad	 1
  00087	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0008b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0008e	8b 8a 70 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-144]
  00094	33 c8		 xor	 ecx, eax
  00096	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0009b	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0009e	33 c8		 xor	 ecx, eax
  000a0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a5	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?ReadIniFile@CDlgSettingToolBar@@AAEXH@Z
  000aa	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?ReadIniFile@CDlgSettingToolBar@@AAEXH@Z ENDP		; CDlgSettingToolBar::ReadIniFile
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
;	COMDAT ?GetFieldData@CDlgSettingToolBar@@AAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAHAAV23@@Z
_TEXT	SEGMENT
$T2 = -20						; size = 4
_strFieldKey$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_strFieldData$ = 8					; size = 4
_nFieldKey$ = 12					; size = 4
_strFieldName$ = 16					; size = 4
?GetFieldData@CDlgSettingToolBar@@AAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAHAAV23@@Z PROC ; CDlgSettingToolBar::GetFieldData, COMDAT
; _this$ = ecx

; 321  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?GetFieldData@CDlgSettingToolBar@@AAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAHAAV23@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 322  : 	CString strFieldKey;

  00026	8d 4d f0	 lea	 ecx, DWORD PTR _strFieldKey$[ebp]
  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00030	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 323  : 
; 324  : 	int nPos = strFieldData.Find(',');

  00036	6a 00		 push	 0
  00038	6a 2c		 push	 44			; 0000002cH
  0003a	8d 4d 08	 lea	 ecx, DWORD PTR _strFieldData$[ebp]
  0003d	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00041	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Find@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEHDH@Z
  00047	8b f0		 mov	 esi, eax

; 325  : 	if(nPos==-1)	return;		

  00049	83 fe ff	 cmp	 esi, -1
  0004c	74 56		 je	 SHORT $LN11@GetFieldDa

; 326  : 	strFieldKey = strFieldData.Left(nPos);			//

  0004e	56		 push	 esi
  0004f	8d 45 ec	 lea	 eax, DWORD PTR $T2[ebp]
  00052	50		 push	 eax
  00053	8d 4d 08	 lea	 ecx, DWORD PTR _strFieldData$[ebp]
  00056	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Left@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBE?AV12@H@Z
  0005c	50		 push	 eax
  0005d	8d 4d f0	 lea	 ecx, DWORD PTR _strFieldKey$[ebp]
  00060	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00064	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
  0006a	8d 4d ec	 lea	 ecx, DWORD PTR $T2[ebp]
  0006d	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00071	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 327  : 	nFieldKey = atoi(strFieldKey);

  00077	ff 75 f0	 push	 DWORD PTR _strFieldKey$[ebp]
  0007a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  00080	8b 4d 0c	 mov	 ecx, DWORD PTR _nFieldKey$[ebp]
  00083	83 c4 04	 add	 esp, 4
  00086	89 01		 mov	 DWORD PTR [ecx], eax

; 328  : 	strFieldData.Delete(0,nPos+1);		

  00088	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  0008b	50		 push	 eax
  0008c	6a 00		 push	 0
  0008e	8d 4d 08	 lea	 ecx, DWORD PTR _strFieldData$[ebp]
  00091	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Delete@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEHHH@Z

; 329  : 
; 330  : 	strFieldName = strFieldData;			//

  00097	8b 4d 10	 mov	 ecx, DWORD PTR _strFieldName$[ebp]
  0009a	8d 45 08	 lea	 eax, DWORD PTR _strFieldData$[ebp]
  0009d	50		 push	 eax
  0009e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
$LN11@GetFieldDa:

; 331  : }

  000a4	8d 4d f0	 lea	 ecx, DWORD PTR _strFieldKey$[ebp]
  000a7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  000ad	8d 4d 08	 lea	 ecx, DWORD PTR _strFieldData$[ebp]
  000b0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  000b6	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000b9	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000c0	59		 pop	 ecx
  000c1	5e		 pop	 esi
  000c2	8b e5		 mov	 esp, ebp
  000c4	5d		 pop	 ebp
  000c5	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetFieldData@CDlgSettingToolBar@@AAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAHAAV23@@Z$0:
  00000	8d 4d 08	 lea	 ecx, DWORD PTR _strFieldData$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?GetFieldData@CDlgSettingToolBar@@AAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAHAAV23@@Z$1:
  00009	8d 4d f0	 lea	 ecx, DWORD PTR _strFieldKey$[ebp]
  0000c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?GetFieldData@CDlgSettingToolBar@@AAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAHAAV23@@Z$2:
  00012	8d 4d ec	 lea	 ecx, DWORD PTR $T2[ebp]
  00015	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0001b	cc		 int	 3
  0001c	cc		 int	 3
  0001d	cc		 int	 3
  0001e	cc		 int	 3
  0001f	cc		 int	 3
__ehhandler$?GetFieldData@CDlgSettingToolBar@@AAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAHAAV23@@Z:
  00020	90		 npad	 1
  00021	90		 npad	 1
  00022	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00026	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00029	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0002c	33 c8		 xor	 ecx, eax
  0002e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00033	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?GetFieldData@CDlgSettingToolBar@@AAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAHAAV23@@Z
  00038	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?GetFieldData@CDlgSettingToolBar@@AAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAHAAV23@@Z ENDP ; CDlgSettingToolBar::GetFieldData
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
;	COMDAT ??_G?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@UAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_G?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@UAEPAXI@Z PROC ; CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_G?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@UAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 1472 : {

  00025	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0002c	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@6B@

; 1473 : 	RemoveAll();

  00032	e8 00 00 00 00	 call	 ?RemoveAll@?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@QAEXXZ ; CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >::RemoveAll
  00037	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  0003a	a8 01		 test	 al, 1
  0003c	74 2c		 je	 SHORT $LN12@scalar
  0003e	a8 04		 test	 al, 4
  00040	75 1d		 jne	 SHORT $LN3@scalar
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 112  : 	{ ::operator delete(p); }

  00042	56		 push	 esi
  00043	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00048	83 c4 04	 add	 esp, 4
  0004b	8b c6		 mov	 eax, esi
  0004d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00050	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00057	59		 pop	 ecx
  00058	5e		 pop	 esi
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c2 04 00	 ret	 4
$LN3@scalar:
  0005f	6a 1c		 push	 28			; 0000001cH
  00061	56		 push	 esi
  00062	e8 00 00 00 00	 call	 ?__global_delete@@YAXPAXI@Z ; __global_delete
  00067	83 c4 08	 add	 esp, 8
$LN12@scalar:
  0006a	8b c6		 mov	 eax, esi
  0006c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00076	59		 pop	 ecx
  00077	5e		 pop	 esi
  00078	8b e5		 mov	 esp, ebp
  0007a	5d		 pop	 ebp
  0007b	c2 04 00	 ret	 4
  0007e	cc		 int	 3
  0007f	cc		 int	 3
  00080	cc		 int	 3
  00081	cc		 int	 3
  00082	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??_G?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@UAEPAXI@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_G?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@UAEPAXI@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_G?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@UAEPAXI@Z ENDP ; CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >::`scalar deleting destructor'
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ?Serialize@?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@UAEXAAVCArchive@@@Z
_TEXT	SEGMENT
_nNewCount$1$ = -44					; size = 4
_nHashBucket$1$ = -40					; size = 4
_pValue$1$ = -40					; size = 4
_this$1$ = -36						; size = 4
_newKey$4 = -32						; size = 4
_pData$1$ = -28						; size = 4
_nElementsLeft$1$ = -28					; size = 4
_key$1$ = -28						; size = 4
_nHash$1$ = -28						; size = 4
tv846 = -24						; size = 4
_pData$1$ = -24						; size = 4
_pAssoc$1$ = -24					; size = 4
_pData$1$ = -20						; size = 4
_pData$1$ = -20						; size = 4
$T5 = -20						; size = 4
_nElementsLeft$1$ = -16					; size = 4
_newValue$6 = -16					; size = 4
__$EHRec$ = -12						; size = 12
_ar$ = 8						; size = 4
?Serialize@?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@UAEXAAVCArchive@@@Z PROC ; CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >::Serialize, COMDAT
; _this$ = ecx

; 1743 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Serialize@?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@UAEXAAVCArchive@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 20	 sub	 esp, 32			; 00000020H
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	50		 push	 eax
  0001e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00027	8b f9		 mov	 edi, ecx
  00029	89 7d dc	 mov	 DWORD PTR _this$1$[ebp], edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 212  : 	{ return (m_nMode & CArchive::load) == 0; }

  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _ar$[ebp]
  0002f	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  00032	f7 d0		 not	 eax
  00034	a8 01		 test	 al, 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 1748 : 	if (ar.IsStoring())

  00036	0f 84 0e 01 00
	00		 je	 $LN10@Serialize

; 1749 : 	{
; 1750 : 		ar.WriteCount(m_nCount);

  0003c	ff 77 0c	 push	 DWORD PTR [edi+12]
  0003f	e8 00 00 00 00	 call	 ?WriteCount@CArchive@@QAEXK@Z ; CArchive::WriteCount

; 1751 : 		if (m_nCount == 0)

  00044	83 7f 0c 00	 cmp	 DWORD PTR [edi+12], 0
  00048	0f 84 e9 00 00
	00		 je	 $LN140@Serialize

; 1752 : 			return;  // nothing more to do
; 1753 : 
; 1754 : 		ASSERT(m_pHashTable != NULL);
; 1755 : 		if (m_pHashTable != NULL)

  0004e	83 7f 04 00	 cmp	 DWORD PTR [edi+4], 0
  00052	0f 84 df 00 00
	00		 je	 $LN140@Serialize

; 1756 : 		{
; 1757 : 			for (UINT nHash = 0; nHash < m_nHashTableSize; nHash++)

  00058	33 c9		 xor	 ecx, ecx
  0005a	89 4d e4	 mov	 DWORD PTR _nHash$1$[ebp], ecx
  0005d	39 4f 08	 cmp	 DWORD PTR [edi+8], ecx
  00060	0f 86 d1 00 00
	00		 jbe	 $LN140@Serialize
$LL4@Serialize:

; 1758 : 			{
; 1759 : 				CAssoc* pAssoc;
; 1760 : 				for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL; pAssoc = pAssoc->pNext)

  00066	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00069	8b 14 88	 mov	 edx, DWORD PTR [eax+ecx*4]
  0006c	89 55 e8	 mov	 DWORD PTR _pAssoc$1$[ebp], edx
  0006f	85 d2		 test	 edx, edx
  00071	0f 84 b3 00 00
	00		 je	 $LN2@Serialize
$LL7@Serialize:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 212  : 	{ return (m_nMode & CArchive::load) == 0; }

  00077	8b 4d 08	 mov	 ecx, DWORD PTR _ar$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 1770 : 					pValue = reinterpret_cast< VALUE* >( &reinterpret_cast< int& >( static_cast< VALUE& >( pAssoc->value ) ) );

  0007a	8d 42 04	 lea	 eax, DWORD PTR [edx+4]
  0007d	89 45 d8	 mov	 DWORD PTR _pValue$1$[ebp], eax

; 73   : 	if (ar.IsStoring())

  00080	89 55 ec	 mov	 DWORD PTR _pData$1$[ebp], edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 212  : 	{ return (m_nMode & CArchive::load) == 0; }

  00083	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  00086	f7 d0		 not	 eax
  00088	a8 01		 test	 al, 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 73   : 	if (ar.IsStoring())

  0008a	74 3b		 je	 SHORT $LN28@Serialize

; 74   : 	{
; 75   : 		TYPE* pData;
; 76   : 		UINT_PTR nElementsLeft;
; 77   : 
; 78   : 		nElementsLeft = nCount;

  0008c	b8 01 00 00 00	 mov	 eax, 1

; 79   : 		pData = pElements;

  00091	8b ca		 mov	 ecx, edx
  00093	89 45 f0	 mov	 DWORD PTR _nElementsLeft$1$[ebp], eax
$LL23@Serialize:

; 80   : 		while( nElementsLeft > 0 )
; 81   : 		{
; 82   : 			UINT nElementsToWrite;
; 83   : 
; 84   : 			nElementsToWrite = UINT(__min(nElementsLeft, INT_MAX/sizeof(TYPE)));

  00096	bf ff ff ff 1f	 mov	 edi, 536870911		; 1fffffffH
  0009b	3b c7		 cmp	 eax, edi
  0009d	0f 42 f8	 cmovb	 edi, eax

; 85   : 			ar.Write(pData, nElementsToWrite*sizeof(TYPE));

  000a0	8d 34 bd 00 00
	00 00		 lea	 esi, DWORD PTR [edi*4]
  000a7	56		 push	 esi
  000a8	51		 push	 ecx
  000a9	8b 4d 08	 mov	 ecx, DWORD PTR _ar$[ebp]
  000ac	e8 00 00 00 00	 call	 ?Write@CArchive@@QAEXPBXI@Z ; CArchive::Write

; 86   : 			nElementsLeft -= nElementsToWrite;

  000b1	8b 45 f0	 mov	 eax, DWORD PTR _nElementsLeft$1$[ebp]

; 87   : 			pData += nElementsToWrite;

  000b4	8b 4d ec	 mov	 ecx, DWORD PTR _pData$1$[ebp]
  000b7	2b c7		 sub	 eax, edi
  000b9	03 ce		 add	 ecx, esi
  000bb	89 45 f0	 mov	 DWORD PTR _nElementsLeft$1$[ebp], eax
  000be	89 4d ec	 mov	 DWORD PTR _pData$1$[ebp], ecx
  000c1	85 c0		 test	 eax, eax
  000c3	75 d1		 jne	 SHORT $LL23@Serialize

; 88   : 		}
; 89   : 	}

  000c5	eb 3f		 jmp	 SHORT $LN26@Serialize
$LN28@Serialize:

; 90   : 	else
; 91   : 	{
; 92   : 		TYPE* pData;
; 93   : 		UINT_PTR nElementsLeft;
; 94   : 
; 95   : 		nElementsLeft = nCount;

  000c7	be 01 00 00 00	 mov	 esi, 1
  000cc	0f 1f 40 00	 npad	 4
$LL25@Serialize:

; 97   : 		while( nElementsLeft > 0 )
; 98   : 		{
; 99   : 			UINT nElementsToRead;
; 100  : 
; 101  : 			nElementsToRead = UINT(__min(nElementsLeft, INT_MAX/sizeof(TYPE)));

  000d0	bf ff ff ff 1f	 mov	 edi, 536870911		; 1fffffffH
  000d5	3b f7		 cmp	 esi, edi
  000d7	0f 42 fe	 cmovb	 edi, esi

; 102  : 			ar.EnsureRead(pData, nElementsToRead*sizeof(TYPE));

  000da	8d 04 bd 00 00
	00 00		 lea	 eax, DWORD PTR [edi*4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 399  : 	UINT nRead=Read(lpBuf, nCount);

  000e1	50		 push	 eax
  000e2	52		 push	 edx
  000e3	e8 00 00 00 00	 call	 ?Read@CArchive@@QAEIPAXI@Z ; CArchive::Read

; 400  : 	if(nRead!=nCount)

  000e8	8d 0c bd 00 00
	00 00		 lea	 ecx, DWORD PTR [edi*4]
  000ef	3b c1		 cmp	 eax, ecx
  000f1	0f 85 a3 02 00
	00		 jne	 $LN123@Serialize
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 104  : 			pData += nElementsToRead;

  000f7	8b 55 ec	 mov	 edx, DWORD PTR _pData$1$[ebp]
  000fa	03 d1		 add	 edx, ecx
  000fc	8b 4d 08	 mov	 ecx, DWORD PTR _ar$[ebp]
  000ff	89 55 ec	 mov	 DWORD PTR _pData$1$[ebp], edx
  00102	2b f7		 sub	 esi, edi
  00104	75 ca		 jne	 SHORT $LL25@Serialize
$LN26@Serialize:

; 1771 : 					SerializeElements<KEY>(ar, pKey, 1);
; 1772 : 					SerializeElements<VALUE>(ar, pValue, 1);

  00106	6a 01		 push	 1
  00108	ff 75 d8	 push	 DWORD PTR _pValue$1$[ebp]
  0010b	ff 75 08	 push	 DWORD PTR _ar$[ebp]
  0010e	e8 00 00 00 00	 call	 ??$SerializeElements@V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@@YGXAAVCArchive@@PAV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z ; SerializeElements<ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >
  00113	8b 55 e8	 mov	 edx, DWORD PTR _pAssoc$1$[ebp]
  00116	8b 52 08	 mov	 edx, DWORD PTR [edx+8]
  00119	89 55 e8	 mov	 DWORD PTR _pAssoc$1$[ebp], edx
  0011c	85 d2		 test	 edx, edx
  0011e	0f 85 53 ff ff
	ff		 jne	 $LL7@Serialize
  00124	8b 7d dc	 mov	 edi, DWORD PTR _this$1$[ebp]
  00127	8b 4d e4	 mov	 ecx, DWORD PTR _nHash$1$[ebp]
$LN2@Serialize:

; 1756 : 		{
; 1757 : 			for (UINT nHash = 0; nHash < m_nHashTableSize; nHash++)

  0012a	41		 inc	 ecx
  0012b	89 4d e4	 mov	 DWORD PTR _nHash$1$[ebp], ecx
  0012e	3b 4f 08	 cmp	 ecx, DWORD PTR [edi+8]
  00131	0f 82 2f ff ff
	ff		 jb	 $LL4@Serialize
$LN140@Serialize:

; 1788 : 	}
; 1789 : }

  00137	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0013a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00141	59		 pop	 ecx
  00142	5f		 pop	 edi
  00143	5e		 pop	 esi
  00144	8b e5		 mov	 esp, ebp
  00146	5d		 pop	 ebp
  00147	c2 04 00	 ret	 4
$LN10@Serialize:

; 1773 : 				}
; 1774 : 			}
; 1775 : 		}
; 1776 : 	}
; 1777 : 	else
; 1778 : 	{
; 1779 : 		DWORD_PTR nNewCount = ar.ReadCount();

  0014a	e8 00 00 00 00	 call	 ?ReadCount@CArchive@@QAEKXZ ; CArchive::ReadCount

; 1780 : 		while (nNewCount--)

  0014f	85 c0		 test	 eax, eax
  00151	74 e4		 je	 SHORT $LN140@Serialize
$LL8@Serialize:

; 1781 : 		{
; 1782 : 			KEY newKey[1];
; 1783 : 			VALUE newValue[1];

  00153	ff 35 00 00 00
	00		 push	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00159	48		 dec	 eax
  0015a	ff 35 00 00 00
	00		 push	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00160	89 45 d4	 mov	 DWORD PTR _nNewCount$1$[ebp], eax
  00163	8d 45 f0	 lea	 eax, DWORD PTR _newValue$6[ebp]
  00166	6a 01		 push	 1
  00168	6a 04		 push	 4
  0016a	50		 push	 eax
  0016b	e8 00 00 00 00	 call	 ??_L@YGXPAXIIP6EX0@Z1@Z
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 212  : 	{ return (m_nMode & CArchive::load) == 0; }

  00170	8b 4d 08	 mov	 ecx, DWORD PTR _ar$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 73   : 	if (ar.IsStoring())

  00173	8d 55 e0	 lea	 edx, DWORD PTR _newKey$4[ebp]

; 1781 : 		{
; 1782 : 			KEY newKey[1];
; 1783 : 			VALUE newValue[1];

  00176	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 212  : 	{ return (m_nMode & CArchive::load) == 0; }

  0017d	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  00180	f7 d0		 not	 eax
  00182	a8 01		 test	 al, 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 73   : 	if (ar.IsStoring())

  00184	74 3c		 je	 SHORT $LN49@Serialize

; 74   : 	{
; 75   : 		TYPE* pData;
; 76   : 		UINT_PTR nElementsLeft;
; 77   : 
; 78   : 		nElementsLeft = nCount;

  00186	b8 01 00 00 00	 mov	 eax, 1

; 79   : 		pData = pElements;

  0018b	89 55 e8	 mov	 DWORD PTR _pData$1$[ebp], edx
  0018e	89 45 e4	 mov	 DWORD PTR _nElementsLeft$1$[ebp], eax
$LL44@Serialize:

; 80   : 		while( nElementsLeft > 0 )
; 81   : 		{
; 82   : 			UINT nElementsToWrite;
; 83   : 
; 84   : 			nElementsToWrite = UINT(__min(nElementsLeft, INT_MAX/sizeof(TYPE)));

  00191	bf ff ff ff 1f	 mov	 edi, 536870911		; 1fffffffH
  00196	3b c7		 cmp	 eax, edi
  00198	0f 42 f8	 cmovb	 edi, eax

; 85   : 			ar.Write(pData, nElementsToWrite*sizeof(TYPE));

  0019b	8d 34 bd 00 00
	00 00		 lea	 esi, DWORD PTR [edi*4]
  001a2	56		 push	 esi
  001a3	52		 push	 edx
  001a4	e8 00 00 00 00	 call	 ?Write@CArchive@@QAEXPBXI@Z ; CArchive::Write

; 86   : 			nElementsLeft -= nElementsToWrite;

  001a9	8b 45 e4	 mov	 eax, DWORD PTR _nElementsLeft$1$[ebp]

; 87   : 			pData += nElementsToWrite;

  001ac	8b 55 e8	 mov	 edx, DWORD PTR _pData$1$[ebp]
  001af	2b c7		 sub	 eax, edi
  001b1	8b 4d 08	 mov	 ecx, DWORD PTR _ar$[ebp]
  001b4	03 d6		 add	 edx, esi
  001b6	89 45 e4	 mov	 DWORD PTR _nElementsLeft$1$[ebp], eax
  001b9	89 55 e8	 mov	 DWORD PTR _pData$1$[ebp], edx
  001bc	85 c0		 test	 eax, eax
  001be	75 d1		 jne	 SHORT $LL44@Serialize

; 88   : 		}
; 89   : 	}

  001c0	eb 44		 jmp	 SHORT $LN47@Serialize
$LN49@Serialize:

; 90   : 	else
; 91   : 	{
; 92   : 		TYPE* pData;
; 93   : 		UINT_PTR nElementsLeft;
; 94   : 
; 95   : 		nElementsLeft = nCount;

  001c2	be 01 00 00 00	 mov	 esi, 1

; 96   : 		pData = pElements;

  001c7	89 55 e4	 mov	 DWORD PTR _pData$1$[ebp], edx
  001ca	66 0f 1f 44 00
	00		 npad	 6
$LL46@Serialize:

; 97   : 		while( nElementsLeft > 0 )
; 98   : 		{
; 99   : 			UINT nElementsToRead;
; 100  : 
; 101  : 			nElementsToRead = UINT(__min(nElementsLeft, INT_MAX/sizeof(TYPE)));

  001d0	bf ff ff ff 1f	 mov	 edi, 536870911		; 1fffffffH
  001d5	3b f7		 cmp	 esi, edi
  001d7	0f 42 fe	 cmovb	 edi, esi

; 102  : 			ar.EnsureRead(pData, nElementsToRead*sizeof(TYPE));

  001da	8d 04 bd 00 00
	00 00		 lea	 eax, DWORD PTR [edi*4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 399  : 	UINT nRead=Read(lpBuf, nCount);

  001e1	50		 push	 eax
  001e2	52		 push	 edx
  001e3	e8 00 00 00 00	 call	 ?Read@CArchive@@QAEIPAXI@Z ; CArchive::Read

; 400  : 	if(nRead!=nCount)

  001e8	8d 0c bd 00 00
	00 00		 lea	 ecx, DWORD PTR [edi*4]
  001ef	3b c1		 cmp	 eax, ecx
  001f1	0f 85 a3 01 00
	00		 jne	 $LN123@Serialize
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 104  : 			pData += nElementsToRead;

  001f7	8b 55 e4	 mov	 edx, DWORD PTR _pData$1$[ebp]
  001fa	03 d1		 add	 edx, ecx
  001fc	8b 4d 08	 mov	 ecx, DWORD PTR _ar$[ebp]
  001ff	89 55 e4	 mov	 DWORD PTR _pData$1$[ebp], edx
  00202	2b f7		 sub	 esi, edi
  00204	75 ca		 jne	 SHORT $LL46@Serialize
$LN47@Serialize:

; 1784 : 			SerializeElements<KEY>(ar, newKey, 1);
; 1785 : 			SerializeElements<VALUE>(ar, newValue, 1);

  00206	6a 01		 push	 1
  00208	8d 45 f0	 lea	 eax, DWORD PTR _newValue$6[ebp]
  0020b	50		 push	 eax
  0020c	ff 75 08	 push	 DWORD PTR _ar$[ebp]
  0020f	e8 00 00 00 00	 call	 ??$SerializeElements@V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@@YGXAAVCArchive@@PAV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z ; SerializeElements<ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >

; 1786 : 			SetAt(newKey[0], newValue[0]);

  00214	8d 45 f0	 lea	 eax, DWORD PTR _newValue$6[ebp]
  00217	50		 push	 eax
  00218	8d 4d ec	 lea	 ecx, DWORD PTR $T5[ebp]
  0021b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z
  00221	8b 45 e0	 mov	 eax, DWORD PTR _newKey$4[ebp]
  00224	89 45 e4	 mov	 DWORD PTR _key$1$[ebp], eax

; 1350 : 	{ (*this)[key] = newValue; }

  00227	99		 cdq
  00228	b9 1d f3 01 00	 mov	 ecx, 127773		; 0001f31dH
  0022d	f7 f9		 idiv	 ecx

; 1534 : 	nHashBucket = nHashValue % m_nHashTableSize;

  0022f	8b 7d dc	 mov	 edi, DWORD PTR _this$1$[ebp]

; 166  : 	HashVal.rem = 16807 * HashVal.rem - 2836 * HashVal.quot;

  00232	69 c0 14 0b 00
	00		 imul	 eax, eax, 2836
  00238	69 ca a7 41 00
	00		 imul	 ecx, edx, 16807

; 1350 : 	{ (*this)[key] = newValue; }

  0023e	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 1534 : 	nHashBucket = nHashValue % m_nHashTableSize;

  00242	8b 77 08	 mov	 esi, DWORD PTR [edi+8]

; 166  : 	HashVal.rem = 16807 * HashVal.rem - 2836 * HashVal.quot;

  00245	2b c8		 sub	 ecx, eax

; 1534 : 	nHashBucket = nHashValue % m_nHashTableSize;

  00247	8d 81 ff ff ff
	7f		 lea	 eax, DWORD PTR [ecx+2147483647]
  0024d	0f 49 c1	 cmovns	 eax, ecx
  00250	33 d2		 xor	 edx, edx
  00252	89 45 e8	 mov	 DWORD PTR tv846[ebp], eax
  00255	f7 f6		 div	 esi

; 1535 : 
; 1536 : 	if (m_pHashTable == NULL)

  00257	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0025a	8b ca		 mov	 ecx, edx
  0025c	89 4d d8	 mov	 DWORD PTR _nHashBucket$1$[ebp], ecx
  0025f	85 c0		 test	 eax, eax
  00261	75 48		 jne	 SHORT $LN75@Serialize

; 1434 : 		m_pHashTable = new CAssoc* [nHashSize];

  00263	33 c9		 xor	 ecx, ecx
  00265	8b c6		 mov	 eax, esi
  00267	ba 04 00 00 00	 mov	 edx, 4
  0026c	f7 e2		 mul	 edx
  0026e	0f 90 c1	 seto	 cl
  00271	f7 d9		 neg	 ecx
  00273	0b c8		 or	 ecx, eax
  00275	51		 push	 ecx
  00276	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  0027b	83 c4 04	 add	 esp, 4
  0027e	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 1435 : 		ENSURE(m_pHashTable != NULL);

  00281	85 c0		 test	 eax, eax
  00283	0f 84 1a 01 00
	00		 je	 $LN131@Serialize

; 1436 : 		memset(m_pHashTable, 0, sizeof(CAssoc*) * nHashSize);

  00289	8d 0c b5 00 00
	00 00		 lea	 ecx, DWORD PTR [esi*4]
  00290	51		 push	 ecx
  00291	6a 00		 push	 0
  00293	50		 push	 eax
  00294	e8 00 00 00 00	 call	 _memset
  00299	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1437 : 	}
; 1438 : 	m_nHashTableSize = nHashSize;

  0029c	89 77 08	 mov	 DWORD PTR [edi+8], esi

; 1595 : 		ENSURE(m_pHashTable);

  0029f	83 7f 04 00	 cmp	 DWORD PTR [edi+4], 0
  002a3	0f 84 fa 00 00
	00		 je	 $LN131@Serialize
  002a9	eb 21		 jmp	 SHORT $LN166@Serialize
$LN75@Serialize:

; 1541 : 	for (pAssoc = m_pHashTable[nHashBucket]; pAssoc != NULL; pAssoc = pAssoc->pNext)

  002ab	8b 34 88	 mov	 esi, DWORD PTR [eax+ecx*4]
  002ae	85 f6		 test	 esi, esi
  002b0	74 1a		 je	 SHORT $LN166@Serialize
  002b2	8b 45 e8	 mov	 eax, DWORD PTR tv846[ebp]
  002b5	8b 4d e4	 mov	 ecx, DWORD PTR _key$1$[ebp]
$LL74@Serialize:

; 1542 : 	{
; 1543 : 		if (pAssoc->nHashValue == nHashValue && CompareElements(&pAssoc->key, &key))

  002b8	39 46 0c	 cmp	 DWORD PTR [esi+12], eax
  002bb	75 08		 jne	 SHORT $LN72@Serialize
  002bd	39 0e		 cmp	 DWORD PTR [esi], ecx
  002bf	0f 84 87 00 00
	00		 je	 $LN67@Serialize
$LN72@Serialize:

; 1537 : 		return NULL;
; 1538 : 
; 1539 : 	// see if it exists
; 1540 : 	CAssoc* pAssoc;
; 1541 : 	for (pAssoc = m_pHashTable[nHashBucket]; pAssoc != NULL; pAssoc = pAssoc->pNext)

  002c5	8b 76 08	 mov	 esi, DWORD PTR [esi+8]
  002c8	85 f6		 test	 esi, esi
  002ca	75 ec		 jne	 SHORT $LL74@Serialize
$LN166@Serialize:

; 1481 : 	if (m_pFreeList == NULL)

  002cc	83 7f 10 00	 cmp	 DWORD PTR [edi+16], 0
  002d0	75 31		 jne	 SHORT $LN105@Serialize

; 1482 : 	{
; 1483 : 		// add another block
; 1484 : 		CPlex* newBlock = CPlex::Create(m_pBlocks, m_nBlockSize, sizeof(CMap::CAssoc));

  002d2	6a 10		 push	 16			; 00000010H
  002d4	ff 77 18	 push	 DWORD PTR [edi+24]
  002d7	8d 47 14	 lea	 eax, DWORD PTR [edi+20]
  002da	50		 push	 eax
  002db	e8 00 00 00 00	 call	 ?Create@CPlex@@SGPAU1@AAPAU1@II@Z ; CPlex::Create

; 1485 : 		// chain them into free list
; 1486 : 		CMap::CAssoc* pAssoc = (CMap::CAssoc*) newBlock->data();
; 1487 : 		// free in reverse order to make it easier to debug
; 1488 : 		pAssoc += m_nBlockSize - 1;

  002e0	8b 57 18	 mov	 edx, DWORD PTR [edi+24]
  002e3	8b ca		 mov	 ecx, edx
  002e5	c1 e1 04	 shl	 ecx, 4
  002e8	83 c1 f8	 add	 ecx, -8			; fffffff8H
  002eb	03 c8		 add	 ecx, eax

; 1489 : 		for (INT_PTR i = m_nBlockSize-1; i >= 0; i--, pAssoc--)

  002ed	83 c2 ff	 add	 edx, -1
  002f0	78 11		 js	 SHORT $LN105@Serialize
$LL102@Serialize:

; 1490 : 		{
; 1491 : 			pAssoc->pNext = m_pFreeList;

  002f2	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  002f5	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1492 : 			m_pFreeList = pAssoc;

  002f8	89 4f 10	 mov	 DWORD PTR [edi+16], ecx
  002fb	83 e9 10	 sub	 ecx, 16			; 00000010H
  002fe	83 ea 01	 sub	 edx, 1
  00301	79 ef		 jns	 SHORT $LL102@Serialize
$LN105@Serialize:

; 1493 : 		}
; 1494 : 	}
; 1495 : 	ENSURE(m_pFreeList != NULL);  // we must have something

  00303	8b 77 10	 mov	 esi, DWORD PTR [edi+16]
  00306	85 f6		 test	 esi, esi
  00308	0f 84 95 00 00
	00		 je	 $LN131@Serialize

; 1496 : 
; 1497 : 	CMap::CAssoc* pAssoc = m_pFreeList;
; 1498 : 
; 1499 : 	// zero the memory
; 1500 : 	CMap::CAssoc* pTemp = pAssoc->pNext;

  0030e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]

; 1256 : 		CPair( ARG_KEY keyval ) : key( keyval )	{}

  00311	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00314	0f 57 c0	 xorps	 xmm0, xmm0

; 1501 : 	memset( pAssoc, 0, sizeof(CMap::CAssoc) );

  00317	0f 11 06	 movups	 XMMWORD PTR [esi], xmm0

; 1502 : 	pAssoc->pNext = pTemp;

  0031a	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 1503 : 
; 1504 : 	m_pFreeList = m_pFreeList->pNext;

  0031d	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00320	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 1505 : 	m_nCount++;

  00323	ff 47 0c	 inc	 DWORD PTR [edi+12]
  00326	89 47 10	 mov	 DWORD PTR [edi+16], eax

; 1256 : 		CPair( ARG_KEY keyval ) : key( keyval )	{}

  00329	8b 45 e4	 mov	 eax, DWORD PTR _key$1$[ebp]
  0032c	89 06		 mov	 DWORD PTR [esi], eax
  0032e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 1598 : 		pAssoc->nHashValue = nHashValue;

  00334	8b 45 e8	 mov	 eax, DWORD PTR tv846[ebp]

; 1599 : 		//'pAssoc->value' is a constructed object, nothing more
; 1600 : 
; 1601 : 		// put into hash table
; 1602 : 		pAssoc->pNext = m_pHashTable[nHashBucket];

  00337	8b 4d d8	 mov	 ecx, DWORD PTR _nHashBucket$1$[ebp]
  0033a	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  0033d	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00340	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
  00343	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 1603 : 		m_pHashTable[nHashBucket] = pAssoc;

  00346	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00349	89 34 88	 mov	 DWORD PTR [eax+ecx*4], esi
$LN67@Serialize:

; 1350 : 	{ (*this)[key] = newValue; }

  0034c	8d 45 ec	 lea	 eax, DWORD PTR $T5[ebp]

; 1605 : 	return pAssoc->value;  // return new reference

  0034f	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]

; 1350 : 	{ (*this)[key] = newValue; }

  00352	50		 push	 eax
  00353	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
  00359	8d 4d ec	 lea	 ecx, DWORD PTR $T5[ebp]
  0035c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 1787 : 		}

  00362	ff 35 00 00 00
	00		 push	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00368	8d 45 f0	 lea	 eax, DWORD PTR _newValue$6[ebp]
  0036b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00372	6a 01		 push	 1
  00374	6a 04		 push	 4
  00376	50		 push	 eax
  00377	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  0037c	8b 45 d4	 mov	 eax, DWORD PTR _nNewCount$1$[ebp]
  0037f	85 c0		 test	 eax, eax
  00381	0f 85 cc fd ff
	ff		 jne	 $LL8@Serialize

; 1788 : 	}
; 1789 : }

  00387	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0038a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00391	59		 pop	 ecx
  00392	5f		 pop	 edi
  00393	5e		 pop	 esi
  00394	8b e5		 mov	 esp, ebp
  00396	5d		 pop	 ebp
  00397	c2 04 00	 ret	 4
$LN123@Serialize:
  0039a	6a 00		 push	 0
  0039c	6a 03		 push	 3
  0039e	e8 00 00 00 00	 call	 ?AfxThrowArchiveException@@YGXHPBD@Z ; AfxThrowArchiveException
$LN131@Serialize:

; 1495 : 	ENSURE(m_pFreeList != NULL);  // we must have something

  003a3	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN168@Serialize:
  003a8	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Serialize@?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@UAEXAAVCArchive@@@Z$0:
  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00005	50		 push	 eax
  00006	6a 01		 push	 1
  00008	6a 04		 push	 4
  0000a	8d 45 f0	 lea	 eax, DWORD PTR _newValue$6[ebp]
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  00013	c3		 ret	 0
__unwindfunclet$?Serialize@?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@UAEXAAVCArchive@@@Z$2:
  00014	8d 4d ec	 lea	 ecx, DWORD PTR $T5[ebp]
  00017	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0001d	cc		 int	 3
  0001e	cc		 int	 3
  0001f	cc		 int	 3
  00020	cc		 int	 3
  00021	cc		 int	 3
__ehhandler$?Serialize@?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@UAEXAAVCArchive@@@Z:
  00022	90		 npad	 1
  00023	90		 npad	 1
  00024	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00028	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0002b	8b 4a d4	 mov	 ecx, DWORD PTR [edx-44]
  0002e	33 c8		 xor	 ecx, eax
  00030	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00035	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Serialize@?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@UAEXAAVCArchive@@@Z
  0003a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Serialize@?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@UAEXAAVCArchive@@@Z ENDP ; CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >::Serialize
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ??1?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@UAE@XZ PROC ; CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >::~CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >, COMDAT
; _this$ = ecx

; 1472 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00022	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@6B@

; 1473 : 	RemoveAll();

  00028	e8 00 00 00 00	 call	 ?RemoveAll@?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@QAEXXZ ; CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >::RemoveAll

; 1474 : 	ASSERT(m_nCount == 0);
; 1475 : }

  0002d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00030	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00037	59		 pop	 ecx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
  0003c	cc		 int	 3
  0003d	cc		 int	 3
  0003e	cc		 int	 3
  0003f	cc		 int	 3
  00040	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@UAE@XZ ENDP ; CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >::~CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ?GetAssocAt@?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@IBEPAVCAssoc@1@HAAI0@Z
_TEXT	SEGMENT
_key$ = 8						; size = 4
_nHashBucket$ = 12					; size = 4
_nHashValue$ = 16					; size = 4
?GetAssocAt@?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@IBEPAVCAssoc@1@HAAI0@Z PROC ; CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >::GetAssocAt, COMDAT
; _this$ = ecx

; 1532 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 165  : 	ldiv_t HashVal = ldiv((long)(ARG_KEY)key, 127773);

  00006	b9 1d f3 01 00	 mov	 ecx, 127773		; 0001f31dH

; 1532 : {

  0000b	57		 push	 edi

; 165  : 	ldiv_t HashVal = ldiv((long)(ARG_KEY)key, 127773);

  0000c	8b 7d 08	 mov	 edi, DWORD PTR _key$[ebp]
  0000f	8b c7		 mov	 eax, edi
  00011	99		 cdq
  00012	f7 f9		 idiv	 ecx

; 166  : 	HashVal.rem = 16807 * HashVal.rem - 2836 * HashVal.quot;

  00014	69 c0 14 0b 00
	00		 imul	 eax, eax, 2836
  0001a	69 ca a7 41 00
	00		 imul	 ecx, edx, 16807
  00020	2b c8		 sub	 ecx, eax

; 1533 : 	nHashValue = HashKey<ARG_KEY>(key);

  00022	8d 81 ff ff ff
	7f		 lea	 eax, DWORD PTR [ecx+2147483647]
  00028	0f 49 c1	 cmovns	 eax, ecx
  0002b	8b 4d 10	 mov	 ecx, DWORD PTR _nHashValue$[ebp]

; 1534 : 	nHashBucket = nHashValue % m_nHashTableSize;

  0002e	33 d2		 xor	 edx, edx
  00030	89 01		 mov	 DWORD PTR [ecx], eax
  00032	f7 76 08	 div	 DWORD PTR [esi+8]
  00035	8b 45 0c	 mov	 eax, DWORD PTR _nHashBucket$[ebp]
  00038	89 10		 mov	 DWORD PTR [eax], edx

; 1535 : 
; 1536 : 	if (m_pHashTable == NULL)

  0003a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0003d	85 c0		 test	 eax, eax
  0003f	74 1f		 je	 SHORT $LN26@GetAssocAt

; 1537 : 		return NULL;
; 1538 : 
; 1539 : 	// see if it exists
; 1540 : 	CAssoc* pAssoc;
; 1541 : 	for (pAssoc = m_pHashTable[nHashBucket]; pAssoc != NULL; pAssoc = pAssoc->pNext)

  00041	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]
  00044	85 c0		 test	 eax, eax
  00046	74 18		 je	 SHORT $LN26@GetAssocAt

; 1542 : 	{
; 1543 : 		if (pAssoc->nHashValue == nHashValue && CompareElements(&pAssoc->key, &key))

  00048	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0004a	66 0f 1f 44 00
	00		 npad	 6
$LL4@GetAssocAt:
  00050	39 48 0c	 cmp	 DWORD PTR [eax+12], ecx
  00053	75 04		 jne	 SHORT $LN2@GetAssocAt

; 156  : 	return *pElement1 == *pElement2;

  00055	39 38		 cmp	 DWORD PTR [eax], edi

; 1542 : 	{
; 1543 : 		if (pAssoc->nHashValue == nHashValue && CompareElements(&pAssoc->key, &key))

  00057	74 09		 je	 SHORT $LN1@GetAssocAt
$LN2@GetAssocAt:

; 1537 : 		return NULL;
; 1538 : 
; 1539 : 	// see if it exists
; 1540 : 	CAssoc* pAssoc;
; 1541 : 	for (pAssoc = m_pHashTable[nHashBucket]; pAssoc != NULL; pAssoc = pAssoc->pNext)

  00059	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0005c	85 c0		 test	 eax, eax
  0005e	75 f0		 jne	 SHORT $LL4@GetAssocAt
$LN26@GetAssocAt:

; 1544 : 			return pAssoc;
; 1545 : 	}
; 1546 : 	return NULL;

  00060	33 c0		 xor	 eax, eax
$LN1@GetAssocAt:
  00062	5f		 pop	 edi

; 1547 : }

  00063	5e		 pop	 esi
  00064	5d		 pop	 ebp
  00065	c2 0c 00	 ret	 12			; 0000000cH
?GetAssocAt@?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@IBEPAVCAssoc@1@HAAI0@Z ENDP ; CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >::GetAssocAt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ?FreeAssoc@?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@IAEXPAVCAssoc@1@@Z
_TEXT	SEGMENT
_pAssoc$ = 8						; size = 4
?FreeAssoc@?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@IAEXPAVCAssoc@1@@Z PROC ; CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >::FreeAssoc, COMDAT
; _this$ = ecx

; 1516 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b 75 08	 mov	 esi, DWORD PTR _pAssoc$[ebp]
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
  0000a	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 1517 : 	pAssoc->CAssoc::~CAssoc();
; 1518 : 	pAssoc->pNext = m_pFreeList;

  00013	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00016	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 1519 : 	m_pFreeList = pAssoc;
; 1520 : 	m_nCount--;

  00019	83 47 0c ff	 add	 DWORD PTR [edi+12], -1
  0001d	89 77 10	 mov	 DWORD PTR [edi+16], esi

; 1521 : 	ASSERT(m_nCount >= 0);  // make sure we don't underflow
; 1522 : 
; 1523 : 	// if no more elements, cleanup completely
; 1524 : 	if (m_nCount == 0)

  00020	75 07		 jne	 SHORT $LN2@FreeAssoc

; 1525 : 		RemoveAll();

  00022	8b cf		 mov	 ecx, edi
  00024	e8 00 00 00 00	 call	 ?RemoveAll@?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@QAEXXZ ; CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >::RemoveAll
$LN2@FreeAssoc:

; 1526 : }

  00029	5f		 pop	 edi
  0002a	5e		 pop	 esi
  0002b	5d		 pop	 ebp
  0002c	c2 04 00	 ret	 4
?FreeAssoc@?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@IAEXPAVCAssoc@1@@Z ENDP ; CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >::FreeAssoc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ?NewAssoc@?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@IAEPAVCAssoc@1@H@Z
_TEXT	SEGMENT
_key$ = 8						; size = 4
?NewAssoc@?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@IAEPAVCAssoc@1@H@Z PROC ; CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >::NewAssoc, COMDAT
; _this$ = ecx

; 1480 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	57		 push	 edi

; 1481 : 	if (m_pFreeList == NULL)

  00007	83 7e 10 00	 cmp	 DWORD PTR [esi+16], 0
  0000b	75 34		 jne	 SHORT $LN7@NewAssoc

; 1482 : 	{
; 1483 : 		// add another block
; 1484 : 		CPlex* newBlock = CPlex::Create(m_pBlocks, m_nBlockSize, sizeof(CMap::CAssoc));

  0000d	6a 10		 push	 16			; 00000010H
  0000f	ff 76 18	 push	 DWORD PTR [esi+24]
  00012	8d 46 14	 lea	 eax, DWORD PTR [esi+20]
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ?Create@CPlex@@SGPAU1@AAPAU1@II@Z ; CPlex::Create

; 1485 : 		// chain them into free list
; 1486 : 		CMap::CAssoc* pAssoc = (CMap::CAssoc*) newBlock->data();
; 1487 : 		// free in reverse order to make it easier to debug
; 1488 : 		pAssoc += m_nBlockSize - 1;

  0001b	8b 56 18	 mov	 edx, DWORD PTR [esi+24]
  0001e	83 c0 08	 add	 eax, 8
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e1 04	 shl	 ecx, 4
  00026	83 c1 f0	 add	 ecx, -16		; fffffff0H
  00029	03 c1		 add	 eax, ecx

; 1489 : 		for (INT_PTR i = m_nBlockSize-1; i >= 0; i--, pAssoc--)

  0002b	83 c2 ff	 add	 edx, -1
  0002e	78 11		 js	 SHORT $LN7@NewAssoc
$LL4@NewAssoc:

; 1490 : 		{
; 1491 : 			pAssoc->pNext = m_pFreeList;

  00030	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00033	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 1492 : 			m_pFreeList = pAssoc;

  00036	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00039	83 e8 10	 sub	 eax, 16			; 00000010H
  0003c	83 ea 01	 sub	 edx, 1
  0003f	79 ef		 jns	 SHORT $LL4@NewAssoc
$LN7@NewAssoc:

; 1493 : 		}
; 1494 : 	}
; 1495 : 	ENSURE(m_pFreeList != NULL);  // we must have something

  00041	8b 7e 10	 mov	 edi, DWORD PTR [esi+16]
  00044	85 ff		 test	 edi, edi
  00046	74 2e		 je	 SHORT $LN21@NewAssoc

; 1496 : 
; 1497 : 	CMap::CAssoc* pAssoc = m_pFreeList;
; 1498 : 
; 1499 : 	// zero the memory
; 1500 : 	CMap::CAssoc* pTemp = pAssoc->pNext;

  00048	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  0004b	0f 57 c0	 xorps	 xmm0, xmm0

; 1501 : 	memset( pAssoc, 0, sizeof(CMap::CAssoc) );

  0004e	0f 11 07	 movups	 XMMWORD PTR [edi], xmm0

; 1502 : 	pAssoc->pNext = pTemp;

  00051	89 47 08	 mov	 DWORD PTR [edi+8], eax

; 1503 : 
; 1504 : 	m_pFreeList = m_pFreeList->pNext;

  00054	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00057	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]

; 1505 : 	m_nCount++;

  0005a	ff 46 0c	 inc	 DWORD PTR [esi+12]
  0005d	89 4e 10	 mov	 DWORD PTR [esi+16], ecx

; 1256 : 		CPair( ARG_KEY keyval ) : key( keyval )	{}

  00060	8b 4d 08	 mov	 ecx, DWORD PTR _key$[ebp]
  00063	89 0f		 mov	 DWORD PTR [edi], ecx
  00065	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  00068	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 1506 : 	ASSERT(m_nCount > 0);  // make sure we don't overflow
; 1507 : #pragma push_macro("new")
; 1508 : #undef new
; 1509 : 	::new(pAssoc) CMap::CAssoc(key);
; 1510 : #pragma pop_macro("new")
; 1511 : 	return pAssoc;

  0006e	8b c7		 mov	 eax, edi
  00070	5f		 pop	 edi
  00071	5e		 pop	 esi

; 1512 : }

  00072	5d		 pop	 ebp
  00073	c2 04 00	 ret	 4
$LN21@NewAssoc:

; 1493 : 		}
; 1494 : 	}
; 1495 : 	ENSURE(m_pFreeList != NULL);  // we must have something

  00076	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN19@NewAssoc:
  0007b	cc		 int	 3
?NewAssoc@?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@IAEPAVCAssoc@1@H@Z ENDP ; CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >::NewAssoc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ?InitHashTable@?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@QAEXIH@Z
_TEXT	SEGMENT
_nHashSize$ = 8						; size = 4
_bAllocNow$ = 12					; size = 4
?InitHashTable@?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@QAEXIH@Z PROC ; CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >::InitHashTable, COMDAT
; _this$ = ecx

; 1420 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	57		 push	 edi

; 1421 : 	ASSERT_VALID(this);
; 1422 : 	ASSERT(m_nCount == 0);
; 1423 : 	ASSERT(nHashSize > 0);
; 1424 : 
; 1425 : 	if (m_pHashTable != NULL)

  00007	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000a	85 c0		 test	 eax, eax
  0000c	74 10		 je	 SHORT $LN5@InitHashTa

; 1426 : 	{
; 1427 : 		// free hash table
; 1428 : 		delete[] m_pHashTable;

  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00014	83 c4 04	 add	 esp, 4

; 1429 : 		m_pHashTable = NULL;

  00017	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
$LN5@InitHashTa:

; 1430 : 	}
; 1431 : 
; 1432 : 	if (bAllocNow)

  0001e	83 7d 0c 00	 cmp	 DWORD PTR _bAllocNow$[ebp], 0
  00022	8b 7d 08	 mov	 edi, DWORD PTR _nHashSize$[ebp]
  00025	74 37		 je	 SHORT $LN6@InitHashTa

; 1433 : 	{
; 1434 : 		m_pHashTable = new CAssoc* [nHashSize];

  00027	33 c9		 xor	 ecx, ecx
  00029	8b c7		 mov	 eax, edi
  0002b	ba 04 00 00 00	 mov	 edx, 4
  00030	f7 e2		 mul	 edx
  00032	0f 90 c1	 seto	 cl
  00035	f7 d9		 neg	 ecx
  00037	0b c8		 or	 ecx, eax
  00039	51		 push	 ecx
  0003a	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  0003f	8b c8		 mov	 ecx, eax
  00041	83 c4 04	 add	 esp, 4
  00044	89 4e 04	 mov	 DWORD PTR [esi+4], ecx

; 1435 : 		ENSURE(m_pHashTable != NULL);

  00047	85 c9		 test	 ecx, ecx
  00049	74 1c		 je	 SHORT $LN11@InitHashTa

; 1436 : 		memset(m_pHashTable, 0, sizeof(CAssoc*) * nHashSize);

  0004b	8d 04 bd 00 00
	00 00		 lea	 eax, DWORD PTR [edi*4]
  00052	50		 push	 eax
  00053	6a 00		 push	 0
  00055	51		 push	 ecx
  00056	e8 00 00 00 00	 call	 _memset
  0005b	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN6@InitHashTa:

; 1437 : 	}
; 1438 : 	m_nHashTableSize = nHashSize;

  0005e	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  00061	5f		 pop	 edi
  00062	5e		 pop	 esi

; 1439 : }

  00063	5d		 pop	 ebp
  00064	c2 08 00	 ret	 8
$LN11@InitHashTa:

; 1435 : 		ENSURE(m_pHashTable != NULL);

  00067	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN9@InitHashTa:
  0006c	cc		 int	 3
?InitHashTable@?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@QAEXIH@Z ENDP ; CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >::InitHashTable
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ?RemoveAll@?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@QAEXXZ
_TEXT	SEGMENT
?RemoveAll@?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@QAEXXZ PROC ; CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >::RemoveAll, COMDAT
; _this$ = ecx

; 1443 : {

  00000	57		 push	 edi
  00001	8b f9		 mov	 edi, ecx

; 1444 : 	ASSERT_VALID(this);
; 1445 : 
; 1446 : 	if (m_pHashTable != NULL)

  00003	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00006	85 c0		 test	 eax, eax
  00008	74 45		 je	 SHORT $LN8@RemoveAll

; 1447 : 	{
; 1448 : 		// destroy elements (values and keys)
; 1449 : 		for (UINT nHash = 0; nHash < m_nHashTableSize; nHash++)

  0000a	53		 push	 ebx
  0000b	33 db		 xor	 ebx, ebx
  0000d	39 5f 08	 cmp	 DWORD PTR [edi+8], ebx
  00010	76 2c		 jbe	 SHORT $LN3@RemoveAll
  00012	56		 push	 esi
$LL4@RemoveAll:

; 1450 : 		{
; 1451 : 			CAssoc* pAssoc;
; 1452 : 			for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL;

  00013	8b 34 98	 mov	 esi, DWORD PTR [eax+ebx*4]
  00016	8b c8		 mov	 ecx, eax
  00018	85 f6		 test	 esi, esi
  0001a	74 19		 je	 SHORT $LN2@RemoveAll
  0001c	0f 1f 40 00	 npad	 4
$LL7@RemoveAll:
  00020	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 1453 : 			  pAssoc = pAssoc->pNext)

  00029	8b 76 08	 mov	 esi, DWORD PTR [esi+8]
  0002c	85 f6		 test	 esi, esi
  0002e	75 f0		 jne	 SHORT $LL7@RemoveAll
  00030	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00033	8b c8		 mov	 ecx, eax
$LN2@RemoveAll:

; 1447 : 	{
; 1448 : 		// destroy elements (values and keys)
; 1449 : 		for (UINT nHash = 0; nHash < m_nHashTableSize; nHash++)

  00035	43		 inc	 ebx
  00036	3b 5f 08	 cmp	 ebx, DWORD PTR [edi+8]
  00039	72 d8		 jb	 SHORT $LL4@RemoveAll
  0003b	8b c1		 mov	 eax, ecx
  0003d	5e		 pop	 esi
$LN3@RemoveAll:

; 1454 : 			{
; 1455 : 				pAssoc->CAssoc::~CAssoc();
; 1456 : 			}
; 1457 : 		}
; 1458 : 
; 1459 : 		// free hash table
; 1460 : 		delete[] m_pHashTable;

  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00044	83 c4 04	 add	 esp, 4

; 1461 : 		m_pHashTable = NULL;

  00047	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0
  0004e	5b		 pop	 ebx
$LN8@RemoveAll:

; 1462 : 	}
; 1463 : 
; 1464 : 	m_nCount = 0;
; 1465 : 	m_pFreeList = NULL;
; 1466 : 	m_pBlocks->FreeDataChain();

  0004f	8b 4f 14	 mov	 ecx, DWORD PTR [edi+20]
  00052	c7 47 0c 00 00
	00 00		 mov	 DWORD PTR [edi+12], 0
  00059	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0
  00060	e8 00 00 00 00	 call	 ?FreeDataChain@CPlex@@QAEXXZ ; CPlex::FreeDataChain

; 1467 : 	m_pBlocks = NULL;

  00065	c7 47 14 00 00
	00 00		 mov	 DWORD PTR [edi+20], 0
  0006c	5f		 pop	 edi

; 1468 : }

  0006d	c3		 ret	 0
?RemoveAll@?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@QAEXXZ ENDP ; CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >::RemoveAll
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ?RemoveKey@?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@QAEHH@Z
_TEXT	SEGMENT
_key$ = 8						; size = 4
?RemoveKey@?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@QAEHH@Z PROC ; CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >::RemoveKey, COMDAT
; _this$ = ecx

; 1611 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b f9		 mov	 edi, ecx

; 1612 : 	ASSERT_VALID(this);
; 1613 : 
; 1614 : 	if (m_pHashTable == NULL)

  00008	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
  0000b	85 f6		 test	 esi, esi
  0000d	74 47		 je	 SHORT $LN35@RemoveKey

; 165  : 	ldiv_t HashVal = ldiv((long)(ARG_KEY)key, 127773);

  0000f	8b 45 08	 mov	 eax, DWORD PTR _key$[ebp]
  00012	b9 1d f3 01 00	 mov	 ecx, 127773		; 0001f31dH
  00017	99		 cdq
  00018	f7 f9		 idiv	 ecx

; 166  : 	HashVal.rem = 16807 * HashVal.rem - 2836 * HashVal.quot;

  0001a	69 ca a7 41 00
	00		 imul	 ecx, edx, 16807
  00020	69 c0 14 0b 00
	00		 imul	 eax, eax, 2836
  00026	2b c8		 sub	 ecx, eax

; 1615 : 		return FALSE;  // nothing in the table
; 1616 : 
; 1617 : 	UINT nHashValue;
; 1618 : 	CAssoc** ppAssocPrev;
; 1619 : 	nHashValue = HashKey<ARG_KEY>(key);
; 1620 : 	ppAssocPrev = &m_pHashTable[nHashValue%m_nHashTableSize];

  00028	8d 99 ff ff ff
	7f		 lea	 ebx, DWORD PTR [ecx+2147483647]
  0002e	0f 49 d9	 cmovns	 ebx, ecx
  00031	33 d2		 xor	 edx, edx
  00033	8b c3		 mov	 eax, ebx
  00035	f7 77 08	 div	 DWORD PTR [edi+8]
  00038	8d 0c 96	 lea	 ecx, DWORD PTR [esi+edx*4]

; 1621 : 
; 1622 : 	CAssoc* pAssoc;
; 1623 : 	for (pAssoc = *ppAssocPrev; pAssoc != NULL; pAssoc = pAssoc->pNext)

  0003b	8b 31		 mov	 esi, DWORD PTR [ecx]
  0003d	85 f6		 test	 esi, esi
  0003f	74 15		 je	 SHORT $LN35@RemoveKey
$LL4@RemoveKey:

; 1624 : 	{
; 1625 : 		if ((pAssoc->nHashValue == nHashValue) && CompareElements(&pAssoc->key, &key))

  00041	39 5e 0c	 cmp	 DWORD PTR [esi+12], ebx
  00044	75 07		 jne	 SHORT $LN6@RemoveKey

; 156  : 	return *pElement1 == *pElement2;

  00046	8b 45 08	 mov	 eax, DWORD PTR _key$[ebp]
  00049	39 06		 cmp	 DWORD PTR [esi], eax

; 1624 : 	{
; 1625 : 		if ((pAssoc->nHashValue == nHashValue) && CompareElements(&pAssoc->key, &key))

  0004b	74 12		 je	 SHORT $LN31@RemoveKey
$LN6@RemoveKey:

; 1629 : 			FreeAssoc(pAssoc);
; 1630 : 			return TRUE;
; 1631 : 		}
; 1632 : 		ppAssocPrev = &pAssoc->pNext;

  0004d	8d 4e 08	 lea	 ecx, DWORD PTR [esi+8]
  00050	8b 31		 mov	 esi, DWORD PTR [ecx]
  00052	85 f6		 test	 esi, esi
  00054	75 eb		 jne	 SHORT $LL4@RemoveKey
$LN35@RemoveKey:
  00056	5f		 pop	 edi

; 1633 : 	}
; 1634 : 	return FALSE;  // not found
; 1635 : }

  00057	5e		 pop	 esi
  00058	33 c0		 xor	 eax, eax
  0005a	5b		 pop	 ebx
  0005b	5d		 pop	 ebp
  0005c	c2 04 00	 ret	 4
$LN31@RemoveKey:

; 1626 : 		{
; 1627 : 			// remove it
; 1628 : 			*ppAssocPrev = pAssoc->pNext;  // remove from list

  0005f	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00062	89 01		 mov	 DWORD PTR [ecx], eax
  00064	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00067	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 1518 : 	pAssoc->pNext = m_pFreeList;

  0006d	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00070	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 1519 : 	m_pFreeList = pAssoc;
; 1520 : 	m_nCount--;

  00073	83 47 0c ff	 add	 DWORD PTR [edi+12], -1
  00077	89 77 10	 mov	 DWORD PTR [edi+16], esi

; 1521 : 	ASSERT(m_nCount >= 0);  // make sure we don't underflow
; 1522 : 
; 1523 : 	// if no more elements, cleanup completely
; 1524 : 	if (m_nCount == 0)

  0007a	75 07		 jne	 SHORT $LN21@RemoveKey

; 1525 : 		RemoveAll();

  0007c	8b cf		 mov	 ecx, edi
  0007e	e8 00 00 00 00	 call	 ?RemoveAll@?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@QAEXXZ ; CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >::RemoveAll
$LN21@RemoveKey:
  00083	5f		 pop	 edi

; 1633 : 	}
; 1634 : 	return FALSE;  // not found
; 1635 : }

  00084	5e		 pop	 esi
  00085	b8 01 00 00 00	 mov	 eax, 1
  0008a	5b		 pop	 ebx
  0008b	5d		 pop	 ebp
  0008c	c2 04 00	 ret	 4
?RemoveKey@?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@QAEHH@Z ENDP ; CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >::RemoveKey
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ?SetAt@?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@QAEXHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
_TEXT	SEGMENT
_nHashBucket$2 = -20					; size = 4
_nHashValue$3 = -16					; size = 4
__$EHRec$ = -12						; size = 12
_key$ = 8						; size = 4
_newValue$ = 12						; size = 4
?SetAt@?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@QAEXHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z PROC ; CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >::SetAt, COMDAT
; _this$ = ecx

; 1350 : 	{ (*this)[key] = newValue; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?SetAt@?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@QAEXHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	50		 push	 eax
  0001e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00027	8b f1		 mov	 esi, ecx

; 1590 : 	if ((pAssoc = GetAssocAt(key, nHashBucket, nHashValue)) == NULL)

  00029	8d 45 f0	 lea	 eax, DWORD PTR _nHashValue$3[ebp]

; 1350 : 	{ (*this)[key] = newValue; }

  0002c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 1590 : 	if ((pAssoc = GetAssocAt(key, nHashBucket, nHashValue)) == NULL)

  00033	50		 push	 eax
  00034	8d 45 ec	 lea	 eax, DWORD PTR _nHashBucket$2[ebp]
  00037	50		 push	 eax
  00038	ff 75 08	 push	 DWORD PTR _key$[ebp]
  0003b	e8 00 00 00 00	 call	 ?GetAssocAt@?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@IBEPAVCAssoc@1@HAAI0@Z ; CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >::GetAssocAt
  00040	8b f8		 mov	 edi, eax
  00042	85 ff		 test	 edi, edi
  00044	0f 85 d7 00 00
	00		 jne	 $LN8@SetAt

; 1591 : 	{
; 1592 : 		if (m_pHashTable == NULL)

  0004a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0004d	85 c0		 test	 eax, eax
  0004f	75 4a		 jne	 SHORT $LN44@SetAt

; 1593 : 			InitHashTable(m_nHashTableSize);

  00051	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]

; 1434 : 		m_pHashTable = new CAssoc* [nHashSize];

  00054	33 c9		 xor	 ecx, ecx
  00056	8b c7		 mov	 eax, edi
  00058	ba 04 00 00 00	 mov	 edx, 4
  0005d	f7 e2		 mul	 edx
  0005f	0f 90 c1	 seto	 cl
  00062	f7 d9		 neg	 ecx
  00064	0b c8		 or	 ecx, eax
  00066	51		 push	 ecx
  00067	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  0006c	83 c4 04	 add	 esp, 4
  0006f	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 1435 : 		ENSURE(m_pHashTable != NULL);

  00072	85 c0		 test	 eax, eax
  00074	0f 84 d0 00 00
	00		 je	 $LN40@SetAt

; 1436 : 		memset(m_pHashTable, 0, sizeof(CAssoc*) * nHashSize);

  0007a	8d 0c bd 00 00
	00 00		 lea	 ecx, DWORD PTR [edi*4]
  00081	51		 push	 ecx
  00082	6a 00		 push	 0
  00084	50		 push	 eax
  00085	e8 00 00 00 00	 call	 _memset

; 1437 : 	}
; 1438 : 	m_nHashTableSize = nHashSize;

  0008a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0008d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00090	89 7e 08	 mov	 DWORD PTR [esi+8], edi

; 1595 : 		ENSURE(m_pHashTable);

  00093	85 c0		 test	 eax, eax
  00095	0f 84 af 00 00
	00		 je	 $LN40@SetAt
$LN44@SetAt:

; 1481 : 	if (m_pFreeList == NULL)

  0009b	83 7e 10 00	 cmp	 DWORD PTR [esi+16], 0
  0009f	75 34		 jne	 SHORT $LN27@SetAt

; 1482 : 	{
; 1483 : 		// add another block
; 1484 : 		CPlex* newBlock = CPlex::Create(m_pBlocks, m_nBlockSize, sizeof(CMap::CAssoc));

  000a1	6a 10		 push	 16			; 00000010H
  000a3	ff 76 18	 push	 DWORD PTR [esi+24]
  000a6	8d 46 14	 lea	 eax, DWORD PTR [esi+20]
  000a9	50		 push	 eax
  000aa	e8 00 00 00 00	 call	 ?Create@CPlex@@SGPAU1@AAPAU1@II@Z ; CPlex::Create

; 1485 : 		// chain them into free list
; 1486 : 		CMap::CAssoc* pAssoc = (CMap::CAssoc*) newBlock->data();
; 1487 : 		// free in reverse order to make it easier to debug
; 1488 : 		pAssoc += m_nBlockSize - 1;

  000af	8b 56 18	 mov	 edx, DWORD PTR [esi+24]
  000b2	83 c0 08	 add	 eax, 8
  000b5	8b ca		 mov	 ecx, edx
  000b7	c1 e1 04	 shl	 ecx, 4
  000ba	83 c1 f0	 add	 ecx, -16		; fffffff0H
  000bd	03 c8		 add	 ecx, eax

; 1489 : 		for (INT_PTR i = m_nBlockSize-1; i >= 0; i--, pAssoc--)

  000bf	83 c2 ff	 add	 edx, -1
  000c2	78 11		 js	 SHORT $LN27@SetAt
$LL24@SetAt:

; 1490 : 		{
; 1491 : 			pAssoc->pNext = m_pFreeList;

  000c4	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000c7	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1492 : 			m_pFreeList = pAssoc;

  000ca	89 4e 10	 mov	 DWORD PTR [esi+16], ecx
  000cd	83 e9 10	 sub	 ecx, 16			; 00000010H
  000d0	83 ea 01	 sub	 edx, 1
  000d3	79 ef		 jns	 SHORT $LL24@SetAt
$LN27@SetAt:

; 1493 : 		}
; 1494 : 	}
; 1495 : 	ENSURE(m_pFreeList != NULL);  // we must have something

  000d5	8b 7e 10	 mov	 edi, DWORD PTR [esi+16]
  000d8	85 ff		 test	 edi, edi
  000da	74 6e		 je	 SHORT $LN40@SetAt

; 1496 : 
; 1497 : 	CMap::CAssoc* pAssoc = m_pFreeList;
; 1498 : 
; 1499 : 	// zero the memory
; 1500 : 	CMap::CAssoc* pTemp = pAssoc->pNext;

  000dc	8b 47 08	 mov	 eax, DWORD PTR [edi+8]

; 1256 : 		CPair( ARG_KEY keyval ) : key( keyval )	{}

  000df	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  000e2	0f 57 c0	 xorps	 xmm0, xmm0

; 1501 : 	memset( pAssoc, 0, sizeof(CMap::CAssoc) );

  000e5	0f 11 07	 movups	 XMMWORD PTR [edi], xmm0

; 1502 : 	pAssoc->pNext = pTemp;

  000e8	89 47 08	 mov	 DWORD PTR [edi+8], eax

; 1503 : 
; 1504 : 	m_pFreeList = m_pFreeList->pNext;

  000eb	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000ee	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 1505 : 	m_nCount++;

  000f1	ff 46 0c	 inc	 DWORD PTR [esi+12]
  000f4	89 46 10	 mov	 DWORD PTR [esi+16], eax

; 1256 : 		CPair( ARG_KEY keyval ) : key( keyval )	{}

  000f7	8b 45 08	 mov	 eax, DWORD PTR _key$[ebp]
  000fa	89 07		 mov	 DWORD PTR [edi], eax
  000fc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 1598 : 		pAssoc->nHashValue = nHashValue;

  00102	8b 45 f0	 mov	 eax, DWORD PTR _nHashValue$3[ebp]
  00105	89 47 0c	 mov	 DWORD PTR [edi+12], eax

; 1599 : 		//'pAssoc->value' is a constructed object, nothing more
; 1600 : 
; 1601 : 		// put into hash table
; 1602 : 		pAssoc->pNext = m_pHashTable[nHashBucket];

  00108	8b 45 ec	 mov	 eax, DWORD PTR _nHashBucket$2[ebp]
  0010b	8d 0c 85 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*4]
  00112	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00115	8b 04 01	 mov	 eax, DWORD PTR [ecx+eax]
  00118	89 47 08	 mov	 DWORD PTR [edi+8], eax

; 1603 : 		m_pHashTable[nHashBucket] = pAssoc;

  0011b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0011e	89 3c 01	 mov	 DWORD PTR [ecx+eax], edi
$LN8@SetAt:

; 1350 : 	{ (*this)[key] = newValue; }

  00121	8d 45 0c	 lea	 eax, DWORD PTR _newValue$[ebp]
  00124	50		 push	 eax

; 1605 : 	return pAssoc->value;  // return new reference

  00125	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]

; 1350 : 	{ (*this)[key] = newValue; }

  00128	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
  0012e	8d 4d 0c	 lea	 ecx, DWORD PTR _newValue$[ebp]
  00131	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00137	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0013a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00141	59		 pop	 ecx
  00142	5f		 pop	 edi
  00143	5e		 pop	 esi
  00144	8b e5		 mov	 esp, ebp
  00146	5d		 pop	 ebp
  00147	c2 08 00	 ret	 8
$LN40@SetAt:

; 1495 : 	ENSURE(m_pFreeList != NULL);  // we must have something

  0014a	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN42@SetAt:
  0014f	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SetAt@?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@QAEXHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z$0:
  00000	8d 4d 0c	 lea	 ecx, DWORD PTR _newValue$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
  0000d	cc		 int	 3
__ehhandler$?SetAt@?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@QAEXHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z:
  0000e	90		 npad	 1
  0000f	90		 npad	 1
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?SetAt@?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@QAEXHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
  00026	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?SetAt@?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@QAEXHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ENDP ; CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >::SetAt
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ??A?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@QAEAAV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z
_TEXT	SEGMENT
_nHashBucket$ = -8					; size = 4
_nHashValue$ = -4					; size = 4
_key$ = 8						; size = 4
??A?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@QAEAAV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z PROC ; CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >::operator[], COMDAT
; _this$ = ecx

; 1585 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1586 : 	ASSERT_VALID(this);
; 1587 : 
; 1588 : 	UINT nHashBucket, nHashValue;
; 1589 : 	CAssoc* pAssoc;
; 1590 : 	if ((pAssoc = GetAssocAt(key, nHashBucket, nHashValue)) == NULL)

  00006	8d 45 fc	 lea	 eax, DWORD PTR _nHashValue$[ebp]
  00009	53		 push	 ebx
  0000a	8b 5d 08	 mov	 ebx, DWORD PTR _key$[ebp]
  0000d	56		 push	 esi
  0000e	57		 push	 edi
  0000f	50		 push	 eax
  00010	8d 45 f8	 lea	 eax, DWORD PTR _nHashBucket$[ebp]
  00013	8b f1		 mov	 esi, ecx
  00015	50		 push	 eax
  00016	53		 push	 ebx
  00017	e8 00 00 00 00	 call	 ?GetAssocAt@?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@IBEPAVCAssoc@1@HAAI0@Z ; CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >::GetAssocAt
  0001c	8b f8		 mov	 edi, eax
  0001e	85 ff		 test	 edi, edi
  00020	0f 85 d4 00 00
	00		 jne	 $LN5@operator

; 1591 : 	{
; 1592 : 		if (m_pHashTable == NULL)

  00026	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00029	85 c0		 test	 eax, eax
  0002b	75 4a		 jne	 SHORT $LN39@operator

; 1593 : 			InitHashTable(m_nHashTableSize);

  0002d	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]

; 1434 : 		m_pHashTable = new CAssoc* [nHashSize];

  00030	33 c9		 xor	 ecx, ecx
  00032	8b c7		 mov	 eax, edi
  00034	ba 04 00 00 00	 mov	 edx, 4
  00039	f7 e2		 mul	 edx
  0003b	0f 90 c1	 seto	 cl
  0003e	f7 d9		 neg	 ecx
  00040	0b c8		 or	 ecx, eax
  00042	51		 push	 ecx
  00043	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00048	83 c4 04	 add	 esp, 4
  0004b	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 1435 : 		ENSURE(m_pHashTable != NULL);

  0004e	85 c0		 test	 eax, eax
  00050	0f 84 b0 00 00
	00		 je	 $LN36@operator

; 1436 : 		memset(m_pHashTable, 0, sizeof(CAssoc*) * nHashSize);

  00056	8d 0c bd 00 00
	00 00		 lea	 ecx, DWORD PTR [edi*4]
  0005d	51		 push	 ecx
  0005e	6a 00		 push	 0
  00060	50		 push	 eax
  00061	e8 00 00 00 00	 call	 _memset

; 1437 : 	}
; 1438 : 	m_nHashTableSize = nHashSize;

  00066	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00069	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006c	89 7e 08	 mov	 DWORD PTR [esi+8], edi

; 1594 : 
; 1595 : 		ENSURE(m_pHashTable);

  0006f	85 c0		 test	 eax, eax
  00071	0f 84 8f 00 00
	00		 je	 $LN36@operator
$LN39@operator:

; 1481 : 	if (m_pFreeList == NULL)

  00077	83 7e 10 00	 cmp	 DWORD PTR [esi+16], 0
  0007b	75 34		 jne	 SHORT $LN24@operator

; 1482 : 	{
; 1483 : 		// add another block
; 1484 : 		CPlex* newBlock = CPlex::Create(m_pBlocks, m_nBlockSize, sizeof(CMap::CAssoc));

  0007d	6a 10		 push	 16			; 00000010H
  0007f	ff 76 18	 push	 DWORD PTR [esi+24]
  00082	8d 46 14	 lea	 eax, DWORD PTR [esi+20]
  00085	50		 push	 eax
  00086	e8 00 00 00 00	 call	 ?Create@CPlex@@SGPAU1@AAPAU1@II@Z ; CPlex::Create

; 1485 : 		// chain them into free list
; 1486 : 		CMap::CAssoc* pAssoc = (CMap::CAssoc*) newBlock->data();
; 1487 : 		// free in reverse order to make it easier to debug
; 1488 : 		pAssoc += m_nBlockSize - 1;

  0008b	8b 56 18	 mov	 edx, DWORD PTR [esi+24]
  0008e	83 c0 08	 add	 eax, 8
  00091	8b ca		 mov	 ecx, edx
  00093	c1 e1 04	 shl	 ecx, 4
  00096	83 c1 f0	 add	 ecx, -16		; fffffff0H
  00099	03 c8		 add	 ecx, eax

; 1489 : 		for (INT_PTR i = m_nBlockSize-1; i >= 0; i--, pAssoc--)

  0009b	83 c2 ff	 add	 edx, -1
  0009e	78 11		 js	 SHORT $LN24@operator
$LL21@operator:

; 1490 : 		{
; 1491 : 			pAssoc->pNext = m_pFreeList;

  000a0	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000a3	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1492 : 			m_pFreeList = pAssoc;

  000a6	89 4e 10	 mov	 DWORD PTR [esi+16], ecx
  000a9	83 e9 10	 sub	 ecx, 16			; 00000010H
  000ac	83 ea 01	 sub	 edx, 1
  000af	79 ef		 jns	 SHORT $LL21@operator
$LN24@operator:

; 1493 : 		}
; 1494 : 	}
; 1495 : 	ENSURE(m_pFreeList != NULL);  // we must have something

  000b1	8b 7e 10	 mov	 edi, DWORD PTR [esi+16]
  000b4	85 ff		 test	 edi, edi
  000b6	74 4e		 je	 SHORT $LN36@operator

; 1496 : 
; 1497 : 	CMap::CAssoc* pAssoc = m_pFreeList;
; 1498 : 
; 1499 : 	// zero the memory
; 1500 : 	CMap::CAssoc* pTemp = pAssoc->pNext;

  000b8	8b 47 08	 mov	 eax, DWORD PTR [edi+8]

; 1256 : 		CPair( ARG_KEY keyval ) : key( keyval )	{}

  000bb	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  000be	0f 57 c0	 xorps	 xmm0, xmm0

; 1501 : 	memset( pAssoc, 0, sizeof(CMap::CAssoc) );

  000c1	0f 11 07	 movups	 XMMWORD PTR [edi], xmm0

; 1502 : 	pAssoc->pNext = pTemp;

  000c4	89 47 08	 mov	 DWORD PTR [edi+8], eax

; 1503 : 
; 1504 : 	m_pFreeList = m_pFreeList->pNext;

  000c7	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000ca	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 1505 : 	m_nCount++;

  000cd	ff 46 0c	 inc	 DWORD PTR [esi+12]
  000d0	89 46 10	 mov	 DWORD PTR [esi+16], eax

; 1256 : 		CPair( ARG_KEY keyval ) : key( keyval )	{}

  000d3	89 1f		 mov	 DWORD PTR [edi], ebx
  000d5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 1596 : 		// it doesn't exist, add a new Association
; 1597 : 		pAssoc = NewAssoc(key);
; 1598 : 		pAssoc->nHashValue = nHashValue;

  000db	8b 45 fc	 mov	 eax, DWORD PTR _nHashValue$[ebp]
  000de	89 47 0c	 mov	 DWORD PTR [edi+12], eax

; 1599 : 		//'pAssoc->value' is a constructed object, nothing more
; 1600 : 
; 1601 : 		// put into hash table
; 1602 : 		pAssoc->pNext = m_pHashTable[nHashBucket];

  000e1	8b 45 f8	 mov	 eax, DWORD PTR _nHashBucket$[ebp]
  000e4	8d 0c 85 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*4]
  000eb	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000ee	8b 04 01	 mov	 eax, DWORD PTR [ecx+eax]
  000f1	89 47 08	 mov	 DWORD PTR [edi+8], eax

; 1603 : 		m_pHashTable[nHashBucket] = pAssoc;

  000f4	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000f7	89 3c 01	 mov	 DWORD PTR [ecx+eax], edi
$LN5@operator:

; 1604 : 	}
; 1605 : 	return pAssoc->value;  // return new reference

  000fa	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  000fd	5f		 pop	 edi
  000fe	5e		 pop	 esi
  000ff	5b		 pop	 ebx

; 1606 : }

  00100	8b e5		 mov	 esp, ebp
  00102	5d		 pop	 ebp
  00103	c2 04 00	 ret	 4
$LN36@operator:

; 1495 : 	ENSURE(m_pFreeList != NULL);  // we must have something

  00106	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN37@operator:
  0010b	cc		 int	 3
??A?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@QAEAAV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z ENDP ; CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ?Lookup@?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@QBEHHAAV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
_TEXT	SEGMENT
_nHashBucket$ = -8					; size = 4
_nHashValue$ = -4					; size = 4
_key$ = 8						; size = 4
_rValue$ = 12						; size = 4
?Lookup@?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@QBEHHAAV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z PROC ; CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >::Lookup, COMDAT
; _this$ = ecx

; 1551 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1552 : 	ASSERT_VALID(this);
; 1553 : 
; 1554 : 	UINT nHashBucket, nHashValue;
; 1555 : 	CAssoc* pAssoc = GetAssocAt(key, nHashBucket, nHashValue);

  00006	8d 45 fc	 lea	 eax, DWORD PTR _nHashValue$[ebp]
  00009	50		 push	 eax
  0000a	8d 45 f8	 lea	 eax, DWORD PTR _nHashBucket$[ebp]
  0000d	50		 push	 eax
  0000e	ff 75 08	 push	 DWORD PTR _key$[ebp]
  00011	e8 00 00 00 00	 call	 ?GetAssocAt@?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@IBEPAVCAssoc@1@HAAI0@Z ; CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >::GetAssocAt

; 1556 : 	if (pAssoc == NULL)

  00016	85 c0		 test	 eax, eax
  00018	75 06		 jne	 SHORT $LN2@Lookup

; 1561 : }

  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c2 08 00	 ret	 8
$LN2@Lookup:

; 1557 : 		return FALSE;  // not in map
; 1558 : 
; 1559 : 	rValue = pAssoc->value;

  00020	8b 4d 0c	 mov	 ecx, DWORD PTR _rValue$[ebp]
  00023	83 c0 04	 add	 eax, 4
  00026	50		 push	 eax
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z

; 1560 : 	return TRUE;

  0002d	b8 01 00 00 00	 mov	 eax, 1

; 1561 : }

  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c2 08 00	 ret	 8
?Lookup@?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@QBEHHAAV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ENDP ; CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >::Lookup
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ??0?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@QAE@H@Z
_TEXT	SEGMENT
_nBlockSize$ = 8					; size = 4
??0?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@QAE@H@Z PROC ; CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >::CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >, COMDAT
; _this$ = ecx

; 1403 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1404 : 	ASSERT(nBlockSize > 0);
; 1405 : 
; 1406 : 	m_pHashTable = NULL;
; 1407 : 	m_nHashTableSize = 17;  // default size
; 1408 : 	m_nCount = 0;
; 1409 : 	m_pFreeList = NULL;
; 1410 : 	m_pBlocks = NULL;
; 1411 : 	m_nBlockSize = nBlockSize;

  00003	8b 45 08	 mov	 eax, DWORD PTR _nBlockSize$[ebp]
  00006	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 1412 : }

  00009	8b c1		 mov	 eax, ecx
  0000b	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@6B@
  00011	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  00018	c7 41 08 11 00
	00 00		 mov	 DWORD PTR [ecx+8], 17	; 00000011H
  0001f	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0
  00026	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  0002d	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
??0?$CMap@HHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@@QAE@H@Z ENDP ; CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >::CMap<int,int,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >,ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
;	COMDAT ??_G?$CArray@HH@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CArray@HH@@UAEPAXI@Z PROC				; CArray<int,int>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 355  : {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 356  : 	ASSERT_VALID(this);
; 357  : 
; 358  : 	if (m_pData != NULL)

  00006	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CArray@HH@@6B@
  0000f	85 c0		 test	 eax, eax
  00011	74 09		 je	 SHORT $LN11@scalar

; 359  : 	{
; 360  : 		for( int i = 0; i < m_nSize; i++ )
; 361  : 			(m_pData + i)->~TYPE();
; 362  : 		delete[] (BYTE*)m_pData;

  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00019	83 c4 04	 add	 esp, 4
$LN11@scalar:
  0001c	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  0001f	a8 01		 test	 al, 1
  00021	74 1f		 je	 SHORT $LN20@scalar
  00023	a8 04		 test	 al, 4
  00025	75 10		 jne	 SHORT $LN3@scalar
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 112  : 	{ ::operator delete(p); }

  00027	56		 push	 esi
  00028	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0002d	83 c4 04	 add	 esp, 4
  00030	8b c6		 mov	 eax, esi
  00032	5e		 pop	 esi
  00033	5d		 pop	 ebp
  00034	c2 04 00	 ret	 4
$LN3@scalar:
  00037	6a 14		 push	 20			; 00000014H
  00039	56		 push	 esi
  0003a	e8 00 00 00 00	 call	 ?__global_delete@@YAXPAXI@Z ; __global_delete
  0003f	83 c4 08	 add	 esp, 8
$LN20@scalar:
  00042	8b c6		 mov	 eax, esi
  00044	5e		 pop	 esi
  00045	5d		 pop	 ebp
  00046	c2 04 00	 ret	 4
??_G?$CArray@HH@@UAEPAXI@Z ENDP				; CArray<int,int>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ?Serialize@?$CArray@HH@@UAEXAAVCArchive@@@Z
_TEXT	SEGMENT
_ar$ = 8						; size = 4
?Serialize@?$CArray@HH@@UAEXAAVCArchive@@@Z PROC	; CArray<int,int>::Serialize, COMDAT
; _this$ = ecx

; 633  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 212  : 	{ return (m_nMode & CArchive::load) == 0; }

  00005	8b 7d 08	 mov	 edi, DWORD PTR _ar$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 633  : {

  00008	8b f1		 mov	 esi, ecx

; 637  : 	if (ar.IsStoring())

  0000a	8b cf		 mov	 ecx, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 212  : 	{ return (m_nMode & CArchive::load) == 0; }

  0000c	8b 47 18	 mov	 eax, DWORD PTR [edi+24]
  0000f	f7 d0		 not	 eax
  00011	a8 01		 test	 al, 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 637  : 	if (ar.IsStoring())

  00013	74 1a		 je	 SHORT $LN2@Serialize

; 638  : 	{
; 639  : 		ar.WriteCount(m_nSize);

  00015	ff 76 08	 push	 DWORD PTR [esi+8]
  00018	e8 00 00 00 00	 call	 ?WriteCount@CArchive@@QAEXK@Z ; CArchive::WriteCount

; 645  : 	}
; 646  : 	SerializeElements<TYPE>(ar, m_pData, m_nSize);

  0001d	ff 76 08	 push	 DWORD PTR [esi+8]
  00020	ff 76 04	 push	 DWORD PTR [esi+4]
  00023	57		 push	 edi
  00024	e8 00 00 00 00	 call	 ??$SerializeElements@H@@YGXAAVCArchive@@PAHH@Z ; SerializeElements<int>
  00029	5f		 pop	 edi
  0002a	5e		 pop	 esi

; 647  : }

  0002b	5d		 pop	 ebp
  0002c	c2 04 00	 ret	 4
$LN2@Serialize:

; 640  : 	}
; 641  : 	else
; 642  : 	{
; 643  : 		DWORD_PTR nOldSize = ar.ReadCount();

  0002f	e8 00 00 00 00	 call	 ?ReadCount@CArchive@@QAEKXZ ; CArchive::ReadCount

; 644  : 		SetSize(nOldSize, -1);

  00034	6a ff		 push	 -1
  00036	50		 push	 eax
  00037	8b ce		 mov	 ecx, esi
  00039	e8 00 00 00 00	 call	 ?SetSize@?$CArray@HH@@QAEXHH@Z ; CArray<int,int>::SetSize

; 645  : 	}
; 646  : 	SerializeElements<TYPE>(ar, m_pData, m_nSize);

  0003e	ff 76 08	 push	 DWORD PTR [esi+8]
  00041	ff 76 04	 push	 DWORD PTR [esi+4]
  00044	57		 push	 edi
  00045	e8 00 00 00 00	 call	 ??$SerializeElements@H@@YGXAAVCArchive@@PAHH@Z ; SerializeElements<int>
  0004a	5f		 pop	 edi
  0004b	5e		 pop	 esi

; 647  : }

  0004c	5d		 pop	 ebp
  0004d	c2 04 00	 ret	 4
?Serialize@?$CArray@HH@@UAEXAAVCArchive@@@Z ENDP	; CArray<int,int>::Serialize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ??1?$CArray@HH@@UAE@XZ
_TEXT	SEGMENT
??1?$CArray@HH@@UAE@XZ PROC				; CArray<int,int>::~CArray<int,int>, COMDAT
; _this$ = ecx

; 356  : 	ASSERT_VALID(this);
; 357  : 
; 358  : 	if (m_pData != NULL)

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CArray@HH@@6B@
  00009	85 c0		 test	 eax, eax
  0000b	74 07		 je	 SHORT $LN5@CArray

; 359  : 	{
; 360  : 		for( int i = 0; i < m_nSize; i++ )
; 361  : 			(m_pData + i)->~TYPE();
; 362  : 		delete[] (BYTE*)m_pData;

  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00013	59		 pop	 ecx
$LN5@CArray:

; 363  : 	}
; 364  : }

  00014	c3		 ret	 0
??1?$CArray@HH@@UAE@XZ ENDP				; CArray<int,int>::~CArray<int,int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_memcpy_s.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_memcpy_s.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlchecked.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_memcpy_s.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlchecked.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ?RemoveAt@?$CArray@HH@@QAEXHH@Z
_TEXT	SEGMENT
__N$1$ = 8						; size = 4
_nIndex$ = 8						; size = 4
_nCount$ = 12						; size = 4
?RemoveAt@?$CArray@HH@@QAEXHH@Z PROC			; CArray<int,int>::RemoveAt, COMDAT
; _this$ = ecx

; 590  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 591  : 	ASSERT_VALID(this);
; 592  : 	ASSERT(nIndex >= 0);
; 593  : 	ASSERT(nCount >= 0);
; 594  : 	INT_PTR nUpperBound = nIndex + nCount;

  00005	8b 75 0c	 mov	 esi, DWORD PTR _nCount$[ebp]
  00008	8b d9		 mov	 ebx, ecx
  0000a	57		 push	 edi
  0000b	8b 7d 08	 mov	 edi, DWORD PTR _nIndex$[ebp]
  0000e	8d 14 37	 lea	 edx, DWORD PTR [edi+esi]

; 595  : 	ASSERT(nUpperBound <= m_nSize && nUpperBound >= nIndex && nUpperBound >= nCount);
; 596  : 
; 597  : 	if(nIndex < 0 || nCount < 0 || (nUpperBound > m_nSize) || (nUpperBound < nIndex) || (nUpperBound < nCount))

  00011	85 ff		 test	 edi, edi
  00013	78 79		 js	 SHORT $LN6@RemoveAt
  00015	85 f6		 test	 esi, esi
  00017	78 75		 js	 SHORT $LN6@RemoveAt
  00019	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  0001c	3b d0		 cmp	 edx, eax
  0001e	7f 6e		 jg	 SHORT $LN6@RemoveAt
  00020	3b d7		 cmp	 edx, edi
  00022	7c 6a		 jl	 SHORT $LN6@RemoveAt
  00024	3b d6		 cmp	 edx, esi
  00026	7c 66		 jl	 SHORT $LN6@RemoveAt

; 599  : 
; 600  : 	// just remove a range
; 601  : 	INT_PTR nMoveCount = m_nSize - (nUpperBound);

  00028	8b c8		 mov	 ecx, eax
  0002a	2b ca		 sub	 ecx, edx

; 602  : 	for( int i = 0; i < nCount; i++ )
; 603  : 		(m_pData + nIndex + i)->~TYPE();
; 604  : 	if (nMoveCount)

  0002c	74 54		 je	 SHORT $LN7@RemoveAt

; 606  : 		::ATL::Checked::memmove_s(m_pData + nIndex, (size_t)nMoveCount * sizeof(TYPE),

  0002e	8d 04 8d 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*4]
  00035	89 45 08	 mov	 DWORD PTR __N$1$[ebp], eax
  00038	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0003b	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_memcpy_s.h

; 74   :         if (_SourceSize == 0)

  0003e	8b 55 08	 mov	 edx, DWORD PTR __N$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 606  : 		::ATL::Checked::memmove_s(m_pData + nIndex, (size_t)nMoveCount * sizeof(TYPE),

  00041	8d 04 b8	 lea	 eax, DWORD PTR [eax+edi*4]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_memcpy_s.h

; 74   :         if (_SourceSize == 0)

  00044	85 d2		 test	 edx, edx
  00046	74 2c		 je	 SHORT $LN22@RemoveAt

; 75   :         {
; 76   :             return 0;
; 77   :         }
; 78   : 
; 79   :         _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Destination != NULL,            EINVAL);

  00048	85 c0		 test	 eax, eax
  0004a	75 19		 jne	 SHORT $LN13@RemoveAt
$LN23@RemoveAt:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlchecked.h

; 87   : 	ATLMFC_CRT_ERRORCHECK(::memmove_s(_S1, _S1max, _S2, _N));

  0004c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___errno
  00052	c7 00 16 00 00
	00		 mov	 DWORD PTR [eax], 22	; 00000016H
  00058	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo
  0005e	b8 16 00 00 00	 mov	 eax, 22			; 00000016H
  00063	eb 11		 jmp	 SHORT $LN11@RemoveAt
$LN13@RemoveAt:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_memcpy_s.h

; 80   :         _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Source != NULL,                 EINVAL);

  00065	85 c9		 test	 ecx, ecx
  00067	74 e3		 je	 SHORT $LN23@RemoveAt

; 81   :         _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_DestinationSize >= _SourceSize, ERANGE);
; 82   : 
; 83   :         memmove(_Destination, _Source, _SourceSize);

  00069	52		 push	 edx
  0006a	51		 push	 ecx
  0006b	50		 push	 eax
  0006c	e8 00 00 00 00	 call	 _memmove
  00071	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN22@RemoveAt:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlchecked.h

; 87   : 	ATLMFC_CRT_ERRORCHECK(::memmove_s(_S1, _S1max, _S2, _N));

  00074	33 c0		 xor	 eax, eax
$LN11@RemoveAt:
  00076	50		 push	 eax
  00077	e8 00 00 00 00	 call	 ?AfxCrtErrorCheck@@YAHH@Z ; AfxCrtErrorCheck
  0007c	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  0007f	83 c4 04	 add	 esp, 4
$LN7@RemoveAt:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 609  : 	m_nSize -= nCount;

  00082	5f		 pop	 edi
  00083	2b c6		 sub	 eax, esi
  00085	5e		 pop	 esi
  00086	89 43 08	 mov	 DWORD PTR [ebx+8], eax
  00089	5b		 pop	 ebx

; 610  : }

  0008a	5d		 pop	 ebp
  0008b	c2 08 00	 ret	 8
$LN6@RemoveAt:

; 598  : 		AfxThrowInvalidArgException();

  0008e	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN21@RemoveAt:
  00093	cc		 int	 3
?RemoveAt@?$CArray@HH@@QAEXHH@Z ENDP			; CArray<int,int>::RemoveAt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_memcpy_s.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlchecked.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_memcpy_s.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlchecked.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ?InsertAt@?$CArray@HH@@QAEXHHH@Z
_TEXT	SEGMENT
tv323 = 8						; size = 4
_nIndex$ = 8						; size = 4
_newElement$ = 12					; size = 4
__S2$1$ = 16						; size = 4
__N$1$ = 16						; size = 4
_nCount$ = 16						; size = 4
?InsertAt@?$CArray@HH@@QAEXHHH@Z PROC			; CArray<int,int>::InsertAt, COMDAT
; _this$ = ecx

; 548  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	8b 75 10	 mov	 esi, DWORD PTR _nCount$[ebp]
  00008	8b d9		 mov	 ebx, ecx
  0000a	57		 push	 edi
  0000b	8b 7d 08	 mov	 edi, DWORD PTR _nIndex$[ebp]

; 549  : 	ASSERT_VALID(this);
; 550  : 	ASSERT(nIndex >= 0);    // will expand to meet need
; 551  : 	ASSERT(nCount > 0);     // zero or negative size not allowed
; 552  : 
; 553  : 	if(nIndex < 0 || nCount <= 0)

  0000e	85 ff		 test	 edi, edi
  00010	0f 88 c0 00 00
	00		 js	 $LN11@InsertAt
  00016	85 f6		 test	 esi, esi
  00018	0f 8e b8 00 00
	00		 jle	 $LN11@InsertAt

; 555  : 
; 556  : 	if (nIndex >= m_nSize)

  0001e	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  00021	8d 0c 3e	 lea	 ecx, DWORD PTR [esi+edi]
  00024	89 45 10	 mov	 DWORD PTR __N$1$[ebp], eax
  00027	89 4d 08	 mov	 DWORD PTR tv323[ebp], ecx
  0002a	6a ff		 push	 -1
  0002c	3b f8		 cmp	 edi, eax
  0002e	7c 0d		 jl	 SHORT $LN12@InsertAt

; 557  : 	{
; 558  : 		// adding after the end of the array
; 559  : 		SetSize(nIndex + nCount, -1);   // grow so nIndex is valid

  00030	51		 push	 ecx
  00031	8b cb		 mov	 ecx, ebx
  00033	e8 00 00 00 00	 call	 ?SetSize@?$CArray@HH@@QAEXHH@Z ; CArray<int,int>::SetSize
  00038	c1 e7 02	 shl	 edi, 2

; 560  : 	}

  0003b	eb 77		 jmp	 SHORT $LN7@InsertAt
$LN12@InsertAt:

; 561  : 	else
; 562  : 	{
; 563  : 		// inserting in the middle of the array
; 564  : 		INT_PTR nOldSize = m_nSize;
; 565  : 		SetSize(m_nSize + nCount, -1);  // grow it to new size

  0003d	03 c6		 add	 eax, esi
  0003f	8b cb		 mov	 ecx, ebx
  00041	50		 push	 eax
  00042	e8 00 00 00 00	 call	 ?SetSize@?$CArray@HH@@QAEXHH@Z ; CArray<int,int>::SetSize

; 566  : 		// destroy intial data before copying over it
; 567  : 		for( int i = 0; i < nCount; i++ )
; 568  : 			(m_pData + nOldSize + i)->~TYPE();
; 569  : 		// shift old data up to fill gap
; 570  : 		::ATL::Checked::memmove_s(m_pData + nIndex + nCount, (nOldSize-nIndex) * sizeof(TYPE),

  00047	8b 4d 10	 mov	 ecx, DWORD PTR __N$1$[ebp]
  0004a	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0004d	2b cf		 sub	 ecx, edi
  0004f	c1 e7 02	 shl	 edi, 2
  00052	c1 e1 02	 shl	 ecx, 2
  00055	8d 14 07	 lea	 edx, DWORD PTR [edi+eax]
  00058	89 55 10	 mov	 DWORD PTR __S2$1$[ebp], edx
  0005b	8b 55 08	 mov	 edx, DWORD PTR tv323[ebp]
  0005e	8d 14 90	 lea	 edx, DWORD PTR [eax+edx*4]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_memcpy_s.h

; 74   :         if (_SourceSize == 0)

  00061	85 c9		 test	 ecx, ecx
  00063	74 2f		 je	 SHORT $LN38@InsertAt

; 75   :         {
; 76   :             return 0;
; 77   :         }
; 78   : 
; 79   :         _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Destination != NULL,            EINVAL);

  00065	85 d2		 test	 edx, edx
  00067	75 19		 jne	 SHORT $LN19@InsertAt
$LN39@InsertAt:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlchecked.h

; 87   : 	ATLMFC_CRT_ERRORCHECK(::memmove_s(_S1, _S1max, _S2, _N));

  00069	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___errno
  0006f	c7 00 16 00 00
	00		 mov	 DWORD PTR [eax], 22	; 00000016H
  00075	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo
  0007b	b8 16 00 00 00	 mov	 eax, 22			; 00000016H
  00080	eb 14		 jmp	 SHORT $LN17@InsertAt
$LN19@InsertAt:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_memcpy_s.h

; 80   :         _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Source != NULL,                 EINVAL);

  00082	8b 45 10	 mov	 eax, DWORD PTR __S2$1$[ebp]
  00085	85 c0		 test	 eax, eax
  00087	74 e0		 je	 SHORT $LN39@InsertAt

; 81   :         _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_DestinationSize >= _SourceSize, ERANGE);
; 82   : 
; 83   :         memmove(_Destination, _Source, _SourceSize);

  00089	51		 push	 ecx
  0008a	50		 push	 eax
  0008b	52		 push	 edx
  0008c	e8 00 00 00 00	 call	 _memmove
  00091	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN38@InsertAt:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlchecked.h

; 87   : 	ATLMFC_CRT_ERRORCHECK(::memmove_s(_S1, _S1max, _S2, _N));

  00094	33 c0		 xor	 eax, eax
$LN17@InsertAt:
  00096	50		 push	 eax
  00097	e8 00 00 00 00	 call	 ?AfxCrtErrorCheck@@YAHH@Z ; AfxCrtErrorCheck
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 574  : 		memset((void*)(m_pData + nIndex), 0, (size_t)nCount * sizeof(TYPE));

  0009c	8d 04 b5 00 00
	00 00		 lea	 eax, DWORD PTR [esi*4]
  000a3	50		 push	 eax
  000a4	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  000a7	03 c7		 add	 eax, edi
  000a9	6a 00		 push	 0
  000ab	50		 push	 eax
  000ac	e8 00 00 00 00	 call	 _memset
  000b1	83 c4 10	 add	 esp, 16			; 00000010H
$LN7@InsertAt:
  000b4	8b 4d 0c	 mov	 ecx, DWORD PTR _newElement$[ebp]
  000b7	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL8@InsertAt:

; 575  : 		for( int i = 0; i < nCount; i++ )
; 576  : #pragma push_macro("new")
; 577  : #undef new
; 578  : 			::new( (void*)( m_pData + nIndex + i ) ) TYPE;
; 579  : #pragma pop_macro("new")
; 580  : 	}
; 581  : 
; 582  : 	// insert new value in the gap
; 583  : 	ASSERT(nIndex + nCount <= m_nSize);
; 584  : 	while (nCount--)
; 585  : 		m_pData[nIndex++] = newElement;

  000c0	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  000c3	8d 7f 04	 lea	 edi, DWORD PTR [edi+4]
  000c6	89 4c 07 fc	 mov	 DWORD PTR [edi+eax-4], ecx
  000ca	83 ee 01	 sub	 esi, 1
  000cd	75 f1		 jne	 SHORT $LL8@InsertAt

; 549  : 	ASSERT_VALID(this);
; 550  : 	ASSERT(nIndex >= 0);    // will expand to meet need
; 551  : 	ASSERT(nCount > 0);     // zero or negative size not allowed
; 552  : 
; 553  : 	if(nIndex < 0 || nCount <= 0)

  000cf	5f		 pop	 edi
  000d0	5e		 pop	 esi
  000d1	5b		 pop	 ebx

; 586  : }

  000d2	5d		 pop	 ebp
  000d3	c2 0c 00	 ret	 12			; 0000000cH
$LN11@InsertAt:

; 554  : 		AfxThrowInvalidArgException();

  000d6	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN37@InsertAt:
  000db	cc		 int	 3
?InsertAt@?$CArray@HH@@QAEXHHH@Z ENDP			; CArray<int,int>::InsertAt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ?SetAtGrow@?$CArray@HH@@QAEXHH@Z
_TEXT	SEGMENT
_nIndex$ = 8						; size = 4
_newElement$ = 12					; size = 4
?SetAtGrow@?$CArray@HH@@QAEXHH@Z PROC			; CArray<int,int>::SetAtGrow, COMDAT
; _this$ = ecx

; 534  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 535  : 	ASSERT_VALID(this);
; 536  : 	ASSERT(nIndex >= 0);
; 537  : 
; 538  : 	if(nIndex < 0)

  00004	8b 75 08	 mov	 esi, DWORD PTR _nIndex$[ebp]
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
  0000a	85 f6		 test	 esi, esi
  0000c	78 1f		 js	 SHORT $LN7@SetAtGrow

; 540  : 
; 541  : 	if (nIndex >= m_nSize)

  0000e	3b 77 08	 cmp	 esi, DWORD PTR [edi+8]
  00011	7c 0b		 jl	 SHORT $LN3@SetAtGrow

; 542  : 		SetSize(nIndex+1, -1);

  00013	6a ff		 push	 -1
  00015	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ?SetSize@?$CArray@HH@@QAEXHH@Z ; CArray<int,int>::SetSize
$LN3@SetAtGrow:

; 543  : 	m_pData[nIndex] = newElement;

  0001e	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00021	8b 45 0c	 mov	 eax, DWORD PTR _newElement$[ebp]
  00024	5f		 pop	 edi
  00025	89 04 b1	 mov	 DWORD PTR [ecx+esi*4], eax
  00028	5e		 pop	 esi

; 544  : }

  00029	5d		 pop	 ebp
  0002a	c2 08 00	 ret	 8
$LN7@SetAtGrow:

; 539  : 		AfxThrowInvalidArgException();

  0002d	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN5@SetAtGrow:
  00032	cc		 int	 3
?SetAtGrow@?$CArray@HH@@QAEXHH@Z ENDP			; CArray<int,int>::SetAtGrow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ?GetAt@?$CArray@HH@@QAEAAHH@Z
_TEXT	SEGMENT
_nIndex$ = 8						; size = 4
?GetAt@?$CArray@HH@@QAEAAHH@Z PROC			; CArray<int,int>::GetAt, COMDAT
; _this$ = ecx

; 286  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 287  : 	ASSERT(nIndex >= 0 && nIndex < m_nSize);
; 288  : 	if(nIndex >= 0 && nIndex < m_nSize)

  00003	8b 55 08	 mov	 edx, DWORD PTR _nIndex$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	78 0f		 js	 SHORT $LN2@GetAt
  0000a	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  0000d	7d 0a		 jge	 SHORT $LN2@GetAt

; 289  : 		return m_pData[nIndex];

  0000f	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00012	8d 04 90	 lea	 eax, DWORD PTR [eax+edx*4]

; 291  : }

  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
$LN2@GetAt:

; 290  : 	AfxThrowInvalidArgException();

  00019	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN4@GetAt:
  0001e	cc		 int	 3
?GetAt@?$CArray@HH@@QAEAAHH@Z ENDP			; CArray<int,int>::GetAt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_memcpy_s.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlchecked.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_memcpy_s.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlchecked.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_memcpy_s.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ?SetSize@?$CArray@HH@@QAEXHH@Z
_TEXT	SEGMENT
__N$1$ = -4						; size = 4
__S2$1$ = 8						; size = 4
_nNewSize$ = 8						; size = 4
_pNewData$1$ = 12					; size = 4
_nGrowBy$ = 12						; size = 4
?SetSize@?$CArray@HH@@QAEXHH@Z PROC			; CArray<int,int>::SetSize, COMDAT
; _this$ = ecx

; 368  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi

; 369  : 	ASSERT_VALID(this);
; 370  : 	ASSERT(nNewSize >= 0);
; 371  : 
; 372  : 	if(nNewSize < 0 )

  00006	8b 75 08	 mov	 esi, DWORD PTR _nNewSize$[ebp]
  00009	8b d9		 mov	 ebx, ecx
  0000b	57		 push	 edi
  0000c	85 f6		 test	 esi, esi
  0000e	0f 88 c2 01 00
	00		 js	 $LN70@SetSize

; 373  : 		AfxThrowInvalidArgException();
; 374  : 
; 375  : 	if (nGrowBy >= 0)

  00014	8b 45 0c	 mov	 eax, DWORD PTR _nGrowBy$[ebp]
  00017	85 c0		 test	 eax, eax
  00019	78 03		 js	 SHORT $LN69@SetSize

; 376  : 		m_nGrowBy = nGrowBy;  // set new size

  0001b	89 43 10	 mov	 DWORD PTR [ebx+16], eax
$LN69@SetSize:

; 377  : 
; 378  : 	if (nNewSize == 0)

  0001e	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00021	85 f6		 test	 esi, esi
  00023	75 27		 jne	 SHORT $LN19@SetSize

; 379  : 	{
; 380  : 		// shrink to nothing
; 381  : 		if (m_pData != NULL)

  00025	85 c9		 test	 ecx, ecx
  00027	74 0c		 je	 SHORT $LN21@SetSize

; 382  : 		{
; 383  : 			for( int i = 0; i < m_nSize; i++ )
; 384  : 				(m_pData + i)->~TYPE();
; 385  : 			delete[] (BYTE*)m_pData;

  00029	51		 push	 ecx
  0002a	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0002f	83 c4 04	 add	 esp, 4

; 386  : 			m_pData = NULL;

  00032	89 73 04	 mov	 DWORD PTR [ebx+4], esi
$LN21@SetSize:

; 472  : 		m_nSize = nNewSize;
; 473  : 		m_nMaxSize = nNewMax;
; 474  : 	}
; 475  : }

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	c7 43 0c 00 00
	00 00		 mov	 DWORD PTR [ebx+12], 0
  0003e	c7 43 08 00 00
	00 00		 mov	 DWORD PTR [ebx+8], 0
  00045	5b		 pop	 ebx
  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c2 08 00	 ret	 8
$LN19@SetSize:

; 387  : 		}
; 388  : 		m_nSize = m_nMaxSize = 0;
; 389  : 	}
; 390  : 	else if (m_pData == NULL)

  0004c	85 c9		 test	 ecx, ecx
  0004e	75 36		 jne	 SHORT $LN22@SetSize

; 391  : 	{
; 392  : 		// create buffer big enough to hold number of requested elements or
; 393  : 		// m_nGrowBy elements, whichever is larger.
; 394  : #ifdef SIZE_T_MAX
; 395  : 		ASSERT(nNewSize <= SIZE_T_MAX/sizeof(TYPE));    // no overflow
; 396  : #endif
; 397  : 		size_t nAllocSize = __max(nNewSize, m_nGrowBy);

  00050	8b 7b 10	 mov	 edi, DWORD PTR [ebx+16]
  00053	3b f7		 cmp	 esi, edi
  00055	0f 4f fe	 cmovg	 edi, esi

; 398  : 		m_pData = (TYPE*) new BYTE[(size_t)nAllocSize * sizeof(TYPE)];

  00058	8d 34 bd 00 00
	00 00		 lea	 esi, DWORD PTR [edi*4]
  0005f	56		 push	 esi
  00060	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]

; 399  : 		memset((void*)m_pData, 0, (size_t)nAllocSize * sizeof(TYPE));

  00065	56		 push	 esi
  00066	6a 00		 push	 0
  00068	50		 push	 eax
  00069	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  0006c	e8 00 00 00 00	 call	 _memset

; 400  : 		for( int i = 0; i < nNewSize; i++ )
; 401  : #pragma push_macro("new")
; 402  : #undef new
; 403  : 			::new( (void*)( m_pData + i ) ) TYPE;
; 404  : #pragma pop_macro("new")
; 405  : 		m_nSize = nNewSize;

  00071	8b 45 08	 mov	 eax, DWORD PTR _nNewSize$[ebp]
  00074	83 c4 10	 add	 esp, 16			; 00000010H

; 472  : 		m_nSize = nNewSize;
; 473  : 		m_nMaxSize = nNewMax;
; 474  : 	}
; 475  : }

  00077	89 7b 0c	 mov	 DWORD PTR [ebx+12], edi
  0007a	89 43 08	 mov	 DWORD PTR [ebx+8], eax
  0007d	5f		 pop	 edi
  0007e	5e		 pop	 esi
  0007f	5b		 pop	 ebx
  00080	8b e5		 mov	 esp, ebp
  00082	5d		 pop	 ebp
  00083	c2 08 00	 ret	 8
$LN22@SetSize:

; 406  : 		m_nMaxSize = nAllocSize;
; 407  : 	}
; 408  : 	else if (nNewSize <= m_nMaxSize)

  00086	8b 7b 0c	 mov	 edi, DWORD PTR [ebx+12]
  00089	3b f7		 cmp	 esi, edi
  0008b	7f 29		 jg	 SHORT $LN24@SetSize

; 409  : 	{
; 410  : 		// it fits
; 411  : 		if (nNewSize > m_nSize)

  0008d	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]
  00090	3b f2		 cmp	 esi, edx
  00092	7e 16		 jle	 SHORT $LN26@SetSize

; 412  : 		{
; 413  : 			// initialize the new elements
; 414  : 			memset((void*)(m_pData + m_nSize), 0, (size_t)(nNewSize-m_nSize) * sizeof(TYPE));

  00094	8b c6		 mov	 eax, esi
  00096	2b c2		 sub	 eax, edx
  00098	c1 e0 02	 shl	 eax, 2
  0009b	50		 push	 eax
  0009c	8d 04 91	 lea	 eax, DWORD PTR [ecx+edx*4]
  0009f	6a 00		 push	 0
  000a1	50		 push	 eax
  000a2	e8 00 00 00 00	 call	 _memset
  000a7	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN26@SetSize:

; 415  : 			for( int i = 0; i < nNewSize-m_nSize; i++ )
; 416  : #pragma push_macro("new")
; 417  : #undef new
; 418  : 				::new( (void*)( m_pData + m_nSize + i ) ) TYPE;
; 419  : #pragma pop_macro("new")
; 420  : 		}
; 421  : 		else if (m_nSize > nNewSize)
; 422  : 		{
; 423  : 			// destroy the old elements
; 424  : 			for( int i = 0; i < m_nSize-nNewSize; i++ )
; 425  : 				(m_pData + nNewSize + i)->~TYPE();
; 426  : 		}
; 427  : 		m_nSize = nNewSize;

  000aa	5f		 pop	 edi
  000ab	89 73 08	 mov	 DWORD PTR [ebx+8], esi

; 472  : 		m_nSize = nNewSize;
; 473  : 		m_nMaxSize = nNewMax;
; 474  : 	}
; 475  : }

  000ae	5e		 pop	 esi
  000af	5b		 pop	 ebx
  000b0	8b e5		 mov	 esp, ebp
  000b2	5d		 pop	 ebp
  000b3	c2 08 00	 ret	 8
$LN24@SetSize:

; 428  : 	}
; 429  : 	else
; 430  : 	{
; 431  : 		// otherwise, grow array
; 432  : 		nGrowBy = m_nGrowBy;

  000b6	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]

; 433  : 		if (nGrowBy == 0)

  000b9	85 c0		 test	 eax, eax
  000bb	75 22		 jne	 SHORT $LN37@SetSize

; 434  : 		{
; 435  : 			// heuristically determine growth when nGrowBy == 0
; 436  : 			//  (this avoids heap fragmentation in many situations)
; 437  : 			nGrowBy = m_nSize / 8;

  000bd	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  000c0	99		 cdq
  000c1	83 e2 07	 and	 edx, 7
  000c4	03 c2		 add	 eax, edx
  000c6	c1 f8 03	 sar	 eax, 3

; 438  : 			nGrowBy = (nGrowBy < 4) ? 4 : ((nGrowBy > 1024) ? 1024 : nGrowBy);

  000c9	83 f8 04	 cmp	 eax, 4
  000cc	7d 07		 jge	 SHORT $LN36@SetSize
  000ce	b8 04 00 00 00	 mov	 eax, 4
  000d3	eb 0a		 jmp	 SHORT $LN37@SetSize
$LN36@SetSize:
  000d5	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  000da	3b c1		 cmp	 eax, ecx
  000dc	0f 4f c1	 cmovg	 eax, ecx
$LN37@SetSize:

; 439  : 		}
; 440  : 		INT_PTR nNewMax;
; 441  : 		if (nNewSize < m_nMaxSize + nGrowBy)

  000df	03 f8		 add	 edi, eax
  000e1	3b f7		 cmp	 esi, edi
  000e3	7d 0b		 jge	 SHORT $LN30@SetSize

; 445  : 
; 446  : 		ASSERT(nNewMax >= m_nMaxSize);  // no wrap around
; 447  : 
; 448  : 		if(nNewMax  < m_nMaxSize)

  000e5	3b 7b 0c	 cmp	 edi, DWORD PTR [ebx+12]
  000e8	0f 8c e8 00 00
	00		 jl	 $LN70@SetSize
  000ee	eb 02		 jmp	 SHORT $LN32@SetSize
$LN30@SetSize:

; 442  : 			nNewMax = m_nMaxSize + nGrowBy;  // granularity
; 443  : 		else
; 444  : 			nNewMax = nNewSize;  // no slush

  000f0	8b fe		 mov	 edi, esi
$LN32@SetSize:

; 450  : 
; 451  : #ifdef SIZE_T_MAX
; 452  : 		ASSERT(nNewMax <= SIZE_T_MAX/sizeof(TYPE)); // no overflow
; 453  : #endif
; 454  : 		TYPE* pNewData = (TYPE*) new BYTE[(size_t)nNewMax * sizeof(TYPE)];

  000f2	8d 04 bd 00 00
	00 00		 lea	 eax, DWORD PTR [edi*4]
  000f9	50		 push	 eax
  000fa	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]

; 455  : 
; 456  : 		// copy new data from old
; 457  : 		::ATL::Checked::memcpy_s(pNewData, (size_t)nNewMax * sizeof(TYPE),

  000ff	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  00102	8b c8		 mov	 ecx, eax
  00104	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  00107	83 c4 04	 add	 esp, 4
  0010a	c1 e0 02	 shl	 eax, 2
  0010d	89 4d 0c	 mov	 DWORD PTR _pNewData$1$[ebp], ecx
  00110	89 45 fc	 mov	 DWORD PTR __N$1$[ebp], eax
  00113	89 55 08	 mov	 DWORD PTR __S2$1$[ebp], edx
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_memcpy_s.h

; 46   :         if (_SourceSize == 0)

  00116	85 c0		 test	 eax, eax
  00118	74 76		 je	 SHORT $LN74@SetSize

; 47   :         {
; 48   :             return 0;
; 49   :         }
; 50   : 
; 51   :         _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Destination != NULL, EINVAL);

  0011a	85 c9		 test	 ecx, ecx
  0011c	75 56		 jne	 SHORT $LN42@SetSize
$LN73@SetSize:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlchecked.h

; 69   : 	ATLMFC_CRT_ERRORCHECK(::memcpy_s(_S1, _S1max, _S2, _N));

  0011e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___errno
  00124	c7 00 16 00 00
	00		 mov	 DWORD PTR [eax], 22	; 00000016H
  0012a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo
$LN46@SetSize:
  00130	b8 16 00 00 00	 mov	 eax, 22			; 00000016H
$LN40@SetSize:
  00135	50		 push	 eax
  00136	e8 00 00 00 00	 call	 ?AfxCrtErrorCheck@@YAHH@Z ; AfxCrtErrorCheck
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 462  : 		memset((void*)(pNewData + m_nSize), 0, (size_t)(nNewSize-m_nSize) * sizeof(TYPE));

  0013b	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  0013e	8b c6		 mov	 eax, esi
  00140	2b c1		 sub	 eax, ecx
  00142	c1 e0 02	 shl	 eax, 2
  00145	50		 push	 eax
  00146	8b 45 0c	 mov	 eax, DWORD PTR _pNewData$1$[ebp]
  00149	6a 00		 push	 0
  0014b	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  0014e	50		 push	 eax
  0014f	e8 00 00 00 00	 call	 _memset

; 463  : 		for( int i = 0; i < nNewSize-m_nSize; i++ )
; 464  : #pragma push_macro("new")
; 465  : #undef new
; 466  : 			::new( (void*)( pNewData + m_nSize + i ) ) TYPE;
; 467  : #pragma pop_macro("new")
; 468  : 
; 469  : 		// get rid of old stuff (note: no destructors called)
; 470  : 		delete[] (BYTE*)m_pData;

  00154	ff 73 04	 push	 DWORD PTR [ebx+4]
  00157	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]

; 471  : 		m_pData = pNewData;

  0015c	8b 45 0c	 mov	 eax, DWORD PTR _pNewData$1$[ebp]
  0015f	83 c4 14	 add	 esp, 20			; 00000014H

; 472  : 		m_nSize = nNewSize;
; 473  : 		m_nMaxSize = nNewMax;
; 474  : 	}
; 475  : }

  00162	89 7b 0c	 mov	 DWORD PTR [ebx+12], edi
  00165	89 73 08	 mov	 DWORD PTR [ebx+8], esi
  00168	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  0016b	5f		 pop	 edi
  0016c	5e		 pop	 esi
  0016d	5b		 pop	 ebx
  0016e	8b e5		 mov	 esp, ebp
  00170	5d		 pop	 ebp
  00171	c2 08 00	 ret	 8
$LN42@SetSize:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_memcpy_s.h

; 52   :         if (_Source == NULL || _DestinationSize < _SourceSize)

  00174	85 d2		 test	 edx, edx
  00176	8d 14 bd 00 00
	00 00		 lea	 edx, DWORD PTR [edi*4]
  0017d	74 15		 je	 SHORT $LN44@SetSize
  0017f	3b d0		 cmp	 edx, eax
  00181	72 11		 jb	 SHORT $LN44@SetSize

; 58   : 
; 59   :             // Unreachable, but required to suppress /analyze warnings:
; 60   :             return EINVAL;
; 61   :         }
; 62   :         memcpy(_Destination, _Source, _SourceSize);

  00183	50		 push	 eax
  00184	ff 75 08	 push	 DWORD PTR __S2$1$[ebp]
  00187	51		 push	 ecx
  00188	e8 00 00 00 00	 call	 _memcpy
  0018d	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN74@SetSize:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlchecked.h

; 69   : 	ATLMFC_CRT_ERRORCHECK(::memcpy_s(_S1, _S1max, _S2, _N));

  00190	33 c0		 xor	 eax, eax
  00192	eb a1		 jmp	 SHORT $LN40@SetSize
$LN44@SetSize:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_memcpy_s.h

; 54   :             memset(_Destination, 0, _DestinationSize);

  00194	52		 push	 edx
  00195	6a 00		 push	 0
  00197	51		 push	 ecx
  00198	e8 00 00 00 00	 call	 _memset
  0019d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 55   : 
; 56   :             _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Source != NULL,                 EINVAL);

  001a0	83 7d 08 00	 cmp	 DWORD PTR __S2$1$[ebp], 0
  001a4	0f 84 74 ff ff
	ff		 je	 $LN73@SetSize

; 57   :             _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_DestinationSize >= _SourceSize, ERANGE);

  001aa	8d 04 bd 00 00
	00 00		 lea	 eax, DWORD PTR [edi*4]
  001b1	3b 45 fc	 cmp	 eax, DWORD PTR __N$1$[ebp]
  001b4	0f 83 76 ff ff
	ff		 jae	 $LN46@SetSize
  001ba	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___errno
  001c0	c7 00 22 00 00
	00		 mov	 DWORD PTR [eax], 34	; 00000022H
  001c6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo
  001cc	b8 22 00 00 00	 mov	 eax, 34			; 00000022H
  001d1	e9 5f ff ff ff	 jmp	 $LN40@SetSize
$LN70@SetSize:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 449  : 			AfxThrowInvalidArgException();

  001d6	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN72@SetSize:
  001db	cc		 int	 3
?SetSize@?$CArray@HH@@QAEXHH@Z ENDP			; CArray<int,int>::SetSize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ??0?$CArray@HH@@QAE@XZ
_TEXT	SEGMENT
??0?$CArray@HH@@QAE@XZ PROC				; CArray<int,int>::CArray<int,int>, COMDAT
; _this$ = ecx

; 348  : {

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CArray@HH@@6B@

; 349  : 	m_pData = NULL;
; 350  : 	m_nSize = m_nMaxSize = m_nGrowBy = 0;
; 351  : }

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  00016	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0
  0001d	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00024	c3		 ret	 0
??0?$CArray@HH@@QAE@XZ ENDP				; CArray<int,int>::CArray<int,int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
;	COMDAT ??_GCComboBox@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCComboBox@@UAEPAXI@Z PROC				; CComboBox::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CComboBox@@UAE@XZ	; CComboBox::~CComboBox
  0000b	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  0000e	a8 01		 test	 al, 1
  00010	74 22		 je	 SHORT $LN9@scalar
  00012	a8 04		 test	 al, 4
  00014	75 10		 jne	 SHORT $LN3@scalar

; 112  : 	{ ::operator delete(p); }

  00016	56		 push	 esi
  00017	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001c	83 c4 04	 add	 esp, 4
  0001f	8b c6		 mov	 eax, esi
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
$LN3@scalar:
  00026	68 80 00 00 00	 push	 128			; 00000080H
  0002b	56		 push	 esi
  0002c	e8 00 00 00 00	 call	 ?__global_delete@@YAXPAXI@Z ; __global_delete
  00031	83 c4 08	 add	 esp, 8
$LN9@scalar:
  00034	8b c6		 mov	 eax, esi
  00036	5e		 pop	 esi
  00037	5d		 pop	 ebp
  00038	c2 04 00	 ret	 4
??_GCComboBox@@UAEPAXI@Z ENDP				; CComboBox::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
;	COMDAT ??_GCListBox@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCListBox@@UAEPAXI@Z PROC				; CListBox::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CListBox@@UAE@XZ	; CListBox::~CListBox
  0000b	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  0000e	a8 01		 test	 al, 1
  00010	74 22		 je	 SHORT $LN9@scalar
  00012	a8 04		 test	 al, 4
  00014	75 10		 jne	 SHORT $LN3@scalar

; 112  : 	{ ::operator delete(p); }

  00016	56		 push	 esi
  00017	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001c	83 c4 04	 add	 esp, 4
  0001f	8b c6		 mov	 eax, esi
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
$LN3@scalar:
  00026	68 80 00 00 00	 push	 128			; 00000080H
  0002b	56		 push	 esi
  0002c	e8 00 00 00 00	 call	 ?__global_delete@@YAXPAXI@Z ; __global_delete
  00031	83 c4 08	 add	 esp, 8
$LN9@scalar:
  00034	8b c6		 mov	 eax, esi
  00036	5e		 pop	 esi
  00037	5d		 pop	 ebp
  00038	c2 04 00	 ret	 4
??_GCListBox@@UAEPAXI@Z ENDP				; CListBox::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
;	COMDAT ?Create@CDialog@@UAEHIPAVCWnd@@@Z
_TEXT	SEGMENT
_nIDTemplate$ = 8					; size = 4
_pParentWnd$ = 12					; size = 4
?Create@CDialog@@UAEHIPAVCWnd@@@Z PROC			; CDialog::Create, COMDAT
; _this$ = ecx

; 585  : 	{ return CDialog::Create(ATL_MAKEINTRESOURCE(nIDTemplate), pParentWnd); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	0f b7 45 08	 movzx	 eax, WORD PTR _nIDTemplate$[ebp]
  00007	89 45 08	 mov	 DWORD PTR _nIDTemplate$[ebp], eax
  0000a	5d		 pop	 ebp
  0000b	e9 00 00 00 00	 jmp	 ?Create@CDialog@@UAEHPBDPAVCWnd@@@Z ; CDialog::Create
?Create@CDialog@@UAEHIPAVCWnd@@@Z ENDP			; CDialog::Create
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
;	COMDAT ?EndModalState@CWnd@@UAEXXZ
_TEXT	SEGMENT
?EndModalState@CWnd@@UAEXXZ PROC			; CWnd::EndModalState, COMDAT
; _this$ = ecx

; 567  : 	{ ::EnableWindow(m_hWnd, TRUE); }

  00000	6a 01		 push	 1
  00002	ff 71 20	 push	 DWORD PTR [ecx+32]
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnableWindow@8
  0000b	c3		 ret	 0
?EndModalState@CWnd@@UAEXXZ ENDP			; CWnd::EndModalState
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
;	COMDAT ?BeginModalState@CWnd@@UAEXXZ
_TEXT	SEGMENT
?BeginModalState@CWnd@@UAEXXZ PROC			; CWnd::BeginModalState, COMDAT
; _this$ = ecx

; 565  : 	{ ::EnableWindow(m_hWnd, FALSE); }

  00000	6a 00		 push	 0
  00002	ff 71 20	 push	 DWORD PTR [ecx+32]
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnableWindow@8
  0000b	c3		 ret	 0
?BeginModalState@CWnd@@UAEXXZ ENDP			; CWnd::BeginModalState
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
;	COMDAT ?DoDataExchange@CWnd@@MAEXPAVCDataExchange@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?DoDataExchange@CWnd@@MAEXPAVCDataExchange@@@Z PROC	; CWnd::DoDataExchange, COMDAT
; _this$ = ecx

; 561  : 	{ } // default does nothing

  00000	c2 04 00	 ret	 4
?DoDataExchange@CWnd@@MAEXPAVCDataExchange@@@Z ENDP	; CWnd::DoDataExchange
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
;	COMDAT ?Dump@CObject@@UBEXAAVCDumpContext@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?Dump@CObject@@UBEXAAVCDumpContext@@@Z PROC		; CObject::Dump, COMDAT
; _this$ = ecx

; 122  : 	{ /* no dumping in release builds */ }

  00000	c2 04 00	 ret	 4
?Dump@CObject@@UBEXAAVCDumpContext@@@Z ENDP		; CObject::Dump
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
;	COMDAT ?AssertValid@CObject@@UBEXXZ
_TEXT	SEGMENT
?AssertValid@CObject@@UBEXXZ PROC			; CObject::AssertValid, COMDAT
; _this$ = ecx

; 120  : 	{ /* no asserts in release builds */ }

  00000	c2 00 00	 ret	 0
?AssertValid@CObject@@UBEXXZ ENDP			; CObject::AssertValid
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
;	COMDAT ?Serialize@CObject@@UAEXAAVCArchive@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?Serialize@CObject@@UAEXAAVCArchive@@@Z PROC		; CObject::Serialize, COMDAT
; _this$ = ecx

; 106  : 	{ /* CObject does not serialize anything by default */ }

  00000	c2 04 00	 ret	 4
?Serialize@CObject@@UAEXAAVCArchive@@@Z ENDP		; CObject::Serialize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
;	COMDAT ??1CObject@@UAE@XZ
_TEXT	SEGMENT
??1CObject@@UAE@XZ PROC					; CObject::~CObject, COMDAT
; _this$ = ecx

; 104  : 	{ }

  00000	c2 00 00	 ret	 0
??1CObject@@UAE@XZ ENDP					; CObject::~CObject
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.h
;	COMDAT ?AfxCrtErrorCheck@@YAHH@Z
_TEXT	SEGMENT
_error$ = 8						; size = 4
?AfxCrtErrorCheck@@YAHH@Z PROC				; AfxCrtErrorCheck, COMDAT

; 503  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 504  : 	switch(error)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _error$[ebp]
  00006	83 f9 50	 cmp	 ecx, 80			; 00000050H
  00009	77 17		 ja	 SHORT $LN9@AfxCrtErro
  0000b	0f b6 81 00 00
	00 00		 movzx	 eax, BYTE PTR $LN11@AfxCrtErro[ecx]
  00012	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN12@AfxCrtErro[eax*4]
$LN4@AfxCrtErro:

; 505  : 	{
; 506  : 	case ENOMEM:
; 507  : 		AfxThrowMemoryException();

  00019	e9 00 00 00 00	 jmp	 ?AfxThrowMemoryException@@YGXXZ ; AfxThrowMemoryException
$LN7@AfxCrtErro:

; 518  : 		break;
; 519  : 	}
; 520  : 	return error;

  0001e	8b c1		 mov	 eax, ecx

; 521  : }

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
$LN9@AfxCrtErro:

; 508  : 		break;
; 509  : 	case EINVAL:
; 510  : 	case ERANGE:
; 511  : 		AfxThrowInvalidArgException();
; 512  : 		break;
; 513  : 	case STRUNCATE:
; 514  : 	case 0:
; 515  : 		break;
; 516  : 	default:
; 517  : 		AfxThrowInvalidArgException();

  00022	e9 00 00 00 00	 jmp	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
  00027	90		 npad	 1
$LN12@AfxCrtErro:

; 521  : }

  00028	00 00 00 00	 DD	 $LN7@AfxCrtErro
  0002c	00 00 00 00	 DD	 $LN4@AfxCrtErro
  00030	00 00 00 00	 DD	 $LN9@AfxCrtErro
  00034	00 00 00 00	 DD	 $LN9@AfxCrtErro
$LN11@AfxCrtErro:
  00038	00		 DB	 0
  00039	03		 DB	 3
  0003a	03		 DB	 3
  0003b	03		 DB	 3
  0003c	03		 DB	 3
  0003d	03		 DB	 3
  0003e	03		 DB	 3
  0003f	03		 DB	 3
  00040	03		 DB	 3
  00041	03		 DB	 3
  00042	03		 DB	 3
  00043	03		 DB	 3
  00044	01		 DB	 1
  00045	03		 DB	 3
  00046	03		 DB	 3
  00047	03		 DB	 3
  00048	03		 DB	 3
  00049	03		 DB	 3
  0004a	03		 DB	 3
  0004b	03		 DB	 3
  0004c	03		 DB	 3
  0004d	03		 DB	 3
  0004e	02		 DB	 2
  0004f	03		 DB	 3
  00050	03		 DB	 3
  00051	03		 DB	 3
  00052	03		 DB	 3
  00053	03		 DB	 3
  00054	03		 DB	 3
  00055	03		 DB	 3
  00056	03		 DB	 3
  00057	03		 DB	 3
  00058	03		 DB	 3
  00059	03		 DB	 3
  0005a	02		 DB	 2
  0005b	03		 DB	 3
  0005c	03		 DB	 3
  0005d	03		 DB	 3
  0005e	03		 DB	 3
  0005f	03		 DB	 3
  00060	03		 DB	 3
  00061	03		 DB	 3
  00062	03		 DB	 3
  00063	03		 DB	 3
  00064	03		 DB	 3
  00065	03		 DB	 3
  00066	03		 DB	 3
  00067	03		 DB	 3
  00068	03		 DB	 3
  00069	03		 DB	 3
  0006a	03		 DB	 3
  0006b	03		 DB	 3
  0006c	03		 DB	 3
  0006d	03		 DB	 3
  0006e	03		 DB	 3
  0006f	03		 DB	 3
  00070	03		 DB	 3
  00071	03		 DB	 3
  00072	03		 DB	 3
  00073	03		 DB	 3
  00074	03		 DB	 3
  00075	03		 DB	 3
  00076	03		 DB	 3
  00077	03		 DB	 3
  00078	03		 DB	 3
  00079	03		 DB	 3
  0007a	03		 DB	 3
  0007b	03		 DB	 3
  0007c	03		 DB	 3
  0007d	03		 DB	 3
  0007e	03		 DB	 3
  0007f	03		 DB	 3
  00080	03		 DB	 3
  00081	03		 DB	 3
  00082	03		 DB	 3
  00083	03		 DB	 3
  00084	03		 DB	 3
  00085	03		 DB	 3
  00086	03		 DB	 3
  00087	03		 DB	 3
  00088	00		 DB	 0
?AfxCrtErrorCheck@@YAHH@Z ENDP				; AfxCrtErrorCheck
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _sscanf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sscanf	PROC						; COMDAT

; 2247 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2153 :         return __stdio_common_vsscanf(

  00003	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00006	50		 push	 eax
  00007	6a 00		 push	 0
  00009	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000c	6a ff		 push	 -1
  0000e	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00011	e8 00 00 00 00	 call	 ___local_stdio_scanf_options
  00016	ff 70 04	 push	 DWORD PTR [eax+4]
  00019	ff 30		 push	 DWORD PTR [eax]
  0001b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vsscanf
  00021	83 c4 1c	 add	 esp, 28			; 0000001cH

; 2248 :         int _Result;
; 2249 :         va_list _ArgList;
; 2250 :         __crt_va_start(_ArgList, _Format);
; 2251 :         _Result = _vsscanf_l(_Buffer, _Format, NULL, _ArgList);
; 2252 :         __crt_va_end(_ArgList);
; 2253 :         return _Result;
; 2254 :     }

  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
_sscanf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1771 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1392 :         int const _Result = __stdio_common_vsprintf(

  00003	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00006	50		 push	 eax
  00007	6a 00		 push	 0
  00009	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000c	6a ff		 push	 -1
  0000e	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00011	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00016	8b 08		 mov	 ecx, DWORD PTR [eax]
  00018	ff 70 04	 push	 DWORD PTR [eax+4]
  0001b	83 c9 01	 or	 ecx, 1
  0001e	51		 push	 ecx
  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vsprintf

; 1393 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1394 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1395 : 
; 1396 :         return _Result < 0 ? -1 : _Result;

  00025	83 c9 ff	 or	 ecx, -1
  00028	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002b	85 c0		 test	 eax, eax
  0002d	0f 48 c1	 cmovs	 eax, ecx

; 1772 :         int _Result;
; 1773 :         va_list _ArgList;
; 1774 :         __crt_va_start(_ArgList, _Format);
; 1775 : 
; 1776 :         _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);
; 1777 : 
; 1778 :         __crt_va_end(_ArgList);
; 1779 :         return _Result;
; 1780 :     }

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_scanf_options
_TEXT	SEGMENT
___local_stdio_scanf_options PROC			; COMDAT

; 101  :         static unsigned __int64 _OptionsStorage;
; 102  :         return &_OptionsStorage;

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_scanf_options@@9@4_KA ; `__local_stdio_scanf_options'::`2'::_OptionsStorage

; 103  :     }

  00005	c3		 ret	 0
___local_stdio_scanf_options ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00005	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	c2 00 00	 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\DlgSettingToolBar.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

  00000	c2 00 00	 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
