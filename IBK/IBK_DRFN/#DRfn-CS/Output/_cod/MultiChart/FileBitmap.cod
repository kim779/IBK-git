; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30145.0 

	TITLE	D:\git\src\IBK\IBK_DRFN\#DRfn-CS\_Obj\MultiChart\FileBitmap.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	??1CObject@@UAE@XZ				; CObject::~CObject
PUBLIC	?Serialize@CObject@@UAEXAAVCArchive@@@Z		; CObject::Serialize
PUBLIC	?AssertValid@CObject@@UBEXXZ			; CObject::AssertValid
PUBLIC	?Dump@CObject@@UBEXAAVCDumpContext@@@Z		; CObject::Dump
PUBLIC	??1CGdiObject@@UAE@XZ				; CGdiObject::~CGdiObject
PUBLIC	??_GCGdiObject@@UAEPAXI@Z			; CGdiObject::`scalar deleting destructor'
PUBLIC	??1CBitmap@@UAE@XZ				; CBitmap::~CBitmap
PUBLIC	??_GCBitmap@@UAEPAXI@Z				; CBitmap::`scalar deleting destructor'
PUBLIC	??0CFileBitmap@@QAE@XZ				; CFileBitmap::CFileBitmap
PUBLIC	??1CFileBitmap@@UAE@XZ				; CFileBitmap::~CFileBitmap
PUBLIC	?ClearAll@CFileBitmap@@QAEXXZ			; CFileBitmap::ClearAll
PUBLIC	?LoadBMP@CFileBitmap@@QAEHPBD@Z			; CFileBitmap::LoadBMP
PUBLIC	?LoadBMP@CFileBitmap@@QAEHPBDPAPAX@Z		; CFileBitmap::LoadBMP
PUBLIC	?LoadBMPImage@CFileBitmap@@QAEHPBDAAVCBitmap@@@Z ; CFileBitmap::LoadBMPImage
PUBLIC	?LoadBMPImage@CFileBitmap@@QAEHPBD@Z		; CFileBitmap::LoadBMPImage
PUBLIC	??_GCFileBitmap@@UAEPAXI@Z			; CFileBitmap::`scalar deleting destructor'
PUBLIC	??_R0PAVCException@@@8				; CException * `RTTI Type Descriptor'
PUBLIC	??_7CGdiObject@@6B@				; CGdiObject::`vftable'
PUBLIC	??_7CBitmap@@6B@				; CBitmap::`vftable'
PUBLIC	??_C@_0HD@JJCHHHNK@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ ; `string'
PUBLIC	??_C@_0BP@OIEOKIDM@Exception?5thrown?5in?5destructor@ ; `string'
PUBLIC	??_C@_0BB@HBOOMJBF@?$CFTs?5?$CI?$CFTs?3?$CFd?$CJ?6?$CFTs@ ; `string'
PUBLIC	??_C@_0N@OMEMOKLE@?$CFTs?5?$CI?$CFTs?3?$CFd?$CJ@ ; `string'
PUBLIC	??_R0?AVCObject@@@8				; CObject `RTTI Type Descriptor'
PUBLIC	??_R3CObject@@8					; CObject::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CObject@@8					; CObject::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CObject@@8			; CObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4CGdiObject@@6B@				; CGdiObject::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCGdiObject@@@8				; CGdiObject `RTTI Type Descriptor'
PUBLIC	??_R3CGdiObject@@8				; CGdiObject::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CGdiObject@@8				; CGdiObject::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CGdiObject@@8			; CGdiObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4CBitmap@@6B@				; CBitmap::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCBitmap@@@8				; CBitmap `RTTI Type Descriptor'
PUBLIC	??_R3CBitmap@@8					; CBitmap::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CBitmap@@8					; CBitmap::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CBitmap@@8			; CBitmap::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_7CFileBitmap@@6B@				; CFileBitmap::`vftable'
PUBLIC	??_R4CFileBitmap@@6B@				; CFileBitmap::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCFileBitmap@@@8				; CFileBitmap `RTTI Type Descriptor'
PUBLIC	??_R3CFileBitmap@@8				; CFileBitmap::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CFileBitmap@@8				; CFileBitmap::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CFileBitmap@@8			; CFileBitmap::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	?__global_delete@@YAXPAXI@Z:PROC		; __global_delete
EXTRN	__imp__GlobalAlloc@8:PROC
EXTRN	__imp__GlobalFree@4:PROC
EXTRN	__imp__CreateDIBitmap@24:PROC
EXTRN	__imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ:PROC
EXTRN	__imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ:PROC
EXTRN	__imp_?Format@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAAXPBDZZ:PROC
EXTRN	??0CFile@@QAE@XZ:PROC				; CFile::CFile
EXTRN	?Open@CFile@@UAEHPBDIPAVCFileException@@@Z:PROC	; CFile::Open
EXTRN	?GetLength@CFile@@UBE_KXZ:PROC			; CFile::GetLength
EXTRN	?Read@CFile@@UAEIPAXI@Z:PROC			; CFile::Read
EXTRN	??1CFile@@UAE@XZ:PROC				; CFile::~CFile
EXTRN	?GetRuntimeClass@CGdiObject@@UBEPAUCRuntimeClass@@XZ:PROC ; CGdiObject::GetRuntimeClass
EXTRN	?Attach@CGdiObject@@QAEHPAX@Z:PROC		; CGdiObject::Attach
EXTRN	?DeleteObject@CGdiObject@@QAEHXZ:PROC		; CGdiObject::DeleteObject
EXTRN	??_ECGdiObject@@UAEPAXI@Z:PROC			; CGdiObject::`vector deleting destructor'
EXTRN	?GetRuntimeClass@CBitmap@@UBEPAUCRuntimeClass@@XZ:PROC ; CBitmap::GetRuntimeClass
EXTRN	??_ECBitmap@@UAEPAXI@Z:PROC			; CBitmap::`vector deleting destructor'
EXTRN	??0CClientDC@@QAE@PAVCWnd@@@Z:PROC		; CClientDC::CClientDC
EXTRN	??1CClientDC@@UAE@XZ:PROC			; CClientDC::~CClientDC
EXTRN	?AfxMessageBox@@YGHPBDII@Z:PROC			; AfxMessageBox
EXTRN	??_ECFileBitmap@@UAEPAXI@Z:PROC			; CFileBitmap::`vector deleting destructor'
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___security_cookie:DWORD
;	COMDAT ??_R1A@?0A@EA@CFileBitmap@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CFileBitmap@@8 DD FLAT:??_R0?AVCFileBitmap@@@8 ; CFileBitmap::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CFileBitmap@@8
rdata$r	ENDS
;	COMDAT ??_R2CFileBitmap@@8
rdata$r	SEGMENT
??_R2CFileBitmap@@8 DD FLAT:??_R1A@?0A@EA@CFileBitmap@@8 ; CFileBitmap::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CBitmap@@8
	DD	FLAT:??_R1A@?0A@EA@CGdiObject@@8
	DD	FLAT:??_R1A@?0A@EA@CObject@@8
rdata$r	ENDS
;	COMDAT ??_R3CFileBitmap@@8
rdata$r	SEGMENT
??_R3CFileBitmap@@8 DD 00H				; CFileBitmap::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2CFileBitmap@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCFileBitmap@@@8
data$rs	SEGMENT
??_R0?AVCFileBitmap@@@8 DD FLAT:??_7type_info@@6B@	; CFileBitmap `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCFileBitmap@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CFileBitmap@@6B@
rdata$r	SEGMENT
??_R4CFileBitmap@@6B@ DD 00H				; CFileBitmap::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCFileBitmap@@@8
	DD	FLAT:??_R3CFileBitmap@@8
rdata$r	ENDS
;	COMDAT ??_7CFileBitmap@@6B@
CONST	SEGMENT
??_7CFileBitmap@@6B@ DD FLAT:??_R4CFileBitmap@@6B@	; CFileBitmap::`vftable'
	DD	FLAT:?GetRuntimeClass@CBitmap@@UBEPAUCRuntimeClass@@XZ
	DD	FLAT:??_ECFileBitmap@@UAEPAXI@Z
	DD	FLAT:?Serialize@CObject@@UAEXAAVCArchive@@@Z
	DD	FLAT:?AssertValid@CObject@@UBEXXZ
	DD	FLAT:?Dump@CObject@@UBEXAAVCDumpContext@@@Z
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@CBitmap@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CBitmap@@8 DD FLAT:??_R0?AVCBitmap@@@8	; CBitmap::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CBitmap@@8
rdata$r	ENDS
;	COMDAT ??_R2CBitmap@@8
rdata$r	SEGMENT
??_R2CBitmap@@8 DD FLAT:??_R1A@?0A@EA@CBitmap@@8	; CBitmap::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CGdiObject@@8
	DD	FLAT:??_R1A@?0A@EA@CObject@@8
rdata$r	ENDS
;	COMDAT ??_R3CBitmap@@8
rdata$r	SEGMENT
??_R3CBitmap@@8 DD 00H					; CBitmap::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2CBitmap@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCBitmap@@@8
data$rs	SEGMENT
??_R0?AVCBitmap@@@8 DD FLAT:??_7type_info@@6B@		; CBitmap `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCBitmap@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CBitmap@@6B@
rdata$r	SEGMENT
??_R4CBitmap@@6B@ DD 00H				; CBitmap::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCBitmap@@@8
	DD	FLAT:??_R3CBitmap@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CGdiObject@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CGdiObject@@8 DD FLAT:??_R0?AVCGdiObject@@@8 ; CGdiObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CGdiObject@@8
rdata$r	ENDS
;	COMDAT ??_R2CGdiObject@@8
rdata$r	SEGMENT
??_R2CGdiObject@@8 DD FLAT:??_R1A@?0A@EA@CGdiObject@@8	; CGdiObject::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CObject@@8
rdata$r	ENDS
;	COMDAT ??_R3CGdiObject@@8
rdata$r	SEGMENT
??_R3CGdiObject@@8 DD 00H				; CGdiObject::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CGdiObject@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCGdiObject@@@8
data$rs	SEGMENT
??_R0?AVCGdiObject@@@8 DD FLAT:??_7type_info@@6B@	; CGdiObject `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCGdiObject@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CGdiObject@@6B@
rdata$r	SEGMENT
??_R4CGdiObject@@6B@ DD 00H				; CGdiObject::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCGdiObject@@@8
	DD	FLAT:??_R3CGdiObject@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CObject@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CObject@@8 DD FLAT:??_R0?AVCObject@@@8	; CObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CObject@@8
rdata$r	ENDS
;	COMDAT ??_R2CObject@@8
rdata$r	SEGMENT
??_R2CObject@@8 DD FLAT:??_R1A@?0A@EA@CObject@@8	; CObject::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CObject@@8
rdata$r	SEGMENT
??_R3CObject@@8 DD 00H					; CObject::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CObject@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCObject@@@8
data$rs	SEGMENT
??_R0?AVCObject@@@8 DD FLAT:??_7type_info@@6B@		; CObject `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCObject@@', 00H
data$rs	ENDS
;	COMDAT ??_C@_0N@OMEMOKLE@?$CFTs?5?$CI?$CFTs?3?$CFd?$CJ@
CONST	SEGMENT
??_C@_0N@OMEMOKLE@?$CFTs?5?$CI?$CFTs?3?$CFd?$CJ@ DB '%Ts (%Ts:%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@HBOOMJBF@?$CFTs?5?$CI?$CFTs?3?$CFd?$CJ?6?$CFTs@
CONST	SEGMENT
??_C@_0BB@HBOOMJBF@?$CFTs?5?$CI?$CFTs?3?$CFd?$CJ?6?$CFTs@ DB '%Ts (%Ts:%d'
	DB	')', 0aH, '%Ts', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@OIEOKIDM@Exception?5thrown?5in?5destructor@
CONST	SEGMENT
??_C@_0BP@OIEOKIDM@Exception?5thrown?5in?5destructor@ DB 'Exception throw'
	DB	'n in destructor', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0HD@JJCHHHNK@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
CONST	SEGMENT
??_C@_0HD@JJCHHHNK@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ DB 'C:\Pro'
	DB	'gram Files (x86)\Microsoft Visual Studio\2019\Community\VC\To'
	DB	'ols\MSVC\14.29.30133\atlmfc\include\afxwin1.inl', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7CBitmap@@6B@
CONST	SEGMENT
??_7CBitmap@@6B@ DD FLAT:??_R4CBitmap@@6B@		; CBitmap::`vftable'
	DD	FLAT:?GetRuntimeClass@CBitmap@@UBEPAUCRuntimeClass@@XZ
	DD	FLAT:??_ECBitmap@@UAEPAXI@Z
	DD	FLAT:?Serialize@CObject@@UAEXAAVCArchive@@@Z
	DD	FLAT:?AssertValid@CObject@@UBEXXZ
	DD	FLAT:?Dump@CObject@@UBEXAAVCDumpContext@@@Z
CONST	ENDS
;	COMDAT ??_7CGdiObject@@6B@
CONST	SEGMENT
??_7CGdiObject@@6B@ DD FLAT:??_R4CGdiObject@@6B@	; CGdiObject::`vftable'
	DD	FLAT:?GetRuntimeClass@CGdiObject@@UBEPAUCRuntimeClass@@XZ
	DD	FLAT:??_ECGdiObject@@UAEPAXI@Z
	DD	FLAT:?Serialize@CObject@@UAEXAAVCArchive@@@Z
	DD	FLAT:?AssertValid@CObject@@UBEXXZ
	DD	FLAT:?Dump@CObject@@UBEXAAVCDumpContext@@@Z
CONST	ENDS
;	COMDAT ??_R0PAVCException@@@8
data$r	SEGMENT
??_R0PAVCException@@@8 DD FLAT:??_7type_info@@6B@	; CException * `RTTI Type Descriptor'
	DD	00H
	DB	'.PAVCException@@', 00H
data$r	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?LoadBMPImage@CFileBitmap@@QAEHPBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LoadBMPImage@CFileBitmap@@QAEHPBD@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadBMPImage@CFileBitmap@@QAEHPBD@Z$1
__ehfuncinfo$?LoadBMPImage@CFileBitmap@@QAEHPBD@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?LoadBMPImage@CFileBitmap@@QAEHPBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?LoadBMPImage@CFileBitmap@@QAEHPBDAAVCBitmap@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LoadBMPImage@CFileBitmap@@QAEHPBDAAVCBitmap@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadBMPImage@CFileBitmap@@QAEHPBDAAVCBitmap@@@Z$1
__ehfuncinfo$?LoadBMPImage@CFileBitmap@@QAEHPBDAAVCBitmap@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?LoadBMPImage@CFileBitmap@@QAEHPBDAAVCBitmap@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?LoadBMP@CFileBitmap@@QAEHPBDPAPAX@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LoadBMP@CFileBitmap@@QAEHPBDPAPAX@Z$0
__ehfuncinfo$?LoadBMP@CFileBitmap@@QAEHPBDPAPAX@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?LoadBMP@CFileBitmap@@QAEHPBDPAPAX@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?LoadBMP@CFileBitmap@@QAEHPBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LoadBMP@CFileBitmap@@QAEHPBD@Z$0
__ehfuncinfo$?LoadBMP@CFileBitmap@@QAEHPBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?LoadBMP@CFileBitmap@@QAEHPBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??1CGdiObject@@UAE@XZ$3 DD 00H
	DD	FLAT:??_R0PAVCException@@@8
	DD	0fffffde4H
	DD	FLAT:__catch$??1CGdiObject@@UAE@XZ$0
__tryblocktable$??1CGdiObject@@UAE@XZ DD 00H
	DD	00H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??1CGdiObject@@UAE@XZ$3
__unwindtable$??1CGdiObject@@UAE@XZ DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	FLAT:__unwindfunclet$??1CGdiObject@@UAE@XZ$2
__ehfuncinfo$??1CGdiObject@@UAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??1CGdiObject@@UAE@XZ
	DD	01H
	DD	FLAT:__tryblocktable$??1CGdiObject@@UAE@XZ
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\analtool\FileBitmap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin1.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
;	COMDAT ??_GCFileBitmap@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCFileBitmap@@UAEPAXI@Z PROC				; CFileBitmap::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\analtool\FileBitmap.cpp

; 22   : {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 28   : 	if(m_hDIB) {

  00006	8b 46 08	 mov	 eax, DWORD PTR [esi+8]

; 22   : {

  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CFileBitmap@@6B@

; 28   : 	if(m_hDIB) {

  0000f	85 c0		 test	 eax, eax
  00011	74 0e		 je	 SHORT $LN11@scalar

; 29   : 		::GlobalFree(m_hDIB);

  00013	50		 push	 eax
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalFree@4

; 30   : 		m_hDIB = NULL;

  0001a	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN11@scalar:

; 24   : }

  00021	8d 4e 14	 lea	 ecx, DWORD PTR [esi+20]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin1.inl

; 179  : 	{ }

  00024	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CBitmap@@6B@
  0002a	e8 00 00 00 00	 call	 ??1CGdiObject@@UAE@XZ	; CGdiObject::~CGdiObject
  0002f	8b ce		 mov	 ecx, esi
  00031	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CBitmap@@6B@
  00037	e8 00 00 00 00	 call	 ??1CGdiObject@@UAE@XZ	; CGdiObject::~CGdiObject
  0003c	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  0003f	a8 01		 test	 al, 1
  00041	74 1f		 je	 SHORT $LN21@scalar
  00043	a8 04		 test	 al, 4
  00045	75 10		 jne	 SHORT $LN3@scalar
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 112  : 	{ ::operator delete(p); }

  00047	56		 push	 esi
  00048	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0004d	83 c4 04	 add	 esp, 4
  00050	8b c6		 mov	 eax, esi
  00052	5e		 pop	 esi
  00053	5d		 pop	 ebp
  00054	c2 04 00	 ret	 4
$LN3@scalar:
  00057	6a 1c		 push	 28			; 0000001cH
  00059	56		 push	 esi
  0005a	e8 00 00 00 00	 call	 ?__global_delete@@YAXPAXI@Z ; __global_delete
  0005f	83 c4 08	 add	 esp, 8
$LN21@scalar:
  00062	8b c6		 mov	 eax, esi
  00064	5e		 pop	 esi
  00065	5d		 pop	 ebp
  00066	c2 04 00	 ret	 4
??_GCFileBitmap@@UAEPAXI@Z ENDP				; CFileBitmap::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\analtool\FileBitmap.cpp
;	COMDAT ?LoadBMPImage@CFileBitmap@@QAEHPBD@Z
_TEXT	SEGMENT
_dc$2 = -72						; size = 20
_file$3 = -52						; size = 20
_bmfHeader$4 = -32					; size = 14
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_sBMPFile$ = 8						; size = 4
?LoadBMPImage@CFileBitmap@@QAEHPBD@Z PROC		; CFileBitmap::LoadBMPImage, COMDAT
; _this$ = ecx

; 122  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?LoadBMPImage@CFileBitmap@@QAEHPBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b d9		 mov	 ebx, ecx
  0002d	8b 75 08	 mov	 esi, DWORD PTR _sBMPFile$[ebp]

; 134  : 	CFile file;

  00030	8d 4d cc	 lea	 ecx, DWORD PTR _file$3[ebp]
  00033	e8 00 00 00 00	 call	 ??0CFile@@QAE@XZ	; CFile::CFile

; 135  : 	if( !file.Open( sBMPFile, CFile::modeRead) )

  00038	6a 00		 push	 0
  0003a	6a 00		 push	 0
  0003c	56		 push	 esi
  0003d	8d 4d cc	 lea	 ecx, DWORD PTR _file$3[ebp]
  00040	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00047	e8 00 00 00 00	 call	 ?Open@CFile@@UAEHPBDIPAVCFileException@@@Z ; CFile::Open
  0004c	85 c0		 test	 eax, eax
  0004e	74 54		 je	 SHORT $LN17@LoadBMPIma

; 136  : 		return FALSE;
; 137  : 
; 138  : 	BITMAPFILEHEADER bmfHeader;
; 139  : 
; 140  : 	// Read file header
; 141  : 	if (file.Read((LPSTR)&bmfHeader, sizeof(bmfHeader)) != sizeof(bmfHeader))

  00050	6a 0e		 push	 14			; 0000000eH
  00052	8d 45 e0	 lea	 eax, DWORD PTR _bmfHeader$4[ebp]
  00055	50		 push	 eax
  00056	8d 4d cc	 lea	 ecx, DWORD PTR _file$3[ebp]
  00059	e8 00 00 00 00	 call	 ?Read@CFile@@UAEIPAXI@Z	; CFile::Read
  0005e	83 f8 0e	 cmp	 eax, 14			; 0000000eH
  00061	75 41		 jne	 SHORT $LN17@LoadBMPIma

; 142  : 		return FALSE;
; 143  : 
; 144  : 	// File type should be 'BM'
; 145  : 	if (bmfHeader.bfType != ((WORD) ('M' << 8) | 'B'))

  00063	b8 42 4d 00 00	 mov	 eax, 19778		; 00004d42H
  00068	66 39 45 e0	 cmp	 WORD PTR _bmfHeader$4[ebp], ax
  0006c	75 36		 jne	 SHORT $LN17@LoadBMPIma

; 146  : 		return FALSE;
; 147  : 
; 148  : 	// Get length of the remainder of the file and allocate memory
; 149  : 	DWORD nPackedDIBLen = file.GetLength() - sizeof(BITMAPFILEHEADER);

  0006e	8d 4d cc	 lea	 ecx, DWORD PTR _file$3[ebp]
  00071	e8 00 00 00 00	 call	 ?GetLength@CFile@@UBE_KXZ ; CFile::GetLength
  00076	8d 78 f2	 lea	 edi, DWORD PTR [eax-14]

; 150  : 	HGLOBAL hDIB = ::GlobalAlloc(GMEM_FIXED, nPackedDIBLen);

  00079	57		 push	 edi
  0007a	6a 00		 push	 0
  0007c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalAlloc@8
  00082	8b f0		 mov	 esi, eax

; 151  : 	if (hDIB == 0)

  00084	85 f6		 test	 esi, esi
  00086	74 1c		 je	 SHORT $LN17@LoadBMPIma

; 152  : 		return FALSE;
; 153  : 
; 154  : 	// Read the remainder of the bitmap file.
; 155  : 	if (file.Read((LPSTR)hDIB, nPackedDIBLen) != nPackedDIBLen )

  00088	57		 push	 edi
  00089	56		 push	 esi
  0008a	8d 4d cc	 lea	 ecx, DWORD PTR _file$3[ebp]
  0008d	e8 00 00 00 00	 call	 ?Read@CFile@@UAEIPAXI@Z	; CFile::Read
  00092	3b c7		 cmp	 eax, edi
  00094	74 15		 je	 SHORT $LN8@LoadBMPIma

; 156  : 	{
; 157  : 		::GlobalFree(hDIB);

  00096	56		 push	 esi
  00097	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalFree@4

; 158  : 		m_hDIB = NULL;

  0009d	c7 43 08 00 00
	00 00		 mov	 DWORD PTR [ebx+8], 0
$LN17@LoadBMPIma:

; 123  : 	return LoadBMPImage(sBMPFile, m_bitmap/*, &m_pPal*/);

  000a4	33 f6		 xor	 esi, esi
  000a6	e9 81 00 00 00	 jmp	 $LN3@LoadBMPIma
$LN8@LoadBMPIma:

; 165  : 	m_nWidth = bmInfo.bmiHeader.biWidth;

  000ab	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000ae	89 43 0c	 mov	 DWORD PTR [ebx+12], eax

; 166  : 	m_nHeight = bmInfo.bmiHeader.biHeight;

  000b1	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000b4	89 43 10	 mov	 DWORD PTR [ebx+16], eax

; 167  : 
; 168  : 	// If bmiHeader.biClrUsed is zero we have to infer the number
; 169  : 	// of colors from the number of bits used to specify it.
; 170  : 	int nColors = bmiHeader.biClrUsed ? bmiHeader.biClrUsed : 

  000b7	8b 56 20	 mov	 edx, DWORD PTR [esi+32]
  000ba	0f b7 46 0e	 movzx	 eax, WORD PTR [esi+14]
  000be	85 d2		 test	 edx, edx
  000c0	74 04		 je	 SHORT $LN12@LoadBMPIma
  000c2	8b fa		 mov	 edi, edx
  000c4	eb 09		 jmp	 SHORT $LN13@LoadBMPIma
$LN12@LoadBMPIma:
  000c6	bf 01 00 00 00	 mov	 edi, 1
  000cb	8a c8		 mov	 cl, al
  000cd	d3 e7		 shl	 edi, cl
$LN13@LoadBMPIma:

; 171  : 						1 << bmiHeader.biBitCount;
; 172  : 
; 173  : 	LPVOID lpDIBBits;
; 174  : 	if( bmInfo.bmiHeader.biBitCount > 8 )

  000cf	66 83 f8 08	 cmp	 ax, 8
  000d3	76 0f		 jbe	 SHORT $LN10@LoadBMPIma

; 175  : 		lpDIBBits = (LPVOID)((LPDWORD)(bmInfo.bmiColors + bmInfo.bmiHeader.biClrUsed) + 

  000d5	33 ff		 xor	 edi, edi
  000d7	b8 03 00 00 00	 mov	 eax, 3
  000dc	39 46 10	 cmp	 DWORD PTR [esi+16], eax
  000df	0f 44 f8	 cmove	 edi, eax
  000e2	03 fa		 add	 edi, edx
$LN10@LoadBMPIma:

; 176  : 			((bmInfo.bmiHeader.biCompression == BI_BITFIELDS) ? 3 : 0));
; 177  : 	else
; 178  : 		lpDIBBits = (LPVOID)(bmInfo.bmiColors + nColors);
; 179  : 
; 180  : 	// Create the logical palette
; 181  : /*
; 182  : 	if( pPal != NULL )
; 183  : 	{
; 184  : 		// Create the palette
; 185  : 		if( nColors <= 256 )
; 186  : 		{
; 187  : 			UINT nSize = sizeof(LOGPALETTE) + (sizeof(PALETTEENTRY) * nColors);
; 188  : 			LOGPALETTE *pLP = (LOGPALETTE *) new BYTE[nSize];
; 189  : 
; 190  : 			pLP->palVersion = 0x300;
; 191  : 			pLP->palNumEntries = nColors;
; 192  : 
; 193  : 			for( int i=0; i < nColors; i++)
; 194  : 			{
; 195  : 				pLP->palPalEntry[i].peRed = bmInfo.bmiColors[i].rgbRed;
; 196  : 				pLP->palPalEntry[i].peGreen = bmInfo.bmiColors[i].rgbGreen;
; 197  : 				pLP->palPalEntry[i].peBlue = bmInfo.bmiColors[i].rgbBlue;
; 198  : 				pLP->palPalEntry[i].peFlags = 0;
; 199  : 			}
; 200  : 
; 201  : 			pPal->CreatePalette( pLP );
; 202  : 
; 203  : 			delete[] pLP;
; 204  : 		}
; 205  : 	}
; 206  : */
; 207  : 
; 208  : 	CClientDC dc(NULL);

  000e4	6a 00		 push	 0
  000e6	8d 4d b8	 lea	 ecx, DWORD PTR _dc$2[ebp]
  000e9	e8 00 00 00 00	 call	 ??0CClientDC@@QAE@PAVCWnd@@@Z ; CClientDC::CClientDC

; 209  : //	CPalette* pOldPalette = NULL;
; 210  : //	if( pPal )
; 211  : //	{
; 212  : //		pOldPalette = dc.SelectPalette( pPal, FALSE );
; 213  : //		dc.RealizePalette();
; 214  : //	}
; 215  : 
; 216  : 	HBITMAP hBmp = CreateDIBitmap( dc.m_hDC,		// handle to device context 

  000ee	6a 00		 push	 0
  000f0	56		 push	 esi
  000f1	8d 46 28	 lea	 eax, DWORD PTR [esi+40]
  000f4	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  000f8	8d 04 b8	 lea	 eax, DWORD PTR [eax+edi*4]
  000fb	50		 push	 eax
  000fc	6a 04		 push	 4
  000fe	56		 push	 esi
  000ff	ff 75 bc	 push	 DWORD PTR _dc$2[ebp+4]
  00102	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateDIBitmap@24

; 217  : 				&bmiHeader,	// pointer to bitmap size and format data 
; 218  : 				CBM_INIT,	// initialization flag 
; 219  : 				lpDIBBits,	// pointer to initialization data 
; 220  : 				&bmInfo,	// pointer to bitmap color-format data 
; 221  : 				DIB_RGB_COLORS);		// color-data usage 
; 222  : 	bitmap.Attach( hBmp );

  00108	50		 push	 eax

; 123  : 	return LoadBMPImage(sBMPFile, m_bitmap/*, &m_pPal*/);

  00109	8d 4b 14	 lea	 ecx, DWORD PTR [ebx+20]

; 222  : 	bitmap.Attach( hBmp );

  0010c	e8 00 00 00 00	 call	 ?Attach@CGdiObject@@QAEHPAX@Z ; CGdiObject::Attach

; 223  : 
; 224  : /*
; 225  : 	if( pOldPalette )
; 226  : 		dc.SelectPalette( pOldPalette, FALSE );
; 227  : */
; 228  : 
; 229  : 	::GlobalFree(hDIB);

  00111	56		 push	 esi
  00112	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalFree@4

; 230  : 	m_hDIB = NULL;
; 231  : 	return TRUE;

  00118	8d 4d b8	 lea	 ecx, DWORD PTR _dc$2[ebp]
  0011b	c7 43 08 00 00
	00 00		 mov	 DWORD PTR [ebx+8], 0
  00122	e8 00 00 00 00	 call	 ??1CClientDC@@UAE@XZ	; CClientDC::~CClientDC
  00127	be 01 00 00 00	 mov	 esi, 1
$LN3@LoadBMPIma:

; 123  : 	return LoadBMPImage(sBMPFile, m_bitmap/*, &m_pPal*/);

  0012c	8d 4d cc	 lea	 ecx, DWORD PTR _file$3[ebp]
  0012f	e8 00 00 00 00	 call	 ??1CFile@@UAE@XZ	; CFile::~CFile
  00134	8b c6		 mov	 eax, esi

; 124  : }

  00136	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00139	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00140	59		 pop	 ecx
  00141	5f		 pop	 edi
  00142	5e		 pop	 esi
  00143	5b		 pop	 ebx
  00144	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00147	33 cd		 xor	 ecx, ebp
  00149	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0014e	8b e5		 mov	 esp, ebp
  00150	5d		 pop	 ebp
  00151	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LoadBMPImage@CFileBitmap@@QAEHPBD@Z$0:
  00000	8d 4d cc	 lea	 ecx, DWORD PTR _file$3[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CFile@@UAE@XZ	; CFile::~CFile
__unwindfunclet$?LoadBMPImage@CFileBitmap@@QAEHPBD@Z$1:
  00008	8d 4d b8	 lea	 ecx, DWORD PTR _dc$2[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1CClientDC@@UAE@XZ	; CClientDC::~CClientDC
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$?LoadBMPImage@CFileBitmap@@QAEHPBD@Z:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a b4	 mov	 ecx, DWORD PTR [edx-76]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0002b	33 c8		 xor	 ecx, eax
  0002d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00032	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?LoadBMPImage@CFileBitmap@@QAEHPBD@Z
  00037	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?LoadBMPImage@CFileBitmap@@QAEHPBD@Z ENDP		; CFileBitmap::LoadBMPImage
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\analtool\FileBitmap.cpp
;	COMDAT ?LoadBMPImage@CFileBitmap@@QAEHPBDAAVCBitmap@@@Z
_TEXT	SEGMENT
_dc$ = -76						; size = 20
_file$ = -56						; size = 20
_bitmap$GSCopy$1$ = -36					; size = 4
_bmfHeader$ = -32					; size = 14
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_sBMPFile$ = 8						; size = 4
_bitmap$ = 12						; size = 4
?LoadBMPImage@CFileBitmap@@QAEHPBDAAVCBitmap@@@Z PROC	; CFileBitmap::LoadBMPImage, COMDAT
; _this$ = ecx

; 133  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?LoadBMPImage@CFileBitmap@@QAEHPBDAAVCBitmap@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 40	 sub	 esp, 64			; 00000040H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b d9		 mov	 ebx, ecx
  0002d	8b 45 0c	 mov	 eax, DWORD PTR _bitmap$[ebp]

; 134  : 	CFile file;

  00030	8d 4d c8	 lea	 ecx, DWORD PTR _file$[ebp]
  00033	8b 75 08	 mov	 esi, DWORD PTR _sBMPFile$[ebp]
  00036	89 45 dc	 mov	 DWORD PTR _bitmap$GSCopy$1$[ebp], eax
  00039	e8 00 00 00 00	 call	 ??0CFile@@QAE@XZ	; CFile::CFile

; 135  : 	if( !file.Open( sBMPFile, CFile::modeRead) )

  0003e	6a 00		 push	 0
  00040	6a 00		 push	 0
  00042	56		 push	 esi
  00043	8d 4d c8	 lea	 ecx, DWORD PTR _file$[ebp]
  00046	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0004d	e8 00 00 00 00	 call	 ?Open@CFile@@UAEHPBDIPAVCFileException@@@Z ; CFile::Open
  00052	85 c0		 test	 eax, eax
  00054	74 54		 je	 SHORT $LN17@LoadBMPIma

; 136  : 		return FALSE;
; 137  : 
; 138  : 	BITMAPFILEHEADER bmfHeader;
; 139  : 
; 140  : 	// Read file header
; 141  : 	if (file.Read((LPSTR)&bmfHeader, sizeof(bmfHeader)) != sizeof(bmfHeader))

  00056	6a 0e		 push	 14			; 0000000eH
  00058	8d 45 e0	 lea	 eax, DWORD PTR _bmfHeader$[ebp]
  0005b	50		 push	 eax
  0005c	8d 4d c8	 lea	 ecx, DWORD PTR _file$[ebp]
  0005f	e8 00 00 00 00	 call	 ?Read@CFile@@UAEIPAXI@Z	; CFile::Read
  00064	83 f8 0e	 cmp	 eax, 14			; 0000000eH
  00067	75 41		 jne	 SHORT $LN17@LoadBMPIma

; 142  : 		return FALSE;
; 143  : 
; 144  : 	// File type should be 'BM'
; 145  : 	if (bmfHeader.bfType != ((WORD) ('M' << 8) | 'B'))

  00069	b8 42 4d 00 00	 mov	 eax, 19778		; 00004d42H
  0006e	66 39 45 e0	 cmp	 WORD PTR _bmfHeader$[ebp], ax
  00072	75 36		 jne	 SHORT $LN17@LoadBMPIma

; 146  : 		return FALSE;
; 147  : 
; 148  : 	// Get length of the remainder of the file and allocate memory
; 149  : 	DWORD nPackedDIBLen = file.GetLength() - sizeof(BITMAPFILEHEADER);

  00074	8d 4d c8	 lea	 ecx, DWORD PTR _file$[ebp]
  00077	e8 00 00 00 00	 call	 ?GetLength@CFile@@UBE_KXZ ; CFile::GetLength
  0007c	8d 78 f2	 lea	 edi, DWORD PTR [eax-14]

; 150  : 	HGLOBAL hDIB = ::GlobalAlloc(GMEM_FIXED, nPackedDIBLen);

  0007f	57		 push	 edi
  00080	6a 00		 push	 0
  00082	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalAlloc@8
  00088	8b f0		 mov	 esi, eax

; 151  : 	if (hDIB == 0)

  0008a	85 f6		 test	 esi, esi
  0008c	74 1c		 je	 SHORT $LN17@LoadBMPIma

; 152  : 		return FALSE;
; 153  : 
; 154  : 	// Read the remainder of the bitmap file.
; 155  : 	if (file.Read((LPSTR)hDIB, nPackedDIBLen) != nPackedDIBLen )

  0008e	57		 push	 edi
  0008f	56		 push	 esi
  00090	8d 4d c8	 lea	 ecx, DWORD PTR _file$[ebp]
  00093	e8 00 00 00 00	 call	 ?Read@CFile@@UAEIPAXI@Z	; CFile::Read
  00098	3b c7		 cmp	 eax, edi
  0009a	74 38		 je	 SHORT $LN6@LoadBMPIma

; 156  : 	{
; 157  : 		::GlobalFree(hDIB);

  0009c	56		 push	 esi
  0009d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalFree@4

; 158  : 		m_hDIB = NULL;

  000a3	c7 43 08 00 00
	00 00		 mov	 DWORD PTR [ebx+8], 0
$LN17@LoadBMPIma:
  000aa	33 f6		 xor	 esi, esi
$LN18@LoadBMPIma:

; 230  : 	m_hDIB = NULL;
; 231  : 	return TRUE;

  000ac	8d 4d c8	 lea	 ecx, DWORD PTR _file$[ebp]
  000af	e8 00 00 00 00	 call	 ??1CFile@@UAE@XZ	; CFile::~CFile
  000b4	8b c6		 mov	 eax, esi

; 232  : }

  000b6	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000b9	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000c0	59		 pop	 ecx
  000c1	5f		 pop	 edi
  000c2	5e		 pop	 esi
  000c3	5b		 pop	 ebx
  000c4	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000c7	33 cd		 xor	 ecx, ebp
  000c9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ce	8b e5		 mov	 esp, ebp
  000d0	5d		 pop	 ebp
  000d1	c2 08 00	 ret	 8
$LN6@LoadBMPIma:

; 159  : 		return FALSE;
; 160  : 	}
; 161  : 
; 162  : 
; 163  : 	BITMAPINFOHEADER &bmiHeader = *(LPBITMAPINFOHEADER)hDIB ;
; 164  : 	BITMAPINFO &bmInfo = *(LPBITMAPINFO)hDIB ;
; 165  : 	m_nWidth = bmInfo.bmiHeader.biWidth;

  000d4	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000d7	89 43 0c	 mov	 DWORD PTR [ebx+12], eax

; 166  : 	m_nHeight = bmInfo.bmiHeader.biHeight;

  000da	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000dd	89 43 10	 mov	 DWORD PTR [ebx+16], eax

; 167  : 
; 168  : 	// If bmiHeader.biClrUsed is zero we have to infer the number
; 169  : 	// of colors from the number of bits used to specify it.
; 170  : 	int nColors = bmiHeader.biClrUsed ? bmiHeader.biClrUsed : 

  000e0	8b 56 20	 mov	 edx, DWORD PTR [esi+32]
  000e3	0f b7 46 0e	 movzx	 eax, WORD PTR [esi+14]
  000e7	85 d2		 test	 edx, edx
  000e9	74 04		 je	 SHORT $LN10@LoadBMPIma
  000eb	8b fa		 mov	 edi, edx
  000ed	eb 09		 jmp	 SHORT $LN11@LoadBMPIma
$LN10@LoadBMPIma:
  000ef	bf 01 00 00 00	 mov	 edi, 1
  000f4	8a c8		 mov	 cl, al
  000f6	d3 e7		 shl	 edi, cl
$LN11@LoadBMPIma:

; 171  : 						1 << bmiHeader.biBitCount;
; 172  : 
; 173  : 	LPVOID lpDIBBits;
; 174  : 	if( bmInfo.bmiHeader.biBitCount > 8 )

  000f8	66 83 f8 08	 cmp	 ax, 8
  000fc	76 0f		 jbe	 SHORT $LN8@LoadBMPIma

; 175  : 		lpDIBBits = (LPVOID)((LPDWORD)(bmInfo.bmiColors + bmInfo.bmiHeader.biClrUsed) + 

  000fe	33 ff		 xor	 edi, edi
  00100	b8 03 00 00 00	 mov	 eax, 3
  00105	39 46 10	 cmp	 DWORD PTR [esi+16], eax
  00108	0f 44 f8	 cmove	 edi, eax
  0010b	03 fa		 add	 edi, edx
$LN8@LoadBMPIma:

; 176  : 			((bmInfo.bmiHeader.biCompression == BI_BITFIELDS) ? 3 : 0));
; 177  : 	else
; 178  : 		lpDIBBits = (LPVOID)(bmInfo.bmiColors + nColors);
; 179  : 
; 180  : 	// Create the logical palette
; 181  : /*
; 182  : 	if( pPal != NULL )
; 183  : 	{
; 184  : 		// Create the palette
; 185  : 		if( nColors <= 256 )
; 186  : 		{
; 187  : 			UINT nSize = sizeof(LOGPALETTE) + (sizeof(PALETTEENTRY) * nColors);
; 188  : 			LOGPALETTE *pLP = (LOGPALETTE *) new BYTE[nSize];
; 189  : 
; 190  : 			pLP->palVersion = 0x300;
; 191  : 			pLP->palNumEntries = nColors;
; 192  : 
; 193  : 			for( int i=0; i < nColors; i++)
; 194  : 			{
; 195  : 				pLP->palPalEntry[i].peRed = bmInfo.bmiColors[i].rgbRed;
; 196  : 				pLP->palPalEntry[i].peGreen = bmInfo.bmiColors[i].rgbGreen;
; 197  : 				pLP->palPalEntry[i].peBlue = bmInfo.bmiColors[i].rgbBlue;
; 198  : 				pLP->palPalEntry[i].peFlags = 0;
; 199  : 			}
; 200  : 
; 201  : 			pPal->CreatePalette( pLP );
; 202  : 
; 203  : 			delete[] pLP;
; 204  : 		}
; 205  : 	}
; 206  : */
; 207  : 
; 208  : 	CClientDC dc(NULL);

  0010d	6a 00		 push	 0
  0010f	8d 4d b4	 lea	 ecx, DWORD PTR _dc$[ebp]
  00112	e8 00 00 00 00	 call	 ??0CClientDC@@QAE@PAVCWnd@@@Z ; CClientDC::CClientDC

; 209  : //	CPalette* pOldPalette = NULL;
; 210  : //	if( pPal )
; 211  : //	{
; 212  : //		pOldPalette = dc.SelectPalette( pPal, FALSE );
; 213  : //		dc.RealizePalette();
; 214  : //	}
; 215  : 
; 216  : 	HBITMAP hBmp = CreateDIBitmap( dc.m_hDC,		// handle to device context 

  00117	6a 00		 push	 0
  00119	56		 push	 esi
  0011a	8d 46 28	 lea	 eax, DWORD PTR [esi+40]
  0011d	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00121	8d 04 b8	 lea	 eax, DWORD PTR [eax+edi*4]
  00124	50		 push	 eax
  00125	6a 04		 push	 4
  00127	56		 push	 esi
  00128	ff 75 b8	 push	 DWORD PTR _dc$[ebp+4]
  0012b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateDIBitmap@24

; 217  : 				&bmiHeader,	// pointer to bitmap size and format data 
; 218  : 				CBM_INIT,	// initialization flag 
; 219  : 				lpDIBBits,	// pointer to initialization data 
; 220  : 				&bmInfo,	// pointer to bitmap color-format data 
; 221  : 				DIB_RGB_COLORS);		// color-data usage 
; 222  : 	bitmap.Attach( hBmp );

  00131	8b 4d dc	 mov	 ecx, DWORD PTR _bitmap$GSCopy$1$[ebp]
  00134	50		 push	 eax
  00135	e8 00 00 00 00	 call	 ?Attach@CGdiObject@@QAEHPAX@Z ; CGdiObject::Attach

; 223  : 
; 224  : /*
; 225  : 	if( pOldPalette )
; 226  : 		dc.SelectPalette( pOldPalette, FALSE );
; 227  : */
; 228  : 
; 229  : 	::GlobalFree(hDIB);

  0013a	56		 push	 esi
  0013b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalFree@4

; 230  : 	m_hDIB = NULL;
; 231  : 	return TRUE;

  00141	8d 4d b4	 lea	 ecx, DWORD PTR _dc$[ebp]
  00144	c7 43 08 00 00
	00 00		 mov	 DWORD PTR [ebx+8], 0
  0014b	be 01 00 00 00	 mov	 esi, 1
  00150	e8 00 00 00 00	 call	 ??1CClientDC@@UAE@XZ	; CClientDC::~CClientDC
  00155	e9 52 ff ff ff	 jmp	 $LN18@LoadBMPIma
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LoadBMPImage@CFileBitmap@@QAEHPBDAAVCBitmap@@@Z$0:
  00000	8d 4d c8	 lea	 ecx, DWORD PTR _file$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CFile@@UAE@XZ	; CFile::~CFile
__unwindfunclet$?LoadBMPImage@CFileBitmap@@QAEHPBDAAVCBitmap@@@Z$1:
  00008	8d 4d b4	 lea	 ecx, DWORD PTR _dc$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1CClientDC@@UAE@XZ	; CClientDC::~CClientDC
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$?LoadBMPImage@CFileBitmap@@QAEHPBDAAVCBitmap@@@Z:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a b0	 mov	 ecx, DWORD PTR [edx-80]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0002b	33 c8		 xor	 ecx, eax
  0002d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00032	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?LoadBMPImage@CFileBitmap@@QAEHPBDAAVCBitmap@@@Z
  00037	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?LoadBMPImage@CFileBitmap@@QAEHPBDAAVCBitmap@@@Z ENDP	; CFileBitmap::LoadBMPImage
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\analtool\FileBitmap.cpp
;	COMDAT ?LoadBMP@CFileBitmap@@QAEHPBDPAPAX@Z
_TEXT	SEGMENT
_file$ = -56						; size = 20
_phDIB$GSCopy$1$ = -36					; size = 4
_bmfHeader$ = -32					; size = 14
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_sBMPFile$ = 8						; size = 4
_phDIB$ = 12						; size = 4
?LoadBMP@CFileBitmap@@QAEHPBDPAPAX@Z PROC		; CFileBitmap::LoadBMP, COMDAT
; _this$ = ecx

; 51   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?LoadBMP@CFileBitmap@@QAEHPBDPAPAX@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b d9		 mov	 ebx, ecx
  0002d	8b 75 08	 mov	 esi, DWORD PTR _sBMPFile$[ebp]
  00030	8b 45 0c	 mov	 eax, DWORD PTR _phDIB$[ebp]
  00033	89 45 dc	 mov	 DWORD PTR _phDIB$GSCopy$1$[ebp], eax

; 52   : 	if(!sBMPFile)

  00036	85 f6		 test	 esi, esi
  00038	75 04		 jne	 SHORT $LN2@LoadBMP

; 53   : 		return FALSE;

  0003a	33 c0		 xor	 eax, eax
  0003c	eb 7b		 jmp	 SHORT $LN1@LoadBMP
$LN2@LoadBMP:

; 54   : 
; 55   : 	CFile file;

  0003e	8d 4d c8	 lea	 ecx, DWORD PTR _file$[ebp]
  00041	e8 00 00 00 00	 call	 ??0CFile@@QAE@XZ	; CFile::CFile

; 56   : 	if( !file.Open( sBMPFile, CFile::modeRead) )

  00046	6a 00		 push	 0
  00048	6a 00		 push	 0
  0004a	56		 push	 esi
  0004b	8d 4d c8	 lea	 ecx, DWORD PTR _file$[ebp]
  0004e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00055	e8 00 00 00 00	 call	 ?Open@CFile@@UAEHPBDIPAVCFileException@@@Z ; CFile::Open
  0005a	85 c0		 test	 eax, eax
  0005c	74 4f		 je	 SHORT $LN15@LoadBMP

; 57   : 		return FALSE;
; 58   : 
; 59   : 	BITMAPFILEHEADER bmfHeader;
; 60   : 	long nFileLen;
; 61   : 
; 62   : 	nFileLen = file.GetLength();

  0005e	8d 4d c8	 lea	 ecx, DWORD PTR _file$[ebp]
  00061	e8 00 00 00 00	 call	 ?GetLength@CFile@@UBE_KXZ ; CFile::GetLength
  00066	8b f0		 mov	 esi, eax

; 63   : 
; 64   : 
; 65   : 	// Read file header
; 66   : 	if (file.Read((LPSTR)&bmfHeader, sizeof(bmfHeader)) != sizeof(bmfHeader))

  00068	8d 4d c8	 lea	 ecx, DWORD PTR _file$[ebp]
  0006b	6a 0e		 push	 14			; 0000000eH
  0006d	8d 45 e0	 lea	 eax, DWORD PTR _bmfHeader$[ebp]
  00070	50		 push	 eax
  00071	e8 00 00 00 00	 call	 ?Read@CFile@@UAEIPAXI@Z	; CFile::Read
  00076	83 f8 0e	 cmp	 eax, 14			; 0000000eH
  00079	75 32		 jne	 SHORT $LN15@LoadBMP

; 67   : 		return FALSE;
; 68   : 
; 69   : 	// File type should be 'BM'
; 70   : 	if (bmfHeader.bfType != ((WORD) ('M' << 8) | 'B'))

  0007b	b8 42 4d 00 00	 mov	 eax, 19778		; 00004d42H
  00080	66 39 45 e0	 cmp	 WORD PTR _bmfHeader$[ebp], ax
  00084	75 27		 jne	 SHORT $LN15@LoadBMP

; 71   : 		return FALSE;
; 72   : 
; 73   : 	HGLOBAL hDIB = ::GlobalAlloc(GMEM_FIXED, nFileLen);

  00086	56		 push	 esi
  00087	6a 00		 push	 0
  00089	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalAlloc@8
  0008f	8b f8		 mov	 edi, eax

; 74   : 	if (hDIB == 0)

  00091	85 ff		 test	 edi, edi
  00093	74 18		 je	 SHORT $LN15@LoadBMP

; 75   : 		return FALSE;
; 76   : 
; 77   : 	// Read the remainder of the bitmap file.
; 78   : 	if (file.Read((LPSTR)hDIB, nFileLen - sizeof(BITMAPFILEHEADER)) !=

  00095	83 c6 f2	 add	 esi, -14		; fffffff2H
  00098	8d 4d c8	 lea	 ecx, DWORD PTR _file$[ebp]
  0009b	56		 push	 esi
  0009c	57		 push	 edi
  0009d	e8 00 00 00 00	 call	 ?Read@CFile@@UAEIPAXI@Z	; CFile::Read
  000a2	3b c6		 cmp	 eax, esi
  000a4	74 31		 je	 SHORT $LN7@LoadBMP

; 79   : 		nFileLen - sizeof(BITMAPFILEHEADER) )
; 80   : 	{
; 81   : 		::GlobalFree(hDIB);

  000a6	57		 push	 edi
  000a7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalFree@4
$LN15@LoadBMP:
  000ad	33 f6		 xor	 esi, esi
$LN16@LoadBMP:

; 88   : 	m_nHeight = bmInfo.bmiHeader.biHeight;
; 89   : 
; 90   : 	int nColors = bmInfo.bmiHeader.biClrUsed ? bmInfo.bmiHeader.biClrUsed : 
; 91   : 						1 << bmInfo.bmiHeader.biBitCount;
; 92   : 
; 93   : 	// Create the palette
; 94   : /*
; 95   : 	if( nColors <= 256 )
; 96   : 	{
; 97   : 		UINT nSize = sizeof(LOGPALETTE) + (sizeof(PALETTEENTRY) * nColors);
; 98   : 		LOGPALETTE *pLP = (LOGPALETTE *) new BYTE[nSize];
; 99   : 
; 100  : 		pLP->palVersion = 0x300;
; 101  : 		pLP->palNumEntries = nColors;
; 102  : 
; 103  : 		for( int i=0; i < nColors; i++)
; 104  : 		{
; 105  : 			pLP->palPalEntry[i].peRed = bmInfo.bmiColors[i].rgbRed;
; 106  : 			pLP->palPalEntry[i].peGreen = bmInfo.bmiColors[i].rgbGreen;
; 107  : 			pLP->palPalEntry[i].peBlue = bmInfo.bmiColors[i].rgbBlue;
; 108  : 			pLP->palPalEntry[i].peFlags = 0;
; 109  : 		}
; 110  : 
; 111  : 		pPal->CreatePalette( pLP );
; 112  : 
; 113  : 		delete[] pLP;
; 114  : 	}
; 115  : */
; 116  : 
; 117  : 	*phDIB = hDIB;
; 118  : 	return TRUE;

  000af	8d 4d c8	 lea	 ecx, DWORD PTR _file$[ebp]
  000b2	e8 00 00 00 00	 call	 ??1CFile@@UAE@XZ	; CFile::~CFile
  000b7	8b c6		 mov	 eax, esi
$LN1@LoadBMP:

; 119  : }

  000b9	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000bc	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000c3	59		 pop	 ecx
  000c4	5f		 pop	 edi
  000c5	5e		 pop	 esi
  000c6	5b		 pop	 ebx
  000c7	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ca	33 cd		 xor	 ecx, ebp
  000cc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000d1	8b e5		 mov	 esp, ebp
  000d3	5d		 pop	 ebp
  000d4	c2 08 00	 ret	 8
$LN7@LoadBMP:

; 82   : 		hDIB = NULL;
; 83   : 		return FALSE;
; 84   : 	}
; 85   : 	
; 86   : 	BITMAPINFO &bmInfo = *(LPBITMAPINFO)hDIB ;
; 87   : 	m_nWidth = bmInfo.bmiHeader.biWidth;

  000d7	8b 47 04	 mov	 eax, DWORD PTR [edi+4]

; 88   : 	m_nHeight = bmInfo.bmiHeader.biHeight;
; 89   : 
; 90   : 	int nColors = bmInfo.bmiHeader.biClrUsed ? bmInfo.bmiHeader.biClrUsed : 
; 91   : 						1 << bmInfo.bmiHeader.biBitCount;
; 92   : 
; 93   : 	// Create the palette
; 94   : /*
; 95   : 	if( nColors <= 256 )
; 96   : 	{
; 97   : 		UINT nSize = sizeof(LOGPALETTE) + (sizeof(PALETTEENTRY) * nColors);
; 98   : 		LOGPALETTE *pLP = (LOGPALETTE *) new BYTE[nSize];
; 99   : 
; 100  : 		pLP->palVersion = 0x300;
; 101  : 		pLP->palNumEntries = nColors;
; 102  : 
; 103  : 		for( int i=0; i < nColors; i++)
; 104  : 		{
; 105  : 			pLP->palPalEntry[i].peRed = bmInfo.bmiColors[i].rgbRed;
; 106  : 			pLP->palPalEntry[i].peGreen = bmInfo.bmiColors[i].rgbGreen;
; 107  : 			pLP->palPalEntry[i].peBlue = bmInfo.bmiColors[i].rgbBlue;
; 108  : 			pLP->palPalEntry[i].peFlags = 0;
; 109  : 		}
; 110  : 
; 111  : 		pPal->CreatePalette( pLP );
; 112  : 
; 113  : 		delete[] pLP;
; 114  : 	}
; 115  : */
; 116  : 
; 117  : 	*phDIB = hDIB;
; 118  : 	return TRUE;

  000da	be 01 00 00 00	 mov	 esi, 1
  000df	89 43 0c	 mov	 DWORD PTR [ebx+12], eax
  000e2	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  000e5	89 43 10	 mov	 DWORD PTR [ebx+16], eax
  000e8	8b 45 dc	 mov	 eax, DWORD PTR _phDIB$GSCopy$1$[ebp]
  000eb	89 38		 mov	 DWORD PTR [eax], edi
  000ed	eb c0		 jmp	 SHORT $LN16@LoadBMP
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LoadBMP@CFileBitmap@@QAEHPBDPAPAX@Z$0:
  00000	8d 4d c8	 lea	 ecx, DWORD PTR _file$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CFile@@UAE@XZ	; CFile::~CFile
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?LoadBMP@CFileBitmap@@QAEHPBDPAPAX@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a c4	 mov	 ecx, DWORD PTR [edx-60]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?LoadBMP@CFileBitmap@@QAEHPBDPAPAX@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?LoadBMP@CFileBitmap@@QAEHPBDPAPAX@Z ENDP		; CFileBitmap::LoadBMP
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\analtool\FileBitmap.cpp
;	COMDAT ?LoadBMP@CFileBitmap@@QAEHPBD@Z
_TEXT	SEGMENT
_file$2 = -52						; size = 20
_bmfHeader$3 = -32					; size = 14
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_sBMPFile$ = 8						; size = 4
?LoadBMP@CFileBitmap@@QAEHPBD@Z PROC			; CFileBitmap::LoadBMP, COMDAT
; _this$ = ecx

; 37   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?LoadBMP@CFileBitmap@@QAEHPBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 28	 sub	 esp, 40			; 00000028H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b d9		 mov	 ebx, ecx
  0002d	8b 75 08	 mov	 esi, DWORD PTR _sBMPFile$[ebp]

; 52   : 	if(!sBMPFile)

  00030	85 f6		 test	 esi, esi
  00032	74 77		 je	 SHORT $LN15@LoadBMP

; 53   : 		return FALSE;
; 54   : 
; 55   : 	CFile file;

  00034	8d 4d cc	 lea	 ecx, DWORD PTR _file$2[ebp]
  00037	e8 00 00 00 00	 call	 ??0CFile@@QAE@XZ	; CFile::CFile

; 56   : 	if( !file.Open( sBMPFile, CFile::modeRead) )

  0003c	6a 00		 push	 0
  0003e	6a 00		 push	 0
  00040	56		 push	 esi
  00041	8d 4d cc	 lea	 ecx, DWORD PTR _file$2[ebp]
  00044	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0004b	e8 00 00 00 00	 call	 ?Open@CFile@@UAEHPBDIPAVCFileException@@@Z ; CFile::Open
  00050	8d 4d cc	 lea	 ecx, DWORD PTR _file$2[ebp]
  00053	85 c0		 test	 eax, eax
  00055	74 4f		 je	 SHORT $LN16@LoadBMP

; 57   : 		return FALSE;
; 58   : 
; 59   : 	BITMAPFILEHEADER bmfHeader;
; 60   : 	long nFileLen;
; 61   : 
; 62   : 	nFileLen = file.GetLength();

  00057	e8 00 00 00 00	 call	 ?GetLength@CFile@@UBE_KXZ ; CFile::GetLength
  0005c	8b f0		 mov	 esi, eax

; 63   : 
; 64   : 
; 65   : 	// Read file header
; 66   : 	if (file.Read((LPSTR)&bmfHeader, sizeof(bmfHeader)) != sizeof(bmfHeader))

  0005e	8d 4d cc	 lea	 ecx, DWORD PTR _file$2[ebp]
  00061	6a 0e		 push	 14			; 0000000eH
  00063	8d 45 e0	 lea	 eax, DWORD PTR _bmfHeader$3[ebp]
  00066	50		 push	 eax
  00067	e8 00 00 00 00	 call	 ?Read@CFile@@UAEIPAXI@Z	; CFile::Read
  0006c	83 f8 0e	 cmp	 eax, 14			; 0000000eH
  0006f	75 32		 jne	 SHORT $LN17@LoadBMP

; 67   : 		return FALSE;
; 68   : 
; 69   : 	// File type should be 'BM'
; 70   : 	if (bmfHeader.bfType != ((WORD) ('M' << 8) | 'B'))

  00071	b8 42 4d 00 00	 mov	 eax, 19778		; 00004d42H
  00076	66 39 45 e0	 cmp	 WORD PTR _bmfHeader$3[ebp], ax
  0007a	75 27		 jne	 SHORT $LN17@LoadBMP

; 71   : 		return FALSE;
; 72   : 
; 73   : 	HGLOBAL hDIB = ::GlobalAlloc(GMEM_FIXED, nFileLen);

  0007c	56		 push	 esi
  0007d	6a 00		 push	 0
  0007f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalAlloc@8
  00085	8b f8		 mov	 edi, eax

; 74   : 	if (hDIB == 0)

  00087	8d 4d cc	 lea	 ecx, DWORD PTR _file$2[ebp]
  0008a	85 ff		 test	 edi, edi
  0008c	74 18		 je	 SHORT $LN16@LoadBMP

; 75   : 		return FALSE;
; 76   : 
; 77   : 	// Read the remainder of the bitmap file.
; 78   : 	if (file.Read((LPSTR)hDIB, nFileLen - sizeof(BITMAPFILEHEADER)) !=

  0008e	83 c6 f2	 add	 esi, -14		; fffffff2H
  00091	56		 push	 esi
  00092	57		 push	 edi
  00093	e8 00 00 00 00	 call	 ?Read@CFile@@UAEIPAXI@Z	; CFile::Read
  00098	3b c6		 cmp	 eax, esi
  0009a	74 13		 je	 SHORT $LN9@LoadBMP

; 79   : 		nFileLen - sizeof(BITMAPFILEHEADER) )
; 80   : 	{
; 81   : 		::GlobalFree(hDIB);

  0009c	57		 push	 edi
  0009d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalFree@4
$LN17@LoadBMP:

; 39   : }

  000a3	8d 4d cc	 lea	 ecx, DWORD PTR _file$2[ebp]
$LN16@LoadBMP:
  000a6	e8 00 00 00 00	 call	 ??1CFile@@UAE@XZ	; CFile::~CFile
$LN15@LoadBMP:
  000ab	33 c0		 xor	 eax, eax
  000ad	eb 1c		 jmp	 SHORT $LN3@LoadBMP
$LN9@LoadBMP:

; 87   : 	m_nWidth = bmInfo.bmiHeader.biWidth;

  000af	8b 47 04	 mov	 eax, DWORD PTR [edi+4]

; 88   : 	m_nHeight = bmInfo.bmiHeader.biHeight;
; 89   : 
; 90   : 	int nColors = bmInfo.bmiHeader.biClrUsed ? bmInfo.bmiHeader.biClrUsed : 
; 91   : 						1 << bmInfo.bmiHeader.biBitCount;
; 92   : 
; 93   : 	// Create the palette
; 94   : /*
; 95   : 	if( nColors <= 256 )
; 96   : 	{
; 97   : 		UINT nSize = sizeof(LOGPALETTE) + (sizeof(PALETTEENTRY) * nColors);
; 98   : 		LOGPALETTE *pLP = (LOGPALETTE *) new BYTE[nSize];
; 99   : 
; 100  : 		pLP->palVersion = 0x300;
; 101  : 		pLP->palNumEntries = nColors;
; 102  : 
; 103  : 		for( int i=0; i < nColors; i++)
; 104  : 		{
; 105  : 			pLP->palPalEntry[i].peRed = bmInfo.bmiColors[i].rgbRed;
; 106  : 			pLP->palPalEntry[i].peGreen = bmInfo.bmiColors[i].rgbGreen;
; 107  : 			pLP->palPalEntry[i].peBlue = bmInfo.bmiColors[i].rgbBlue;
; 108  : 			pLP->palPalEntry[i].peFlags = 0;
; 109  : 		}
; 110  : 
; 111  : 		pPal->CreatePalette( pLP );
; 112  : 
; 113  : 		delete[] pLP;
; 114  : 	}
; 115  : */
; 116  : 
; 117  : 	*phDIB = hDIB;
; 118  : 	return TRUE;

  000b2	8d 4d cc	 lea	 ecx, DWORD PTR _file$2[ebp]
  000b5	89 43 0c	 mov	 DWORD PTR [ebx+12], eax
  000b8	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  000bb	89 43 10	 mov	 DWORD PTR [ebx+16], eax
  000be	89 7b 08	 mov	 DWORD PTR [ebx+8], edi
  000c1	e8 00 00 00 00	 call	 ??1CFile@@UAE@XZ	; CFile::~CFile

; 38   : 	return LoadBMP(sBMPFile, &m_hDIB/*, &m_Pal*/);

  000c6	b8 01 00 00 00	 mov	 eax, 1
$LN3@LoadBMP:

; 39   : }

  000cb	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000ce	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000d5	59		 pop	 ecx
  000d6	5f		 pop	 edi
  000d7	5e		 pop	 esi
  000d8	5b		 pop	 ebx
  000d9	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000dc	33 cd		 xor	 ecx, ebp
  000de	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e3	8b e5		 mov	 esp, ebp
  000e5	5d		 pop	 ebp
  000e6	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LoadBMP@CFileBitmap@@QAEHPBD@Z$0:
  00000	8d 4d cc	 lea	 ecx, DWORD PTR _file$2[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CFile@@UAE@XZ	; CFile::~CFile
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?LoadBMP@CFileBitmap@@QAEHPBD@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a c8	 mov	 ecx, DWORD PTR [edx-56]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?LoadBMP@CFileBitmap@@QAEHPBD@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?LoadBMP@CFileBitmap@@QAEHPBD@Z ENDP			; CFileBitmap::LoadBMP
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\analtool\FileBitmap.cpp
;	COMDAT ?ClearAll@CFileBitmap@@QAEXXZ
_TEXT	SEGMENT
?ClearAll@CFileBitmap@@QAEXXZ PROC			; CFileBitmap::ClearAll, COMDAT
; _this$ = ecx

; 27   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 28   : 	if(m_hDIB) {

  00003	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00006	85 c0		 test	 eax, eax
  00008	74 0e		 je	 SHORT $LN2@ClearAll

; 29   : 		::GlobalFree(m_hDIB);

  0000a	50		 push	 eax
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalFree@4

; 30   : 		m_hDIB = NULL;

  00011	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN2@ClearAll:

; 31   : 	}
; 32   : //	m_Pal.DeleteObject();
; 33   : //	m_pPal.DeleteObject();
; 34   : }

  00018	5e		 pop	 esi
  00019	c3		 ret	 0
?ClearAll@CFileBitmap@@QAEXXZ ENDP			; CFileBitmap::ClearAll
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\analtool\FileBitmap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin1.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\analtool\FileBitmap.cpp
;	COMDAT ??1CFileBitmap@@UAE@XZ
_TEXT	SEGMENT
??1CFileBitmap@@UAE@XZ PROC				; CFileBitmap::~CFileBitmap, COMDAT
; _this$ = ecx

; 22   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 28   : 	if(m_hDIB) {

  00003	8b 46 08	 mov	 eax, DWORD PTR [esi+8]

; 22   : {

  00006	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CFileBitmap@@6B@

; 28   : 	if(m_hDIB) {

  0000c	85 c0		 test	 eax, eax
  0000e	74 0e		 je	 SHORT $LN4@CFileBitma

; 29   : 		::GlobalFree(m_hDIB);

  00010	50		 push	 eax
  00011	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalFree@4

; 30   : 		m_hDIB = NULL;

  00017	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN4@CFileBitma:

; 24   : }

  0001e	8d 4e 14	 lea	 ecx, DWORD PTR [esi+20]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin1.inl

; 179  : 	{ }

  00021	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CBitmap@@6B@
  00027	e8 00 00 00 00	 call	 ??1CGdiObject@@UAE@XZ	; CGdiObject::~CGdiObject
  0002c	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CBitmap@@6B@
  00032	8b ce		 mov	 ecx, esi
  00034	5e		 pop	 esi
  00035	e9 00 00 00 00	 jmp	 ??1CGdiObject@@UAE@XZ	; CGdiObject::~CGdiObject
??1CFileBitmap@@UAE@XZ ENDP				; CFileBitmap::~CFileBitmap
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\analtool\FileBitmap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin1.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\analtool\FileBitmap.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin1.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\analtool\FileBitmap.cpp
;	COMDAT ??0CFileBitmap@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CFileBitmap@@QAE@XZ PROC				; CFileBitmap::CFileBitmap, COMDAT
; _this$ = ecx

; 17   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin1.inl

; 70   : 	{ m_hObject = NULL; }

  00004	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\analtool\FileBitmap.cpp

; 19   : }

  0000b	8b c1		 mov	 eax, ecx
  0000d	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CFileBitmap@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin1.inl

; 70   : 	{ m_hObject = NULL; }

  00013	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0

; 177  : 	{ }

  0001a	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], OFFSET ??_7CBitmap@@6B@
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\analtool\FileBitmap.cpp

; 17   : {

  00021	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 18   : 	m_hDIB = NULL;

  00024	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 19   : }

  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
??0CFileBitmap@@QAE@XZ ENDP				; CFileBitmap::CFileBitmap
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin1.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
;	COMDAT ??_GCBitmap@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCBitmap@@UAEPAXI@Z PROC				; CBitmap::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin1.inl

; 179  : 	{ }

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CBitmap@@6B@
  0000c	e8 00 00 00 00	 call	 ??1CGdiObject@@UAE@XZ	; CGdiObject::~CGdiObject
  00011	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00014	a8 01		 test	 al, 1
  00016	74 1f		 je	 SHORT $LN12@scalar
  00018	a8 04		 test	 al, 4
  0001a	75 10		 jne	 SHORT $LN3@scalar
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 112  : 	{ ::operator delete(p); }

  0001c	56		 push	 esi
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	83 c4 04	 add	 esp, 4
  00025	8b c6		 mov	 eax, esi
  00027	5e		 pop	 esi
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
$LN3@scalar:
  0002c	6a 08		 push	 8
  0002e	56		 push	 esi
  0002f	e8 00 00 00 00	 call	 ?__global_delete@@YAXPAXI@Z ; __global_delete
  00034	83 c4 08	 add	 esp, 8
$LN12@scalar:
  00037	8b c6		 mov	 eax, esi
  00039	5e		 pop	 esi
  0003a	5d		 pop	 ebp
  0003b	c2 04 00	 ret	 4
??_GCBitmap@@UAEPAXI@Z ENDP				; CBitmap::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin1.inl
;	COMDAT ??1CBitmap@@UAE@XZ
_TEXT	SEGMENT
??1CBitmap@@UAE@XZ PROC					; CBitmap::~CBitmap, COMDAT
; _this$ = ecx

; 179  : 	{ }

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CBitmap@@6B@
  00006	e9 00 00 00 00	 jmp	 ??1CGdiObject@@UAE@XZ	; CGdiObject::~CGdiObject
??1CBitmap@@UAE@XZ ENDP					; CBitmap::~CBitmap
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
;	COMDAT ??_GCGdiObject@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCGdiObject@@UAEPAXI@Z PROC				; CGdiObject::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CGdiObject@@UAE@XZ	; CGdiObject::~CGdiObject
  0000b	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  0000e	a8 01		 test	 al, 1
  00010	74 1f		 je	 SHORT $LN9@scalar
  00012	a8 04		 test	 al, 4
  00014	75 10		 jne	 SHORT $LN3@scalar

; 112  : 	{ ::operator delete(p); }

  00016	56		 push	 esi
  00017	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001c	83 c4 04	 add	 esp, 4
  0001f	8b c6		 mov	 eax, esi
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
$LN3@scalar:
  00026	6a 08		 push	 8
  00028	56		 push	 esi
  00029	e8 00 00 00 00	 call	 ?__global_delete@@YAXPAXI@Z ; __global_delete
  0002e	83 c4 08	 add	 esp, 8
$LN9@scalar:
  00031	8b c6		 mov	 eax, esi
  00033	5e		 pop	 esi
  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
??_GCGdiObject@@UAEPAXI@Z ENDP				; CGdiObject::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin1.inl
;	COMDAT ??1CGdiObject@@UAE@XZ
_TEXT	SEGMENT
_pException$2 = -540					; size = 4
_strMsg$3 = -536					; size = 4
_szErrorMessage$4 = -532				; size = 512
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
??1CGdiObject@@UAE@XZ PROC				; CGdiObject::~CGdiObject, COMDAT
; _this$ = ecx

; 74   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CGdiObject@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 10 02 00
	00		 sub	 esp, 528		; 00000210H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00031	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CGdiObject@@6B@

; 75   : 	AFX_BEGIN_DESTRUCTOR

  00037	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 76   : 	DeleteObject();

  0003e	e8 00 00 00 00	 call	 ?DeleteObject@CGdiObject@@QAEHXZ ; CGdiObject::DeleteObject
$LN18@CGdiObject:

; 78   : }

  00043	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00046	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0004d	59		 pop	 ecx
  0004e	5f		 pop	 edi
  0004f	5e		 pop	 esi
  00050	5b		 pop	 ebx
  00051	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00054	33 cd		 xor	 ecx, ebp
  00056	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005b	8b e5		 mov	 esp, ebp
  0005d	5d		 pop	 ebp
  0005e	c3		 ret	 0
__catch$??1CGdiObject@@UAE@XZ$0:

; 77   : 	AFX_END_DESTRUCTOR

  0005f	8d 8d e8 fd ff
	ff		 lea	 ecx, DWORD PTR _strMsg$3[ebp]
  00065	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0006b	8b b5 e4 fd ff
	ff		 mov	 esi, DWORD PTR _pException$2[ebp]
  00071	8d 8d ec fd ff
	ff		 lea	 ecx, DWORD PTR _szErrorMessage$4[ebp]
  00077	6a 00		 push	 0
  00079	68 00 02 00 00	 push	 512			; 00000200H
  0007e	51		 push	 ecx
  0007f	8b 06		 mov	 eax, DWORD PTR [esi]
  00081	8b ce		 mov	 ecx, esi
  00083	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
  00087	ff 50 14	 call	 DWORD PTR [eax+20]
  0008a	85 c0		 test	 eax, eax
  0008c	74 2a		 je	 SHORT $LN9@CGdiObject
  0008e	8d 85 ec fd ff
	ff		 lea	 eax, DWORD PTR _szErrorMessage$4[ebp]
  00094	50		 push	 eax
  00095	6a 4d		 push	 77			; 0000004dH
  00097	68 00 00 00 00	 push	 OFFSET ??_C@_0HD@JJCHHHNK@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
  0009c	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@OIEOKIDM@Exception?5thrown?5in?5destructor@
  000a1	8d 85 e8 fd ff
	ff		 lea	 eax, DWORD PTR _strMsg$3[ebp]
  000a7	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@HBOOMJBF@?$CFTs?5?$CI?$CFTs?3?$CFd?$CJ?6?$CFTs@
  000ac	50		 push	 eax
  000ad	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Format@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAAXPBDZZ
  000b3	83 c4 18	 add	 esp, 24			; 00000018H
  000b6	eb 21		 jmp	 SHORT $LN10@CGdiObject
$LN9@CGdiObject:
  000b8	6a 4d		 push	 77			; 0000004dH
  000ba	68 00 00 00 00	 push	 OFFSET ??_C@_0HD@JJCHHHNK@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
  000bf	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@OIEOKIDM@Exception?5thrown?5in?5destructor@
  000c4	8d 85 e8 fd ff
	ff		 lea	 eax, DWORD PTR _strMsg$3[ebp]
  000ca	68 00 00 00 00	 push	 OFFSET ??_C@_0N@OMEMOKLE@?$CFTs?5?$CI?$CFTs?3?$CFd?$CJ@
  000cf	50		 push	 eax
  000d0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Format@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAAXPBDZZ
  000d6	83 c4 14	 add	 esp, 20			; 00000014H
$LN10@CGdiObject:
  000d9	6a 00		 push	 0
  000db	6a 00		 push	 0
  000dd	ff b5 e8 fd ff
	ff		 push	 DWORD PTR _strMsg$3[ebp]
  000e3	e8 00 00 00 00	 call	 ?AfxMessageBox@@YGHPBDII@Z ; AfxMessageBox
  000e8	8d 8d e8 fd ff
	ff		 lea	 ecx, DWORD PTR _strMsg$3[ebp]
  000ee	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  000f4	8b 06		 mov	 eax, DWORD PTR [esi]
  000f6	8b ce		 mov	 ecx, esi
  000f8	6a 01		 push	 1
  000fa	ff 50 04	 call	 DWORD PTR [eax+4]
  000fd	b8 00 00 00 00	 mov	 eax, $LN18@CGdiObject
  00102	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CGdiObject@@UAE@XZ$2:
  00000	8d 8d e8 fd ff
	ff		 lea	 ecx, DWORD PTR _strMsg$3[ebp]
  00006	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0000c	cc		 int	 3
  0000d	cc		 int	 3
  0000e	cc		 int	 3
  0000f	cc		 int	 3
  00010	cc		 int	 3
__ehhandler$??1CGdiObject@@UAE@XZ:
  00011	90		 npad	 1
  00012	90		 npad	 1
  00013	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00017	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001a	8b 8a e0 fd ff
	ff		 mov	 ecx, DWORD PTR [edx-544]
  00020	33 c8		 xor	 ecx, eax
  00022	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00027	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0002a	33 c8		 xor	 ecx, eax
  0002c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00031	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CGdiObject@@UAE@XZ
  00036	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CGdiObject@@UAE@XZ ENDP				; CGdiObject::~CGdiObject
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
;	COMDAT ?Dump@CObject@@UBEXAAVCDumpContext@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?Dump@CObject@@UBEXAAVCDumpContext@@@Z PROC		; CObject::Dump, COMDAT
; _this$ = ecx

; 122  : 	{ /* no dumping in release builds */ }

  00000	c2 04 00	 ret	 4
?Dump@CObject@@UBEXAAVCDumpContext@@@Z ENDP		; CObject::Dump
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
;	COMDAT ?AssertValid@CObject@@UBEXXZ
_TEXT	SEGMENT
?AssertValid@CObject@@UBEXXZ PROC			; CObject::AssertValid, COMDAT
; _this$ = ecx

; 120  : 	{ /* no asserts in release builds */ }

  00000	c2 00 00	 ret	 0
?AssertValid@CObject@@UBEXXZ ENDP			; CObject::AssertValid
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
;	COMDAT ?Serialize@CObject@@UAEXAAVCArchive@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?Serialize@CObject@@UAEXAAVCArchive@@@Z PROC		; CObject::Serialize, COMDAT
; _this$ = ecx

; 106  : 	{ /* CObject does not serialize anything by default */ }

  00000	c2 04 00	 ret	 4
?Serialize@CObject@@UAEXAAVCArchive@@@Z ENDP		; CObject::Serialize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
;	COMDAT ??1CObject@@UAE@XZ
_TEXT	SEGMENT
??1CObject@@UAE@XZ PROC					; CObject::~CObject, COMDAT
; _this$ = ecx

; 104  : 	{ }

  00000	c2 00 00	 ret	 0
??1CObject@@UAE@XZ ENDP					; CObject::~CObject
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\analtool\FileBitmap.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	c2 00 00	 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\MULTICHART\analtool\FileBitmap.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

  00000	c2 00 00	 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
