; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30145.0 

	TITLE	D:\git\src\IBK\IBK_DRFN\#DRfn-CS\_Obj\IndexOptimizer\DlgOptimizer.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BB@GOOPDKI@RMSG_GETPCTRDATA@		; `string'
PUBLIC	??_C@_0BG@OHIMHJEO@RMSG_STTREE_ITEMCLICK@	; `string'
PUBLIC	??_C@_0BH@LAAMLACL@RMSG_STTREE_ITEMDBLCLK@	; `string'
PUBLIC	??_C@_0BO@DBLNBLBD@RMSG_STDATAMANAGER_RESULTDATA@ ; `string'
PUBLIC	??_C@_0BD@GFDLLOKP@RMSG_OB_ITEMDBLCLK@		; `string'
PUBLIC	??_C@_0BA@DEABJHGB@RMSG_GETDLLSIZE@		; `string'
PUBLIC	?hTradeInst@@3PAUHINSTANCE__@@A			; hTradeInst
_BSS	SEGMENT
?hTradeInst@@3PAUHINSTANCE__@@A DD 01H DUP (?)		; hTradeInst
_BSS	ENDS
;	COMDAT ??_C@_0BA@DEABJHGB@RMSG_GETDLLSIZE@
CONST	SEGMENT
??_C@_0BA@DEABJHGB@RMSG_GETDLLSIZE@ DB 'RMSG_GETDLLSIZE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@GFDLLOKP@RMSG_OB_ITEMDBLCLK@
CONST	SEGMENT
??_C@_0BD@GFDLLOKP@RMSG_OB_ITEMDBLCLK@ DB 'RMSG_OB_ITEMDBLCLK', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@DBLNBLBD@RMSG_STDATAMANAGER_RESULTDATA@
CONST	SEGMENT
??_C@_0BO@DBLNBLBD@RMSG_STDATAMANAGER_RESULTDATA@ DB 'RMSG_STDATAMANAGER_'
	DB	'RESULTDATA', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LAAMLACL@RMSG_STTREE_ITEMDBLCLK@
CONST	SEGMENT
??_C@_0BH@LAAMLACL@RMSG_STTREE_ITEMDBLCLK@ DB 'RMSG_STTREE_ITEMDBLCLK', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@OHIMHJEO@RMSG_STTREE_ITEMCLICK@
CONST	SEGMENT
??_C@_0BG@OHIMHJEO@RMSG_STTREE_ITEMCLICK@ DB 'RMSG_STTREE_ITEMCLICK', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GOOPDKI@RMSG_GETPCTRDATA@
CONST	SEGMENT
??_C@_0BB@GOOPDKI@RMSG_GETPCTRDATA@ DB 'RMSG_GETPCTRDATA', 00H ; `string'
CONST	ENDS
PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	___local_stdio_scanf_options
PUBLIC	_sscanf
PUBLIC	?AfxCrtErrorCheck@@YAHH@Z			; AfxCrtErrorCheck
PUBLIC	??1CObject@@UAE@XZ				; CObject::~CObject
PUBLIC	??3CObject@@SGXPAX@Z				; CObject::operator delete
PUBLIC	?Serialize@CObject@@UAEXAAVCArchive@@@Z		; CObject::Serialize
PUBLIC	?AssertValid@CObject@@UBEXXZ			; CObject::AssertValid
PUBLIC	?Dump@CObject@@UBEXAAVCDumpContext@@@Z		; CObject::Dump
PUBLIC	??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@ABV10@0@Z ; ATL::operator+
PUBLIC	??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@ABV10@PBD@Z ; ATL::operator+
PUBLIC	??1CGdiObject@@UAE@XZ				; CGdiObject::~CGdiObject
PUBLIC	??_GCGdiObject@@UAEPAXI@Z			; CGdiObject::`scalar deleting destructor'
PUBLIC	??1CBrush@@UAE@XZ				; CBrush::~CBrush
PUBLIC	??_GCBrush@@UAEPAXI@Z				; CBrush::`scalar deleting destructor'
PUBLIC	??1CFont@@UAE@XZ				; CFont::~CFont
PUBLIC	??_GCFont@@UAEPAXI@Z				; CFont::`scalar deleting destructor'
PUBLIC	??1CBitmap@@UAE@XZ				; CBitmap::~CBitmap
PUBLIC	??_GCBitmap@@UAEPAXI@Z				; CBitmap::`scalar deleting destructor'
PUBLIC	?DoDataExchange@CWnd@@MAEXPAVCDataExchange@@@Z	; CWnd::DoDataExchange
PUBLIC	?BeginModalState@CWnd@@UAEXXZ			; CWnd::BeginModalState
PUBLIC	?EndModalState@CWnd@@UAEXXZ			; CWnd::EndModalState
PUBLIC	?Create@CDialog@@UAEHIPAVCWnd@@@Z		; CDialog::Create
PUBLIC	?GetCount@CListBox@@QBEHXZ			; CListBox::GetCount
PUBLIC	??_GCListBox@@UAEPAXI@Z				; CListBox::`scalar deleting destructor'
PUBLIC	?PreTranslateMessage@CEscDialog@@MAEHPAUtagMSG@@@Z ; CEscDialog::PreTranslateMessage
PUBLIC	??1CEscDialog@@UAE@XZ				; CEscDialog::~CEscDialog
PUBLIC	??_GCEscDialog@@UAEPAXI@Z			; CEscDialog::`scalar deleting destructor'
PUBLIC	??1_GV_ITEM@@QAE@XZ				; _GV_ITEM::~_GV_ITEM
PUBLIC	??0?$CArray@NN@@QAE@XZ				; CArray<double,double>::CArray<double,double>
PUBLIC	?SetSize@?$CArray@NN@@QAEXHH@Z			; CArray<double,double>::SetSize
PUBLIC	?SetAtGrow@?$CArray@NN@@QAEXHN@Z		; CArray<double,double>::SetAtGrow
PUBLIC	??1?$CArray@NN@@UAE@XZ				; CArray<double,double>::~CArray<double,double>
PUBLIC	?Serialize@?$CArray@NN@@UAEXAAVCArchive@@@Z	; CArray<double,double>::Serialize
PUBLIC	??_G?$CArray@NN@@UAEPAXI@Z			; CArray<double,double>::`scalar deleting destructor'
PUBLIC	??0?$CArray@UST_VALUEOPTIMAZE@@U1@@@QAE@XZ	; CArray<ST_VALUEOPTIMAZE,ST_VALUEOPTIMAZE>::CArray<ST_VALUEOPTIMAZE,ST_VALUEOPTIMAZE>
PUBLIC	?SetSize@?$CArray@UST_VALUEOPTIMAZE@@U1@@@QAEXHH@Z ; CArray<ST_VALUEOPTIMAZE,ST_VALUEOPTIMAZE>::SetSize
PUBLIC	?Copy@?$CArray@UST_VALUEOPTIMAZE@@U1@@@QAEXABV1@@Z ; CArray<ST_VALUEOPTIMAZE,ST_VALUEOPTIMAZE>::Copy
PUBLIC	??1?$CArray@UST_VALUEOPTIMAZE@@U1@@@UAE@XZ	; CArray<ST_VALUEOPTIMAZE,ST_VALUEOPTIMAZE>::~CArray<ST_VALUEOPTIMAZE,ST_VALUEOPTIMAZE>
PUBLIC	?Serialize@?$CArray@UST_VALUEOPTIMAZE@@U1@@@UAEXAAVCArchive@@@Z ; CArray<ST_VALUEOPTIMAZE,ST_VALUEOPTIMAZE>::Serialize
PUBLIC	??_G?$CArray@UST_VALUEOPTIMAZE@@U1@@@UAEPAXI@Z	; CArray<ST_VALUEOPTIMAZE,ST_VALUEOPTIMAZE>::`scalar deleting destructor'
PUBLIC	??0ST_GRIDDATA@@QAE@XZ				; ST_GRIDDATA::ST_GRIDDATA
PUBLIC	??1ST_GRIDDATA@@QAE@XZ				; ST_GRIDDATA::~ST_GRIDDATA
PUBLIC	??1ST_VALUEOPTIMAZE@@QAE@XZ			; ST_VALUEOPTIMAZE::~ST_VALUEOPTIMAZE
PUBLIC	??0CDlgOptimizer@@QAE@PAVCWnd@@@Z		; CDlgOptimizer::CDlgOptimizer
PUBLIC	?DoDataExchange@CDlgOptimizer@@MAEXPAVCDataExchange@@@Z ; CDlgOptimizer::DoDataExchange
PUBLIC	?WindowProc@CDlgOptimizer@@MAEJIIJ@Z		; CDlgOptimizer::WindowProc
PUBLIC	?OnNotify@CDlgOptimizer@@MAEHIJPAJ@Z		; CDlgOptimizer::OnNotify
PUBLIC	?OnInitDialog@CDlgOptimizer@@MAEHXZ		; CDlgOptimizer::OnInitDialog
PUBLIC	?OnCtlColor@CDlgOptimizer@@IAEPAUHBRUSH__@@PAVCDC@@PAVCWnd@@I@Z ; CDlgOptimizer::OnCtlColor
PUBLIC	?OnDestroy@CDlgOptimizer@@IAEXXZ		; CDlgOptimizer::OnDestroy
PUBLIC	?OnBtnOpt@CDlgOptimizer@@IAEXXZ			; CDlgOptimizer::OnBtnOpt
PUBLIC	?OnTimer@CDlgOptimizer@@IAEXI@Z			; CDlgOptimizer::OnTimer
PUBLIC	?OnBtnStop@CDlgOptimizer@@IAEXXZ		; CDlgOptimizer::OnBtnStop
PUBLIC	?OnSTDataManagerMessagge@CDlgOptimizer@@IAEJIJ@Z ; CDlgOptimizer::OnSTDataManagerMessagge
PUBLIC	?OnSetKeyCodeChange@CDlgOptimizer@@IAEJIJ@Z	; CDlgOptimizer::OnSetKeyCodeChange
PUBLIC	?OnRmsgObItemDBClk@CDlgOptimizer@@IAEJIJ@Z	; CDlgOptimizer::OnRmsgObItemDBClk
PUBLIC	?OnRmsgGetDllSize@CDlgOptimizer@@IAEJIJ@Z	; CDlgOptimizer::OnRmsgGetDllSize
PUBLIC	?GetThisMessageMap@CDlgOptimizer@@KGPBUAFX_MSGMAP@@XZ ; CDlgOptimizer::GetThisMessageMap
PUBLIC	?GetMessageMap@CDlgOptimizer@@MBEPBUAFX_MSGMAP@@XZ ; CDlgOptimizer::GetMessageMap
PUBLIC	?CreateTImeSetupDlg@CDlgOptimizer@@QAEXXZ	; CDlgOptimizer::CreateTImeSetupDlg
PUBLIC	?DestoryTImeSetupDlg@CDlgOptimizer@@QAEXXZ	; CDlgOptimizer::DestoryTImeSetupDlg
PUBLIC	?FormInit@CDlgOptimizer@@QAEXXZ			; CDlgOptimizer::FormInit
PUBLIC	?FormLoad@CDlgOptimizer@@QAEXXZ			; CDlgOptimizer::FormLoad
PUBLIC	?SetSTMessageType@CDlgOptimizer@@QAEXF@Z	; CDlgOptimizer::SetSTMessageType
PUBLIC	?InitGrid@CDlgOptimizer@@QAEXXZ			; CDlgOptimizer::InitGrid
PUBLIC	?InitCodeInfo@CDlgOptimizer@@QAEXXZ		; CDlgOptimizer::InitCodeInfo
PUBLIC	?ReSize@CDlgOptimizer@@QAEXXZ			; CDlgOptimizer::ReSize
PUBLIC	?AutoSizeColumns@CDlgOptimizer@@QAEXXZ		; CDlgOptimizer::AutoSizeColumns
PUBLIC	??0?$CArray@PAVCDialog@@PAV1@@@QAE@XZ		; CArray<CDialog *,CDialog *>::CArray<CDialog *,CDialog *>
PUBLIC	?SetSize@?$CArray@PAVCDialog@@PAV1@@@QAEXHH@Z	; CArray<CDialog *,CDialog *>::SetSize
PUBLIC	?SetAtGrow@?$CArray@PAVCDialog@@PAV1@@@QAEXHPAVCDialog@@@Z ; CArray<CDialog *,CDialog *>::SetAtGrow
PUBLIC	??1?$CArray@PAVCDialog@@PAV1@@@UAE@XZ		; CArray<CDialog *,CDialog *>::~CArray<CDialog *,CDialog *>
PUBLIC	?Serialize@?$CArray@PAVCDialog@@PAV1@@@UAEXAAVCArchive@@@Z ; CArray<CDialog *,CDialog *>::Serialize
PUBLIC	??_G?$CArray@PAVCDialog@@PAV1@@@UAEPAXI@Z	; CArray<CDialog *,CDialog *>::`scalar deleting destructor'
PUBLIC	??0?$CArray@PAUST_VALUE@@PAU1@@@QAE@XZ		; CArray<ST_VALUE *,ST_VALUE *>::CArray<ST_VALUE *,ST_VALUE *>
PUBLIC	?SetSize@?$CArray@PAUST_VALUE@@PAU1@@@QAEXHH@Z	; CArray<ST_VALUE *,ST_VALUE *>::SetSize
PUBLIC	??1?$CArray@PAUST_VALUE@@PAU1@@@UAE@XZ		; CArray<ST_VALUE *,ST_VALUE *>::~CArray<ST_VALUE *,ST_VALUE *>
PUBLIC	?Serialize@?$CArray@PAUST_VALUE@@PAU1@@@UAEXAAVCArchive@@@Z ; CArray<ST_VALUE *,ST_VALUE *>::Serialize
PUBLIC	??_G?$CArray@PAUST_VALUE@@PAU1@@@UAEPAXI@Z	; CArray<ST_VALUE *,ST_VALUE *>::`scalar deleting destructor'
PUBLIC	?InitTab@CDlgOptimizer@@QAEXXZ			; CDlgOptimizer::InitTab
PUBLIC	?InitControls@CDlgOptimizer@@QAEXXZ		; CDlgOptimizer::InitControls
PUBLIC	?RemoveAllControlSet@CDlgOptimizer@@QAEXXZ	; CDlgOptimizer::RemoveAllControlSet
PUBLIC	?StartOpt@CDlgOptimizer@@QAEXXZ			; CDlgOptimizer::StartOpt
PUBLIC	?InitStrategy@CDlgOptimizer@@QAEXXZ		; CDlgOptimizer::InitStrategy
PUBLIC	?CalculateSendData@CDlgOptimizer@@QAEHXZ	; CDlgOptimizer::CalculateSendData
PUBLIC	?GetJMNameAndGubunFromCode@CDlgOptimizer@@QAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V23@@Z ; CDlgOptimizer::GetJMNameAndGubunFromCode
PUBLIC	?IsCurrentChartData@CDlgOptimizer@@QAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ; CDlgOptimizer::IsCurrentChartData
PUBLIC	?IsNumber@CDlgOptimizer@@QAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z ; CDlgOptimizer::IsNumber
PUBLIC	?SpreadGridData@CDlgOptimizer@@QAEXXZ		; CDlgOptimizer::SpreadGridData
PUBLIC	??0?$CArray@UST_RUNVALUE@@U1@@@QAE@XZ		; CArray<ST_RUNVALUE,ST_RUNVALUE>::CArray<ST_RUNVALUE,ST_RUNVALUE>
PUBLIC	?SetSize@?$CArray@UST_RUNVALUE@@U1@@@QAEXHH@Z	; CArray<ST_RUNVALUE,ST_RUNVALUE>::SetSize
PUBLIC	??1?$CArray@UST_RUNVALUE@@U1@@@UAE@XZ		; CArray<ST_RUNVALUE,ST_RUNVALUE>::~CArray<ST_RUNVALUE,ST_RUNVALUE>
PUBLIC	?Serialize@?$CArray@UST_RUNVALUE@@U1@@@UAEXAAVCArchive@@@Z ; CArray<ST_RUNVALUE,ST_RUNVALUE>::Serialize
PUBLIC	??_G?$CArray@UST_RUNVALUE@@U1@@@UAEPAXI@Z	; CArray<ST_RUNVALUE,ST_RUNVALUE>::`scalar deleting destructor'
PUBLIC	??0?$CArray@UST_GRIDDATA@@U1@@@QAE@XZ		; CArray<ST_GRIDDATA,ST_GRIDDATA>::CArray<ST_GRIDDATA,ST_GRIDDATA>
PUBLIC	?SetSize@?$CArray@UST_GRIDDATA@@U1@@@QAEXHH@Z	; CArray<ST_GRIDDATA,ST_GRIDDATA>::SetSize
PUBLIC	??1?$CArray@UST_GRIDDATA@@U1@@@UAE@XZ		; CArray<ST_GRIDDATA,ST_GRIDDATA>::~CArray<ST_GRIDDATA,ST_GRIDDATA>
PUBLIC	?Serialize@?$CArray@UST_GRIDDATA@@U1@@@UAEXAAVCArchive@@@Z ; CArray<ST_GRIDDATA,ST_GRIDDATA>::Serialize
PUBLIC	??_G?$CArray@UST_GRIDDATA@@U1@@@UAEPAXI@Z	; CArray<ST_GRIDDATA,ST_GRIDDATA>::`scalar deleting destructor'
PUBLIC	??0?$CArray@UST_STRGRIDDATA@@U1@@@QAE@XZ	; CArray<ST_STRGRIDDATA,ST_STRGRIDDATA>::CArray<ST_STRGRIDDATA,ST_STRGRIDDATA>
PUBLIC	?SetSize@?$CArray@UST_STRGRIDDATA@@U1@@@QAEXHH@Z ; CArray<ST_STRGRIDDATA,ST_STRGRIDDATA>::SetSize
PUBLIC	??1?$CArray@UST_STRGRIDDATA@@U1@@@UAE@XZ	; CArray<ST_STRGRIDDATA,ST_STRGRIDDATA>::~CArray<ST_STRGRIDDATA,ST_STRGRIDDATA>
PUBLIC	?Serialize@?$CArray@UST_STRGRIDDATA@@U1@@@UAEXAAVCArchive@@@Z ; CArray<ST_STRGRIDDATA,ST_STRGRIDDATA>::Serialize
PUBLIC	??_G?$CArray@UST_STRGRIDDATA@@U1@@@UAEPAXI@Z	; CArray<ST_STRGRIDDATA,ST_STRGRIDDATA>::`scalar deleting destructor'
PUBLIC	?MedoMesuComboDataParsing@CDlgOptimizer@@QAEXXZ	; CDlgOptimizer::MedoMesuComboDataParsing
PUBLIC	?SearchFileToData@CDlgOptimizer@@QAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V23@0@Z ; CDlgOptimizer::SearchFileToData
PUBLIC	?SetControlState@CDlgOptimizer@@QAEXH@Z		; CDlgOptimizer::SetControlState
PUBLIC	?InitSkin@CDlgOptimizer@@QAEXXZ			; CDlgOptimizer::InitSkin
PUBLIC	?LoadOutlookBar@CDlgOptimizer@@QAEXXZ		; CDlgOptimizer::LoadOutlookBar
PUBLIC	?LoadSTList@CDlgOptimizer@@QAEXXZ		; CDlgOptimizer::LoadSTList
PUBLIC	?UnLoadSTList@CDlgOptimizer@@QAEXXZ		; CDlgOptimizer::UnLoadSTList
PUBLIC	?OnBnClickedBtnAddall@CDlgOptimizer@@QAEXXZ	; CDlgOptimizer::OnBnClickedBtnAddall
PUBLIC	?OnBnClickedBtnAddone@CDlgOptimizer@@QAEXXZ	; CDlgOptimizer::OnBnClickedBtnAddone
PUBLIC	?OnBnClickedBtnDelall@CDlgOptimizer@@QAEXXZ	; CDlgOptimizer::OnBnClickedBtnDelall
PUBLIC	?OnBnClickedBtnDelone@CDlgOptimizer@@QAEXXZ	; CDlgOptimizer::OnBnClickedBtnDelone
PUBLIC	?HideControl@CDlgOptimizer@@QAEXXZ		; CDlgOptimizer::HideControl
PUBLIC	?GetChartData@CSTUserData@CDlgOptimizer@@UAGHAAJ000000AAH@Z ; CDlgOptimizer::CSTUserData::GetChartData
PUBLIC	?OnLbnDblclkListSt@CDlgOptimizer@@QAEXXZ	; CDlgOptimizer::OnLbnDblclkListSt
PUBLIC	?LoadSTList_SSStyle@CDlgOptimizer@@QAEXXZ	; CDlgOptimizer::LoadSTList_SSStyle
PUBLIC	?OnRmsgSTTreeItemDBClk@CDlgOptimizer@@QAEJIJ@Z	; CDlgOptimizer::OnRmsgSTTreeItemDBClk
PUBLIC	??1CDlgOptimizer@@UAE@XZ			; CDlgOptimizer::~CDlgOptimizer
PUBLIC	??_GCDlgOptimizer@@UAEPAXI@Z			; CDlgOptimizer::`scalar deleting destructor'
PUBLIC	?StartOptThread@@YAIPAX@Z			; StartOptThread
PUBLIC	??0?$CList@PAUSTMNG_ITEMINFO@@PAU1@@@QAE@H@Z	; CList<STMNG_ITEMINFO *,STMNG_ITEMINFO *>::CList<STMNG_ITEMINFO *,STMNG_ITEMINFO *>
PUBLIC	?AddTail@?$CList@PAUSTMNG_ITEMINFO@@PAU1@@@QAEPAU__POSITION@@PAUSTMNG_ITEMINFO@@@Z ; CList<STMNG_ITEMINFO *,STMNG_ITEMINFO *>::AddTail
PUBLIC	?RemoveAll@?$CList@PAUSTMNG_ITEMINFO@@PAU1@@@QAEXXZ ; CList<STMNG_ITEMINFO *,STMNG_ITEMINFO *>::RemoveAll
PUBLIC	?NewNode@?$CList@PAUSTMNG_ITEMINFO@@PAU1@@@IAEPAUCNode@1@PAU21@0@Z ; CList<STMNG_ITEMINFO *,STMNG_ITEMINFO *>::NewNode
PUBLIC	??1?$CList@PAUSTMNG_ITEMINFO@@PAU1@@@UAE@XZ	; CList<STMNG_ITEMINFO *,STMNG_ITEMINFO *>::~CList<STMNG_ITEMINFO *,STMNG_ITEMINFO *>
PUBLIC	?Serialize@?$CList@PAUSTMNG_ITEMINFO@@PAU1@@@UAEXAAVCArchive@@@Z ; CList<STMNG_ITEMINFO *,STMNG_ITEMINFO *>::Serialize
PUBLIC	??_G?$CList@PAUSTMNG_ITEMINFO@@PAU1@@@UAEPAXI@Z	; CList<STMNG_ITEMINFO *,STMNG_ITEMINFO *>::`scalar deleting destructor'
PUBLIC	??$SerializeElements@N@@YGXAAVCArchive@@PANH@Z	; SerializeElements<double>
PUBLIC	??$SerializeElements@PAUSTMNG_ITEMINFO@@@@YGXAAVCArchive@@PAPAUSTMNG_ITEMINFO@@H@Z ; SerializeElements<STMNG_ITEMINFO *>
PUBLIC	??$SerializeElements@UST_VALUEOPTIMAZE@@@@YGXAAVCArchive@@PAUST_VALUEOPTIMAZE@@H@Z ; SerializeElements<ST_VALUEOPTIMAZE>
PUBLIC	??$SerializeElements@PAVCDialog@@@@YGXAAVCArchive@@PAPAVCDialog@@H@Z ; SerializeElements<CDialog *>
PUBLIC	??$SerializeElements@PAUST_VALUE@@@@YGXAAVCArchive@@PAPAUST_VALUE@@H@Z ; SerializeElements<ST_VALUE *>
PUBLIC	??$SerializeElements@UST_RUNVALUE@@@@YGXAAVCArchive@@PAUST_RUNVALUE@@H@Z ; SerializeElements<ST_RUNVALUE>
PUBLIC	??$SerializeElements@UST_GRIDDATA@@@@YGXAAVCArchive@@PAUST_GRIDDATA@@H@Z ; SerializeElements<ST_GRIDDATA>
PUBLIC	??$SerializeElements@UST_STRGRIDDATA@@@@YGXAAVCArchive@@PAUST_STRGRIDDATA@@H@Z ; SerializeElements<ST_STRGRIDDATA>
PUBLIC	?_OptionsStorage@?1??__local_stdio_scanf_options@@9@4_KA ; `__local_stdio_scanf_options'::`2'::_OptionsStorage
PUBLIC	??_R0PAVCException@@@8				; CException * `RTTI Type Descriptor'
PUBLIC	??_C@_02DPKJAMEF@?$CFd@				; `string'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_7CGdiObject@@6B@				; CGdiObject::`vftable'
PUBLIC	??_7CBrush@@6B@					; CBrush::`vftable'
PUBLIC	??_7CFont@@6B@					; CFont::`vftable'
PUBLIC	??_7CBitmap@@6B@				; CBitmap::`vftable'
PUBLIC	??_7CListBox@@6B@				; CListBox::`vftable'
PUBLIC	??_C@_0HD@JJCHHHNK@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ ; `string'
PUBLIC	??_C@_0BP@OIEOKIDM@Exception?5thrown?5in?5destructor@ ; `string'
PUBLIC	??_C@_0BB@HBOOMJBF@?$CFTs?5?$CI?$CFTs?3?$CFd?$CJ?6?$CFTs@ ; `string'
PUBLIC	??_C@_0N@OMEMOKLE@?$CFTs?5?$CI?$CFTs?3?$CFd?$CJ@ ; `string'
PUBLIC	??_C@_01HIHLOKLC@1@				; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
PUBLIC	??_C@_0M@CBBNGGHM@PcTrMng?4dll@			; `string'
PUBLIC	??_C@_0P@IDMAJEGN@HANAROPCTRMAIN@		; `string'
PUBLIC	??_C@_06NDLAHCHE@?$CFs?$CF08X@			; `string'
PUBLIC	??_C@_02EMFKHFLK@?$CFX@				; `string'
PUBLIC	??_7CEscDialog@@6B@				; CEscDialog::`vftable'
PUBLIC	??_R0?AVCObject@@@8				; CObject `RTTI Type Descriptor'
PUBLIC	??_R3CObject@@8					; CObject::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CObject@@8					; CObject::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CObject@@8			; CObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4CGdiObject@@6B@				; CGdiObject::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCGdiObject@@@8				; CGdiObject `RTTI Type Descriptor'
PUBLIC	??_R3CGdiObject@@8				; CGdiObject::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CGdiObject@@8				; CGdiObject::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CGdiObject@@8			; CGdiObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4CBrush@@6B@				; CBrush::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCBrush@@@8				; CBrush `RTTI Type Descriptor'
PUBLIC	??_R3CBrush@@8					; CBrush::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CBrush@@8					; CBrush::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CBrush@@8				; CBrush::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4CFont@@6B@					; CFont::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCFont@@@8				; CFont `RTTI Type Descriptor'
PUBLIC	??_R3CFont@@8					; CFont::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CFont@@8					; CFont::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CFont@@8				; CFont::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4CBitmap@@6B@				; CBitmap::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCBitmap@@@8				; CBitmap `RTTI Type Descriptor'
PUBLIC	??_R3CBitmap@@8					; CBitmap::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CBitmap@@8					; CBitmap::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CBitmap@@8			; CBitmap::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@CWnd@@8				; CWnd::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCWnd@@@8				; CWnd `RTTI Type Descriptor'
PUBLIC	??_R3CWnd@@8					; CWnd::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CWnd@@8					; CWnd::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CCmdTarget@@8			; CCmdTarget::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCCmdTarget@@@8				; CCmdTarget `RTTI Type Descriptor'
PUBLIC	??_R3CCmdTarget@@8				; CCmdTarget::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CCmdTarget@@8				; CCmdTarget::`RTTI Base Class Array'
PUBLIC	??_R4CListBox@@6B@				; CListBox::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCListBox@@@8				; CListBox `RTTI Type Descriptor'
PUBLIC	??_R3CListBox@@8				; CListBox::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CListBox@@8				; CListBox::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CListBox@@8			; CListBox::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@CDialog@@8			; CDialog::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCDialog@@@8				; CDialog `RTTI Type Descriptor'
PUBLIC	??_R3CDialog@@8					; CDialog::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CDialog@@8					; CDialog::`RTTI Base Class Array'
PUBLIC	??_R4CEscDialog@@6B@				; CEscDialog::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCEscDialog@@@8				; CEscDialog `RTTI Type Descriptor'
PUBLIC	??_R3CEscDialog@@8				; CEscDialog::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CEscDialog@@8				; CEscDialog::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CEscDialog@@8			; CEscDialog::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_7ISTUserData@@6B@				; ISTUserData::`vftable'
PUBLIC	??_7?$CArray@NN@@6B@				; CArray<double,double>::`vftable'
PUBLIC	??_7?$CArray@UST_VALUEOPTIMAZE@@U1@@@6B@	; CArray<ST_VALUEOPTIMAZE,ST_VALUEOPTIMAZE>::`vftable'
PUBLIC	??_C@_04ECGMOPPD@?$CK?4ST@			; `string'
PUBLIC	??_7?$CArray@PAVCDialog@@PAV1@@@6B@		; CArray<CDialog *,CDialog *>::`vftable'
PUBLIC	??_7?$CArray@PAUST_VALUE@@PAU1@@@6B@		; CArray<ST_VALUE *,ST_VALUE *>::`vftable'
PUBLIC	??_7?$CArray@UST_RUNVALUE@@U1@@@6B@		; CArray<ST_RUNVALUE,ST_RUNVALUE>::`vftable'
PUBLIC	??_7?$CArray@UST_GRIDDATA@@U1@@@6B@		; CArray<ST_GRIDDATA,ST_GRIDDATA>::`vftable'
PUBLIC	??_7?$CArray@UST_STRGRIDDATA@@U1@@@6B@		; CArray<ST_STRGRIDDATA,ST_STRGRIDDATA>::`vftable'
PUBLIC	??_7CSTUserData@CDlgOptimizer@@6B@		; CDlgOptimizer::CSTUserData::`vftable'
PUBLIC	??_7CDlgOptimizer@@6B@				; CDlgOptimizer::`vftable'
PUBLIC	??_C@_02NNHDHLCM@?$MA?O@			; `string'
PUBLIC	??_C@_06MFMMLLPC@?$LB?$LM?$LI?$LC?C?$LM@	; `string'
PUBLIC	??_C@_08BKFIOHKC@?2drchart@			; `string'
PUBLIC	??_C@_0O@DADNAINN@?$CFs?2folder?4bmp@		; `string'
PUBLIC	??_C@_0BD@OCOIJGGE@?$CFs?2outbar_icon?4bmp@	; `string'
PUBLIC	??_C@_0BD@CNEELEMP@SCW_IGfxOutBarCtrl@		; `string'
PUBLIC	??_C@_0BO@DLDLABLN@HWStrategyConfigureWizard?4dll@ ; `string'
PUBLIC	??_C@_0BL@OHKGLIGI@SCW_GetInterfaceOfStrategy@	; `string'
PUBLIC	??_C@_09ONDJILNJ@STDATA?2ST@			; `string'
PUBLIC	??_C@_01KICIPPFI@?2@				; `string'
PUBLIC	??_C@_03JMEKIEOG@Row@				; `string'
PUBLIC	??_C@_06NEMOAOGB@?$MA?$PM?$LH?$KL?$LI?m@	; `string'
PUBLIC	??_C@_06GNECPJOA@?C?Q?$LM?U?$MA?M@		; `string'
PUBLIC	??_C@_08IANCNINB@?F?r?$LB?U?$LM?U?$MA?M@	; `string'
PUBLIC	??_C@_06HMHBOMDL@?C?Q?$MA?L?$MA?M@		; `string'
PUBLIC	??_C@_06MLIEOKGJ@?C?Q?$LM?U?$LN?G@		; `string'
PUBLIC	??_C@_08MKACKNJD@?C?V?$LE?k?$MA?L?$MA?M@	; `string'
PUBLIC	??_C@_08HNPHKLMB@?C?V?$LE?k?$LM?U?$LN?G@	; `string'
PUBLIC	??_C@_06FDKHGHHF@?$LM?v?$MA?M?$LH?$PM@		; `string'
PUBLIC	??_C@_0N@HGEBBOLI@ProfitFactor@			; `string'
PUBLIC	??_C@_04HFNGKEOO@?$LN?B?$LH?$PM@		; `string'
PUBLIC	??_C@_04BPIEHLPP@?$LA?E?$LH?$KB@		; `string'
PUBLIC	??_C@_06MKCPLBEP@?A?v?G?$KF?$LI?m@		; `string'
PUBLIC	??_C@_02DINIKGF@?$LK?$MA@			; `string'
PUBLIC	??_C@_07BMIBILFB@?2STData@			; `string'
PUBLIC	??_C@_0BE@MFEGIDEI@?2IndexOptimizer?4htm@	; `string'
PUBLIC	??_C@_0N@NNCCFHAL@?2IOTrade?4htm@		; `string'
PUBLIC	??_C@_08OEAPFIFH@?$LM?$LK?$LA?z?$LK?P?$LM?$KO@	; `string'
PUBLIC	??_C@_08INENBIFG@?$LI?E?$LI?E?$LD?$LL?$LP?$KK@	; `string'
PUBLIC	??_C@_0L@CPJPEJFL@?$LM?v?$MA?M?$LH?$PM?B?w?F?$KO@ ; `string'
PUBLIC	??_C@_0N@HEBKHCBM@?$LM?U?$MA?M?$LK?P?F?w?B?w?F?$KO@ ; `string'
PUBLIC	??_C@_0BK@IMFLIICM@?$MA?$PM?$LH?$KL?$MA?L?5?$LI?$KO?$LN?$LK?F?$KO?$LP?$KB?5?$LO?x?$LN?$MA?$LE?O?$LE?Y?4@ ; `string'
PUBLIC	??_C@_03IDLCJCBF@?4st@				; `string'
PUBLIC	??_C@_0P@PJNJDIFE@Icss?2STDATA?2SD@		; `string'
PUBLIC	??_C@_0O@ILIJGNAL@Usr?2STDATA?2SD@		; `string'
PUBLIC	??_C@_0DF@KKHNOAOO@?$LK?$MA?5?$MA?T?$LH?B?$LA?$KK?$MA?L?5?$MA?$NP?$LI?x?5?$LM?$LD?A?$KE?$LF?G?$LO?z?$LN?$MA?$LE?O?$LE?Y@ ; `string'
PUBLIC	??_C@_0DI@FCBICJNP@1000?5?$MA?L?$LL?s?$MA?G?5?$LA?$KK?$MA?$LK?5?$LL?g?$LP?k?G?R?5?$LM?v?5?$LO?x?$LN?$MA@ ; `string'
PUBLIC	??_C@_05DCDOHKAB@Input@				; `string'
PUBLIC	??_C@_0L@CNGHBHNE@?$CFs?$CFd?$DN?$CF?42f?0@	; `string'
PUBLIC	??_C@_04GEFJINEE@?$CF?42f@			; `string'
PUBLIC	??_7?$CList@PAUSTMNG_ITEMINFO@@PAU1@@@6B@	; CList<STMNG_ITEMINFO *,STMNG_ITEMINFO *>::`vftable'
PUBLIC	??_C@_01BMBHCPLG@5@				; `string'
PUBLIC	??_C@_0BO@NADBMJJJ@?C?V?$MA?$PL?H?$KN?$LA?$KB?5?$MA?$NP?$LI?x?5?$LM?$LB?E?C?$LF?G?$LO?z?$LN?$MA?$LE?O?$LE?Y?4@ ; `string'
PUBLIC	??_C@_0BL@EOEHIOGI@?2Icss?2STData?2VarOptima?4cfg@ ; `string'
PUBLIC	??_C@_0CL@JOCOAICG@?$LK?$KP?$LM?v?5?C?V?$MA?$PL?H?$KN?$LP?$KB?$LM?$KN?5?$LL?g?$LP?k?G?R?5?$LM?v?5?$LO?x?$LE?B?5@ ; `string'
PUBLIC	??_C@_0BO@CPKKMKKO@SCW_DeleteInterfaceOfStrategy@ ; `string'
PUBLIC	??_C@_04FFLPOIDN@?C?J?$LB?$NO@			; `string'
PUBLIC	??_C@_04NGCIOFKF@?$LA?m?$LB?$NO@		; `string'
PUBLIC	??_R4?$CArray@NN@@6B@				; CArray<double,double>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CArray@NN@@@8				; CArray<double,double> `RTTI Type Descriptor'
PUBLIC	??_R3?$CArray@NN@@8				; CArray<double,double>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CArray@NN@@8				; CArray<double,double>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CArray@NN@@8			; CArray<double,double>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4CDlgOptimizer@@6B@				; CDlgOptimizer::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCDlgOptimizer@@@8			; CDlgOptimizer `RTTI Type Descriptor'
PUBLIC	??_R3CDlgOptimizer@@8				; CDlgOptimizer::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CDlgOptimizer@@8				; CDlgOptimizer::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CDlgOptimizer@@8			; CDlgOptimizer::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CList@PAUSTMNG_ITEMINFO@@PAU1@@@6B@	; CList<STMNG_ITEMINFO *,STMNG_ITEMINFO *>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CList@PAUSTMNG_ITEMINFO@@PAU1@@@@8	; CList<STMNG_ITEMINFO *,STMNG_ITEMINFO *> `RTTI Type Descriptor'
PUBLIC	??_R3?$CList@PAUSTMNG_ITEMINFO@@PAU1@@@8	; CList<STMNG_ITEMINFO *,STMNG_ITEMINFO *>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CList@PAUSTMNG_ITEMINFO@@PAU1@@@8	; CList<STMNG_ITEMINFO *,STMNG_ITEMINFO *>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CList@PAUSTMNG_ITEMINFO@@PAU1@@@8 ; CList<STMNG_ITEMINFO *,STMNG_ITEMINFO *>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4ISTUserData@@6B@				; ISTUserData::`RTTI Complete Object Locator'
PUBLIC	??_R0?AUISTUserData@@@8				; ISTUserData `RTTI Type Descriptor'
PUBLIC	??_R3ISTUserData@@8				; ISTUserData::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ISTUserData@@8				; ISTUserData::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ISTUserData@@8			; ISTUserData::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CArray@UST_VALUEOPTIMAZE@@U1@@@6B@	; CArray<ST_VALUEOPTIMAZE,ST_VALUEOPTIMAZE>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CArray@UST_VALUEOPTIMAZE@@U1@@@@8	; CArray<ST_VALUEOPTIMAZE,ST_VALUEOPTIMAZE> `RTTI Type Descriptor'
PUBLIC	??_R3?$CArray@UST_VALUEOPTIMAZE@@U1@@@8		; CArray<ST_VALUEOPTIMAZE,ST_VALUEOPTIMAZE>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CArray@UST_VALUEOPTIMAZE@@U1@@@8		; CArray<ST_VALUEOPTIMAZE,ST_VALUEOPTIMAZE>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CArray@UST_VALUEOPTIMAZE@@U1@@@8 ; CArray<ST_VALUEOPTIMAZE,ST_VALUEOPTIMAZE>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CArray@PAVCDialog@@PAV1@@@6B@		; CArray<CDialog *,CDialog *>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CArray@PAVCDialog@@PAV1@@@@8		; CArray<CDialog *,CDialog *> `RTTI Type Descriptor'
PUBLIC	??_R3?$CArray@PAVCDialog@@PAV1@@@8		; CArray<CDialog *,CDialog *>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CArray@PAVCDialog@@PAV1@@@8		; CArray<CDialog *,CDialog *>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CArray@PAVCDialog@@PAV1@@@8	; CArray<CDialog *,CDialog *>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CArray@PAUST_VALUE@@PAU1@@@6B@		; CArray<ST_VALUE *,ST_VALUE *>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CArray@PAUST_VALUE@@PAU1@@@@8		; CArray<ST_VALUE *,ST_VALUE *> `RTTI Type Descriptor'
PUBLIC	??_R3?$CArray@PAUST_VALUE@@PAU1@@@8		; CArray<ST_VALUE *,ST_VALUE *>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CArray@PAUST_VALUE@@PAU1@@@8		; CArray<ST_VALUE *,ST_VALUE *>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CArray@PAUST_VALUE@@PAU1@@@8	; CArray<ST_VALUE *,ST_VALUE *>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CArray@UST_RUNVALUE@@U1@@@6B@		; CArray<ST_RUNVALUE,ST_RUNVALUE>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CArray@UST_RUNVALUE@@U1@@@@8		; CArray<ST_RUNVALUE,ST_RUNVALUE> `RTTI Type Descriptor'
PUBLIC	??_R3?$CArray@UST_RUNVALUE@@U1@@@8		; CArray<ST_RUNVALUE,ST_RUNVALUE>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CArray@UST_RUNVALUE@@U1@@@8		; CArray<ST_RUNVALUE,ST_RUNVALUE>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CArray@UST_RUNVALUE@@U1@@@8	; CArray<ST_RUNVALUE,ST_RUNVALUE>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CArray@UST_GRIDDATA@@U1@@@6B@		; CArray<ST_GRIDDATA,ST_GRIDDATA>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CArray@UST_GRIDDATA@@U1@@@@8		; CArray<ST_GRIDDATA,ST_GRIDDATA> `RTTI Type Descriptor'
PUBLIC	??_R3?$CArray@UST_GRIDDATA@@U1@@@8		; CArray<ST_GRIDDATA,ST_GRIDDATA>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CArray@UST_GRIDDATA@@U1@@@8		; CArray<ST_GRIDDATA,ST_GRIDDATA>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CArray@UST_GRIDDATA@@U1@@@8	; CArray<ST_GRIDDATA,ST_GRIDDATA>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CArray@UST_STRGRIDDATA@@U1@@@6B@		; CArray<ST_STRGRIDDATA,ST_STRGRIDDATA>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CArray@UST_STRGRIDDATA@@U1@@@@8	; CArray<ST_STRGRIDDATA,ST_STRGRIDDATA> `RTTI Type Descriptor'
PUBLIC	??_R3?$CArray@UST_STRGRIDDATA@@U1@@@8		; CArray<ST_STRGRIDDATA,ST_STRGRIDDATA>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CArray@UST_STRGRIDDATA@@U1@@@8		; CArray<ST_STRGRIDDATA,ST_STRGRIDDATA>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CArray@UST_STRGRIDDATA@@U1@@@8	; CArray<ST_STRGRIDDATA,ST_STRGRIDDATA>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4CSTUserData@CDlgOptimizer@@6B@		; CDlgOptimizer::CSTUserData::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCSTUserData@CDlgOptimizer@@@8		; CDlgOptimizer::CSTUserData `RTTI Type Descriptor'
PUBLIC	??_R3CSTUserData@CDlgOptimizer@@8		; CDlgOptimizer::CSTUserData::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CSTUserData@CDlgOptimizer@@8		; CDlgOptimizer::CSTUserData::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CSTUserData@CDlgOptimizer@@8	; CDlgOptimizer::CSTUserData::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@408f400000000000
PUBLIC	__xmm@0000002d0000002d000000500000003c
PUBLIC	__xmm@000000320000004b0000004b00000032
PUBLIC	__xmm@0000003c000000460000006400000000
PUBLIC	__xmm@0000004b000000070000007800000000
PUBLIC	__xmm@0000004b0000004b0000003c00000046
PUBLIC	__xmm@00000050000000460000006400000000
PUBLIC	__xmm@00000190000000000000000000000000
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	?__global_delete@@YAXPAXI@Z:PROC		; __global_delete
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	___std_terminate:PROC
EXTRN	__imp___invalid_parameter_noinfo:PROC
EXTRN	__imp___errno:PROC
EXTRN	__imp__GetEnvironmentVariableA@12:PROC
EXTRN	__imp__FreeLibrary@4:PROC
EXTRN	__imp__GetModuleHandleA@4:PROC
EXTRN	__imp__GetProcAddress@8:PROC
EXTRN	__imp__LoadLibraryA@4:PROC
EXTRN	__imp__CreateFontIndirectA@4:PROC
EXTRN	__imp__CreateSolidBrush@4:PROC
EXTRN	__imp__RegisterWindowMessageA@4:PROC
EXTRN	__imp__SendMessageA@16:PROC
EXTRN	__imp__GetKeyState@4:PROC
EXTRN	__imp__KillTimer@8:PROC
EXTRN	__imp__EnableWindow@8:PROC
EXTRN	__imp__GetClientRect@8:PROC
EXTRN	__imp__GetWindowRect@8:PROC
EXTRN	__imp__InflateRect@12:PROC
EXTRN	__imp__GetParent@4:PROC
EXTRN	__imp__LoadImageA@24:PROC
EXTRN	__imp__ImageList_AddMasked@12:PROC
EXTRN	__imp____stdio_common_vsscanf:PROC
EXTRN	__imp__atoi:PROC
EXTRN	?AfxThrowMemoryException@@YGXXZ:PROC		; AfxThrowMemoryException
EXTRN	?AfxThrowInvalidArgException@@YGXXZ:PROC	; AfxThrowInvalidArgException
EXTRN	?AfxThrowArchiveException@@YGXHPBD@Z:PROC	; AfxThrowArchiveException
EXTRN	?GetRuntimeClass@CObject@@UBEPAUCRuntimeClass@@XZ:PROC ; CObject::GetRuntimeClass
EXTRN	__imp_?GetAt@?$CSimpleStringT@D$00@ATL@@QBEDH@Z:PROC
EXTRN	__imp_?Concatenate@?$CSimpleStringT@D$00@ATL@@KAXAAV12@PBDH1H@Z:PROC
EXTRN	__imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ:PROC
EXTRN	__imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PAUIAtlStringMgr@1@@Z:PROC
EXTRN	__imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z:PROC
EXTRN	__imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z:PROC
EXTRN	__imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ:PROC
EXTRN	__imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z:PROC
EXTRN	__imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z:PROC
EXTRN	__imp_??Y?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV?$CSimpleStringT@D$00@1@@Z:PROC
EXTRN	__imp_??Y?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z:PROC
EXTRN	__imp_?GetManager@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEPAUIAtlStringMgr@2@XZ:PROC
EXTRN	__imp_?Compare@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEHPBD@Z:PROC
EXTRN	__imp_?Delete@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEHHH@Z:PROC
EXTRN	__imp_?Find@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEHDH@Z:PROC
EXTRN	__imp_?Mid@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBE?AV12@HH@Z:PROC
EXTRN	__imp_?Left@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBE?AV12@H@Z:PROC
EXTRN	__imp_?Format@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAAXPBDZZ:PROC
EXTRN	?Read@CArchive@@QAEIPAXI@Z:PROC			; CArchive::Read
EXTRN	?Write@CArchive@@QAEXPBXI@Z:PROC		; CArchive::Write
EXTRN	?ReadCount@CArchive@@QAEKXZ:PROC		; CArchive::ReadCount
EXTRN	?WriteCount@CArchive@@QAEXK@Z:PROC		; CArchive::WriteCount
EXTRN	??0CStringArray@@QAE@XZ:PROC			; CStringArray::CStringArray
EXTRN	?SetSize@CStringArray@@QAEXHH@Z:PROC		; CStringArray::SetSize
EXTRN	?SetAtGrow@CStringArray@@QAEXHPBD@Z:PROC	; CStringArray::SetAtGrow
EXTRN	?SetAtGrow@CStringArray@@QAEXHABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z:PROC ; CStringArray::SetAtGrow
EXTRN	??1CStringArray@@UAE@XZ:PROC			; CStringArray::~CStringArray
EXTRN	?Create@CPlex@@SGPAU1@AAPAU1@II@Z:PROC		; CPlex::Create
EXTRN	?FreeDataChain@CPlex@@QAEXXZ:PROC		; CPlex::FreeDataChain
EXTRN	?GetRuntimeClass@CGdiObject@@UBEPAUCRuntimeClass@@XZ:PROC ; CGdiObject::GetRuntimeClass
EXTRN	?Attach@CGdiObject@@QAEHPAX@Z:PROC		; CGdiObject::Attach
EXTRN	?DeleteObject@CGdiObject@@QAEHXZ:PROC		; CGdiObject::DeleteObject
EXTRN	??_ECGdiObject@@UAEPAXI@Z:PROC			; CGdiObject::`vector deleting destructor'
EXTRN	?GetRuntimeClass@CBrush@@UBEPAUCRuntimeClass@@XZ:PROC ; CBrush::GetRuntimeClass
EXTRN	??_ECBrush@@UAEPAXI@Z:PROC			; CBrush::`vector deleting destructor'
EXTRN	?GetRuntimeClass@CFont@@UBEPAUCRuntimeClass@@XZ:PROC ; CFont::GetRuntimeClass
EXTRN	??_ECFont@@UAEPAXI@Z:PROC			; CFont::`vector deleting destructor'
EXTRN	?GetRuntimeClass@CBitmap@@UBEPAUCRuntimeClass@@XZ:PROC ; CBitmap::GetRuntimeClass
EXTRN	??_ECBitmap@@UAEPAXI@Z:PROC			; CBitmap::`vector deleting destructor'
EXTRN	??0CImageList@@QAE@XZ:PROC			; CImageList::CImageList
EXTRN	?Create@CImageList@@QAEHHHIHH@Z:PROC		; CImageList::Create
EXTRN	?DeleteImageList@CImageList@@QAEHXZ:PROC	; CImageList::DeleteImageList
EXTRN	??1CImageList@@UAE@XZ:PROC			; CImageList::~CImageList
EXTRN	?DDX_Control@@YGXPAVCDataExchange@@HAAVCWnd@@@Z:PROC ; DDX_Control
EXTRN	?OnCmdMsg@CCmdTarget@@UAEHIHPAXPAUAFX_CMDHANDLERINFO@@@Z:PROC ; CCmdTarget::OnCmdMsg
EXTRN	?IsInvokeAllowed@CCmdTarget@@UAEHJ@Z:PROC	; CCmdTarget::IsInvokeAllowed
EXTRN	?GetDispatchIID@CCmdTarget@@UAEHPAU_GUID@@@Z:PROC ; CCmdTarget::GetDispatchIID
EXTRN	?GetTypeInfoCount@CCmdTarget@@UAEIXZ:PROC	; CCmdTarget::GetTypeInfoCount
EXTRN	?GetTypeLibCache@CCmdTarget@@UAEPAVCTypeLibCache@@XZ:PROC ; CCmdTarget::GetTypeLibCache
EXTRN	?GetTypeLib@CCmdTarget@@UAEJKPAPAUITypeLib@@@Z:PROC ; CCmdTarget::GetTypeLib
EXTRN	?GetCommandMap@CCmdTarget@@MBEPBUAFX_OLECMDMAP@@XZ:PROC ; CCmdTarget::GetCommandMap
EXTRN	?GetDispatchMap@CCmdTarget@@MBEPBUAFX_DISPMAP@@XZ:PROC ; CCmdTarget::GetDispatchMap
EXTRN	?GetConnectionMap@CCmdTarget@@MBEPBUAFX_CONNECTIONMAP@@XZ:PROC ; CCmdTarget::GetConnectionMap
EXTRN	?GetEventSinkMap@CCmdTarget@@MBEPBUAFX_EVENTSINKMAP@@XZ:PROC ; CCmdTarget::GetEventSinkMap
EXTRN	?OnCreateAggregates@CCmdTarget@@UAEHXZ:PROC	; CCmdTarget::OnCreateAggregates
EXTRN	?GetInterfaceHook@CCmdTarget@@UAEPAUIUnknown@@PBX@Z:PROC ; CCmdTarget::GetInterfaceHook
EXTRN	?GetExtraConnectionPoints@CCmdTarget@@MAEHPAVCPtrArray@@@Z:PROC ; CCmdTarget::GetExtraConnectionPoints
EXTRN	?GetConnectionHook@CCmdTarget@@MAEPAUIConnectionPoint@@ABU_GUID@@@Z:PROC ; CCmdTarget::GetConnectionHook
EXTRN	??0CWnd@@QAE@XZ:PROC				; CWnd::CWnd
EXTRN	?FromHandle@CWnd@@SGPAV1@PAUHWND__@@@Z:PROC	; CWnd::FromHandle
EXTRN	?PreSubclassWindow@CWnd@@UAEXXZ:PROC		; CWnd::PreSubclassWindow
EXTRN	?Create@CWnd@@UAEHPBD0KABUtagRECT@@PAV1@IPAUCCreateContext@@@Z:PROC ; CWnd::Create
EXTRN	?CreateEx@CWnd@@UAEHKPBD0KHHHHPAUHWND__@@PAUHMENU__@@PAX@Z:PROC ; CWnd::CreateEx
EXTRN	?CreateEx@CWnd@@UAEHKPBD0KABUtagRECT@@PAV1@IPAX@Z:PROC ; CWnd::CreateEx
EXTRN	?DestroyWindow@CWnd@@UAEHXZ:PROC		; CWnd::DestroyWindow
EXTRN	?PreCreateWindow@CWnd@@UAEHAAUtagCREATESTRUCTA@@@Z:PROC ; CWnd::PreCreateWindow
EXTRN	?CalcWindowRect@CWnd@@UAEXPAUtagRECT@@I@Z:PROC	; CWnd::CalcWindowRect
EXTRN	?GetDlgItem@CWnd@@QBEPAV1@H@Z:PROC		; CWnd::GetDlgItem
EXTRN	?GetMenu@CWnd@@UBEPAVCMenu@@XZ:PROC		; CWnd::GetMenu
EXTRN	?SetMenu@CWnd@@UAEHPAVCMenu@@@Z:PROC		; CWnd::SetMenu
EXTRN	?MoveWindow@CWnd@@QAEXHHHHH@Z:PROC		; CWnd::MoveWindow
EXTRN	?ScreenToClient@CWnd@@QBEXPAUtagRECT@@@Z:PROC	; CWnd::ScreenToClient
EXTRN	?ShowWindow@CWnd@@QAEHH@Z:PROC			; CWnd::ShowWindow
EXTRN	?OnToolHitTest@CWnd@@UBEHVCPoint@@PAUtagTOOLINFOA@@@Z:PROC ; CWnd::OnToolHitTest
EXTRN	?GetDlgItemInt@CWnd@@QBEIHPAHH@Z:PROC		; CWnd::GetDlgItemInt
EXTRN	?SetDlgItemTextA@CWnd@@QAEXHPBD@Z:PROC		; CWnd::SetDlgItemTextA
EXTRN	?GetScrollBarCtrl@CWnd@@UBEPAVCScrollBar@@H@Z:PROC ; CWnd::GetScrollBarCtrl
EXTRN	?WinHelpA@CWnd@@UAEXKI@Z:PROC			; CWnd::WinHelpA
EXTRN	?HtmlHelpA@CWnd@@UAEXKI@Z:PROC			; CWnd::HtmlHelpA
EXTRN	?WinHelpInternal@CWnd@@UAEXKI@Z:PROC		; CWnd::WinHelpInternal
EXTRN	?ContinueModal@CWnd@@UAEHXZ:PROC		; CWnd::ContinueModal
EXTRN	?EndModalLoop@CWnd@@UAEXH@Z:PROC		; CWnd::EndModalLoop
EXTRN	?OnDrawIconicThumbnailOrLivePreview@CWnd@@UAEXAAVCDC@@VCRect@@VCSize@@HAAH@Z:PROC ; CWnd::OnDrawIconicThumbnailOrLivePreview
EXTRN	?GetInterfaceMap@CWnd@@MBEPBUAFX_INTERFACEMAP@@XZ:PROC ; CWnd::GetInterfaceMap
EXTRN	?EnsureStdObj@CWnd@@UAEJXZ:PROC			; CWnd::EnsureStdObj
EXTRN	?get_accParent@CWnd@@UAEJPAPAUIDispatch@@@Z:PROC ; CWnd::get_accParent
EXTRN	?get_accChildCount@CWnd@@UAEJPAJ@Z:PROC		; CWnd::get_accChildCount
EXTRN	?get_accChild@CWnd@@UAEJUtagVARIANT@@PAPAUIDispatch@@@Z:PROC ; CWnd::get_accChild
EXTRN	?get_accName@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z:PROC ; CWnd::get_accName
EXTRN	?get_accValue@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z:PROC ; CWnd::get_accValue
EXTRN	?get_accDescription@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z:PROC ; CWnd::get_accDescription
EXTRN	?get_accRole@CWnd@@UAEJUtagVARIANT@@PAU2@@Z:PROC ; CWnd::get_accRole
EXTRN	?get_accState@CWnd@@UAEJUtagVARIANT@@PAU2@@Z:PROC ; CWnd::get_accState
EXTRN	?get_accHelp@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z:PROC ; CWnd::get_accHelp
EXTRN	?get_accHelpTopic@CWnd@@UAEJPAPA_WUtagVARIANT@@PAJ@Z:PROC ; CWnd::get_accHelpTopic
EXTRN	?get_accKeyboardShortcut@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z:PROC ; CWnd::get_accKeyboardShortcut
EXTRN	?get_accFocus@CWnd@@UAEJPAUtagVARIANT@@@Z:PROC	; CWnd::get_accFocus
EXTRN	?get_accSelection@CWnd@@UAEJPAUtagVARIANT@@@Z:PROC ; CWnd::get_accSelection
EXTRN	?get_accDefaultAction@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z:PROC ; CWnd::get_accDefaultAction
EXTRN	?accSelect@CWnd@@UAEJJUtagVARIANT@@@Z:PROC	; CWnd::accSelect
EXTRN	?accLocation@CWnd@@UAEJPAJ000UtagVARIANT@@@Z:PROC ; CWnd::accLocation
EXTRN	?accNavigate@CWnd@@UAEJJUtagVARIANT@@PAU2@@Z:PROC ; CWnd::accNavigate
EXTRN	?accHitTest@CWnd@@UAEJJJPAUtagVARIANT@@@Z:PROC	; CWnd::accHitTest
EXTRN	?accDoDefaultAction@CWnd@@UAEJUtagVARIANT@@@Z:PROC ; CWnd::accDoDefaultAction
EXTRN	?put_accName@CWnd@@UAEJUtagVARIANT@@PA_W@Z:PROC	; CWnd::put_accName
EXTRN	?put_accValue@CWnd@@UAEJUtagVARIANT@@PA_W@Z:PROC ; CWnd::put_accValue
EXTRN	?SetProxy@CWnd@@UAEJPAUIAccessibleProxy@@@Z:PROC ; CWnd::SetProxy
EXTRN	?CreateAccessibleProxy@CWnd@@UAEJIJPAJ@Z:PROC	; CWnd::CreateAccessibleProxy
EXTRN	?OnCommand@CWnd@@MAEHIJ@Z:PROC			; CWnd::OnCommand
EXTRN	?OnNotify@CWnd@@MAEHIJPAJ@Z:PROC		; CWnd::OnNotify
EXTRN	?OnCtlColor@CWnd@@IAEPAUHBRUSH__@@PAVCDC@@PAV1@I@Z:PROC ; CWnd::OnCtlColor
EXTRN	?OnDestroy@CWnd@@IAEXXZ:PROC			; CWnd::OnDestroy
EXTRN	?GetSuperWndProcAddr@CWnd@@MAEPAP6GJPAUHWND__@@IIJ@ZXZ:PROC ; CWnd::GetSuperWndProcAddr
EXTRN	?PreTranslateMessage@CWnd@@UAEHPAUtagMSG@@@Z:PROC ; CWnd::PreTranslateMessage
EXTRN	?OnAmbientProperty@CWnd@@UAEHPAVCOleControlSite@@JPAUtagVARIANT@@@Z:PROC ; CWnd::OnAmbientProperty
EXTRN	?WindowProc@CWnd@@MAEJIIJ@Z:PROC		; CWnd::WindowProc
EXTRN	?OnWndMsg@CWnd@@MAEHIIJPAJ@Z:PROC		; CWnd::OnWndMsg
EXTRN	?Default@CWnd@@IAEJXZ:PROC			; CWnd::Default
EXTRN	?DefWindowProcA@CWnd@@MAEJIIJ@Z:PROC		; CWnd::DefWindowProcA
EXTRN	?PostNcDestroy@CWnd@@MAEXXZ:PROC		; CWnd::PostNcDestroy
EXTRN	?OnChildNotify@CWnd@@MAEHIIJPAJ@Z:PROC		; CWnd::OnChildNotify
EXTRN	?OnTouchInputs@CWnd@@MAEHIPAUtagTOUCHINPUT@@@Z:PROC ; CWnd::OnTouchInputs
EXTRN	?OnTouchInput@CWnd@@MAEHVCPoint@@HHPAUtagTOUCHINPUT@@@Z:PROC ; CWnd::OnTouchInput
EXTRN	?GetGestureStatus@CWnd@@MAEKVCPoint@@@Z:PROC	; CWnd::GetGestureStatus
EXTRN	?OnGestureZoom@CWnd@@MAEHVCPoint@@J@Z:PROC	; CWnd::OnGestureZoom
EXTRN	?OnGesturePan@CWnd@@MAEHVCPoint@@0@Z:PROC	; CWnd::OnGesturePan
EXTRN	?OnGestureRotate@CWnd@@MAEHVCPoint@@N@Z:PROC	; CWnd::OnGestureRotate
EXTRN	?OnGestureTwoFingerTap@CWnd@@MAEHVCPoint@@@Z:PROC ; CWnd::OnGestureTwoFingerTap
EXTRN	?OnGesturePressAndTap@CWnd@@MAEHVCPoint@@J@Z:PROC ; CWnd::OnGesturePressAndTap
EXTRN	?ResizeDynamicLayout@CWnd@@MAEXXZ:PROC		; CWnd::ResizeDynamicLayout
EXTRN	?CheckAutoCenter@CWnd@@UAEHXZ:PROC		; CWnd::CheckAutoCenter
EXTRN	?IsFrameWnd@CWnd@@UBEHXZ:PROC			; CWnd::IsFrameWnd
EXTRN	?OnFinalRelease@CWnd@@UAEXXZ:PROC		; CWnd::OnFinalRelease
EXTRN	?CreateControlContainer@CWnd@@MAEHPAPAVCOleControlContainer@@@Z:PROC ; CWnd::CreateControlContainer
EXTRN	?CreateControlSite@CWnd@@MAEHPAVCOleControlContainer@@PAPAVCOleControlSite@@IABU_GUID@@@Z:PROC ; CWnd::CreateControlSite
EXTRN	?SetOccDialogInfo@CWnd@@MAEHPAU_AFX_OCC_DIALOG_INFO@@@Z:PROC ; CWnd::SetOccDialogInfo
EXTRN	?GetOccDialogInfo@CWnd@@MAEPAU_AFX_OCC_DIALOG_INFO@@XZ:PROC ; CWnd::GetOccDialogInfo
EXTRN	?GetMessageMap@CWnd@@MBEPBUAFX_MSGMAP@@XZ:PROC	; CWnd::GetMessageMap
EXTRN	?GetRuntimeClass@CDialog@@UBEPAUCRuntimeClass@@XZ:PROC ; CDialog::GetRuntimeClass
EXTRN	?Create@CDialog@@UAEHPBDPAVCWnd@@@Z:PROC	; CDialog::Create
EXTRN	?CreateIndirect@CDialog@@UAEHPBUDLGTEMPLATE@@PAVCWnd@@PAX@Z:PROC ; CDialog::CreateIndirect
EXTRN	?CreateIndirect@CDialog@@UAEHPAXPAVCWnd@@@Z:PROC ; CDialog::CreateIndirect
EXTRN	??0CDialog@@QAE@IPAVCWnd@@@Z:PROC		; CDialog::CDialog
EXTRN	?DoModal@CDialog@@UAEHXZ:PROC			; CDialog::DoModal
EXTRN	?OnInitDialog@CDialog@@UAEHXZ:PROC		; CDialog::OnInitDialog
EXTRN	?OnSetFont@CDialog@@UAEXPAVCFont@@@Z:PROC	; CDialog::OnSetFont
EXTRN	?OnOK@CDialog@@MAEXXZ:PROC			; CDialog::OnOK
EXTRN	?OnCancel@CDialog@@MAEXXZ:PROC			; CDialog::OnCancel
EXTRN	??1CDialog@@UAE@XZ:PROC				; CDialog::~CDialog
EXTRN	?PreTranslateMessage@CDialog@@UAEHPAUtagMSG@@@Z:PROC ; CDialog::PreTranslateMessage
EXTRN	?OnCmdMsg@CDialog@@UAEHIHPAXPAUAFX_CMDHANDLERINFO@@@Z:PROC ; CDialog::OnCmdMsg
EXTRN	?CheckAutoCenter@CDialog@@UAEHXZ:PROC		; CDialog::CheckAutoCenter
EXTRN	?SetOccDialogInfo@CDialog@@MAEHPAU_AFX_OCC_DIALOG_INFO@@@Z:PROC ; CDialog::SetOccDialogInfo
EXTRN	?GetOccDialogInfo@CDialog@@MAEPAU_AFX_OCC_DIALOG_INFO@@XZ:PROC ; CDialog::GetOccDialogInfo
EXTRN	?PreInitDialog@CDialog@@MAEXXZ:PROC		; CDialog::PreInitDialog
EXTRN	?GetThisMessageMap@CDialog@@KGPBUAFX_MSGMAP@@XZ:PROC ; CDialog::GetThisMessageMap
EXTRN	?GetMessageMap@CDialog@@MBEPBUAFX_MSGMAP@@XZ:PROC ; CDialog::GetMessageMap
EXTRN	?GetRuntimeClass@CListBox@@UBEPAUCRuntimeClass@@XZ:PROC ; CListBox::GetRuntimeClass
EXTRN	?Create@CListBox@@UAEHKABUtagRECT@@PAVCWnd@@I@Z:PROC ; CListBox::Create
EXTRN	?DrawItem@CListBox@@UAEXPAUtagDRAWITEMSTRUCT@@@Z:PROC ; CListBox::DrawItem
EXTRN	?MeasureItem@CListBox@@UAEXPAUtagMEASUREITEMSTRUCT@@@Z:PROC ; CListBox::MeasureItem
EXTRN	?CompareItem@CListBox@@UAEHPAUtagCOMPAREITEMSTRUCT@@@Z:PROC ; CListBox::CompareItem
EXTRN	?DeleteItem@CListBox@@UAEXPAUtagDELETEITEMSTRUCT@@@Z:PROC ; CListBox::DeleteItem
EXTRN	?VKeyToItem@CListBox@@UAEHII@Z:PROC		; CListBox::VKeyToItem
EXTRN	?CharToItem@CListBox@@UAEHII@Z:PROC		; CListBox::CharToItem
EXTRN	??1CListBox@@UAE@XZ:PROC			; CListBox::~CListBox
EXTRN	?OnChildNotify@CListBox@@MAEHIIJPAJ@Z:PROC	; CListBox::OnChildNotify
EXTRN	??_ECListBox@@UAEPAXI@Z:PROC			; CListBox::`vector deleting destructor'
EXTRN	?AfxBeginThread@@YGPAVCWinThread@@P6AIPAX@Z0HIKPAU_SECURITY_ATTRIBUTES@@@Z:PROC ; AfxBeginThread
EXTRN	?AfxMessageBox@@YGHPBDII@Z:PROC			; AfxMessageBox
EXTRN	?AfxEnableControlContainer@@YAXPAVCOccManager@@@Z:PROC ; AfxEnableControlContainer
EXTRN	??0CXTabCtrl@@QAE@XZ:PROC			; CXTabCtrl::CXTabCtrl
EXTRN	?AddTab@CXTabCtrl@@QAEXPAVCWnd@@PADH@Z:PROC	; CXTabCtrl::AddTab
EXTRN	?SetTopLeftCorner@CXTabCtrl@@QAEXVCPoint@@@Z:PROC ; CXTabCtrl::SetTopLeftCorner
EXTRN	?SetSelectedColor@CXTabCtrl@@QAEXKK@Z:PROC	; CXTabCtrl::SetSelectedColor
EXTRN	?SetNormalColor@CXTabCtrl@@QAEXKKK@Z:PROC	; CXTabCtrl::SetNormalColor
EXTRN	??1CXTabCtrl@@UAE@XZ:PROC			; CXTabCtrl::~CXTabCtrl
EXTRN	??0CStrategyLoader@@QAE@XZ:PROC			; CStrategyLoader::CStrategyLoader
EXTRN	?GetStrategyItem@CStrategyLoader@@QAEPAVCIStrategyItem0001@@XZ:PROC ; CStrategyLoader::GetStrategyItem
EXTRN	??1CStrategyLoader@@UAE@XZ:PROC			; CStrategyLoader::~CStrategyLoader
EXTRN	??0CExDrawButton@@QAE@H@Z:PROC			; CExDrawButton::CExDrawButton
EXTRN	??1CExDrawButton@@UAE@XZ:PROC			; CExDrawButton::~CExDrawButton
EXTRN	??_ECEscDialog@@UAEPAXI@Z:PROC			; CEscDialog::`vector deleting destructor'
EXTRN	??0CGridCtrl@@QAE@HHHH@Z:PROC			; CGridCtrl::CGridCtrl
EXTRN	?Create@CGridCtrl@@QAEHABUtagRECT@@PAVCWnd@@IK@Z:PROC ; CGridCtrl::Create
EXTRN	?SetRowCount@CGridCtrl@@QAEHH@Z:PROC		; CGridCtrl::SetRowCount
EXTRN	?SetColumnCount@CGridCtrl@@QAEHH@Z:PROC		; CGridCtrl::SetColumnCount
EXTRN	?SetFixedRowCount@CGridCtrl@@QAEHH@Z:PROC	; CGridCtrl::SetFixedRowCount
EXTRN	?SetRowHeight@CGridCtrl@@QAEHHH@Z:PROC		; CGridCtrl::SetRowHeight
EXTRN	?SetColumnWidth@CGridCtrl@@QAEHHH@Z:PROC	; CGridCtrl::SetColumnWidth
EXTRN	?SetListMode@CGridCtrl@@QAEXH@Z:PROC		; CGridCtrl::SetListMode
EXTRN	?SetItem@CGridCtrl@@QAEHPBU_GV_ITEM@@@Z:PROC	; CGridCtrl::SetItem
EXTRN	?SetItemText@CGridCtrl@@QAEHHHPBDK@Z:PROC	; CGridCtrl::SetItemText
EXTRN	?SetItemText@CGridCtrl@@QAEHHHPBD@Z:PROC	; CGridCtrl::SetItemText
EXTRN	?GetItemText@CGridCtrl@@QBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HH@Z:PROC ; CGridCtrl::GetItemText
EXTRN	?InsertRow@CGridCtrl@@QAEHPBDH@Z:PROC		; CGridCtrl::InsertRow
EXTRN	?AutoSizeColumn@CGridCtrl@@QAEHHIH@Z:PROC	; CGridCtrl::AutoSizeColumn
EXTRN	?ExpandColumnsToFit@CGridCtrl@@QAEXH@Z:PROC	; CGridCtrl::ExpandColumnsToFit
EXTRN	?Refresh@CGridCtrl@@QAEXXZ:PROC			; CGridCtrl::Refresh
EXTRN	?SortItems@CGridCtrl@@QAEHP6GHJJJ@ZHHJ@Z:PROC	; CGridCtrl::SortItems
EXTRN	?pfnCellTextCompare@CGridCtrl@@SGHJJJ@Z:PROC	; CGridCtrl::pfnCellTextCompare
EXTRN	?pfnCellNumericCompare@CGridCtrl@@SGHJJJ@Z:PROC	; CGridCtrl::pfnCellNumericCompare
EXTRN	??1CGridCtrl@@UAE@XZ:PROC			; CGridCtrl::~CGridCtrl
EXTRN	??0CDlgResult@@QAE@PAVCWnd@@@Z:PROC		; CDlgResult::CDlgResult
EXTRN	?SetOptimizer@CDlgResult@@QAEXPAVCDlgOptimizer@@@Z:PROC ; CDlgResult::SetOptimizer
EXTRN	?SetDataDir@CDlgResult@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z:PROC ; CDlgResult::SetDataDir
EXTRN	?OpenWebView@CDlgResult@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z:PROC ; CDlgResult::OpenWebView
EXTRN	?GetComma@CDlgResult@@QAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PBD@Z:PROC ; CDlgResult::GetComma
EXTRN	?SetDataSpreadGrid@CDlgResult@@QAEXXZ:PROC	; CDlgResult::SetDataSpreadGrid
EXTRN	??0CTabSoonikChart@@QAE@PAVCWnd@@@Z:PROC	; CTabSoonikChart::CTabSoonikChart
EXTRN	??0CTabSonikChart@@QAE@PAVCWnd@@@Z:PROC		; CTabSonikChart::CTabSonikChart
EXTRN	??0CDlgTrade@@QAE@PAVCWnd@@@Z:PROC		; CDlgTrade::CDlgTrade
EXTRN	?SetStrategyItem@CDlgTrade@@QAEXPAVCIStrategyItem0001@@@Z:PROC ; CDlgTrade::SetStrategyItem
EXTRN	?SetDataDir@CDlgTrade@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z:PROC ; CDlgTrade::SetDataDir
EXTRN	?OpenWebView@CDlgTrade@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z:PROC ; CDlgTrade::OpenWebView
EXTRN	?SetDataSpreadGrid@CDlgTrade@@QAEXXZ:PROC	; CDlgTrade::SetDataSpreadGrid
EXTRN	??0CSTGfxOutBarCtrl@@QAE@XZ:PROC		; CSTGfxOutBarCtrl::CSTGfxOutBarCtrl
EXTRN	?SetImageList@CSTGfxOutBarCtrl@@QAEPAVCImageList@@PAV2@H@Z:PROC ; CSTGfxOutBarCtrl::SetImageList
EXTRN	?Create@CSTGfxOutBarCtrl@@QAEHKABUtagRECT@@PAVCWnd@@IK@Z:PROC ; CSTGfxOutBarCtrl::Create
EXTRN	??1CSTGfxOutBarCtrl@@UAE@XZ:PROC		; CSTGfxOutBarCtrl::~CSTGfxOutBarCtrl
EXTRN	?SetFolderImageList@CSTGfxOutBarCtrl@@QAEXPAVCImageList@@HHH@Z:PROC ; CSTGfxOutBarCtrl::SetFolderImageList
EXTRN	??0CSTDataItem@@QAE@XZ:PROC			; CSTDataItem::CSTDataItem
EXTRN	??_E?$CArray@NN@@UAEPAXI@Z:PROC			; CArray<double,double>::`vector deleting destructor'
EXTRN	??0CSDataItem@@QAE@XZ:PROC			; CSDataItem::CSDataItem
EXTRN	??0CDlgTimeSetup@@QAE@PAVCWnd@@@Z:PROC		; CDlgTimeSetup::CDlgTimeSetup
EXTRN	?Reset@CDlgTimeSetup@@QAEXXZ:PROC		; CDlgTimeSetup::Reset
EXTRN	?LoadCFG@CDlgTimeSetup@@QAEHPBD0@Z:PROC		; CDlgTimeSetup::LoadCFG
EXTRN	?ParseCFG@CDlgTimeSetup@@QAEXXZ:PROC		; CDlgTimeSetup::ParseCFG
EXTRN	?SetInputData@CDlgTimeSetup@@QAEXXZ:PROC	; CDlgTimeSetup::SetInputData
EXTRN	??_E?$CArray@UST_VALUEOPTIMAZE@@U1@@@UAEPAXI@Z:PROC ; CArray<ST_VALUEOPTIMAZE,ST_VALUEOPTIMAZE>::`vector deleting destructor'
EXTRN	?Create@CSTTreeCtrl@@QAEHKABUtagRECT@@PAVCWnd@@I@Z:PROC ; CSTTreeCtrl::Create
EXTRN	??0CSTExtTree@@QAE@XZ:PROC			; CSTExtTree::CSTExtTree
EXTRN	??1CSTExtTree@@UAE@XZ:PROC			; CSTExtTree::~CSTExtTree
EXTRN	??0CSTBasicTree@@QAE@XZ:PROC			; CSTBasicTree::CSTBasicTree
EXTRN	??1CSTBasicTree@@UAE@XZ:PROC			; CSTBasicTree::~CSTBasicTree
EXTRN	??_E?$CArray@PAVCDialog@@PAV1@@@UAEPAXI@Z:PROC	; CArray<CDialog *,CDialog *>::`vector deleting destructor'
EXTRN	??_E?$CArray@PAUST_VALUE@@PAU1@@@UAEPAXI@Z:PROC	; CArray<ST_VALUE *,ST_VALUE *>::`vector deleting destructor'
EXTRN	??_E?$CArray@UST_RUNVALUE@@U1@@@UAEPAXI@Z:PROC	; CArray<ST_RUNVALUE,ST_RUNVALUE>::`vector deleting destructor'
EXTRN	??_E?$CArray@UST_GRIDDATA@@U1@@@UAEPAXI@Z:PROC	; CArray<ST_GRIDDATA,ST_GRIDDATA>::`vector deleting destructor'
EXTRN	??_E?$CArray@UST_STRGRIDDATA@@U1@@@UAEPAXI@Z:PROC ; CArray<ST_STRGRIDDATA,ST_STRGRIDDATA>::`vector deleting destructor'
EXTRN	??_ECDlgOptimizer@@UAEPAXI@Z:PROC		; CDlgOptimizer::`vector deleting destructor'
EXTRN	??_E?$CList@PAUSTMNG_ITEMINFO@@PAU1@@@UAEPAXI@Z:PROC ; CList<STMNG_ITEMINFO *,STMNG_ITEMINFO *>::`vector deleting destructor'
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_scanf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_scanf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_scanf_options'::`2'::_OptionsStorage
_BSS	ENDS
_BSS	SEGMENT
?RMSG_GETPCTRDATA@@3IB DD 01H DUP (?)			; RMSG_GETPCTRDATA
?RMSG_STTREE_ITEMCLICK@@3IB DD 01H DUP (?)		; RMSG_STTREE_ITEMCLICK
?RMSG_STTREE_ITEMDBLCLK@@3IB DD 01H DUP (?)		; RMSG_STTREE_ITEMDBLCLK
?RMSG_STDATAMANAGER_RESULTDATA@@3IB DD 01H DUP (?)	; RMSG_STDATAMANAGER_RESULTDATA
?RMSG_OB_ITEMDBLCLK@@3IB DD 01H DUP (?)			; RMSG_OB_ITEMDBLCLK
?RMSG_GETDLLSIZE@@3IB DD 01H DUP (?)			; RMSG_GETDLLSIZE
_BSS	ENDS
CRT$XCU	SEGMENT
?RMSG_GETPCTRDATA$initializer$@@3P6AXXZA DD FLAT:??__ERMSG_GETPCTRDATA@@YAXXZ ; RMSG_GETPCTRDATA$initializer$
CRT$XCU	ENDS
;	COMDAT __xmm@00000190000000000000000000000000
CONST	SEGMENT
__xmm@00000190000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 090H, 01H, 00H, 00H
CONST	ENDS
;	COMDAT __xmm@00000050000000460000006400000000
CONST	SEGMENT
__xmm@00000050000000460000006400000000 DB 00H, 00H, 00H, 00H, 'd', 00H, 00H
	DB	00H, 'F', 00H, 00H, 00H, 'P', 00H, 00H, 00H
CONST	ENDS
;	COMDAT __xmm@0000004b0000004b0000003c00000046
CONST	SEGMENT
__xmm@0000004b0000004b0000003c00000046 DB 'F', 00H, 00H, 00H, '<', 00H, 00H
	DB	00H, 'K', 00H, 00H, 00H, 'K', 00H, 00H, 00H
CONST	ENDS
;	COMDAT __xmm@0000004b000000070000007800000000
CONST	SEGMENT
__xmm@0000004b000000070000007800000000 DB 00H, 00H, 00H, 00H, 'x', 00H, 00H
	DB	00H, 07H, 00H, 00H, 00H, 'K', 00H, 00H, 00H
CONST	ENDS
;	COMDAT __xmm@0000003c000000460000006400000000
CONST	SEGMENT
__xmm@0000003c000000460000006400000000 DB 00H, 00H, 00H, 00H, 'd', 00H, 00H
	DB	00H, 'F', 00H, 00H, 00H, '<', 00H, 00H, 00H
CONST	ENDS
;	COMDAT __xmm@000000320000004b0000004b00000032
CONST	SEGMENT
__xmm@000000320000004b0000004b00000032 DB '2', 00H, 00H, 00H, 'K', 00H, 00H
	DB	00H, 'K', 00H, 00H, 00H, '2', 00H, 00H, 00H
CONST	ENDS
;	COMDAT __xmm@0000002d0000002d000000500000003c
CONST	SEGMENT
__xmm@0000002d0000002d000000500000003c DB '<', 00H, 00H, 00H, 'P', 00H, 00H
	DB	00H, '-', 00H, 00H, 00H, '-', 00H, 00H, 00H
CONST	ENDS
;	COMDAT __real@408f400000000000
CONST	SEGMENT
__real@408f400000000000 DQ 0408f400000000000r	; 1000
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@CSTUserData@CDlgOptimizer@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CSTUserData@CDlgOptimizer@@8 DD FLAT:??_R0?AVCSTUserData@CDlgOptimizer@@@8 ; CDlgOptimizer::CSTUserData::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CSTUserData@CDlgOptimizer@@8
rdata$r	ENDS
;	COMDAT ??_R2CSTUserData@CDlgOptimizer@@8
rdata$r	SEGMENT
??_R2CSTUserData@CDlgOptimizer@@8 DD FLAT:??_R1A@?0A@EA@CSTUserData@CDlgOptimizer@@8 ; CDlgOptimizer::CSTUserData::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ISTUserData@@8
rdata$r	ENDS
;	COMDAT ??_R3CSTUserData@CDlgOptimizer@@8
rdata$r	SEGMENT
??_R3CSTUserData@CDlgOptimizer@@8 DD 00H		; CDlgOptimizer::CSTUserData::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CSTUserData@CDlgOptimizer@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCSTUserData@CDlgOptimizer@@@8
data$rs	SEGMENT
??_R0?AVCSTUserData@CDlgOptimizer@@@8 DD FLAT:??_7type_info@@6B@ ; CDlgOptimizer::CSTUserData `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCSTUserData@CDlgOptimizer@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CSTUserData@CDlgOptimizer@@6B@
rdata$r	SEGMENT
??_R4CSTUserData@CDlgOptimizer@@6B@ DD 00H		; CDlgOptimizer::CSTUserData::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCSTUserData@CDlgOptimizer@@@8
	DD	FLAT:??_R3CSTUserData@CDlgOptimizer@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CArray@UST_STRGRIDDATA@@U1@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CArray@UST_STRGRIDDATA@@U1@@@8 DD FLAT:??_R0?AV?$CArray@UST_STRGRIDDATA@@U1@@@@8 ; CArray<ST_STRGRIDDATA,ST_STRGRIDDATA>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CArray@UST_STRGRIDDATA@@U1@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CArray@UST_STRGRIDDATA@@U1@@@8
rdata$r	SEGMENT
??_R2?$CArray@UST_STRGRIDDATA@@U1@@@8 DD FLAT:??_R1A@?0A@EA@?$CArray@UST_STRGRIDDATA@@U1@@@8 ; CArray<ST_STRGRIDDATA,ST_STRGRIDDATA>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CObject@@8
rdata$r	ENDS
;	COMDAT ??_R3?$CArray@UST_STRGRIDDATA@@U1@@@8
rdata$r	SEGMENT
??_R3?$CArray@UST_STRGRIDDATA@@U1@@@8 DD 00H		; CArray<ST_STRGRIDDATA,ST_STRGRIDDATA>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$CArray@UST_STRGRIDDATA@@U1@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CArray@UST_STRGRIDDATA@@U1@@@@8
data$rs	SEGMENT
??_R0?AV?$CArray@UST_STRGRIDDATA@@U1@@@@8 DD FLAT:??_7type_info@@6B@ ; CArray<ST_STRGRIDDATA,ST_STRGRIDDATA> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CArray@UST_STRGRIDDATA@@U1@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CArray@UST_STRGRIDDATA@@U1@@@6B@
rdata$r	SEGMENT
??_R4?$CArray@UST_STRGRIDDATA@@U1@@@6B@ DD 00H		; CArray<ST_STRGRIDDATA,ST_STRGRIDDATA>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CArray@UST_STRGRIDDATA@@U1@@@@8
	DD	FLAT:??_R3?$CArray@UST_STRGRIDDATA@@U1@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CArray@UST_GRIDDATA@@U1@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CArray@UST_GRIDDATA@@U1@@@8 DD FLAT:??_R0?AV?$CArray@UST_GRIDDATA@@U1@@@@8 ; CArray<ST_GRIDDATA,ST_GRIDDATA>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CArray@UST_GRIDDATA@@U1@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CArray@UST_GRIDDATA@@U1@@@8
rdata$r	SEGMENT
??_R2?$CArray@UST_GRIDDATA@@U1@@@8 DD FLAT:??_R1A@?0A@EA@?$CArray@UST_GRIDDATA@@U1@@@8 ; CArray<ST_GRIDDATA,ST_GRIDDATA>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CObject@@8
rdata$r	ENDS
;	COMDAT ??_R3?$CArray@UST_GRIDDATA@@U1@@@8
rdata$r	SEGMENT
??_R3?$CArray@UST_GRIDDATA@@U1@@@8 DD 00H		; CArray<ST_GRIDDATA,ST_GRIDDATA>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$CArray@UST_GRIDDATA@@U1@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CArray@UST_GRIDDATA@@U1@@@@8
data$rs	SEGMENT
??_R0?AV?$CArray@UST_GRIDDATA@@U1@@@@8 DD FLAT:??_7type_info@@6B@ ; CArray<ST_GRIDDATA,ST_GRIDDATA> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CArray@UST_GRIDDATA@@U1@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CArray@UST_GRIDDATA@@U1@@@6B@
rdata$r	SEGMENT
??_R4?$CArray@UST_GRIDDATA@@U1@@@6B@ DD 00H		; CArray<ST_GRIDDATA,ST_GRIDDATA>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CArray@UST_GRIDDATA@@U1@@@@8
	DD	FLAT:??_R3?$CArray@UST_GRIDDATA@@U1@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CArray@UST_RUNVALUE@@U1@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CArray@UST_RUNVALUE@@U1@@@8 DD FLAT:??_R0?AV?$CArray@UST_RUNVALUE@@U1@@@@8 ; CArray<ST_RUNVALUE,ST_RUNVALUE>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CArray@UST_RUNVALUE@@U1@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CArray@UST_RUNVALUE@@U1@@@8
rdata$r	SEGMENT
??_R2?$CArray@UST_RUNVALUE@@U1@@@8 DD FLAT:??_R1A@?0A@EA@?$CArray@UST_RUNVALUE@@U1@@@8 ; CArray<ST_RUNVALUE,ST_RUNVALUE>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CObject@@8
rdata$r	ENDS
;	COMDAT ??_R3?$CArray@UST_RUNVALUE@@U1@@@8
rdata$r	SEGMENT
??_R3?$CArray@UST_RUNVALUE@@U1@@@8 DD 00H		; CArray<ST_RUNVALUE,ST_RUNVALUE>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$CArray@UST_RUNVALUE@@U1@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CArray@UST_RUNVALUE@@U1@@@@8
data$rs	SEGMENT
??_R0?AV?$CArray@UST_RUNVALUE@@U1@@@@8 DD FLAT:??_7type_info@@6B@ ; CArray<ST_RUNVALUE,ST_RUNVALUE> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CArray@UST_RUNVALUE@@U1@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CArray@UST_RUNVALUE@@U1@@@6B@
rdata$r	SEGMENT
??_R4?$CArray@UST_RUNVALUE@@U1@@@6B@ DD 00H		; CArray<ST_RUNVALUE,ST_RUNVALUE>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CArray@UST_RUNVALUE@@U1@@@@8
	DD	FLAT:??_R3?$CArray@UST_RUNVALUE@@U1@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CArray@PAUST_VALUE@@PAU1@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CArray@PAUST_VALUE@@PAU1@@@8 DD FLAT:??_R0?AV?$CArray@PAUST_VALUE@@PAU1@@@@8 ; CArray<ST_VALUE *,ST_VALUE *>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CArray@PAUST_VALUE@@PAU1@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CArray@PAUST_VALUE@@PAU1@@@8
rdata$r	SEGMENT
??_R2?$CArray@PAUST_VALUE@@PAU1@@@8 DD FLAT:??_R1A@?0A@EA@?$CArray@PAUST_VALUE@@PAU1@@@8 ; CArray<ST_VALUE *,ST_VALUE *>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CObject@@8
rdata$r	ENDS
;	COMDAT ??_R3?$CArray@PAUST_VALUE@@PAU1@@@8
rdata$r	SEGMENT
??_R3?$CArray@PAUST_VALUE@@PAU1@@@8 DD 00H		; CArray<ST_VALUE *,ST_VALUE *>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$CArray@PAUST_VALUE@@PAU1@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CArray@PAUST_VALUE@@PAU1@@@@8
data$rs	SEGMENT
??_R0?AV?$CArray@PAUST_VALUE@@PAU1@@@@8 DD FLAT:??_7type_info@@6B@ ; CArray<ST_VALUE *,ST_VALUE *> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CArray@PAUST_VALUE@@PAU1@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CArray@PAUST_VALUE@@PAU1@@@6B@
rdata$r	SEGMENT
??_R4?$CArray@PAUST_VALUE@@PAU1@@@6B@ DD 00H		; CArray<ST_VALUE *,ST_VALUE *>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CArray@PAUST_VALUE@@PAU1@@@@8
	DD	FLAT:??_R3?$CArray@PAUST_VALUE@@PAU1@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CArray@PAVCDialog@@PAV1@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CArray@PAVCDialog@@PAV1@@@8 DD FLAT:??_R0?AV?$CArray@PAVCDialog@@PAV1@@@@8 ; CArray<CDialog *,CDialog *>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CArray@PAVCDialog@@PAV1@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CArray@PAVCDialog@@PAV1@@@8
rdata$r	SEGMENT
??_R2?$CArray@PAVCDialog@@PAV1@@@8 DD FLAT:??_R1A@?0A@EA@?$CArray@PAVCDialog@@PAV1@@@8 ; CArray<CDialog *,CDialog *>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CObject@@8
rdata$r	ENDS
;	COMDAT ??_R3?$CArray@PAVCDialog@@PAV1@@@8
rdata$r	SEGMENT
??_R3?$CArray@PAVCDialog@@PAV1@@@8 DD 00H		; CArray<CDialog *,CDialog *>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$CArray@PAVCDialog@@PAV1@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CArray@PAVCDialog@@PAV1@@@@8
data$rs	SEGMENT
??_R0?AV?$CArray@PAVCDialog@@PAV1@@@@8 DD FLAT:??_7type_info@@6B@ ; CArray<CDialog *,CDialog *> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CArray@PAVCDialog@@PAV1@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CArray@PAVCDialog@@PAV1@@@6B@
rdata$r	SEGMENT
??_R4?$CArray@PAVCDialog@@PAV1@@@6B@ DD 00H		; CArray<CDialog *,CDialog *>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CArray@PAVCDialog@@PAV1@@@@8
	DD	FLAT:??_R3?$CArray@PAVCDialog@@PAV1@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CArray@UST_VALUEOPTIMAZE@@U1@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CArray@UST_VALUEOPTIMAZE@@U1@@@8 DD FLAT:??_R0?AV?$CArray@UST_VALUEOPTIMAZE@@U1@@@@8 ; CArray<ST_VALUEOPTIMAZE,ST_VALUEOPTIMAZE>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CArray@UST_VALUEOPTIMAZE@@U1@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CArray@UST_VALUEOPTIMAZE@@U1@@@8
rdata$r	SEGMENT
??_R2?$CArray@UST_VALUEOPTIMAZE@@U1@@@8 DD FLAT:??_R1A@?0A@EA@?$CArray@UST_VALUEOPTIMAZE@@U1@@@8 ; CArray<ST_VALUEOPTIMAZE,ST_VALUEOPTIMAZE>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CObject@@8
rdata$r	ENDS
;	COMDAT ??_R3?$CArray@UST_VALUEOPTIMAZE@@U1@@@8
rdata$r	SEGMENT
??_R3?$CArray@UST_VALUEOPTIMAZE@@U1@@@8 DD 00H		; CArray<ST_VALUEOPTIMAZE,ST_VALUEOPTIMAZE>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$CArray@UST_VALUEOPTIMAZE@@U1@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CArray@UST_VALUEOPTIMAZE@@U1@@@@8
data$rs	SEGMENT
??_R0?AV?$CArray@UST_VALUEOPTIMAZE@@U1@@@@8 DD FLAT:??_7type_info@@6B@ ; CArray<ST_VALUEOPTIMAZE,ST_VALUEOPTIMAZE> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CArray@UST_VALUEOPTIMAZE@@U1@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CArray@UST_VALUEOPTIMAZE@@U1@@@6B@
rdata$r	SEGMENT
??_R4?$CArray@UST_VALUEOPTIMAZE@@U1@@@6B@ DD 00H	; CArray<ST_VALUEOPTIMAZE,ST_VALUEOPTIMAZE>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CArray@UST_VALUEOPTIMAZE@@U1@@@@8
	DD	FLAT:??_R3?$CArray@UST_VALUEOPTIMAZE@@U1@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ISTUserData@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ISTUserData@@8 DD FLAT:??_R0?AUISTUserData@@@8 ; ISTUserData::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ISTUserData@@8
rdata$r	ENDS
;	COMDAT ??_R2ISTUserData@@8
rdata$r	SEGMENT
??_R2ISTUserData@@8 DD FLAT:??_R1A@?0A@EA@ISTUserData@@8 ; ISTUserData::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3ISTUserData@@8
rdata$r	SEGMENT
??_R3ISTUserData@@8 DD 00H				; ISTUserData::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2ISTUserData@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUISTUserData@@@8
data$rs	SEGMENT
??_R0?AUISTUserData@@@8 DD FLAT:??_7type_info@@6B@	; ISTUserData `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUISTUserData@@', 00H
data$rs	ENDS
;	COMDAT ??_R4ISTUserData@@6B@
rdata$r	SEGMENT
??_R4ISTUserData@@6B@ DD 00H				; ISTUserData::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AUISTUserData@@@8
	DD	FLAT:??_R3ISTUserData@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CList@PAUSTMNG_ITEMINFO@@PAU1@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CList@PAUSTMNG_ITEMINFO@@PAU1@@@8 DD FLAT:??_R0?AV?$CList@PAUSTMNG_ITEMINFO@@PAU1@@@@8 ; CList<STMNG_ITEMINFO *,STMNG_ITEMINFO *>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CList@PAUSTMNG_ITEMINFO@@PAU1@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CList@PAUSTMNG_ITEMINFO@@PAU1@@@8
rdata$r	SEGMENT
??_R2?$CList@PAUSTMNG_ITEMINFO@@PAU1@@@8 DD FLAT:??_R1A@?0A@EA@?$CList@PAUSTMNG_ITEMINFO@@PAU1@@@8 ; CList<STMNG_ITEMINFO *,STMNG_ITEMINFO *>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CObject@@8
rdata$r	ENDS
;	COMDAT ??_R3?$CList@PAUSTMNG_ITEMINFO@@PAU1@@@8
rdata$r	SEGMENT
??_R3?$CList@PAUSTMNG_ITEMINFO@@PAU1@@@8 DD 00H		; CList<STMNG_ITEMINFO *,STMNG_ITEMINFO *>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$CList@PAUSTMNG_ITEMINFO@@PAU1@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CList@PAUSTMNG_ITEMINFO@@PAU1@@@@8
data$rs	SEGMENT
??_R0?AV?$CList@PAUSTMNG_ITEMINFO@@PAU1@@@@8 DD FLAT:??_7type_info@@6B@ ; CList<STMNG_ITEMINFO *,STMNG_ITEMINFO *> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CList@PAUSTMNG_ITEMINFO@@PAU1@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CList@PAUSTMNG_ITEMINFO@@PAU1@@@6B@
rdata$r	SEGMENT
??_R4?$CList@PAUSTMNG_ITEMINFO@@PAU1@@@6B@ DD 00H	; CList<STMNG_ITEMINFO *,STMNG_ITEMINFO *>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CList@PAUSTMNG_ITEMINFO@@PAU1@@@@8
	DD	FLAT:??_R3?$CList@PAUSTMNG_ITEMINFO@@PAU1@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CDlgOptimizer@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CDlgOptimizer@@8 DD FLAT:??_R0?AVCDlgOptimizer@@@8 ; CDlgOptimizer::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	05H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CDlgOptimizer@@8
rdata$r	ENDS
;	COMDAT ??_R2CDlgOptimizer@@8
rdata$r	SEGMENT
??_R2CDlgOptimizer@@8 DD FLAT:??_R1A@?0A@EA@CDlgOptimizer@@8 ; CDlgOptimizer::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CEscDialog@@8
	DD	FLAT:??_R1A@?0A@EA@CDialog@@8
	DD	FLAT:??_R1A@?0A@EA@CWnd@@8
	DD	FLAT:??_R1A@?0A@EA@CCmdTarget@@8
	DD	FLAT:??_R1A@?0A@EA@CObject@@8
rdata$r	ENDS
;	COMDAT ??_R3CDlgOptimizer@@8
rdata$r	SEGMENT
??_R3CDlgOptimizer@@8 DD 00H				; CDlgOptimizer::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	06H
	DD	FLAT:??_R2CDlgOptimizer@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCDlgOptimizer@@@8
data$rs	SEGMENT
??_R0?AVCDlgOptimizer@@@8 DD FLAT:??_7type_info@@6B@	; CDlgOptimizer `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCDlgOptimizer@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CDlgOptimizer@@6B@
rdata$r	SEGMENT
??_R4CDlgOptimizer@@6B@ DD 00H				; CDlgOptimizer::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCDlgOptimizer@@@8
	DD	FLAT:??_R3CDlgOptimizer@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CArray@NN@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CArray@NN@@8 DD FLAT:??_R0?AV?$CArray@NN@@@8 ; CArray<double,double>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CArray@NN@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CArray@NN@@8
rdata$r	SEGMENT
??_R2?$CArray@NN@@8 DD FLAT:??_R1A@?0A@EA@?$CArray@NN@@8 ; CArray<double,double>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CObject@@8
rdata$r	ENDS
;	COMDAT ??_R3?$CArray@NN@@8
rdata$r	SEGMENT
??_R3?$CArray@NN@@8 DD 00H				; CArray<double,double>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$CArray@NN@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CArray@NN@@@8
data$rs	SEGMENT
??_R0?AV?$CArray@NN@@@8 DD FLAT:??_7type_info@@6B@	; CArray<double,double> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CArray@NN@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CArray@NN@@6B@
rdata$r	SEGMENT
??_R4?$CArray@NN@@6B@ DD 00H				; CArray<double,double>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CArray@NN@@@8
	DD	FLAT:??_R3?$CArray@NN@@8
rdata$r	ENDS
;	COMDAT ??_C@_04NGCIOFKF@?$LA?m?$LB?$NO@
CONST	SEGMENT
??_C@_04NGCIOFKF@?$LA?m?$LB?$NO@ DB 0b0H, 0edH, 0b1H, 0deH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04FFLPOIDN@?C?J?$LB?$NO@
CONST	SEGMENT
??_C@_04FFLPOIDN@?C?J?$LB?$NO@ DB 0c3H, 0caH, 0b1H, 0deH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@CPKKMKKO@SCW_DeleteInterfaceOfStrategy@
CONST	SEGMENT
??_C@_0BO@CPKKMKKO@SCW_DeleteInterfaceOfStrategy@ DB 'SCW_DeleteInterface'
	DB	'OfStrategy', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@JOCOAICG@?$LK?$KP?$LM?v?5?C?V?$MA?$PL?H?$KN?$LP?$KB?$LM?$KN?5?$LL?g?$LP?k?G?R?5?$LM?v?5?$LO?x?$LE?B?5@
CONST	SEGMENT
??_C@_0CL@JOCOAICG@?$LK?$KP?$LM?v?5?C?V?$MA?$PL?H?$KN?$LP?$KB?$LM?$KN?5?$LL?g?$LP?k?G?R?5?$LM?v?5?$LO?x?$LE?B?5@ DB 0baH
	DB	0afH, 0bcH, 0f6H, ' ', 0c3H, 0d6H, 0c0H, 0fbH, 0c8H, 0adH, 0bfH
	DB	0a1H, 0bcH, 0adH, ' ', 0bbH, 0e7H, 0bfH, 0ebH, 0c7H, 0d2H, ' ', 0bcH
	DB	0f6H, ' ', 0beH, 0f8H, 0b4H, 0c2H, ' ', 0c0H, 0fcH, 0b7H, 0abH
	DB	0c0H, 0d4H, 0b4H, 0cfH, 0b4H, 0d9H, '.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@EOEHIOGI@?2Icss?2STData?2VarOptima?4cfg@
CONST	SEGMENT
??_C@_0BL@EOEHIOGI@?2Icss?2STData?2VarOptima?4cfg@ DB '\Icss\STData\VarOp'
	DB	'tima.cfg', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@NADBMJJJ@?C?V?$MA?$PL?H?$KN?$LA?$KB?5?$MA?$NP?$LI?x?5?$LM?$LB?E?C?$LF?G?$LO?z?$LN?$MA?$LE?O?$LE?Y?4@
CONST	SEGMENT
??_C@_0BO@NADBMJJJ@?C?V?$MA?$PL?H?$KN?$LA?$KB?5?$MA?$NP?$LI?x?5?$LM?$LB?E?C?$LF?G?$LO?z?$LN?$MA?$LE?O?$LE?Y?4@ DB 0c3H
	DB	0d6H, 0c0H, 0fbH, 0c8H, 0adH, 0b0H, 0a1H, ' ', 0c0H, 0dfH, 0b8H
	DB	0f8H, ' ', 0bcH, 0b1H, 0c5H, 0c3H, 0b5H, 0c7H, 0beH, 0faH, 0bdH
	DB	0c0H, 0b4H, 0cfH, 0b4H, 0d9H, '.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01BMBHCPLG@5@
CONST	SEGMENT
??_C@_01BMBHCPLG@5@ DB '5', 00H				; `string'
CONST	ENDS
;	COMDAT ??_7?$CList@PAUSTMNG_ITEMINFO@@PAU1@@@6B@
CONST	SEGMENT
??_7?$CList@PAUSTMNG_ITEMINFO@@PAU1@@@6B@ DD FLAT:??_R4?$CList@PAUSTMNG_ITEMINFO@@PAU1@@@6B@ ; CList<STMNG_ITEMINFO *,STMNG_ITEMINFO *>::`vftable'
	DD	FLAT:?GetRuntimeClass@CObject@@UBEPAUCRuntimeClass@@XZ
	DD	FLAT:??_E?$CList@PAUSTMNG_ITEMINFO@@PAU1@@@UAEPAXI@Z
	DD	FLAT:?Serialize@?$CList@PAUSTMNG_ITEMINFO@@PAU1@@@UAEXAAVCArchive@@@Z
	DD	FLAT:?AssertValid@CObject@@UBEXXZ
	DD	FLAT:?Dump@CObject@@UBEXAAVCDumpContext@@@Z
CONST	ENDS
;	COMDAT ??_C@_04GEFJINEE@?$CF?42f@
CONST	SEGMENT
??_C@_04GEFJINEE@?$CF?42f@ DB '%.2f', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@CNGHBHNE@?$CFs?$CFd?$DN?$CF?42f?0@
CONST	SEGMENT
??_C@_0L@CNGHBHNE@?$CFs?$CFd?$DN?$CF?42f?0@ DB '%s%d=%.2f,', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05DCDOHKAB@Input@
CONST	SEGMENT
??_C@_05DCDOHKAB@Input@ DB 'Input', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@FCBICJNP@1000?5?$MA?L?$LL?s?$MA?G?5?$LA?$KK?$MA?$LK?5?$LL?g?$LP?k?G?R?5?$LM?v?5?$LO?x?$LN?$MA@
CONST	SEGMENT
??_C@_0DI@FCBICJNP@1000?5?$MA?L?$LL?s?$MA?G?5?$LA?$KK?$MA?$LK?5?$LL?g?$LP?k?G?R?5?$LM?v?5?$LO?x?$LN?$MA@ DB '1'
	DB	'000 ', 0c0H, 0ccH, 0bbH, 0f3H, 0c0H, 0c7H, ' ', 0b0H, 0aaH, 0c0H
	DB	0baH, ' ', 0bbH, 0e7H, 0bfH, 0ebH, 0c7H, 0d2H, ' ', 0bcH, 0f6H
	DB	' ', 0beH, 0f8H, 0bdH, 0c0H, 0b4H, 0cfH, 0b4H, 0d9H, '. ', 0b4H
	DB	0d9H, 0bdH, 0c3H, ' ', 0c0H, 0d4H, 0b7H, 0c2H, 0b9H, 0d9H, 0b6H
	DB	0f8H, 0b4H, 0cfH, 0b4H, 0d9H, '.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@KKHNOAOO@?$LK?$MA?5?$MA?T?$LH?B?$LA?$KK?$MA?L?5?$MA?$NP?$LI?x?5?$LM?$LD?A?$KE?$LF?G?$LO?z?$LN?$MA?$LE?O?$LE?Y@
CONST	SEGMENT
??_C@_0DF@KKHNOAOO@?$LK?$MA?5?$MA?T?$LH?B?$LA?$KK?$MA?L?5?$MA?$NP?$LI?x?5?$LM?$LD?A?$KE?$LF?G?$LO?z?$LN?$MA?$LE?O?$LE?Y@ DB 0baH
	DB	0c0H, ' ', 0c0H, 0d4H, 0b7H, 0c2H, 0b0H, 0aaH, 0c0H, 0ccH, ' ', 0c0H
	DB	0dfH, 0b8H, 0f8H, ' ', 0bcH, 0b3H, 0c1H, 0a4H, 0b5H, 0c7H, 0beH
	DB	0faH, 0bdH, 0c0H, 0b4H, 0cfH, 0b4H, 0d9H, '. ', 0b4H, 0d9H, 0bdH
	DB	0c3H, ' ', 0bcH, 0b3H, 0c1H, 0a4H, 0c7H, 0d8H, 0c1H, 0d6H, 0bdH
	DB	0caH, 0bdH, 0c3H, 0bfH, 0c0H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@ILIJGNAL@Usr?2STDATA?2SD@
CONST	SEGMENT
??_C@_0O@ILIJGNAL@Usr?2STDATA?2SD@ DB 'Usr\STDATA\SD', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@PJNJDIFE@Icss?2STDATA?2SD@
CONST	SEGMENT
??_C@_0P@PJNJDIFE@Icss?2STDATA?2SD@ DB 'Icss\STDATA\SD', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03IDLCJCBF@?4st@
CONST	SEGMENT
??_C@_03IDLCJCBF@?4st@ DB '.st', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@IMFLIICM@?$MA?$PM?$LH?$KL?$MA?L?5?$LI?$KO?$LN?$LK?F?$KO?$LP?$KB?5?$LO?x?$LN?$MA?$LE?O?$LE?Y?4@
CONST	SEGMENT
??_C@_0BK@IMFLIICM@?$MA?$PM?$LH?$KL?$MA?L?5?$LI?$KO?$LN?$LK?F?$KO?$LP?$KB?5?$LO?x?$LN?$MA?$LE?O?$LE?Y?4@ DB 0c0H
	DB	0fcH, 0b7H, 0abH, 0c0H, 0ccH, ' ', 0b8H, 0aeH, 0bdH, 0baH, 0c6H
	DB	0aeH, 0bfH, 0a1H, ' ', 0beH, 0f8H, 0bdH, 0c0H, 0b4H, 0cfH, 0b4H
	DB	0d9H, '.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@HEBKHCBM@?$LM?U?$MA?M?$LK?P?F?w?B?w?F?$KO@
CONST	SEGMENT
??_C@_0N@HEBKHCBM@?$LM?U?$MA?M?$LK?P?F?w?B?w?F?$KO@ DB 0bcH, 0d5H, 0c0H, 0cdH
	DB	0baH, 0d0H, 0c6H, 0f7H, 0c2H, 0f7H, 0c6H, 0aeH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@CPJPEJFL@?$LM?v?$MA?M?$LH?$PM?B?w?F?$KO@
CONST	SEGMENT
??_C@_0L@CPJPEJFL@?$LM?v?$MA?M?$LH?$PM?B?w?F?$KO@ DB 0bcH, 0f6H, 0c0H, 0cdH
	DB	0b7H, 0fcH, 0c2H, 0f7H, 0c6H, 0aeH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08INENBIFG@?$LI?E?$LI?E?$LD?$LL?$LP?$KK@
CONST	SEGMENT
??_C@_08INENBIFG@?$LI?E?$LI?E?$LD?$LL?$LP?$KK@ DB 0b8H, 0c5H, 0b8H, 0c5H, 0b3H
	DB	0bbH, 0bfH, 0aaH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08OEAPFIFH@?$LM?$LK?$LA?z?$LK?P?$LM?$KO@
CONST	SEGMENT
??_C@_08OEAPFIFH@?$LM?$LK?$LA?z?$LK?P?$LM?$KO@ DB 0bcH, 0baH, 0b0H, 0faH, 0baH
	DB	0d0H, 0bcH, 0aeH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NNCCFHAL@?2IOTrade?4htm@
CONST	SEGMENT
??_C@_0N@NNCCFHAL@?2IOTrade?4htm@ DB '\IOTrade.htm', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@MFEGIDEI@?2IndexOptimizer?4htm@
CONST	SEGMENT
??_C@_0BE@MFEGIDEI@?2IndexOptimizer?4htm@ DB '\IndexOptimizer.htm', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07BMIBILFB@?2STData@
CONST	SEGMENT
??_C@_07BMIBILFB@?2STData@ DB '\STData', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02DINIKGF@?$LK?$MA@
CONST	SEGMENT
??_C@_02DINIKGF@?$LK?$MA@ DB 0baH, 0c0H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06MKCPLBEP@?A?v?G?$KF?$LI?m@
CONST	SEGMENT
??_C@_06MKCPLBEP@?A?v?G?$KF?$LI?m@ DB 0c1H, 0f6H, 0c7H, 0a5H, 0b8H, 0edH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04BPIEHLPP@?$LA?E?$LH?$KB@
CONST	SEGMENT
??_C@_04BPIEHLPP@?$LA?E?$LH?$KB@ DB 0b0H, 0c5H, 0b7H, 0a1H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04HFNGKEOO@?$LN?B?$LH?$PM@
CONST	SEGMENT
??_C@_04HFNGKEOO@?$LN?B?$LH?$PM@ DB 0bdH, 0c2H, 0b7H, 0fcH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@HGEBBOLI@ProfitFactor@
CONST	SEGMENT
??_C@_0N@HGEBBOLI@ProfitFactor@ DB 'ProfitFactor', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06FDKHGHHF@?$LM?v?$MA?M?$LH?$PM@
CONST	SEGMENT
??_C@_06FDKHGHHF@?$LM?v?$MA?M?$LH?$PM@ DB 0bcH, 0f6H, 0c0H, 0cdH, 0b7H, 0fcH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_08HNPHKLMB@?C?V?$LE?k?$LM?U?$LN?G@
CONST	SEGMENT
??_C@_08HNPHKLMB@?C?V?$LE?k?$LM?U?$LN?G@ DB 0c3H, 0d6H, 0b4H, 0ebH, 0bcH, 0d5H
	DB	0bdH, 0c7H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_08MKACKNJD@?C?V?$LE?k?$MA?L?$MA?M@
CONST	SEGMENT
??_C@_08MKACKNJD@?C?V?$LE?k?$MA?L?$MA?M@ DB 0c3H, 0d6H, 0b4H, 0ebH, 0c0H, 0ccH
	DB	0c0H, 0cdH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_06MLIEOKGJ@?C?Q?$LM?U?$LN?G@
CONST	SEGMENT
??_C@_06MLIEOKGJ@?C?Q?$LM?U?$LN?G@ DB 0c3H, 0d1H, 0bcH, 0d5H, 0bdH, 0c7H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06HMHBOMDL@?C?Q?$MA?L?$MA?M@
CONST	SEGMENT
??_C@_06HMHBOMDL@?C?Q?$MA?L?$MA?M@ DB 0c3H, 0d1H, 0c0H, 0ccH, 0c0H, 0cdH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08IANCNINB@?F?r?$LB?U?$LM?U?$MA?M@
CONST	SEGMENT
??_C@_08IANCNINB@?F?r?$LB?U?$LM?U?$MA?M@ DB 0c6H, 0f2H, 0b1H, 0d5H, 0bcH, 0d5H
	DB	0c0H, 0cdH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_06GNECPJOA@?C?Q?$LM?U?$MA?M@
CONST	SEGMENT
??_C@_06GNECPJOA@?C?Q?$LM?U?$MA?M@ DB 0c3H, 0d1H, 0bcH, 0d5H, 0c0H, 0cdH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06NEMOAOGB@?$MA?$PM?$LH?$KL?$LI?m@
CONST	SEGMENT
??_C@_06NEMOAOGB@?$MA?$PM?$LH?$KL?$LI?m@ DB 0c0H, 0fcH, 0b7H, 0abH, 0b8H, 0edH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_03JMEKIEOG@Row@
CONST	SEGMENT
??_C@_03JMEKIEOG@Row@ DB 'Row', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01KICIPPFI@?2@
CONST	SEGMENT
??_C@_01KICIPPFI@?2@ DB '\', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09ONDJILNJ@STDATA?2ST@
CONST	SEGMENT
??_C@_09ONDJILNJ@STDATA?2ST@ DB 'STDATA\ST', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@OHKGLIGI@SCW_GetInterfaceOfStrategy@
CONST	SEGMENT
??_C@_0BL@OHKGLIGI@SCW_GetInterfaceOfStrategy@ DB 'SCW_GetInterfaceOfStra'
	DB	'tegy', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@DLDLABLN@HWStrategyConfigureWizard?4dll@
CONST	SEGMENT
??_C@_0BO@DLDLABLN@HWStrategyConfigureWizard?4dll@ DB 'HWStrategyConfigur'
	DB	'eWizard.dll', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@CNEELEMP@SCW_IGfxOutBarCtrl@
CONST	SEGMENT
??_C@_0BD@CNEELEMP@SCW_IGfxOutBarCtrl@ DB 'SCW_IGfxOutBarCtrl', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@OCOIJGGE@?$CFs?2outbar_icon?4bmp@
CONST	SEGMENT
??_C@_0BD@OCOIJGGE@?$CFs?2outbar_icon?4bmp@ DB '%s\outbar_icon.bmp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DADNAINN@?$CFs?2folder?4bmp@
CONST	SEGMENT
??_C@_0O@DADNAINN@?$CFs?2folder?4bmp@ DB '%s\folder.bmp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08BKFIOHKC@?2drchart@
CONST	SEGMENT
??_C@_08BKFIOHKC@?2drchart@ DB '\drchart', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06MFMMLLPC@?$LB?$LM?$LI?$LC?C?$LM@
CONST	SEGMENT
??_C@_06MFMMLLPC@?$LB?$LM?$LI?$LC?C?$LM@ DB 0b1H, 0bcH, 0b8H, 0b2H, 0c3H, 0bcH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ?messageMap@?1??GetThisMessageMap@CDlgOptimizer@@KGPBUAFX_MSGMAP@@XZ@4U3@B
CONST	SEGMENT
?messageMap@?1??GetThisMessageMap@CDlgOptimizer@@KGPBUAFX_MSGMAP@@XZ@4U3@B DD FLAT:?GetThisMessageMap@CDialog@@KGPBUAFX_MSGMAP@@XZ ; `CDlgOptimizer::GetThisMessageMap'::`2'::messageMap
	DD	FLAT:?_messageEntries@?1??GetThisMessageMap@CDlgOptimizer@@KGPBUAFX_MSGMAP@@XZ@4QBUAFX_MSGMAP_ENTRY@@B
CONST	ENDS
;	COMDAT ?_messageEntries@?1??GetThisMessageMap@CDlgOptimizer@@KGPBUAFX_MSGMAP@@XZ@4QBUAFX_MSGMAP_ENTRY@@B
CONST	SEGMENT
?_messageEntries@?1??GetThisMessageMap@CDlgOptimizer@@KGPBUAFX_MSGMAP@@XZ@4QBUAFX_MSGMAP_ENTRY@@B DD 019H ; `CDlgOptimizer::GetThisMessageMap'::`2'::_messageEntries
	DD	00H
	DD	00H
	DD	00H
	DD	08H
	DD	FLAT:?OnCtlColor@CDlgOptimizer@@IAEPAUHBRUSH__@@PAVCDC@@PAVCWnd@@I@Z
	DD	02H
	DD	00H
	DD	00H
	DD	00H
	DD	013H
	DD	FLAT:?OnDestroy@CDlgOptimizer@@IAEXXZ
	DD	0111H
	DD	00H
	DD	03307H
	DD	03307H
	DD	03aH
	DD	FLAT:?OnBtnOpt@CDlgOptimizer@@IAEXXZ
	DD	0113H
	DD	00H
	DD	00H
	DD	00H
	DD	015H
	DD	FLAT:?OnTimer@CDlgOptimizer@@IAEXI@Z
	DD	0111H
	DD	00H
	DD	03358H
	DD	03358H
	DD	03aH
	DD	FLAT:?OnBtnStop@CDlgOptimizer@@IAEXXZ
	DD	0c000H
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:?RMSG_STDATAMANAGER_RESULTDATA@@3IB
	DD	FLAT:?OnSTDataManagerMessagge@CDlgOptimizer@@IAEJIJ@Z
	DD	0111H
	DD	00H
	DD	032ebH
	DD	032ebH
	DD	03aH
	DD	FLAT:?OnBnClickedBtnAddall@CDlgOptimizer@@QAEXXZ
	DD	0111H
	DD	00H
	DD	03305H
	DD	03305H
	DD	03aH
	DD	FLAT:?OnBnClickedBtnAddone@CDlgOptimizer@@QAEXXZ
	DD	0111H
	DD	00H
	DD	0335cH
	DD	0335cH
	DD	03aH
	DD	FLAT:?OnBnClickedBtnDelall@CDlgOptimizer@@QAEXXZ
	DD	0111H
	DD	00H
	DD	0335dH
	DD	0335dH
	DD	03aH
	DD	FLAT:?OnBnClickedBtnDelone@CDlgOptimizer@@QAEXXZ
	DD	0c000H
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:?RMSG_OB_ITEMDBLCLK@@3IB
	DD	FLAT:?OnRmsgObItemDBClk@CDlgOptimizer@@IAEJIJ@Z
	DD	0c000H
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:?RMSG_GETDLLSIZE@@3IB
	DD	FLAT:?OnRmsgGetDllSize@CDlgOptimizer@@IAEJIJ@Z
	DD	0111H
	DD	02H
	DD	0335eH
	DD	0335eH
	DD	03aH
	DD	FLAT:?OnLbnDblclkListSt@CDlgOptimizer@@QAEXXZ
	DD	0c000H
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:?RMSG_STTREE_ITEMDBLCLK@@3IB
	DD	FLAT:?OnRmsgSTTreeItemDBClk@CDlgOptimizer@@QAEJIJ@Z
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT ??_C@_02NNHDHLCM@?$MA?O@
CONST	SEGMENT
??_C@_02NNHDHLCM@?$MA?O@ DB 0c0H, 0cfH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_7CDlgOptimizer@@6B@
CONST	SEGMENT
??_7CDlgOptimizer@@6B@ DD FLAT:??_R4CDlgOptimizer@@6B@	; CDlgOptimizer::`vftable'
	DD	FLAT:?GetRuntimeClass@CDialog@@UBEPAUCRuntimeClass@@XZ
	DD	FLAT:??_ECDlgOptimizer@@UAEPAXI@Z
	DD	FLAT:?Serialize@CObject@@UAEXAAVCArchive@@@Z
	DD	FLAT:?AssertValid@CObject@@UBEXXZ
	DD	FLAT:?Dump@CObject@@UBEXAAVCDumpContext@@@Z
	DD	FLAT:?OnCmdMsg@CDialog@@UAEHIHPAXPAUAFX_CMDHANDLERINFO@@@Z
	DD	FLAT:?OnFinalRelease@CWnd@@UAEXXZ
	DD	FLAT:?IsInvokeAllowed@CCmdTarget@@UAEHJ@Z
	DD	FLAT:?GetDispatchIID@CCmdTarget@@UAEHPAU_GUID@@@Z
	DD	FLAT:?GetTypeInfoCount@CCmdTarget@@UAEIXZ
	DD	FLAT:?GetTypeLibCache@CCmdTarget@@UAEPAVCTypeLibCache@@XZ
	DD	FLAT:?GetTypeLib@CCmdTarget@@UAEJKPAPAUITypeLib@@@Z
	DD	FLAT:?GetMessageMap@CDlgOptimizer@@MBEPBUAFX_MSGMAP@@XZ
	DD	FLAT:?GetCommandMap@CCmdTarget@@MBEPBUAFX_OLECMDMAP@@XZ
	DD	FLAT:?GetDispatchMap@CCmdTarget@@MBEPBUAFX_DISPMAP@@XZ
	DD	FLAT:?GetConnectionMap@CCmdTarget@@MBEPBUAFX_CONNECTIONMAP@@XZ
	DD	FLAT:?GetInterfaceMap@CWnd@@MBEPBUAFX_INTERFACEMAP@@XZ
	DD	FLAT:?GetEventSinkMap@CCmdTarget@@MBEPBUAFX_EVENTSINKMAP@@XZ
	DD	FLAT:?OnCreateAggregates@CCmdTarget@@UAEHXZ
	DD	FLAT:?GetInterfaceHook@CCmdTarget@@UAEPAUIUnknown@@PBX@Z
	DD	FLAT:?GetExtraConnectionPoints@CCmdTarget@@MAEHPAVCPtrArray@@@Z
	DD	FLAT:?GetConnectionHook@CCmdTarget@@MAEPAUIConnectionPoint@@ABU_GUID@@@Z
	DD	FLAT:?PreSubclassWindow@CWnd@@UAEXXZ
	DD	FLAT:?Create@CWnd@@UAEHPBD0KABUtagRECT@@PAV1@IPAUCCreateContext@@@Z
	DD	FLAT:?CreateEx@CWnd@@UAEHKPBD0KABUtagRECT@@PAV1@IPAX@Z
	DD	FLAT:?CreateEx@CWnd@@UAEHKPBD0KHHHHPAUHWND__@@PAUHMENU__@@PAX@Z
	DD	FLAT:?DestroyWindow@CWnd@@UAEHXZ
	DD	FLAT:?PreCreateWindow@CWnd@@UAEHAAUtagCREATESTRUCTA@@@Z
	DD	FLAT:?CalcWindowRect@CWnd@@UAEXPAUtagRECT@@I@Z
	DD	FLAT:?GetMenu@CWnd@@UBEPAVCMenu@@XZ
	DD	FLAT:?SetMenu@CWnd@@UAEHPAVCMenu@@@Z
	DD	FLAT:?OnToolHitTest@CWnd@@UBEHVCPoint@@PAUtagTOOLINFOA@@@Z
	DD	FLAT:?GetScrollBarCtrl@CWnd@@UBEPAVCScrollBar@@H@Z
	DD	FLAT:?WinHelpA@CWnd@@UAEXKI@Z
	DD	FLAT:?HtmlHelpA@CWnd@@UAEXKI@Z
	DD	FLAT:?WinHelpInternal@CWnd@@UAEXKI@Z
	DD	FLAT:?ContinueModal@CWnd@@UAEHXZ
	DD	FLAT:?EndModalLoop@CWnd@@UAEXH@Z
	DD	FLAT:?OnDrawIconicThumbnailOrLivePreview@CWnd@@UAEXAAVCDC@@VCRect@@VCSize@@HAAH@Z
	DD	FLAT:?EnsureStdObj@CWnd@@UAEJXZ
	DD	FLAT:?get_accParent@CWnd@@UAEJPAPAUIDispatch@@@Z
	DD	FLAT:?get_accChildCount@CWnd@@UAEJPAJ@Z
	DD	FLAT:?get_accChild@CWnd@@UAEJUtagVARIANT@@PAPAUIDispatch@@@Z
	DD	FLAT:?get_accName@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z
	DD	FLAT:?get_accValue@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z
	DD	FLAT:?get_accDescription@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z
	DD	FLAT:?get_accRole@CWnd@@UAEJUtagVARIANT@@PAU2@@Z
	DD	FLAT:?get_accState@CWnd@@UAEJUtagVARIANT@@PAU2@@Z
	DD	FLAT:?get_accHelp@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z
	DD	FLAT:?get_accHelpTopic@CWnd@@UAEJPAPA_WUtagVARIANT@@PAJ@Z
	DD	FLAT:?get_accKeyboardShortcut@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z
	DD	FLAT:?get_accFocus@CWnd@@UAEJPAUtagVARIANT@@@Z
	DD	FLAT:?get_accSelection@CWnd@@UAEJPAUtagVARIANT@@@Z
	DD	FLAT:?get_accDefaultAction@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z
	DD	FLAT:?accSelect@CWnd@@UAEJJUtagVARIANT@@@Z
	DD	FLAT:?accLocation@CWnd@@UAEJPAJ000UtagVARIANT@@@Z
	DD	FLAT:?accNavigate@CWnd@@UAEJJUtagVARIANT@@PAU2@@Z
	DD	FLAT:?accHitTest@CWnd@@UAEJJJPAUtagVARIANT@@@Z
	DD	FLAT:?accDoDefaultAction@CWnd@@UAEJUtagVARIANT@@@Z
	DD	FLAT:?put_accName@CWnd@@UAEJUtagVARIANT@@PA_W@Z
	DD	FLAT:?put_accValue@CWnd@@UAEJUtagVARIANT@@PA_W@Z
	DD	FLAT:?SetProxy@CWnd@@UAEJPAUIAccessibleProxy@@@Z
	DD	FLAT:?CreateAccessibleProxy@CWnd@@UAEJIJPAJ@Z
	DD	FLAT:?OnCommand@CWnd@@MAEHIJ@Z
	DD	FLAT:?OnNotify@CDlgOptimizer@@MAEHIJPAJ@Z
	DD	FLAT:?GetSuperWndProcAddr@CWnd@@MAEPAP6GJPAUHWND__@@IIJ@ZXZ
	DD	FLAT:?DoDataExchange@CDlgOptimizer@@MAEXPAVCDataExchange@@@Z
	DD	FLAT:?BeginModalState@CWnd@@UAEXXZ
	DD	FLAT:?EndModalState@CWnd@@UAEXXZ
	DD	FLAT:?PreTranslateMessage@CEscDialog@@MAEHPAUtagMSG@@@Z
	DD	FLAT:?OnAmbientProperty@CWnd@@UAEHPAVCOleControlSite@@JPAUtagVARIANT@@@Z
	DD	FLAT:?WindowProc@CDlgOptimizer@@MAEJIIJ@Z
	DD	FLAT:?OnWndMsg@CWnd@@MAEHIIJPAJ@Z
	DD	FLAT:?DefWindowProcA@CWnd@@MAEJIIJ@Z
	DD	FLAT:?PostNcDestroy@CWnd@@MAEXXZ
	DD	FLAT:?OnChildNotify@CWnd@@MAEHIIJPAJ@Z
	DD	FLAT:?OnTouchInputs@CWnd@@MAEHIPAUtagTOUCHINPUT@@@Z
	DD	FLAT:?OnTouchInput@CWnd@@MAEHVCPoint@@HHPAUtagTOUCHINPUT@@@Z
	DD	FLAT:?GetGestureStatus@CWnd@@MAEKVCPoint@@@Z
	DD	FLAT:?OnGestureZoom@CWnd@@MAEHVCPoint@@J@Z
	DD	FLAT:?OnGesturePan@CWnd@@MAEHVCPoint@@0@Z
	DD	FLAT:?OnGestureRotate@CWnd@@MAEHVCPoint@@N@Z
	DD	FLAT:?OnGestureTwoFingerTap@CWnd@@MAEHVCPoint@@@Z
	DD	FLAT:?OnGesturePressAndTap@CWnd@@MAEHVCPoint@@J@Z
	DD	FLAT:?ResizeDynamicLayout@CWnd@@MAEXXZ
	DD	FLAT:?CheckAutoCenter@CDialog@@UAEHXZ
	DD	FLAT:?IsFrameWnd@CWnd@@UBEHXZ
	DD	FLAT:?CreateControlContainer@CWnd@@MAEHPAPAVCOleControlContainer@@@Z
	DD	FLAT:?CreateControlSite@CWnd@@MAEHPAVCOleControlContainer@@PAPAVCOleControlSite@@IABU_GUID@@@Z
	DD	FLAT:?SetOccDialogInfo@CDialog@@MAEHPAU_AFX_OCC_DIALOG_INFO@@@Z
	DD	FLAT:?GetOccDialogInfo@CDialog@@MAEPAU_AFX_OCC_DIALOG_INFO@@XZ
	DD	FLAT:?Create@CDialog@@UAEHIPAVCWnd@@@Z
	DD	FLAT:?Create@CDialog@@UAEHPBDPAVCWnd@@@Z
	DD	FLAT:?CreateIndirect@CDialog@@UAEHPAXPAVCWnd@@@Z
	DD	FLAT:?CreateIndirect@CDialog@@UAEHPBUDLGTEMPLATE@@PAVCWnd@@PAX@Z
	DD	FLAT:?DoModal@CDialog@@UAEHXZ
	DD	FLAT:?OnInitDialog@CDlgOptimizer@@MAEHXZ
	DD	FLAT:?OnSetFont@CDialog@@UAEXPAVCFont@@@Z
	DD	FLAT:?OnOK@CDialog@@MAEXXZ
	DD	FLAT:?OnCancel@CDialog@@MAEXXZ
	DD	FLAT:?PreInitDialog@CDialog@@MAEXXZ
CONST	ENDS
;	COMDAT ??_7CSTUserData@CDlgOptimizer@@6B@
CONST	SEGMENT
??_7CSTUserData@CDlgOptimizer@@6B@ DD FLAT:??_R4CSTUserData@CDlgOptimizer@@6B@ ; CDlgOptimizer::CSTUserData::`vftable'
	DD	FLAT:?GetChartData@CSTUserData@CDlgOptimizer@@UAGHAAJ000000AAH@Z
CONST	ENDS
;	COMDAT ??_7?$CArray@UST_STRGRIDDATA@@U1@@@6B@
CONST	SEGMENT
??_7?$CArray@UST_STRGRIDDATA@@U1@@@6B@ DD FLAT:??_R4?$CArray@UST_STRGRIDDATA@@U1@@@6B@ ; CArray<ST_STRGRIDDATA,ST_STRGRIDDATA>::`vftable'
	DD	FLAT:?GetRuntimeClass@CObject@@UBEPAUCRuntimeClass@@XZ
	DD	FLAT:??_E?$CArray@UST_STRGRIDDATA@@U1@@@UAEPAXI@Z
	DD	FLAT:?Serialize@?$CArray@UST_STRGRIDDATA@@U1@@@UAEXAAVCArchive@@@Z
	DD	FLAT:?AssertValid@CObject@@UBEXXZ
	DD	FLAT:?Dump@CObject@@UBEXAAVCDumpContext@@@Z
CONST	ENDS
;	COMDAT ??_7?$CArray@UST_GRIDDATA@@U1@@@6B@
CONST	SEGMENT
??_7?$CArray@UST_GRIDDATA@@U1@@@6B@ DD FLAT:??_R4?$CArray@UST_GRIDDATA@@U1@@@6B@ ; CArray<ST_GRIDDATA,ST_GRIDDATA>::`vftable'
	DD	FLAT:?GetRuntimeClass@CObject@@UBEPAUCRuntimeClass@@XZ
	DD	FLAT:??_E?$CArray@UST_GRIDDATA@@U1@@@UAEPAXI@Z
	DD	FLAT:?Serialize@?$CArray@UST_GRIDDATA@@U1@@@UAEXAAVCArchive@@@Z
	DD	FLAT:?AssertValid@CObject@@UBEXXZ
	DD	FLAT:?Dump@CObject@@UBEXAAVCDumpContext@@@Z
CONST	ENDS
;	COMDAT ??_7?$CArray@UST_RUNVALUE@@U1@@@6B@
CONST	SEGMENT
??_7?$CArray@UST_RUNVALUE@@U1@@@6B@ DD FLAT:??_R4?$CArray@UST_RUNVALUE@@U1@@@6B@ ; CArray<ST_RUNVALUE,ST_RUNVALUE>::`vftable'
	DD	FLAT:?GetRuntimeClass@CObject@@UBEPAUCRuntimeClass@@XZ
	DD	FLAT:??_E?$CArray@UST_RUNVALUE@@U1@@@UAEPAXI@Z
	DD	FLAT:?Serialize@?$CArray@UST_RUNVALUE@@U1@@@UAEXAAVCArchive@@@Z
	DD	FLAT:?AssertValid@CObject@@UBEXXZ
	DD	FLAT:?Dump@CObject@@UBEXAAVCDumpContext@@@Z
CONST	ENDS
;	COMDAT ??_7?$CArray@PAUST_VALUE@@PAU1@@@6B@
CONST	SEGMENT
??_7?$CArray@PAUST_VALUE@@PAU1@@@6B@ DD FLAT:??_R4?$CArray@PAUST_VALUE@@PAU1@@@6B@ ; CArray<ST_VALUE *,ST_VALUE *>::`vftable'
	DD	FLAT:?GetRuntimeClass@CObject@@UBEPAUCRuntimeClass@@XZ
	DD	FLAT:??_E?$CArray@PAUST_VALUE@@PAU1@@@UAEPAXI@Z
	DD	FLAT:?Serialize@?$CArray@PAUST_VALUE@@PAU1@@@UAEXAAVCArchive@@@Z
	DD	FLAT:?AssertValid@CObject@@UBEXXZ
	DD	FLAT:?Dump@CObject@@UBEXAAVCDumpContext@@@Z
CONST	ENDS
;	COMDAT ??_7?$CArray@PAVCDialog@@PAV1@@@6B@
CONST	SEGMENT
??_7?$CArray@PAVCDialog@@PAV1@@@6B@ DD FLAT:??_R4?$CArray@PAVCDialog@@PAV1@@@6B@ ; CArray<CDialog *,CDialog *>::`vftable'
	DD	FLAT:?GetRuntimeClass@CObject@@UBEPAUCRuntimeClass@@XZ
	DD	FLAT:??_E?$CArray@PAVCDialog@@PAV1@@@UAEPAXI@Z
	DD	FLAT:?Serialize@?$CArray@PAVCDialog@@PAV1@@@UAEXAAVCArchive@@@Z
	DD	FLAT:?AssertValid@CObject@@UBEXXZ
	DD	FLAT:?Dump@CObject@@UBEXAAVCDumpContext@@@Z
CONST	ENDS
;	COMDAT ??_C@_04ECGMOPPD@?$CK?4ST@
CONST	SEGMENT
??_C@_04ECGMOPPD@?$CK?4ST@ DB '*.ST', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7?$CArray@UST_VALUEOPTIMAZE@@U1@@@6B@
CONST	SEGMENT
??_7?$CArray@UST_VALUEOPTIMAZE@@U1@@@6B@ DD FLAT:??_R4?$CArray@UST_VALUEOPTIMAZE@@U1@@@6B@ ; CArray<ST_VALUEOPTIMAZE,ST_VALUEOPTIMAZE>::`vftable'
	DD	FLAT:?GetRuntimeClass@CObject@@UBEPAUCRuntimeClass@@XZ
	DD	FLAT:??_E?$CArray@UST_VALUEOPTIMAZE@@U1@@@UAEPAXI@Z
	DD	FLAT:?Serialize@?$CArray@UST_VALUEOPTIMAZE@@U1@@@UAEXAAVCArchive@@@Z
	DD	FLAT:?AssertValid@CObject@@UBEXXZ
	DD	FLAT:?Dump@CObject@@UBEXAAVCDumpContext@@@Z
CONST	ENDS
;	COMDAT ??_7?$CArray@NN@@6B@
CONST	SEGMENT
??_7?$CArray@NN@@6B@ DD FLAT:??_R4?$CArray@NN@@6B@	; CArray<double,double>::`vftable'
	DD	FLAT:?GetRuntimeClass@CObject@@UBEPAUCRuntimeClass@@XZ
	DD	FLAT:??_E?$CArray@NN@@UAEPAXI@Z
	DD	FLAT:?Serialize@?$CArray@NN@@UAEXAAVCArchive@@@Z
	DD	FLAT:?AssertValid@CObject@@UBEXXZ
	DD	FLAT:?Dump@CObject@@UBEXAAVCDumpContext@@@Z
CONST	ENDS
;	COMDAT ??_7ISTUserData@@6B@
CONST	SEGMENT
??_7ISTUserData@@6B@ DD FLAT:??_R4ISTUserData@@6B@	; ISTUserData::`vftable'
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@CEscDialog@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CEscDialog@@8 DD FLAT:??_R0?AVCEscDialog@@@8 ; CEscDialog::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CEscDialog@@8
rdata$r	ENDS
;	COMDAT ??_R2CEscDialog@@8
rdata$r	SEGMENT
??_R2CEscDialog@@8 DD FLAT:??_R1A@?0A@EA@CEscDialog@@8	; CEscDialog::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CDialog@@8
	DD	FLAT:??_R1A@?0A@EA@CWnd@@8
	DD	FLAT:??_R1A@?0A@EA@CCmdTarget@@8
	DD	FLAT:??_R1A@?0A@EA@CObject@@8
rdata$r	ENDS
;	COMDAT ??_R3CEscDialog@@8
rdata$r	SEGMENT
??_R3CEscDialog@@8 DD 00H				; CEscDialog::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	05H
	DD	FLAT:??_R2CEscDialog@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCEscDialog@@@8
data$rs	SEGMENT
??_R0?AVCEscDialog@@@8 DD FLAT:??_7type_info@@6B@	; CEscDialog `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCEscDialog@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CEscDialog@@6B@
rdata$r	SEGMENT
??_R4CEscDialog@@6B@ DD 00H				; CEscDialog::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCEscDialog@@@8
	DD	FLAT:??_R3CEscDialog@@8
rdata$r	ENDS
;	COMDAT ??_R2CDialog@@8
rdata$r	SEGMENT
??_R2CDialog@@8 DD FLAT:??_R1A@?0A@EA@CDialog@@8	; CDialog::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CWnd@@8
	DD	FLAT:??_R1A@?0A@EA@CCmdTarget@@8
	DD	FLAT:??_R1A@?0A@EA@CObject@@8
rdata$r	ENDS
;	COMDAT ??_R3CDialog@@8
rdata$r	SEGMENT
??_R3CDialog@@8 DD 00H					; CDialog::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2CDialog@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCDialog@@@8
data$rs	SEGMENT
??_R0?AVCDialog@@@8 DD FLAT:??_7type_info@@6B@		; CDialog `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCDialog@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@CDialog@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CDialog@@8 DD FLAT:??_R0?AVCDialog@@@8	; CDialog::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CDialog@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CListBox@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CListBox@@8 DD FLAT:??_R0?AVCListBox@@@8	; CListBox::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CListBox@@8
rdata$r	ENDS
;	COMDAT ??_R2CListBox@@8
rdata$r	SEGMENT
??_R2CListBox@@8 DD FLAT:??_R1A@?0A@EA@CListBox@@8	; CListBox::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CWnd@@8
	DD	FLAT:??_R1A@?0A@EA@CCmdTarget@@8
	DD	FLAT:??_R1A@?0A@EA@CObject@@8
rdata$r	ENDS
;	COMDAT ??_R3CListBox@@8
rdata$r	SEGMENT
??_R3CListBox@@8 DD 00H					; CListBox::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2CListBox@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCListBox@@@8
data$rs	SEGMENT
??_R0?AVCListBox@@@8 DD FLAT:??_7type_info@@6B@		; CListBox `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCListBox@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CListBox@@6B@
rdata$r	SEGMENT
??_R4CListBox@@6B@ DD 00H				; CListBox::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCListBox@@@8
	DD	FLAT:??_R3CListBox@@8
rdata$r	ENDS
;	COMDAT ??_R2CCmdTarget@@8
rdata$r	SEGMENT
??_R2CCmdTarget@@8 DD FLAT:??_R1A@?0A@EA@CCmdTarget@@8	; CCmdTarget::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CObject@@8
rdata$r	ENDS
;	COMDAT ??_R3CCmdTarget@@8
rdata$r	SEGMENT
??_R3CCmdTarget@@8 DD 00H				; CCmdTarget::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CCmdTarget@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCCmdTarget@@@8
data$rs	SEGMENT
??_R0?AVCCmdTarget@@@8 DD FLAT:??_7type_info@@6B@	; CCmdTarget `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCCmdTarget@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@CCmdTarget@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CCmdTarget@@8 DD FLAT:??_R0?AVCCmdTarget@@@8 ; CCmdTarget::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CCmdTarget@@8
rdata$r	ENDS
;	COMDAT ??_R2CWnd@@8
rdata$r	SEGMENT
??_R2CWnd@@8 DD	FLAT:??_R1A@?0A@EA@CWnd@@8		; CWnd::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CCmdTarget@@8
	DD	FLAT:??_R1A@?0A@EA@CObject@@8
rdata$r	ENDS
;	COMDAT ??_R3CWnd@@8
rdata$r	SEGMENT
??_R3CWnd@@8 DD	00H					; CWnd::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2CWnd@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCWnd@@@8
data$rs	SEGMENT
??_R0?AVCWnd@@@8 DD FLAT:??_7type_info@@6B@		; CWnd `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCWnd@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@CWnd@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CWnd@@8 DD FLAT:??_R0?AVCWnd@@@8		; CWnd::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CWnd@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CBitmap@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CBitmap@@8 DD FLAT:??_R0?AVCBitmap@@@8	; CBitmap::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CBitmap@@8
rdata$r	ENDS
;	COMDAT ??_R2CBitmap@@8
rdata$r	SEGMENT
??_R2CBitmap@@8 DD FLAT:??_R1A@?0A@EA@CBitmap@@8	; CBitmap::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CGdiObject@@8
	DD	FLAT:??_R1A@?0A@EA@CObject@@8
rdata$r	ENDS
;	COMDAT ??_R3CBitmap@@8
rdata$r	SEGMENT
??_R3CBitmap@@8 DD 00H					; CBitmap::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2CBitmap@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCBitmap@@@8
data$rs	SEGMENT
??_R0?AVCBitmap@@@8 DD FLAT:??_7type_info@@6B@		; CBitmap `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCBitmap@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CBitmap@@6B@
rdata$r	SEGMENT
??_R4CBitmap@@6B@ DD 00H				; CBitmap::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCBitmap@@@8
	DD	FLAT:??_R3CBitmap@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CFont@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CFont@@8 DD FLAT:??_R0?AVCFont@@@8	; CFont::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CFont@@8
rdata$r	ENDS
;	COMDAT ??_R2CFont@@8
rdata$r	SEGMENT
??_R2CFont@@8 DD FLAT:??_R1A@?0A@EA@CFont@@8		; CFont::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CGdiObject@@8
	DD	FLAT:??_R1A@?0A@EA@CObject@@8
rdata$r	ENDS
;	COMDAT ??_R3CFont@@8
rdata$r	SEGMENT
??_R3CFont@@8 DD 00H					; CFont::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2CFont@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCFont@@@8
data$rs	SEGMENT
??_R0?AVCFont@@@8 DD FLAT:??_7type_info@@6B@		; CFont `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCFont@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CFont@@6B@
rdata$r	SEGMENT
??_R4CFont@@6B@ DD 00H					; CFont::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCFont@@@8
	DD	FLAT:??_R3CFont@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CBrush@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CBrush@@8 DD FLAT:??_R0?AVCBrush@@@8	; CBrush::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CBrush@@8
rdata$r	ENDS
;	COMDAT ??_R2CBrush@@8
rdata$r	SEGMENT
??_R2CBrush@@8 DD FLAT:??_R1A@?0A@EA@CBrush@@8		; CBrush::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CGdiObject@@8
	DD	FLAT:??_R1A@?0A@EA@CObject@@8
rdata$r	ENDS
;	COMDAT ??_R3CBrush@@8
rdata$r	SEGMENT
??_R3CBrush@@8 DD 00H					; CBrush::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2CBrush@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCBrush@@@8
data$rs	SEGMENT
??_R0?AVCBrush@@@8 DD FLAT:??_7type_info@@6B@		; CBrush `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCBrush@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CBrush@@6B@
rdata$r	SEGMENT
??_R4CBrush@@6B@ DD 00H					; CBrush::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCBrush@@@8
	DD	FLAT:??_R3CBrush@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CGdiObject@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CGdiObject@@8 DD FLAT:??_R0?AVCGdiObject@@@8 ; CGdiObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CGdiObject@@8
rdata$r	ENDS
;	COMDAT ??_R2CGdiObject@@8
rdata$r	SEGMENT
??_R2CGdiObject@@8 DD FLAT:??_R1A@?0A@EA@CGdiObject@@8	; CGdiObject::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CObject@@8
rdata$r	ENDS
;	COMDAT ??_R3CGdiObject@@8
rdata$r	SEGMENT
??_R3CGdiObject@@8 DD 00H				; CGdiObject::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CGdiObject@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCGdiObject@@@8
data$rs	SEGMENT
??_R0?AVCGdiObject@@@8 DD FLAT:??_7type_info@@6B@	; CGdiObject `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCGdiObject@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CGdiObject@@6B@
rdata$r	SEGMENT
??_R4CGdiObject@@6B@ DD 00H				; CGdiObject::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCGdiObject@@@8
	DD	FLAT:??_R3CGdiObject@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CObject@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CObject@@8 DD FLAT:??_R0?AVCObject@@@8	; CObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CObject@@8
rdata$r	ENDS
;	COMDAT ??_R2CObject@@8
rdata$r	SEGMENT
??_R2CObject@@8 DD FLAT:??_R1A@?0A@EA@CObject@@8	; CObject::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CObject@@8
rdata$r	SEGMENT
??_R3CObject@@8 DD 00H					; CObject::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CObject@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCObject@@@8
data$rs	SEGMENT
??_R0?AVCObject@@@8 DD FLAT:??_7type_info@@6B@		; CObject `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCObject@@', 00H
data$rs	ENDS
;	COMDAT ??_7CEscDialog@@6B@
CONST	SEGMENT
??_7CEscDialog@@6B@ DD FLAT:??_R4CEscDialog@@6B@	; CEscDialog::`vftable'
	DD	FLAT:?GetRuntimeClass@CDialog@@UBEPAUCRuntimeClass@@XZ
	DD	FLAT:??_ECEscDialog@@UAEPAXI@Z
	DD	FLAT:?Serialize@CObject@@UAEXAAVCArchive@@@Z
	DD	FLAT:?AssertValid@CObject@@UBEXXZ
	DD	FLAT:?Dump@CObject@@UBEXAAVCDumpContext@@@Z
	DD	FLAT:?OnCmdMsg@CDialog@@UAEHIHPAXPAUAFX_CMDHANDLERINFO@@@Z
	DD	FLAT:?OnFinalRelease@CWnd@@UAEXXZ
	DD	FLAT:?IsInvokeAllowed@CCmdTarget@@UAEHJ@Z
	DD	FLAT:?GetDispatchIID@CCmdTarget@@UAEHPAU_GUID@@@Z
	DD	FLAT:?GetTypeInfoCount@CCmdTarget@@UAEIXZ
	DD	FLAT:?GetTypeLibCache@CCmdTarget@@UAEPAVCTypeLibCache@@XZ
	DD	FLAT:?GetTypeLib@CCmdTarget@@UAEJKPAPAUITypeLib@@@Z
	DD	FLAT:?GetMessageMap@CDialog@@MBEPBUAFX_MSGMAP@@XZ
	DD	FLAT:?GetCommandMap@CCmdTarget@@MBEPBUAFX_OLECMDMAP@@XZ
	DD	FLAT:?GetDispatchMap@CCmdTarget@@MBEPBUAFX_DISPMAP@@XZ
	DD	FLAT:?GetConnectionMap@CCmdTarget@@MBEPBUAFX_CONNECTIONMAP@@XZ
	DD	FLAT:?GetInterfaceMap@CWnd@@MBEPBUAFX_INTERFACEMAP@@XZ
	DD	FLAT:?GetEventSinkMap@CCmdTarget@@MBEPBUAFX_EVENTSINKMAP@@XZ
	DD	FLAT:?OnCreateAggregates@CCmdTarget@@UAEHXZ
	DD	FLAT:?GetInterfaceHook@CCmdTarget@@UAEPAUIUnknown@@PBX@Z
	DD	FLAT:?GetExtraConnectionPoints@CCmdTarget@@MAEHPAVCPtrArray@@@Z
	DD	FLAT:?GetConnectionHook@CCmdTarget@@MAEPAUIConnectionPoint@@ABU_GUID@@@Z
	DD	FLAT:?PreSubclassWindow@CWnd@@UAEXXZ
	DD	FLAT:?Create@CWnd@@UAEHPBD0KABUtagRECT@@PAV1@IPAUCCreateContext@@@Z
	DD	FLAT:?CreateEx@CWnd@@UAEHKPBD0KABUtagRECT@@PAV1@IPAX@Z
	DD	FLAT:?CreateEx@CWnd@@UAEHKPBD0KHHHHPAUHWND__@@PAUHMENU__@@PAX@Z
	DD	FLAT:?DestroyWindow@CWnd@@UAEHXZ
	DD	FLAT:?PreCreateWindow@CWnd@@UAEHAAUtagCREATESTRUCTA@@@Z
	DD	FLAT:?CalcWindowRect@CWnd@@UAEXPAUtagRECT@@I@Z
	DD	FLAT:?GetMenu@CWnd@@UBEPAVCMenu@@XZ
	DD	FLAT:?SetMenu@CWnd@@UAEHPAVCMenu@@@Z
	DD	FLAT:?OnToolHitTest@CWnd@@UBEHVCPoint@@PAUtagTOOLINFOA@@@Z
	DD	FLAT:?GetScrollBarCtrl@CWnd@@UBEPAVCScrollBar@@H@Z
	DD	FLAT:?WinHelpA@CWnd@@UAEXKI@Z
	DD	FLAT:?HtmlHelpA@CWnd@@UAEXKI@Z
	DD	FLAT:?WinHelpInternal@CWnd@@UAEXKI@Z
	DD	FLAT:?ContinueModal@CWnd@@UAEHXZ
	DD	FLAT:?EndModalLoop@CWnd@@UAEXH@Z
	DD	FLAT:?OnDrawIconicThumbnailOrLivePreview@CWnd@@UAEXAAVCDC@@VCRect@@VCSize@@HAAH@Z
	DD	FLAT:?EnsureStdObj@CWnd@@UAEJXZ
	DD	FLAT:?get_accParent@CWnd@@UAEJPAPAUIDispatch@@@Z
	DD	FLAT:?get_accChildCount@CWnd@@UAEJPAJ@Z
	DD	FLAT:?get_accChild@CWnd@@UAEJUtagVARIANT@@PAPAUIDispatch@@@Z
	DD	FLAT:?get_accName@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z
	DD	FLAT:?get_accValue@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z
	DD	FLAT:?get_accDescription@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z
	DD	FLAT:?get_accRole@CWnd@@UAEJUtagVARIANT@@PAU2@@Z
	DD	FLAT:?get_accState@CWnd@@UAEJUtagVARIANT@@PAU2@@Z
	DD	FLAT:?get_accHelp@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z
	DD	FLAT:?get_accHelpTopic@CWnd@@UAEJPAPA_WUtagVARIANT@@PAJ@Z
	DD	FLAT:?get_accKeyboardShortcut@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z
	DD	FLAT:?get_accFocus@CWnd@@UAEJPAUtagVARIANT@@@Z
	DD	FLAT:?get_accSelection@CWnd@@UAEJPAUtagVARIANT@@@Z
	DD	FLAT:?get_accDefaultAction@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z
	DD	FLAT:?accSelect@CWnd@@UAEJJUtagVARIANT@@@Z
	DD	FLAT:?accLocation@CWnd@@UAEJPAJ000UtagVARIANT@@@Z
	DD	FLAT:?accNavigate@CWnd@@UAEJJUtagVARIANT@@PAU2@@Z
	DD	FLAT:?accHitTest@CWnd@@UAEJJJPAUtagVARIANT@@@Z
	DD	FLAT:?accDoDefaultAction@CWnd@@UAEJUtagVARIANT@@@Z
	DD	FLAT:?put_accName@CWnd@@UAEJUtagVARIANT@@PA_W@Z
	DD	FLAT:?put_accValue@CWnd@@UAEJUtagVARIANT@@PA_W@Z
	DD	FLAT:?SetProxy@CWnd@@UAEJPAUIAccessibleProxy@@@Z
	DD	FLAT:?CreateAccessibleProxy@CWnd@@UAEJIJPAJ@Z
	DD	FLAT:?OnCommand@CWnd@@MAEHIJ@Z
	DD	FLAT:?OnNotify@CWnd@@MAEHIJPAJ@Z
	DD	FLAT:?GetSuperWndProcAddr@CWnd@@MAEPAP6GJPAUHWND__@@IIJ@ZXZ
	DD	FLAT:?DoDataExchange@CWnd@@MAEXPAVCDataExchange@@@Z
	DD	FLAT:?BeginModalState@CWnd@@UAEXXZ
	DD	FLAT:?EndModalState@CWnd@@UAEXXZ
	DD	FLAT:?PreTranslateMessage@CEscDialog@@MAEHPAUtagMSG@@@Z
	DD	FLAT:?OnAmbientProperty@CWnd@@UAEHPAVCOleControlSite@@JPAUtagVARIANT@@@Z
	DD	FLAT:?WindowProc@CWnd@@MAEJIIJ@Z
	DD	FLAT:?OnWndMsg@CWnd@@MAEHIIJPAJ@Z
	DD	FLAT:?DefWindowProcA@CWnd@@MAEJIIJ@Z
	DD	FLAT:?PostNcDestroy@CWnd@@MAEXXZ
	DD	FLAT:?OnChildNotify@CWnd@@MAEHIIJPAJ@Z
	DD	FLAT:?OnTouchInputs@CWnd@@MAEHIPAUtagTOUCHINPUT@@@Z
	DD	FLAT:?OnTouchInput@CWnd@@MAEHVCPoint@@HHPAUtagTOUCHINPUT@@@Z
	DD	FLAT:?GetGestureStatus@CWnd@@MAEKVCPoint@@@Z
	DD	FLAT:?OnGestureZoom@CWnd@@MAEHVCPoint@@J@Z
	DD	FLAT:?OnGesturePan@CWnd@@MAEHVCPoint@@0@Z
	DD	FLAT:?OnGestureRotate@CWnd@@MAEHVCPoint@@N@Z
	DD	FLAT:?OnGestureTwoFingerTap@CWnd@@MAEHVCPoint@@@Z
	DD	FLAT:?OnGesturePressAndTap@CWnd@@MAEHVCPoint@@J@Z
	DD	FLAT:?ResizeDynamicLayout@CWnd@@MAEXXZ
	DD	FLAT:?CheckAutoCenter@CDialog@@UAEHXZ
	DD	FLAT:?IsFrameWnd@CWnd@@UBEHXZ
	DD	FLAT:?CreateControlContainer@CWnd@@MAEHPAPAVCOleControlContainer@@@Z
	DD	FLAT:?CreateControlSite@CWnd@@MAEHPAVCOleControlContainer@@PAPAVCOleControlSite@@IABU_GUID@@@Z
	DD	FLAT:?SetOccDialogInfo@CDialog@@MAEHPAU_AFX_OCC_DIALOG_INFO@@@Z
	DD	FLAT:?GetOccDialogInfo@CDialog@@MAEPAU_AFX_OCC_DIALOG_INFO@@XZ
	DD	FLAT:?Create@CDialog@@UAEHIPAVCWnd@@@Z
	DD	FLAT:?Create@CDialog@@UAEHPBDPAVCWnd@@@Z
	DD	FLAT:?CreateIndirect@CDialog@@UAEHPAXPAVCWnd@@@Z
	DD	FLAT:?CreateIndirect@CDialog@@UAEHPBUDLGTEMPLATE@@PAVCWnd@@PAX@Z
	DD	FLAT:?DoModal@CDialog@@UAEHXZ
	DD	FLAT:?OnInitDialog@CDialog@@UAEHXZ
	DD	FLAT:?OnSetFont@CDialog@@UAEXPAVCFont@@@Z
	DD	FLAT:?OnOK@CDialog@@MAEXXZ
	DD	FLAT:?OnCancel@CDialog@@MAEXXZ
	DD	FLAT:?PreInitDialog@CDialog@@MAEXXZ
CONST	ENDS
;	COMDAT ??_C@_02EMFKHFLK@?$CFX@
CONST	SEGMENT
??_C@_02EMFKHFLK@?$CFX@ DB '%X', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06NDLAHCHE@?$CFs?$CF08X@
CONST	SEGMENT
??_C@_06NDLAHCHE@?$CFs?$CF08X@ DB '%s%08X', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@IDMAJEGN@HANAROPCTRMAIN@
CONST	SEGMENT
??_C@_0P@IDMAJEGN@HANAROPCTRMAIN@ DB 'HANAROPCTRMAIN', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CBBNGGHM@PcTrMng?4dll@
CONST	SEGMENT
??_C@_0M@CBBNGGHM@PcTrMng?4dll@ DB 'PcTrMng.dll', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01HIHLOKLC@1@
CONST	SEGMENT
??_C@_01HIHLOKLC@1@ DB '1', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@OMEMOKLE@?$CFTs?5?$CI?$CFTs?3?$CFd?$CJ@
CONST	SEGMENT
??_C@_0N@OMEMOKLE@?$CFTs?5?$CI?$CFTs?3?$CFd?$CJ@ DB '%Ts (%Ts:%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@HBOOMJBF@?$CFTs?5?$CI?$CFTs?3?$CFd?$CJ?6?$CFTs@
CONST	SEGMENT
??_C@_0BB@HBOOMJBF@?$CFTs?5?$CI?$CFTs?3?$CFd?$CJ?6?$CFTs@ DB '%Ts (%Ts:%d'
	DB	')', 0aH, '%Ts', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@OIEOKIDM@Exception?5thrown?5in?5destructor@
CONST	SEGMENT
??_C@_0BP@OIEOKIDM@Exception?5thrown?5in?5destructor@ DB 'Exception throw'
	DB	'n in destructor', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0HD@JJCHHHNK@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
CONST	SEGMENT
??_C@_0HD@JJCHHHNK@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ DB 'C:\Pro'
	DB	'gram Files (x86)\Microsoft Visual Studio\2019\Community\VC\To'
	DB	'ols\MSVC\14.29.30133\atlmfc\include\afxwin1.inl', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7CListBox@@6B@
CONST	SEGMENT
??_7CListBox@@6B@ DD FLAT:??_R4CListBox@@6B@		; CListBox::`vftable'
	DD	FLAT:?GetRuntimeClass@CListBox@@UBEPAUCRuntimeClass@@XZ
	DD	FLAT:??_ECListBox@@UAEPAXI@Z
	DD	FLAT:?Serialize@CObject@@UAEXAAVCArchive@@@Z
	DD	FLAT:?AssertValid@CObject@@UBEXXZ
	DD	FLAT:?Dump@CObject@@UBEXAAVCDumpContext@@@Z
	DD	FLAT:?OnCmdMsg@CCmdTarget@@UAEHIHPAXPAUAFX_CMDHANDLERINFO@@@Z
	DD	FLAT:?OnFinalRelease@CWnd@@UAEXXZ
	DD	FLAT:?IsInvokeAllowed@CCmdTarget@@UAEHJ@Z
	DD	FLAT:?GetDispatchIID@CCmdTarget@@UAEHPAU_GUID@@@Z
	DD	FLAT:?GetTypeInfoCount@CCmdTarget@@UAEIXZ
	DD	FLAT:?GetTypeLibCache@CCmdTarget@@UAEPAVCTypeLibCache@@XZ
	DD	FLAT:?GetTypeLib@CCmdTarget@@UAEJKPAPAUITypeLib@@@Z
	DD	FLAT:?GetMessageMap@CWnd@@MBEPBUAFX_MSGMAP@@XZ
	DD	FLAT:?GetCommandMap@CCmdTarget@@MBEPBUAFX_OLECMDMAP@@XZ
	DD	FLAT:?GetDispatchMap@CCmdTarget@@MBEPBUAFX_DISPMAP@@XZ
	DD	FLAT:?GetConnectionMap@CCmdTarget@@MBEPBUAFX_CONNECTIONMAP@@XZ
	DD	FLAT:?GetInterfaceMap@CWnd@@MBEPBUAFX_INTERFACEMAP@@XZ
	DD	FLAT:?GetEventSinkMap@CCmdTarget@@MBEPBUAFX_EVENTSINKMAP@@XZ
	DD	FLAT:?OnCreateAggregates@CCmdTarget@@UAEHXZ
	DD	FLAT:?GetInterfaceHook@CCmdTarget@@UAEPAUIUnknown@@PBX@Z
	DD	FLAT:?GetExtraConnectionPoints@CCmdTarget@@MAEHPAVCPtrArray@@@Z
	DD	FLAT:?GetConnectionHook@CCmdTarget@@MAEPAUIConnectionPoint@@ABU_GUID@@@Z
	DD	FLAT:?PreSubclassWindow@CWnd@@UAEXXZ
	DD	FLAT:?Create@CWnd@@UAEHPBD0KABUtagRECT@@PAV1@IPAUCCreateContext@@@Z
	DD	FLAT:?CreateEx@CWnd@@UAEHKPBD0KABUtagRECT@@PAV1@IPAX@Z
	DD	FLAT:?CreateEx@CWnd@@UAEHKPBD0KHHHHPAUHWND__@@PAUHMENU__@@PAX@Z
	DD	FLAT:?DestroyWindow@CWnd@@UAEHXZ
	DD	FLAT:?PreCreateWindow@CWnd@@UAEHAAUtagCREATESTRUCTA@@@Z
	DD	FLAT:?CalcWindowRect@CWnd@@UAEXPAUtagRECT@@I@Z
	DD	FLAT:?GetMenu@CWnd@@UBEPAVCMenu@@XZ
	DD	FLAT:?SetMenu@CWnd@@UAEHPAVCMenu@@@Z
	DD	FLAT:?OnToolHitTest@CWnd@@UBEHVCPoint@@PAUtagTOOLINFOA@@@Z
	DD	FLAT:?GetScrollBarCtrl@CWnd@@UBEPAVCScrollBar@@H@Z
	DD	FLAT:?WinHelpA@CWnd@@UAEXKI@Z
	DD	FLAT:?HtmlHelpA@CWnd@@UAEXKI@Z
	DD	FLAT:?WinHelpInternal@CWnd@@UAEXKI@Z
	DD	FLAT:?ContinueModal@CWnd@@UAEHXZ
	DD	FLAT:?EndModalLoop@CWnd@@UAEXH@Z
	DD	FLAT:?OnDrawIconicThumbnailOrLivePreview@CWnd@@UAEXAAVCDC@@VCRect@@VCSize@@HAAH@Z
	DD	FLAT:?EnsureStdObj@CWnd@@UAEJXZ
	DD	FLAT:?get_accParent@CWnd@@UAEJPAPAUIDispatch@@@Z
	DD	FLAT:?get_accChildCount@CWnd@@UAEJPAJ@Z
	DD	FLAT:?get_accChild@CWnd@@UAEJUtagVARIANT@@PAPAUIDispatch@@@Z
	DD	FLAT:?get_accName@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z
	DD	FLAT:?get_accValue@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z
	DD	FLAT:?get_accDescription@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z
	DD	FLAT:?get_accRole@CWnd@@UAEJUtagVARIANT@@PAU2@@Z
	DD	FLAT:?get_accState@CWnd@@UAEJUtagVARIANT@@PAU2@@Z
	DD	FLAT:?get_accHelp@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z
	DD	FLAT:?get_accHelpTopic@CWnd@@UAEJPAPA_WUtagVARIANT@@PAJ@Z
	DD	FLAT:?get_accKeyboardShortcut@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z
	DD	FLAT:?get_accFocus@CWnd@@UAEJPAUtagVARIANT@@@Z
	DD	FLAT:?get_accSelection@CWnd@@UAEJPAUtagVARIANT@@@Z
	DD	FLAT:?get_accDefaultAction@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z
	DD	FLAT:?accSelect@CWnd@@UAEJJUtagVARIANT@@@Z
	DD	FLAT:?accLocation@CWnd@@UAEJPAJ000UtagVARIANT@@@Z
	DD	FLAT:?accNavigate@CWnd@@UAEJJUtagVARIANT@@PAU2@@Z
	DD	FLAT:?accHitTest@CWnd@@UAEJJJPAUtagVARIANT@@@Z
	DD	FLAT:?accDoDefaultAction@CWnd@@UAEJUtagVARIANT@@@Z
	DD	FLAT:?put_accName@CWnd@@UAEJUtagVARIANT@@PA_W@Z
	DD	FLAT:?put_accValue@CWnd@@UAEJUtagVARIANT@@PA_W@Z
	DD	FLAT:?SetProxy@CWnd@@UAEJPAUIAccessibleProxy@@@Z
	DD	FLAT:?CreateAccessibleProxy@CWnd@@UAEJIJPAJ@Z
	DD	FLAT:?OnCommand@CWnd@@MAEHIJ@Z
	DD	FLAT:?OnNotify@CWnd@@MAEHIJPAJ@Z
	DD	FLAT:?GetSuperWndProcAddr@CWnd@@MAEPAP6GJPAUHWND__@@IIJ@ZXZ
	DD	FLAT:?DoDataExchange@CWnd@@MAEXPAVCDataExchange@@@Z
	DD	FLAT:?BeginModalState@CWnd@@UAEXXZ
	DD	FLAT:?EndModalState@CWnd@@UAEXXZ
	DD	FLAT:?PreTranslateMessage@CWnd@@UAEHPAUtagMSG@@@Z
	DD	FLAT:?OnAmbientProperty@CWnd@@UAEHPAVCOleControlSite@@JPAUtagVARIANT@@@Z
	DD	FLAT:?WindowProc@CWnd@@MAEJIIJ@Z
	DD	FLAT:?OnWndMsg@CWnd@@MAEHIIJPAJ@Z
	DD	FLAT:?DefWindowProcA@CWnd@@MAEJIIJ@Z
	DD	FLAT:?PostNcDestroy@CWnd@@MAEXXZ
	DD	FLAT:?OnChildNotify@CListBox@@MAEHIIJPAJ@Z
	DD	FLAT:?OnTouchInputs@CWnd@@MAEHIPAUtagTOUCHINPUT@@@Z
	DD	FLAT:?OnTouchInput@CWnd@@MAEHVCPoint@@HHPAUtagTOUCHINPUT@@@Z
	DD	FLAT:?GetGestureStatus@CWnd@@MAEKVCPoint@@@Z
	DD	FLAT:?OnGestureZoom@CWnd@@MAEHVCPoint@@J@Z
	DD	FLAT:?OnGesturePan@CWnd@@MAEHVCPoint@@0@Z
	DD	FLAT:?OnGestureRotate@CWnd@@MAEHVCPoint@@N@Z
	DD	FLAT:?OnGestureTwoFingerTap@CWnd@@MAEHVCPoint@@@Z
	DD	FLAT:?OnGesturePressAndTap@CWnd@@MAEHVCPoint@@J@Z
	DD	FLAT:?ResizeDynamicLayout@CWnd@@MAEXXZ
	DD	FLAT:?CheckAutoCenter@CWnd@@UAEHXZ
	DD	FLAT:?IsFrameWnd@CWnd@@UBEHXZ
	DD	FLAT:?CreateControlContainer@CWnd@@MAEHPAPAVCOleControlContainer@@@Z
	DD	FLAT:?CreateControlSite@CWnd@@MAEHPAVCOleControlContainer@@PAPAVCOleControlSite@@IABU_GUID@@@Z
	DD	FLAT:?SetOccDialogInfo@CWnd@@MAEHPAU_AFX_OCC_DIALOG_INFO@@@Z
	DD	FLAT:?GetOccDialogInfo@CWnd@@MAEPAU_AFX_OCC_DIALOG_INFO@@XZ
	DD	FLAT:?Create@CListBox@@UAEHKABUtagRECT@@PAVCWnd@@I@Z
	DD	FLAT:?DrawItem@CListBox@@UAEXPAUtagDRAWITEMSTRUCT@@@Z
	DD	FLAT:?MeasureItem@CListBox@@UAEXPAUtagMEASUREITEMSTRUCT@@@Z
	DD	FLAT:?CompareItem@CListBox@@UAEHPAUtagCOMPAREITEMSTRUCT@@@Z
	DD	FLAT:?DeleteItem@CListBox@@UAEXPAUtagDELETEITEMSTRUCT@@@Z
	DD	FLAT:?VKeyToItem@CListBox@@UAEHII@Z
	DD	FLAT:?CharToItem@CListBox@@UAEHII@Z
CONST	ENDS
;	COMDAT ??_7CBitmap@@6B@
CONST	SEGMENT
??_7CBitmap@@6B@ DD FLAT:??_R4CBitmap@@6B@		; CBitmap::`vftable'
	DD	FLAT:?GetRuntimeClass@CBitmap@@UBEPAUCRuntimeClass@@XZ
	DD	FLAT:??_ECBitmap@@UAEPAXI@Z
	DD	FLAT:?Serialize@CObject@@UAEXAAVCArchive@@@Z
	DD	FLAT:?AssertValid@CObject@@UBEXXZ
	DD	FLAT:?Dump@CObject@@UBEXAAVCDumpContext@@@Z
CONST	ENDS
;	COMDAT ??_7CFont@@6B@
CONST	SEGMENT
??_7CFont@@6B@ DD FLAT:??_R4CFont@@6B@			; CFont::`vftable'
	DD	FLAT:?GetRuntimeClass@CFont@@UBEPAUCRuntimeClass@@XZ
	DD	FLAT:??_ECFont@@UAEPAXI@Z
	DD	FLAT:?Serialize@CObject@@UAEXAAVCArchive@@@Z
	DD	FLAT:?AssertValid@CObject@@UBEXXZ
	DD	FLAT:?Dump@CObject@@UBEXAAVCDumpContext@@@Z
CONST	ENDS
;	COMDAT ??_7CBrush@@6B@
CONST	SEGMENT
??_7CBrush@@6B@ DD FLAT:??_R4CBrush@@6B@		; CBrush::`vftable'
	DD	FLAT:?GetRuntimeClass@CBrush@@UBEPAUCRuntimeClass@@XZ
	DD	FLAT:??_ECBrush@@UAEPAXI@Z
	DD	FLAT:?Serialize@CObject@@UAEXAAVCArchive@@@Z
	DD	FLAT:?AssertValid@CObject@@UBEXXZ
	DD	FLAT:?Dump@CObject@@UBEXAAVCDumpContext@@@Z
CONST	ENDS
;	COMDAT ??_7CGdiObject@@6B@
CONST	SEGMENT
??_7CGdiObject@@6B@ DD FLAT:??_R4CGdiObject@@6B@	; CGdiObject::`vftable'
	DD	FLAT:?GetRuntimeClass@CGdiObject@@UBEPAUCRuntimeClass@@XZ
	DD	FLAT:??_ECGdiObject@@UAEPAXI@Z
	DD	FLAT:?Serialize@CObject@@UAEXAAVCArchive@@@Z
	DD	FLAT:?AssertValid@CObject@@UBEXXZ
	DD	FLAT:?Dump@CObject@@UBEXAAVCDumpContext@@@Z
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd@ DB '%d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_R0PAVCException@@@8
data$r	SEGMENT
??_R0PAVCException@@@8 DD FLAT:??_7type_info@@6B@	; CException * `RTTI Type Descriptor'
	DD	00H
	DB	'.PAVCException@@', 00H
data$r	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_G?$CList@PAUSTMNG_ITEMINFO@@PAU1@@@UAEPAXI@Z DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??_G?$CList@PAUSTMNG_ITEMINFO@@PAU1@@@UAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_G?$CList@PAUSTMNG_ITEMINFO@@PAU1@@@UAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CList@PAUSTMNG_ITEMINFO@@PAU1@@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?OnBnClickedBtnAddone@CDlgOptimizer@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?OnBnClickedBtnAddone@CDlgOptimizer@@QAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?OnBnClickedBtnAddone@CDlgOptimizer@@QAEXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?OnBnClickedBtnAddone@CDlgOptimizer@@QAEXXZ$2
	DD	0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$?OnBnClickedBtnAddone@CDlgOptimizer@@QAEXXZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?OnBnClickedBtnAddone@CDlgOptimizer@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?OnBnClickedBtnAddall@CDlgOptimizer@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?OnBnClickedBtnAddall@CDlgOptimizer@@QAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?OnBnClickedBtnAddall@CDlgOptimizer@@QAEXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?OnBnClickedBtnAddall@CDlgOptimizer@@QAEXXZ$2
	DD	0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$?OnBnClickedBtnAddall@CDlgOptimizer@@QAEXXZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?OnBnClickedBtnAddall@CDlgOptimizer@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?LoadSTList@CDlgOptimizer@@QAEXXZ DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$?LoadSTList@CDlgOptimizer@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LoadSTList@CDlgOptimizer@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LoadSTList@CDlgOptimizer@@QAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadSTList@CDlgOptimizer@@QAEXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LoadSTList@CDlgOptimizer@@QAEXXZ$7
	DD	02H
	DD	FLAT:__unwindfunclet$?LoadSTList@CDlgOptimizer@@QAEXXZ$3
	DD	01H
	DD	FLAT:__unwindfunclet$?LoadSTList@CDlgOptimizer@@QAEXXZ$3
	DD	04H
	DD	FLAT:__unwindfunclet$?LoadSTList@CDlgOptimizer@@QAEXXZ$9
	DD	05H
	DD	FLAT:__unwindfunclet$?LoadSTList@CDlgOptimizer@@QAEXXZ$10
	DD	04H
	DD	FLAT:__unwindfunclet$?LoadSTList@CDlgOptimizer@@QAEXXZ$10
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?LoadOutlookBar@CDlgOptimizer@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LoadOutlookBar@CDlgOptimizer@@QAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadOutlookBar@CDlgOptimizer@@QAEXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LoadOutlookBar@CDlgOptimizer@@QAEXXZ$2
__ehfuncinfo$?LoadOutlookBar@CDlgOptimizer@@QAEXXZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?LoadOutlookBar@CDlgOptimizer@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?SearchFileToData@CDlgOptimizer@@QAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V23@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SearchFileToData@CDlgOptimizer@@QAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V23@0@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?SearchFileToData@CDlgOptimizer@@QAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V23@0@Z$1
__ehfuncinfo$?SearchFileToData@CDlgOptimizer@@QAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V23@0@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?SearchFileToData@CDlgOptimizer@@QAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V23@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?IsNumber@CDlgOptimizer@@QAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?IsNumber@CDlgOptimizer@@QAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z$0
__ehfuncinfo$?IsNumber@CDlgOptimizer@@QAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?IsNumber@CDlgOptimizer@@QAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?GetJMNameAndGubunFromCode@CDlgOptimizer@@QAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V23@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetJMNameAndGubunFromCode@CDlgOptimizer@@QAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V23@@Z$0
__ehfuncinfo$?GetJMNameAndGubunFromCode@CDlgOptimizer@@QAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V23@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetJMNameAndGubunFromCode@CDlgOptimizer@@QAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V23@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?InitControls@CDlgOptimizer@@QAEXXZ DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$?InitControls@CDlgOptimizer@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?InitControls@CDlgOptimizer@@QAEXXZ DD 0ffffffffH
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	00H
	DD	02H
	DD	00H
	DD	02H
	DD	00H
	DD	04H
	DD	00H
	DD	04H
	DD	00H
	DD	04H
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?InitTab@CDlgOptimizer@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?InitTab@CDlgOptimizer@@QAEXXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?InitTab@CDlgOptimizer@@QAEXXZ$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?InitTab@CDlgOptimizer@@QAEXXZ$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?InitTab@CDlgOptimizer@@QAEXXZ$5
__ehfuncinfo$?InitTab@CDlgOptimizer@@QAEXXZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?InitTab@CDlgOptimizer@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?ReSize@CDlgOptimizer@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ReSize@CDlgOptimizer@@QAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ReSize@CDlgOptimizer@@QAEXXZ$1
__ehfuncinfo$?ReSize@CDlgOptimizer@@QAEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?ReSize@CDlgOptimizer@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?CreateTImeSetupDlg@CDlgOptimizer@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateTImeSetupDlg@CDlgOptimizer@@QAEXXZ$0
__ehfuncinfo$?CreateTImeSetupDlg@CDlgOptimizer@@QAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?CreateTImeSetupDlg@CDlgOptimizer@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?OnRmsgObItemDBClk@CDlgOptimizer@@IAEJIJ@Z DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$?OnRmsgObItemDBClk@CDlgOptimizer@@IAEJIJ@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?OnRmsgObItemDBClk@CDlgOptimizer@@IAEJIJ@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?OnRmsgObItemDBClk@CDlgOptimizer@@IAEJIJ@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?OnRmsgObItemDBClk@CDlgOptimizer@@IAEJIJ@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?OnRmsgObItemDBClk@CDlgOptimizer@@IAEJIJ@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?OnRmsgObItemDBClk@CDlgOptimizer@@IAEJIJ@Z$3
	DD	02H
	DD	FLAT:__unwindfunclet$?OnRmsgObItemDBClk@CDlgOptimizer@@IAEJIJ@Z$8
	DD	04H
	DD	FLAT:__unwindfunclet$?OnRmsgObItemDBClk@CDlgOptimizer@@IAEJIJ@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$?OnRmsgObItemDBClk@CDlgOptimizer@@IAEJIJ@Z$9
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?OnSTDataManagerMessagge@CDlgOptimizer@@IAEJIJ@Z DD 019930522H
	DD	011H
	DD	FLAT:__unwindtable$?OnSTDataManagerMessagge@CDlgOptimizer@@IAEJIJ@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?OnSTDataManagerMessagge@CDlgOptimizer@@IAEJIJ@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?OnSTDataManagerMessagge@CDlgOptimizer@@IAEJIJ@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?OnSTDataManagerMessagge@CDlgOptimizer@@IAEJIJ@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?OnSTDataManagerMessagge@CDlgOptimizer@@IAEJIJ@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?OnSTDataManagerMessagge@CDlgOptimizer@@IAEJIJ@Z$3
	DD	00H
	DD	FLAT:__unwindfunclet$?OnSTDataManagerMessagge@CDlgOptimizer@@IAEJIJ@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?OnSTDataManagerMessagge@CDlgOptimizer@@IAEJIJ@Z$5
	DD	04H
	DD	FLAT:__unwindfunclet$?OnSTDataManagerMessagge@CDlgOptimizer@@IAEJIJ@Z$6
	DD	00H
	DD	FLAT:__unwindfunclet$?OnSTDataManagerMessagge@CDlgOptimizer@@IAEJIJ@Z$7
	DD	00H
	DD	FLAT:__unwindfunclet$?OnSTDataManagerMessagge@CDlgOptimizer@@IAEJIJ@Z$8
	DD	00H
	DD	FLAT:__unwindfunclet$?OnSTDataManagerMessagge@CDlgOptimizer@@IAEJIJ@Z$9
	DD	00H
	DD	FLAT:__unwindfunclet$?OnSTDataManagerMessagge@CDlgOptimizer@@IAEJIJ@Z$10
	DD	00H
	DD	FLAT:__unwindfunclet$?OnSTDataManagerMessagge@CDlgOptimizer@@IAEJIJ@Z$11
	DD	00H
	DD	FLAT:__unwindfunclet$?OnSTDataManagerMessagge@CDlgOptimizer@@IAEJIJ@Z$12
	DD	00H
	DD	FLAT:__unwindfunclet$?OnSTDataManagerMessagge@CDlgOptimizer@@IAEJIJ@Z$13
	DD	00H
	DD	FLAT:__unwindfunclet$?OnSTDataManagerMessagge@CDlgOptimizer@@IAEJIJ@Z$14
	DD	00H
	DD	FLAT:__unwindfunclet$?OnSTDataManagerMessagge@CDlgOptimizer@@IAEJIJ@Z$15
	DD	00H
	DD	FLAT:__unwindfunclet$?OnSTDataManagerMessagge@CDlgOptimizer@@IAEJIJ@Z$16
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?OnBtnOpt@CDlgOptimizer@@IAEXXZ DD 019930522H
	DD	011H
	DD	FLAT:__unwindtable$?OnBtnOpt@CDlgOptimizer@@IAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?OnBtnOpt@CDlgOptimizer@@IAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?OnBtnOpt@CDlgOptimizer@@IAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?OnBtnOpt@CDlgOptimizer@@IAEXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?OnBtnOpt@CDlgOptimizer@@IAEXXZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$?OnBtnOpt@CDlgOptimizer@@IAEXXZ$17
	DD	03H
	DD	FLAT:__unwindfunclet$?OnBtnOpt@CDlgOptimizer@@IAEXXZ$18
	DD	04H
	DD	FLAT:__unwindfunclet$?OnBtnOpt@CDlgOptimizer@@IAEXXZ$19
	DD	02H
	DD	FLAT:__unwindfunclet$?OnBtnOpt@CDlgOptimizer@@IAEXXZ$20
	DD	06H
	DD	FLAT:__unwindfunclet$?OnBtnOpt@CDlgOptimizer@@IAEXXZ$7
	DD	02H
	DD	FLAT:__unwindfunclet$?OnBtnOpt@CDlgOptimizer@@IAEXXZ$7
	DD	08H
	DD	FLAT:__unwindfunclet$?OnBtnOpt@CDlgOptimizer@@IAEXXZ$22
	DD	09H
	DD	FLAT:__unwindfunclet$?OnBtnOpt@CDlgOptimizer@@IAEXXZ$9
	DD	08H
	DD	FLAT:__unwindfunclet$?OnBtnOpt@CDlgOptimizer@@IAEXXZ$9
	DD	0bH
	DD	FLAT:__unwindfunclet$?OnBtnOpt@CDlgOptimizer@@IAEXXZ$10
	DD	0bH
	DD	FLAT:__unwindfunclet$?OnBtnOpt@CDlgOptimizer@@IAEXXZ$11
	DD	0dH
	DD	FLAT:__unwindfunclet$?OnBtnOpt@CDlgOptimizer@@IAEXXZ$13
	DD	0eH
	DD	FLAT:__unwindfunclet$?OnBtnOpt@CDlgOptimizer@@IAEXXZ$14
	DD	0fH
	DD	FLAT:__unwindfunclet$?OnBtnOpt@CDlgOptimizer@@IAEXXZ$15
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?OnInitDialog@CDlgOptimizer@@MAEHXZ DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$?OnInitDialog@CDlgOptimizer@@MAEHXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?OnInitDialog@CDlgOptimizer@@MAEHXZ DD 0ffffffffH
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	00H
	DD	02H
	DD	00H
	DD	02H
	DD	00H
	DD	04H
	DD	00H
	DD	04H
	DD	00H
	DD	04H
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?OnNotify@CDlgOptimizer@@MAEHIJPAJ@Z DD 019930522H
	DD	0aH
	DD	FLAT:__unwindtable$?OnNotify@CDlgOptimizer@@MAEHIJPAJ@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?OnNotify@CDlgOptimizer@@MAEHIJPAJ@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?OnNotify@CDlgOptimizer@@MAEHIJPAJ@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?OnNotify@CDlgOptimizer@@MAEHIJPAJ@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?OnNotify@CDlgOptimizer@@MAEHIJPAJ@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?OnNotify@CDlgOptimizer@@MAEHIJPAJ@Z$3
	DD	02H
	DD	FLAT:__unwindfunclet$?OnNotify@CDlgOptimizer@@MAEHIJPAJ@Z$10
	DD	04H
	DD	FLAT:__unwindfunclet$?OnNotify@CDlgOptimizer@@MAEHIJPAJ@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$?OnNotify@CDlgOptimizer@@MAEHIJPAJ@Z$11
	DD	02H
	DD	FLAT:__unwindfunclet$?OnNotify@CDlgOptimizer@@MAEHIJPAJ@Z$7
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?OnNotify@CDlgOptimizer@@MAEHIJPAJ@Z$8
	DD	08H
	DD	FLAT:__unwindfunclet$?OnNotify@CDlgOptimizer@@MAEHIJPAJ@Z$9
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z DD 019930522H
	DD	02bH
	DD	FLAT:__unwindtable$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z$6
	DD	06H
	DD	FLAT:__unwindfunclet$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z$7
	DD	07H
	DD	FLAT:__unwindfunclet$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z$8
	DD	08H
	DD	FLAT:__unwindfunclet$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z$9
	DD	09H
	DD	FLAT:__unwindfunclet$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z$10
	DD	0aH
	DD	FLAT:__unwindfunclet$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z$11
	DD	0bH
	DD	FLAT:__unwindfunclet$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z$12
	DD	0cH
	DD	FLAT:__unwindfunclet$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z$13
	DD	0dH
	DD	FLAT:__unwindfunclet$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z$14
	DD	0eH
	DD	FLAT:__unwindfunclet$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z$15
	DD	0fH
	DD	FLAT:__unwindfunclet$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z$16
	DD	010H
	DD	FLAT:__unwindfunclet$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z$17
	DD	011H
	DD	FLAT:__unwindfunclet$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z$18
	DD	012H
	DD	FLAT:__unwindfunclet$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z$19
	DD	013H
	DD	FLAT:__unwindfunclet$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z$20
	DD	014H
	DD	FLAT:__unwindfunclet$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z$21
	DD	015H
	DD	FLAT:__unwindfunclet$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z$22
	DD	016H
	DD	FLAT:__unwindfunclet$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z$23
	DD	017H
	DD	FLAT:__unwindfunclet$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z$24
	DD	018H
	DD	FLAT:__unwindfunclet$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z$25
	DD	019H
	DD	FLAT:__unwindfunclet$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z$26
	DD	01aH
	DD	FLAT:__unwindfunclet$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z$27
	DD	01bH
	DD	FLAT:__unwindfunclet$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z$28
	DD	01cH
	DD	FLAT:__unwindfunclet$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z$29
	DD	01dH
	DD	FLAT:__unwindfunclet$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z$30
	DD	01eH
	DD	FLAT:__unwindfunclet$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z$31
	DD	01fH
	DD	FLAT:__unwindfunclet$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z$32
	DD	020H
	DD	FLAT:__unwindfunclet$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z$33
	DD	021H
	DD	FLAT:__unwindfunclet$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z$34
	DD	022H
	DD	FLAT:__unwindfunclet$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z$35
	DD	023H
	DD	FLAT:__unwindfunclet$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z$36
	DD	024H
	DD	FLAT:__unwindfunclet$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z$37
	DD	025H
	DD	FLAT:__unwindfunclet$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z$38
	DD	026H
	DD	FLAT:__unwindfunclet$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z$39
	DD	027H
	DD	FLAT:__unwindfunclet$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z$40
	DD	028H
	DD	FLAT:__unwindfunclet$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z$41
	DD	029H
	DD	FLAT:__unwindfunclet$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z$42
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?AfxGetPctrData@@YGJH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AfxGetPctrData@@YGJH@Z$0
__ehfuncinfo$?AfxGetPctrData@@YGJH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?AfxGetPctrData@@YGJH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??1CGdiObject@@UAE@XZ$3 DD 00H
	DD	FLAT:??_R0PAVCException@@@8
	DD	0fffffde4H
	DD	FLAT:__catch$??1CGdiObject@@UAE@XZ$0
__tryblocktable$??1CGdiObject@@UAE@XZ DD 00H
	DD	00H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??1CGdiObject@@UAE@XZ$3
__unwindtable$??1CGdiObject@@UAE@XZ DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	FLAT:__unwindfunclet$??1CGdiObject@@UAE@XZ$2
__ehfuncinfo$??1CGdiObject@@UAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??1CGdiObject@@UAE@XZ
	DD	01H
	DD	FLAT:__tryblocktable$??1CGdiObject@@UAE@XZ
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@ABV10@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@ABV10@PBD@Z$0
__ehfuncinfo$??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@ABV10@PBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@ABV10@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@ABV10@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@ABV10@0@Z$0
__ehfuncinfo$??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@ABV10@0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@ABV10@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
CRT$XCU	SEGMENT
?RMSG_STTREE_ITEMCLICK$initializer$@@3P6AXXZA DD FLAT:??__ERMSG_STTREE_ITEMCLICK@@YAXXZ ; RMSG_STTREE_ITEMCLICK$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?RMSG_STTREE_ITEMDBLCLK$initializer$@@3P6AXXZA DD FLAT:??__ERMSG_STTREE_ITEMDBLCLK@@YAXXZ ; RMSG_STTREE_ITEMDBLCLK$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?RMSG_STDATAMANAGER_RESULTDATA$initializer$@@3P6AXXZA DD FLAT:??__ERMSG_STDATAMANAGER_RESULTDATA@@YAXXZ ; RMSG_STDATAMANAGER_RESULTDATA$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?RMSG_OB_ITEMDBLCLK$initializer$@@3P6AXXZA DD FLAT:??__ERMSG_OB_ITEMDBLCLK@@YAXXZ ; RMSG_OB_ITEMDBLCLK$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?RMSG_GETDLLSIZE$initializer$@@3P6AXXZA DD FLAT:??__ERMSG_GETDLLSIZE@@YAXXZ ; RMSG_GETDLLSIZE$initializer$
CRT$XCU	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ??$SerializeElements@UST_STRGRIDDATA@@@@YGXAAVCArchive@@PAUST_STRGRIDDATA@@H@Z
_TEXT	SEGMENT
_ar$ = 8						; size = 4
_pElements$ = 12					; size = 4
_nCount$ = 16						; size = 4
??$SerializeElements@UST_STRGRIDDATA@@@@YGXAAVCArchive@@PAUST_STRGRIDDATA@@H@Z PROC ; SerializeElements<ST_STRGRIDDATA>, COMDAT

; 67   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 68   : 	ENSURE(nCount == 0 || pElements != NULL);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR _pElements$[ebp]
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b 75 10	 mov	 esi, DWORD PTR _nCount$[ebp]
  0000b	57		 push	 edi
  0000c	85 f6		 test	 esi, esi
  0000e	74 08		 je	 SHORT $LN2@SerializeE
  00010	85 c9		 test	 ecx, ecx
  00012	0f 84 89 00 00
	00		 je	 $LN34@SerializeE
$LN2@SerializeE:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 212  : 	{ return (m_nMode & CArchive::load) == 0; }

  00018	8b 55 08	 mov	 edx, DWORD PTR _ar$[ebp]
  0001b	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0001e	f7 d0		 not	 eax
  00020	a8 01		 test	 al, 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 73   : 	if (ar.IsStoring())

  00022	74 3c		 je	 SHORT $LN10@SerializeE

; 74   : 	{
; 75   : 		TYPE* pData;
; 76   : 		UINT_PTR nElementsLeft;
; 77   : 
; 78   : 		nElementsLeft = nCount;
; 79   : 		pData = pElements;
; 80   : 		while( nElementsLeft > 0 )

  00024	85 f6		 test	 esi, esi
  00026	74 31		 je	 SHORT $LN8@SerializeE
  00028	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL5@SerializeE:

; 81   : 		{
; 82   : 			UINT nElementsToWrite;
; 83   : 
; 84   : 			nElementsToWrite = UINT(__min(nElementsLeft, INT_MAX/sizeof(TYPE)));

  00030	bb ff ff ff 0f	 mov	 ebx, 268435455		; 0fffffffH
  00035	3b f3		 cmp	 esi, ebx
  00037	0f 42 de	 cmovb	 ebx, esi

; 85   : 			ar.Write(pData, nElementsToWrite*sizeof(TYPE));

  0003a	8d 3c dd 00 00
	00 00		 lea	 edi, DWORD PTR [ebx*8]
  00041	57		 push	 edi
  00042	51		 push	 ecx
  00043	8b ca		 mov	 ecx, edx
  00045	e8 00 00 00 00	 call	 ?Write@CArchive@@QAEXPBXI@Z ; CArchive::Write

; 86   : 			nElementsLeft -= nElementsToWrite;
; 87   : 			pData += nElementsToWrite;

  0004a	8b 4d 0c	 mov	 ecx, DWORD PTR _pElements$[ebp]
  0004d	8b 55 08	 mov	 edx, DWORD PTR _ar$[ebp]
  00050	03 cf		 add	 ecx, edi
  00052	89 4d 0c	 mov	 DWORD PTR _pElements$[ebp], ecx
  00055	2b f3		 sub	 esi, ebx
  00057	75 d7		 jne	 SHORT $LL5@SerializeE
$LN8@SerializeE:
  00059	5f		 pop	 edi

; 105  : 		}
; 106  : 	}
; 107  : }

  0005a	5e		 pop	 esi
  0005b	5b		 pop	 ebx
  0005c	5d		 pop	 ebp
  0005d	c2 0c 00	 ret	 12			; 0000000cH
$LN10@SerializeE:

; 97   : 		while( nElementsLeft > 0 )

  00060	85 f6		 test	 esi, esi
  00062	74 f5		 je	 SHORT $LN8@SerializeE
$LL7@SerializeE:

; 98   : 		{
; 99   : 			UINT nElementsToRead;
; 100  : 
; 101  : 			nElementsToRead = UINT(__min(nElementsLeft, INT_MAX/sizeof(TYPE)));

  00064	bf ff ff ff 0f	 mov	 edi, 268435455		; 0fffffffH
  00069	3b f7		 cmp	 esi, edi
  0006b	0f 42 fe	 cmovb	 edi, esi

; 102  : 			ar.EnsureRead(pData, nElementsToRead*sizeof(TYPE));

  0006e	8d 1c fd 00 00
	00 00		 lea	 ebx, DWORD PTR [edi*8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 399  : 	UINT nRead=Read(lpBuf, nCount);

  00075	53		 push	 ebx
  00076	51		 push	 ecx
  00077	8b ca		 mov	 ecx, edx
  00079	e8 00 00 00 00	 call	 ?Read@CArchive@@QAEIPAXI@Z ; CArchive::Read

; 400  : 	if(nRead!=nCount)

  0007e	3b c3		 cmp	 eax, ebx
  00080	75 16		 jne	 SHORT $LN23@SerializeE
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 97   : 		while( nElementsLeft > 0 )

  00082	8b 4d 0c	 mov	 ecx, DWORD PTR _pElements$[ebp]
  00085	8b 55 08	 mov	 edx, DWORD PTR _ar$[ebp]

; 103  : 			nElementsLeft -= nElementsToRead;
; 104  : 			pData += nElementsToRead;

  00088	03 cb		 add	 ecx, ebx
  0008a	89 4d 0c	 mov	 DWORD PTR _pElements$[ebp], ecx
  0008d	2b f7		 sub	 esi, edi
  0008f	75 d3		 jne	 SHORT $LL7@SerializeE

; 105  : 		}
; 106  : 	}
; 107  : }

  00091	5f		 pop	 edi
  00092	5e		 pop	 esi
  00093	5b		 pop	 ebx
  00094	5d		 pop	 ebp
  00095	c2 0c 00	 ret	 12			; 0000000cH
$LN23@SerializeE:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 402  : 		AfxThrowArchiveException(CArchiveException::endOfFile);

  00098	6a 00		 push	 0
  0009a	6a 03		 push	 3
  0009c	e8 00 00 00 00	 call	 ?AfxThrowArchiveException@@YGXHPBD@Z ; AfxThrowArchiveException
$LN34@SerializeE:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 68   : 	ENSURE(nCount == 0 || pElements != NULL);

  000a1	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN32@SerializeE:
  000a6	cc		 int	 3
??$SerializeElements@UST_STRGRIDDATA@@@@YGXAAVCArchive@@PAUST_STRGRIDDATA@@H@Z ENDP ; SerializeElements<ST_STRGRIDDATA>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ??$SerializeElements@UST_GRIDDATA@@@@YGXAAVCArchive@@PAUST_GRIDDATA@@H@Z
_TEXT	SEGMENT
_ar$ = 8						; size = 4
_pElements$ = 12					; size = 4
_nCount$ = 16						; size = 4
??$SerializeElements@UST_GRIDDATA@@@@YGXAAVCArchive@@PAUST_GRIDDATA@@H@Z PROC ; SerializeElements<ST_GRIDDATA>, COMDAT

; 67   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 68   : 	ENSURE(nCount == 0 || pElements != NULL);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR _pElements$[ebp]
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b 75 10	 mov	 esi, DWORD PTR _nCount$[ebp]
  0000b	57		 push	 edi
  0000c	85 f6		 test	 esi, esi
  0000e	74 08		 je	 SHORT $LN2@SerializeE
  00010	85 c9		 test	 ecx, ecx
  00012	0f 84 87 00 00
	00		 je	 $LN34@SerializeE
$LN2@SerializeE:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 212  : 	{ return (m_nMode & CArchive::load) == 0; }

  00018	8b 55 08	 mov	 edx, DWORD PTR _ar$[ebp]
  0001b	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0001e	f7 d0		 not	 eax
  00020	a8 01		 test	 al, 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 73   : 	if (ar.IsStoring())

  00022	74 3b		 je	 SHORT $LN10@SerializeE

; 74   : 	{
; 75   : 		TYPE* pData;
; 76   : 		UINT_PTR nElementsLeft;
; 77   : 
; 78   : 		nElementsLeft = nCount;
; 79   : 		pData = pElements;
; 80   : 		while( nElementsLeft > 0 )

  00024	85 f6		 test	 esi, esi
  00026	74 30		 je	 SHORT $LN8@SerializeE
  00028	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL5@SerializeE:

; 81   : 		{
; 82   : 			UINT nElementsToWrite;
; 83   : 
; 84   : 			nElementsToWrite = UINT(__min(nElementsLeft, INT_MAX/sizeof(TYPE)));

  00030	bb c8 67 dd 00	 mov	 ebx, 14510024		; 00dd67c8H
  00035	3b f3		 cmp	 esi, ebx
  00037	0f 42 de	 cmovb	 ebx, esi

; 85   : 			ar.Write(pData, nElementsToWrite*sizeof(TYPE));

  0003a	69 fb 94 00 00
	00		 imul	 edi, ebx, 148
  00040	57		 push	 edi
  00041	51		 push	 ecx
  00042	8b ca		 mov	 ecx, edx
  00044	e8 00 00 00 00	 call	 ?Write@CArchive@@QAEXPBXI@Z ; CArchive::Write

; 86   : 			nElementsLeft -= nElementsToWrite;
; 87   : 			pData += nElementsToWrite;

  00049	8b 4d 0c	 mov	 ecx, DWORD PTR _pElements$[ebp]
  0004c	8b 55 08	 mov	 edx, DWORD PTR _ar$[ebp]
  0004f	03 cf		 add	 ecx, edi
  00051	89 4d 0c	 mov	 DWORD PTR _pElements$[ebp], ecx
  00054	2b f3		 sub	 esi, ebx
  00056	75 d8		 jne	 SHORT $LL5@SerializeE
$LN8@SerializeE:
  00058	5f		 pop	 edi

; 105  : 		}
; 106  : 	}
; 107  : }

  00059	5e		 pop	 esi
  0005a	5b		 pop	 ebx
  0005b	5d		 pop	 ebp
  0005c	c2 0c 00	 ret	 12			; 0000000cH
$LN10@SerializeE:

; 97   : 		while( nElementsLeft > 0 )

  0005f	85 f6		 test	 esi, esi
  00061	74 f5		 je	 SHORT $LN8@SerializeE
$LL7@SerializeE:

; 98   : 		{
; 99   : 			UINT nElementsToRead;
; 100  : 
; 101  : 			nElementsToRead = UINT(__min(nElementsLeft, INT_MAX/sizeof(TYPE)));

  00063	bf c8 67 dd 00	 mov	 edi, 14510024		; 00dd67c8H
  00068	3b f7		 cmp	 esi, edi
  0006a	0f 42 fe	 cmovb	 edi, esi

; 102  : 			ar.EnsureRead(pData, nElementsToRead*sizeof(TYPE));

  0006d	69 df 94 00 00
	00		 imul	 ebx, edi, 148
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 399  : 	UINT nRead=Read(lpBuf, nCount);

  00073	53		 push	 ebx
  00074	51		 push	 ecx
  00075	8b ca		 mov	 ecx, edx
  00077	e8 00 00 00 00	 call	 ?Read@CArchive@@QAEIPAXI@Z ; CArchive::Read

; 400  : 	if(nRead!=nCount)

  0007c	3b c3		 cmp	 eax, ebx
  0007e	75 16		 jne	 SHORT $LN23@SerializeE
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 97   : 		while( nElementsLeft > 0 )

  00080	8b 4d 0c	 mov	 ecx, DWORD PTR _pElements$[ebp]
  00083	8b 55 08	 mov	 edx, DWORD PTR _ar$[ebp]

; 103  : 			nElementsLeft -= nElementsToRead;
; 104  : 			pData += nElementsToRead;

  00086	03 cb		 add	 ecx, ebx
  00088	89 4d 0c	 mov	 DWORD PTR _pElements$[ebp], ecx
  0008b	2b f7		 sub	 esi, edi
  0008d	75 d4		 jne	 SHORT $LL7@SerializeE

; 105  : 		}
; 106  : 	}
; 107  : }

  0008f	5f		 pop	 edi
  00090	5e		 pop	 esi
  00091	5b		 pop	 ebx
  00092	5d		 pop	 ebp
  00093	c2 0c 00	 ret	 12			; 0000000cH
$LN23@SerializeE:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 402  : 		AfxThrowArchiveException(CArchiveException::endOfFile);

  00096	6a 00		 push	 0
  00098	6a 03		 push	 3
  0009a	e8 00 00 00 00	 call	 ?AfxThrowArchiveException@@YGXHPBD@Z ; AfxThrowArchiveException
$LN34@SerializeE:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 68   : 	ENSURE(nCount == 0 || pElements != NULL);

  0009f	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN32@SerializeE:
  000a4	cc		 int	 3
??$SerializeElements@UST_GRIDDATA@@@@YGXAAVCArchive@@PAUST_GRIDDATA@@H@Z ENDP ; SerializeElements<ST_GRIDDATA>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ??$SerializeElements@UST_RUNVALUE@@@@YGXAAVCArchive@@PAUST_RUNVALUE@@H@Z
_TEXT	SEGMENT
_ar$ = 8						; size = 4
_pElements$ = 12					; size = 4
_nCount$ = 16						; size = 4
??$SerializeElements@UST_RUNVALUE@@@@YGXAAVCArchive@@PAUST_RUNVALUE@@H@Z PROC ; SerializeElements<ST_RUNVALUE>, COMDAT

; 67   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 68   : 	ENSURE(nCount == 0 || pElements != NULL);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR _pElements$[ebp]
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b 75 10	 mov	 esi, DWORD PTR _nCount$[ebp]
  0000b	57		 push	 edi
  0000c	85 f6		 test	 esi, esi
  0000e	74 08		 je	 SHORT $LN2@SerializeE
  00010	85 c9		 test	 ecx, ecx
  00012	0f 84 87 00 00
	00		 je	 $LN34@SerializeE
$LN2@SerializeE:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 212  : 	{ return (m_nMode & CArchive::load) == 0; }

  00018	8b 55 08	 mov	 edx, DWORD PTR _ar$[ebp]
  0001b	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0001e	f7 d0		 not	 eax
  00020	a8 01		 test	 al, 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 73   : 	if (ar.IsStoring())

  00022	74 3b		 je	 SHORT $LN10@SerializeE

; 74   : 	{
; 75   : 		TYPE* pData;
; 76   : 		UINT_PTR nElementsLeft;
; 77   : 
; 78   : 		nElementsLeft = nCount;
; 79   : 		pData = pElements;
; 80   : 		while( nElementsLeft > 0 )

  00024	85 f6		 test	 esi, esi
  00026	74 30		 je	 SHORT $LN8@SerializeE
  00028	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL5@SerializeE:

; 81   : 		{
; 82   : 			UINT nElementsToWrite;
; 83   : 
; 84   : 			nElementsToWrite = UINT(__min(nElementsLeft, INT_MAX/sizeof(TYPE)));

  00030	bb aa aa aa 0a	 mov	 ebx, 178956970		; 0aaaaaaaH
  00035	3b f3		 cmp	 esi, ebx
  00037	0f 42 de	 cmovb	 ebx, esi

; 85   : 			ar.Write(pData, nElementsToWrite*sizeof(TYPE));

  0003a	8d 3c 5b	 lea	 edi, DWORD PTR [ebx+ebx*2]
  0003d	c1 e7 02	 shl	 edi, 2
  00040	57		 push	 edi
  00041	51		 push	 ecx
  00042	8b ca		 mov	 ecx, edx
  00044	e8 00 00 00 00	 call	 ?Write@CArchive@@QAEXPBXI@Z ; CArchive::Write

; 86   : 			nElementsLeft -= nElementsToWrite;
; 87   : 			pData += nElementsToWrite;

  00049	8b 4d 0c	 mov	 ecx, DWORD PTR _pElements$[ebp]
  0004c	8b 55 08	 mov	 edx, DWORD PTR _ar$[ebp]
  0004f	03 cf		 add	 ecx, edi
  00051	89 4d 0c	 mov	 DWORD PTR _pElements$[ebp], ecx
  00054	2b f3		 sub	 esi, ebx
  00056	75 d8		 jne	 SHORT $LL5@SerializeE
$LN8@SerializeE:
  00058	5f		 pop	 edi

; 105  : 		}
; 106  : 	}
; 107  : }

  00059	5e		 pop	 esi
  0005a	5b		 pop	 ebx
  0005b	5d		 pop	 ebp
  0005c	c2 0c 00	 ret	 12			; 0000000cH
$LN10@SerializeE:

; 97   : 		while( nElementsLeft > 0 )

  0005f	85 f6		 test	 esi, esi
  00061	74 f5		 je	 SHORT $LN8@SerializeE
$LL7@SerializeE:

; 98   : 		{
; 99   : 			UINT nElementsToRead;
; 100  : 
; 101  : 			nElementsToRead = UINT(__min(nElementsLeft, INT_MAX/sizeof(TYPE)));

  00063	bf aa aa aa 0a	 mov	 edi, 178956970		; 0aaaaaaaH
  00068	3b f7		 cmp	 esi, edi
  0006a	0f 42 fe	 cmovb	 edi, esi

; 102  : 			ar.EnsureRead(pData, nElementsToRead*sizeof(TYPE));

  0006d	8d 1c 7f	 lea	 ebx, DWORD PTR [edi+edi*2]
  00070	c1 e3 02	 shl	 ebx, 2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 399  : 	UINT nRead=Read(lpBuf, nCount);

  00073	53		 push	 ebx
  00074	51		 push	 ecx
  00075	8b ca		 mov	 ecx, edx
  00077	e8 00 00 00 00	 call	 ?Read@CArchive@@QAEIPAXI@Z ; CArchive::Read

; 400  : 	if(nRead!=nCount)

  0007c	3b c3		 cmp	 eax, ebx
  0007e	75 16		 jne	 SHORT $LN23@SerializeE
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 97   : 		while( nElementsLeft > 0 )

  00080	8b 4d 0c	 mov	 ecx, DWORD PTR _pElements$[ebp]
  00083	8b 55 08	 mov	 edx, DWORD PTR _ar$[ebp]

; 103  : 			nElementsLeft -= nElementsToRead;
; 104  : 			pData += nElementsToRead;

  00086	03 cb		 add	 ecx, ebx
  00088	89 4d 0c	 mov	 DWORD PTR _pElements$[ebp], ecx
  0008b	2b f7		 sub	 esi, edi
  0008d	75 d4		 jne	 SHORT $LL7@SerializeE

; 105  : 		}
; 106  : 	}
; 107  : }

  0008f	5f		 pop	 edi
  00090	5e		 pop	 esi
  00091	5b		 pop	 ebx
  00092	5d		 pop	 ebp
  00093	c2 0c 00	 ret	 12			; 0000000cH
$LN23@SerializeE:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 402  : 		AfxThrowArchiveException(CArchiveException::endOfFile);

  00096	6a 00		 push	 0
  00098	6a 03		 push	 3
  0009a	e8 00 00 00 00	 call	 ?AfxThrowArchiveException@@YGXHPBD@Z ; AfxThrowArchiveException
$LN34@SerializeE:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 68   : 	ENSURE(nCount == 0 || pElements != NULL);

  0009f	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN32@SerializeE:
  000a4	cc		 int	 3
??$SerializeElements@UST_RUNVALUE@@@@YGXAAVCArchive@@PAUST_RUNVALUE@@H@Z ENDP ; SerializeElements<ST_RUNVALUE>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ??$SerializeElements@PAUST_VALUE@@@@YGXAAVCArchive@@PAPAUST_VALUE@@H@Z
_TEXT	SEGMENT
_ar$ = 8						; size = 4
_pElements$ = 12					; size = 4
_nCount$ = 16						; size = 4
??$SerializeElements@PAUST_VALUE@@@@YGXAAVCArchive@@PAPAUST_VALUE@@H@Z PROC ; SerializeElements<ST_VALUE *>, COMDAT

; 67   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 68   : 	ENSURE(nCount == 0 || pElements != NULL);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR _pElements$[ebp]
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b 75 10	 mov	 esi, DWORD PTR _nCount$[ebp]
  0000b	57		 push	 edi
  0000c	85 f6		 test	 esi, esi
  0000e	74 08		 je	 SHORT $LN2@SerializeE
  00010	85 c9		 test	 ecx, ecx
  00012	0f 84 89 00 00
	00		 je	 $LN34@SerializeE
$LN2@SerializeE:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 212  : 	{ return (m_nMode & CArchive::load) == 0; }

  00018	8b 55 08	 mov	 edx, DWORD PTR _ar$[ebp]
  0001b	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0001e	f7 d0		 not	 eax
  00020	a8 01		 test	 al, 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 73   : 	if (ar.IsStoring())

  00022	74 3c		 je	 SHORT $LN10@SerializeE

; 74   : 	{
; 75   : 		TYPE* pData;
; 76   : 		UINT_PTR nElementsLeft;
; 77   : 
; 78   : 		nElementsLeft = nCount;
; 79   : 		pData = pElements;
; 80   : 		while( nElementsLeft > 0 )

  00024	85 f6		 test	 esi, esi
  00026	74 31		 je	 SHORT $LN8@SerializeE
  00028	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL5@SerializeE:

; 81   : 		{
; 82   : 			UINT nElementsToWrite;
; 83   : 
; 84   : 			nElementsToWrite = UINT(__min(nElementsLeft, INT_MAX/sizeof(TYPE)));

  00030	bb ff ff ff 1f	 mov	 ebx, 536870911		; 1fffffffH
  00035	3b f3		 cmp	 esi, ebx
  00037	0f 42 de	 cmovb	 ebx, esi

; 85   : 			ar.Write(pData, nElementsToWrite*sizeof(TYPE));

  0003a	8d 3c 9d 00 00
	00 00		 lea	 edi, DWORD PTR [ebx*4]
  00041	57		 push	 edi
  00042	51		 push	 ecx
  00043	8b ca		 mov	 ecx, edx
  00045	e8 00 00 00 00	 call	 ?Write@CArchive@@QAEXPBXI@Z ; CArchive::Write

; 86   : 			nElementsLeft -= nElementsToWrite;
; 87   : 			pData += nElementsToWrite;

  0004a	8b 4d 0c	 mov	 ecx, DWORD PTR _pElements$[ebp]
  0004d	8b 55 08	 mov	 edx, DWORD PTR _ar$[ebp]
  00050	03 cf		 add	 ecx, edi
  00052	89 4d 0c	 mov	 DWORD PTR _pElements$[ebp], ecx
  00055	2b f3		 sub	 esi, ebx
  00057	75 d7		 jne	 SHORT $LL5@SerializeE
$LN8@SerializeE:
  00059	5f		 pop	 edi

; 105  : 		}
; 106  : 	}
; 107  : }

  0005a	5e		 pop	 esi
  0005b	5b		 pop	 ebx
  0005c	5d		 pop	 ebp
  0005d	c2 0c 00	 ret	 12			; 0000000cH
$LN10@SerializeE:

; 97   : 		while( nElementsLeft > 0 )

  00060	85 f6		 test	 esi, esi
  00062	74 f5		 je	 SHORT $LN8@SerializeE
$LL7@SerializeE:

; 98   : 		{
; 99   : 			UINT nElementsToRead;
; 100  : 
; 101  : 			nElementsToRead = UINT(__min(nElementsLeft, INT_MAX/sizeof(TYPE)));

  00064	bf ff ff ff 1f	 mov	 edi, 536870911		; 1fffffffH
  00069	3b f7		 cmp	 esi, edi
  0006b	0f 42 fe	 cmovb	 edi, esi

; 102  : 			ar.EnsureRead(pData, nElementsToRead*sizeof(TYPE));

  0006e	8d 1c bd 00 00
	00 00		 lea	 ebx, DWORD PTR [edi*4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 399  : 	UINT nRead=Read(lpBuf, nCount);

  00075	53		 push	 ebx
  00076	51		 push	 ecx
  00077	8b ca		 mov	 ecx, edx
  00079	e8 00 00 00 00	 call	 ?Read@CArchive@@QAEIPAXI@Z ; CArchive::Read

; 400  : 	if(nRead!=nCount)

  0007e	3b c3		 cmp	 eax, ebx
  00080	75 16		 jne	 SHORT $LN23@SerializeE
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 97   : 		while( nElementsLeft > 0 )

  00082	8b 4d 0c	 mov	 ecx, DWORD PTR _pElements$[ebp]
  00085	8b 55 08	 mov	 edx, DWORD PTR _ar$[ebp]

; 103  : 			nElementsLeft -= nElementsToRead;
; 104  : 			pData += nElementsToRead;

  00088	03 cb		 add	 ecx, ebx
  0008a	89 4d 0c	 mov	 DWORD PTR _pElements$[ebp], ecx
  0008d	2b f7		 sub	 esi, edi
  0008f	75 d3		 jne	 SHORT $LL7@SerializeE

; 105  : 		}
; 106  : 	}
; 107  : }

  00091	5f		 pop	 edi
  00092	5e		 pop	 esi
  00093	5b		 pop	 ebx
  00094	5d		 pop	 ebp
  00095	c2 0c 00	 ret	 12			; 0000000cH
$LN23@SerializeE:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 402  : 		AfxThrowArchiveException(CArchiveException::endOfFile);

  00098	6a 00		 push	 0
  0009a	6a 03		 push	 3
  0009c	e8 00 00 00 00	 call	 ?AfxThrowArchiveException@@YGXHPBD@Z ; AfxThrowArchiveException
$LN34@SerializeE:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 68   : 	ENSURE(nCount == 0 || pElements != NULL);

  000a1	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN32@SerializeE:
  000a6	cc		 int	 3
??$SerializeElements@PAUST_VALUE@@@@YGXAAVCArchive@@PAPAUST_VALUE@@H@Z ENDP ; SerializeElements<ST_VALUE *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ??$SerializeElements@PAVCDialog@@@@YGXAAVCArchive@@PAPAVCDialog@@H@Z
_TEXT	SEGMENT
_ar$ = 8						; size = 4
_pElements$ = 12					; size = 4
_nCount$ = 16						; size = 4
??$SerializeElements@PAVCDialog@@@@YGXAAVCArchive@@PAPAVCDialog@@H@Z PROC ; SerializeElements<CDialog *>, COMDAT

; 67   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 68   : 	ENSURE(nCount == 0 || pElements != NULL);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR _pElements$[ebp]
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b 75 10	 mov	 esi, DWORD PTR _nCount$[ebp]
  0000b	57		 push	 edi
  0000c	85 f6		 test	 esi, esi
  0000e	74 08		 je	 SHORT $LN2@SerializeE
  00010	85 c9		 test	 ecx, ecx
  00012	0f 84 89 00 00
	00		 je	 $LN34@SerializeE
$LN2@SerializeE:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 212  : 	{ return (m_nMode & CArchive::load) == 0; }

  00018	8b 55 08	 mov	 edx, DWORD PTR _ar$[ebp]
  0001b	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0001e	f7 d0		 not	 eax
  00020	a8 01		 test	 al, 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 73   : 	if (ar.IsStoring())

  00022	74 3c		 je	 SHORT $LN10@SerializeE

; 74   : 	{
; 75   : 		TYPE* pData;
; 76   : 		UINT_PTR nElementsLeft;
; 77   : 
; 78   : 		nElementsLeft = nCount;
; 79   : 		pData = pElements;
; 80   : 		while( nElementsLeft > 0 )

  00024	85 f6		 test	 esi, esi
  00026	74 31		 je	 SHORT $LN8@SerializeE
  00028	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL5@SerializeE:

; 81   : 		{
; 82   : 			UINT nElementsToWrite;
; 83   : 
; 84   : 			nElementsToWrite = UINT(__min(nElementsLeft, INT_MAX/sizeof(TYPE)));

  00030	bb ff ff ff 1f	 mov	 ebx, 536870911		; 1fffffffH
  00035	3b f3		 cmp	 esi, ebx
  00037	0f 42 de	 cmovb	 ebx, esi

; 85   : 			ar.Write(pData, nElementsToWrite*sizeof(TYPE));

  0003a	8d 3c 9d 00 00
	00 00		 lea	 edi, DWORD PTR [ebx*4]
  00041	57		 push	 edi
  00042	51		 push	 ecx
  00043	8b ca		 mov	 ecx, edx
  00045	e8 00 00 00 00	 call	 ?Write@CArchive@@QAEXPBXI@Z ; CArchive::Write

; 86   : 			nElementsLeft -= nElementsToWrite;
; 87   : 			pData += nElementsToWrite;

  0004a	8b 4d 0c	 mov	 ecx, DWORD PTR _pElements$[ebp]
  0004d	8b 55 08	 mov	 edx, DWORD PTR _ar$[ebp]
  00050	03 cf		 add	 ecx, edi
  00052	89 4d 0c	 mov	 DWORD PTR _pElements$[ebp], ecx
  00055	2b f3		 sub	 esi, ebx
  00057	75 d7		 jne	 SHORT $LL5@SerializeE
$LN8@SerializeE:
  00059	5f		 pop	 edi

; 105  : 		}
; 106  : 	}
; 107  : }

  0005a	5e		 pop	 esi
  0005b	5b		 pop	 ebx
  0005c	5d		 pop	 ebp
  0005d	c2 0c 00	 ret	 12			; 0000000cH
$LN10@SerializeE:

; 97   : 		while( nElementsLeft > 0 )

  00060	85 f6		 test	 esi, esi
  00062	74 f5		 je	 SHORT $LN8@SerializeE
$LL7@SerializeE:

; 98   : 		{
; 99   : 			UINT nElementsToRead;
; 100  : 
; 101  : 			nElementsToRead = UINT(__min(nElementsLeft, INT_MAX/sizeof(TYPE)));

  00064	bf ff ff ff 1f	 mov	 edi, 536870911		; 1fffffffH
  00069	3b f7		 cmp	 esi, edi
  0006b	0f 42 fe	 cmovb	 edi, esi

; 102  : 			ar.EnsureRead(pData, nElementsToRead*sizeof(TYPE));

  0006e	8d 1c bd 00 00
	00 00		 lea	 ebx, DWORD PTR [edi*4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 399  : 	UINT nRead=Read(lpBuf, nCount);

  00075	53		 push	 ebx
  00076	51		 push	 ecx
  00077	8b ca		 mov	 ecx, edx
  00079	e8 00 00 00 00	 call	 ?Read@CArchive@@QAEIPAXI@Z ; CArchive::Read

; 400  : 	if(nRead!=nCount)

  0007e	3b c3		 cmp	 eax, ebx
  00080	75 16		 jne	 SHORT $LN23@SerializeE
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 97   : 		while( nElementsLeft > 0 )

  00082	8b 4d 0c	 mov	 ecx, DWORD PTR _pElements$[ebp]
  00085	8b 55 08	 mov	 edx, DWORD PTR _ar$[ebp]

; 103  : 			nElementsLeft -= nElementsToRead;
; 104  : 			pData += nElementsToRead;

  00088	03 cb		 add	 ecx, ebx
  0008a	89 4d 0c	 mov	 DWORD PTR _pElements$[ebp], ecx
  0008d	2b f7		 sub	 esi, edi
  0008f	75 d3		 jne	 SHORT $LL7@SerializeE

; 105  : 		}
; 106  : 	}
; 107  : }

  00091	5f		 pop	 edi
  00092	5e		 pop	 esi
  00093	5b		 pop	 ebx
  00094	5d		 pop	 ebp
  00095	c2 0c 00	 ret	 12			; 0000000cH
$LN23@SerializeE:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 402  : 		AfxThrowArchiveException(CArchiveException::endOfFile);

  00098	6a 00		 push	 0
  0009a	6a 03		 push	 3
  0009c	e8 00 00 00 00	 call	 ?AfxThrowArchiveException@@YGXHPBD@Z ; AfxThrowArchiveException
$LN34@SerializeE:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 68   : 	ENSURE(nCount == 0 || pElements != NULL);

  000a1	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN32@SerializeE:
  000a6	cc		 int	 3
??$SerializeElements@PAVCDialog@@@@YGXAAVCArchive@@PAPAVCDialog@@H@Z ENDP ; SerializeElements<CDialog *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ??$SerializeElements@UST_VALUEOPTIMAZE@@@@YGXAAVCArchive@@PAUST_VALUEOPTIMAZE@@H@Z
_TEXT	SEGMENT
_ar$ = 8						; size = 4
_pElements$ = 12					; size = 4
_nCount$ = 16						; size = 4
??$SerializeElements@UST_VALUEOPTIMAZE@@@@YGXAAVCArchive@@PAUST_VALUEOPTIMAZE@@H@Z PROC ; SerializeElements<ST_VALUEOPTIMAZE>, COMDAT

; 67   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 68   : 	ENSURE(nCount == 0 || pElements != NULL);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR _pElements$[ebp]
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b 75 10	 mov	 esi, DWORD PTR _nCount$[ebp]
  0000b	57		 push	 edi
  0000c	85 f6		 test	 esi, esi
  0000e	74 08		 je	 SHORT $LN2@SerializeE
  00010	85 c9		 test	 ecx, ecx
  00012	0f 84 9a 00 00
	00		 je	 $LN34@SerializeE
$LN2@SerializeE:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 212  : 	{ return (m_nMode & CArchive::load) == 0; }

  00018	8b 55 08	 mov	 edx, DWORD PTR _ar$[ebp]
  0001b	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0001e	f7 d0		 not	 eax
  00020	a8 01		 test	 al, 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 73   : 	if (ar.IsStoring())

  00022	74 41		 je	 SHORT $LN10@SerializeE

; 74   : 	{
; 75   : 		TYPE* pData;
; 76   : 		UINT_PTR nElementsLeft;
; 77   : 
; 78   : 		nElementsLeft = nCount;
; 79   : 		pData = pElements;
; 80   : 		while( nElementsLeft > 0 )

  00024	85 f6		 test	 esi, esi
  00026	74 36		 je	 SHORT $LN8@SerializeE
  00028	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL5@SerializeE:

; 81   : 		{
; 82   : 			UINT nElementsToWrite;
; 83   : 
; 84   : 			nElementsToWrite = UINT(__min(nElementsLeft, INT_MAX/sizeof(TYPE)));

  00030	bb 92 24 49 02	 mov	 ebx, 38347922		; 02492492H
  00035	3b f3		 cmp	 esi, ebx
  00037	0f 42 de	 cmovb	 ebx, esi

; 85   : 			ar.Write(pData, nElementsToWrite*sizeof(TYPE));

  0003a	8d 3c dd 00 00
	00 00		 lea	 edi, DWORD PTR [ebx*8]
  00041	2b fb		 sub	 edi, ebx
  00043	c1 e7 03	 shl	 edi, 3
  00046	57		 push	 edi
  00047	51		 push	 ecx
  00048	8b ca		 mov	 ecx, edx
  0004a	e8 00 00 00 00	 call	 ?Write@CArchive@@QAEXPBXI@Z ; CArchive::Write

; 86   : 			nElementsLeft -= nElementsToWrite;
; 87   : 			pData += nElementsToWrite;

  0004f	8b 4d 0c	 mov	 ecx, DWORD PTR _pElements$[ebp]
  00052	8b 55 08	 mov	 edx, DWORD PTR _ar$[ebp]
  00055	03 cf		 add	 ecx, edi
  00057	89 4d 0c	 mov	 DWORD PTR _pElements$[ebp], ecx
  0005a	2b f3		 sub	 esi, ebx
  0005c	75 d2		 jne	 SHORT $LL5@SerializeE
$LN8@SerializeE:
  0005e	5f		 pop	 edi

; 105  : 		}
; 106  : 	}
; 107  : }

  0005f	5e		 pop	 esi
  00060	5b		 pop	 ebx
  00061	5d		 pop	 ebp
  00062	c2 0c 00	 ret	 12			; 0000000cH
$LN10@SerializeE:

; 97   : 		while( nElementsLeft > 0 )

  00065	85 f6		 test	 esi, esi
  00067	74 f5		 je	 SHORT $LN8@SerializeE
  00069	0f 1f 80 00 00
	00 00		 npad	 7
$LL7@SerializeE:

; 98   : 		{
; 99   : 			UINT nElementsToRead;
; 100  : 
; 101  : 			nElementsToRead = UINT(__min(nElementsLeft, INT_MAX/sizeof(TYPE)));

  00070	bb 92 24 49 02	 mov	 ebx, 38347922		; 02492492H
  00075	3b f3		 cmp	 esi, ebx
  00077	0f 42 de	 cmovb	 ebx, esi

; 102  : 			ar.EnsureRead(pData, nElementsToRead*sizeof(TYPE));

  0007a	8d 3c dd 00 00
	00 00		 lea	 edi, DWORD PTR [ebx*8]
  00081	2b fb		 sub	 edi, ebx
  00083	c1 e7 03	 shl	 edi, 3
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 399  : 	UINT nRead=Read(lpBuf, nCount);

  00086	57		 push	 edi
  00087	51		 push	 ecx
  00088	8b ca		 mov	 ecx, edx
  0008a	e8 00 00 00 00	 call	 ?Read@CArchive@@QAEIPAXI@Z ; CArchive::Read

; 400  : 	if(nRead!=nCount)

  0008f	3b c7		 cmp	 eax, edi
  00091	75 16		 jne	 SHORT $LN23@SerializeE
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 97   : 		while( nElementsLeft > 0 )

  00093	8b 4d 0c	 mov	 ecx, DWORD PTR _pElements$[ebp]
  00096	8b 55 08	 mov	 edx, DWORD PTR _ar$[ebp]

; 103  : 			nElementsLeft -= nElementsToRead;
; 104  : 			pData += nElementsToRead;

  00099	03 cf		 add	 ecx, edi
  0009b	89 4d 0c	 mov	 DWORD PTR _pElements$[ebp], ecx
  0009e	2b f3		 sub	 esi, ebx
  000a0	75 ce		 jne	 SHORT $LL7@SerializeE

; 105  : 		}
; 106  : 	}
; 107  : }

  000a2	5f		 pop	 edi
  000a3	5e		 pop	 esi
  000a4	5b		 pop	 ebx
  000a5	5d		 pop	 ebp
  000a6	c2 0c 00	 ret	 12			; 0000000cH
$LN23@SerializeE:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 402  : 		AfxThrowArchiveException(CArchiveException::endOfFile);

  000a9	6a 00		 push	 0
  000ab	6a 03		 push	 3
  000ad	e8 00 00 00 00	 call	 ?AfxThrowArchiveException@@YGXHPBD@Z ; AfxThrowArchiveException
$LN34@SerializeE:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 68   : 	ENSURE(nCount == 0 || pElements != NULL);

  000b2	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN32@SerializeE:
  000b7	cc		 int	 3
??$SerializeElements@UST_VALUEOPTIMAZE@@@@YGXAAVCArchive@@PAUST_VALUEOPTIMAZE@@H@Z ENDP ; SerializeElements<ST_VALUEOPTIMAZE>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ??$SerializeElements@PAUSTMNG_ITEMINFO@@@@YGXAAVCArchive@@PAPAUSTMNG_ITEMINFO@@H@Z
_TEXT	SEGMENT
_ar$ = 8						; size = 4
_pElements$ = 12					; size = 4
_nCount$ = 16						; size = 4
??$SerializeElements@PAUSTMNG_ITEMINFO@@@@YGXAAVCArchive@@PAPAUSTMNG_ITEMINFO@@H@Z PROC ; SerializeElements<STMNG_ITEMINFO *>, COMDAT

; 67   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 68   : 	ENSURE(nCount == 0 || pElements != NULL);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR _pElements$[ebp]
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b 75 10	 mov	 esi, DWORD PTR _nCount$[ebp]
  0000b	57		 push	 edi
  0000c	85 f6		 test	 esi, esi
  0000e	74 08		 je	 SHORT $LN2@SerializeE
  00010	85 c9		 test	 ecx, ecx
  00012	0f 84 89 00 00
	00		 je	 $LN34@SerializeE
$LN2@SerializeE:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 212  : 	{ return (m_nMode & CArchive::load) == 0; }

  00018	8b 55 08	 mov	 edx, DWORD PTR _ar$[ebp]
  0001b	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0001e	f7 d0		 not	 eax
  00020	a8 01		 test	 al, 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 73   : 	if (ar.IsStoring())

  00022	74 3c		 je	 SHORT $LN10@SerializeE

; 74   : 	{
; 75   : 		TYPE* pData;
; 76   : 		UINT_PTR nElementsLeft;
; 77   : 
; 78   : 		nElementsLeft = nCount;
; 79   : 		pData = pElements;
; 80   : 		while( nElementsLeft > 0 )

  00024	85 f6		 test	 esi, esi
  00026	74 31		 je	 SHORT $LN8@SerializeE
  00028	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL5@SerializeE:

; 81   : 		{
; 82   : 			UINT nElementsToWrite;
; 83   : 
; 84   : 			nElementsToWrite = UINT(__min(nElementsLeft, INT_MAX/sizeof(TYPE)));

  00030	bb ff ff ff 1f	 mov	 ebx, 536870911		; 1fffffffH
  00035	3b f3		 cmp	 esi, ebx
  00037	0f 42 de	 cmovb	 ebx, esi

; 85   : 			ar.Write(pData, nElementsToWrite*sizeof(TYPE));

  0003a	8d 3c 9d 00 00
	00 00		 lea	 edi, DWORD PTR [ebx*4]
  00041	57		 push	 edi
  00042	51		 push	 ecx
  00043	8b ca		 mov	 ecx, edx
  00045	e8 00 00 00 00	 call	 ?Write@CArchive@@QAEXPBXI@Z ; CArchive::Write

; 86   : 			nElementsLeft -= nElementsToWrite;
; 87   : 			pData += nElementsToWrite;

  0004a	8b 4d 0c	 mov	 ecx, DWORD PTR _pElements$[ebp]
  0004d	8b 55 08	 mov	 edx, DWORD PTR _ar$[ebp]
  00050	03 cf		 add	 ecx, edi
  00052	89 4d 0c	 mov	 DWORD PTR _pElements$[ebp], ecx
  00055	2b f3		 sub	 esi, ebx
  00057	75 d7		 jne	 SHORT $LL5@SerializeE
$LN8@SerializeE:
  00059	5f		 pop	 edi

; 105  : 		}
; 106  : 	}
; 107  : }

  0005a	5e		 pop	 esi
  0005b	5b		 pop	 ebx
  0005c	5d		 pop	 ebp
  0005d	c2 0c 00	 ret	 12			; 0000000cH
$LN10@SerializeE:

; 97   : 		while( nElementsLeft > 0 )

  00060	85 f6		 test	 esi, esi
  00062	74 f5		 je	 SHORT $LN8@SerializeE
$LL7@SerializeE:

; 98   : 		{
; 99   : 			UINT nElementsToRead;
; 100  : 
; 101  : 			nElementsToRead = UINT(__min(nElementsLeft, INT_MAX/sizeof(TYPE)));

  00064	bf ff ff ff 1f	 mov	 edi, 536870911		; 1fffffffH
  00069	3b f7		 cmp	 esi, edi
  0006b	0f 42 fe	 cmovb	 edi, esi

; 102  : 			ar.EnsureRead(pData, nElementsToRead*sizeof(TYPE));

  0006e	8d 1c bd 00 00
	00 00		 lea	 ebx, DWORD PTR [edi*4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 399  : 	UINT nRead=Read(lpBuf, nCount);

  00075	53		 push	 ebx
  00076	51		 push	 ecx
  00077	8b ca		 mov	 ecx, edx
  00079	e8 00 00 00 00	 call	 ?Read@CArchive@@QAEIPAXI@Z ; CArchive::Read

; 400  : 	if(nRead!=nCount)

  0007e	3b c3		 cmp	 eax, ebx
  00080	75 16		 jne	 SHORT $LN23@SerializeE
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 97   : 		while( nElementsLeft > 0 )

  00082	8b 4d 0c	 mov	 ecx, DWORD PTR _pElements$[ebp]
  00085	8b 55 08	 mov	 edx, DWORD PTR _ar$[ebp]

; 103  : 			nElementsLeft -= nElementsToRead;
; 104  : 			pData += nElementsToRead;

  00088	03 cb		 add	 ecx, ebx
  0008a	89 4d 0c	 mov	 DWORD PTR _pElements$[ebp], ecx
  0008d	2b f7		 sub	 esi, edi
  0008f	75 d3		 jne	 SHORT $LL7@SerializeE

; 105  : 		}
; 106  : 	}
; 107  : }

  00091	5f		 pop	 edi
  00092	5e		 pop	 esi
  00093	5b		 pop	 ebx
  00094	5d		 pop	 ebp
  00095	c2 0c 00	 ret	 12			; 0000000cH
$LN23@SerializeE:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 402  : 		AfxThrowArchiveException(CArchiveException::endOfFile);

  00098	6a 00		 push	 0
  0009a	6a 03		 push	 3
  0009c	e8 00 00 00 00	 call	 ?AfxThrowArchiveException@@YGXHPBD@Z ; AfxThrowArchiveException
$LN34@SerializeE:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 68   : 	ENSURE(nCount == 0 || pElements != NULL);

  000a1	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN32@SerializeE:
  000a6	cc		 int	 3
??$SerializeElements@PAUSTMNG_ITEMINFO@@@@YGXAAVCArchive@@PAPAUSTMNG_ITEMINFO@@H@Z ENDP ; SerializeElements<STMNG_ITEMINFO *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ??$SerializeElements@N@@YGXAAVCArchive@@PANH@Z
_TEXT	SEGMENT
_ar$ = 8						; size = 4
_pElements$ = 12					; size = 4
_nCount$ = 16						; size = 4
??$SerializeElements@N@@YGXAAVCArchive@@PANH@Z PROC	; SerializeElements<double>, COMDAT

; 67   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 68   : 	ENSURE(nCount == 0 || pElements != NULL);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR _pElements$[ebp]
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b 75 10	 mov	 esi, DWORD PTR _nCount$[ebp]
  0000b	57		 push	 edi
  0000c	85 f6		 test	 esi, esi
  0000e	74 08		 je	 SHORT $LN2@SerializeE
  00010	85 c9		 test	 ecx, ecx
  00012	0f 84 89 00 00
	00		 je	 $LN34@SerializeE
$LN2@SerializeE:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 212  : 	{ return (m_nMode & CArchive::load) == 0; }

  00018	8b 55 08	 mov	 edx, DWORD PTR _ar$[ebp]
  0001b	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0001e	f7 d0		 not	 eax
  00020	a8 01		 test	 al, 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 73   : 	if (ar.IsStoring())

  00022	74 3c		 je	 SHORT $LN10@SerializeE

; 74   : 	{
; 75   : 		TYPE* pData;
; 76   : 		UINT_PTR nElementsLeft;
; 77   : 
; 78   : 		nElementsLeft = nCount;
; 79   : 		pData = pElements;
; 80   : 		while( nElementsLeft > 0 )

  00024	85 f6		 test	 esi, esi
  00026	74 31		 je	 SHORT $LN8@SerializeE
  00028	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL5@SerializeE:

; 81   : 		{
; 82   : 			UINT nElementsToWrite;
; 83   : 
; 84   : 			nElementsToWrite = UINT(__min(nElementsLeft, INT_MAX/sizeof(TYPE)));

  00030	bb ff ff ff 0f	 mov	 ebx, 268435455		; 0fffffffH
  00035	3b f3		 cmp	 esi, ebx
  00037	0f 42 de	 cmovb	 ebx, esi

; 85   : 			ar.Write(pData, nElementsToWrite*sizeof(TYPE));

  0003a	8d 3c dd 00 00
	00 00		 lea	 edi, DWORD PTR [ebx*8]
  00041	57		 push	 edi
  00042	51		 push	 ecx
  00043	8b ca		 mov	 ecx, edx
  00045	e8 00 00 00 00	 call	 ?Write@CArchive@@QAEXPBXI@Z ; CArchive::Write

; 86   : 			nElementsLeft -= nElementsToWrite;
; 87   : 			pData += nElementsToWrite;

  0004a	8b 4d 0c	 mov	 ecx, DWORD PTR _pElements$[ebp]
  0004d	8b 55 08	 mov	 edx, DWORD PTR _ar$[ebp]
  00050	03 cf		 add	 ecx, edi
  00052	89 4d 0c	 mov	 DWORD PTR _pElements$[ebp], ecx
  00055	2b f3		 sub	 esi, ebx
  00057	75 d7		 jne	 SHORT $LL5@SerializeE
$LN8@SerializeE:
  00059	5f		 pop	 edi

; 105  : 		}
; 106  : 	}
; 107  : }

  0005a	5e		 pop	 esi
  0005b	5b		 pop	 ebx
  0005c	5d		 pop	 ebp
  0005d	c2 0c 00	 ret	 12			; 0000000cH
$LN10@SerializeE:

; 97   : 		while( nElementsLeft > 0 )

  00060	85 f6		 test	 esi, esi
  00062	74 f5		 je	 SHORT $LN8@SerializeE
$LL7@SerializeE:

; 98   : 		{
; 99   : 			UINT nElementsToRead;
; 100  : 
; 101  : 			nElementsToRead = UINT(__min(nElementsLeft, INT_MAX/sizeof(TYPE)));

  00064	bf ff ff ff 0f	 mov	 edi, 268435455		; 0fffffffH
  00069	3b f7		 cmp	 esi, edi
  0006b	0f 42 fe	 cmovb	 edi, esi

; 102  : 			ar.EnsureRead(pData, nElementsToRead*sizeof(TYPE));

  0006e	8d 1c fd 00 00
	00 00		 lea	 ebx, DWORD PTR [edi*8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 399  : 	UINT nRead=Read(lpBuf, nCount);

  00075	53		 push	 ebx
  00076	51		 push	 ecx
  00077	8b ca		 mov	 ecx, edx
  00079	e8 00 00 00 00	 call	 ?Read@CArchive@@QAEIPAXI@Z ; CArchive::Read

; 400  : 	if(nRead!=nCount)

  0007e	3b c3		 cmp	 eax, ebx
  00080	75 16		 jne	 SHORT $LN23@SerializeE
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 97   : 		while( nElementsLeft > 0 )

  00082	8b 4d 0c	 mov	 ecx, DWORD PTR _pElements$[ebp]
  00085	8b 55 08	 mov	 edx, DWORD PTR _ar$[ebp]

; 103  : 			nElementsLeft -= nElementsToRead;
; 104  : 			pData += nElementsToRead;

  00088	03 cb		 add	 ecx, ebx
  0008a	89 4d 0c	 mov	 DWORD PTR _pElements$[ebp], ecx
  0008d	2b f7		 sub	 esi, edi
  0008f	75 d3		 jne	 SHORT $LL7@SerializeE

; 105  : 		}
; 106  : 	}
; 107  : }

  00091	5f		 pop	 edi
  00092	5e		 pop	 esi
  00093	5b		 pop	 ebx
  00094	5d		 pop	 ebp
  00095	c2 0c 00	 ret	 12			; 0000000cH
$LN23@SerializeE:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 402  : 		AfxThrowArchiveException(CArchiveException::endOfFile);

  00098	6a 00		 push	 0
  0009a	6a 03		 push	 3
  0009c	e8 00 00 00 00	 call	 ?AfxThrowArchiveException@@YGXHPBD@Z ; AfxThrowArchiveException
$LN34@SerializeE:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 68   : 	ENSURE(nCount == 0 || pElements != NULL);

  000a1	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN32@SerializeE:
  000a6	cc		 int	 3
??$SerializeElements@N@@YGXAAVCArchive@@PANH@Z ENDP	; SerializeElements<double>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
;	COMDAT ??_G?$CList@PAUSTMNG_ITEMINFO@@PAU1@@@UAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_G?$CList@PAUSTMNG_ITEMINFO@@PAU1@@@UAEPAXI@Z PROC	; CList<STMNG_ITEMINFO *,STMNG_ITEMINFO *>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_G?$CList@PAUSTMNG_ITEMINFO@@PAU1@@@UAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 872  : 	m_pBlocks->FreeDataChain();

  00025	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]

; 878  : {

  00028	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0002f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CList@PAUSTMNG_ITEMINFO@@PAU1@@@6B@

; 870  : 	m_nCount = 0;

  00035	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0

; 871  : 	m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;

  0003c	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00043	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  0004a	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 872  : 	m_pBlocks->FreeDataChain();

  00051	e8 00 00 00 00	 call	 ?FreeDataChain@CPlex@@QAEXXZ ; CPlex::FreeDataChain

; 873  : 	m_pBlocks = NULL;

  00056	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00059	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
  00060	a8 01		 test	 al, 1
  00062	74 2c		 je	 SHORT $LN22@scalar
  00064	a8 04		 test	 al, 4
  00066	75 1d		 jne	 SHORT $LN3@scalar
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 112  : 	{ ::operator delete(p); }

  00068	56		 push	 esi
  00069	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0006e	83 c4 04	 add	 esp, 4
  00071	8b c6		 mov	 eax, esi
  00073	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00076	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007d	59		 pop	 ecx
  0007e	5e		 pop	 esi
  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c2 04 00	 ret	 4
$LN3@scalar:
  00085	6a 1c		 push	 28			; 0000001cH
  00087	56		 push	 esi
  00088	e8 00 00 00 00	 call	 ?__global_delete@@YAXPAXI@Z ; __global_delete
  0008d	83 c4 08	 add	 esp, 8
$LN22@scalar:
  00090	8b c6		 mov	 eax, esi
  00092	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00095	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0009c	59		 pop	 ecx
  0009d	5e		 pop	 esi
  0009e	8b e5		 mov	 esp, ebp
  000a0	5d		 pop	 ebp
  000a1	c2 04 00	 ret	 4
  000a4	cc		 int	 3
  000a5	cc		 int	 3
  000a6	cc		 int	 3
  000a7	cc		 int	 3
  000a8	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??_G?$CList@PAUSTMNG_ITEMINFO@@PAU1@@@UAEPAXI@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_G?$CList@PAUSTMNG_ITEMINFO@@PAU1@@@UAEPAXI@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_G?$CList@PAUSTMNG_ITEMINFO@@PAU1@@@UAEPAXI@Z ENDP	; CList<STMNG_ITEMINFO *,STMNG_ITEMINFO *>::`scalar deleting destructor'
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ?Serialize@?$CList@PAUSTMNG_ITEMINFO@@PAU1@@@UAEXAAVCArchive@@@Z
_TEXT	SEGMENT
_nNewCount$1$ = -16					; size = 4
_newData$1 = -12					; size = 4
_pData$1$ = -8						; size = 4
_pData$1$ = -8						; size = 4
_pNode$1$ = -8						; size = 4
_nElementsLeft$1$ = -4					; size = 4
_this$1$ = -4						; size = 4
_ar$ = 8						; size = 4
?Serialize@?$CList@PAUSTMNG_ITEMINFO@@PAU1@@@UAEXAAVCArchive@@@Z PROC ; CList<STMNG_ITEMINFO *,STMNG_ITEMINFO *>::Serialize, COMDAT
; _this$ = ecx

; 1169 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx
  00007	8b d9		 mov	 ebx, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 212  : 	{ return (m_nMode & CArchive::load) == 0; }

  00009	8b 4d 08	 mov	 ecx, DWORD PTR _ar$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 1169 : {

  0000c	56		 push	 esi
  0000d	57		 push	 edi
  0000e	89 5d fc	 mov	 DWORD PTR _this$1$[ebp], ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 212  : 	{ return (m_nMode & CArchive::load) == 0; }

  00011	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  00014	f7 d0		 not	 eax
  00016	a8 01		 test	 al, 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 1174 : 	if (ar.IsStoring())

  00018	0f 84 ae 00 00
	00		 je	 $LN7@Serialize

; 1175 : 	{
; 1176 : 		ar.WriteCount(m_nCount);

  0001e	ff 73 0c	 push	 DWORD PTR [ebx+12]
  00021	e8 00 00 00 00	 call	 ?WriteCount@CArchive@@QAEXK@Z ; CArchive::WriteCount

; 1177 : 		for (CNode* pNode = m_pNodeHead; pNode != NULL; pNode = pNode->pNext)

  00026	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00029	89 45 f8	 mov	 DWORD PTR _pNode$1$[ebp], eax
  0002c	85 c0		 test	 eax, eax
  0002e	0f 84 b9 01 00
	00		 je	 $LN86@Serialize
$LL4@Serialize:

; 1178 : 		{
; 1179 : 			ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 1180 : 			TYPE* pData;
; 1181 : 			/*
; 1182 : 			 * in some cases the & operator might be overloaded, and we cannot use it to obtain
; 1183 : 			 * the address of a given object.  We then use the following trick to get the address
; 1184 : 			 */
; 1185 : 			pData = reinterpret_cast< TYPE* >( &reinterpret_cast< int& >( static_cast< TYPE& >( pNode->data ) ) );

  00034	8d 70 08	 lea	 esi, DWORD PTR [eax+8]

; 68   : 	ENSURE(nCount == 0 || pElements != NULL);

  00037	85 f6		 test	 esi, esi
  00039	0f 84 c0 01 00
	00		 je	 $LN76@Serialize
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 212  : 	{ return (m_nMode & CArchive::load) == 0; }

  0003f	8b 4d 08	 mov	 ecx, DWORD PTR _ar$[ebp]
  00042	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  00045	f7 d0		 not	 eax
  00047	a8 01		 test	 al, 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 73   : 	if (ar.IsStoring())

  00049	74 33		 je	 SHORT $LN21@Serialize

; 74   : 	{
; 75   : 		TYPE* pData;
; 76   : 		UINT_PTR nElementsLeft;
; 77   : 
; 78   : 		nElementsLeft = nCount;

  0004b	b8 01 00 00 00	 mov	 eax, 1
  00050	89 45 fc	 mov	 DWORD PTR _nElementsLeft$1$[ebp], eax
$LL16@Serialize:

; 80   : 		while( nElementsLeft > 0 )
; 81   : 		{
; 82   : 			UINT nElementsToWrite;
; 83   : 
; 84   : 			nElementsToWrite = UINT(__min(nElementsLeft, INT_MAX/sizeof(TYPE)));

  00053	bb ff ff ff 1f	 mov	 ebx, 536870911		; 1fffffffH
  00058	3b c3		 cmp	 eax, ebx
  0005a	0f 42 d8	 cmovb	 ebx, eax

; 85   : 			ar.Write(pData, nElementsToWrite*sizeof(TYPE));

  0005d	8d 3c 9d 00 00
	00 00		 lea	 edi, DWORD PTR [ebx*4]
  00064	57		 push	 edi
  00065	56		 push	 esi
  00066	e8 00 00 00 00	 call	 ?Write@CArchive@@QAEXPBXI@Z ; CArchive::Write

; 86   : 			nElementsLeft -= nElementsToWrite;

  0006b	8b 45 fc	 mov	 eax, DWORD PTR _nElementsLeft$1$[ebp]

; 87   : 			pData += nElementsToWrite;

  0006e	03 f7		 add	 esi, edi
  00070	8b 4d 08	 mov	 ecx, DWORD PTR _ar$[ebp]
  00073	2b c3		 sub	 eax, ebx
  00075	89 45 fc	 mov	 DWORD PTR _nElementsLeft$1$[ebp], eax
  00078	85 c0		 test	 eax, eax
  0007a	75 d7		 jne	 SHORT $LL16@Serialize

; 88   : 		}
; 89   : 	}

  0007c	eb 35		 jmp	 SHORT $LN2@Serialize
$LN21@Serialize:

; 90   : 	else
; 91   : 	{
; 92   : 		TYPE* pData;
; 93   : 		UINT_PTR nElementsLeft;
; 94   : 
; 95   : 		nElementsLeft = nCount;

  0007e	bf 01 00 00 00	 mov	 edi, 1
$LL18@Serialize:

; 98   : 		{
; 99   : 			UINT nElementsToRead;
; 100  : 
; 101  : 			nElementsToRead = UINT(__min(nElementsLeft, INT_MAX/sizeof(TYPE)));

  00083	bb ff ff ff 1f	 mov	 ebx, 536870911		; 1fffffffH
  00088	3b fb		 cmp	 edi, ebx
  0008a	0f 42 df	 cmovb	 ebx, edi

; 102  : 			ar.EnsureRead(pData, nElementsToRead*sizeof(TYPE));

  0008d	8d 04 9d 00 00
	00 00		 lea	 eax, DWORD PTR [ebx*4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 399  : 	UINT nRead=Read(lpBuf, nCount);

  00094	50		 push	 eax
  00095	56		 push	 esi
  00096	e8 00 00 00 00	 call	 ?Read@CArchive@@QAEIPAXI@Z ; CArchive::Read

; 400  : 	if(nRead!=nCount)

  0009b	8d 0c 9d 00 00
	00 00		 lea	 ecx, DWORD PTR [ebx*4]
  000a2	3b c1		 cmp	 eax, ecx
  000a4	0f 85 4c 01 00
	00		 jne	 $LN75@Serialize
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 97   : 		while( nElementsLeft > 0 )

  000aa	03 f1		 add	 esi, ecx
  000ac	8b 4d 08	 mov	 ecx, DWORD PTR _ar$[ebp]

; 103  : 			nElementsLeft -= nElementsToRead;

  000af	2b fb		 sub	 edi, ebx
  000b1	75 d0		 jne	 SHORT $LL18@Serialize
$LN2@Serialize:

; 1177 : 		for (CNode* pNode = m_pNodeHead; pNode != NULL; pNode = pNode->pNext)

  000b3	8b 45 f8	 mov	 eax, DWORD PTR _pNode$1$[ebp]
  000b6	8b 00		 mov	 eax, DWORD PTR [eax]
  000b8	89 45 f8	 mov	 DWORD PTR _pNode$1$[ebp], eax
  000bb	85 c0		 test	 eax, eax
  000bd	0f 85 71 ff ff
	ff		 jne	 $LL4@Serialize

; 1197 : 		}
; 1198 : 	}
; 1199 : }

  000c3	5f		 pop	 edi
  000c4	5e		 pop	 esi
  000c5	5b		 pop	 ebx
  000c6	8b e5		 mov	 esp, ebp
  000c8	5d		 pop	 ebp
  000c9	c2 04 00	 ret	 4
$LN7@Serialize:

; 1186 : 			SerializeElements<TYPE>(ar, pData, 1);
; 1187 : 		}
; 1188 : 	}
; 1189 : 	else
; 1190 : 	{
; 1191 : 		DWORD_PTR nNewCount = ar.ReadCount();

  000cc	e8 00 00 00 00	 call	 ?ReadCount@CArchive@@QAEKXZ ; CArchive::ReadCount

; 1192 : 		while (nNewCount--)

  000d1	85 c0		 test	 eax, eax
  000d3	0f 84 14 01 00
	00		 je	 $LN86@Serialize
  000d9	0f 1f 80 00 00
	00 00		 npad	 7
$LL5@Serialize:
  000e0	48		 dec	 eax
  000e1	89 45 f0	 mov	 DWORD PTR _nNewCount$1$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 212  : 	{ return (m_nMode & CArchive::load) == 0; }

  000e4	8b 45 08	 mov	 eax, DWORD PTR _ar$[ebp]
  000e7	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  000ea	f7 d1		 not	 ecx
  000ec	f6 c1 01	 test	 cl, 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 73   : 	if (ar.IsStoring())

  000ef	74 3d		 je	 SHORT $LN42@Serialize

; 79   : 		pData = pElements;

  000f1	8d 4d f4	 lea	 ecx, DWORD PTR _newData$1[ebp]
  000f4	bb 01 00 00 00	 mov	 ebx, 1
  000f9	89 4d f8	 mov	 DWORD PTR _pData$1$[ebp], ecx
  000fc	0f 1f 40 00	 npad	 4
$LL37@Serialize:

; 80   : 		while( nElementsLeft > 0 )
; 81   : 		{
; 82   : 			UINT nElementsToWrite;
; 83   : 
; 84   : 			nElementsToWrite = UINT(__min(nElementsLeft, INT_MAX/sizeof(TYPE)));

  00100	bf ff ff ff 1f	 mov	 edi, 536870911		; 1fffffffH
  00105	3b df		 cmp	 ebx, edi
  00107	0f 42 fb	 cmovb	 edi, ebx

; 85   : 			ar.Write(pData, nElementsToWrite*sizeof(TYPE));

  0010a	8d 34 bd 00 00
	00 00		 lea	 esi, DWORD PTR [edi*4]
  00111	56		 push	 esi
  00112	51		 push	 ecx
  00113	8b c8		 mov	 ecx, eax
  00115	e8 00 00 00 00	 call	 ?Write@CArchive@@QAEXPBXI@Z ; CArchive::Write

; 87   : 			pData += nElementsToWrite;

  0011a	8b 4d f8	 mov	 ecx, DWORD PTR _pData$1$[ebp]
  0011d	8b 45 08	 mov	 eax, DWORD PTR _ar$[ebp]
  00120	03 ce		 add	 ecx, esi
  00122	89 4d f8	 mov	 DWORD PTR _pData$1$[ebp], ecx
  00125	2b df		 sub	 ebx, edi
  00127	75 d7		 jne	 SHORT $LL37@Serialize

; 88   : 		}
; 89   : 	}

  00129	8b 5d fc	 mov	 ebx, DWORD PTR _this$1$[ebp]
  0012c	eb 4a		 jmp	 SHORT $LN40@Serialize
$LN42@Serialize:

; 96   : 		pData = pElements;

  0012e	8d 55 f4	 lea	 edx, DWORD PTR _newData$1[ebp]
  00131	be 01 00 00 00	 mov	 esi, 1
  00136	89 55 f8	 mov	 DWORD PTR _pData$1$[ebp], edx
  00139	0f 1f 80 00 00
	00 00		 npad	 7
$LL39@Serialize:

; 98   : 		{
; 99   : 			UINT nElementsToRead;
; 100  : 
; 101  : 			nElementsToRead = UINT(__min(nElementsLeft, INT_MAX/sizeof(TYPE)));

  00140	bf ff ff ff 1f	 mov	 edi, 536870911		; 1fffffffH
  00145	3b f7		 cmp	 esi, edi
  00147	0f 42 fe	 cmovb	 edi, esi

; 102  : 			ar.EnsureRead(pData, nElementsToRead*sizeof(TYPE));

  0014a	8d 0c bd 00 00
	00 00		 lea	 ecx, DWORD PTR [edi*4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 399  : 	UINT nRead=Read(lpBuf, nCount);

  00151	51		 push	 ecx
  00152	52		 push	 edx
  00153	8b c8		 mov	 ecx, eax
  00155	e8 00 00 00 00	 call	 ?Read@CArchive@@QAEIPAXI@Z ; CArchive::Read

; 400  : 	if(nRead!=nCount)

  0015a	8d 0c bd 00 00
	00 00		 lea	 ecx, DWORD PTR [edi*4]
  00161	3b c1		 cmp	 eax, ecx
  00163	0f 85 8d 00 00
	00		 jne	 $LN75@Serialize
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 97   : 		while( nElementsLeft > 0 )

  00169	8b 55 f8	 mov	 edx, DWORD PTR _pData$1$[ebp]
  0016c	8b 45 08	 mov	 eax, DWORD PTR _ar$[ebp]

; 104  : 			pData += nElementsToRead;

  0016f	03 d1		 add	 edx, ecx
  00171	89 55 f8	 mov	 DWORD PTR _pData$1$[ebp], edx
  00174	2b f7		 sub	 esi, edi
  00176	75 c8		 jne	 SHORT $LL39@Serialize
$LN40@Serialize:

; 902  : 	if (m_pNodeFree == NULL)

  00178	83 7b 10 00	 cmp	 DWORD PTR [ebx+16], 0

; 1193 : 		{
; 1194 : 			TYPE newData[1];
; 1195 : 			SerializeElements<TYPE>(ar, newData, 1);
; 1196 : 			AddTail(newData[0]);

  0017c	8b 75 f4	 mov	 esi, DWORD PTR _newData$1[ebp]

; 968  : 	CNode* pNewNode = NewNode(m_pNodeTail, NULL);

  0017f	8b 7b 08	 mov	 edi, DWORD PTR [ebx+8]

; 902  : 	if (m_pNodeFree == NULL)

  00182	75 32		 jne	 SHORT $LN63@Serialize

; 903  : 	{
; 904  : 		// add another block
; 905  : 		CPlex* pNewBlock = CPlex::Create(m_pBlocks, m_nBlockSize,

  00184	6a 0c		 push	 12			; 0000000cH
  00186	ff 73 18	 push	 DWORD PTR [ebx+24]
  00189	8d 43 14	 lea	 eax, DWORD PTR [ebx+20]
  0018c	50		 push	 eax
  0018d	e8 00 00 00 00	 call	 ?Create@CPlex@@SGPAU1@AAPAU1@II@Z ; CPlex::Create

; 906  : 				 sizeof(CNode));
; 907  : 
; 908  : 		// chain them into free list
; 909  : 		CNode* pNode = (CNode*) pNewBlock->data();
; 910  : 		// free in reverse order to make it easier to debug
; 911  : 		pNode += m_nBlockSize - 1;

  00192	8b 53 18	 mov	 edx, DWORD PTR [ebx+24]
  00195	83 c0 08	 add	 eax, 8
  00198	8d 4a ff	 lea	 ecx, DWORD PTR [edx-1]

; 912  : 		for (INT_PTR i = m_nBlockSize-1; i >= 0; i--, pNode--)

  0019b	83 c2 ff	 add	 edx, -1
  0019e	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]
  001a1	8d 0c 88	 lea	 ecx, DWORD PTR [eax+ecx*4]
  001a4	78 10		 js	 SHORT $LN63@Serialize
$LL60@Serialize:

; 913  : 		{
; 914  : 			pNode->pNext = m_pNodeFree;

  001a6	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  001a9	89 01		 mov	 DWORD PTR [ecx], eax

; 915  : 			m_pNodeFree = pNode;

  001ab	89 4b 10	 mov	 DWORD PTR [ebx+16], ecx
  001ae	83 e9 0c	 sub	 ecx, 12			; 0000000cH
  001b1	83 ea 01	 sub	 edx, 1
  001b4	79 f0		 jns	 SHORT $LL60@Serialize
$LN63@Serialize:

; 916  : 		}
; 917  : 	}
; 918  : 	ENSURE(m_pNodeFree != NULL);  // we must have something

  001b6	8b 4b 10	 mov	 ecx, DWORD PTR [ebx+16]
  001b9	85 c9		 test	 ecx, ecx
  001bb	74 42		 je	 SHORT $LN76@Serialize

; 919  : 
; 920  : 	CList::CNode* pNode = m_pNodeFree;
; 921  : 	m_pNodeFree = m_pNodeFree->pNext;

  001bd	8b 01		 mov	 eax, DWORD PTR [ecx]
  001bf	89 43 10	 mov	 DWORD PTR [ebx+16], eax

; 922  : 	pNode->pPrev = pPrev;

  001c2	89 79 04	 mov	 DWORD PTR [ecx+4], edi

; 923  : 	pNode->pNext = pNext;

  001c5	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 924  : 	m_nCount++;

  001cb	ff 43 0c	 inc	 DWORD PTR [ebx+12]

; 969  : 	pNewNode->data = newElement;

  001ce	89 71 08	 mov	 DWORD PTR [ecx+8], esi

; 970  : 	if (m_pNodeTail != NULL)

  001d1	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  001d4	85 c0		 test	 eax, eax
  001d6	74 04		 je	 SHORT $LN54@Serialize

; 971  : 		m_pNodeTail->pNext = pNewNode;

  001d8	89 08		 mov	 DWORD PTR [eax], ecx
  001da	eb 03		 jmp	 SHORT $LN55@Serialize
$LN54@Serialize:

; 972  : 	else
; 973  : 		m_pNodeHead = pNewNode;

  001dc	89 4b 04	 mov	 DWORD PTR [ebx+4], ecx
$LN55@Serialize:

; 1192 : 		while (nNewCount--)

  001df	8b 45 f0	 mov	 eax, DWORD PTR _nNewCount$1$[ebp]

; 974  : 	m_pNodeTail = pNewNode;

  001e2	89 4b 08	 mov	 DWORD PTR [ebx+8], ecx

; 1192 : 		while (nNewCount--)

  001e5	85 c0		 test	 eax, eax
  001e7	0f 85 f3 fe ff
	ff		 jne	 $LL5@Serialize
$LN86@Serialize:
  001ed	5f		 pop	 edi

; 1197 : 		}
; 1198 : 	}
; 1199 : }

  001ee	5e		 pop	 esi
  001ef	5b		 pop	 ebx
  001f0	8b e5		 mov	 esp, ebp
  001f2	5d		 pop	 ebp
  001f3	c2 04 00	 ret	 4
$LN75@Serialize:
  001f6	6a 00		 push	 0
  001f8	6a 03		 push	 3
  001fa	e8 00 00 00 00	 call	 ?AfxThrowArchiveException@@YGXHPBD@Z ; AfxThrowArchiveException
$LN76@Serialize:
  001ff	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN105@Serialize:
  00204	cc		 int	 3
?Serialize@?$CList@PAUSTMNG_ITEMINFO@@PAU1@@@UAEXAAVCArchive@@@Z ENDP ; CList<STMNG_ITEMINFO *,STMNG_ITEMINFO *>::Serialize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ??1?$CList@PAUSTMNG_ITEMINFO@@PAU1@@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$CList@PAUSTMNG_ITEMINFO@@PAU1@@@UAE@XZ PROC	; CList<STMNG_ITEMINFO *,STMNG_ITEMINFO *>::~CList<STMNG_ITEMINFO *,STMNG_ITEMINFO *>, COMDAT
; _this$ = ecx

; 878  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$CList@PAUSTMNG_ITEMINFO@@PAU1@@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx

; 872  : 	m_pBlocks->FreeDataChain();

  00025	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]

; 878  : {

  00028	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CList@PAUSTMNG_ITEMINFO@@PAU1@@@6B@

; 870  : 	m_nCount = 0;

  0002e	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0

; 871  : 	m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;

  00035	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0003c	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00043	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 872  : 	m_pBlocks->FreeDataChain();

  0004a	e8 00 00 00 00	 call	 ?FreeDataChain@CPlex@@QAEXXZ ; CPlex::FreeDataChain

; 873  : 	m_pBlocks = NULL;

  0004f	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 879  : 	RemoveAll();
; 880  : 	ASSERT(m_nCount == 0);
; 881  : }

  00056	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00059	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00060	59		 pop	 ecx
  00061	5e		 pop	 esi
  00062	8b e5		 mov	 esp, ebp
  00064	5d		 pop	 ebp
  00065	c3		 ret	 0
  00066	cc		 int	 3
  00067	cc		 int	 3
  00068	cc		 int	 3
  00069	cc		 int	 3
  0006a	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CList@PAUSTMNG_ITEMINFO@@PAU1@@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$CList@PAUSTMNG_ITEMINFO@@PAU1@@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$CList@PAUSTMNG_ITEMINFO@@PAU1@@@UAE@XZ ENDP	; CList<STMNG_ITEMINFO *,STMNG_ITEMINFO *>::~CList<STMNG_ITEMINFO *,STMNG_ITEMINFO *>
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ?NewNode@?$CList@PAUSTMNG_ITEMINFO@@PAU1@@@IAEPAUCNode@1@PAU21@0@Z
_TEXT	SEGMENT
_pPrev$ = 8						; size = 4
_pNext$ = 12						; size = 4
?NewNode@?$CList@PAUSTMNG_ITEMINFO@@PAU1@@@IAEPAUCNode@1@PAU21@0@Z PROC ; CList<STMNG_ITEMINFO *,STMNG_ITEMINFO *>::NewNode, COMDAT
; _this$ = ecx

; 901  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 902  : 	if (m_pNodeFree == NULL)

  00006	83 7e 10 00	 cmp	 DWORD PTR [esi+16], 0
  0000a	75 34		 jne	 SHORT $LN7@NewNode

; 903  : 	{
; 904  : 		// add another block
; 905  : 		CPlex* pNewBlock = CPlex::Create(m_pBlocks, m_nBlockSize,

  0000c	6a 0c		 push	 12			; 0000000cH
  0000e	ff 76 18	 push	 DWORD PTR [esi+24]
  00011	8d 46 14	 lea	 eax, DWORD PTR [esi+20]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ?Create@CPlex@@SGPAU1@AAPAU1@II@Z ; CPlex::Create

; 906  : 				 sizeof(CNode));
; 907  : 
; 908  : 		// chain them into free list
; 909  : 		CNode* pNode = (CNode*) pNewBlock->data();
; 910  : 		// free in reverse order to make it easier to debug
; 911  : 		pNode += m_nBlockSize - 1;

  0001a	8b 56 18	 mov	 edx, DWORD PTR [esi+24]
  0001d	83 c0 08	 add	 eax, 8
  00020	8d 0c 52	 lea	 ecx, DWORD PTR [edx+edx*2]
  00023	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  00026	83 c0 f4	 add	 eax, -12		; fffffff4H

; 912  : 		for (INT_PTR i = m_nBlockSize-1; i >= 0; i--, pNode--)

  00029	83 c2 ff	 add	 edx, -1
  0002c	78 12		 js	 SHORT $LN7@NewNode
  0002e	66 90		 npad	 2
$LL4@NewNode:

; 913  : 		{
; 914  : 			pNode->pNext = m_pNodeFree;

  00030	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00033	89 08		 mov	 DWORD PTR [eax], ecx

; 915  : 			m_pNodeFree = pNode;

  00035	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00038	83 e8 0c	 sub	 eax, 12			; 0000000cH
  0003b	83 ea 01	 sub	 edx, 1
  0003e	79 f0		 jns	 SHORT $LL4@NewNode
$LN7@NewNode:

; 916  : 		}
; 917  : 	}
; 918  : 	ENSURE(m_pNodeFree != NULL);  // we must have something

  00040	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00043	85 c0		 test	 eax, eax
  00045	74 18		 je	 SHORT $LN17@NewNode

; 919  : 
; 920  : 	CList::CNode* pNode = m_pNodeFree;
; 921  : 	m_pNodeFree = m_pNodeFree->pNext;

  00047	8b 08		 mov	 ecx, DWORD PTR [eax]
  00049	89 4e 10	 mov	 DWORD PTR [esi+16], ecx

; 922  : 	pNode->pPrev = pPrev;

  0004c	8b 4d 08	 mov	 ecx, DWORD PTR _pPrev$[ebp]
  0004f	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 923  : 	pNode->pNext = pNext;

  00052	8b 4d 0c	 mov	 ecx, DWORD PTR _pNext$[ebp]
  00055	89 08		 mov	 DWORD PTR [eax], ecx

; 924  : 	m_nCount++;

  00057	ff 46 0c	 inc	 DWORD PTR [esi+12]

; 925  : 	ASSERT(m_nCount > 0);  // make sure we don't overflow
; 926  : 
; 927  : #pragma push_macro("new")
; 928  : #undef new
; 929  : 	::new( (void*)( &pNode->data ) ) TYPE;
; 930  : #pragma pop_macro("new")
; 931  : 	return pNode;

  0005a	5e		 pop	 esi

; 932  : }

  0005b	5d		 pop	 ebp
  0005c	c2 08 00	 ret	 8
$LN17@NewNode:

; 916  : 		}
; 917  : 	}
; 918  : 	ENSURE(m_pNodeFree != NULL);  // we must have something

  0005f	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN15@NewNode:
  00064	cc		 int	 3
?NewNode@?$CList@PAUSTMNG_ITEMINFO@@PAU1@@@IAEPAUCNode@1@PAU21@0@Z ENDP ; CList<STMNG_ITEMINFO *,STMNG_ITEMINFO *>::NewNode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ?RemoveAll@?$CList@PAUSTMNG_ITEMINFO@@PAU1@@@QAEXXZ
_TEXT	SEGMENT
?RemoveAll@?$CList@PAUSTMNG_ITEMINFO@@PAU1@@@QAEXXZ PROC ; CList<STMNG_ITEMINFO *,STMNG_ITEMINFO *>::RemoveAll, COMDAT
; _this$ = ecx

; 862  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 863  : 	ASSERT_VALID(this);
; 864  : 
; 865  : 	// destroy elements
; 866  : 	CNode* pNode;
; 867  : 	for (pNode = m_pNodeHead; pNode != NULL; pNode = pNode->pNext)
; 868  : 		pNode->data.~TYPE();
; 869  : 
; 870  : 	m_nCount = 0;
; 871  : 	m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
; 872  : 	m_pBlocks->FreeDataChain();

  00003	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00006	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  0000d	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00014	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  0001b	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00022	e8 00 00 00 00	 call	 ?FreeDataChain@CPlex@@QAEXXZ ; CPlex::FreeDataChain

; 873  : 	m_pBlocks = NULL;

  00027	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
  0002e	5e		 pop	 esi

; 874  : }

  0002f	c3		 ret	 0
?RemoveAll@?$CList@PAUSTMNG_ITEMINFO@@PAU1@@@QAEXXZ ENDP ; CList<STMNG_ITEMINFO *,STMNG_ITEMINFO *>::RemoveAll
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ?AddTail@?$CList@PAUSTMNG_ITEMINFO@@PAU1@@@QAEPAU__POSITION@@PAUSTMNG_ITEMINFO@@@Z
_TEXT	SEGMENT
_newElement$ = 8					; size = 4
?AddTail@?$CList@PAUSTMNG_ITEMINFO@@PAU1@@@QAEPAU__POSITION@@PAUSTMNG_ITEMINFO@@@Z PROC ; CList<STMNG_ITEMINFO *,STMNG_ITEMINFO *>::AddTail, COMDAT
; _this$ = ecx

; 965  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	57		 push	 edi

; 902  : 	if (m_pNodeFree == NULL)

  00007	83 7e 10 00	 cmp	 DWORD PTR [esi+16], 0

; 966  : 	ASSERT_VALID(this);
; 967  : 
; 968  : 	CNode* pNewNode = NewNode(m_pNodeTail, NULL);

  0000b	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]

; 902  : 	if (m_pNodeFree == NULL)

  0000e	75 32		 jne	 SHORT $LN11@AddTail

; 903  : 	{
; 904  : 		// add another block
; 905  : 		CPlex* pNewBlock = CPlex::Create(m_pBlocks, m_nBlockSize,

  00010	6a 0c		 push	 12			; 0000000cH
  00012	ff 76 18	 push	 DWORD PTR [esi+24]
  00015	8d 46 14	 lea	 eax, DWORD PTR [esi+20]
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ?Create@CPlex@@SGPAU1@AAPAU1@II@Z ; CPlex::Create

; 906  : 				 sizeof(CNode));
; 907  : 
; 908  : 		// chain them into free list
; 909  : 		CNode* pNode = (CNode*) pNewBlock->data();
; 910  : 		// free in reverse order to make it easier to debug
; 911  : 		pNode += m_nBlockSize - 1;

  0001e	8b 56 18	 mov	 edx, DWORD PTR [esi+24]
  00021	83 c0 08	 add	 eax, 8
  00024	8d 4a ff	 lea	 ecx, DWORD PTR [edx-1]

; 912  : 		for (INT_PTR i = m_nBlockSize-1; i >= 0; i--, pNode--)

  00027	83 c2 ff	 add	 edx, -1
  0002a	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]
  0002d	8d 0c 88	 lea	 ecx, DWORD PTR [eax+ecx*4]
  00030	78 10		 js	 SHORT $LN11@AddTail
$LL8@AddTail:

; 913  : 		{
; 914  : 			pNode->pNext = m_pNodeFree;

  00032	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00035	89 01		 mov	 DWORD PTR [ecx], eax

; 915  : 			m_pNodeFree = pNode;

  00037	89 4e 10	 mov	 DWORD PTR [esi+16], ecx
  0003a	83 e9 0c	 sub	 ecx, 12			; 0000000cH
  0003d	83 ea 01	 sub	 edx, 1
  00040	79 f0		 jns	 SHORT $LL8@AddTail
$LN11@AddTail:

; 916  : 		}
; 917  : 	}
; 918  : 	ENSURE(m_pNodeFree != NULL);  // we must have something

  00042	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00045	85 c9		 test	 ecx, ecx
  00047	74 39		 je	 SHORT $LN22@AddTail

; 919  : 
; 920  : 	CList::CNode* pNode = m_pNodeFree;
; 921  : 	m_pNodeFree = m_pNodeFree->pNext;

  00049	8b 01		 mov	 eax, DWORD PTR [ecx]
  0004b	89 46 10	 mov	 DWORD PTR [esi+16], eax

; 969  : 	pNewNode->data = newElement;

  0004e	8b 45 08	 mov	 eax, DWORD PTR _newElement$[ebp]

; 922  : 	pNode->pPrev = pPrev;

  00051	89 79 04	 mov	 DWORD PTR [ecx+4], edi

; 923  : 	pNode->pNext = pNext;

  00054	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 924  : 	m_nCount++;

  0005a	ff 46 0c	 inc	 DWORD PTR [esi+12]

; 969  : 	pNewNode->data = newElement;

  0005d	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 970  : 	if (m_pNodeTail != NULL)

  00060	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00063	85 c0		 test	 eax, eax
  00065	74 0d		 je	 SHORT $LN2@AddTail

; 971  : 		m_pNodeTail->pNext = pNewNode;

  00067	89 08		 mov	 DWORD PTR [eax], ecx

; 972  : 	else
; 973  : 		m_pNodeHead = pNewNode;
; 974  : 	m_pNodeTail = pNewNode;
; 975  : 	return (POSITION) pNewNode;

  00069	8b c1		 mov	 eax, ecx
  0006b	5f		 pop	 edi
  0006c	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  0006f	5e		 pop	 esi

; 976  : }

  00070	5d		 pop	 ebp
  00071	c2 04 00	 ret	 4
$LN2@AddTail:

; 972  : 	else
; 973  : 		m_pNodeHead = pNewNode;
; 974  : 	m_pNodeTail = pNewNode;
; 975  : 	return (POSITION) pNewNode;

  00074	5f		 pop	 edi
  00075	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  00078	8b c1		 mov	 eax, ecx
  0007a	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  0007d	5e		 pop	 esi

; 976  : }

  0007e	5d		 pop	 ebp
  0007f	c2 04 00	 ret	 4
$LN22@AddTail:

; 918  : 	ENSURE(m_pNodeFree != NULL);  // we must have something

  00082	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN20@AddTail:
  00087	cc		 int	 3
?AddTail@?$CList@PAUSTMNG_ITEMINFO@@PAU1@@@QAEPAU__POSITION@@PAUSTMNG_ITEMINFO@@@Z ENDP ; CList<STMNG_ITEMINFO *,STMNG_ITEMINFO *>::AddTail
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ??0?$CList@PAUSTMNG_ITEMINFO@@PAU1@@@QAE@H@Z
_TEXT	SEGMENT
_nBlockSize$ = 8					; size = 4
??0?$CList@PAUSTMNG_ITEMINFO@@PAU1@@@QAE@H@Z PROC	; CList<STMNG_ITEMINFO *,STMNG_ITEMINFO *>::CList<STMNG_ITEMINFO *,STMNG_ITEMINFO *>, COMDAT
; _this$ = ecx

; 851  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 852  : 	ASSERT(nBlockSize > 0);
; 853  : 
; 854  : 	m_nCount = 0;
; 855  : 	m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
; 856  : 	m_pBlocks = NULL;
; 857  : 	m_nBlockSize = nBlockSize;

  00003	8b 45 08	 mov	 eax, DWORD PTR _nBlockSize$[ebp]
  00006	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 858  : }

  00009	8b c1		 mov	 eax, ecx
  0000b	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CList@PAUSTMNG_ITEMINFO@@PAU1@@@6B@
  00011	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0
  00018	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  0001f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00026	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0002d	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
??0?$CList@PAUSTMNG_ITEMINFO@@PAU1@@@QAE@H@Z ENDP	; CList<STMNG_ITEMINFO *,STMNG_ITEMINFO *>::CList<STMNG_ITEMINFO *,STMNG_ITEMINFO *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
;	COMDAT ?StartOptThread@@YAIPAX@Z
_TEXT	SEGMENT
_inData$1 = 8						; size = 4
_pParam$ = 8						; size = 4
?StartOptThread@@YAIPAX@Z PROC				; StartOptThread, COMDAT

; 852  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 863  : 	inData.pThisPoint = (long)this;

  00003	8b 45 08	 mov	 eax, DWORD PTR _pParam$[ebp]

; 864  : 
; 865  : 	AfxBeginThread(StartOptThread, &inData);

  00006	6a 00		 push	 0
  00008	6a 00		 push	 0
  0000a	6a 00		 push	 0
  0000c	8b 00		 mov	 eax, DWORD PTR [eax]
  0000e	89 45 08	 mov	 DWORD PTR _inData$1[ebp], eax
  00011	8d 45 08	 lea	 eax, DWORD PTR _inData$1[ebp]
  00014	6a 00		 push	 0
  00016	50		 push	 eax
  00017	68 00 00 00 00	 push	 OFFSET ?StartOptThread@@YAIPAX@Z ; StartOptThread
  0001c	e8 00 00 00 00	 call	 ?AfxBeginThread@@YGPAVCWinThread@@P6AIPAX@Z0HIKPAU_SECURITY_ATTRIBUTES@@@Z ; AfxBeginThread

; 853  : 	STOPTTHREAD* pInData = (STOPTTHREAD*)pParam;
; 854  : 	CDlgOptimizer* pDlg = (CDlgOptimizer*)pInData->pThisPoint;
; 855  : 	pDlg->StartOpt();
; 856  : 
; 857  : 	return 0;

  00021	33 c0		 xor	 eax, eax

; 858  : }

  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
?StartOptThread@@YAIPAX@Z ENDP				; StartOptThread
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
;	COMDAT ??__ERMSG_GETDLLSIZE@@YAXXZ
text$di	SEGMENT
??__ERMSG_GETDLLSIZE@@YAXXZ PROC			; `dynamic initializer for 'RMSG_GETDLLSIZE'', COMDAT

; 56   : const UINT RMSG_GETDLLSIZE		= ::RegisterWindowMessage("RMSG_GETDLLSIZE");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@DEABJHGB@RMSG_GETDLLSIZE@
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegisterWindowMessageA@4
  0000b	a3 00 00 00 00	 mov	 DWORD PTR ?RMSG_GETDLLSIZE@@3IB, eax
  00010	c3		 ret	 0
??__ERMSG_GETDLLSIZE@@YAXXZ ENDP			; `dynamic initializer for 'RMSG_GETDLLSIZE''
text$di	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
;	COMDAT ??__ERMSG_OB_ITEMDBLCLK@@YAXXZ
text$di	SEGMENT
??__ERMSG_OB_ITEMDBLCLK@@YAXXZ PROC			; `dynamic initializer for 'RMSG_OB_ITEMDBLCLK'', COMDAT

; 55   : const UINT RMSG_OB_ITEMDBLCLK	= ::RegisterWindowMessage("RMSG_OB_ITEMDBLCLK");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@GFDLLOKP@RMSG_OB_ITEMDBLCLK@
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegisterWindowMessageA@4
  0000b	a3 00 00 00 00	 mov	 DWORD PTR ?RMSG_OB_ITEMDBLCLK@@3IB, eax
  00010	c3		 ret	 0
??__ERMSG_OB_ITEMDBLCLK@@YAXXZ ENDP			; `dynamic initializer for 'RMSG_OB_ITEMDBLCLK''
text$di	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
;	COMDAT ??__ERMSG_STDATAMANAGER_RESULTDATA@@YAXXZ
text$di	SEGMENT
??__ERMSG_STDATAMANAGER_RESULTDATA@@YAXXZ PROC		; `dynamic initializer for 'RMSG_STDATAMANAGER_RESULTDATA'', COMDAT

; 54   : const UINT RMSG_STDATAMANAGER_RESULTDATA = ::RegisterWindowMessage("RMSG_STDATAMANAGER_RESULTDATA");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@DBLNBLBD@RMSG_STDATAMANAGER_RESULTDATA@
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegisterWindowMessageA@4
  0000b	a3 00 00 00 00	 mov	 DWORD PTR ?RMSG_STDATAMANAGER_RESULTDATA@@3IB, eax
  00010	c3		 ret	 0
??__ERMSG_STDATAMANAGER_RESULTDATA@@YAXXZ ENDP		; `dynamic initializer for 'RMSG_STDATAMANAGER_RESULTDATA''
text$di	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
;	COMDAT ??_GCDlgOptimizer@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCDlgOptimizer@@UAEPAXI@Z PROC			; CDlgOptimizer::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CDlgOptimizer@@UAE@XZ
  0000b	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  0000e	a8 01		 test	 al, 1
  00010	74 22		 je	 SHORT $LN9@scalar
  00012	a8 04		 test	 al, 4
  00014	75 10		 jne	 SHORT $LN3@scalar

; 112  : 	{ ::operator delete(p); }

  00016	56		 push	 esi
  00017	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001c	83 c4 04	 add	 esp, 4
  0001f	8b c6		 mov	 eax, esi
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
$LN3@scalar:
  00026	68 f8 12 00 00	 push	 4856			; 000012f8H
  0002b	56		 push	 esi
  0002c	e8 00 00 00 00	 call	 ?__global_delete@@YAXPAXI@Z ; __global_delete
  00031	83 c4 08	 add	 esp, 8
$LN9@scalar:
  00034	8b c6		 mov	 eax, esi
  00036	5e		 pop	 esi
  00037	5d		 pop	 ebp
  00038	c2 04 00	 ret	 4
??_GCDlgOptimizer@@UAEPAXI@Z ENDP			; CDlgOptimizer::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin1.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin1.inl
;	COMDAT ??1CDlgOptimizer@@UAE@XZ
_TEXT	SEGMENT
??1CDlgOptimizer@@UAE@XZ PROC				; CDlgOptimizer::~CDlgOptimizer, COMDAT
; _this$ = ecx

; 155  : 	{ }

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8d 8e f0 12 00
	00		 lea	 ecx, DWORD PTR [esi+4848]
  00009	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CFont@@6B@
  0000f	e8 00 00 00 00	 call	 ??1CGdiObject@@UAE@XZ	; CGdiObject::~CGdiObject
  00014	8d 8e 58 12 00
	00		 lea	 ecx, DWORD PTR [esi+4696]
  0001a	e8 00 00 00 00	 call	 ??1CSTExtTree@@UAE@XZ	; CSTExtTree::~CSTExtTree
  0001f	8d 8e c0 11 00
	00		 lea	 ecx, DWORD PTR [esi+4544]
  00025	e8 00 00 00 00	 call	 ??1CSTBasicTree@@UAE@XZ	; CSTBasicTree::~CSTBasicTree
  0002a	8d 8e ac 11 00
	00		 lea	 ecx, DWORD PTR [esi+4524]
  00030	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00036	8d 8e 98 11 00
	00		 lea	 ecx, DWORD PTR [esi+4504]
  0003c	e8 00 00 00 00	 call	 ??1?$CArray@UST_VALUEOPTIMAZE@@U1@@@UAE@XZ ; CArray<ST_VALUEOPTIMAZE,ST_VALUEOPTIMAZE>::~CArray<ST_VALUEOPTIMAZE,ST_VALUEOPTIMAZE>
  00041	8d 8e 84 11 00
	00		 lea	 ecx, DWORD PTR [esi+4484]
  00047	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0004d	8d 8e 80 11 00
	00		 lea	 ecx, DWORD PTR [esi+4480]
  00053	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00059	8d 8e 78 11 00
	00		 lea	 ecx, DWORD PTR [esi+4472]
  0005f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00065	8d 8e f0 10 00
	00		 lea	 ecx, DWORD PTR [esi+4336]
  0006b	e8 00 00 00 00	 call	 ??1CListBox@@UAE@XZ	; CListBox::~CListBox
  00070	8d 8e dc 10 00
	00		 lea	 ecx, DWORD PTR [esi+4316]
  00076	e8 00 00 00 00	 call	 ??1CStringArray@@UAE@XZ	; CStringArray::~CStringArray
  0007b	8d 8e d4 10 00
	00		 lea	 ecx, DWORD PTR [esi+4308]
  00081	e8 00 00 00 00	 call	 ??1CImageList@@UAE@XZ	; CImageList::~CImageList
  00086	8d 8e cc 10 00
	00		 lea	 ecx, DWORD PTR [esi+4300]
  0008c	e8 00 00 00 00	 call	 ??1CImageList@@UAE@XZ	; CImageList::~CImageList
  00091	8d 8e 60 0f 00
	00		 lea	 ecx, DWORD PTR [esi+3936]
  00097	e8 00 00 00 00	 call	 ??1CSTGfxOutBarCtrl@@UAE@XZ ; CSTGfxOutBarCtrl::~CSTGfxOutBarCtrl
  0009c	8d 8e 48 0f 00
	00		 lea	 ecx, DWORD PTR [esi+3912]
  000a2	e8 00 00 00 00	 call	 ??1CStringArray@@UAE@XZ	; CStringArray::~CStringArray
  000a7	8d 8e 34 0f 00
	00		 lea	 ecx, DWORD PTR [esi+3892]
  000ad	e8 00 00 00 00	 call	 ??1?$CArray@UST_STRGRIDDATA@@U1@@@UAE@XZ ; CArray<ST_STRGRIDDATA,ST_STRGRIDDATA>::~CArray<ST_STRGRIDDATA,ST_STRGRIDDATA>
  000b2	8d 8e 20 0f 00
	00		 lea	 ecx, DWORD PTR [esi+3872]
  000b8	e8 00 00 00 00	 call	 ??1?$CArray@UST_GRIDDATA@@U1@@@UAE@XZ ; CArray<ST_GRIDDATA,ST_GRIDDATA>::~CArray<ST_GRIDDATA,ST_GRIDDATA>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 358  : 	if (m_pData != NULL)

  000bd	8b 86 10 0f 00
	00		 mov	 eax, DWORD PTR [esi+3856]
  000c3	c7 86 0c 0f 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+3852], OFFSET ??_7?$CArray@UST_RUNVALUE@@U1@@@6B@
  000cd	85 c0		 test	 eax, eax
  000cf	74 13		 je	 SHORT $LN10@CDlgOptimi

; 359  : 	{
; 360  : 		for( int i = 0; i < m_nSize; i++ )

  000d1	83 be 14 0f 00
	00 00		 cmp	 DWORD PTR [esi+3860], 0
  000d8	0f 4f c0	 cmovg	 eax, eax

; 361  : 			(m_pData + i)->~TYPE();
; 362  : 		delete[] (BYTE*)m_pData;

  000db	50		 push	 eax
  000dc	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  000e1	83 c4 04	 add	 esp, 4
$LN10@CDlgOptimi:
  000e4	8d 8e 04 0f 00
	00		 lea	 ecx, DWORD PTR [esi+3844]
  000ea	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  000f0	8d 8e fc 0e 00
	00		 lea	 ecx, DWORD PTR [esi+3836]
  000f6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  000fc	8d 8e f8 0e 00
	00		 lea	 ecx, DWORD PTR [esi+3832]
  00102	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00108	8d 8e f4 0e 00
	00		 lea	 ecx, DWORD PTR [esi+3828]
  0010e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00114	8d 8e e0 0e 00
	00		 lea	 ecx, DWORD PTR [esi+3808]
  0011a	e8 00 00 00 00	 call	 ??1CStringArray@@UAE@XZ	; CStringArray::~CStringArray
  0011f	8d 8e cc 0e 00
	00		 lea	 ecx, DWORD PTR [esi+3788]
  00125	e8 00 00 00 00	 call	 ??1CStringArray@@UAE@XZ	; CStringArray::~CStringArray

; 358  : 	if (m_pData != NULL)

  0012a	8b 86 a8 0e 00
	00		 mov	 eax, DWORD PTR [esi+3752]
  00130	c7 86 a4 0e 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+3748], OFFSET ??_7?$CArray@PAUST_VALUE@@PAU1@@@6B@
  0013a	85 c0		 test	 eax, eax
  0013c	74 13		 je	 SHORT $LN17@CDlgOptimi

; 359  : 	{
; 360  : 		for( int i = 0; i < m_nSize; i++ )

  0013e	83 be ac 0e 00
	00 00		 cmp	 DWORD PTR [esi+3756], 0
  00145	0f 4f c0	 cmovg	 eax, eax

; 361  : 			(m_pData + i)->~TYPE();
; 362  : 		delete[] (BYTE*)m_pData;

  00148	50		 push	 eax
  00149	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0014e	83 c4 04	 add	 esp, 4
$LN17@CDlgOptimi:

; 358  : 	if (m_pData != NULL)

  00151	8b 86 94 0e 00
	00		 mov	 eax, DWORD PTR [esi+3732]
  00157	c7 86 90 0e 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+3728], OFFSET ??_7?$CArray@PAVCDialog@@PAV1@@@6B@
  00161	85 c0		 test	 eax, eax
  00163	74 13		 je	 SHORT $LN24@CDlgOptimi

; 359  : 	{
; 360  : 		for( int i = 0; i < m_nSize; i++ )

  00165	83 be 98 0e 00
	00 00		 cmp	 DWORD PTR [esi+3736], 0
  0016c	0f 4f c0	 cmovg	 eax, eax

; 361  : 			(m_pData + i)->~TYPE();
; 362  : 		delete[] (BYTE*)m_pData;

  0016f	50		 push	 eax
  00170	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00175	83 c4 04	 add	 esp, 4
$LN24@CDlgOptimi:
  00178	8d 8e f0 09 00
	00		 lea	 ecx, DWORD PTR [esi+2544]
  0017e	e8 00 00 00 00	 call	 ??1CGridCtrl@@UAE@XZ	; CGridCtrl::~CGridCtrl
  00183	8d 8e 60 05 00
	00		 lea	 ecx, DWORD PTR [esi+1376]
  00189	e8 00 00 00 00	 call	 ??1CGridCtrl@@UAE@XZ	; CGridCtrl::~CGridCtrl
  0018e	8d 8e 50 05 00
	00		 lea	 ecx, DWORD PTR [esi+1360]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin1.inl

; 130  : 	{ }

  00194	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CBrush@@6B@
  0019a	e8 00 00 00 00	 call	 ??1CGdiObject@@UAE@XZ	; CGdiObject::~CGdiObject
  0019f	8d 8e 4c 05 00
	00		 lea	 ecx, DWORD PTR [esi+1356]
  001a5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  001ab	8d 8e 48 05 00
	00		 lea	 ecx, DWORD PTR [esi+1352]
  001b1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  001b7	8d 8e 44 05 00
	00		 lea	 ecx, DWORD PTR [esi+1348]
  001bd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  001c3	8d 8e 40 05 00
	00		 lea	 ecx, DWORD PTR [esi+1344]
  001c9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  001cf	8d 8e 3c 05 00
	00		 lea	 ecx, DWORD PTR [esi+1340]
  001d5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  001db	8d 8e 38 05 00
	00		 lea	 ecx, DWORD PTR [esi+1336]
  001e1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  001e7	8d 8e 14 05 00
	00		 lea	 ecx, DWORD PTR [esi+1300]
  001ed	e8 00 00 00 00	 call	 ??1CStrategyLoader@@UAE@XZ ; CStrategyLoader::~CStrategyLoader
  001f2	8d 8e 08 04 00
	00		 lea	 ecx, DWORD PTR [esi+1032]
  001f8	e8 00 00 00 00	 call	 ??1CXTabCtrl@@UAE@XZ	; CXTabCtrl::~CXTabCtrl
  001fd	8d 8e 78 03 00
	00		 lea	 ecx, DWORD PTR [esi+888]
  00203	e8 00 00 00 00	 call	 ??1CExDrawButton@@UAE@XZ ; CExDrawButton::~CExDrawButton
  00208	8d 8e e8 02 00
	00		 lea	 ecx, DWORD PTR [esi+744]
  0020e	e8 00 00 00 00	 call	 ??1CExDrawButton@@UAE@XZ ; CExDrawButton::~CExDrawButton
  00213	8d 8e 58 02 00
	00		 lea	 ecx, DWORD PTR [esi+600]
  00219	e8 00 00 00 00	 call	 ??1CExDrawButton@@UAE@XZ ; CExDrawButton::~CExDrawButton
  0021e	8d 8e c8 01 00
	00		 lea	 ecx, DWORD PTR [esi+456]
  00224	e8 00 00 00 00	 call	 ??1CExDrawButton@@UAE@XZ ; CExDrawButton::~CExDrawButton
  00229	8d 8e 38 01 00
	00		 lea	 ecx, DWORD PTR [esi+312]
  0022f	e8 00 00 00 00	 call	 ??1CExDrawButton@@UAE@XZ ; CExDrawButton::~CExDrawButton
  00234	8d 8e a8 00 00
	00		 lea	 ecx, DWORD PTR [esi+168]
  0023a	e8 00 00 00 00	 call	 ??1CExDrawButton@@UAE@XZ ; CExDrawButton::~CExDrawButton
  0023f	8b ce		 mov	 ecx, esi
  00241	5e		 pop	 esi
  00242	e9 00 00 00 00	 jmp	 ??1CDialog@@UAE@XZ	; CDialog::~CDialog
??1CDlgOptimizer@@UAE@XZ ENDP				; CDlgOptimizer::~CDlgOptimizer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
;	COMDAT ?OnRmsgSTTreeItemDBClk@CDlgOptimizer@@QAEJIJ@Z
_TEXT	SEGMENT
_wParam$ = 8						; size = 4
_lParam$ = 12						; size = 4
?OnRmsgSTTreeItemDBClk@CDlgOptimizer@@QAEJIJ@Z PROC	; CDlgOptimizer::OnRmsgSTTreeItemDBClk, COMDAT
; _this$ = ecx

; 1928 : {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1930 : }

  00003	5d		 pop	 ebp

; 1929 : 	return OnRmsgObItemDBClk(wParam, lParam);

  00004	e9 00 00 00 00	 jmp	 ?OnRmsgObItemDBClk@CDlgOptimizer@@IAEJIJ@Z ; CDlgOptimizer::OnRmsgObItemDBClk
?OnRmsgSTTreeItemDBClk@CDlgOptimizer@@QAEJIJ@Z ENDP	; CDlgOptimizer::OnRmsgSTTreeItemDBClk
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
;	COMDAT ?LoadSTList_SSStyle@CDlgOptimizer@@QAEXXZ
_TEXT	SEGMENT
_this$GSCopy$1$ = -24					; size = 4
$T1 = -20						; size = 16
$T2 = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
?LoadSTList_SSStyle@CDlgOptimizer@@QAEXXZ PROC		; CDlgOptimizer::LoadSTList_SSStyle, COMDAT
; _this$ = ecx

; 1899 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b f1		 mov	 esi, ecx
  00013	89 75 e8	 mov	 DWORD PTR _this$GSCopy$1$[ebp], esi

; 1900 : 	if(!m_pWndOutBar) return;

  00016	8b 8e b8 11 00
	00		 mov	 ecx, DWORD PTR [esi+4536]
  0001c	85 c9		 test	 ecx, ecx
  0001e	0f 84 ac 00 00
	00		 je	 $LN1@LoadSTList

; 1901 : 
; 1902 : 	m_STTree.m_szRootDir = m_strRootPath;

  00024	8b 86 40 05 00
	00		 mov	 eax, DWORD PTR [esi+1344]
  0002a	53		 push	 ebx
  0002b	89 86 dc 12 00
	00		 mov	 DWORD PTR [esi+4828], eax

; 1903 : 	m_STBasicTree.m_szRootDir = m_strRootPath;

  00031	89 86 44 12 00
	00		 mov	 DWORD PTR [esi+4676], eax

; 1904 : 
; 1905 : 	DWORD dwStyle = WS_CHILD | WS_CLIPCHILDREN | TVS_HASBUTTONS | TVS_LINESATROOT | TVS_HASLINES | TVS_SHOWSELALWAYS;
; 1906 : 	CWnd* pParentWnd = m_pWndOutBar->GetCoutBarCtrl();

  00037	8b 01		 mov	 eax, DWORD PTR [ecx]
  00039	57		 push	 edi
  0003a	51		 push	 ecx
  0003b	ff 10		 call	 DWORD PTR [eax]

; 1909 : 	BOOL bResult = m_STTree.Create(dwStyle, CRect(0, 0, 0, 0), pParentWnd, nID);

  0003d	68 e8 03 00 00	 push	 1000			; 000003e8H
  00042	8b f8		 mov	 edi, eax
  00044	8d 9e 58 12 00
	00		 lea	 ebx, DWORD PTR [esi+4696]
  0004a	57		 push	 edi
  0004b	8d 45 ec	 lea	 eax, DWORD PTR $T2[ebp]
  0004e	0f 57 c0	 xorps	 xmm0, xmm0
  00051	50		 push	 eax
  00052	68 27 00 00 42	 push	 1107296295		; 42000027H
  00057	8b cb		 mov	 ecx, ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h

; 540  : 	left = l;

  00059	0f 11 45 ec	 movups	 XMMWORD PTR $T2[ebp], xmm0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 1909 : 	BOOL bResult = m_STTree.Create(dwStyle, CRect(0, 0, 0, 0), pParentWnd, nID);

  0005d	e8 00 00 00 00	 call	 ?Create@CSTTreeCtrl@@QAEHKABUtagRECT@@PAVCWnd@@I@Z ; CSTTreeCtrl::Create

; 1910 : 	m_STTree.LoadSTTree();

  00062	8b 03		 mov	 eax, DWORD PTR [ebx]
  00064	8b cb		 mov	 ecx, ebx
  00066	ff 90 6c 01 00
	00		 call	 DWORD PTR [eax+364]

; 1913 : 	bResult = m_STBasicTree.Create(dwStyle, CRect(0, 0, 0, 0), pParentWnd, nID);

  0006c	68 e9 03 00 00	 push	 1001			; 000003e9H
  00071	57		 push	 edi
  00072	8d 45 ec	 lea	 eax, DWORD PTR $T1[ebp]
  00075	0f 57 c0	 xorps	 xmm0, xmm0
  00078	50		 push	 eax
  00079	81 c6 c0 11 00
	00		 add	 esi, 4544		; 000011c0H
  0007f	68 27 00 00 42	 push	 1107296295		; 42000027H
  00084	8b ce		 mov	 ecx, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h

; 540  : 	left = l;

  00086	0f 11 45 ec	 movups	 XMMWORD PTR $T1[ebp], xmm0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 1913 : 	bResult = m_STBasicTree.Create(dwStyle, CRect(0, 0, 0, 0), pParentWnd, nID);

  0008a	e8 00 00 00 00	 call	 ?Create@CSTTreeCtrl@@QAEHKABUtagRECT@@PAVCWnd@@I@Z ; CSTTreeCtrl::Create

; 1914 : 	m_STBasicTree.LoadSTTree();

  0008f	8b 06		 mov	 eax, DWORD PTR [esi]
  00091	8b ce		 mov	 ecx, esi
  00093	ff 90 6c 01 00
	00		 call	 DWORD PTR [eax+364]

; 1915 : 
; 1916 : 	m_pWndOutBar->AddFolderBar("", &m_STBasicTree);

  00099	8b 7d e8	 mov	 edi, DWORD PTR _this$GSCopy$1$[ebp]
  0009c	56		 push	 esi
  0009d	68 00 00 00 00	 push	 OFFSET ??_C@_04FFLPOIDN@?C?J?$LB?$NO@
  000a2	8b 87 b8 11 00
	00		 mov	 eax, DWORD PTR [edi+4536]
  000a8	50		 push	 eax
  000a9	8b 08		 mov	 ecx, DWORD PTR [eax]
  000ab	ff 51 18	 call	 DWORD PTR [ecx+24]

; 1917 : 	m_pWndOutBar->AddFolderBar("", &m_STTree);

  000ae	8b 87 b8 11 00
	00		 mov	 eax, DWORD PTR [edi+4536]
  000b4	53		 push	 ebx
  000b5	68 00 00 00 00	 push	 OFFSET ??_C@_04NGCIOFKF@?$LA?m?$LB?$NO@
  000ba	50		 push	 eax
  000bb	8b 08		 mov	 ecx, DWORD PTR [eax]
  000bd	ff 51 18	 call	 DWORD PTR [ecx+24]

; 1918 : 
; 1919 : 	m_pWndOutBar->SetSelFolder(0);

  000c0	8b 87 b8 11 00
	00		 mov	 eax, DWORD PTR [edi+4536]
  000c6	6a 00		 push	 0
  000c8	50		 push	 eax
  000c9	8b 08		 mov	 ecx, DWORD PTR [eax]
  000cb	ff 51 1c	 call	 DWORD PTR [ecx+28]
  000ce	5f		 pop	 edi
  000cf	5b		 pop	 ebx
$LN1@LoadSTList:

; 1920 : }

  000d0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000d3	33 cd		 xor	 ecx, ebp
  000d5	5e		 pop	 esi
  000d6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000db	8b e5		 mov	 esp, ebp
  000dd	5d		 pop	 ebp
  000de	c3		 ret	 0
?LoadSTList_SSStyle@CDlgOptimizer@@QAEXXZ ENDP		; CDlgOptimizer::LoadSTList_SSStyle
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
;	COMDAT ?OnLbnDblclkListSt@CDlgOptimizer@@QAEXXZ
_TEXT	SEGMENT
?OnLbnDblclkListSt@CDlgOptimizer@@QAEXXZ PROC		; CDlgOptimizer::OnLbnDblclkListSt, COMDAT
; _this$ = ecx

; 1892 : {

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl

; 666  : 	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_GETCURSEL, 0, 0); }

  00003	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__SendMessageA@16
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 1892 : {

  00009	8b d9		 mov	 ebx, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl

; 666  : 	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_GETCURSEL, 0, 0); }

  0000b	6a 00		 push	 0
  0000d	6a 00		 push	 0
  0000f	68 88 01 00 00	 push	 392			; 00000188H
  00014	ff b3 10 11 00
	00		 push	 DWORD PTR [ebx+4368]
  0001a	ff d7		 call	 edi

; 683  : 	{ ASSERT(::IsWindow(m_hWnd)); return ::SendMessage(m_hWnd, LB_GETITEMDATA, nIndex, 0); }

  0001c	6a 00		 push	 0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 1686 : 	int nCurSel = m_listST.GetCurSel();

  0001e	8b f0		 mov	 esi, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl

; 683  : 	{ ASSERT(::IsWindow(m_hWnd)); return ::SendMessage(m_hWnd, LB_GETITEMDATA, nIndex, 0); }

  00020	56		 push	 esi
  00021	68 99 01 00 00	 push	 409			; 00000199H
  00026	ff b3 10 11 00
	00		 push	 DWORD PTR [ebx+4368]
  0002c	ff d7		 call	 edi

; 727  : 	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_DELETESTRING, nIndex, 0); }

  0002e	6a 00		 push	 0
  00030	56		 push	 esi
  00031	68 82 01 00 00	 push	 386			; 00000182H
  00036	ff b3 10 11 00
	00		 push	 DWORD PTR [ebx+4368]
  0003c	ff d7		 call	 edi
  0003e	5f		 pop	 edi
  0003f	5e		 pop	 esi
  00040	5b		 pop	 ebx
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 1894 : }

  00041	c3		 ret	 0
?OnLbnDblclkListSt@CDlgOptimizer@@QAEXXZ ENDP		; CDlgOptimizer::OnLbnDblclkListSt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\Common_ST\DataItem.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\Common_ST\DataItem.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\Common_ST\DataItem.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
;	COMDAT ?GetChartData@CSTUserData@CDlgOptimizer@@UAGHAAJ000000AAH@Z
_TEXT	SEGMENT
_nBongClose$1 = -60					; size = 8
_nBongOpen$2 = -52					; size = 8
_nBongLow$3 = -44					; size = 8
_nBongHigh$4 = -36					; size = 8
_nEnd$1$ = -28						; size = 4
tv741 = -24						; size = 8
tv732 = -24						; size = 8
_nIndex$1$ = -20					; size = 4
_nIndex$1$ = -20					; size = 4
_nIndex$1$ = -20					; size = 4
$T5 = -16						; size = 4
_nCnt$1$ = -12						; size = 4
$T6 = -8						; size = 4
$T7 = -4						; size = 4
_i$1$ = 8						; size = 4
_this$ = 8						; size = 4
_dwDataTime$ = 12					; size = 4
_dwDataOpen$ = 16					; size = 4
_dwDataHigh$ = 20					; size = 4
$T8 = 24						; size = 4
_dwDataLow$ = 24					; size = 4
_dwDataClose$ = 28					; size = 4
$T9 = 32						; size = 4
_dwVolume$ = 32						; size = 4
$T10 = 36						; size = 4
_dwDataExt$ = 36					; size = 4
_nBong$ = 40						; size = 4
?GetChartData@CSTUserData@CDlgOptimizer@@UAGHAAJ000000AAH@Z PROC ; CDlgOptimizer::CSTUserData::GetChartData, COMDAT

; 1766 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1767 : 	MYMETHOD_PROLOGUE(CDlgOptimizer, STUserData)
; 1768 : 	ISTInterface* pSTInterface = (ISTInterface*)pThis->m_pChartInterface;

  00009	8b 7d 08	 mov	 edi, DWORD PTR _this$[ebp]
  0000c	8b 4f e4	 mov	 ecx, DWORD PTR [edi-28]

; 1769 : 	if(pSTInterface)

  0000f	85 c9		 test	 ecx, ecx
  00011	0f 84 cc 02 00
	00		 je	 $LN8@GetChartDa

; 1770 : 	{
; 1771 : 		//  !!
; 1772 : 		ISTAnalysisInput* pMng = (ISTAnalysisInput*)pSTInterface->GetInterface(UUSTID_ISTAnalysisInput);

  00017	8b 01		 mov	 eax, DWORD PTR [ecx]
  00019	6a 00		 push	 0
  0001b	51		 push	 ecx
  0001c	ff 10		 call	 DWORD PTR [eax]

; 1773 : 		// ST         - ojtaso (20080609)
; 1774 : 		int nCnt = pMng->GetChartData(dwDataTime, dwDataOpen, dwDataHigh, dwDataLow, dwDataClose,dwVolume, dwDataExt);//

  0001e	ff 75 24	 push	 DWORD PTR _dwDataExt$[ebp]
  00021	8b 5d 18	 mov	 ebx, DWORD PTR _dwDataLow$[ebp]
  00024	ff 75 20	 push	 DWORD PTR _dwVolume$[ebp]
  00027	8b 75 14	 mov	 esi, DWORD PTR _dwDataHigh$[ebp]
  0002a	ff 75 1c	 push	 DWORD PTR _dwDataClose$[ebp]
  0002d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002f	53		 push	 ebx
  00030	56		 push	 esi
  00031	ff 75 10	 push	 DWORD PTR _dwDataOpen$[ebp]
  00034	ff 75 0c	 push	 DWORD PTR _dwDataTime$[ebp]
  00037	50		 push	 eax
  00038	ff 51 38	 call	 DWORD PTR [ecx+56]

; 1775 : 		nBong = pThis->m_pStrategyItem->GetTimeBong();//     .

  0003b	8b 8f 80 f3 ff
	ff		 mov	 ecx, DWORD PTR [edi-3200]
  00041	89 45 f4	 mov	 DWORD PTR _nCnt$1$[ebp], eax
  00044	8b 11		 mov	 edx, DWORD PTR [ecx]
  00046	ff 92 80 00 00
	00		 call	 DWORD PTR [edx+128]
  0004c	8b 7d 28	 mov	 edi, DWORD PTR _nBong$[ebp]
  0004f	89 07		 mov	 DWORD PTR [edi], eax

; 1776 : 		if(nBong ==1) return 0;//1   ..   

  00051	83 f8 01	 cmp	 eax, 1
  00054	0f 84 89 02 00
	00		 je	 $LN8@GetChartDa

; 1777 : 		//  Copy 
; 1778 : 		CSDataItem* dTimeDataTime		= new CSDataItem;

  0005a	6a 24		 push	 36			; 00000024H
  0005c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00061	83 c4 04	 add	 esp, 4
  00064	85 c0		 test	 eax, eax
  00066	74 0c		 je	 SHORT $LN11@GetChartDa
  00068	8b c8		 mov	 ecx, eax
  0006a	e8 00 00 00 00	 call	 ??0CSDataItem@@QAE@XZ	; CSDataItem::CSDataItem
  0006f	89 45 20	 mov	 DWORD PTR $T9[ebp], eax
  00072	eb 07		 jmp	 SHORT $LN12@GetChartDa
$LN11@GetChartDa:
  00074	c7 45 20 00 00
	00 00		 mov	 DWORD PTR $T9[ebp], 0
$LN12@GetChartDa:

; 1779 : 		CSTDataItem* dTimeDataOpen		= new CSTDataItem;

  0007b	6a 58		 push	 88			; 00000058H
  0007d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00082	83 c4 04	 add	 esp, 4
  00085	85 c0		 test	 eax, eax
  00087	74 0c		 je	 SHORT $LN13@GetChartDa
  00089	8b c8		 mov	 ecx, eax
  0008b	e8 00 00 00 00	 call	 ??0CSTDataItem@@QAE@XZ	; CSTDataItem::CSTDataItem
  00090	89 45 24	 mov	 DWORD PTR $T10[ebp], eax
  00093	eb 07		 jmp	 SHORT $LN14@GetChartDa
$LN13@GetChartDa:
  00095	c7 45 24 00 00
	00 00		 mov	 DWORD PTR $T10[ebp], 0
$LN14@GetChartDa:

; 1780 : 		CSTDataItem* dTimeDataHigh		= new CSTDataItem;

  0009c	6a 58		 push	 88			; 00000058H
  0009e	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000a3	83 c4 04	 add	 esp, 4
  000a6	85 c0		 test	 eax, eax
  000a8	74 0c		 je	 SHORT $LN15@GetChartDa
  000aa	8b c8		 mov	 ecx, eax
  000ac	e8 00 00 00 00	 call	 ??0CSTDataItem@@QAE@XZ	; CSTDataItem::CSTDataItem
  000b1	89 45 18	 mov	 DWORD PTR $T8[ebp], eax
  000b4	eb 07		 jmp	 SHORT $LN16@GetChartDa
$LN15@GetChartDa:
  000b6	c7 45 18 00 00
	00 00		 mov	 DWORD PTR $T8[ebp], 0
$LN16@GetChartDa:

; 1781 : 		CSTDataItem* dTimeDataLow		= new CSTDataItem;

  000bd	6a 58		 push	 88			; 00000058H
  000bf	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000c4	83 c4 04	 add	 esp, 4
  000c7	85 c0		 test	 eax, eax
  000c9	74 0c		 je	 SHORT $LN17@GetChartDa
  000cb	8b c8		 mov	 ecx, eax
  000cd	e8 00 00 00 00	 call	 ??0CSTDataItem@@QAE@XZ	; CSTDataItem::CSTDataItem
  000d2	89 45 fc	 mov	 DWORD PTR $T7[ebp], eax
  000d5	eb 07		 jmp	 SHORT $LN18@GetChartDa
$LN17@GetChartDa:
  000d7	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T7[ebp], 0
$LN18@GetChartDa:

; 1782 : 		CSTDataItem* dTimeDataClose		= new CSTDataItem;

  000de	6a 58		 push	 88			; 00000058H
  000e0	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000e5	83 c4 04	 add	 esp, 4
  000e8	85 c0		 test	 eax, eax
  000ea	74 0c		 je	 SHORT $LN19@GetChartDa
  000ec	8b c8		 mov	 ecx, eax
  000ee	e8 00 00 00 00	 call	 ??0CSTDataItem@@QAE@XZ	; CSTDataItem::CSTDataItem
  000f3	89 45 f8	 mov	 DWORD PTR $T6[ebp], eax
  000f6	eb 07		 jmp	 SHORT $LN20@GetChartDa
$LN19@GetChartDa:
  000f8	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR $T6[ebp], 0
$LN20@GetChartDa:

; 1783 : 
; 1784 : 		double nBongOpen; 
; 1785 : 		double nBongHigh;
; 1786 : 		double nBongLow;
; 1787 : 		double nBongClose;
; 1788 : 		int nStartI;
; 1789 : 		int nEnd = (nCnt-(nCnt%nBong)); //->   .

  000ff	8b 45 f4	 mov	 eax, DWORD PTR _nCnt$1$[ebp]
  00102	99		 cdq
  00103	f7 3f		 idiv	 DWORD PTR [edi]
  00105	8b 45 f4	 mov	 eax, DWORD PTR _nCnt$1$[ebp]
  00108	2b c2		 sub	 eax, edx

; 1790 : 		for(int i = 0; i<nEnd ; i+=nBong)

  0010a	33 d2		 xor	 edx, edx
  0010c	89 45 e4	 mov	 DWORD PTR _nEnd$1$[ebp], eax
  0010f	89 55 08	 mov	 DWORD PTR _i$1$[ebp], edx
  00112	85 c0		 test	 eax, eax
  00114	0f 8e 9b 01 00
	00		 jle	 $LN3@GetChartDa
  0011a	66 0f 1f 44 00
	00		 npad	 6
$LL4@GetChartDa:

; 1791 : 		{	
; 1792 : 			nStartI = i;
; 1793 : 			nBongOpen	= ((CSTDataItem*)dwDataOpen)->GetAt(nStartI);

  00120	8b 45 10	 mov	 eax, DWORD PTR _dwDataOpen$[ebp]
  00123	52		 push	 edx
  00124	8b 08		 mov	 ecx, DWORD PTR [eax]
  00126	8b 01		 mov	 eax, DWORD PTR [ecx]
  00128	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0012b	ff d0		 call	 eax

; 1794 : 			nBongClose	= ((CSTDataItem*)dwDataClose)->GetAt(nStartI+nBong-1);

  0012d	8b 45 1c	 mov	 eax, DWORD PTR _dwDataClose$[ebp]
  00130	dd 5d cc	 fstp	 QWORD PTR _nBongOpen$2[ebp]
  00133	8b 08		 mov	 ecx, DWORD PTR [eax]
  00135	8b 07		 mov	 eax, DWORD PTR [edi]
  00137	8b 7d 08	 mov	 edi, DWORD PTR _i$1$[ebp]
  0013a	48		 dec	 eax
  0013b	03 c7		 add	 eax, edi
  0013d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0013f	50		 push	 eax
  00140	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00143	ff d0		 call	 eax

; 1795 : 			//  .
; 1796 : 			nBongHigh		=((CSTDataItem*)dwDataHigh)->GetAt(nStartI);

  00145	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00147	dd 5d c4	 fstp	 QWORD PTR _nBongClose$1[ebp]
  0014a	57		 push	 edi
  0014b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0014d	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00150	ff d0		 call	 eax

; 1797 : 			nBongLow		=((CSTDataItem*)dwDataLow)->GetAt(nStartI);

  00152	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00154	dd 5d dc	 fstp	 QWORD PTR _nBongHigh$4[ebp]
  00157	57		 push	 edi
  00158	8b 01		 mov	 eax, DWORD PTR [ecx]
  0015a	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0015d	ff d0		 call	 eax

; 1798 : 			for(int j=0;j<nBong;j++)	

  0015f	8b 45 28	 mov	 eax, DWORD PTR _nBong$[ebp]
  00162	33 ff		 xor	 edi, edi
  00164	dd 5d d4	 fstp	 QWORD PTR _nBongLow$3[ebp]
  00167	39 38		 cmp	 DWORD PTR [eax], edi
  00169	7e 63		 jle	 SHORT $LN80@GetChartDa

; 1791 : 		{	
; 1792 : 			nStartI = i;
; 1793 : 			nBongOpen	= ((CSTDataItem*)dwDataOpen)->GetAt(nStartI);

  0016b	8b 75 08	 mov	 esi, DWORD PTR _i$1$[ebp]
  0016e	66 90		 npad	 2
$LL7@GetChartDa:

; 1799 : 			{
; 1800 : 				nBongHigh = max(nBongHigh, ((CSTDataItem*)dwDataHigh)->GetAt(nStartI+j));

  00170	8b 45 14	 mov	 eax, DWORD PTR _dwDataHigh$[ebp]
  00173	56		 push	 esi
  00174	8b 08		 mov	 ecx, DWORD PTR [eax]
  00176	8b 01		 mov	 eax, DWORD PTR [ecx]
  00178	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0017b	ff d0		 call	 eax
  0017d	f2 0f 10 45 dc	 movsd	 xmm0, QWORD PTR _nBongHigh$4[ebp]
  00182	dd 5d e8	 fstp	 QWORD PTR tv741[ebp]
  00185	66 0f 2f 45 e8	 comisd	 xmm0, QWORD PTR tv741[ebp]
  0018a	77 10		 ja	 SHORT $LN22@GetChartDa
  0018c	8b 45 14	 mov	 eax, DWORD PTR _dwDataHigh$[ebp]
  0018f	56		 push	 esi
  00190	8b 08		 mov	 ecx, DWORD PTR [eax]
  00192	8b 01		 mov	 eax, DWORD PTR [ecx]
  00194	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00197	ff d0		 call	 eax
  00199	dd 5d dc	 fstp	 QWORD PTR _nBongHigh$4[ebp]
$LN22@GetChartDa:

; 1801 : 				nBongLow  = min(nBongLow,  ((CSTDataItem*)dwDataLow)->GetAt(nStartI+j));

  0019c	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0019e	56		 push	 esi
  0019f	8b 01		 mov	 eax, DWORD PTR [ecx]
  001a1	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  001a4	ff d0		 call	 eax
  001a6	dd 5d e8	 fstp	 QWORD PTR tv732[ebp]
  001a9	f2 0f 10 45 e8	 movsd	 xmm0, QWORD PTR tv732[ebp]
  001ae	66 0f 2f 45 d4	 comisd	 xmm0, QWORD PTR _nBongLow$3[ebp]
  001b3	77 0d		 ja	 SHORT $LN24@GetChartDa
  001b5	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  001b7	56		 push	 esi
  001b8	8b 01		 mov	 eax, DWORD PTR [ecx]
  001ba	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  001bd	ff d0		 call	 eax
  001bf	dd 5d d4	 fstp	 QWORD PTR _nBongLow$3[ebp]
$LN24@GetChartDa:

; 1798 : 			for(int j=0;j<nBong;j++)	

  001c2	8b 45 28	 mov	 eax, DWORD PTR _nBong$[ebp]
  001c5	47		 inc	 edi
  001c6	46		 inc	 esi
  001c7	3b 38		 cmp	 edi, DWORD PTR [eax]
  001c9	7c a5		 jl	 SHORT $LL7@GetChartDa
  001cb	8b 75 14	 mov	 esi, DWORD PTR _dwDataHigh$[ebp]
$LN80@GetChartDa:

; 1802 : 			}
; 1803 : 
; 1804 : 			dTimeDataTime->Add(((CSDataItem*)dwDataTime)->GetAt(nStartI));

  001ce	8b 45 0c	 mov	 eax, DWORD PTR _dwDataTime$[ebp]
  001d1	8d 55 f0	 lea	 edx, DWORD PTR $T5[ebp]
  001d4	ff 75 08	 push	 DWORD PTR _i$1$[ebp]
  001d7	52		 push	 edx
  001d8	8b 08		 mov	 ecx, DWORD PTR [eax]
  001da	8b 01		 mov	 eax, DWORD PTR [ecx]
  001dc	ff 50 0c	 call	 DWORD PTR [eax+12]
  001df	8b 4d 20	 mov	 ecx, DWORD PTR $T9[ebp]
  001e2	ff 30		 push	 DWORD PTR [eax]
  001e4	8b 11		 mov	 edx, DWORD PTR [ecx]
  001e6	ff 52 14	 call	 DWORD PTR [edx+20]
  001e9	8d 4d f0	 lea	 ecx, DWORD PTR $T5[ebp]
  001ec	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 333  : 	{ INT_PTR nIndex = m_nSize;

  001f2	8b 4d 24	 mov	 ecx, DWORD PTR $T10[ebp]
  001f5	83 c1 18	 add	 ecx, 24			; 00000018H
  001f8	8b 79 08	 mov	 edi, DWORD PTR [ecx+8]

; 538  : 	if(nIndex < 0)

  001fb	85 ff		 test	 edi, edi
  001fd	0f 88 eb 00 00
	00		 js	 $LN73@GetChartDa

; 540  : 
; 541  : 	if (nIndex >= m_nSize)
; 542  : 		SetSize(nIndex+1, -1);

  00203	6a ff		 push	 -1
  00205	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  00208	50		 push	 eax
  00209	e8 00 00 00 00	 call	 ?SetSize@?$CArray@NN@@QAEXHH@Z ; CArray<double,double>::SetSize

; 543  : 	m_pData[nIndex] = newElement;

  0020e	8b 55 24	 mov	 edx, DWORD PTR $T10[ebp]
  00211	f2 0f 10 45 cc	 movsd	 xmm0, QWORD PTR _nBongOpen$2[ebp]
  00216	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00219	f2 0f 11 04 f8	 movsd	 QWORD PTR [eax+edi*8], xmm0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\Common_ST\DataItem.h

; 71   : 		return m_arrayData.Add(dValue);

  0021e	8b 7d 18	 mov	 edi, DWORD PTR $T8[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 333  : 	{ INT_PTR nIndex = m_nSize;

  00221	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  00224	89 45 ec	 mov	 DWORD PTR _nIndex$1$[ebp], eax

; 538  : 	if(nIndex < 0)

  00227	85 c0		 test	 eax, eax
  00229	0f 88 bf 00 00
	00		 js	 $LN73@GetChartDa

; 540  : 
; 541  : 	if (nIndex >= m_nSize)
; 542  : 		SetSize(nIndex+1, -1);

  0022f	6a ff		 push	 -1
  00231	40		 inc	 eax
  00232	8d 4f 18	 lea	 ecx, DWORD PTR [edi+24]
  00235	50		 push	 eax
  00236	e8 00 00 00 00	 call	 ?SetSize@?$CArray@NN@@QAEXHH@Z ; CArray<double,double>::SetSize

; 543  : 	m_pData[nIndex] = newElement;

  0023b	8b 47 1c	 mov	 eax, DWORD PTR [edi+28]
  0023e	8b 4d ec	 mov	 ecx, DWORD PTR _nIndex$1$[ebp]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\Common_ST\DataItem.h

; 71   : 		return m_arrayData.Add(dValue);

  00241	8b 7d fc	 mov	 edi, DWORD PTR $T7[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 543  : 	m_pData[nIndex] = newElement;

  00244	f2 0f 10 45 dc	 movsd	 xmm0, QWORD PTR _nBongHigh$4[ebp]
  00249	f2 0f 11 04 c8	 movsd	 QWORD PTR [eax+ecx*8], xmm0

; 333  : 	{ INT_PTR nIndex = m_nSize;

  0024e	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  00251	89 45 ec	 mov	 DWORD PTR _nIndex$1$[ebp], eax

; 538  : 	if(nIndex < 0)

  00254	85 c0		 test	 eax, eax
  00256	0f 88 92 00 00
	00		 js	 $LN73@GetChartDa

; 540  : 
; 541  : 	if (nIndex >= m_nSize)
; 542  : 		SetSize(nIndex+1, -1);

  0025c	6a ff		 push	 -1
  0025e	40		 inc	 eax
  0025f	8d 4f 18	 lea	 ecx, DWORD PTR [edi+24]
  00262	50		 push	 eax
  00263	e8 00 00 00 00	 call	 ?SetSize@?$CArray@NN@@QAEXHH@Z ; CArray<double,double>::SetSize

; 543  : 	m_pData[nIndex] = newElement;

  00268	8b 47 1c	 mov	 eax, DWORD PTR [edi+28]
  0026b	8b 4d ec	 mov	 ecx, DWORD PTR _nIndex$1$[ebp]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\Common_ST\DataItem.h

; 71   : 		return m_arrayData.Add(dValue);

  0026e	8b 7d f8	 mov	 edi, DWORD PTR $T6[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 543  : 	m_pData[nIndex] = newElement;

  00271	f2 0f 10 45 d4	 movsd	 xmm0, QWORD PTR _nBongLow$3[ebp]
  00276	f2 0f 11 04 c8	 movsd	 QWORD PTR [eax+ecx*8], xmm0

; 333  : 	{ INT_PTR nIndex = m_nSize;

  0027b	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  0027e	89 45 ec	 mov	 DWORD PTR _nIndex$1$[ebp], eax

; 538  : 	if(nIndex < 0)

  00281	85 c0		 test	 eax, eax
  00283	78 69		 js	 SHORT $LN73@GetChartDa

; 540  : 
; 541  : 	if (nIndex >= m_nSize)
; 542  : 		SetSize(nIndex+1, -1);

  00285	6a ff		 push	 -1
  00287	40		 inc	 eax
  00288	8d 4f 18	 lea	 ecx, DWORD PTR [edi+24]
  0028b	50		 push	 eax
  0028c	e8 00 00 00 00	 call	 ?SetSize@?$CArray@NN@@QAEXHH@Z ; CArray<double,double>::SetSize

; 543  : 	m_pData[nIndex] = newElement;

  00291	8b 47 1c	 mov	 eax, DWORD PTR [edi+28]
  00294	8b 4d ec	 mov	 ecx, DWORD PTR _nIndex$1$[ebp]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 1790 : 		for(int i = 0; i<nEnd ; i+=nBong)

  00297	8b 7d 28	 mov	 edi, DWORD PTR _nBong$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 543  : 	m_pData[nIndex] = newElement;

  0029a	f2 0f 10 45 c4	 movsd	 xmm0, QWORD PTR _nBongClose$1[ebp]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 1790 : 		for(int i = 0; i<nEnd ; i+=nBong)

  0029f	8b 55 08	 mov	 edx, DWORD PTR _i$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 543  : 	m_pData[nIndex] = newElement;

  002a2	f2 0f 11 04 c8	 movsd	 QWORD PTR [eax+ecx*8], xmm0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 1790 : 		for(int i = 0; i<nEnd ; i+=nBong)

  002a7	03 17		 add	 edx, DWORD PTR [edi]
  002a9	89 55 08	 mov	 DWORD PTR _i$1$[ebp], edx
  002ac	3b 55 e4	 cmp	 edx, DWORD PTR _nEnd$1$[ebp]
  002af	0f 8c 6b fe ff
	ff		 jl	 $LL4@GetChartDa
$LN3@GetChartDa:

; 1805 : 			dTimeDataOpen->Add(nBongOpen);
; 1806 : 			dTimeDataHigh->Add(nBongHigh);
; 1807 : 			dTimeDataLow->Add(nBongLow);
; 1808 : 			dTimeDataClose->Add(nBongClose);
; 1809 : 		}
; 1810 : 
; 1811 : 		dwDataTime  = (LONG)dTimeDataTime;

  002b5	8b 4d 0c	 mov	 ecx, DWORD PTR _dwDataTime$[ebp]
  002b8	8b 45 20	 mov	 eax, DWORD PTR $T9[ebp]
  002bb	5f		 pop	 edi
  002bc	89 01		 mov	 DWORD PTR [ecx], eax

; 1812 : 		dwDataOpen	= (LONG)dTimeDataOpen;

  002be	8b 4d 10	 mov	 ecx, DWORD PTR _dwDataOpen$[ebp]
  002c1	8b 45 24	 mov	 eax, DWORD PTR $T10[ebp]
  002c4	89 01		 mov	 DWORD PTR [ecx], eax

; 1813 : 		dwDataHigh	= (LONG)dTimeDataHigh;

  002c6	8b 45 18	 mov	 eax, DWORD PTR $T8[ebp]

; 1814 : 		dwDataLow	= (LONG)dTimeDataLow;
; 1815 : 		dwDataClose	= (LONG)dTimeDataClose;

  002c9	8b 4d 1c	 mov	 ecx, DWORD PTR _dwDataClose$[ebp]
  002cc	89 06		 mov	 DWORD PTR [esi], eax
  002ce	8b 45 fc	 mov	 eax, DWORD PTR $T7[ebp]
  002d1	89 03		 mov	 DWORD PTR [ebx], eax
  002d3	8b 45 f8	 mov	 eax, DWORD PTR $T6[ebp]

; 1820 : }

  002d6	5e		 pop	 esi
  002d7	89 01		 mov	 DWORD PTR [ecx], eax
  002d9	8b 45 f4	 mov	 eax, DWORD PTR _nCnt$1$[ebp]
  002dc	5b		 pop	 ebx
  002dd	8b e5		 mov	 esp, ebp
  002df	5d		 pop	 ebp
  002e0	c2 24 00	 ret	 36			; 00000024H
$LN8@GetChartDa:
  002e3	5f		 pop	 edi
  002e4	5e		 pop	 esi
  002e5	33 c0		 xor	 eax, eax
  002e7	5b		 pop	 ebx
  002e8	8b e5		 mov	 esp, ebp
  002ea	5d		 pop	 ebp
  002eb	c2 24 00	 ret	 36			; 00000024H
$LN73@GetChartDa:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 539  : 		AfxThrowInvalidArgException();

  002ee	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN81@GetChartDa:
  002f3	cc		 int	 3
?GetChartData@CSTUserData@CDlgOptimizer@@UAGHAAJ000000AAH@Z ENDP ; CDlgOptimizer::CSTUserData::GetChartData
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
;	COMDAT ?HideControl@CDlgOptimizer@@QAEXXZ
_TEXT	SEGMENT
?HideControl@CDlgOptimizer@@QAEXXZ PROC			; CDlgOptimizer::HideControl, COMDAT
; _this$ = ecx

; 184  : 
; 185  : 	
; 186  : }

  00000	c2 00 00	 ret	 0
?HideControl@CDlgOptimizer@@QAEXXZ ENDP			; CDlgOptimizer::HideControl
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
;	COMDAT ?OnBnClickedBtnDelone@CDlgOptimizer@@QAEXXZ
_TEXT	SEGMENT
?OnBnClickedBtnDelone@CDlgOptimizer@@QAEXXZ PROC	; CDlgOptimizer::OnBnClickedBtnDelone, COMDAT
; _this$ = ecx

; 1684 : {

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl

; 666  : 	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_GETCURSEL, 0, 0); }

  00003	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__SendMessageA@16
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 1684 : {

  00009	8b d9		 mov	 ebx, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl

; 666  : 	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_GETCURSEL, 0, 0); }

  0000b	6a 00		 push	 0
  0000d	6a 00		 push	 0
  0000f	68 88 01 00 00	 push	 392			; 00000188H
  00014	ff b3 10 11 00
	00		 push	 DWORD PTR [ebx+4368]
  0001a	ff d7		 call	 edi

; 683  : 	{ ASSERT(::IsWindow(m_hWnd)); return ::SendMessage(m_hWnd, LB_GETITEMDATA, nIndex, 0); }

  0001c	6a 00		 push	 0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 1686 : 	int nCurSel = m_listST.GetCurSel();

  0001e	8b f0		 mov	 esi, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl

; 683  : 	{ ASSERT(::IsWindow(m_hWnd)); return ::SendMessage(m_hWnd, LB_GETITEMDATA, nIndex, 0); }

  00020	56		 push	 esi
  00021	68 99 01 00 00	 push	 409			; 00000199H
  00026	ff b3 10 11 00
	00		 push	 DWORD PTR [ebx+4368]
  0002c	ff d7		 call	 edi

; 727  : 	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_DELETESTRING, nIndex, 0); }

  0002e	6a 00		 push	 0
  00030	56		 push	 esi
  00031	68 82 01 00 00	 push	 386			; 00000182H
  00036	ff b3 10 11 00
	00		 push	 DWORD PTR [ebx+4368]
  0003c	ff d7		 call	 edi
  0003e	5f		 pop	 edi
  0003f	5e		 pop	 esi
  00040	5b		 pop	 ebx
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 1689 : }

  00041	c3		 ret	 0
?OnBnClickedBtnDelone@CDlgOptimizer@@QAEXXZ ENDP	; CDlgOptimizer::OnBnClickedBtnDelone
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
;	COMDAT ?OnBnClickedBtnDelall@CDlgOptimizer@@QAEXXZ
_TEXT	SEGMENT
_nListCount$1$ = -4					; size = 4
?OnBnClickedBtnDelall@CDlgOptimizer@@QAEXXZ PROC	; CDlgOptimizer::OnBnClickedBtnDelall, COMDAT
; _this$ = ecx

; 1669 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	57		 push	 edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl

; 664  : 	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_GETCOUNT, 0, 0); }

  00007	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__SendMessageA@16
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 1669 : {

  0000d	8b d9		 mov	 ebx, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl

; 664  : 	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_GETCOUNT, 0, 0); }

  0000f	6a 00		 push	 0
  00011	6a 00		 push	 0
  00013	68 8b 01 00 00	 push	 395			; 0000018bH
  00018	ff b3 10 11 00
	00		 push	 DWORD PTR [ebx+4368]
  0001e	ff d7		 call	 edi
  00020	33 f6		 xor	 esi, esi
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 1670 : 	int nListCount = m_listST.GetCount();

  00022	89 45 fc	 mov	 DWORD PTR _nListCount$1$[ebp], eax

; 1671 : 	STMNG_ITEMINFO* pItemInfo = NULL;
; 1672 : 	for(int nIndx = 0; nIndx < nListCount; ++nIndx)

  00025	85 c0		 test	 eax, eax
  00027	7e 4e		 jle	 SHORT $LN3@OnBnClicke
  00029	0f 1f 80 00 00
	00 00		 npad	 7
$LL4@OnBnClicke:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl

; 683  : 	{ ASSERT(::IsWindow(m_hWnd)); return ::SendMessage(m_hWnd, LB_GETITEMDATA, nIndex, 0); }

  00030	6a 00		 push	 0
  00032	56		 push	 esi
  00033	68 99 01 00 00	 push	 409			; 00000199H
  00038	ff b3 10 11 00
	00		 push	 DWORD PTR [ebx+4368]
  0003e	ff d7		 call	 edi
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 1674 : 		if(pItemInfo = (STMNG_ITEMINFO*)m_listST.GetItemData(nIndx)) {

  00040	8b f8		 mov	 edi, eax
  00042	85 ff		 test	 edi, edi
  00044	74 25		 je	 SHORT $LN2@OnBnClicke
  00046	8d 4f 08	 lea	 ecx, DWORD PTR [edi+8]
  00049	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0004f	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  00052	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00058	8b cf		 mov	 ecx, edi
  0005a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00060	6a 18		 push	 24			; 00000018H
  00062	57		 push	 edi
  00063	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00068	83 c4 08	 add	 esp, 8
$LN2@OnBnClicke:

; 1671 : 	STMNG_ITEMINFO* pItemInfo = NULL;
; 1672 : 	for(int nIndx = 0; nIndx < nListCount; ++nIndx)

  0006b	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__SendMessageA@16
  00071	46		 inc	 esi
  00072	3b 75 fc	 cmp	 esi, DWORD PTR _nListCount$1$[ebp]
  00075	7c b9		 jl	 SHORT $LL4@OnBnClicke
$LN3@OnBnClicke:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl

; 731  : 	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, LB_RESETCONTENT, 0, 0); }

  00077	6a 00		 push	 0
  00079	6a 00		 push	 0
  0007b	68 84 01 00 00	 push	 388			; 00000184H
  00080	ff b3 10 11 00
	00		 push	 DWORD PTR [ebx+4368]
  00086	ff d7		 call	 edi
  00088	5f		 pop	 edi
  00089	5e		 pop	 esi
  0008a	5b		 pop	 ebx
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 1681 : }

  0008b	8b e5		 mov	 esp, ebp
  0008d	5d		 pop	 ebp
  0008e	c3		 ret	 0
?OnBnClickedBtnDelall@CDlgOptimizer@@QAEXXZ ENDP	; CDlgOptimizer::OnBnClickedBtnDelall
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
;	COMDAT ?OnBnClickedBtnAddone@CDlgOptimizer@@QAEXXZ
_TEXT	SEGMENT
_STListInfo$ = -48					; size = 28
$T2 = -20						; size = 4
_szSTName$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?OnBnClickedBtnAddone@CDlgOptimizer@@QAEXXZ PROC	; CDlgOptimizer::OnBnClickedBtnAddone, COMDAT
; _this$ = ecx

; 1642 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?OnBnClickedBtnAddone@CDlgOptimizer@@QAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 24	 sub	 esp, 36			; 00000024H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b d9		 mov	 ebx, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 851  : {

  0002a	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _STListInfo$[ebp], OFFSET ??_7?$CList@PAUSTMNG_ITEMINFO@@PAU1@@@6B@

; 852  : 	ASSERT(nBlockSize > 0);
; 853  : 
; 854  : 	m_nCount = 0;
; 855  : 	m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
; 856  : 	m_pBlocks = NULL;

  00031	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _STListInfo$[ebp+20], 0

; 857  : 	m_nBlockSize = nBlockSize;

  00038	c7 45 e8 0a 00
	00 00		 mov	 DWORD PTR _STListInfo$[ebp+24], 10 ; 0000000aH

; 872  : 	m_pBlocks->FreeDataChain();

  0003f	33 c9		 xor	 ecx, ecx
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 1643 : 	LIST_STMNG_ITEMINFO STListInfo;

  00041	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 870  : 	m_nCount = 0;

  00048	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _STListInfo$[ebp+12], 0

; 871  : 	m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;

  0004f	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _STListInfo$[ebp+16], 0
  00056	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _STListInfo$[ebp+8], 0
  0005d	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _STListInfo$[ebp+4], 0

; 872  : 	m_pBlocks->FreeDataChain();

  00064	e8 00 00 00 00	 call	 ?FreeDataChain@CPlex@@QAEXXZ ; CPlex::FreeDataChain
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 1646 : 	m_pSTLoadMnger->GetItemST((DWORD)&STListInfo);

  00069	8b 83 c8 10 00
	00		 mov	 eax, DWORD PTR [ebx+4296]
  0006f	8d 55 d0	 lea	 edx, DWORD PTR _STListInfo$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 873  : 	m_pBlocks = NULL;

  00072	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _STListInfo$[ebp+20], 0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 1646 : 	m_pSTLoadMnger->GetItemST((DWORD)&STListInfo);

  00079	52		 push	 edx
  0007a	50		 push	 eax
  0007b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0007d	ff 51 18	 call	 DWORD PTR [ecx+24]

; 1647 : 	
; 1648 : 	STMNG_ITEMINFO* pItemInfo = NULL;
; 1649 : 	CString szSTName;

  00080	8d 4d f0	 lea	 ecx, DWORD PTR _szSTName$[ebp]
  00083	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 1650 : 	POSITION pos = STListInfo.GetHeadPosition();

  00089	8b 75 d4	 mov	 esi, DWORD PTR _STListInfo$[ebp+4]
  0008c	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00090	85 f6		 test	 esi, esi

; 1652 : 	while(pos) {

  00092	0f 84 9d 00 00
	00		 je	 $LN3@OnBnClicke
$LL2@OnBnClicke:

; 1653 : 		if(pItemInfo = (STMNG_ITEMINFO*)STListInfo.GetNext(pos)) {

  00098	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 813  : 		rPosition = (POSITION) pNode->pNext;

  0009b	8b 36		 mov	 esi, DWORD PTR [esi]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 1653 : 		if(pItemInfo = (STMNG_ITEMINFO*)STListInfo.GetNext(pos)) {

  0009d	85 ff		 test	 edi, edi
  0009f	0f 84 88 00 00
	00		 je	 $LN4@OnBnClicke

; 1654 : 			szSTName = pItemInfo->szSTName;

  000a5	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  000a8	50		 push	 eax
  000a9	8d 4d f0	 lea	 ecx, DWORD PTR _szSTName$[ebp]
  000ac	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z

; 1655 : 			nAtPos = szSTName.Find(gSTGubunKey);

  000b2	6a 00		 push	 0
  000b4	6a 5e		 push	 94			; 0000005eH
  000b6	8d 4d f0	 lea	 ecx, DWORD PTR _szSTName$[ebp]
  000b9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Find@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEHDH@Z

; 1656 : 			if(nAtPos > 0)

  000bf	85 c0		 test	 eax, eax
  000c1	7e 2b		 jle	 SHORT $LN5@OnBnClicke

; 1657 : 				szSTName = szSTName.Mid(0, nAtPos);

  000c3	50		 push	 eax
  000c4	6a 00		 push	 0
  000c6	8d 45 ec	 lea	 eax, DWORD PTR $T2[ebp]
  000c9	50		 push	 eax
  000ca	8d 4d f0	 lea	 ecx, DWORD PTR _szSTName$[ebp]
  000cd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Mid@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBE?AV12@HH@Z
  000d3	50		 push	 eax
  000d4	8d 4d f0	 lea	 ecx, DWORD PTR _szSTName$[ebp]
  000d7	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  000db	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
  000e1	8d 4d ec	 lea	 ecx, DWORD PTR $T2[ebp]
  000e4	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  000e8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$LN5@OnBnClicke:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl

; 725  : 	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_ADDSTRING, 0, (LPARAM)lpszItem); }

  000ee	ff 75 f0	 push	 DWORD PTR _szSTName$[ebp]
  000f1	6a 00		 push	 0
  000f3	68 80 01 00 00	 push	 384			; 00000180H
  000f8	ff b3 10 11 00
	00		 push	 DWORD PTR [ebx+4368]
  000fe	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16

; 664  : 	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_GETCOUNT, 0, 0); }

  00104	6a 00		 push	 0
  00106	6a 00		 push	 0
  00108	68 8b 01 00 00	 push	 395			; 0000018bH
  0010d	ff b3 10 11 00
	00		 push	 DWORD PTR [ebx+4368]
  00113	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16

; 685  : 	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_SETITEMDATA, nIndex, (LPARAM)dwItemData); }

  00119	57		 push	 edi
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 1662 : 				m_listST.SetItemData(m_listST.GetCount() - 1, (DWORD)pItemInfo);

  0011a	48		 dec	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl

; 685  : 	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_SETITEMDATA, nIndex, (LPARAM)dwItemData); }

  0011b	50		 push	 eax
  0011c	68 9a 01 00 00	 push	 410			; 0000019aH
  00121	ff b3 10 11 00
	00		 push	 DWORD PTR [ebx+4368]
  00127	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16
$LN4@OnBnClicke:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 1652 : 	while(pos) {

  0012d	85 f6		 test	 esi, esi
  0012f	0f 85 63 ff ff
	ff		 jne	 $LL2@OnBnClicke
$LN3@OnBnClicke:

; 1666 : }

  00135	8d 4d f0	 lea	 ecx, DWORD PTR _szSTName$[ebp]
  00138	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 872  : 	m_pBlocks->FreeDataChain();

  0013e	8b 4d e4	 mov	 ecx, DWORD PTR _STListInfo$[ebp+20]

; 878  : {

  00141	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 3
  00148	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _STListInfo$[ebp], OFFSET ??_7?$CList@PAUSTMNG_ITEMINFO@@PAU1@@@6B@

; 870  : 	m_nCount = 0;

  0014f	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _STListInfo$[ebp+12], 0

; 871  : 	m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;

  00156	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _STListInfo$[ebp+16], 0
  0015d	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _STListInfo$[ebp+8], 0
  00164	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _STListInfo$[ebp+4], 0

; 872  : 	m_pBlocks->FreeDataChain();

  0016b	e8 00 00 00 00	 call	 ?FreeDataChain@CPlex@@QAEXXZ ; CPlex::FreeDataChain
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 1666 : }

  00170	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00173	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0017a	59		 pop	 ecx
  0017b	5f		 pop	 edi
  0017c	5e		 pop	 esi
  0017d	5b		 pop	 ebx
  0017e	8b e5		 mov	 esp, ebp
  00180	5d		 pop	 ebp
  00181	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?OnBnClickedBtnAddone@CDlgOptimizer@@QAEXXZ$0:
  00000	8d 4d d0	 lea	 ecx, DWORD PTR _STListInfo$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$CList@PAUSTMNG_ITEMINFO@@PAU1@@@UAE@XZ ; CList<STMNG_ITEMINFO *,STMNG_ITEMINFO *>::~CList<STMNG_ITEMINFO *,STMNG_ITEMINFO *>
__unwindfunclet$?OnBnClickedBtnAddone@CDlgOptimizer@@QAEXXZ$1:
  00008	8d 4d f0	 lea	 ecx, DWORD PTR _szSTName$[ebp]
  0000b	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?OnBnClickedBtnAddone@CDlgOptimizer@@QAEXXZ$2:
  00011	8d 4d ec	 lea	 ecx, DWORD PTR $T2[ebp]
  00014	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0001a	cc		 int	 3
  0001b	cc		 int	 3
  0001c	cc		 int	 3
  0001d	cc		 int	 3
  0001e	cc		 int	 3
__ehhandler$?OnBnClickedBtnAddone@CDlgOptimizer@@QAEXXZ:
  0001f	90		 npad	 1
  00020	90		 npad	 1
  00021	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00025	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00028	8b 4a cc	 mov	 ecx, DWORD PTR [edx-52]
  0002b	33 c8		 xor	 ecx, eax
  0002d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00032	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?OnBnClickedBtnAddone@CDlgOptimizer@@QAEXXZ
  00037	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?OnBnClickedBtnAddone@CDlgOptimizer@@QAEXXZ ENDP	; CDlgOptimizer::OnBnClickedBtnAddone
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
;	COMDAT ?OnBnClickedBtnAddall@CDlgOptimizer@@QAEXXZ
_TEXT	SEGMENT
_STListInfo$ = -48					; size = 28
$T2 = -20						; size = 4
_szSTName$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?OnBnClickedBtnAddall@CDlgOptimizer@@QAEXXZ PROC	; CDlgOptimizer::OnBnClickedBtnAddall, COMDAT
; _this$ = ecx

; 1614 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?OnBnClickedBtnAddall@CDlgOptimizer@@QAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 24	 sub	 esp, 36			; 00000024H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b d9		 mov	 ebx, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 851  : {

  0002a	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _STListInfo$[ebp], OFFSET ??_7?$CList@PAUSTMNG_ITEMINFO@@PAU1@@@6B@

; 852  : 	ASSERT(nBlockSize > 0);
; 853  : 
; 854  : 	m_nCount = 0;
; 855  : 	m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
; 856  : 	m_pBlocks = NULL;

  00031	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _STListInfo$[ebp+20], 0

; 857  : 	m_nBlockSize = nBlockSize;

  00038	c7 45 e8 0a 00
	00 00		 mov	 DWORD PTR _STListInfo$[ebp+24], 10 ; 0000000aH

; 872  : 	m_pBlocks->FreeDataChain();

  0003f	33 c9		 xor	 ecx, ecx
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 1615 : 	LIST_STMNG_ITEMINFO STListInfo;

  00041	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 870  : 	m_nCount = 0;

  00048	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _STListInfo$[ebp+12], 0

; 871  : 	m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;

  0004f	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _STListInfo$[ebp+16], 0
  00056	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _STListInfo$[ebp+8], 0
  0005d	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _STListInfo$[ebp+4], 0

; 872  : 	m_pBlocks->FreeDataChain();

  00064	e8 00 00 00 00	 call	 ?FreeDataChain@CPlex@@QAEXXZ ; CPlex::FreeDataChain
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 1618 : 	m_pSTLoadMnger->GetFolderST((DWORD)&STListInfo);

  00069	8b 83 c8 10 00
	00		 mov	 eax, DWORD PTR [ebx+4296]
  0006f	8d 55 d0	 lea	 edx, DWORD PTR _STListInfo$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 873  : 	m_pBlocks = NULL;

  00072	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _STListInfo$[ebp+20], 0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 1618 : 	m_pSTLoadMnger->GetFolderST((DWORD)&STListInfo);

  00079	52		 push	 edx
  0007a	50		 push	 eax
  0007b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0007d	ff 51 14	 call	 DWORD PTR [ecx+20]

; 1619 : 
; 1620 : 	STMNG_ITEMINFO* pItemInfo = NULL;
; 1621 : 	CString szSTName;

  00080	8d 4d f0	 lea	 ecx, DWORD PTR _szSTName$[ebp]
  00083	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 1622 : 	POSITION pos = STListInfo.GetHeadPosition();

  00089	8b 75 d4	 mov	 esi, DWORD PTR _STListInfo$[ebp+4]
  0008c	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00090	85 f6		 test	 esi, esi

; 1624 : 	while(pos) {

  00092	0f 84 9d 00 00
	00		 je	 $LN3@OnBnClicke
$LL2@OnBnClicke:

; 1625 : 		if(pItemInfo = (STMNG_ITEMINFO*)STListInfo.GetNext(pos)) 

  00098	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 813  : 		rPosition = (POSITION) pNode->pNext;

  0009b	8b 36		 mov	 esi, DWORD PTR [esi]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 1625 : 		if(pItemInfo = (STMNG_ITEMINFO*)STListInfo.GetNext(pos)) 

  0009d	85 ff		 test	 edi, edi
  0009f	0f 84 88 00 00
	00		 je	 $LN4@OnBnClicke

; 1626 : 		{
; 1627 : 			szSTName = pItemInfo->szSTName;

  000a5	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  000a8	50		 push	 eax
  000a9	8d 4d f0	 lea	 ecx, DWORD PTR _szSTName$[ebp]
  000ac	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z

; 1628 : 			nAtPos = szSTName.Find(gSTGubunKey);

  000b2	6a 00		 push	 0
  000b4	6a 5e		 push	 94			; 0000005eH
  000b6	8d 4d f0	 lea	 ecx, DWORD PTR _szSTName$[ebp]
  000b9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Find@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEHDH@Z

; 1629 : 			if(nAtPos > 0)

  000bf	85 c0		 test	 eax, eax
  000c1	7e 2b		 jle	 SHORT $LN5@OnBnClicke

; 1630 : 				szSTName = szSTName.Mid(0, nAtPos);

  000c3	50		 push	 eax
  000c4	6a 00		 push	 0
  000c6	8d 45 ec	 lea	 eax, DWORD PTR $T2[ebp]
  000c9	50		 push	 eax
  000ca	8d 4d f0	 lea	 ecx, DWORD PTR _szSTName$[ebp]
  000cd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Mid@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBE?AV12@HH@Z
  000d3	50		 push	 eax
  000d4	8d 4d f0	 lea	 ecx, DWORD PTR _szSTName$[ebp]
  000d7	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  000db	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
  000e1	8d 4d ec	 lea	 ecx, DWORD PTR $T2[ebp]
  000e4	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  000e8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$LN5@OnBnClicke:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl

; 725  : 	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_ADDSTRING, 0, (LPARAM)lpszItem); }

  000ee	ff 75 f0	 push	 DWORD PTR _szSTName$[ebp]
  000f1	6a 00		 push	 0
  000f3	68 80 01 00 00	 push	 384			; 00000180H
  000f8	ff b3 10 11 00
	00		 push	 DWORD PTR [ebx+4368]
  000fe	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16

; 664  : 	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_GETCOUNT, 0, 0); }

  00104	6a 00		 push	 0
  00106	6a 00		 push	 0
  00108	68 8b 01 00 00	 push	 395			; 0000018bH
  0010d	ff b3 10 11 00
	00		 push	 DWORD PTR [ebx+4368]
  00113	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16

; 685  : 	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_SETITEMDATA, nIndex, (LPARAM)dwItemData); }

  00119	57		 push	 edi
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 1635 : 				m_listST.SetItemData(m_listST.GetCount()-1, (DWORD)pItemInfo);

  0011a	48		 dec	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl

; 685  : 	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_SETITEMDATA, nIndex, (LPARAM)dwItemData); }

  0011b	50		 push	 eax
  0011c	68 9a 01 00 00	 push	 410			; 0000019aH
  00121	ff b3 10 11 00
	00		 push	 DWORD PTR [ebx+4368]
  00127	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16
$LN4@OnBnClicke:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 1624 : 	while(pos) {

  0012d	85 f6		 test	 esi, esi
  0012f	0f 85 63 ff ff
	ff		 jne	 $LL2@OnBnClicke
$LN3@OnBnClicke:

; 1639 : }

  00135	8d 4d f0	 lea	 ecx, DWORD PTR _szSTName$[ebp]
  00138	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 872  : 	m_pBlocks->FreeDataChain();

  0013e	8b 4d e4	 mov	 ecx, DWORD PTR _STListInfo$[ebp+20]

; 878  : {

  00141	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 3
  00148	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _STListInfo$[ebp], OFFSET ??_7?$CList@PAUSTMNG_ITEMINFO@@PAU1@@@6B@

; 870  : 	m_nCount = 0;

  0014f	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _STListInfo$[ebp+12], 0

; 871  : 	m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;

  00156	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _STListInfo$[ebp+16], 0
  0015d	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _STListInfo$[ebp+8], 0
  00164	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _STListInfo$[ebp+4], 0

; 872  : 	m_pBlocks->FreeDataChain();

  0016b	e8 00 00 00 00	 call	 ?FreeDataChain@CPlex@@QAEXXZ ; CPlex::FreeDataChain
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 1639 : }

  00170	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00173	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0017a	59		 pop	 ecx
  0017b	5f		 pop	 edi
  0017c	5e		 pop	 esi
  0017d	5b		 pop	 ebx
  0017e	8b e5		 mov	 esp, ebp
  00180	5d		 pop	 ebp
  00181	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?OnBnClickedBtnAddall@CDlgOptimizer@@QAEXXZ$0:
  00000	8d 4d d0	 lea	 ecx, DWORD PTR _STListInfo$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$CList@PAUSTMNG_ITEMINFO@@PAU1@@@UAE@XZ ; CList<STMNG_ITEMINFO *,STMNG_ITEMINFO *>::~CList<STMNG_ITEMINFO *,STMNG_ITEMINFO *>
__unwindfunclet$?OnBnClickedBtnAddall@CDlgOptimizer@@QAEXXZ$1:
  00008	8d 4d f0	 lea	 ecx, DWORD PTR _szSTName$[ebp]
  0000b	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?OnBnClickedBtnAddall@CDlgOptimizer@@QAEXXZ$2:
  00011	8d 4d ec	 lea	 ecx, DWORD PTR $T2[ebp]
  00014	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0001a	cc		 int	 3
  0001b	cc		 int	 3
  0001c	cc		 int	 3
  0001d	cc		 int	 3
  0001e	cc		 int	 3
__ehhandler$?OnBnClickedBtnAddall@CDlgOptimizer@@QAEXXZ:
  0001f	90		 npad	 1
  00020	90		 npad	 1
  00021	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00025	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00028	8b 4a cc	 mov	 ecx, DWORD PTR [edx-52]
  0002b	33 c8		 xor	 ecx, eax
  0002d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00032	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?OnBnClickedBtnAddall@CDlgOptimizer@@QAEXXZ
  00037	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?OnBnClickedBtnAddall@CDlgOptimizer@@QAEXXZ ENDP	; CDlgOptimizer::OnBnClickedBtnAddall
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
;	COMDAT ?UnLoadSTList@CDlgOptimizer@@QAEXXZ
_TEXT	SEGMENT
?UnLoadSTList@CDlgOptimizer@@QAEXXZ PROC		; CDlgOptimizer::UnLoadSTList, COMDAT
; _this$ = ecx

; 1863 : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1864 : 	if(!m_pSTLoadMnger) return;

  00003	83 be c8 10 00
	00 00		 cmp	 DWORD PTR [esi+4296], 0
  0000a	74 3a		 je	 SHORT $LN5@UnLoadSTLi

; 1865 : 
; 1866 : 	typedef	void (FPSCW_DeleteInterfaceOfStrategy)(LONG dwKey, LONG dwType);
; 1867 : 	if(hTradeInst == NULL) return;

  0000c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hTradeInst@@3PAUHINSTANCE__@@A ; hTradeInst
  00011	85 c0		 test	 eax, eax
  00013	74 31		 je	 SHORT $LN5@UnLoadSTLi

; 1868 : 
; 1869 : 	FPSCW_DeleteInterfaceOfStrategy* pFunc = (FPSCW_DeleteInterfaceOfStrategy*)GetProcAddress(hTradeInst,_T("SCW_DeleteInterfaceOfStrategy"));

  00015	57		 push	 edi
  00016	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@CPKKMKKO@SCW_DeleteInterfaceOfStrategy@
  0001b	50		 push	 eax
  0001c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcAddress@8
  00022	8b f8		 mov	 edi, eax

; 1870 : 	if(pFunc == NULL) return ;

  00024	85 ff		 test	 edi, edi
  00026	74 1d		 je	 SHORT $LN7@UnLoadSTLi

; 1871 : 
; 1872 : 	LONG dwType = 0;	//CSTLoadManager*
; 1873 : 	if(m_pSTLoadMnger)

  00028	8b 96 c8 10 00
	00		 mov	 edx, DWORD PTR [esi+4296]
  0002e	85 d2		 test	 edx, edx
  00030	74 13		 je	 SHORT $LN7@UnLoadSTLi

; 1874 : 	{
; 1875 : 		m_pSTLoadMnger->UnloadST();

  00032	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00034	52		 push	 edx
  00035	ff 51 08	 call	 DWORD PTR [ecx+8]

; 1876 : 		pFunc((LONG)m_pSTLoadMnger, dwType);

  00038	6a 00		 push	 0
  0003a	ff b6 c8 10 00
	00		 push	 DWORD PTR [esi+4296]
  00040	ff d7		 call	 edi
  00042	83 c4 08	 add	 esp, 8
$LN7@UnLoadSTLi:
  00045	5f		 pop	 edi
$LN5@UnLoadSTLi:
  00046	5e		 pop	 esi

; 1877 : 	}	
; 1878 : }

  00047	c3		 ret	 0
?UnLoadSTList@CDlgOptimizer@@QAEXXZ ENDP		; CDlgOptimizer::UnLoadSTList
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
;	COMDAT ?LoadSTList@CDlgOptimizer@@QAEXXZ
_TEXT	SEGMENT
_szSTData_STPath$2 = -40				; size = 4
_szDataDir$3 = -36					; size = 4
_szUserDir$4 = -32					; size = 4
$T5 = -28						; size = 4
_szSTUser_STPath$6 = -24				; size = 4
$T7 = -20						; size = 4
$T8 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?LoadSTList@CDlgOptimizer@@QAEXXZ PROC			; CDlgOptimizer::LoadSTList, COMDAT
; _this$ = ecx

; 291  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?LoadSTList@CDlgOptimizer@@QAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	50		 push	 eax
  0001e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00027	8b f1		 mov	 esi, ecx

; 292  : 	//@@@06.12.07[[
; 293  : 	if(gCURRENT_COMPANY_ID==nPCTRComID_SAMSUNG)
; 294  : 	{
; 295  : 		LoadSTList_SSStyle();
; 296  : 		return;
; 297  : 	}
; 298  : 	//@@@06.12.07]]
; 299  : 	if(gCURRENT_COMPANY_ID == nPCTRComID_EUGENE)
; 300  : 	{
; 301  : 		typedef	LONG (FPSCW_GetInterfaceOfStrategy)(LONG dwType/*=0*/);
; 302  : 		hTradeInst = LoadLibrary("HWStrategyConfigureWizard.dll");

  00029	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@DLDLABLN@HWStrategyConfigureWizard?4dll@
  0002e	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T8[ebp], 0
  00035	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadLibraryA@4
  0003b	a3 00 00 00 00	 mov	 DWORD PTR ?hTradeInst@@3PAUHINSTANCE__@@A, eax ; hTradeInst

; 303  : 		if(hTradeInst == NULL) return;

  00040	85 c0		 test	 eax, eax
  00042	0f 84 d4 01 00
	00		 je	 $LN6@LoadSTList

; 304  : 
; 305  : 		FPSCW_GetInterfaceOfStrategy* pFunc = (FPSCW_GetInterfaceOfStrategy*)GetProcAddress(hTradeInst,_T("SCW_GetInterfaceOfStrategy"));

  00048	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@OHKGLIGI@SCW_GetInterfaceOfStrategy@
  0004d	50		 push	 eax
  0004e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcAddress@8

; 306  : 		if(pFunc == NULL) return ;

  00054	85 c0		 test	 eax, eax
  00056	0f 84 c0 01 00
	00		 je	 $LN6@LoadSTList

; 307  : 
; 308  : 		LONG dwType = 0;	//CSTLoadManager*
; 309  : 		m_pSTLoadMnger = (ISTLoadManager2*)pFunc(dwType);

  0005c	6a 00		 push	 0
  0005e	ff d0		 call	 eax
  00060	83 c4 04	 add	 esp, 4
  00063	89 86 c8 10 00
	00		 mov	 DWORD PTR [esi+4296], eax

; 310  : 		if(m_pSTLoadMnger)

  00069	85 c0		 test	 eax, eax
  0006b	0f 84 ab 01 00
	00		 je	 $LN6@LoadSTList

; 311  : 		{
; 312  : 			CString szDataDir = (LPCSTR)AfxGetPctrData(12);	// 12 : Data Directory

  00071	6a 0c		 push	 12			; 0000000cH
  00073	e8 00 00 00 00	 call	 ?AfxGetPctrData@@YGJH@Z	; AfxGetPctrData
  00078	50		 push	 eax
  00079	8d 4d dc	 lea	 ecx, DWORD PTR _szDataDir$3[ebp]
  0007c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z

; 313  : 			CString szUserDir = (LPCSTR)AfxGetPctrData(17);	// 17 : User Directory

  00082	6a 11		 push	 17			; 00000011H
  00084	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0008b	e8 00 00 00 00	 call	 ?AfxGetPctrData@@YGJH@Z	; AfxGetPctrData
  00090	50		 push	 eax
  00091	8d 4d e0	 lea	 ecx, DWORD PTR _szUserDir$4[ebp]
  00094	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h

; 2401 : 		CStringT strResult( str1.GetManager() );

  0009a	8d 4d dc	 lea	 ecx, DWORD PTR _szDataDir$3[ebp]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 315  : 			CString szSTData_STPath = szDataDir + "\\" + STFOLDER_ST;

  0009d	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h

; 2401 : 		CStringT strResult( str1.GetManager() );

  000a1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetManager@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEPAUIAtlStringMgr@2@XZ
  000a7	50		 push	 eax
  000a8	8d 4d e4	 lea	 ecx, DWORD PTR $T5[ebp]
  000ab	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PAUIAtlStringMgr@1@@Z
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h

; 519  : 		return( GetData()->nDataLength );

  000b1	8b 45 dc	 mov	 eax, DWORD PTR _szDataDir$3[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h

; 2403 : 		CThisSimpleString::Concatenate( strResult, str1, str1.GetLength(), psz2, CThisSimpleString::StringLength( psz2 ) );

  000b4	6a 01		 push	 1
  000b6	68 00 00 00 00	 push	 OFFSET ??_C@_01KICIPPFI@?2@

; 2404 : 
; 2405 : 		return( strResult );

  000bb	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR $T8[ebp], 1
  000c2	ff 70 f4	 push	 DWORD PTR [eax-12]
  000c5	50		 push	 eax
  000c6	8d 45 e4	 lea	 eax, DWORD PTR $T5[ebp]
  000c9	50		 push	 eax
  000ca	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Concatenate@?$CSimpleStringT@D$00@ATL@@KAXAAV12@PBDH1H@Z
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 315  : 			CString szSTData_STPath = szDataDir + "\\" + STFOLDER_ST;

  000d0	68 00 00 00 00	 push	 OFFSET ??_C@_09ONDJILNJ@STDATA?2ST@
  000d5	8d 45 e4	 lea	 eax, DWORD PTR $T5[ebp]
  000d8	50		 push	 eax
  000d9	8d 45 d8	 lea	 eax, DWORD PTR _szSTData_STPath$2[ebp]
  000dc	50		 push	 eax
  000dd	e8 00 00 00 00	 call	 ??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@ABV10@PBD@Z ; ATL::operator+
  000e2	83 c4 20	 add	 esp, 32			; 00000020H
  000e5	8d 4d e4	 lea	 ecx, DWORD PTR $T5[ebp]
  000e8	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  000ec	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl

; 321  : 		SetAtGrow(nIndex, newElement);

  000f2	8d 45 d8	 lea	 eax, DWORD PTR _szSTData_STPath$2[ebp]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 316  : 			m_arSTPath.Add(szSTData_STPath);

  000f5	8d be dc 10 00
	00		 lea	 edi, DWORD PTR [esi+4316]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl

; 321  : 		SetAtGrow(nIndex, newElement);

  000fb	50		 push	 eax
  000fc	ff 77 08	 push	 DWORD PTR [edi+8]
  000ff	8b cf		 mov	 ecx, edi
  00101	e8 00 00 00 00	 call	 ?SetAtGrow@CStringArray@@QAEXHABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ; CStringArray::SetAtGrow
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 317  : 			if(m_nOptimizerDiv != VAL_OPTIMIZER)//     . KHD :2007.1.18 

  00106	81 be 70 11 00
	00 ea 03 00 00	 cmp	 DWORD PTR [esi+4464], 1002 ; 000003eaH
  00110	0f 84 a1 00 00
	00		 je	 $LN7@LoadSTList
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h

; 2401 : 		CStringT strResult( str1.GetManager() );

  00116	8d 4d e0	 lea	 ecx, DWORD PTR _szUserDir$4[ebp]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 319  : 				CString szSTUser_STPath = szUserDir + "\\" + STFOLDER_ST;

  00119	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h

; 2401 : 		CStringT strResult( str1.GetManager() );

  0011d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetManager@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEPAUIAtlStringMgr@2@XZ
  00123	50		 push	 eax
  00124	8d 4d ec	 lea	 ecx, DWORD PTR $T7[ebp]
  00127	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PAUIAtlStringMgr@1@@Z
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h

; 519  : 		return( GetData()->nDataLength );

  0012d	8b 45 e0	 mov	 eax, DWORD PTR _szUserDir$4[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h

; 2403 : 		CThisSimpleString::Concatenate( strResult, str1, str1.GetLength(), psz2, CThisSimpleString::StringLength( psz2 ) );

  00130	6a 01		 push	 1
  00132	68 00 00 00 00	 push	 OFFSET ??_C@_01KICIPPFI@?2@

; 2404 : 
; 2405 : 		return( strResult );

  00137	c7 45 f0 04 00
	00 00		 mov	 DWORD PTR $T8[ebp], 4
  0013e	ff 70 f4	 push	 DWORD PTR [eax-12]
  00141	50		 push	 eax
  00142	8d 45 ec	 lea	 eax, DWORD PTR $T7[ebp]
  00145	50		 push	 eax
  00146	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Concatenate@?$CSimpleStringT@D$00@ATL@@KAXAAV12@PBDH1H@Z
  0014c	83 c4 14	 add	 esp, 20			; 00000014H

; 2401 : 		CStringT strResult( str1.GetManager() );

  0014f	8d 4d ec	 lea	 ecx, DWORD PTR $T7[ebp]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 319  : 				CString szSTUser_STPath = szUserDir + "\\" + STFOLDER_ST;

  00152	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h

; 2401 : 		CStringT strResult( str1.GetManager() );

  00156	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetManager@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEPAUIAtlStringMgr@2@XZ
  0015c	50		 push	 eax
  0015d	8d 4d e8	 lea	 ecx, DWORD PTR _szSTUser_STPath$6[ebp]
  00160	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PAUIAtlStringMgr@1@@Z
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h

; 519  : 		return( GetData()->nDataLength );

  00166	8b 45 ec	 mov	 eax, DWORD PTR $T7[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h

; 2403 : 		CThisSimpleString::Concatenate( strResult, str1, str1.GetLength(), psz2, CThisSimpleString::StringLength( psz2 ) );

  00169	6a 09		 push	 9
  0016b	68 00 00 00 00	 push	 OFFSET ??_C@_09ONDJILNJ@STDATA?2ST@

; 2404 : 
; 2405 : 		return( strResult );

  00170	c7 45 f0 0c 00
	00 00		 mov	 DWORD PTR $T8[ebp], 12	; 0000000cH
  00177	ff 70 f4	 push	 DWORD PTR [eax-12]
  0017a	50		 push	 eax
  0017b	8d 45 e8	 lea	 eax, DWORD PTR _szSTUser_STPath$6[ebp]
  0017e	50		 push	 eax
  0017f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Concatenate@?$CSimpleStringT@D$00@ATL@@KAXAAV12@PBDH1H@Z
  00185	83 c4 14	 add	 esp, 20			; 00000014H
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 319  : 				CString szSTUser_STPath = szUserDir + "\\" + STFOLDER_ST;

  00188	c7 45 f0 08 00
	00 00		 mov	 DWORD PTR $T8[ebp], 8
  0018f	8d 4d ec	 lea	 ecx, DWORD PTR $T7[ebp]
  00192	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
  00196	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl

; 321  : 		SetAtGrow(nIndex, newElement);

  0019c	8d 45 e8	 lea	 eax, DWORD PTR _szSTUser_STPath$6[ebp]
  0019f	8b cf		 mov	 ecx, edi
  001a1	50		 push	 eax
  001a2	ff 77 08	 push	 DWORD PTR [edi+8]
  001a5	e8 00 00 00 00	 call	 ?SetAtGrow@CStringArray@@QAEXHABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ; CStringArray::SetAtGrow
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 321  : 			}	

  001aa	8d 4d e8	 lea	 ecx, DWORD PTR _szSTUser_STPath$6[ebp]
  001ad	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  001b1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$LN7@LoadSTList:

; 322  : 
; 323  : //			m_pSTLoadMnger->Init(TRUE, "*.ST", &m_ilSTIcon);
; 324  : 			m_pSTLoadMnger->Init(TRUE, "*.ST", &m_ImageListIcon);

  001b7	8d 86 cc 10 00
	00		 lea	 eax, DWORD PTR [esi+4300]
  001bd	50		 push	 eax
  001be	51		 push	 ecx
  001bf	8b cc		 mov	 ecx, esp
  001c1	68 00 00 00 00	 push	 OFFSET ??_C@_04ECGMOPPD@?$CK?4ST@
  001c6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  001cc	8b 86 c8 10 00
	00		 mov	 eax, DWORD PTR [esi+4296]
  001d2	6a 01		 push	 1
  001d4	50		 push	 eax
  001d5	8b 08		 mov	 ecx, DWORD PTR [eax]
  001d7	ff 11		 call	 DWORD PTR [ecx]

; 325  : 			m_pSTLoadMnger->SetUseBoldFont(FALSE);

  001d9	8b 86 c8 10 00
	00		 mov	 eax, DWORD PTR [esi+4296]
  001df	6a 00		 push	 0
  001e1	50		 push	 eax
  001e2	8b 08		 mov	 ecx, DWORD PTR [eax]
  001e4	ff 51 20	 call	 DWORD PTR [ecx+32]

; 326  : 
; 327  : 			int p_LoadOption = 1;
; 328  : 			m_pSTLoadMnger->LoadST2(&m_wndOutBar, &m_arSTPath, 0, 0, p_LoadOption);

  001e7	8b 8e c8 10 00
	00		 mov	 ecx, DWORD PTR [esi+4296]
  001ed	8d 86 60 0f 00
	00		 lea	 eax, DWORD PTR [esi+3936]
  001f3	6a 01		 push	 1
  001f5	6a 00		 push	 0
  001f7	6a 00		 push	 0
  001f9	8b 11		 mov	 edx, DWORD PTR [ecx]
  001fb	57		 push	 edi
  001fc	50		 push	 eax
  001fd	51		 push	 ecx
  001fe	ff 52 24	 call	 DWORD PTR [edx+36]

; 329  : 		}

  00201	8d 4d d8	 lea	 ecx, DWORD PTR _szSTData_STPath$2[ebp]
  00204	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0020a	8d 4d e0	 lea	 ecx, DWORD PTR _szUserDir$4[ebp]
  0020d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00213	8d 4d dc	 lea	 ecx, DWORD PTR _szDataDir$3[ebp]
  00216	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$LN6@LoadSTList:

; 330  : 	}
; 331  : }

  0021c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0021f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00226	59		 pop	 ecx
  00227	5f		 pop	 edi
  00228	5e		 pop	 esi
  00229	8b e5		 mov	 esp, ebp
  0022b	5d		 pop	 ebp
  0022c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LoadSTList@CDlgOptimizer@@QAEXXZ$0:
  00000	8d 4d dc	 lea	 ecx, DWORD PTR _szDataDir$3[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?LoadSTList@CDlgOptimizer@@QAEXXZ$1:
  00009	8d 4d e0	 lea	 ecx, DWORD PTR _szUserDir$4[ebp]
  0000c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?LoadSTList@CDlgOptimizer@@QAEXXZ$7:
  00012	8b 45 f0	 mov	 eax, DWORD PTR $T8[ebp]
  00015	83 e0 01	 and	 eax, 1
  00018	0f 84 0d 00 00
	00		 je	 $LN30@LoadSTList
  0001e	83 65 f0 fe	 and	 DWORD PTR $T8[ebp], -2	; fffffffeH
  00022	8d 4d e4	 lea	 ecx, DWORD PTR $T5[ebp]
  00025	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$LN30@LoadSTList:
  0002b	c3		 ret	 0
__unwindfunclet$?LoadSTList@CDlgOptimizer@@QAEXXZ$3:
  0002c	8d 4d d8	 lea	 ecx, DWORD PTR _szSTData_STPath$2[ebp]
  0002f	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?LoadSTList@CDlgOptimizer@@QAEXXZ$9:
  00035	8b 45 f0	 mov	 eax, DWORD PTR $T8[ebp]
  00038	83 e0 04	 and	 eax, 4
  0003b	0f 84 0d 00 00
	00		 je	 $LN58@LoadSTList
  00041	83 65 f0 fb	 and	 DWORD PTR $T8[ebp], -5	; fffffffbH
  00045	8d 4d ec	 lea	 ecx, DWORD PTR $T7[ebp]
  00048	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$LN58@LoadSTList:
  0004e	c3		 ret	 0
__unwindfunclet$?LoadSTList@CDlgOptimizer@@QAEXXZ$10:
  0004f	8b 45 f0	 mov	 eax, DWORD PTR $T8[ebp]
  00052	83 e0 08	 and	 eax, 8
  00055	0f 84 0d 00 00
	00		 je	 $LN71@LoadSTList
  0005b	83 65 f0 f7	 and	 DWORD PTR $T8[ebp], -9	; fffffff7H
  0005f	8d 4d e8	 lea	 ecx, DWORD PTR _szSTUser_STPath$6[ebp]
  00062	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$LN71@LoadSTList:
  00068	c3		 ret	 0
  00069	cc		 int	 3
  0006a	cc		 int	 3
  0006b	cc		 int	 3
  0006c	cc		 int	 3
  0006d	cc		 int	 3
__ehhandler$?LoadSTList@CDlgOptimizer@@QAEXXZ:
  0006e	90		 npad	 1
  0006f	90		 npad	 1
  00070	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00074	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00077	8b 4a d8	 mov	 ecx, DWORD PTR [edx-40]
  0007a	33 c8		 xor	 ecx, eax
  0007c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00081	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?LoadSTList@CDlgOptimizer@@QAEXXZ
  00086	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?LoadSTList@CDlgOptimizer@@QAEXXZ ENDP			; CDlgOptimizer::LoadSTList
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin1.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin1.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin1.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin1.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
;	COMDAT ?LoadOutlookBar@CDlgOptimizer@@QAEXXZ
_TEXT	SEGMENT
_clrOLBkgrnd$2 = -60					; size = 4
_clrOLOutLine$3 = -56					; size = 4
_this$GSCopy$1$ = -52					; size = 4
_szImageChartDir$ = -48					; size = 4
_bitmap$ = -44						; size = 8
_strImageDir$ = -36					; size = 4
_rc2$ = -32						; size = 16
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?LoadOutlookBar@CDlgOptimizer@@QAEXXZ PROC		; CDlgOptimizer::LoadOutlookBar, COMDAT
; _this$ = ecx

; 190  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?LoadOutlookBar@CDlgOptimizer@@QAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 30	 sub	 esp, 48			; 00000030H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b f1		 mov	 esi, ecx
  0002d	89 75 cc	 mov	 DWORD PTR _this$GSCopy$1$[ebp], esi
  00030	0f 57 c0	 xorps	 xmm0, xmm0

; 192  : 	GetDlgItem(IDC_STFRAME)->GetWindowRect(rc2);

  00033	68 e6 32 00 00	 push	 13030			; 000032e6H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h

; 528  : 	left = 0;

  00038	0f 11 45 e0	 movups	 XMMWORD PTR _rc2$[ebp], xmm0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 192  : 	GetDlgItem(IDC_STFRAME)->GetWindowRect(rc2);

  0003c	e8 00 00 00 00	 call	 ?GetDlgItem@CWnd@@QBEPAV1@H@Z ; CWnd::GetDlgItem
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl

; 84   : 	{ ASSERT(::IsWindow(m_hWnd)); ::GetWindowRect(m_hWnd, lpRect); }

  00041	8d 4d e0	 lea	 ecx, DWORD PTR _rc2$[ebp]
  00044	51		 push	 ecx
  00045	ff 70 20	 push	 DWORD PTR [eax+32]
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowRect@8
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 193  : 	ScreenToClient(rc2);

  0004e	8d 45 e0	 lea	 eax, DWORD PTR _rc2$[ebp]
  00051	8b ce		 mov	 ecx, esi
  00053	50		 push	 eax
  00054	e8 00 00 00 00	 call	 ?ScreenToClient@CWnd@@QBEXPAUtagRECT@@@Z ; CWnd::ScreenToClient

; 194  : 	rc2.top += 3;

  00059	83 45 e4 03	 add	 DWORD PTR _rc2$[ebp+4], 3

; 195  : 
; 196  : 	CString szImageChartDir = m_strImageDir + "\\drchart";

  0005d	8d 86 4c 05 00
	00		 lea	 eax, DWORD PTR [esi+1356]
  00063	68 00 00 00 00	 push	 OFFSET ??_C@_08BKFIOHKC@?2drchart@
  00068	50		 push	 eax
  00069	8d 45 d0	 lea	 eax, DWORD PTR _szImageChartDir$[ebp]
  0006c	50		 push	 eax
  0006d	e8 00 00 00 00	 call	 ??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@ABV10@PBD@Z ; ATL::operator+
  00072	83 c4 0c	 add	 esp, 12			; 0000000cH
  00075	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin1.inl

; 70   : 	{ m_hObject = NULL; }

  0007c	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _bitmap$[ebp+4], 0

; 177  : 	{ }

  00083	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _bitmap$[ebp], OFFSET ??_7CBitmap@@6B@
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 222  : 	CString strImageDir;

  0008a	8d 4d dc	 lea	 ecx, DWORD PTR _strImageDir$[ebp]
  0008d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 223  : 	strImageDir.Format("%s\\folder.bmp", szImageChartDir);

  00093	ff 75 d0	 push	 DWORD PTR _szImageChartDir$[ebp]
  00096	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp_?Format@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAAXPBDZZ
  0009c	8d 45 dc	 lea	 eax, DWORD PTR _strImageDir$[ebp]
  0009f	68 00 00 00 00	 push	 OFFSET ??_C@_0O@DADNAINN@?$CFs?2folder?4bmp@
  000a4	50		 push	 eax
  000a5	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  000a9	ff d3		 call	 ebx

; 224  : 	bitmap.Attach((HBITMAP)LoadImage(NULL, (LPSTR)(LPCTSTR)strImageDir, IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE|LR_CREATEDIBSECTION|LR_DEFAULTSIZE));

  000ab	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__LoadImageA@24
  000b1	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b4	68 50 20 00 00	 push	 8272			; 00002050H
  000b9	6a 00		 push	 0
  000bb	6a 00		 push	 0
  000bd	6a 00		 push	 0
  000bf	ff 75 dc	 push	 DWORD PTR _strImageDir$[ebp]
  000c2	6a 00		 push	 0
  000c4	ff d7		 call	 edi
  000c6	50		 push	 eax
  000c7	8d 4d d4	 lea	 ecx, DWORD PTR _bitmap$[ebp]
  000ca	e8 00 00 00 00	 call	 ?Attach@CGdiObject@@QAEHPAX@Z ; CGdiObject::Attach

; 225  : 	m_ImageListIcon.Create(18, 18, ILC_MASK | ILC_COLORDDB, 1, 1);

  000cf	6a 01		 push	 1
  000d1	6a 01		 push	 1
  000d3	68 ff 00 00 00	 push	 255			; 000000ffH
  000d8	6a 12		 push	 18			; 00000012H
  000da	8d 8e cc 10 00
	00		 lea	 ecx, DWORD PTR [esi+4300]
  000e0	6a 12		 push	 18			; 00000012H
  000e2	e8 00 00 00 00	 call	 ?Create@CImageList@@QAEHHHIHH@Z ; CImageList::Create
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin1.inl

; 859  : 	{ ASSERT(m_hImageList != NULL); return ImageList_AddMasked(m_hImageList, (HBITMAP)pbmImage->GetSafeHandle(), crMask); }

  000e7	68 ff 00 ff 00	 push	 16711935		; 00ff00ffH
  000ec	ff 75 d8	 push	 DWORD PTR _bitmap$[ebp+4]
  000ef	ff b6 d0 10 00
	00		 push	 DWORD PTR [esi+4304]
  000f5	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__ImageList_AddMasked@12
  000fb	ff d6		 call	 esi
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 227  : 	bitmap.DeleteObject();

  000fd	8d 4d d4	 lea	 ecx, DWORD PTR _bitmap$[ebp]
  00100	e8 00 00 00 00	 call	 ?DeleteObject@CGdiObject@@QAEHXZ ; CGdiObject::DeleteObject

; 228  : 
; 229  : 	//20061213   
; 230  : 	//LeftBar   
; 231  : //@ 
; 232  : 	strImageDir = "";

  00105	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@@
  0010a	8d 4d dc	 lea	 ecx, DWORD PTR _strImageDir$[ebp]
  0010d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z

; 233  : 	strImageDir.Format("%s\\outbar_icon.bmp", szImageChartDir);

  00113	ff 75 d0	 push	 DWORD PTR _szImageChartDir$[ebp]
  00116	8d 45 dc	 lea	 eax, DWORD PTR _strImageDir$[ebp]
  00119	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OCOIJGGE@?$CFs?2outbar_icon?4bmp@
  0011e	50		 push	 eax
  0011f	ff d3		 call	 ebx
  00121	83 c4 0c	 add	 esp, 12			; 0000000cH

; 234  : 	bitmap.Attach((HBITMAP)LoadImage(NULL, (LPSTR)(LPCTSTR)strImageDir, IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE|LR_CREATEDIBSECTION|LR_DEFAULTSIZE));

  00124	68 50 20 00 00	 push	 8272			; 00002050H
  00129	6a 00		 push	 0
  0012b	6a 00		 push	 0
  0012d	6a 00		 push	 0
  0012f	ff 75 dc	 push	 DWORD PTR _strImageDir$[ebp]
  00132	6a 00		 push	 0
  00134	ff d7		 call	 edi
  00136	50		 push	 eax
  00137	8d 4d d4	 lea	 ecx, DWORD PTR _bitmap$[ebp]
  0013a	e8 00 00 00 00	 call	 ?Attach@CGdiObject@@QAEHPAX@Z ; CGdiObject::Attach

; 235  : 	m_ImageOutbarIcon.Create(20, 20, ILC_MASK | ILC_COLORDDB, 1, 1);

  0013f	8b 5d cc	 mov	 ebx, DWORD PTR _this$GSCopy$1$[ebp]
  00142	6a 01		 push	 1
  00144	6a 01		 push	 1
  00146	68 ff 00 00 00	 push	 255			; 000000ffH
  0014b	6a 14		 push	 20			; 00000014H
  0014d	8d bb d4 10 00
	00		 lea	 edi, DWORD PTR [ebx+4308]
  00153	6a 14		 push	 20			; 00000014H
  00155	8b cf		 mov	 ecx, edi
  00157	e8 00 00 00 00	 call	 ?Create@CImageList@@QAEHHHIHH@Z ; CImageList::Create
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin1.inl

; 859  : 	{ ASSERT(m_hImageList != NULL); return ImageList_AddMasked(m_hImageList, (HBITMAP)pbmImage->GetSafeHandle(), crMask); }

  0015c	68 ff 00 ff 00	 push	 16711935		; 00ff00ffH
  00161	ff 75 d8	 push	 DWORD PTR _bitmap$[ebp+4]
  00164	ff b3 d8 10 00
	00		 push	 DWORD PTR [ebx+4312]
  0016a	ff d6		 call	 esi
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 237  : 	bitmap.DeleteObject();

  0016c	8d 4d d4	 lea	 ecx, DWORD PTR _bitmap$[ebp]
  0016f	e8 00 00 00 00	 call	 ?DeleteObject@CGdiObject@@QAEHXZ ; CGdiObject::DeleteObject

; 238  : //@ 
; 239  : 
; 240  : 	DWORD dwf = fDragItems|fEditGroups|fEditItems|fRemoveGroups|fRemoveItems|fAddGroups|fAnimation;
; 241  : 	if(gCURRENT_COMPANY_ID==nPCTRComID_SAMSUNG)
; 242  : 	{
; 243  : 		typedef	LONG (FnSCW_IGfxOutBarCtrl)(int nType, long dwValue, long dwReserved1);
; 244  : 		if(!m_hSTConfigureWizardInst)
; 245  : 			m_hSTConfigureWizardInst  = LoadLibrary("Chart\\HWStrategyConfigureWizard.dll");
; 246  : 		if(!m_hSTConfigureWizardInst) return;
; 247  : 
; 248  : 		FnSCW_IGfxOutBarCtrl* pFunc = (FnSCW_IGfxOutBarCtrl*)GetProcAddress(m_hSTConfigureWizardInst,_T("SCW_IGfxOutBarCtrl"));
; 249  : 		if(pFunc == NULL) return ;
; 250  : 
; 251  : 		m_pWndOutBar = (IGfxOutBarCtrl2*)pFunc(0, 0, 0);
; 252  : 
; 253  : 		m_pWndOutBar->CreateOutBar(WS_CHILD|WS_VISIBLE, rc2, this, IDC_OUTLOOKBAR, dwf);
; 254  : 		m_pWndOutBar->Setcr3dFace(RGB(191,211,233));
; 255  : 		m_pWndOutBar->Setcr3dUnFace(RGB(218,218,218));
; 256  : 		m_pWndOutBar->GetCoutBarCtrl()->SetOwner(this);
; 257  : 
; 258  : 		int  nfSmallIcon = 1 << 0;
; 259  : //		m_pWndOutBar->SetImageList(&m_ilSTIcon, nfSmallIcon);
; 260  : //		m_pWndOutBar->SetFolderImageList(&m_ilW190H21, 0, 2, 3);
; 261  : 		m_pWndOutBar->SetImageList(&m_ImageListIcon, nfSmallIcon);
; 262  : 		m_pWndOutBar->SetFolderImageList(&m_ImageOutbarIcon, 0, 2, 3);
; 263  : 	}
; 264  : 	else
; 265  : 	{
; 266  : 		m_wndOutBar.Create(WS_CHILD|WS_VISIBLE, rc2, this, IDC_OUTLOOKBAR, dwf);

  00174	68 fc 01 00 00	 push	 508			; 000001fcH
  00179	68 e8 03 00 00	 push	 1000			; 000003e8H
  0017e	53		 push	 ebx
  0017f	8d 45 e0	 lea	 eax, DWORD PTR _rc2$[ebp]
  00182	50		 push	 eax
  00183	68 00 00 00 50	 push	 1342177280		; 50000000H
  00188	8d 8b 60 0f 00
	00		 lea	 ecx, DWORD PTR [ebx+3936]
  0018e	e8 00 00 00 00	 call	 ?Create@CSTGfxOutBarCtrl@@QAEHKABUtagRECT@@PAVCWnd@@IK@Z ; CSTGfxOutBarCtrl::Create
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl

; 29   : 	{ m_hWndOwner = pOwnerWnd != NULL ? pOwnerWnd->m_hWnd : NULL; }

  00193	8b 43 20	 mov	 eax, DWORD PTR [ebx+32]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 274  : 		m_wndOutBar.SetImageList(&m_ImageListIcon, nfSmallIcon);

  00196	8d 8b 60 0f 00
	00		 lea	 ecx, DWORD PTR [ebx+3936]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl

; 29   : 	{ m_hWndOwner = pOwnerWnd != NULL ? pOwnerWnd->m_hWnd : NULL; }

  0019c	89 83 bc 0f 00
	00		 mov	 DWORD PTR [ebx+4028], eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 274  : 		m_wndOutBar.SetImageList(&m_ImageListIcon, nfSmallIcon);

  001a2	8d 83 cc 10 00
	00		 lea	 eax, DWORD PTR [ebx+4300]
  001a8	6a 01		 push	 1
  001aa	50		 push	 eax
  001ab	c7 83 ec 0f 00
	00 bf d3 e9 00	 mov	 DWORD PTR [ebx+4076], 15324095 ; 00e9d3bfH
  001b5	c7 83 f0 0f 00
	00 ef f2 f7 00	 mov	 DWORD PTR [ebx+4080], 16249583 ; 00f7f2efH
  001bf	e8 00 00 00 00	 call	 ?SetImageList@CSTGfxOutBarCtrl@@QAEPAVCImageList@@PAV2@H@Z ; CSTGfxOutBarCtrl::SetImageList

; 275  : 		m_wndOutBar.SetFolderImageList(&m_ImageOutbarIcon, 0, 2, 3);

  001c4	6a 03		 push	 3
  001c6	6a 02		 push	 2
  001c8	6a 00		 push	 0
  001ca	57		 push	 edi
  001cb	8d 8b 60 0f 00
	00		 lea	 ecx, DWORD PTR [ebx+3936]
  001d1	e8 00 00 00 00	 call	 ?SetFolderImageList@CSTGfxOutBarCtrl@@QAEXPAVCImageList@@HHH@Z ; CSTGfxOutBarCtrl::SetFolderImageList

; 276  : 
; 277  : 		COLORREF clrOLBkgrnd;
; 278  : 		COLORREF clrOLOutLine;
; 279  : 		if(m_pChartInterface && ((ISTInterface*)m_pChartInterface)->GetOutBarColor(clrOLBkgrnd, clrOLOutLine))

  001d6	8b 8b 74 11 00
	00		 mov	 ecx, DWORD PTR [ebx+4468]
  001dc	85 c9		 test	 ecx, ecx
  001de	74 2a		 je	 SHORT $LN7@LoadOutloo
  001e0	8b 01		 mov	 eax, DWORD PTR [ecx]
  001e2	8d 55 c8	 lea	 edx, DWORD PTR _clrOLOutLine$3[ebp]
  001e5	52		 push	 edx
  001e6	8d 55 c4	 lea	 edx, DWORD PTR _clrOLBkgrnd$2[ebp]
  001e9	52		 push	 edx
  001ea	51		 push	 ecx
  001eb	ff 50 04	 call	 DWORD PTR [eax+4]
  001ee	85 c0		 test	 eax, eax
  001f0	74 18		 je	 SHORT $LN7@LoadOutloo

; 280  : 		{
; 281  : 			m_wndOutBar.cr3dFace = clrOLOutLine;

  001f2	8b 45 c8	 mov	 eax, DWORD PTR _clrOLOutLine$3[ebp]
  001f5	89 83 ec 0f 00
	00		 mov	 DWORD PTR [ebx+4076], eax

; 282  : 			m_wndOutBar.cr3dUnFace = clrOLOutLine;

  001fb	89 83 f0 0f 00
	00		 mov	 DWORD PTR [ebx+4080], eax

; 283  : 			m_wndOutBar.crBackGroundColor1 = clrOLBkgrnd;

  00201	8b 45 c4	 mov	 eax, DWORD PTR _clrOLBkgrnd$2[ebp]
  00204	89 83 e4 0f 00
	00		 mov	 DWORD PTR [ebx+4068], eax
$LN7@LoadOutloo:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl

; 286  : 	{ SetSize(0); }

  0020a	6a ff		 push	 -1
  0020c	6a 00		 push	 0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 286  : 	m_arSTPath.RemoveAll();

  0020e	8d 8b dc 10 00
	00		 lea	 ecx, DWORD PTR [ebx+4316]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl

; 286  : 	{ SetSize(0); }

  00214	e8 00 00 00 00	 call	 ?SetSize@CStringArray@@QAEXHH@Z ; CStringArray::SetSize
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 287  : 	LoadSTList();

  00219	8b cb		 mov	 ecx, ebx
  0021b	e8 00 00 00 00	 call	 ?LoadSTList@CDlgOptimizer@@QAEXXZ ; CDlgOptimizer::LoadSTList

; 288  : }

  00220	8d 4d dc	 lea	 ecx, DWORD PTR _strImageDir$[ebp]
  00223	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin1.inl

; 179  : 	{ }

  00229	8d 4d d4	 lea	 ecx, DWORD PTR _bitmap$[ebp]
  0022c	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _bitmap$[ebp], OFFSET ??_7CBitmap@@6B@
  00233	e8 00 00 00 00	 call	 ??1CGdiObject@@UAE@XZ	; CGdiObject::~CGdiObject
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 288  : }

  00238	8d 4d d0	 lea	 ecx, DWORD PTR _szImageChartDir$[ebp]
  0023b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00241	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00244	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0024b	59		 pop	 ecx
  0024c	5f		 pop	 edi
  0024d	5e		 pop	 esi
  0024e	5b		 pop	 ebx
  0024f	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00252	33 cd		 xor	 ecx, ebp
  00254	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00259	8b e5		 mov	 esp, ebp
  0025b	5d		 pop	 ebp
  0025c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LoadOutlookBar@CDlgOptimizer@@QAEXXZ$0:
  00000	8d 4d d0	 lea	 ecx, DWORD PTR _szImageChartDir$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?LoadOutlookBar@CDlgOptimizer@@QAEXXZ$1:
  00009	8d 4d d4	 lea	 ecx, DWORD PTR _bitmap$[ebp]
  0000c	e9 00 00 00 00	 jmp	 ??1CBitmap@@UAE@XZ	; CBitmap::~CBitmap
__unwindfunclet$?LoadOutlookBar@CDlgOptimizer@@QAEXXZ$2:
  00011	8d 4d dc	 lea	 ecx, DWORD PTR _strImageDir$[ebp]
  00014	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0001a	cc		 int	 3
  0001b	cc		 int	 3
  0001c	cc		 int	 3
  0001d	cc		 int	 3
  0001e	cc		 int	 3
__ehhandler$?LoadOutlookBar@CDlgOptimizer@@QAEXXZ:
  0001f	90		 npad	 1
  00020	90		 npad	 1
  00021	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00025	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00028	8b 4a c0	 mov	 ecx, DWORD PTR [edx-64]
  0002b	33 c8		 xor	 ecx, eax
  0002d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00032	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00035	33 c8		 xor	 ecx, eax
  00037	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?LoadOutlookBar@CDlgOptimizer@@QAEXXZ
  00041	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?LoadOutlookBar@CDlgOptimizer@@QAEXXZ ENDP		; CDlgOptimizer::LoadOutlookBar
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
;	COMDAT ?InitSkin@CDlgOptimizer@@QAEXXZ
_TEXT	SEGMENT
?InitSkin@CDlgOptimizer@@QAEXXZ PROC			; CDlgOptimizer::InitSkin, COMDAT
; _this$ = ecx

; 1608 : 	//m_BtnDef.SetSkin(IDB_BITMAP1_up,IDB_BITMAP1_over,IDB_BITMAP1_up,IDB_BITMAP1_dis);
; 1609 : 	//m_BtnStop.SetSkin(IDB_BITMAP3_up,IDB_BITMAP3_over,IDB_BITMAP3_up,IDB_BITMAP3_dis);
; 1610 : 	//m_BtnOpt.SetSkin(IDB_BITMAP2_up,IDB_BITMAP2_over,IDB_BITMAP2_up,IDB_BITMAP2_dis);
; 1611 : }

  00000	c2 00 00	 ret	 0
?InitSkin@CDlgOptimizer@@QAEXXZ ENDP			; CDlgOptimizer::InitSkin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
;	COMDAT ?SetControlState@CDlgOptimizer@@QAEXH@Z
_TEXT	SEGMENT
_State$ = 8						; size = 4
?SetControlState@CDlgOptimizer@@QAEXH@Z PROC		; CDlgOptimizer::SetControlState, COMDAT
; _this$ = ecx

; 1490 : 	//if(State)//  Enable . 
; 1491 : 	//{
; 1492 : 	//	GetDlgItem(IDC_COM_INDEX)->EnableWindow(TRUE);
; 1493 : 	//	GetDlgItem(IDC_COM_MEDO)->EnableWindow(TRUE);
; 1494 : 	//	GetDlgItem(IDC_COM_MESU)->EnableWindow(TRUE);
; 1495 : 	//	GetDlgItem(IDC_MEDOGIJUN)->EnableWindow(TRUE);
; 1496 : 	//	GetDlgItem(IDC_SPIN_MEDO)->EnableWindow(TRUE);
; 1497 : 	//	GetDlgItem(IDC_MESUGIJUN)->EnableWindow(TRUE);
; 1498 : 	//	GetDlgItem(IDC_SPIN_MESU)->EnableWindow(TRUE);
; 1499 : 	//	ST_VALUESET *ValueSet;
; 1500 : 	//	for(int i =0 ;i< m_arrayValue.GetSize();i++)
; 1501 : 	//	{
; 1502 : 	//		ValueSet = m_arrayValue.GetAt(i);
; 1503 : 	//		ValueSet->stEdit->EnableWindow(TRUE);
; 1504 : 	//		ValueSet->stSpinBtn->EnableWindow(TRUE);
; 1505 : 	//	}
; 1506 : 	//}
; 1507 : 	//else
; 1508 : 	//{
; 1509 : 	//	GetDlgItem(IDC_COM_INDEX)->EnableWindow(FALSE);
; 1510 : 	//	GetDlgItem(IDC_COM_MEDO)->EnableWindow(FALSE);
; 1511 : 	//	GetDlgItem(IDC_COM_MESU)->EnableWindow(FALSE);
; 1512 : 	//	GetDlgItem(IDC_MEDOGIJUN)->EnableWindow(FALSE);
; 1513 : 	//	GetDlgItem(IDC_SPIN_MEDO)->EnableWindow(FALSE);
; 1514 : 	//	GetDlgItem(IDC_MESUGIJUN)->EnableWindow(FALSE);
; 1515 : 	//	GetDlgItem(IDC_SPIN_MESU)->EnableWindow(FALSE);
; 1516 : 	//	ST_VALUESET *ValueSet;
; 1517 : 	//	for(int i =0 ;i< m_arrayValue.GetSize();i++)
; 1518 : 	//	{
; 1519 : 	//		ValueSet = m_arrayValue.GetAt(i);
; 1520 : 	//		ValueSet->stEdit->EnableWindow(FALSE);
; 1521 : 	//		ValueSet->stSpinBtn->EnableWindow(FALSE);
; 1522 : 	//	}
; 1523 : 	//}
; 1524 : }

  00000	c2 04 00	 ret	 4
?SetControlState@CDlgOptimizer@@QAEXH@Z ENDP		; CDlgOptimizer::SetControlState
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
;	COMDAT ?SearchFileToData@CDlgOptimizer@@QAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V23@0@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_strIndex$ = 12						; size = 4
_strPath$ = 16						; size = 4
?SearchFileToData@CDlgOptimizer@@QAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V23@0@Z PROC ; CDlgOptimizer::SearchFileToData, COMDAT
; _this$ = ecx

; 785  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?SearchFileToData@CDlgOptimizer@@QAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V23@0@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 786  : 	/*CString strDataName;
; 787  : 	CHAR inBuf[80]; 
; 788  : 	m_CtlComIndex.GetLBText(m_CtlComIndex.GetCurSel(),strDataName);
; 789  : 	::GetPrivateProfileString(strDataName,strIndex,"N",inBuf,80,strPath);
; 790  : 	strIndex = inBuf;*/
; 791  : 	
; 792  : 
; 793  : 	return strIndex;

  00022	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00025	8d 45 0c	 lea	 eax, DWORD PTR _strIndex$[ebp]
  00028	50		 push	 eax
  00029	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00030	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z
  00036	8d 4d 0c	 lea	 ecx, DWORD PTR _strIndex$[ebp]
  00039	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0003f	8d 4d 10	 lea	 ecx, DWORD PTR _strPath$[ebp]
  00042	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00048	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 794  : }

  0004b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00055	59		 pop	 ecx
  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SearchFileToData@CDlgOptimizer@@QAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V23@0@Z$0:
  00000	8d 4d 10	 lea	 ecx, DWORD PTR _strPath$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?SearchFileToData@CDlgOptimizer@@QAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V23@0@Z$1:
  00009	8d 4d 0c	 lea	 ecx, DWORD PTR _strIndex$[ebp]
  0000c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
  00015	cc		 int	 3
  00016	cc		 int	 3
__ehhandler$?SearchFileToData@CDlgOptimizer@@QAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V23@0@Z:
  00017	90		 npad	 1
  00018	90		 npad	 1
  00019	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00020	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?SearchFileToData@CDlgOptimizer@@QAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V23@0@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?SearchFileToData@CDlgOptimizer@@QAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V23@0@Z ENDP ; CDlgOptimizer::SearchFileToData
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
;	COMDAT ?MedoMesuComboDataParsing@CDlgOptimizer@@QAEXXZ
_TEXT	SEGMENT
?MedoMesuComboDataParsing@CDlgOptimizer@@QAEXXZ PROC	; CDlgOptimizer::MedoMesuComboDataParsing, COMDAT
; _this$ = ecx

; 708  : 
; 709  : 	//CString strIndex;
; 710  : 	//strIndex = SearchFileToData("Index",m_strDataDir+FILE_OPTIMIZE_CFG);
; 711  : 	//m_CtlComMesu.ResetContent();
; 712  : 	//m_CtlComMedo.ResetContent();
; 713  : 	////00000 : Signal, 0  ,   , , 
; 714  : 	//if(strIndex == "N")
; 715  : 	//{
; 716  : 	//	AfxMessageBox("    .");
; 717  : 	//	return;
; 718  : 	//}
; 719  : 	//else //00000 
; 720  : 	//{
; 721  : 	//	for(int i = 0 ;i < strIndex.GetLength();i++)
; 722  : 	//	{
; 723  : 	//		CString OneData = strIndex.GetAt(i); 
; 724  : 	//		int DataIndex = atoi(OneData);
; 725  : 	//		switch(i)
; 726  : 	//		{
; 727  : 	//
; 728  : 	//		case 0: //Signal
; 729  : 	//			if(DataIndex)
; 730  : 	//			{
; 731  : 	//				m_CtlComMesu.AddString(STR_INDEX_CROSSABOVE_ANOTHER);
; 732  : 	//				m_CtlComMesu.AddString(STR_INDEX_CROSSBELOW_ANOTHER);
; 733  : 	//				
; 734  : 	//				m_CtlComMedo.AddString(STR_INDEX_CROSSABOVE_ANOTHER);
; 735  : 	//				m_CtlComMedo.AddString(STR_INDEX_CROSSBELOW_ANOTHER);
; 736  : 	//			}
; 737  : 	//			break;
; 738  : 	//		case 1: // 0 Line
; 739  : 	//			if(DataIndex)
; 740  : 	//			{
; 741  : 	//				m_CtlComMesu.AddString(STR_INDEX_ZEROABOVE_BASIS);
; 742  : 	//				m_CtlComMesu.AddString(STR_INDEX_ZEROBELOW_BASIS);
; 743  : 
; 744  : 	//				m_CtlComMedo.AddString(STR_INDEX_ZEROABOVE_BASIS);
; 745  : 	//				m_CtlComMedo.AddString(STR_INDEX_ZEROBELOW_BASIS);
; 746  : 	//			}
; 747  : 	//			break;
; 748  : 	//		case 2: //  :  
; 749  : 	//			if(DataIndex)
; 750  : 	//			{
; 751  : 	//				m_CtlComMesu.AddString(STR_INDEX_CROSSABOVE_BASIS);
; 752  : 	//				m_CtlComMesu.AddString(STR_INDEX_CROSSBELOW_BASIS);
; 753  : 
; 754  : 	//				m_CtlComMedo.AddString(STR_INDEX_CROSSABOVE_BASIS);
; 755  : 	//				m_CtlComMedo.AddString(STR_INDEX_CROSSBELOW_BASIS);
; 756  : 	//			}
; 757  : 	//			break;
; 758  : 	//		case 3: //   
; 759  : 	//			if(DataIndex)
; 760  : 	//			{
; 761  : 	//				m_CtlComMesu.AddString(STR_INDEX_ABOVEBAN_BASIS);
; 762  : 	//				m_CtlComMesu.AddString(STR_INDEX_BELOWBAN_BASIS);
; 763  : 
; 764  : 	//				m_CtlComMedo.AddString(STR_INDEX_ABOVEBAN_BASIS);
; 765  : 	//				m_CtlComMedo.AddString(STR_INDEX_BELOWBAN_BASIS);
; 766  : 	//			}
; 767  : 	//			break;
; 768  : 	//		case 4: // 
; 769  : 	//			if(DataIndex)
; 770  : 	//			{
; 771  : 	//				m_CtlComMesu.AddString(STR_PRICE_CROSSABOVE_ANOTHER);
; 772  : 	//				m_CtlComMesu.AddString(STR_PRICE_CROSSBELOW_ANOTHER);
; 773  : 	//				
; 774  : 	//				m_CtlComMedo.AddString(STR_PRICE_CROSSABOVE_ANOTHER);
; 775  : 	//				m_CtlComMedo.AddString(STR_PRICE_CROSSBELOW_ANOTHER);
; 776  : 	//			}
; 777  : 	//			break;
; 778  : 	//		}
; 779  : 	//	}
; 780  : 	//}
; 781  : 	
; 782  : }

  00000	c2 00 00	 ret	 0
?MedoMesuComboDataParsing@CDlgOptimizer@@QAEXXZ ENDP	; CDlgOptimizer::MedoMesuComboDataParsing
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
;	COMDAT ??_G?$CArray@UST_STRGRIDDATA@@U1@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CArray@UST_STRGRIDDATA@@U1@@@UAEPAXI@Z PROC	; CArray<ST_STRGRIDDATA,ST_STRGRIDDATA>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1?$CArray@UST_STRGRIDDATA@@U1@@@UAE@XZ ; CArray<ST_STRGRIDDATA,ST_STRGRIDDATA>::~CArray<ST_STRGRIDDATA,ST_STRGRIDDATA>
  0000b	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  0000e	a8 01		 test	 al, 1
  00010	74 1f		 je	 SHORT $LN9@scalar
  00012	a8 04		 test	 al, 4
  00014	75 10		 jne	 SHORT $LN3@scalar

; 112  : 	{ ::operator delete(p); }

  00016	56		 push	 esi
  00017	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001c	83 c4 04	 add	 esp, 4
  0001f	8b c6		 mov	 eax, esi
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
$LN3@scalar:
  00026	6a 14		 push	 20			; 00000014H
  00028	56		 push	 esi
  00029	e8 00 00 00 00	 call	 ?__global_delete@@YAXPAXI@Z ; __global_delete
  0002e	83 c4 08	 add	 esp, 8
$LN9@scalar:
  00031	8b c6		 mov	 eax, esi
  00033	5e		 pop	 esi
  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
??_G?$CArray@UST_STRGRIDDATA@@U1@@@UAEPAXI@Z ENDP	; CArray<ST_STRGRIDDATA,ST_STRGRIDDATA>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ?Serialize@?$CArray@UST_STRGRIDDATA@@U1@@@UAEXAAVCArchive@@@Z
_TEXT	SEGMENT
_pData$1$ = -4						; size = 4
_ar$ = 8						; size = 4
?Serialize@?$CArray@UST_STRGRIDDATA@@U1@@@UAEXAAVCArchive@@@Z PROC ; CArray<ST_STRGRIDDATA,ST_STRGRIDDATA>::Serialize, COMDAT
; _this$ = ecx

; 633  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	8b f9		 mov	 edi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 212  : 	{ return (m_nMode & CArchive::load) == 0; }

  00009	8b 4d 08	 mov	 ecx, DWORD PTR _ar$[ebp]
  0000c	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  0000f	f7 d0		 not	 eax
  00011	a8 01		 test	 al, 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 637  : 	if (ar.IsStoring())

  00013	74 0a		 je	 SHORT $LN2@Serialize

; 638  : 	{
; 639  : 		ar.WriteCount(m_nSize);

  00015	ff 77 08	 push	 DWORD PTR [edi+8]
  00018	e8 00 00 00 00	 call	 ?WriteCount@CArchive@@QAEXK@Z ; CArchive::WriteCount

; 640  : 	}

  0001d	eb 0f		 jmp	 SHORT $LN3@Serialize
$LN2@Serialize:

; 641  : 	else
; 642  : 	{
; 643  : 		DWORD_PTR nOldSize = ar.ReadCount();

  0001f	e8 00 00 00 00	 call	 ?ReadCount@CArchive@@QAEKXZ ; CArchive::ReadCount

; 644  : 		SetSize(nOldSize, -1);

  00024	6a ff		 push	 -1
  00026	50		 push	 eax
  00027	8b cf		 mov	 ecx, edi
  00029	e8 00 00 00 00	 call	 ?SetSize@?$CArray@UST_STRGRIDDATA@@U1@@@QAEXHH@Z ; CArray<ST_STRGRIDDATA,ST_STRGRIDDATA>::SetSize
$LN3@Serialize:

; 645  : 	}
; 646  : 	SerializeElements<TYPE>(ar, m_pData, m_nSize);

  0002e	8b 77 08	 mov	 esi, DWORD PTR [edi+8]
  00031	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00034	89 4d fc	 mov	 DWORD PTR _pData$1$[ebp], ecx

; 68   : 	ENSURE(nCount == 0 || pElements != NULL);

  00037	85 f6		 test	 esi, esi
  00039	74 08		 je	 SHORT $LN8@Serialize
  0003b	85 c9		 test	 ecx, ecx
  0003d	0f 84 8c 00 00
	00		 je	 $LN40@Serialize
$LN8@Serialize:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 212  : 	{ return (m_nMode & CArchive::load) == 0; }

  00043	8b 55 08	 mov	 edx, DWORD PTR _ar$[ebp]
  00046	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00049	f7 d0		 not	 eax
  0004b	a8 01		 test	 al, 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 73   : 	if (ar.IsStoring())

  0004d	74 36		 je	 SHORT $LN16@Serialize

; 74   : 	{
; 75   : 		TYPE* pData;
; 76   : 		UINT_PTR nElementsLeft;
; 77   : 
; 78   : 		nElementsLeft = nCount;
; 79   : 		pData = pElements;
; 80   : 		while( nElementsLeft > 0 )

  0004f	85 f6		 test	 esi, esi
  00051	74 29		 je	 SHORT $LN14@Serialize
$LL11@Serialize:

; 81   : 		{
; 82   : 			UINT nElementsToWrite;
; 83   : 
; 84   : 			nElementsToWrite = UINT(__min(nElementsLeft, INT_MAX/sizeof(TYPE)));

  00053	bb ff ff ff 0f	 mov	 ebx, 268435455		; 0fffffffH
  00058	3b f3		 cmp	 esi, ebx
  0005a	0f 42 de	 cmovb	 ebx, esi

; 85   : 			ar.Write(pData, nElementsToWrite*sizeof(TYPE));

  0005d	8d 3c dd 00 00
	00 00		 lea	 edi, DWORD PTR [ebx*8]
  00064	57		 push	 edi
  00065	51		 push	 ecx
  00066	8b ca		 mov	 ecx, edx
  00068	e8 00 00 00 00	 call	 ?Write@CArchive@@QAEXPBXI@Z ; CArchive::Write

; 86   : 			nElementsLeft -= nElementsToWrite;
; 87   : 			pData += nElementsToWrite;

  0006d	8b 4d fc	 mov	 ecx, DWORD PTR _pData$1$[ebp]
  00070	8b 55 08	 mov	 edx, DWORD PTR _ar$[ebp]
  00073	03 cf		 add	 ecx, edi
  00075	89 4d fc	 mov	 DWORD PTR _pData$1$[ebp], ecx
  00078	2b f3		 sub	 esi, ebx
  0007a	75 d7		 jne	 SHORT $LL11@Serialize
$LN14@Serialize:
  0007c	5f		 pop	 edi

; 647  : }

  0007d	5e		 pop	 esi
  0007e	5b		 pop	 ebx
  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c2 04 00	 ret	 4
$LN16@Serialize:

; 97   : 		while( nElementsLeft > 0 )

  00085	85 f6		 test	 esi, esi
  00087	74 f3		 je	 SHORT $LN14@Serialize
  00089	0f 1f 80 00 00
	00 00		 npad	 7
$LL13@Serialize:

; 98   : 		{
; 99   : 			UINT nElementsToRead;
; 100  : 
; 101  : 			nElementsToRead = UINT(__min(nElementsLeft, INT_MAX/sizeof(TYPE)));

  00090	bf ff ff ff 0f	 mov	 edi, 268435455		; 0fffffffH
  00095	3b f7		 cmp	 esi, edi
  00097	0f 42 fe	 cmovb	 edi, esi

; 102  : 			ar.EnsureRead(pData, nElementsToRead*sizeof(TYPE));

  0009a	8d 1c fd 00 00
	00 00		 lea	 ebx, DWORD PTR [edi*8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 399  : 	UINT nRead=Read(lpBuf, nCount);

  000a1	53		 push	 ebx
  000a2	51		 push	 ecx
  000a3	8b ca		 mov	 ecx, edx
  000a5	e8 00 00 00 00	 call	 ?Read@CArchive@@QAEIPAXI@Z ; CArchive::Read

; 400  : 	if(nRead!=nCount)

  000aa	3b c3		 cmp	 eax, ebx
  000ac	75 18		 jne	 SHORT $LN30@Serialize
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 97   : 		while( nElementsLeft > 0 )

  000ae	8b 4d fc	 mov	 ecx, DWORD PTR _pData$1$[ebp]
  000b1	8b 55 08	 mov	 edx, DWORD PTR _ar$[ebp]

; 103  : 			nElementsLeft -= nElementsToRead;
; 104  : 			pData += nElementsToRead;

  000b4	03 cb		 add	 ecx, ebx
  000b6	89 4d fc	 mov	 DWORD PTR _pData$1$[ebp], ecx
  000b9	2b f7		 sub	 esi, edi
  000bb	75 d3		 jne	 SHORT $LL13@Serialize

; 647  : }

  000bd	5f		 pop	 edi
  000be	5e		 pop	 esi
  000bf	5b		 pop	 ebx
  000c0	8b e5		 mov	 esp, ebp
  000c2	5d		 pop	 ebp
  000c3	c2 04 00	 ret	 4
$LN30@Serialize:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 402  : 		AfxThrowArchiveException(CArchiveException::endOfFile);

  000c6	6a 00		 push	 0
  000c8	6a 03		 push	 3
  000ca	e8 00 00 00 00	 call	 ?AfxThrowArchiveException@@YGXHPBD@Z ; AfxThrowArchiveException
$LN40@Serialize:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 68   : 	ENSURE(nCount == 0 || pElements != NULL);

  000cf	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN38@Serialize:
  000d4	cc		 int	 3
?Serialize@?$CArray@UST_STRGRIDDATA@@U1@@@UAEXAAVCArchive@@@Z ENDP ; CArray<ST_STRGRIDDATA,ST_STRGRIDDATA>::Serialize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ??1?$CArray@UST_STRGRIDDATA@@U1@@@UAE@XZ
_TEXT	SEGMENT
??1?$CArray@UST_STRGRIDDATA@@U1@@@UAE@XZ PROC		; CArray<ST_STRGRIDDATA,ST_STRGRIDDATA>::~CArray<ST_STRGRIDDATA,ST_STRGRIDDATA>, COMDAT
; _this$ = ecx

; 355  : {

  00000	57		 push	 edi
  00001	8b f9		 mov	 edi, ecx

; 356  : 	ASSERT_VALID(this);
; 357  : 
; 358  : 	if (m_pData != NULL)

  00003	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00006	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7?$CArray@UST_STRGRIDDATA@@U1@@@6B@
  0000c	85 c0		 test	 eax, eax
  0000e	74 3b		 je	 SHORT $LN5@CArray

; 359  : 	{
; 360  : 		for( int i = 0; i < m_nSize; i++ )

  00010	53		 push	 ebx
  00011	33 db		 xor	 ebx, ebx
  00013	39 5f 08	 cmp	 DWORD PTR [edi+8], ebx
  00016	7e 29		 jle	 SHORT $LN3@CArray
  00018	56		 push	 esi
  00019	0f 1f 80 00 00
	00 00		 npad	 7
$LL4@CArray:

; 361  : 			(m_pData + i)->~TYPE();

  00020	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00023	8d 34 d8	 lea	 esi, DWORD PTR [eax+ebx*8]
  00026	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0002f	8b ce		 mov	 ecx, esi
  00031	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00037	43		 inc	 ebx
  00038	3b 5f 08	 cmp	 ebx, DWORD PTR [edi+8]
  0003b	7c e3		 jl	 SHORT $LL4@CArray
  0003d	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00040	5e		 pop	 esi
$LN3@CArray:

; 362  : 		delete[] (BYTE*)m_pData;

  00041	50		 push	 eax
  00042	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00047	83 c4 04	 add	 esp, 4
  0004a	5b		 pop	 ebx
$LN5@CArray:

; 363  : 	}
; 364  : }

  0004b	5f		 pop	 edi
  0004c	c3		 ret	 0
??1?$CArray@UST_STRGRIDDATA@@U1@@@UAE@XZ ENDP		; CArray<ST_STRGRIDDATA,ST_STRGRIDDATA>::~CArray<ST_STRGRIDDATA,ST_STRGRIDDATA>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_memcpy_s.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlchecked.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_memcpy_s.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ?SetSize@?$CArray@UST_STRGRIDDATA@@U1@@@QAEXHH@Z
_TEXT	SEGMENT
__N$1$ = -12						; size = 4
__S2$1$ = -8						; size = 4
_nNewMax$1$ = -4					; size = 4
__S1max$1$ = 8						; size = 4
_i$1$ = 8						; size = 4
_i$1$ = 8						; size = 4
_i$1$ = 8						; size = 4
_i$1$ = 8						; size = 4
_nNewSize$ = 8						; size = 4
_pNewData$1$ = 12					; size = 4
_nAllocSize$1$ = 12					; size = 4
tv592 = 12						; size = 4
_nGrowBy$ = 12						; size = 4
?SetSize@?$CArray@UST_STRGRIDDATA@@U1@@@QAEXHH@Z PROC	; CArray<ST_STRGRIDDATA,ST_STRGRIDDATA>::SetSize, COMDAT
; _this$ = ecx

; 368  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx
  00007	8b 5d 08	 mov	 ebx, DWORD PTR _nNewSize$[ebp]
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b f9		 mov	 edi, ecx

; 369  : 	ASSERT_VALID(this);
; 370  : 	ASSERT(nNewSize >= 0);
; 371  : 
; 372  : 	if(nNewSize < 0 )

  0000e	85 db		 test	 ebx, ebx
  00010	0f 88 f1 02 00
	00		 js	 $LN91@SetSize

; 373  : 		AfxThrowInvalidArgException();
; 374  : 
; 375  : 	if (nGrowBy >= 0)

  00016	8b 45 0c	 mov	 eax, DWORD PTR _nGrowBy$[ebp]
  00019	85 c0		 test	 eax, eax
  0001b	78 03		 js	 SHORT $LN90@SetSize

; 376  : 		m_nGrowBy = nGrowBy;  // set new size

  0001d	89 47 10	 mov	 DWORD PTR [edi+16], eax
$LN90@SetSize:

; 377  : 
; 378  : 	if (nNewSize == 0)

  00020	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  00023	85 db		 test	 ebx, ebx
  00025	75 50		 jne	 SHORT $LN19@SetSize

; 379  : 	{
; 380  : 		// shrink to nothing
; 381  : 		if (m_pData != NULL)

  00027	85 d2		 test	 edx, edx
  00029	74 35		 je	 SHORT $LN21@SetSize

; 382  : 		{
; 383  : 			for( int i = 0; i < m_nSize; i++ )

  0002b	39 5f 08	 cmp	 DWORD PTR [edi+8], ebx
  0002e	7e 20		 jle	 SHORT $LN3@SetSize
$LL4@SetSize:

; 384  : 				(m_pData + i)->~TYPE();

  00030	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00033	8d 34 d8	 lea	 esi, DWORD PTR [eax+ebx*8]
  00036	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00039	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0003f	8b ce		 mov	 ecx, esi
  00041	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00047	43		 inc	 ebx
  00048	3b 5f 08	 cmp	 ebx, DWORD PTR [edi+8]
  0004b	7c e3		 jl	 SHORT $LL4@SetSize
  0004d	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
$LN3@SetSize:

; 385  : 			delete[] (BYTE*)m_pData;

  00050	52		 push	 edx
  00051	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00056	83 c4 04	 add	 esp, 4

; 386  : 			m_pData = NULL;

  00059	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0
$LN21@SetSize:

; 387  : 		}
; 388  : 		m_nSize = m_nMaxSize = 0;

  00060	c7 47 0c 00 00
	00 00		 mov	 DWORD PTR [edi+12], 0
  00067	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0
  0006e	5f		 pop	 edi

; 474  : 	}
; 475  : }

  0006f	5e		 pop	 esi
  00070	5b		 pop	 ebx
  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c2 08 00	 ret	 8
$LN19@SetSize:

; 389  : 	}
; 390  : 	else if (m_pData == NULL)

  00077	85 d2		 test	 edx, edx
  00079	75 69		 jne	 SHORT $LN22@SetSize

; 391  : 	{
; 392  : 		// create buffer big enough to hold number of requested elements or
; 393  : 		// m_nGrowBy elements, whichever is larger.
; 394  : #ifdef SIZE_T_MAX
; 395  : 		ASSERT(nNewSize <= SIZE_T_MAX/sizeof(TYPE));    // no overflow
; 396  : #endif
; 397  : 		size_t nAllocSize = __max(nNewSize, m_nGrowBy);

  0007b	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  0007e	3b d8		 cmp	 ebx, eax
  00080	0f 4f c3	 cmovg	 eax, ebx
  00083	89 45 0c	 mov	 DWORD PTR _nAllocSize$1$[ebp], eax

; 398  : 		m_pData = (TYPE*) new BYTE[(size_t)nAllocSize * sizeof(TYPE)];

  00086	8d 34 c5 00 00
	00 00		 lea	 esi, DWORD PTR [eax*8]
  0008d	56		 push	 esi
  0008e	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]

; 399  : 		memset((void*)m_pData, 0, (size_t)nAllocSize * sizeof(TYPE));

  00093	56		 push	 esi
  00094	6a 00		 push	 0
  00096	50		 push	 eax
  00097	89 47 04	 mov	 DWORD PTR [edi+4], eax
  0009a	e8 00 00 00 00	 call	 _memset
  0009f	33 c9		 xor	 ecx, ecx
  000a1	83 c4 10	 add	 esp, 16			; 00000010H
  000a4	89 4d 08	 mov	 DWORD PTR _i$1$[ebp], ecx

; 400  : 		for( int i = 0; i < nNewSize; i++ )

  000a7	85 db		 test	 ebx, ebx
  000a9	7e 27		 jle	 SHORT $LN6@SetSize
  000ab	0f 1f 44 00 00	 npad	 5
$LL7@SetSize:

; 401  : #pragma push_macro("new")
; 402  : #undef new
; 403  : 			::new( (void*)( m_pData + i ) ) TYPE;

  000b0	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  000b3	8d 34 c8	 lea	 esi, DWORD PTR [eax+ecx*8]
  000b6	8b ce		 mov	 ecx, esi
  000b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  000be	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  000c1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  000c7	8b 4d 08	 mov	 ecx, DWORD PTR _i$1$[ebp]
  000ca	41		 inc	 ecx
  000cb	89 4d 08	 mov	 DWORD PTR _i$1$[ebp], ecx
  000ce	3b cb		 cmp	 ecx, ebx
  000d0	7c de		 jl	 SHORT $LL7@SetSize
$LN6@SetSize:

; 404  : #pragma pop_macro("new")
; 405  : 		m_nSize = nNewSize;
; 406  : 		m_nMaxSize = nAllocSize;

  000d2	8b 45 0c	 mov	 eax, DWORD PTR _nAllocSize$1$[ebp]
  000d5	89 5f 08	 mov	 DWORD PTR [edi+8], ebx

; 474  : 	}
; 475  : }

  000d8	89 47 0c	 mov	 DWORD PTR [edi+12], eax
  000db	5f		 pop	 edi
  000dc	5e		 pop	 esi
  000dd	5b		 pop	 ebx
  000de	8b e5		 mov	 esp, ebp
  000e0	5d		 pop	 ebp
  000e1	c2 08 00	 ret	 8
$LN22@SetSize:

; 407  : 	}
; 408  : 	else if (nNewSize <= m_nMaxSize)

  000e4	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  000e7	3b d9		 cmp	 ebx, ecx
  000e9	0f 8f bd 00 00
	00		 jg	 $LN24@SetSize

; 409  : 	{
; 410  : 		// it fits
; 411  : 		if (nNewSize > m_nSize)

  000ef	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  000f2	3b d9		 cmp	 ebx, ecx
  000f4	7e 62		 jle	 SHORT $LN26@SetSize

; 412  : 		{
; 413  : 			// initialize the new elements
; 414  : 			memset((void*)(m_pData + m_nSize), 0, (size_t)(nNewSize-m_nSize) * sizeof(TYPE));

  000f6	8b c3		 mov	 eax, ebx
  000f8	2b c1		 sub	 eax, ecx
  000fa	c1 e0 03	 shl	 eax, 3
  000fd	50		 push	 eax
  000fe	8d 04 ca	 lea	 eax, DWORD PTR [edx+ecx*8]
  00101	6a 00		 push	 0
  00103	50		 push	 eax
  00104	e8 00 00 00 00	 call	 _memset

; 415  : 			for( int i = 0; i < nNewSize-m_nSize; i++ )

  00109	8b c3		 mov	 eax, ebx
  0010b	33 d2		 xor	 edx, edx
  0010d	2b 47 08	 sub	 eax, DWORD PTR [edi+8]
  00110	83 c4 0c	 add	 esp, 12			; 0000000cH
  00113	89 55 08	 mov	 DWORD PTR _i$1$[ebp], edx
  00116	85 c0		 test	 eax, eax
  00118	0f 8e 82 00 00
	00		 jle	 $LN12@SetSize
  0011e	66 90		 npad	 2
$LL10@SetSize:

; 416  : #pragma push_macro("new")
; 417  : #undef new
; 418  : 				::new( (void*)( m_pData + m_nSize + i ) ) TYPE;

  00120	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00123	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00126	03 ca		 add	 ecx, edx
  00128	8d 34 c8	 lea	 esi, DWORD PTR [eax+ecx*8]
  0012b	8b ce		 mov	 ecx, esi
  0012d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00133	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00136	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0013c	8b 55 08	 mov	 edx, DWORD PTR _i$1$[ebp]
  0013f	8b c3		 mov	 eax, ebx
  00141	2b 47 08	 sub	 eax, DWORD PTR [edi+8]
  00144	42		 inc	 edx
  00145	89 55 08	 mov	 DWORD PTR _i$1$[ebp], edx
  00148	3b d0		 cmp	 edx, eax
  0014a	7c d4		 jl	 SHORT $LL10@SetSize

; 426  : 		}
; 427  : 		m_nSize = nNewSize;

  0014c	89 5f 08	 mov	 DWORD PTR [edi+8], ebx
  0014f	5f		 pop	 edi

; 474  : 	}
; 475  : }

  00150	5e		 pop	 esi
  00151	5b		 pop	 ebx
  00152	8b e5		 mov	 esp, ebp
  00154	5d		 pop	 ebp
  00155	c2 08 00	 ret	 8
$LN26@SetSize:

; 419  : #pragma pop_macro("new")
; 420  : 		}
; 421  : 		else if (m_nSize > nNewSize)

  00158	7d 46		 jge	 SHORT $LN12@SetSize

; 422  : 		{
; 423  : 			// destroy the old elements
; 424  : 			for( int i = 0; i < m_nSize-nNewSize; i++ )

  0015a	2b cb		 sub	 ecx, ebx
  0015c	c7 45 08 00 00
	00 00		 mov	 DWORD PTR _i$1$[ebp], 0
  00163	85 c9		 test	 ecx, ecx
  00165	7e 39		 jle	 SHORT $LN12@SetSize
  00167	8d 0c dd 00 00
	00 00		 lea	 ecx, DWORD PTR [ebx*8]
  0016e	89 4d 0c	 mov	 DWORD PTR tv592[ebp], ecx
$LL13@SetSize:

; 425  : 				(m_pData + nNewSize + i)->~TYPE();

  00171	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
  00174	03 f1		 add	 esi, ecx
  00176	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00179	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0017f	8b ce		 mov	 ecx, esi
  00181	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00187	8b 55 08	 mov	 edx, DWORD PTR _i$1$[ebp]
  0018a	8b 4d 0c	 mov	 ecx, DWORD PTR tv592[ebp]
  0018d	42		 inc	 edx
  0018e	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00191	83 c1 08	 add	 ecx, 8
  00194	2b c3		 sub	 eax, ebx
  00196	89 55 08	 mov	 DWORD PTR _i$1$[ebp], edx
  00199	89 4d 0c	 mov	 DWORD PTR tv592[ebp], ecx
  0019c	3b d0		 cmp	 edx, eax
  0019e	7c d1		 jl	 SHORT $LL13@SetSize
$LN12@SetSize:

; 426  : 		}
; 427  : 		m_nSize = nNewSize;

  001a0	89 5f 08	 mov	 DWORD PTR [edi+8], ebx
  001a3	5f		 pop	 edi

; 474  : 	}
; 475  : }

  001a4	5e		 pop	 esi
  001a5	5b		 pop	 ebx
  001a6	8b e5		 mov	 esp, ebp
  001a8	5d		 pop	 ebp
  001a9	c2 08 00	 ret	 8
$LN24@SetSize:

; 428  : 	}
; 429  : 	else
; 430  : 	{
; 431  : 		// otherwise, grow array
; 432  : 		nGrowBy = m_nGrowBy;

  001ac	8b 47 10	 mov	 eax, DWORD PTR [edi+16]

; 433  : 		if (nGrowBy == 0)

  001af	85 c0		 test	 eax, eax
  001b1	75 22		 jne	 SHORT $LN37@SetSize

; 434  : 		{
; 435  : 			// heuristically determine growth when nGrowBy == 0
; 436  : 			//  (this avoids heap fragmentation in many situations)
; 437  : 			nGrowBy = m_nSize / 8;

  001b3	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  001b6	99		 cdq
  001b7	83 e2 07	 and	 edx, 7
  001ba	03 c2		 add	 eax, edx
  001bc	c1 f8 03	 sar	 eax, 3

; 438  : 			nGrowBy = (nGrowBy < 4) ? 4 : ((nGrowBy > 1024) ? 1024 : nGrowBy);

  001bf	83 f8 04	 cmp	 eax, 4
  001c2	7d 07		 jge	 SHORT $LN36@SetSize
  001c4	b8 04 00 00 00	 mov	 eax, 4
  001c9	eb 0a		 jmp	 SHORT $LN37@SetSize
$LN36@SetSize:
  001cb	ba 00 04 00 00	 mov	 edx, 1024		; 00000400H
  001d0	3b c2		 cmp	 eax, edx
  001d2	0f 4f c2	 cmovg	 eax, edx
$LN37@SetSize:

; 439  : 		}
; 440  : 		INT_PTR nNewMax;
; 441  : 		if (nNewSize < m_nMaxSize + nGrowBy)

  001d5	03 c1		 add	 eax, ecx
  001d7	89 45 fc	 mov	 DWORD PTR _nNewMax$1$[ebp], eax
  001da	3b d8		 cmp	 ebx, eax
  001dc	7d 0a		 jge	 SHORT $LN30@SetSize

; 445  : 
; 446  : 		ASSERT(nNewMax >= m_nMaxSize);  // no wrap around
; 447  : 
; 448  : 		if(nNewMax  < m_nMaxSize)

  001de	3b c1		 cmp	 eax, ecx
  001e0	0f 8c 21 01 00
	00		 jl	 $LN91@SetSize
  001e6	eb 05		 jmp	 SHORT $LN32@SetSize
$LN30@SetSize:

; 442  : 			nNewMax = m_nMaxSize + nGrowBy;  // granularity
; 443  : 		else
; 444  : 			nNewMax = nNewSize;  // no slush

  001e8	8b c3		 mov	 eax, ebx
  001ea	89 5d fc	 mov	 DWORD PTR _nNewMax$1$[ebp], ebx
$LN32@SetSize:

; 450  : 
; 451  : #ifdef SIZE_T_MAX
; 452  : 		ASSERT(nNewMax <= SIZE_T_MAX/sizeof(TYPE)); // no overflow
; 453  : #endif
; 454  : 		TYPE* pNewData = (TYPE*) new BYTE[(size_t)nNewMax * sizeof(TYPE)];

  001ed	c1 e0 03	 shl	 eax, 3
  001f0	50		 push	 eax
  001f1	89 45 08	 mov	 DWORD PTR __S1max$1$[ebp], eax
  001f4	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]

; 455  : 
; 456  : 		// copy new data from old
; 457  : 		::ATL::Checked::memcpy_s(pNewData, (size_t)nNewMax * sizeof(TYPE),

  001f9	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  001fc	8b f0		 mov	 esi, eax
  001fe	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00201	83 c4 04	 add	 esp, 4
  00204	c1 e0 03	 shl	 eax, 3
  00207	89 75 0c	 mov	 DWORD PTR _pNewData$1$[ebp], esi
  0020a	89 45 f4	 mov	 DWORD PTR __N$1$[ebp], eax
  0020d	89 55 f8	 mov	 DWORD PTR __S2$1$[ebp], edx
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_memcpy_s.h

; 46   :         if (_SourceSize == 0)

  00210	85 c0		 test	 eax, eax
  00212	74 1f		 je	 SHORT $LN58@SetSize
$LN59@SetSize:

; 47   :         {
; 48   :             return 0;
; 49   :         }
; 50   : 
; 51   :         _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Destination != NULL, EINVAL);

  00214	85 f6		 test	 esi, esi
  00216	0f 85 90 00 00
	00		 jne	 $LN60@SetSize
$LN94@SetSize:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlchecked.h

; 69   : 	ATLMFC_CRT_ERRORCHECK(::memcpy_s(_S1, _S1max, _S2, _N));

  0021c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___errno
  00222	c7 00 16 00 00
	00		 mov	 DWORD PTR [eax], 22	; 00000016H
  00228	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo
$LN64@SetSize:
  0022e	b8 16 00 00 00	 mov	 eax, 22			; 00000016H
$LN58@SetSize:
  00233	50		 push	 eax
  00234	e8 00 00 00 00	 call	 ?AfxCrtErrorCheck@@YAHH@Z ; AfxCrtErrorCheck
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 462  : 		memset((void*)(pNewData + m_nSize), 0, (size_t)(nNewSize-m_nSize) * sizeof(TYPE));

  00239	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  0023c	8b c3		 mov	 eax, ebx
  0023e	2b c1		 sub	 eax, ecx
  00240	c1 e0 03	 shl	 eax, 3
  00243	50		 push	 eax
  00244	8d 04 ce	 lea	 eax, DWORD PTR [esi+ecx*8]
  00247	6a 00		 push	 0
  00249	50		 push	 eax
  0024a	e8 00 00 00 00	 call	 _memset

; 463  : 		for( int i = 0; i < nNewSize-m_nSize; i++ )

  0024f	8b c3		 mov	 eax, ebx
  00251	33 c9		 xor	 ecx, ecx
  00253	2b 47 08	 sub	 eax, DWORD PTR [edi+8]
  00256	83 c4 10	 add	 esp, 16			; 00000010H
  00259	89 4d 08	 mov	 DWORD PTR _i$1$[ebp], ecx
  0025c	85 c0		 test	 eax, eax
  0025e	7e 2c		 jle	 SHORT $LN15@SetSize
$LL16@SetSize:

; 464  : #pragma push_macro("new")
; 465  : #undef new
; 466  : 			::new( (void*)( pNewData + m_nSize + i ) ) TYPE;

  00260	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00263	03 c1		 add	 eax, ecx
  00265	8d 34 c6	 lea	 esi, DWORD PTR [esi+eax*8]
  00268	8b ce		 mov	 ecx, esi
  0026a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00270	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00273	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00279	8b 4d 08	 mov	 ecx, DWORD PTR _i$1$[ebp]
  0027c	8b c3		 mov	 eax, ebx
  0027e	2b 47 08	 sub	 eax, DWORD PTR [edi+8]
  00281	41		 inc	 ecx
  00282	8b 75 0c	 mov	 esi, DWORD PTR _pNewData$1$[ebp]
  00285	89 4d 08	 mov	 DWORD PTR _i$1$[ebp], ecx
  00288	3b c8		 cmp	 ecx, eax
  0028a	7c d4		 jl	 SHORT $LL16@SetSize
$LN15@SetSize:

; 467  : #pragma pop_macro("new")
; 468  : 
; 469  : 		// get rid of old stuff (note: no destructors called)
; 470  : 		delete[] (BYTE*)m_pData;

  0028c	ff 77 04	 push	 DWORD PTR [edi+4]
  0028f	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]

; 471  : 		m_pData = pNewData;
; 472  : 		m_nSize = nNewSize;
; 473  : 		m_nMaxSize = nNewMax;

  00294	8b 45 fc	 mov	 eax, DWORD PTR _nNewMax$1$[ebp]
  00297	83 c4 04	 add	 esp, 4
  0029a	89 77 04	 mov	 DWORD PTR [edi+4], esi
  0029d	89 5f 08	 mov	 DWORD PTR [edi+8], ebx

; 474  : 	}
; 475  : }

  002a0	89 47 0c	 mov	 DWORD PTR [edi+12], eax
  002a3	5f		 pop	 edi
  002a4	5e		 pop	 esi
  002a5	5b		 pop	 ebx
  002a6	8b e5		 mov	 esp, ebp
  002a8	5d		 pop	 ebp
  002a9	c2 08 00	 ret	 8
$LN60@SetSize:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_memcpy_s.h

; 52   :         if (_Source == NULL || _DestinationSize < _SourceSize)

  002ac	8b 4d 08	 mov	 ecx, DWORD PTR __S1max$1$[ebp]
  002af	85 d2		 test	 edx, edx
  002b1	74 16		 je	 SHORT $LN62@SetSize
  002b3	3b c8		 cmp	 ecx, eax
  002b5	72 12		 jb	 SHORT $LN62@SetSize

; 58   : 
; 59   :             // Unreachable, but required to suppress /analyze warnings:
; 60   :             return EINVAL;
; 61   :         }
; 62   :         memcpy(_Destination, _Source, _SourceSize);

  002b7	50		 push	 eax
  002b8	52		 push	 edx
  002b9	56		 push	 esi
  002ba	e8 00 00 00 00	 call	 _memcpy
  002bf	83 c4 0c	 add	 esp, 12			; 0000000cH

; 63   :         return 0;

  002c2	33 c0		 xor	 eax, eax
  002c4	e9 6a ff ff ff	 jmp	 $LN58@SetSize
$LN62@SetSize:

; 53   :         {
; 54   :             memset(_Destination, 0, _DestinationSize);

  002c9	51		 push	 ecx
  002ca	6a 00		 push	 0
  002cc	56		 push	 esi
  002cd	e8 00 00 00 00	 call	 _memset
  002d2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 55   : 
; 56   :             _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Source != NULL,                 EINVAL);

  002d5	83 7d f8 00	 cmp	 DWORD PTR __S2$1$[ebp], 0
  002d9	0f 84 3d ff ff
	ff		 je	 $LN94@SetSize

; 57   :             _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_DestinationSize >= _SourceSize, ERANGE);

  002df	8b 45 08	 mov	 eax, DWORD PTR __S1max$1$[ebp]
  002e2	3b 45 f4	 cmp	 eax, DWORD PTR __N$1$[ebp]
  002e5	0f 83 43 ff ff
	ff		 jae	 $LN64@SetSize
  002eb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___errno
  002f1	c7 00 22 00 00
	00		 mov	 DWORD PTR [eax], 34	; 00000022H
  002f7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo
  002fd	b8 22 00 00 00	 mov	 eax, 34			; 00000022H
  00302	e9 2c ff ff ff	 jmp	 $LN58@SetSize
$LN91@SetSize:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 449  : 			AfxThrowInvalidArgException();

  00307	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN93@SetSize:
  0030c	cc		 int	 3
?SetSize@?$CArray@UST_STRGRIDDATA@@U1@@@QAEXHH@Z ENDP	; CArray<ST_STRGRIDDATA,ST_STRGRIDDATA>::SetSize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ??0?$CArray@UST_STRGRIDDATA@@U1@@@QAE@XZ
_TEXT	SEGMENT
??0?$CArray@UST_STRGRIDDATA@@U1@@@QAE@XZ PROC		; CArray<ST_STRGRIDDATA,ST_STRGRIDDATA>::CArray<ST_STRGRIDDATA,ST_STRGRIDDATA>, COMDAT
; _this$ = ecx

; 348  : {

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CArray@UST_STRGRIDDATA@@U1@@@6B@

; 349  : 	m_pData = NULL;
; 350  : 	m_nSize = m_nMaxSize = m_nGrowBy = 0;
; 351  : }

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  00016	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0
  0001d	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00024	c3		 ret	 0
??0?$CArray@UST_STRGRIDDATA@@U1@@@QAE@XZ ENDP		; CArray<ST_STRGRIDDATA,ST_STRGRIDDATA>::CArray<ST_STRGRIDDATA,ST_STRGRIDDATA>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
;	COMDAT ??_G?$CArray@UST_GRIDDATA@@U1@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CArray@UST_GRIDDATA@@U1@@@UAEPAXI@Z PROC		; CArray<ST_GRIDDATA,ST_GRIDDATA>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1?$CArray@UST_GRIDDATA@@U1@@@UAE@XZ ; CArray<ST_GRIDDATA,ST_GRIDDATA>::~CArray<ST_GRIDDATA,ST_GRIDDATA>
  0000b	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  0000e	a8 01		 test	 al, 1
  00010	74 1f		 je	 SHORT $LN9@scalar
  00012	a8 04		 test	 al, 4
  00014	75 10		 jne	 SHORT $LN3@scalar

; 112  : 	{ ::operator delete(p); }

  00016	56		 push	 esi
  00017	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001c	83 c4 04	 add	 esp, 4
  0001f	8b c6		 mov	 eax, esi
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
$LN3@scalar:
  00026	6a 14		 push	 20			; 00000014H
  00028	56		 push	 esi
  00029	e8 00 00 00 00	 call	 ?__global_delete@@YAXPAXI@Z ; __global_delete
  0002e	83 c4 08	 add	 esp, 8
$LN9@scalar:
  00031	8b c6		 mov	 eax, esi
  00033	5e		 pop	 esi
  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
??_G?$CArray@UST_GRIDDATA@@U1@@@UAEPAXI@Z ENDP		; CArray<ST_GRIDDATA,ST_GRIDDATA>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ?Serialize@?$CArray@UST_GRIDDATA@@U1@@@UAEXAAVCArchive@@@Z
_TEXT	SEGMENT
_pData$1$ = -4						; size = 4
_ar$ = 8						; size = 4
?Serialize@?$CArray@UST_GRIDDATA@@U1@@@UAEXAAVCArchive@@@Z PROC ; CArray<ST_GRIDDATA,ST_GRIDDATA>::Serialize, COMDAT
; _this$ = ecx

; 633  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	8b f9		 mov	 edi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 212  : 	{ return (m_nMode & CArchive::load) == 0; }

  00009	8b 4d 08	 mov	 ecx, DWORD PTR _ar$[ebp]
  0000c	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  0000f	f7 d0		 not	 eax
  00011	a8 01		 test	 al, 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 637  : 	if (ar.IsStoring())

  00013	74 0a		 je	 SHORT $LN2@Serialize

; 638  : 	{
; 639  : 		ar.WriteCount(m_nSize);

  00015	ff 77 08	 push	 DWORD PTR [edi+8]
  00018	e8 00 00 00 00	 call	 ?WriteCount@CArchive@@QAEXK@Z ; CArchive::WriteCount

; 640  : 	}

  0001d	eb 0f		 jmp	 SHORT $LN3@Serialize
$LN2@Serialize:

; 641  : 	else
; 642  : 	{
; 643  : 		DWORD_PTR nOldSize = ar.ReadCount();

  0001f	e8 00 00 00 00	 call	 ?ReadCount@CArchive@@QAEKXZ ; CArchive::ReadCount

; 644  : 		SetSize(nOldSize, -1);

  00024	6a ff		 push	 -1
  00026	50		 push	 eax
  00027	8b cf		 mov	 ecx, edi
  00029	e8 00 00 00 00	 call	 ?SetSize@?$CArray@UST_GRIDDATA@@U1@@@QAEXHH@Z ; CArray<ST_GRIDDATA,ST_GRIDDATA>::SetSize
$LN3@Serialize:

; 645  : 	}
; 646  : 	SerializeElements<TYPE>(ar, m_pData, m_nSize);

  0002e	8b 77 08	 mov	 esi, DWORD PTR [edi+8]
  00031	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00034	89 4d fc	 mov	 DWORD PTR _pData$1$[ebp], ecx

; 68   : 	ENSURE(nCount == 0 || pElements != NULL);

  00037	85 f6		 test	 esi, esi
  00039	74 08		 je	 SHORT $LN8@Serialize
  0003b	85 c9		 test	 ecx, ecx
  0003d	0f 84 8b 00 00
	00		 je	 $LN40@Serialize
$LN8@Serialize:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 212  : 	{ return (m_nMode & CArchive::load) == 0; }

  00043	8b 55 08	 mov	 edx, DWORD PTR _ar$[ebp]
  00046	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00049	f7 d0		 not	 eax
  0004b	a8 01		 test	 al, 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 73   : 	if (ar.IsStoring())

  0004d	74 35		 je	 SHORT $LN16@Serialize

; 74   : 	{
; 75   : 		TYPE* pData;
; 76   : 		UINT_PTR nElementsLeft;
; 77   : 
; 78   : 		nElementsLeft = nCount;
; 79   : 		pData = pElements;
; 80   : 		while( nElementsLeft > 0 )

  0004f	85 f6		 test	 esi, esi
  00051	74 28		 je	 SHORT $LN14@Serialize
$LL11@Serialize:

; 81   : 		{
; 82   : 			UINT nElementsToWrite;
; 83   : 
; 84   : 			nElementsToWrite = UINT(__min(nElementsLeft, INT_MAX/sizeof(TYPE)));

  00053	bb c8 67 dd 00	 mov	 ebx, 14510024		; 00dd67c8H
  00058	3b f3		 cmp	 esi, ebx
  0005a	0f 42 de	 cmovb	 ebx, esi

; 85   : 			ar.Write(pData, nElementsToWrite*sizeof(TYPE));

  0005d	69 fb 94 00 00
	00		 imul	 edi, ebx, 148
  00063	57		 push	 edi
  00064	51		 push	 ecx
  00065	8b ca		 mov	 ecx, edx
  00067	e8 00 00 00 00	 call	 ?Write@CArchive@@QAEXPBXI@Z ; CArchive::Write

; 86   : 			nElementsLeft -= nElementsToWrite;
; 87   : 			pData += nElementsToWrite;

  0006c	8b 4d fc	 mov	 ecx, DWORD PTR _pData$1$[ebp]
  0006f	8b 55 08	 mov	 edx, DWORD PTR _ar$[ebp]
  00072	03 cf		 add	 ecx, edi
  00074	89 4d fc	 mov	 DWORD PTR _pData$1$[ebp], ecx
  00077	2b f3		 sub	 esi, ebx
  00079	75 d8		 jne	 SHORT $LL11@Serialize
$LN14@Serialize:
  0007b	5f		 pop	 edi

; 647  : }

  0007c	5e		 pop	 esi
  0007d	5b		 pop	 ebx
  0007e	8b e5		 mov	 esp, ebp
  00080	5d		 pop	 ebp
  00081	c2 04 00	 ret	 4
$LN16@Serialize:

; 97   : 		while( nElementsLeft > 0 )

  00084	85 f6		 test	 esi, esi
  00086	74 f3		 je	 SHORT $LN14@Serialize
  00088	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL13@Serialize:

; 98   : 		{
; 99   : 			UINT nElementsToRead;
; 100  : 
; 101  : 			nElementsToRead = UINT(__min(nElementsLeft, INT_MAX/sizeof(TYPE)));

  00090	bf c8 67 dd 00	 mov	 edi, 14510024		; 00dd67c8H
  00095	3b f7		 cmp	 esi, edi
  00097	0f 42 fe	 cmovb	 edi, esi

; 102  : 			ar.EnsureRead(pData, nElementsToRead*sizeof(TYPE));

  0009a	69 df 94 00 00
	00		 imul	 ebx, edi, 148
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 399  : 	UINT nRead=Read(lpBuf, nCount);

  000a0	53		 push	 ebx
  000a1	51		 push	 ecx
  000a2	8b ca		 mov	 ecx, edx
  000a4	e8 00 00 00 00	 call	 ?Read@CArchive@@QAEIPAXI@Z ; CArchive::Read

; 400  : 	if(nRead!=nCount)

  000a9	3b c3		 cmp	 eax, ebx
  000ab	75 18		 jne	 SHORT $LN30@Serialize
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 97   : 		while( nElementsLeft > 0 )

  000ad	8b 4d fc	 mov	 ecx, DWORD PTR _pData$1$[ebp]
  000b0	8b 55 08	 mov	 edx, DWORD PTR _ar$[ebp]

; 103  : 			nElementsLeft -= nElementsToRead;
; 104  : 			pData += nElementsToRead;

  000b3	03 cb		 add	 ecx, ebx
  000b5	89 4d fc	 mov	 DWORD PTR _pData$1$[ebp], ecx
  000b8	2b f7		 sub	 esi, edi
  000ba	75 d4		 jne	 SHORT $LL13@Serialize

; 647  : }

  000bc	5f		 pop	 edi
  000bd	5e		 pop	 esi
  000be	5b		 pop	 ebx
  000bf	8b e5		 mov	 esp, ebp
  000c1	5d		 pop	 ebp
  000c2	c2 04 00	 ret	 4
$LN30@Serialize:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 402  : 		AfxThrowArchiveException(CArchiveException::endOfFile);

  000c5	6a 00		 push	 0
  000c7	6a 03		 push	 3
  000c9	e8 00 00 00 00	 call	 ?AfxThrowArchiveException@@YGXHPBD@Z ; AfxThrowArchiveException
$LN40@Serialize:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 68   : 	ENSURE(nCount == 0 || pElements != NULL);

  000ce	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN38@Serialize:
  000d3	cc		 int	 3
?Serialize@?$CArray@UST_GRIDDATA@@U1@@@UAEXAAVCArchive@@@Z ENDP ; CArray<ST_GRIDDATA,ST_GRIDDATA>::Serialize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ??1?$CArray@UST_GRIDDATA@@U1@@@UAE@XZ
_TEXT	SEGMENT
??1?$CArray@UST_GRIDDATA@@U1@@@UAE@XZ PROC		; CArray<ST_GRIDDATA,ST_GRIDDATA>::~CArray<ST_GRIDDATA,ST_GRIDDATA>, COMDAT
; _this$ = ecx

; 355  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 356  : 	ASSERT_VALID(this);
; 357  : 
; 358  : 	if (m_pData != NULL)

  00003	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00006	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CArray@UST_GRIDDATA@@U1@@@6B@
  0000c	85 c0		 test	 eax, eax
  0000e	74 34		 je	 SHORT $LN5@CArray

; 359  : 	{
; 360  : 		for( int i = 0; i < m_nSize; i++ )

  00010	53		 push	 ebx
  00011	33 db		 xor	 ebx, ebx
  00013	39 5e 08	 cmp	 DWORD PTR [esi+8], ebx
  00016	7e 22		 jle	 SHORT $LN3@CArray
  00018	57		 push	 edi
  00019	33 ff		 xor	 edi, edi
  0001b	0f 1f 44 00 00	 npad	 5
$LL4@CArray:

; 361  : 			(m_pData + i)->~TYPE();

  00020	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00023	03 cf		 add	 ecx, edi
  00025	e8 00 00 00 00	 call	 ??1ST_GRIDDATA@@QAE@XZ
  0002a	43		 inc	 ebx
  0002b	81 c7 94 00 00
	00		 add	 edi, 148		; 00000094H
  00031	3b 5e 08	 cmp	 ebx, DWORD PTR [esi+8]
  00034	7c ea		 jl	 SHORT $LL4@CArray
  00036	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00039	5f		 pop	 edi
$LN3@CArray:

; 362  : 		delete[] (BYTE*)m_pData;

  0003a	50		 push	 eax
  0003b	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00040	83 c4 04	 add	 esp, 4
  00043	5b		 pop	 ebx
$LN5@CArray:

; 363  : 	}
; 364  : }

  00044	5e		 pop	 esi
  00045	c3		 ret	 0
??1?$CArray@UST_GRIDDATA@@U1@@@UAE@XZ ENDP		; CArray<ST_GRIDDATA,ST_GRIDDATA>::~CArray<ST_GRIDDATA,ST_GRIDDATA>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_memcpy_s.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlchecked.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_memcpy_s.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ?SetSize@?$CArray@UST_GRIDDATA@@U1@@@QAEXHH@Z
_TEXT	SEGMENT
__N$1$ = -12						; size = 4
__S2$1$ = -8						; size = 4
_nNewMax$1$ = -4					; size = 4
_nAllocSize$1$ = -4					; size = 4
__S1max$1$ = 8						; size = 4
_i$1$ = 8						; size = 4
_nNewSize$ = 8						; size = 4
_pNewData$1$ = 12					; size = 4
tv631 = 12						; size = 4
_nGrowBy$ = 12						; size = 4
?SetSize@?$CArray@UST_GRIDDATA@@U1@@@QAEXHH@Z PROC	; CArray<ST_GRIDDATA,ST_GRIDDATA>::SetSize, COMDAT
; _this$ = ecx

; 368  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx
  00007	8b 5d 08	 mov	 ebx, DWORD PTR _nNewSize$[ebp]
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b f9		 mov	 edi, ecx

; 369  : 	ASSERT_VALID(this);
; 370  : 	ASSERT(nNewSize >= 0);
; 371  : 
; 372  : 	if(nNewSize < 0 )

  0000e	85 db		 test	 ebx, ebx
  00010	0f 88 c5 02 00
	00		 js	 $LN76@SetSize

; 373  : 		AfxThrowInvalidArgException();
; 374  : 
; 375  : 	if (nGrowBy >= 0)

  00016	8b 45 0c	 mov	 eax, DWORD PTR _nGrowBy$[ebp]
  00019	85 c0		 test	 eax, eax
  0001b	78 03		 js	 SHORT $LN75@SetSize

; 376  : 		m_nGrowBy = nGrowBy;  // set new size

  0001d	89 47 10	 mov	 DWORD PTR [edi+16], eax
$LN75@SetSize:

; 377  : 
; 378  : 	if (nNewSize == 0)

  00020	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  00023	85 db		 test	 ebx, ebx
  00025	75 4b		 jne	 SHORT $LN19@SetSize

; 379  : 	{
; 380  : 		// shrink to nothing
; 381  : 		if (m_pData != NULL)

  00027	85 d2		 test	 edx, edx
  00029	74 30		 je	 SHORT $LN21@SetSize

; 382  : 		{
; 383  : 			for( int i = 0; i < m_nSize; i++ )

  0002b	39 5f 08	 cmp	 DWORD PTR [edi+8], ebx
  0002e	7e 1b		 jle	 SHORT $LN3@SetSize
  00030	33 f6		 xor	 esi, esi
$LL4@SetSize:

; 384  : 				(m_pData + i)->~TYPE();

  00032	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00035	03 ce		 add	 ecx, esi
  00037	e8 00 00 00 00	 call	 ??1ST_GRIDDATA@@QAE@XZ
  0003c	43		 inc	 ebx
  0003d	81 c6 94 00 00
	00		 add	 esi, 148		; 00000094H
  00043	3b 5f 08	 cmp	 ebx, DWORD PTR [edi+8]
  00046	7c ea		 jl	 SHORT $LL4@SetSize
  00048	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
$LN3@SetSize:

; 385  : 			delete[] (BYTE*)m_pData;

  0004b	52		 push	 edx
  0004c	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00051	83 c4 04	 add	 esp, 4

; 386  : 			m_pData = NULL;

  00054	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0
$LN21@SetSize:

; 387  : 		}
; 388  : 		m_nSize = m_nMaxSize = 0;

  0005b	c7 47 0c 00 00
	00 00		 mov	 DWORD PTR [edi+12], 0
  00062	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0
  00069	5f		 pop	 edi

; 472  : 		m_nSize = nNewSize;
; 473  : 		m_nMaxSize = nNewMax;
; 474  : 	}
; 475  : }

  0006a	5e		 pop	 esi
  0006b	5b		 pop	 ebx
  0006c	8b e5		 mov	 esp, ebp
  0006e	5d		 pop	 ebp
  0006f	c2 08 00	 ret	 8
$LN19@SetSize:

; 389  : 	}
; 390  : 	else if (m_pData == NULL)

  00072	85 d2		 test	 edx, edx
  00074	75 56		 jne	 SHORT $LN22@SetSize

; 391  : 	{
; 392  : 		// create buffer big enough to hold number of requested elements or
; 393  : 		// m_nGrowBy elements, whichever is larger.
; 394  : #ifdef SIZE_T_MAX
; 395  : 		ASSERT(nNewSize <= SIZE_T_MAX/sizeof(TYPE));    // no overflow
; 396  : #endif
; 397  : 		size_t nAllocSize = __max(nNewSize, m_nGrowBy);

  00076	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00079	3b d8		 cmp	 ebx, eax
  0007b	0f 4f c3	 cmovg	 eax, ebx

; 398  : 		m_pData = (TYPE*) new BYTE[(size_t)nAllocSize * sizeof(TYPE)];

  0007e	69 f0 94 00 00
	00		 imul	 esi, eax, 148
  00084	89 45 fc	 mov	 DWORD PTR _nAllocSize$1$[ebp], eax
  00087	56		 push	 esi
  00088	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]

; 399  : 		memset((void*)m_pData, 0, (size_t)nAllocSize * sizeof(TYPE));

  0008d	56		 push	 esi
  0008e	6a 00		 push	 0
  00090	50		 push	 eax
  00091	89 47 04	 mov	 DWORD PTR [edi+4], eax
  00094	e8 00 00 00 00	 call	 _memset
  00099	83 c4 10	 add	 esp, 16			; 00000010H

; 400  : 		for( int i = 0; i < nNewSize; i++ )

  0009c	85 db		 test	 ebx, ebx
  0009e	7e 1a		 jle	 SHORT $LN6@SetSize

; 398  : 		m_pData = (TYPE*) new BYTE[(size_t)nAllocSize * sizeof(TYPE)];

  000a0	33 f6		 xor	 esi, esi
$LL7@SetSize:

; 401  : #pragma push_macro("new")
; 402  : #undef new
; 403  : 			::new( (void*)( m_pData + i ) ) TYPE;

  000a2	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  000a5	03 ce		 add	 ecx, esi
  000a7	e8 00 00 00 00	 call	 ??0ST_GRIDDATA@@QAE@XZ
  000ac	81 c6 94 00 00
	00		 add	 esi, 148		; 00000094H
  000b2	83 eb 01	 sub	 ebx, 1
  000b5	75 eb		 jne	 SHORT $LL7@SetSize
  000b7	8b 5d 08	 mov	 ebx, DWORD PTR _nNewSize$[ebp]
$LN6@SetSize:

; 472  : 		m_nSize = nNewSize;
; 473  : 		m_nMaxSize = nNewMax;
; 474  : 	}
; 475  : }

  000ba	8b 45 fc	 mov	 eax, DWORD PTR _nNewMax$1$[ebp]
  000bd	89 47 0c	 mov	 DWORD PTR [edi+12], eax
$LN12@SetSize:
  000c0	89 5f 08	 mov	 DWORD PTR [edi+8], ebx
  000c3	5f		 pop	 edi
  000c4	5e		 pop	 esi
  000c5	5b		 pop	 ebx
  000c6	8b e5		 mov	 esp, ebp
  000c8	5d		 pop	 ebp
  000c9	c2 08 00	 ret	 8
$LN22@SetSize:

; 404  : #pragma pop_macro("new")
; 405  : 		m_nSize = nNewSize;
; 406  : 		m_nMaxSize = nAllocSize;
; 407  : 	}
; 408  : 	else if (nNewSize <= m_nMaxSize)

  000cc	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  000cf	3b d9		 cmp	 ebx, ecx
  000d1	0f 8f a7 00 00
	00		 jg	 $LN24@SetSize

; 409  : 	{
; 410  : 		// it fits
; 411  : 		if (nNewSize > m_nSize)

  000d7	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  000da	3b d9		 cmp	 ebx, ecx
  000dc	7e 5b		 jle	 SHORT $LN26@SetSize

; 412  : 		{
; 413  : 			// initialize the new elements
; 414  : 			memset((void*)(m_pData + m_nSize), 0, (size_t)(nNewSize-m_nSize) * sizeof(TYPE));

  000de	8b c3		 mov	 eax, ebx
  000e0	2b c1		 sub	 eax, ecx
  000e2	69 c0 94 00 00
	00		 imul	 eax, eax, 148
  000e8	50		 push	 eax
  000e9	69 c1 94 00 00
	00		 imul	 eax, ecx, 148
  000ef	6a 00		 push	 0
  000f1	03 c2		 add	 eax, edx
  000f3	50		 push	 eax
  000f4	e8 00 00 00 00	 call	 _memset

; 415  : 			for( int i = 0; i < nNewSize-m_nSize; i++ )

  000f9	8b c3		 mov	 eax, ebx
  000fb	83 c4 0c	 add	 esp, 12			; 0000000cH
  000fe	2b 47 08	 sub	 eax, DWORD PTR [edi+8]
  00101	33 f6		 xor	 esi, esi
  00103	85 c0		 test	 eax, eax
  00105	7e b9		 jle	 SHORT $LN12@SetSize
  00107	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL10@SetSize:

; 416  : #pragma push_macro("new")
; 417  : #undef new
; 418  : 				::new( (void*)( m_pData + m_nSize + i ) ) TYPE;

  00110	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00113	03 c6		 add	 eax, esi
  00115	69 c8 94 00 00
	00		 imul	 ecx, eax, 148
  0011b	03 4f 04	 add	 ecx, DWORD PTR [edi+4]
  0011e	e8 00 00 00 00	 call	 ??0ST_GRIDDATA@@QAE@XZ
  00123	8b c3		 mov	 eax, ebx
  00125	46		 inc	 esi
  00126	2b 47 08	 sub	 eax, DWORD PTR [edi+8]
  00129	3b f0		 cmp	 esi, eax
  0012b	7c e3		 jl	 SHORT $LL10@SetSize

; 472  : 		m_nSize = nNewSize;
; 473  : 		m_nMaxSize = nNewMax;
; 474  : 	}
; 475  : }

  0012d	89 5f 08	 mov	 DWORD PTR [edi+8], ebx
  00130	5f		 pop	 edi
  00131	5e		 pop	 esi
  00132	5b		 pop	 ebx
  00133	8b e5		 mov	 esp, ebp
  00135	5d		 pop	 ebp
  00136	c2 08 00	 ret	 8
$LN26@SetSize:

; 419  : #pragma pop_macro("new")
; 420  : 		}
; 421  : 		else if (m_nSize > nNewSize)

  00139	7d 85		 jge	 SHORT $LN12@SetSize

; 422  : 		{
; 423  : 			// destroy the old elements
; 424  : 			for( int i = 0; i < m_nSize-nNewSize; i++ )

  0013b	2b cb		 sub	 ecx, ebx
  0013d	c7 45 08 00 00
	00 00		 mov	 DWORD PTR _i$1$[ebp], 0
  00144	85 c9		 test	 ecx, ecx
  00146	0f 8e 74 ff ff
	ff		 jle	 $LN12@SetSize
  0014c	69 f3 94 00 00
	00		 imul	 esi, ebx, 148
$LL13@SetSize:

; 425  : 				(m_pData + nNewSize + i)->~TYPE();

  00152	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00155	03 ce		 add	 ecx, esi
  00157	e8 00 00 00 00	 call	 ??1ST_GRIDDATA@@QAE@XZ
  0015c	8b 4d 08	 mov	 ecx, DWORD PTR _i$1$[ebp]
  0015f	81 c6 94 00 00
	00		 add	 esi, 148		; 00000094H
  00165	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00168	41		 inc	 ecx
  00169	2b c3		 sub	 eax, ebx
  0016b	89 4d 08	 mov	 DWORD PTR _i$1$[ebp], ecx
  0016e	3b c8		 cmp	 ecx, eax
  00170	7c e0		 jl	 SHORT $LL13@SetSize

; 472  : 		m_nSize = nNewSize;
; 473  : 		m_nMaxSize = nNewMax;
; 474  : 	}
; 475  : }

  00172	89 5f 08	 mov	 DWORD PTR [edi+8], ebx
  00175	5f		 pop	 edi
  00176	5e		 pop	 esi
  00177	5b		 pop	 ebx
  00178	8b e5		 mov	 esp, ebp
  0017a	5d		 pop	 ebp
  0017b	c2 08 00	 ret	 8
$LN24@SetSize:

; 426  : 		}
; 427  : 		m_nSize = nNewSize;
; 428  : 	}
; 429  : 	else
; 430  : 	{
; 431  : 		// otherwise, grow array
; 432  : 		nGrowBy = m_nGrowBy;

  0017e	8b 47 10	 mov	 eax, DWORD PTR [edi+16]

; 433  : 		if (nGrowBy == 0)

  00181	85 c0		 test	 eax, eax
  00183	75 22		 jne	 SHORT $LN37@SetSize

; 434  : 		{
; 435  : 			// heuristically determine growth when nGrowBy == 0
; 436  : 			//  (this avoids heap fragmentation in many situations)
; 437  : 			nGrowBy = m_nSize / 8;

  00185	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00188	99		 cdq
  00189	83 e2 07	 and	 edx, 7
  0018c	03 c2		 add	 eax, edx
  0018e	c1 f8 03	 sar	 eax, 3

; 438  : 			nGrowBy = (nGrowBy < 4) ? 4 : ((nGrowBy > 1024) ? 1024 : nGrowBy);

  00191	83 f8 04	 cmp	 eax, 4
  00194	7d 07		 jge	 SHORT $LN36@SetSize
  00196	b8 04 00 00 00	 mov	 eax, 4
  0019b	eb 0a		 jmp	 SHORT $LN37@SetSize
$LN36@SetSize:
  0019d	ba 00 04 00 00	 mov	 edx, 1024		; 00000400H
  001a2	3b c2		 cmp	 eax, edx
  001a4	0f 4f c2	 cmovg	 eax, edx
$LN37@SetSize:

; 439  : 		}
; 440  : 		INT_PTR nNewMax;
; 441  : 		if (nNewSize < m_nMaxSize + nGrowBy)

  001a7	03 c1		 add	 eax, ecx
  001a9	89 45 fc	 mov	 DWORD PTR _nNewMax$1$[ebp], eax
  001ac	3b d8		 cmp	 ebx, eax
  001ae	7d 0a		 jge	 SHORT $LN30@SetSize

; 445  : 
; 446  : 		ASSERT(nNewMax >= m_nMaxSize);  // no wrap around
; 447  : 
; 448  : 		if(nNewMax  < m_nMaxSize)

  001b0	3b c1		 cmp	 eax, ecx
  001b2	0f 8c 23 01 00
	00		 jl	 $LN76@SetSize
  001b8	eb 05		 jmp	 SHORT $LN32@SetSize
$LN30@SetSize:

; 442  : 			nNewMax = m_nMaxSize + nGrowBy;  // granularity
; 443  : 		else
; 444  : 			nNewMax = nNewSize;  // no slush

  001ba	8b c3		 mov	 eax, ebx
  001bc	89 5d fc	 mov	 DWORD PTR _nNewMax$1$[ebp], ebx
$LN32@SetSize:

; 450  : 
; 451  : #ifdef SIZE_T_MAX
; 452  : 		ASSERT(nNewMax <= SIZE_T_MAX/sizeof(TYPE)); // no overflow
; 453  : #endif
; 454  : 		TYPE* pNewData = (TYPE*) new BYTE[(size_t)nNewMax * sizeof(TYPE)];

  001bf	69 c0 94 00 00
	00		 imul	 eax, eax, 148
  001c5	50		 push	 eax
  001c6	89 45 08	 mov	 DWORD PTR __S1max$1$[ebp], eax
  001c9	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]

; 455  : 
; 456  : 		// copy new data from old
; 457  : 		::ATL::Checked::memcpy_s(pNewData, (size_t)nNewMax * sizeof(TYPE),

  001ce	69 4f 08 94 00
	00 00		 imul	 ecx, DWORD PTR [edi+8], 148
  001d5	83 c4 04	 add	 esp, 4
  001d8	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  001db	8b f0		 mov	 esi, eax
  001dd	89 75 0c	 mov	 DWORD PTR _pNewData$1$[ebp], esi
  001e0	89 55 f8	 mov	 DWORD PTR __S2$1$[ebp], edx
  001e3	89 4d f4	 mov	 DWORD PTR __N$1$[ebp], ecx
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_memcpy_s.h

; 46   :         if (_SourceSize == 0)

  001e6	85 c9		 test	 ecx, ecx
  001e8	74 1f		 je	 SHORT $LN46@SetSize
$LN47@SetSize:

; 47   :         {
; 48   :             return 0;
; 49   :         }
; 50   : 
; 51   :         _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Destination != NULL, EINVAL);

  001ea	85 f6		 test	 esi, esi
  001ec	0f 85 8e 00 00
	00		 jne	 $LN48@SetSize
$LN79@SetSize:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlchecked.h

; 69   : 	ATLMFC_CRT_ERRORCHECK(::memcpy_s(_S1, _S1max, _S2, _N));

  001f2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___errno
  001f8	c7 00 16 00 00
	00		 mov	 DWORD PTR [eax], 22	; 00000016H
  001fe	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo
$LN52@SetSize:
  00204	b9 16 00 00 00	 mov	 ecx, 22			; 00000016H
$LN46@SetSize:
  00209	51		 push	 ecx
  0020a	e8 00 00 00 00	 call	 ?AfxCrtErrorCheck@@YAHH@Z ; AfxCrtErrorCheck
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 462  : 		memset((void*)(pNewData + m_nSize), 0, (size_t)(nNewSize-m_nSize) * sizeof(TYPE));

  0020f	8b c3		 mov	 eax, ebx
  00211	2b 47 08	 sub	 eax, DWORD PTR [edi+8]
  00214	69 c0 94 00 00
	00		 imul	 eax, eax, 148
  0021a	50		 push	 eax
  0021b	69 47 08 94 00
	00 00		 imul	 eax, DWORD PTR [edi+8], 148
  00222	6a 00		 push	 0
  00224	03 c6		 add	 eax, esi
  00226	50		 push	 eax
  00227	e8 00 00 00 00	 call	 _memset

; 463  : 		for( int i = 0; i < nNewSize-m_nSize; i++ )

  0022c	8b c3		 mov	 eax, ebx
  0022e	83 c4 10	 add	 esp, 16			; 00000010H
  00231	2b 47 08	 sub	 eax, DWORD PTR [edi+8]
  00234	33 f6		 xor	 esi, esi
  00236	85 c0		 test	 eax, eax
  00238	7e 23		 jle	 SHORT $LN15@SetSize
  0023a	66 0f 1f 44 00
	00		 npad	 6
$LL16@SetSize:

; 464  : #pragma push_macro("new")
; 465  : #undef new
; 466  : 			::new( (void*)( pNewData + m_nSize + i ) ) TYPE;

  00240	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00243	03 c6		 add	 eax, esi
  00245	69 c8 94 00 00
	00		 imul	 ecx, eax, 148
  0024b	03 4d 0c	 add	 ecx, DWORD PTR _pNewData$1$[ebp]
  0024e	e8 00 00 00 00	 call	 ??0ST_GRIDDATA@@QAE@XZ
  00253	8b c3		 mov	 eax, ebx
  00255	46		 inc	 esi
  00256	2b 47 08	 sub	 eax, DWORD PTR [edi+8]
  00259	3b f0		 cmp	 esi, eax
  0025b	7c e3		 jl	 SHORT $LL16@SetSize
$LN15@SetSize:

; 467  : #pragma pop_macro("new")
; 468  : 
; 469  : 		// get rid of old stuff (note: no destructors called)
; 470  : 		delete[] (BYTE*)m_pData;

  0025d	ff 77 04	 push	 DWORD PTR [edi+4]
  00260	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]

; 471  : 		m_pData = pNewData;

  00265	8b 45 0c	 mov	 eax, DWORD PTR _pNewData$1$[ebp]
  00268	83 c4 04	 add	 esp, 4
  0026b	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 472  : 		m_nSize = nNewSize;
; 473  : 		m_nMaxSize = nNewMax;
; 474  : 	}
; 475  : }

  0026e	8b 45 fc	 mov	 eax, DWORD PTR _nNewMax$1$[ebp]
  00271	89 5f 08	 mov	 DWORD PTR [edi+8], ebx
  00274	89 47 0c	 mov	 DWORD PTR [edi+12], eax
  00277	5f		 pop	 edi
  00278	5e		 pop	 esi
  00279	5b		 pop	 ebx
  0027a	8b e5		 mov	 esp, ebp
  0027c	5d		 pop	 ebp
  0027d	c2 08 00	 ret	 8
$LN48@SetSize:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_memcpy_s.h

; 52   :         if (_Source == NULL || _DestinationSize < _SourceSize)

  00280	8b 45 08	 mov	 eax, DWORD PTR __S1max$1$[ebp]
  00283	85 d2		 test	 edx, edx
  00285	74 16		 je	 SHORT $LN50@SetSize
  00287	3b c1		 cmp	 eax, ecx
  00289	72 12		 jb	 SHORT $LN50@SetSize

; 58   : 
; 59   :             // Unreachable, but required to suppress /analyze warnings:
; 60   :             return EINVAL;
; 61   :         }
; 62   :         memcpy(_Destination, _Source, _SourceSize);

  0028b	51		 push	 ecx
  0028c	52		 push	 edx
  0028d	56		 push	 esi
  0028e	e8 00 00 00 00	 call	 _memcpy
  00293	83 c4 0c	 add	 esp, 12			; 0000000cH

; 63   :         return 0;

  00296	33 c9		 xor	 ecx, ecx
  00298	e9 6c ff ff ff	 jmp	 $LN46@SetSize
$LN50@SetSize:

; 53   :         {
; 54   :             memset(_Destination, 0, _DestinationSize);

  0029d	50		 push	 eax
  0029e	6a 00		 push	 0
  002a0	56		 push	 esi
  002a1	e8 00 00 00 00	 call	 _memset
  002a6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 55   : 
; 56   :             _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Source != NULL,                 EINVAL);

  002a9	83 7d f8 00	 cmp	 DWORD PTR __S2$1$[ebp], 0
  002ad	0f 84 3f ff ff
	ff		 je	 $LN79@SetSize

; 57   :             _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_DestinationSize >= _SourceSize, ERANGE);

  002b3	8b 45 f4	 mov	 eax, DWORD PTR __N$1$[ebp]
  002b6	39 45 08	 cmp	 DWORD PTR __S1max$1$[ebp], eax
  002b9	0f 83 45 ff ff
	ff		 jae	 $LN52@SetSize
  002bf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___errno
  002c5	c7 00 22 00 00
	00		 mov	 DWORD PTR [eax], 34	; 00000022H
  002cb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo
  002d1	b9 22 00 00 00	 mov	 ecx, 34			; 00000022H
  002d6	e9 2e ff ff ff	 jmp	 $LN46@SetSize
$LN76@SetSize:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 449  : 			AfxThrowInvalidArgException();

  002db	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN78@SetSize:
  002e0	cc		 int	 3
?SetSize@?$CArray@UST_GRIDDATA@@U1@@@QAEXHH@Z ENDP	; CArray<ST_GRIDDATA,ST_GRIDDATA>::SetSize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ??0?$CArray@UST_GRIDDATA@@U1@@@QAE@XZ
_TEXT	SEGMENT
??0?$CArray@UST_GRIDDATA@@U1@@@QAE@XZ PROC		; CArray<ST_GRIDDATA,ST_GRIDDATA>::CArray<ST_GRIDDATA,ST_GRIDDATA>, COMDAT
; _this$ = ecx

; 348  : {

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CArray@UST_GRIDDATA@@U1@@@6B@

; 349  : 	m_pData = NULL;
; 350  : 	m_nSize = m_nMaxSize = m_nGrowBy = 0;
; 351  : }

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  00016	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0
  0001d	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00024	c3		 ret	 0
??0?$CArray@UST_GRIDDATA@@U1@@@QAE@XZ ENDP		; CArray<ST_GRIDDATA,ST_GRIDDATA>::CArray<ST_GRIDDATA,ST_GRIDDATA>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
;	COMDAT ??_G?$CArray@UST_RUNVALUE@@U1@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CArray@UST_RUNVALUE@@U1@@@UAEPAXI@Z PROC		; CArray<ST_RUNVALUE,ST_RUNVALUE>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 355  : {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 356  : 	ASSERT_VALID(this);
; 357  : 
; 358  : 	if (m_pData != NULL)

  00006	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CArray@UST_RUNVALUE@@U1@@@6B@
  0000f	85 c0		 test	 eax, eax
  00011	74 09		 je	 SHORT $LN11@scalar

; 359  : 	{
; 360  : 		for( int i = 0; i < m_nSize; i++ )
; 361  : 			(m_pData + i)->~TYPE();
; 362  : 		delete[] (BYTE*)m_pData;

  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00019	83 c4 04	 add	 esp, 4
$LN11@scalar:
  0001c	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  0001f	a8 01		 test	 al, 1
  00021	74 1f		 je	 SHORT $LN20@scalar
  00023	a8 04		 test	 al, 4
  00025	75 10		 jne	 SHORT $LN3@scalar
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 112  : 	{ ::operator delete(p); }

  00027	56		 push	 esi
  00028	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0002d	83 c4 04	 add	 esp, 4
  00030	8b c6		 mov	 eax, esi
  00032	5e		 pop	 esi
  00033	5d		 pop	 ebp
  00034	c2 04 00	 ret	 4
$LN3@scalar:
  00037	6a 14		 push	 20			; 00000014H
  00039	56		 push	 esi
  0003a	e8 00 00 00 00	 call	 ?__global_delete@@YAXPAXI@Z ; __global_delete
  0003f	83 c4 08	 add	 esp, 8
$LN20@scalar:
  00042	8b c6		 mov	 eax, esi
  00044	5e		 pop	 esi
  00045	5d		 pop	 ebp
  00046	c2 04 00	 ret	 4
??_G?$CArray@UST_RUNVALUE@@U1@@@UAEPAXI@Z ENDP		; CArray<ST_RUNVALUE,ST_RUNVALUE>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ?Serialize@?$CArray@UST_RUNVALUE@@U1@@@UAEXAAVCArchive@@@Z
_TEXT	SEGMENT
_pData$1$ = -4						; size = 4
_ar$ = 8						; size = 4
?Serialize@?$CArray@UST_RUNVALUE@@U1@@@UAEXAAVCArchive@@@Z PROC ; CArray<ST_RUNVALUE,ST_RUNVALUE>::Serialize, COMDAT
; _this$ = ecx

; 633  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	8b f9		 mov	 edi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 212  : 	{ return (m_nMode & CArchive::load) == 0; }

  00009	8b 4d 08	 mov	 ecx, DWORD PTR _ar$[ebp]
  0000c	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  0000f	f7 d0		 not	 eax
  00011	a8 01		 test	 al, 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 637  : 	if (ar.IsStoring())

  00013	74 0a		 je	 SHORT $LN2@Serialize

; 638  : 	{
; 639  : 		ar.WriteCount(m_nSize);

  00015	ff 77 08	 push	 DWORD PTR [edi+8]
  00018	e8 00 00 00 00	 call	 ?WriteCount@CArchive@@QAEXK@Z ; CArchive::WriteCount

; 640  : 	}

  0001d	eb 0f		 jmp	 SHORT $LN3@Serialize
$LN2@Serialize:

; 641  : 	else
; 642  : 	{
; 643  : 		DWORD_PTR nOldSize = ar.ReadCount();

  0001f	e8 00 00 00 00	 call	 ?ReadCount@CArchive@@QAEKXZ ; CArchive::ReadCount

; 644  : 		SetSize(nOldSize, -1);

  00024	6a ff		 push	 -1
  00026	50		 push	 eax
  00027	8b cf		 mov	 ecx, edi
  00029	e8 00 00 00 00	 call	 ?SetSize@?$CArray@UST_RUNVALUE@@U1@@@QAEXHH@Z ; CArray<ST_RUNVALUE,ST_RUNVALUE>::SetSize
$LN3@Serialize:

; 645  : 	}
; 646  : 	SerializeElements<TYPE>(ar, m_pData, m_nSize);

  0002e	8b 77 08	 mov	 esi, DWORD PTR [edi+8]
  00031	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00034	89 4d fc	 mov	 DWORD PTR _pData$1$[ebp], ecx

; 68   : 	ENSURE(nCount == 0 || pElements != NULL);

  00037	85 f6		 test	 esi, esi
  00039	74 08		 je	 SHORT $LN8@Serialize
  0003b	85 c9		 test	 ecx, ecx
  0003d	0f 84 8b 00 00
	00		 je	 $LN40@Serialize
$LN8@Serialize:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 212  : 	{ return (m_nMode & CArchive::load) == 0; }

  00043	8b 55 08	 mov	 edx, DWORD PTR _ar$[ebp]
  00046	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00049	f7 d0		 not	 eax
  0004b	a8 01		 test	 al, 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 73   : 	if (ar.IsStoring())

  0004d	74 35		 je	 SHORT $LN16@Serialize

; 74   : 	{
; 75   : 		TYPE* pData;
; 76   : 		UINT_PTR nElementsLeft;
; 77   : 
; 78   : 		nElementsLeft = nCount;
; 79   : 		pData = pElements;
; 80   : 		while( nElementsLeft > 0 )

  0004f	85 f6		 test	 esi, esi
  00051	74 28		 je	 SHORT $LN14@Serialize
$LL11@Serialize:

; 81   : 		{
; 82   : 			UINT nElementsToWrite;
; 83   : 
; 84   : 			nElementsToWrite = UINT(__min(nElementsLeft, INT_MAX/sizeof(TYPE)));

  00053	bb aa aa aa 0a	 mov	 ebx, 178956970		; 0aaaaaaaH
  00058	3b f3		 cmp	 esi, ebx
  0005a	0f 42 de	 cmovb	 ebx, esi

; 85   : 			ar.Write(pData, nElementsToWrite*sizeof(TYPE));

  0005d	8d 3c 5b	 lea	 edi, DWORD PTR [ebx+ebx*2]
  00060	c1 e7 02	 shl	 edi, 2
  00063	57		 push	 edi
  00064	51		 push	 ecx
  00065	8b ca		 mov	 ecx, edx
  00067	e8 00 00 00 00	 call	 ?Write@CArchive@@QAEXPBXI@Z ; CArchive::Write

; 86   : 			nElementsLeft -= nElementsToWrite;
; 87   : 			pData += nElementsToWrite;

  0006c	8b 4d fc	 mov	 ecx, DWORD PTR _pData$1$[ebp]
  0006f	8b 55 08	 mov	 edx, DWORD PTR _ar$[ebp]
  00072	03 cf		 add	 ecx, edi
  00074	89 4d fc	 mov	 DWORD PTR _pData$1$[ebp], ecx
  00077	2b f3		 sub	 esi, ebx
  00079	75 d8		 jne	 SHORT $LL11@Serialize
$LN14@Serialize:
  0007b	5f		 pop	 edi

; 647  : }

  0007c	5e		 pop	 esi
  0007d	5b		 pop	 ebx
  0007e	8b e5		 mov	 esp, ebp
  00080	5d		 pop	 ebp
  00081	c2 04 00	 ret	 4
$LN16@Serialize:

; 97   : 		while( nElementsLeft > 0 )

  00084	85 f6		 test	 esi, esi
  00086	74 f3		 je	 SHORT $LN14@Serialize
  00088	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL13@Serialize:

; 98   : 		{
; 99   : 			UINT nElementsToRead;
; 100  : 
; 101  : 			nElementsToRead = UINT(__min(nElementsLeft, INT_MAX/sizeof(TYPE)));

  00090	bf aa aa aa 0a	 mov	 edi, 178956970		; 0aaaaaaaH
  00095	3b f7		 cmp	 esi, edi
  00097	0f 42 fe	 cmovb	 edi, esi

; 102  : 			ar.EnsureRead(pData, nElementsToRead*sizeof(TYPE));

  0009a	8d 1c 7f	 lea	 ebx, DWORD PTR [edi+edi*2]
  0009d	c1 e3 02	 shl	 ebx, 2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 399  : 	UINT nRead=Read(lpBuf, nCount);

  000a0	53		 push	 ebx
  000a1	51		 push	 ecx
  000a2	8b ca		 mov	 ecx, edx
  000a4	e8 00 00 00 00	 call	 ?Read@CArchive@@QAEIPAXI@Z ; CArchive::Read

; 400  : 	if(nRead!=nCount)

  000a9	3b c3		 cmp	 eax, ebx
  000ab	75 18		 jne	 SHORT $LN30@Serialize
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 97   : 		while( nElementsLeft > 0 )

  000ad	8b 4d fc	 mov	 ecx, DWORD PTR _pData$1$[ebp]
  000b0	8b 55 08	 mov	 edx, DWORD PTR _ar$[ebp]

; 103  : 			nElementsLeft -= nElementsToRead;
; 104  : 			pData += nElementsToRead;

  000b3	03 cb		 add	 ecx, ebx
  000b5	89 4d fc	 mov	 DWORD PTR _pData$1$[ebp], ecx
  000b8	2b f7		 sub	 esi, edi
  000ba	75 d4		 jne	 SHORT $LL13@Serialize

; 647  : }

  000bc	5f		 pop	 edi
  000bd	5e		 pop	 esi
  000be	5b		 pop	 ebx
  000bf	8b e5		 mov	 esp, ebp
  000c1	5d		 pop	 ebp
  000c2	c2 04 00	 ret	 4
$LN30@Serialize:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 402  : 		AfxThrowArchiveException(CArchiveException::endOfFile);

  000c5	6a 00		 push	 0
  000c7	6a 03		 push	 3
  000c9	e8 00 00 00 00	 call	 ?AfxThrowArchiveException@@YGXHPBD@Z ; AfxThrowArchiveException
$LN40@Serialize:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 68   : 	ENSURE(nCount == 0 || pElements != NULL);

  000ce	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN38@Serialize:
  000d3	cc		 int	 3
?Serialize@?$CArray@UST_RUNVALUE@@U1@@@UAEXAAVCArchive@@@Z ENDP ; CArray<ST_RUNVALUE,ST_RUNVALUE>::Serialize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ??1?$CArray@UST_RUNVALUE@@U1@@@UAE@XZ
_TEXT	SEGMENT
??1?$CArray@UST_RUNVALUE@@U1@@@UAE@XZ PROC		; CArray<ST_RUNVALUE,ST_RUNVALUE>::~CArray<ST_RUNVALUE,ST_RUNVALUE>, COMDAT
; _this$ = ecx

; 356  : 	ASSERT_VALID(this);
; 357  : 
; 358  : 	if (m_pData != NULL)

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CArray@UST_RUNVALUE@@U1@@@6B@
  00009	85 c0		 test	 eax, eax
  0000b	74 07		 je	 SHORT $LN5@CArray

; 359  : 	{
; 360  : 		for( int i = 0; i < m_nSize; i++ )
; 361  : 			(m_pData + i)->~TYPE();
; 362  : 		delete[] (BYTE*)m_pData;

  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00013	59		 pop	 ecx
$LN5@CArray:

; 363  : 	}
; 364  : }

  00014	c3		 ret	 0
??1?$CArray@UST_RUNVALUE@@U1@@@UAE@XZ ENDP		; CArray<ST_RUNVALUE,ST_RUNVALUE>::~CArray<ST_RUNVALUE,ST_RUNVALUE>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_memcpy_s.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlchecked.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_memcpy_s.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlchecked.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_memcpy_s.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ?SetSize@?$CArray@UST_RUNVALUE@@U1@@@QAEXHH@Z
_TEXT	SEGMENT
__N$1$ = -8						; size = 4
_pNewData$1$ = -4					; size = 4
__S1max$1$ = 8						; size = 4
_nNewSize$ = 8						; size = 4
__S2$1$ = 12						; size = 4
_nGrowBy$ = 12						; size = 4
?SetSize@?$CArray@UST_RUNVALUE@@U1@@@QAEXHH@Z PROC	; CArray<ST_RUNVALUE,ST_RUNVALUE>::SetSize, COMDAT
; _this$ = ecx

; 368  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 369  : 	ASSERT_VALID(this);
; 370  : 	ASSERT(nNewSize >= 0);
; 371  : 
; 372  : 	if(nNewSize < 0 )

  00008	8b 75 08	 mov	 esi, DWORD PTR _nNewSize$[ebp]
  0000b	8b d9		 mov	 ebx, ecx
  0000d	57		 push	 edi
  0000e	85 f6		 test	 esi, esi
  00010	0f 88 ca 01 00
	00		 js	 $LN70@SetSize

; 373  : 		AfxThrowInvalidArgException();
; 374  : 
; 375  : 	if (nGrowBy >= 0)

  00016	8b 45 0c	 mov	 eax, DWORD PTR _nGrowBy$[ebp]
  00019	85 c0		 test	 eax, eax
  0001b	78 03		 js	 SHORT $LN69@SetSize

; 376  : 		m_nGrowBy = nGrowBy;  // set new size

  0001d	89 43 10	 mov	 DWORD PTR [ebx+16], eax
$LN69@SetSize:

; 377  : 
; 378  : 	if (nNewSize == 0)

  00020	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00023	85 f6		 test	 esi, esi
  00025	75 27		 jne	 SHORT $LN19@SetSize

; 379  : 	{
; 380  : 		// shrink to nothing
; 381  : 		if (m_pData != NULL)

  00027	85 c9		 test	 ecx, ecx
  00029	74 0c		 je	 SHORT $LN21@SetSize

; 382  : 		{
; 383  : 			for( int i = 0; i < m_nSize; i++ )
; 384  : 				(m_pData + i)->~TYPE();
; 385  : 			delete[] (BYTE*)m_pData;

  0002b	51		 push	 ecx
  0002c	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00031	83 c4 04	 add	 esp, 4

; 386  : 			m_pData = NULL;

  00034	89 73 04	 mov	 DWORD PTR [ebx+4], esi
$LN21@SetSize:

; 472  : 		m_nSize = nNewSize;
; 473  : 		m_nMaxSize = nNewMax;
; 474  : 	}
; 475  : }

  00037	5f		 pop	 edi
  00038	5e		 pop	 esi
  00039	c7 43 0c 00 00
	00 00		 mov	 DWORD PTR [ebx+12], 0
  00040	c7 43 08 00 00
	00 00		 mov	 DWORD PTR [ebx+8], 0
  00047	5b		 pop	 ebx
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c2 08 00	 ret	 8
$LN19@SetSize:

; 387  : 		}
; 388  : 		m_nSize = m_nMaxSize = 0;
; 389  : 	}
; 390  : 	else if (m_pData == NULL)

  0004e	85 c9		 test	 ecx, ecx
  00050	75 35		 jne	 SHORT $LN22@SetSize

; 391  : 	{
; 392  : 		// create buffer big enough to hold number of requested elements or
; 393  : 		// m_nGrowBy elements, whichever is larger.
; 394  : #ifdef SIZE_T_MAX
; 395  : 		ASSERT(nNewSize <= SIZE_T_MAX/sizeof(TYPE));    // no overflow
; 396  : #endif
; 397  : 		size_t nAllocSize = __max(nNewSize, m_nGrowBy);

  00052	8b 7b 10	 mov	 edi, DWORD PTR [ebx+16]
  00055	3b f7		 cmp	 esi, edi
  00057	0f 4f fe	 cmovg	 edi, esi

; 398  : 		m_pData = (TYPE*) new BYTE[(size_t)nAllocSize * sizeof(TYPE)];

  0005a	8d 34 7f	 lea	 esi, DWORD PTR [edi+edi*2]
  0005d	c1 e6 02	 shl	 esi, 2
  00060	56		 push	 esi
  00061	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]

; 399  : 		memset((void*)m_pData, 0, (size_t)nAllocSize * sizeof(TYPE));

  00066	56		 push	 esi
  00067	6a 00		 push	 0
  00069	50		 push	 eax
  0006a	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  0006d	e8 00 00 00 00	 call	 _memset

; 400  : 		for( int i = 0; i < nNewSize; i++ )
; 401  : #pragma push_macro("new")
; 402  : #undef new
; 403  : 			::new( (void*)( m_pData + i ) ) TYPE;
; 404  : #pragma pop_macro("new")
; 405  : 		m_nSize = nNewSize;

  00072	8b 45 08	 mov	 eax, DWORD PTR _nNewSize$[ebp]
  00075	83 c4 10	 add	 esp, 16			; 00000010H

; 472  : 		m_nSize = nNewSize;
; 473  : 		m_nMaxSize = nNewMax;
; 474  : 	}
; 475  : }

  00078	89 7b 0c	 mov	 DWORD PTR [ebx+12], edi
  0007b	89 43 08	 mov	 DWORD PTR [ebx+8], eax
  0007e	5f		 pop	 edi
  0007f	5e		 pop	 esi
  00080	5b		 pop	 ebx
  00081	8b e5		 mov	 esp, ebp
  00083	5d		 pop	 ebp
  00084	c2 08 00	 ret	 8
$LN22@SetSize:

; 406  : 		m_nMaxSize = nAllocSize;
; 407  : 	}
; 408  : 	else if (nNewSize <= m_nMaxSize)

  00087	8b 7b 0c	 mov	 edi, DWORD PTR [ebx+12]
  0008a	3b f7		 cmp	 esi, edi
  0008c	7f 2f		 jg	 SHORT $LN24@SetSize

; 409  : 	{
; 410  : 		// it fits
; 411  : 		if (nNewSize > m_nSize)

  0008e	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]
  00091	3b f2		 cmp	 esi, edx
  00093	7e 1c		 jle	 SHORT $LN26@SetSize

; 412  : 		{
; 413  : 			// initialize the new elements
; 414  : 			memset((void*)(m_pData + m_nSize), 0, (size_t)(nNewSize-m_nSize) * sizeof(TYPE));

  00095	8b c6		 mov	 eax, esi
  00097	2b c2		 sub	 eax, edx
  00099	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  0009c	c1 e0 02	 shl	 eax, 2
  0009f	50		 push	 eax
  000a0	8d 04 52	 lea	 eax, DWORD PTR [edx+edx*2]
  000a3	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  000a6	6a 00		 push	 0
  000a8	50		 push	 eax
  000a9	e8 00 00 00 00	 call	 _memset
  000ae	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN26@SetSize:

; 415  : 			for( int i = 0; i < nNewSize-m_nSize; i++ )
; 416  : #pragma push_macro("new")
; 417  : #undef new
; 418  : 				::new( (void*)( m_pData + m_nSize + i ) ) TYPE;
; 419  : #pragma pop_macro("new")
; 420  : 		}
; 421  : 		else if (m_nSize > nNewSize)
; 422  : 		{
; 423  : 			// destroy the old elements
; 424  : 			for( int i = 0; i < m_nSize-nNewSize; i++ )
; 425  : 				(m_pData + nNewSize + i)->~TYPE();
; 426  : 		}
; 427  : 		m_nSize = nNewSize;

  000b1	5f		 pop	 edi
  000b2	89 73 08	 mov	 DWORD PTR [ebx+8], esi

; 472  : 		m_nSize = nNewSize;
; 473  : 		m_nMaxSize = nNewMax;
; 474  : 	}
; 475  : }

  000b5	5e		 pop	 esi
  000b6	5b		 pop	 ebx
  000b7	8b e5		 mov	 esp, ebp
  000b9	5d		 pop	 ebp
  000ba	c2 08 00	 ret	 8
$LN24@SetSize:

; 428  : 	}
; 429  : 	else
; 430  : 	{
; 431  : 		// otherwise, grow array
; 432  : 		nGrowBy = m_nGrowBy;

  000bd	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]

; 433  : 		if (nGrowBy == 0)

  000c0	85 c0		 test	 eax, eax
  000c2	75 22		 jne	 SHORT $LN37@SetSize

; 434  : 		{
; 435  : 			// heuristically determine growth when nGrowBy == 0
; 436  : 			//  (this avoids heap fragmentation in many situations)
; 437  : 			nGrowBy = m_nSize / 8;

  000c4	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  000c7	99		 cdq
  000c8	83 e2 07	 and	 edx, 7
  000cb	03 c2		 add	 eax, edx
  000cd	c1 f8 03	 sar	 eax, 3

; 438  : 			nGrowBy = (nGrowBy < 4) ? 4 : ((nGrowBy > 1024) ? 1024 : nGrowBy);

  000d0	83 f8 04	 cmp	 eax, 4
  000d3	7d 07		 jge	 SHORT $LN36@SetSize
  000d5	b8 04 00 00 00	 mov	 eax, 4
  000da	eb 0a		 jmp	 SHORT $LN37@SetSize
$LN36@SetSize:
  000dc	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  000e1	3b c1		 cmp	 eax, ecx
  000e3	0f 4f c1	 cmovg	 eax, ecx
$LN37@SetSize:

; 439  : 		}
; 440  : 		INT_PTR nNewMax;
; 441  : 		if (nNewSize < m_nMaxSize + nGrowBy)

  000e6	03 f8		 add	 edi, eax
  000e8	3b f7		 cmp	 esi, edi
  000ea	7d 0b		 jge	 SHORT $LN30@SetSize

; 445  : 
; 446  : 		ASSERT(nNewMax >= m_nMaxSize);  // no wrap around
; 447  : 
; 448  : 		if(nNewMax  < m_nMaxSize)

  000ec	3b 7b 0c	 cmp	 edi, DWORD PTR [ebx+12]
  000ef	0f 8c eb 00 00
	00		 jl	 $LN70@SetSize
  000f5	eb 02		 jmp	 SHORT $LN32@SetSize
$LN30@SetSize:

; 442  : 			nNewMax = m_nMaxSize + nGrowBy;  // granularity
; 443  : 		else
; 444  : 			nNewMax = nNewSize;  // no slush

  000f7	8b fe		 mov	 edi, esi
$LN32@SetSize:

; 450  : 
; 451  : #ifdef SIZE_T_MAX
; 452  : 		ASSERT(nNewMax <= SIZE_T_MAX/sizeof(TYPE)); // no overflow
; 453  : #endif
; 454  : 		TYPE* pNewData = (TYPE*) new BYTE[(size_t)nNewMax * sizeof(TYPE)];

  000f9	8d 04 7f	 lea	 eax, DWORD PTR [edi+edi*2]
  000fc	c1 e0 02	 shl	 eax, 2
  000ff	50		 push	 eax
  00100	89 45 08	 mov	 DWORD PTR __S1max$1$[ebp], eax
  00103	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]

; 455  : 
; 456  : 		// copy new data from old
; 457  : 		::ATL::Checked::memcpy_s(pNewData, (size_t)nNewMax * sizeof(TYPE),

  00108	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  0010b	8b d0		 mov	 edx, eax
  0010d	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00110	83 c4 04	 add	 esp, 4
  00113	89 55 fc	 mov	 DWORD PTR _pNewData$1$[ebp], edx
  00116	89 45 0c	 mov	 DWORD PTR __S2$1$[ebp], eax
  00119	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]
  0011c	c1 e1 02	 shl	 ecx, 2
  0011f	89 4d f8	 mov	 DWORD PTR __N$1$[ebp], ecx
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_memcpy_s.h

; 46   :         if (_SourceSize == 0)

  00122	85 c9		 test	 ecx, ecx
  00124	74 78		 je	 SHORT $LN74@SetSize

; 47   :         {
; 48   :             return 0;
; 49   :         }
; 50   : 
; 51   :         _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Destination != NULL, EINVAL);

  00126	85 d2		 test	 edx, edx
  00128	75 5c		 jne	 SHORT $LN42@SetSize
$LN73@SetSize:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlchecked.h

; 69   : 	ATLMFC_CRT_ERRORCHECK(::memcpy_s(_S1, _S1max, _S2, _N));

  0012a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___errno
  00130	c7 00 16 00 00
	00		 mov	 DWORD PTR [eax], 22	; 00000016H
  00136	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo
$LN46@SetSize:
  0013c	b8 16 00 00 00	 mov	 eax, 22			; 00000016H
$LN40@SetSize:
  00141	50		 push	 eax
  00142	e8 00 00 00 00	 call	 ?AfxCrtErrorCheck@@YAHH@Z ; AfxCrtErrorCheck
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 462  : 		memset((void*)(pNewData + m_nSize), 0, (size_t)(nNewSize-m_nSize) * sizeof(TYPE));

  00147	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  0014a	8b c6		 mov	 eax, esi
  0014c	2b c1		 sub	 eax, ecx
  0014e	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00151	c1 e0 02	 shl	 eax, 2
  00154	50		 push	 eax
  00155	8d 04 49	 lea	 eax, DWORD PTR [ecx+ecx*2]
  00158	8b 4d fc	 mov	 ecx, DWORD PTR _pNewData$1$[ebp]
  0015b	6a 00		 push	 0
  0015d	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  00160	50		 push	 eax
  00161	e8 00 00 00 00	 call	 _memset

; 463  : 		for( int i = 0; i < nNewSize-m_nSize; i++ )
; 464  : #pragma push_macro("new")
; 465  : #undef new
; 466  : 			::new( (void*)( pNewData + m_nSize + i ) ) TYPE;
; 467  : #pragma pop_macro("new")
; 468  : 
; 469  : 		// get rid of old stuff (note: no destructors called)
; 470  : 		delete[] (BYTE*)m_pData;

  00166	ff 73 04	 push	 DWORD PTR [ebx+4]
  00169	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]

; 471  : 		m_pData = pNewData;

  0016e	8b 45 fc	 mov	 eax, DWORD PTR _pNewData$1$[ebp]
  00171	83 c4 14	 add	 esp, 20			; 00000014H

; 472  : 		m_nSize = nNewSize;
; 473  : 		m_nMaxSize = nNewMax;
; 474  : 	}
; 475  : }

  00174	89 7b 0c	 mov	 DWORD PTR [ebx+12], edi
  00177	89 73 08	 mov	 DWORD PTR [ebx+8], esi
  0017a	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  0017d	5f		 pop	 edi
  0017e	5e		 pop	 esi
  0017f	5b		 pop	 ebx
  00180	8b e5		 mov	 esp, ebp
  00182	5d		 pop	 ebp
  00183	c2 08 00	 ret	 8
$LN42@SetSize:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_memcpy_s.h

; 52   :         if (_Source == NULL || _DestinationSize < _SourceSize)

  00186	85 c0		 test	 eax, eax
  00188	8b 45 08	 mov	 eax, DWORD PTR __S1max$1$[ebp]
  0018b	74 15		 je	 SHORT $LN44@SetSize
  0018d	3b c1		 cmp	 eax, ecx
  0018f	72 11		 jb	 SHORT $LN44@SetSize

; 58   : 
; 59   :             // Unreachable, but required to suppress /analyze warnings:
; 60   :             return EINVAL;
; 61   :         }
; 62   :         memcpy(_Destination, _Source, _SourceSize);

  00191	51		 push	 ecx
  00192	ff 75 0c	 push	 DWORD PTR __S2$1$[ebp]
  00195	52		 push	 edx
  00196	e8 00 00 00 00	 call	 _memcpy
  0019b	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN74@SetSize:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlchecked.h

; 69   : 	ATLMFC_CRT_ERRORCHECK(::memcpy_s(_S1, _S1max, _S2, _N));

  0019e	33 c0		 xor	 eax, eax
  001a0	eb 9f		 jmp	 SHORT $LN40@SetSize
$LN44@SetSize:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_memcpy_s.h

; 54   :             memset(_Destination, 0, _DestinationSize);

  001a2	50		 push	 eax
  001a3	6a 00		 push	 0
  001a5	52		 push	 edx
  001a6	e8 00 00 00 00	 call	 _memset
  001ab	83 c4 0c	 add	 esp, 12			; 0000000cH

; 55   : 
; 56   :             _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Source != NULL,                 EINVAL);

  001ae	83 7d 0c 00	 cmp	 DWORD PTR __S2$1$[ebp], 0
  001b2	0f 84 72 ff ff
	ff		 je	 $LN73@SetSize

; 57   :             _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_DestinationSize >= _SourceSize, ERANGE);

  001b8	8b 45 f8	 mov	 eax, DWORD PTR __N$1$[ebp]
  001bb	39 45 08	 cmp	 DWORD PTR __S1max$1$[ebp], eax
  001be	0f 83 78 ff ff
	ff		 jae	 $LN46@SetSize
  001c4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___errno
  001ca	c7 00 22 00 00
	00		 mov	 DWORD PTR [eax], 34	; 00000022H
  001d0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo
  001d6	b8 22 00 00 00	 mov	 eax, 34			; 00000022H
  001db	e9 61 ff ff ff	 jmp	 $LN40@SetSize
$LN70@SetSize:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 449  : 			AfxThrowInvalidArgException();

  001e0	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN72@SetSize:
  001e5	cc		 int	 3
?SetSize@?$CArray@UST_RUNVALUE@@U1@@@QAEXHH@Z ENDP	; CArray<ST_RUNVALUE,ST_RUNVALUE>::SetSize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ??0?$CArray@UST_RUNVALUE@@U1@@@QAE@XZ
_TEXT	SEGMENT
??0?$CArray@UST_RUNVALUE@@U1@@@QAE@XZ PROC		; CArray<ST_RUNVALUE,ST_RUNVALUE>::CArray<ST_RUNVALUE,ST_RUNVALUE>, COMDAT
; _this$ = ecx

; 348  : {

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CArray@UST_RUNVALUE@@U1@@@6B@

; 349  : 	m_pData = NULL;
; 350  : 	m_nSize = m_nMaxSize = m_nGrowBy = 0;
; 351  : }

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  00016	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0
  0001d	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00024	c3		 ret	 0
??0?$CArray@UST_RUNVALUE@@U1@@@QAE@XZ ENDP		; CArray<ST_RUNVALUE,ST_RUNVALUE>::CArray<ST_RUNVALUE,ST_RUNVALUE>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
;	COMDAT ?SpreadGridData@CDlgOptimizer@@QAEXXZ
_TEXT	SEGMENT
?SpreadGridData@CDlgOptimizer@@QAEXXZ PROC		; CDlgOptimizer::SpreadGridData, COMDAT
; _this$ = ecx

; 1420 : 
; 1421 : //	ST_GRIDVALUEDATA GridData;
; 1422 : //	ST_STRGRIDDATA  strGridData;
; 1423 : //	CString str;
; 1424 : //	int nSize =m_ArGridData.GetSize();
; 1425 : //	if(nSize == 0) return;
; 1426 : //	//m_GridStatus.SetRowCount(nSize+1);
; 1427 : /////////  ////////////////////////////
; 1428 : ////   . 
; 1429 : //	GridData = m_ArGridData.GetAt(nSize/2);
; 1430 : //	strGridData = m_ArstrGridData.GetAt(nSize/2);
; 1431 : //	str.Format("%d",nSize/2);
; 1432 : //	m_GridTap.SetItemText(1,0, str);
; 1433 : //	m_GridTap.SetItemText(1,1, strGridData.Byunsu);
; 1434 : //	m_GridTap.SetItemText(1,2, GridData.RateCurrent);
; 1435 : //	m_GridTap.SetItemText(1,3, GridData.LossSavg);
; 1436 : //	m_GridTap.SetItemText(1,4, GridData.ProfitAll);
; 1437 : //	m_GridTap.SetItemText(1,5, GridData.LossAll);
; 1438 : //	m_GridTap.SetItemText(1,6, GridData.MaxProfit);
; 1439 : //	m_GridTap.SetItemText(1,7, GridData.MaxLoss);
; 1440 : //	m_GridTap.SetItemText(1,8, GridData.RateAccm);
; 1441 : //	m_GridTap.SetItemText(1,9, GridData.ProfitFactor);
; 1442 : //	m_GridTap.SetItemText(1,10,GridData.RateProfitLoss);
; 1443 : //	m_GridTap.SetItemText(1,11,GridData.CntAll);
; 1444 : //	
; 1445 : //	
; 1446 : //	int dd = m_ArstrGridData.GetSize();
; 1447 : ///////  ////////////////////////////////
; 1448 : 	/*for(int i = 0; i<nSize;i++)
; 1449 : 	{
; 1450 : 		GridData = m_ArGridData.GetAt(i);
; 1451 : 	
; 1452 : 		str.Format("%d",i);
; 1453 : 		strGridData = m_ArstrGridData.GetAt(i);
; 1454 : 		m_GridStatus.SetItemText(i+1,0, str);
; 1455 : 		m_GridStatus.SetItemText(i+1,1, strGridData.Byunsu);
; 1456 : 		m_GridStatus.SetItemText(i+1,2, GridData.RateCurrent);
; 1457 : 		m_GridStatus.SetItemText(i+1,3, GridData.LossSavg);
; 1458 : 		m_GridStatus.SetItemText(i+1,4, GridData.ProfitAll);
; 1459 : 		m_GridStatus.SetItemText(i+1,5, GridData.LossAll);
; 1460 : 		m_GridStatus.SetItemText(i+1,6, GridData.MaxProfit);
; 1461 : 		m_GridStatus.SetItemText(i+1,7, GridData.MaxLoss);
; 1462 : 		m_GridStatus.SetItemText(i+1,8, GridData.RateAccm);
; 1463 : 		m_GridStatus.SetItemText(i+1,9, GridData.ProfitFactor);
; 1464 : 		m_GridStatus.SetItemText(i+1,10,GridData.RateProfitLoss);
; 1465 : 		m_GridStatus.SetItemText(i+1,11,GridData.CntAll);
; 1466 : 	}
; 1467 : 
; 1468 : 	m_GridStatus.SortTextItems(2,TRUE);*/
; 1469 : 	m_GridTap.Refresh();

  00000	81 c1 f0 09 00
	00		 add	 ecx, 2544		; 000009f0H
  00006	e9 00 00 00 00	 jmp	 ?Refresh@CGridCtrl@@QAEXXZ ; CGridCtrl::Refresh
?SpreadGridData@CDlgOptimizer@@QAEXXZ ENDP		; CDlgOptimizer::SpreadGridData
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
;	COMDAT ?IsNumber@CDlgOptimizer@@QAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_str$ = 8						; size = 4
_nIndex$ = 12						; size = 4
?IsNumber@CDlgOptimizer@@QAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z PROC ; CDlgOptimizer::IsNumber, COMDAT
; _this$ = ecx

; 1408 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?IsNumber@CDlgOptimizer@@QAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 1409 : 	BOOL bNumber;
; 1410 : 	TCHAR c = str.GetAt(nIndex);

  00023	ff 75 0c	 push	 DWORD PTR _nIndex$[ebp]
  00026	8d 4d 08	 lea	 ecx, DWORD PTR _str$[ebp]
  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00030	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetAt@?$CSimpleStringT@D$00@ATL@@QBEDH@Z

; 1411 : 	if(c>='0' && c<='9')

  00036	2c 30		 sub	 al, 48			; 00000030H

; 1412 : 		bNumber = TRUE;
; 1413 : 	else
; 1414 : 		bNumber = FALSE;
; 1415 : 	return bNumber;

  00038	b1 09		 mov	 cl, 9
  0003a	3a c8		 cmp	 cl, al
  0003c	8d 4d 08	 lea	 ecx, DWORD PTR _str$[ebp]
  0003f	1b f6		 sbb	 esi, esi
  00041	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00047	8d 46 01	 lea	 eax, DWORD PTR [esi+1]

; 1416 : }

  0004a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00054	59		 pop	 ecx
  00055	5e		 pop	 esi
  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?IsNumber@CDlgOptimizer@@QAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z$0:
  00000	8d 4d 08	 lea	 ecx, DWORD PTR _str$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
  0000d	cc		 int	 3
__ehhandler$?IsNumber@CDlgOptimizer@@QAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z:
  0000e	90		 npad	 1
  0000f	90		 npad	 1
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?IsNumber@CDlgOptimizer@@QAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z
  00026	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?IsNumber@CDlgOptimizer@@QAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z ENDP ; CDlgOptimizer::IsNumber
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
;	COMDAT ?IsCurrentChartData@CDlgOptimizer@@QAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
_TEXT	SEGMENT
_strValue$ = 8						; size = 4
?IsCurrentChartData@CDlgOptimizer@@QAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z PROC ; CDlgOptimizer::IsCurrentChartData, COMDAT
; _this$ = ecx

; 797  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 798  : 	//int nMin;
; 799  : 	//if(m_nGijun == G_MINUTE)//  
; 800  : 	//{
; 801  : 	//	m_CtlEditGijun.GetWindowText(m_strGijun);
; 802  : 	//	
; 803  : 	//	nMin = atoi(m_strGijun);
; 804  : 	//	if(nMin<0 || nMin>61)
; 805  : 	//	{
; 806  : 	//		AfxMessageBox(" 1 ~ 60  ");
; 807  : 	//		m_CtlEditGijun.SetFocus();
; 808  : 	//		return FALSE;
; 809  : 	//	}
; 810  : 	//	m_strGijun +="";
; 811  : 	//}
; 812  : 	//else 
; 813  : 	//	m_strGijun = "";
; 814  : 
; 815  : 	//nMin = atoi(strValue);
; 816  : 	//if(nMin<0||nMin>1001)
; 817  : 	//{
; 818  : 	//	AfxMessageBox(" 1 ~ 1000   ");
; 819  : 	//	m_CtlEditBong.SetFocus();
; 820  : 	//	return FALSE;
; 821  : 	//}	
; 822  : 
; 823  : 	return TRUE;

  00003	8d 4d 08	 lea	 ecx, DWORD PTR _strValue$[ebp]
  00006	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0000c	b8 01 00 00 00	 mov	 eax, 1

; 824  : }

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?IsCurrentChartData@CDlgOptimizer@@QAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ENDP ; CDlgOptimizer::IsCurrentChartData
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
;	COMDAT ?GetJMNameAndGubunFromCode@CDlgOptimizer@@QAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V23@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_csCode$ = 12						; size = 4
?GetJMNameAndGubunFromCode@CDlgOptimizer@@QAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V23@@Z PROC ; CDlgOptimizer::GetJMNameAndGubunFromCode, COMDAT
; _this$ = ecx

; 392  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?GetJMNameAndGubunFromCode@CDlgOptimizer@@QAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V23@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 393  : 	return "";

  00022	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00025	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@@
  0002a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00031	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  00037	8d 4d 0c	 lea	 ecx, DWORD PTR _csCode$[ebp]
  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00040	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 394  : }

  00043	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00046	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0004d	59		 pop	 ecx
  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetJMNameAndGubunFromCode@CDlgOptimizer@@QAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V23@@Z$0:
  00000	8d 4d 0c	 lea	 ecx, DWORD PTR _csCode$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
  0000d	cc		 int	 3
__ehhandler$?GetJMNameAndGubunFromCode@CDlgOptimizer@@QAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V23@@Z:
  0000e	90		 npad	 1
  0000f	90		 npad	 1
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?GetJMNameAndGubunFromCode@CDlgOptimizer@@QAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V23@@Z
  00026	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?GetJMNameAndGubunFromCode@CDlgOptimizer@@QAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V23@@Z ENDP ; CDlgOptimizer::GetJMNameAndGubunFromCode
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
;	COMDAT ?CalculateSendData@CDlgOptimizer@@QAEHXZ
_TEXT	SEGMENT
?CalculateSendData@CDlgOptimizer@@QAEHXZ PROC		; CDlgOptimizer::CalculateSendData, COMDAT
; _this$ = ecx

; 1229 : 	// 
; 1230 : //	CString Data,strD;
; 1231 : //	m_strArSendData.RemoveAll();
; 1232 : //	for(int k=0;k<m_strNum.GetSize();k++)
; 1233 : //	{
; 1234 : //		m_arrayValue.GetAt(k)->stEdit->GetWindowText(strD);
; 1235 : //		CString st;
; 1236 : //		st.Format("%s%d=%s,",INPUTVALUE, k, strD);
; 1237 : //		Data+=st;
; 1238 : //	}
; 1239 : //	Data.Delete(Data.GetLength()-1);
; 1240 : //	m_strArSendData.Add(Data);
; 1241 : //	return TRUE;
; 1242 : 
; 1243 : //	CStringArray NowValue;
; 1244 : //	CString SendValue;
; 1245 : //	int nValue = 1;
; 1246 : //	int nRow=0;
; 1247 : //	int MaxData = 0;
; 1248 : //	int MaxDataIndex = 0;
; 1249 : //	m_ArGridData.RemoveAll();
; 1250 : ////	m_strArSendData.RemoveAll();
; 1251 : //	m_ArstrGridData.RemoveAll();
; 1252 : //	m_ArRunvalue.RemoveAll();
; 1253 : //	//m_strNum   !!!
; 1254 : //	for(int i=0;i<m_strNum.GetSize();i++)
; 1255 : //	{
; 1256 : //		ST_RUNVALUESET ValueSet;
; 1257 : //		m_arrayValue.GetAt(i)->stEdit->GetWindowText(SendValue);
; 1258 : //		//Add ... SendValue   0  .			
; 1259 : //		if(IsNumber(SendValue,0))
; 1260 : //		{
; 1261 : //			if(MaxData == 0) MaxDataIndex =i; //MaxData row    .
; 1262 : //			int nValue = atoi(SendValue);//
; 1263 : //			ValueSet.start = 1;
; 1264 : //			ValueSet.end = nValue*2;
; 1265 : //			ValueSet.bNumber = TRUE;
; 1266 : //			NowValue.Add("1");
; 1267 : //			MaxData++;
; 1268 : //		}
; 1269 : //		else
; 1270 : //		{
; 1271 : //			ValueSet.start = ValueSet.end = 0;
; 1272 : //			ValueSet.bNumber = FALSE;
; 1273 : //			NowValue.Add(SendValue);
; 1274 : //		}
; 1275 : //		m_ArRunvalue.Add(ValueSet);
; 1276 : //	}
; 1277 : //
; 1278 : //	ST_RUNVALUESET ValueSet;
; 1279 : //	nRow =NowValue.GetSize()-1;
; 1280 : //	if(nRow<0) return FALSE;
; 1281 : //	ValueSet = m_ArRunvalue.GetAt(nRow);
; 1282 : //	int prevData;
; 1283 : //	//  
; 1284 : //	for(;;)
; 1285 : //	{
; 1286 : //		SendValue ="";
; 1287 : //		ValueSet = m_ArRunvalue.GetAt(nRow);
; 1288 : //		
; 1289 : //		if(ValueSet.end <=nValue ||ValueSet.bNumber!=TRUE)
; 1290 : //		{
; 1291 : //			int UpValue;
; 1292 : //			--nRow;
; 1293 : //
; 1294 : //			if(nRow<0) break;
; 1295 : //			
; 1296 : //			SendValue = NowValue.GetAt(nRow);
; 1297 : //			if(IsNumber(SendValue,0))
; 1298 : //				UpValue = atoi(NowValue.GetAt(nRow));
; 1299 : //			else
; 1300 : //				continue;
; 1301 : //
; 1302 : //			ValueSet = m_ArRunvalue.GetAt(nRow);
; 1303 : //			++UpValue;
; 1304 : //			if(ValueSet.end <= UpValue) continue;
; 1305 : //			
; 1306 : //			for(int l=nRow+1; l < NowValue.GetSize();l++)
; 1307 : //			{
; 1308 : //				SendValue = NowValue.GetAt(l);
; 1309 : //				if(IsNumber(SendValue,0))
; 1310 : //					NowValue.SetAt(l,"1");//1..
; 1311 : //				else
; 1312 : //					continue;
; 1313 : //			}
; 1314 : //			SendValue.Format("%d",UpValue);
; 1315 : //			NowValue.SetAt(nRow,SendValue);
; 1316 : //			nRow = NowValue.GetSize()-1;
; 1317 : //			nValue = 1;
; 1318 : //		}
; 1319 : //		else
; 1320 : //		{
; 1321 : //			// String ....
; 1322 : //			//strAdditionalItem.Format("%s%d=%s",INPUTVALUE(),
; 1323 : //			//nIndexAdditional(),strPacketName()); m_strArSendArray ..
; 1324 : //			prevData = nValue;
; 1325 : //			CString strAdditionalItem, strByun;
; 1326 : //			SendValue.Format("%d",nValue);
; 1327 : //			if(nRow== MaxDataIndex) break;//   .
; 1328 : //			NowValue.SetAt(nRow,SendValue);
; 1329 : //			for(int j=0;j<NowValue.GetSize();j++)
; 1330 : //			{
; 1331 : //				CString str;
; 1332 : //				str = NowValue.GetAt(j);
; 1333 : //
; 1334 : //			//	if(IsNumber(str,0))
; 1335 : //			//	{
; 1336 : //					str.Format("%s%d=%s,",INPUTVALUE, j, str);
; 1337 : //					strAdditionalItem+=str;
; 1338 : //			//	}
; 1339 : //					str = NowValue.GetAt(j);
; 1340 : //				if(IsNumber(str,0)){
; 1341 : //				str.Format(" [%s]",str);
; 1342 : //				strByun+=str;
; 1343 : //				}
; 1344 : //
; 1345 : //			}
; 1346 : //			strAdditionalItem.Delete(strAdditionalItem.GetLength()-1);
; 1347 : //		//	AfxMessageBox(strAdditionalItem);
; 1348 : //			ST_STRGRIDDATA strData;
; 1349 : //			strData.strGridData = strAdditionalItem;
; 1350 : //			strData.Byunsu = strByun;
; 1351 : //			m_ArstrGridData.Add(strData);
; 1352 : //		//	m_strArSendData.Add(strAdditionalItem);
; 1353 : //			++nValue;
; 1354 : //		
; 1355 : //		}
; 1356 : //	}
; 1357 : //	//Progress Init
; 1358 : //	m_CtlProgress.SetRange(0,m_ArstrGridData.GetSize());
; 1359 : 	return TRUE;

  00000	b8 01 00 00 00	 mov	 eax, 1

; 1360 : }

  00005	c3		 ret	 0
?CalculateSendData@CDlgOptimizer@@QAEHXZ ENDP		; CDlgOptimizer::CalculateSendData
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
;	COMDAT ?InitStrategy@CDlgOptimizer@@QAEXXZ
_TEXT	SEGMENT
?InitStrategy@CDlgOptimizer@@QAEXXZ PROC		; CDlgOptimizer::InitStrategy, COMDAT
; _this$ = ecx

; 336  : //
; 337  : //#ifdef _DEBUG
; 338  : // CString strSystemPath = m_strRootPath +  "\\" + STSYSTEM_D;
; 339  : // CString strUserPath = m_strRootPath + "\\" + STUSER_D;
; 340  : //#else
; 341  : // CString strSystemPath = m_strRootPath + "\\" + STSYSTEM;
; 342  : // CString strUserPath = m_strRootPath + "\\" + STUSER;
; 343  : //#endif
; 344  : //	m_stArrayPath.RemoveAll(); 
; 345  : //	m_stArrayPath.Add(strSystemPath);
; 346  : //	m_stArrayPath.Add(strUserPath);
; 347  : //
; 348  : //	if(!m_pStrategyItem)
; 349  : //	{
; 350  : //		m_pStrategyItem = m_strategyLoader.GetStrategyItem();//   
; 351  : //		if(m_pStrategyItem == NULL) return;
; 352  : //		//, DBMGr,   
; 353  : //	//	int nRetValue = m_pStrategyItem->Create(this,m_hSocket,(long)&m_IDrMLib_CDBMgr,(long)m_pStrategyItem,m_stArrayPath);
; 354  : //	//	if(nRetValue==-1) 
; 355  : //		{
; 356  : //			m_pStrategyItem->DestoryWindow();
; 357  : //			delete m_pStrategyItem;
; 358  : //			m_pStrategyItem = NULL;
; 359  : //		}
; 360  : //	}
; 361  : //	m_DlgTrade->SetStrategyItem(m_pStrategyItem);
; 362  : }

  00000	c2 00 00	 ret	 0
?InitStrategy@CDlgOptimizer@@QAEXXZ ENDP		; CDlgOptimizer::InitStrategy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
;	COMDAT ?StartOpt@CDlgOptimizer@@QAEXXZ
_TEXT	SEGMENT
_inData$ = -4						; size = 4
?StartOpt@CDlgOptimizer@@QAEXXZ PROC			; CDlgOptimizer::StartOpt, COMDAT
; _this$ = ecx

; 861  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 862  : 	STOPTTHREAD inData;
; 863  : 	inData.pThisPoint = (long)this;
; 864  : 
; 865  : 	AfxBeginThread(StartOptThread, &inData);

  00004	6a 00		 push	 0
  00006	6a 00		 push	 0
  00008	6a 00		 push	 0
  0000a	6a 00		 push	 0
  0000c	8d 45 fc	 lea	 eax, DWORD PTR _inData$[ebp]
  0000f	89 4d fc	 mov	 DWORD PTR _inData$[ebp], ecx
  00012	50		 push	 eax
  00013	68 00 00 00 00	 push	 OFFSET ?StartOptThread@@YAIPAX@Z ; StartOptThread
  00018	e8 00 00 00 00	 call	 ?AfxBeginThread@@YGPAVCWinThread@@P6AIPAX@Z0HIKPAU_SECURITY_ATTRIBUTES@@@Z ; AfxBeginThread

; 866  : }

  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
?StartOpt@CDlgOptimizer@@QAEXXZ ENDP			; CDlgOptimizer::StartOpt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
;	COMDAT ?RemoveAllControlSet@CDlgOptimizer@@QAEXXZ
_TEXT	SEGMENT
?RemoveAllControlSet@CDlgOptimizer@@QAEXXZ PROC		; CDlgOptimizer::RemoveAllControlSet, COMDAT
; _this$ = ecx

; 828  : 	/*ST_VALUESET *ValueSet;
; 829  : 	for(int j =0; j< m_arrayValue.GetSize();j++)
; 830  : 	{
; 831  : 		ValueSet = m_arrayValue.GetAt(j);
; 832  : 		ValueSet->stEdit->ShowWindow(SW_HIDE);
; 833  : 		ValueSet->stSpinBtn->ShowWindow(SW_HIDE);
; 834  : 		ValueSet->stStatic->ShowWindow(SW_HIDE);
; 835  : 		
; 836  : 		ValueSet->stEdit->SetWindowText("0");
; 837  : 		ValueSet->stEdit->SetReadOnly(FALSE);
; 838  : 		ValueSet->stEdit->MoveWindow(ValueSet->rt);
; 839  : 		
; 840  : 		ValueSet->stSpinBtn->EnableWindow(TRUE);
; 841  : 		
; 842  : 	}*/
; 843  : }

  00000	c2 00 00	 ret	 0
?RemoveAllControlSet@CDlgOptimizer@@QAEXXZ ENDP		; CDlgOptimizer::RemoveAllControlSet
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
;	COMDAT ?InitControls@CDlgOptimizer@@QAEXXZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
?InitControls@CDlgOptimizer@@QAEXXZ PROC		; CDlgOptimizer::InitControls, COMDAT
; _this$ = ecx

; 647  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?InitControls@CDlgOptimizer@@QAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 648  : 	//Init  Index //
; 649  : 	return;
; 650  : 	CStdioFile IndexFile;
; 651  : 	CString strIndexData,str;
; 652  : 	if(!IndexFile.Open(m_strDataDir+"\\SystemTradingIndexList.dat",CFile::modeRead))
; 653  : 	{
; 654  : 		AfxMessageBox("Do Not Create Html File.");
; 655  : 		return;
; 656  : 	}
; 657  : //     
; 658  : 	char str1[265];
; 659  : 	char* p ;
; 660  : 	CStringArray RemoveData;
; 661  : 	::GetPrivateProfileString("REMOVE","DATA","No",str1,80,m_strDataDir+FILE_OPTIMIZE_CFG);
; 662  : 	 p = strtok(str1,",");
; 663  : 	while(p!=NULL)
; 664  : 	{
; 665  : 		RemoveData.Add(p);
; 666  : 		p = strtok(NULL,",");		
; 667  : 	}
; 668  : ////////////////////////////////////////////
; 669  : 	for(;;){
; 670  : 		if(IndexFile.ReadString(str))
; 671  : 		{
; 672  : 			// Combo Init 
; 673  : 			int start = str.Find(";",0);
; 674  : 			strIndexData = str.Left(start);
; 675  : 			BOOL IsData = TRUE;
; 676  : 			for(int i=0;i<RemoveData.GetSize();i++)
; 677  : 			{
; 678  : 				if(RemoveData.GetAt(i)==strIndexData)
; 679  : 				{
; 680  : 					RemoveData.RemoveAt(i);
; 681  : 					IsData = FALSE;
; 682  : 					break;
; 683  : 				}
; 684  : 			}
; 685  : 			if(IsData == FALSE) continue;
; 686  : 	//		m_CtlComIndex.AddString(strIndexData);
; 687  : 
; 688  : 			str.Delete(0,start+1);
; 689  : 
; 690  : 			//SD   
; 691  : 			start = str.Find(";",0);
; 692  : 			strIndexData = str.Left(start);	
; 693  : 			m_stArraySDFileName.Add(strIndexData);
; 694  : 			str ="";
; 695  : 		}
; 696  : 		else
; 697  : 			break;
; 698  : 	}	
; 699  : 	IndexFile.Close();
; 700  : 
; 701  : 
; 702  :     
; 703  : }

  00022	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00025	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0002c	59		 pop	 ecx
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
  00031	cc		 int	 3
  00032	cc		 int	 3
  00033	cc		 int	 3
  00034	cc		 int	 3
  00035	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?InitControls@CDlgOptimizer@@QAEXXZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?InitControls@CDlgOptimizer@@QAEXXZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?InitControls@CDlgOptimizer@@QAEXXZ ENDP		; CDlgOptimizer::InitControls
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
;	COMDAT ?InitTab@CDlgOptimizer@@QAEXXZ
_TEXT	SEGMENT
_newElement$1$ = -36					; size = 4
_newElement$1$ = -36					; size = 4
_newElement$1$ = -36					; size = 4
_newElement$1$ = -36					; size = 4
$T2 = -36						; size = 4
$T3 = -36						; size = 4
$T4 = -36						; size = 4
$T5 = -36						; size = 4
_rc$ = -32						; size = 16
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?InitTab@CDlgOptimizer@@QAEXXZ PROC			; CDlgOptimizer::InitTab, COMDAT
; _this$ = ecx

; 544  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?InitTab@CDlgOptimizer@@QAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 18	 sub	 esp, 24			; 00000018H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b f1		 mov	 esi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl

; 86   : 	{ ASSERT(::IsWindow(m_hWnd)); ::GetClientRect(m_hWnd, lpRect); }

  0002d	8d 45 e0	 lea	 eax, DWORD PTR _rc$[ebp]
  00030	0f 57 c0	 xorps	 xmm0, xmm0
  00033	50		 push	 eax
  00034	ff b6 28 04 00
	00		 push	 DWORD PTR [esi+1064]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h

; 528  : 	left = 0;

  0003a	0f 11 45 e0	 movups	 XMMWORD PTR _rc$[ebp], xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl

; 86   : 	{ ASSERT(::IsWindow(m_hWnd)); ::GetClientRect(m_hWnd, lpRect); }

  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetClientRect@8
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 549  : 	m_strDataDir += "\\STData";

  00044	8d be 48 05 00
	00		 lea	 edi, DWORD PTR [esi+1352]
  0004a	c7 45 e0 c1 00
	00 00		 mov	 DWORD PTR _rc$[ebp], 193 ; 000000c1H
  00051	68 00 00 00 00	 push	 OFFSET ??_C@_07BMIBILFB@?2STData@
  00056	8b cf		 mov	 ecx, edi
  00058	c7 45 e4 c3 00
	00 00		 mov	 DWORD PTR _rc$[ebp+4], 195 ; 000000c3H
  0005f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z

; 550  : 	m_CtlTab.SetTopLeftCorner(CPoint(rc.left,rc.top));

  00065	ff 75 e4	 push	 DWORD PTR _rc$[ebp+4]
  00068	8d 8e 08 04 00
	00		 lea	 ecx, DWORD PTR [esi+1032]
  0006e	ff 75 e0	 push	 DWORD PTR _rc$[ebp]
  00071	e8 00 00 00 00	 call	 ?SetTopLeftCorner@CXTabCtrl@@QAEXVCPoint@@@Z ; CXTabCtrl::SetTopLeftCorner

; 551  : 	m_CtlTab.SetLeftOffset(0);
; 552  : 	m_CtlTab.SetUpperOffset(0);
; 553  : 	m_CtlTab.SetSelectedColor(RGB(0, 0, 0),CRBACKGROUND);

  00076	68 d3 df f1 00	 push	 15851475		; 00f1dfd3H
  0007b	6a 00		 push	 0
  0007d	8d 8e 08 04 00
	00		 lea	 ecx, DWORD PTR [esi+1032]
  00083	c7 86 08 05 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+1288], 0
  0008d	c7 86 04 05 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+1284], 0
  00097	e8 00 00 00 00	 call	 ?SetSelectedColor@CXTabCtrl@@QAEXKK@Z ; CXTabCtrl::SetSelectedColor

; 554  : 	m_CtlTab.SetNormalColor(RGB(0,0,0), RGB(255,255,255) , RGB(226,225,233));

  0009c	68 e2 e1 e9 00	 push	 15327714		; 00e9e1e2H
  000a1	68 ff ff ff 00	 push	 16777215		; 00ffffffH
  000a6	6a 00		 push	 0
  000a8	8d 8e 08 04 00
	00		 lea	 ecx, DWORD PTR [esi+1032]
  000ae	e8 00 00 00 00	 call	 ?SetNormalColor@CXTabCtrl@@QAEXKKK@Z ; CXTabCtrl::SetNormalColor
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 116  : 	{ return ::operator new(nSize); }

  000b3	68 58 05 00 00	 push	 1368			; 00000558H
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 555  : 	m_CtlTab.SetTabBkColor(RGB(234,235,233));

  000b8	c7 86 c8 04 00
	00 ea eb e9 00	 mov	 DWORD PTR [esi+1224], 15330282 ; 00e9ebeaH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 116  : 	{ return ::operator new(nSize); }

  000c2	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000c7	83 c4 04	 add	 esp, 4
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 557  : 	m_DlgResult = new CDlgResult;

  000ca	89 45 dc	 mov	 DWORD PTR $T5[ebp], eax
  000cd	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  000d4	85 c0		 test	 eax, eax
  000d6	74 0b		 je	 SHORT $LN3@InitTab
  000d8	6a 00		 push	 0
  000da	8b c8		 mov	 ecx, eax
  000dc	e8 00 00 00 00	 call	 ??0CDlgResult@@QAE@PAVCWnd@@@Z ; CDlgResult::CDlgResult
  000e1	eb 02		 jmp	 SHORT $LN4@InitTab
$LN3@InitTab:
  000e3	33 c0		 xor	 eax, eax
$LN4@InitTab:
  000e5	89 86 80 0e 00
	00		 mov	 DWORD PTR [esi+3712], eax

; 558  : 	m_DlgResult->SetGridFont(&m_Font);

  000eb	8d 8e f0 12 00
	00		 lea	 ecx, DWORD PTR [esi+4848]
  000f1	89 88 50 05 00
	00		 mov	 DWORD PTR [eax+1360], ecx

; 559  : 	m_DlgResult->Create(CDlgResult::IDD, this);

  000f7	8b 8e 80 0e 00
	00		 mov	 ecx, DWORD PTR [esi+3712]
  000fd	56		 push	 esi
  000fe	68 c8 32 00 00	 push	 13000			; 000032c8H
  00103	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0010a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0010c	ff 90 6c 01 00
	00		 call	 DWORD PTR [eax+364]

; 560  : 	m_DlgResult->SetOptimizer(this);

  00112	8b 8e 80 0e 00
	00		 mov	 ecx, DWORD PTR [esi+3712]
  00118	56		 push	 esi
  00119	e8 00 00 00 00	 call	 ?SetOptimizer@CDlgResult@@QAEXPAVCDlgOptimizer@@@Z ; CDlgResult::SetOptimizer

; 561  : 	m_DlgResult->SetDataDir(m_strDataDir);

  0011e	51		 push	 ecx
  0011f	8b cc		 mov	 ecx, esp
  00121	57		 push	 edi
  00122	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z
  00128	8b 8e 80 0e 00
	00		 mov	 ecx, DWORD PTR [esi+3712]
  0012e	e8 00 00 00 00	 call	 ?SetDataDir@CDlgResult@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ; CDlgResult::SetDataDir

; 562  : 	m_DlgResult->OpenWebView("\\IndexOptimizer.htm"); 

  00133	51		 push	 ecx
  00134	8b cc		 mov	 ecx, esp
  00136	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@MFEGIDEI@?2IndexOptimizer?4htm@
  0013b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  00141	8b 8e 80 0e 00
	00		 mov	 ecx, DWORD PTR [esi+3712]
  00147	e8 00 00 00 00	 call	 ?OpenWebView@CDlgResult@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ; CDlgResult::OpenWebView
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 333  : 	{ INT_PTR nIndex = m_nSize;

  0014c	8b 9e 98 0e 00
	00		 mov	 ebx, DWORD PTR [esi+3736]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 564  : 	m_arrayTab.Add(m_DlgResult);

  00152	8d be 90 0e 00
	00		 lea	 edi, DWORD PTR [esi+3728]
  00158	8b 86 80 0e 00
	00		 mov	 eax, DWORD PTR [esi+3712]
  0015e	89 45 dc	 mov	 DWORD PTR _newElement$1$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 538  : 	if(nIndex < 0)

  00161	85 db		 test	 ebx, ebx
  00163	0f 88 47 02 00
	00		 js	 $LN62@InitTab

; 540  : 
; 541  : 	if (nIndex >= m_nSize)
; 542  : 		SetSize(nIndex+1, -1);

  00169	6a ff		 push	 -1
  0016b	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
  0016e	8b cf		 mov	 ecx, edi
  00170	50		 push	 eax
  00171	e8 00 00 00 00	 call	 ?SetSize@?$CArray@PAVCDialog@@PAV1@@@QAEXHH@Z ; CArray<CDialog *,CDialog *>::SetSize

; 543  : 	m_pData[nIndex] = newElement;

  00176	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00179	8b 4d dc	 mov	 ecx, DWORD PTR _newElement$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 116  : 	{ return ::operator new(nSize); }

  0017c	68 b0 02 00 00	 push	 688			; 000002b0H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 543  : 	m_pData[nIndex] = newElement;

  00181	89 0c 98	 mov	 DWORD PTR [eax+ebx*4], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 116  : 	{ return ::operator new(nSize); }

  00184	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00189	83 c4 04	 add	 esp, 4
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 567  : 	m_DlgSooik  = new CTabSoonikChart;

  0018c	89 45 dc	 mov	 DWORD PTR $T4[ebp], eax
  0018f	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00196	85 c0		 test	 eax, eax
  00198	74 0d		 je	 SHORT $LN5@InitTab
  0019a	6a 00		 push	 0
  0019c	8b c8		 mov	 ecx, eax
  0019e	e8 00 00 00 00	 call	 ??0CTabSoonikChart@@QAE@PAVCWnd@@@Z ; CTabSoonikChart::CTabSoonikChart
  001a3	8b c8		 mov	 ecx, eax
  001a5	eb 02		 jmp	 SHORT $LN6@InitTab
$LN5@InitTab:
  001a7	33 c9		 xor	 ecx, ecx
$LN6@InitTab:
  001a9	89 8e 84 0e 00
	00		 mov	 DWORD PTR [esi+3716], ecx

; 568  : 	m_DlgSooik->Create(CTabSoonikChart::IDD,this);

  001af	8b 01		 mov	 eax, DWORD PTR [ecx]
  001b1	56		 push	 esi
  001b2	68 ca 32 00 00	 push	 13002			; 000032caH
  001b7	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  001be	ff 90 6c 01 00
	00		 call	 DWORD PTR [eax+364]

; 569  : 	m_DlgSooik->SetParentDlg(this);

  001c4	8b 86 84 0e 00
	00		 mov	 eax, DWORD PTR [esi+3716]
  001ca	89 b0 ac 00 00
	00		 mov	 DWORD PTR [eax+172], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 333  : 	{ INT_PTR nIndex = m_nSize;

  001d0	8b 5f 08	 mov	 ebx, DWORD PTR [edi+8]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 570  : 	m_arrayTab.Add(m_DlgSooik);

  001d3	8b 86 84 0e 00
	00		 mov	 eax, DWORD PTR [esi+3716]
  001d9	89 45 dc	 mov	 DWORD PTR _newElement$1$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 538  : 	if(nIndex < 0)

  001dc	85 db		 test	 ebx, ebx
  001de	0f 88 cc 01 00
	00		 js	 $LN62@InitTab

; 540  : 
; 541  : 	if (nIndex >= m_nSize)
; 542  : 		SetSize(nIndex+1, -1);

  001e4	6a ff		 push	 -1
  001e6	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
  001e9	8b cf		 mov	 ecx, edi
  001eb	50		 push	 eax
  001ec	e8 00 00 00 00	 call	 ?SetSize@?$CArray@PAVCDialog@@PAV1@@@QAEXHH@Z ; CArray<CDialog *,CDialog *>::SetSize

; 543  : 	m_pData[nIndex] = newElement;

  001f1	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  001f4	8b 4d dc	 mov	 ecx, DWORD PTR _newElement$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 116  : 	{ return ::operator new(nSize); }

  001f7	68 50 03 00 00	 push	 848			; 00000350H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 543  : 	m_pData[nIndex] = newElement;

  001fc	89 0c 98	 mov	 DWORD PTR [eax+ebx*4], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 116  : 	{ return ::operator new(nSize); }

  001ff	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00204	83 c4 04	 add	 esp, 4
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 572  : 	m_DlgSonik  = new CTabSonikChart;

  00207	89 45 dc	 mov	 DWORD PTR $T3[ebp], eax
  0020a	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  00211	85 c0		 test	 eax, eax
  00213	74 0d		 je	 SHORT $LN7@InitTab
  00215	6a 00		 push	 0
  00217	8b c8		 mov	 ecx, eax
  00219	e8 00 00 00 00	 call	 ??0CTabSonikChart@@QAE@PAVCWnd@@@Z ; CTabSonikChart::CTabSonikChart
  0021e	8b c8		 mov	 ecx, eax
  00220	eb 02		 jmp	 SHORT $LN8@InitTab
$LN7@InitTab:
  00222	33 c9		 xor	 ecx, ecx
$LN8@InitTab:
  00224	89 8e 88 0e 00
	00		 mov	 DWORD PTR [esi+3720], ecx

; 573  : 	m_DlgSonik->Create(CTabSonikChart::IDD,this);

  0022a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0022c	56		 push	 esi
  0022d	68 ea 32 00 00	 push	 13034			; 000032eaH
  00232	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00239	ff 90 6c 01 00
	00		 call	 DWORD PTR [eax+364]

; 574  : 	m_DlgSonik->SetParentDlg(this);

  0023f	8b 86 88 0e 00
	00		 mov	 eax, DWORD PTR [esi+3720]
  00245	89 b0 ac 00 00
	00		 mov	 DWORD PTR [eax+172], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 333  : 	{ INT_PTR nIndex = m_nSize;

  0024b	8b 5f 08	 mov	 ebx, DWORD PTR [edi+8]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 575  : 	m_arrayTab.Add(m_DlgSonik);

  0024e	8b 86 88 0e 00
	00		 mov	 eax, DWORD PTR [esi+3720]
  00254	89 45 dc	 mov	 DWORD PTR _newElement$1$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 538  : 	if(nIndex < 0)

  00257	85 db		 test	 ebx, ebx
  00259	0f 88 51 01 00
	00		 js	 $LN62@InitTab

; 540  : 
; 541  : 	if (nIndex >= m_nSize)
; 542  : 		SetSize(nIndex+1, -1);

  0025f	6a ff		 push	 -1
  00261	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
  00264	8b cf		 mov	 ecx, edi
  00266	50		 push	 eax
  00267	e8 00 00 00 00	 call	 ?SetSize@?$CArray@PAVCDialog@@PAV1@@@QAEXHH@Z ; CArray<CDialog *,CDialog *>::SetSize

; 543  : 	m_pData[nIndex] = newElement;

  0026c	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0026f	8b 4d dc	 mov	 ecx, DWORD PTR _newElement$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 116  : 	{ return ::operator new(nSize); }

  00272	68 60 05 00 00	 push	 1376			; 00000560H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 543  : 	m_pData[nIndex] = newElement;

  00277	89 0c 98	 mov	 DWORD PTR [eax+ebx*4], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 116  : 	{ return ::operator new(nSize); }

  0027a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0027f	83 c4 04	 add	 esp, 4
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 577  : 	m_DlgTrade  = new CDlgTrade;

  00282	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax
  00285	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 3
  0028c	85 c0		 test	 eax, eax
  0028e	74 0b		 je	 SHORT $LN9@InitTab
  00290	6a 00		 push	 0
  00292	8b c8		 mov	 ecx, eax
  00294	e8 00 00 00 00	 call	 ??0CDlgTrade@@QAE@PAVCWnd@@@Z ; CDlgTrade::CDlgTrade
  00299	eb 02		 jmp	 SHORT $LN10@InitTab
$LN9@InitTab:
  0029b	33 c0		 xor	 eax, eax
$LN10@InitTab:
  0029d	89 86 8c 0e 00
	00		 mov	 DWORD PTR [esi+3724], eax

; 578  : 	m_DlgTrade->SetGridFont(&m_Font);

  002a3	8d 8e f0 12 00
	00		 lea	 ecx, DWORD PTR [esi+4848]
  002a9	89 88 58 05 00
	00		 mov	 DWORD PTR [eax+1368], ecx

; 579  : 	m_DlgTrade->Create(CDlgTrade::IDD,this);

  002af	8b 8e 8c 0e 00
	00		 mov	 ecx, DWORD PTR [esi+3724]
  002b5	56		 push	 esi
  002b6	68 c9 32 00 00	 push	 13001			; 000032c9H
  002bb	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  002c2	8b 01		 mov	 eax, DWORD PTR [ecx]
  002c4	ff 90 6c 01 00
	00		 call	 DWORD PTR [eax+364]

; 580  : 	m_DlgTrade->SetParentDlg(this);

  002ca	8b 86 8c 0e 00
	00		 mov	 eax, DWORD PTR [esi+3724]

; 581  : 	m_DlgTrade->SetDataDir(m_strDataDir);

  002d0	51		 push	 ecx
  002d1	8b cc		 mov	 ecx, esp
  002d3	89 b0 ac 00 00
	00		 mov	 DWORD PTR [eax+172], esi
  002d9	8d 86 48 05 00
	00		 lea	 eax, DWORD PTR [esi+1352]
  002df	50		 push	 eax
  002e0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z
  002e6	8b 8e 8c 0e 00
	00		 mov	 ecx, DWORD PTR [esi+3724]
  002ec	e8 00 00 00 00	 call	 ?SetDataDir@CDlgTrade@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ; CDlgTrade::SetDataDir

; 582  : 	m_DlgTrade->OpenWebView("\\IOTrade.htm");

  002f1	51		 push	 ecx
  002f2	8b cc		 mov	 ecx, esp
  002f4	68 00 00 00 00	 push	 OFFSET ??_C@_0N@NNCCFHAL@?2IOTrade?4htm@
  002f9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  002ff	8b 8e 8c 0e 00
	00		 mov	 ecx, DWORD PTR [esi+3724]
  00305	e8 00 00 00 00	 call	 ?OpenWebView@CDlgTrade@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ; CDlgTrade::OpenWebView
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 333  : 	{ INT_PTR nIndex = m_nSize;

  0030a	8b 5f 08	 mov	 ebx, DWORD PTR [edi+8]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 583  : 	m_arrayTab.Add(m_DlgTrade);

  0030d	8b 86 8c 0e 00
	00		 mov	 eax, DWORD PTR [esi+3724]
  00313	89 45 dc	 mov	 DWORD PTR _newElement$1$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 538  : 	if(nIndex < 0)

  00316	85 db		 test	 ebx, ebx
  00318	0f 88 92 00 00
	00		 js	 $LN62@InitTab

; 540  : 
; 541  : 	if (nIndex >= m_nSize)
; 542  : 		SetSize(nIndex+1, -1);

  0031e	6a ff		 push	 -1
  00320	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
  00323	8b cf		 mov	 ecx, edi
  00325	50		 push	 eax
  00326	e8 00 00 00 00	 call	 ?SetSize@?$CArray@PAVCDialog@@PAV1@@@QAEXHH@Z ; CArray<CDialog *,CDialog *>::SetSize

; 543  : 	m_pData[nIndex] = newElement;

  0032b	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0032e	8b 4d dc	 mov	 ecx, DWORD PTR _newElement$1$[ebp]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 585  : 	m_CtlTab.AddTab(m_DlgResult,"");

  00331	6a 00		 push	 0
  00333	68 00 00 00 00	 push	 OFFSET ??_C@_08OEAPFIFH@?$LM?$LK?$LA?z?$LK?P?$LM?$KO@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 543  : 	m_pData[nIndex] = newElement;

  00338	89 0c 98	 mov	 DWORD PTR [eax+ebx*4], ecx
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 585  : 	m_CtlTab.AddTab(m_DlgResult,"");

  0033b	8d 8e 08 04 00
	00		 lea	 ecx, DWORD PTR [esi+1032]
  00341	ff b6 80 0e 00
	00		 push	 DWORD PTR [esi+3712]
  00347	e8 00 00 00 00	 call	 ?AddTab@CXTabCtrl@@QAEXPAVCWnd@@PADH@Z ; CXTabCtrl::AddTab

; 586  : 	m_CtlTab.AddTab(m_DlgTrade,"");

  0034c	6a 00		 push	 0
  0034e	68 00 00 00 00	 push	 OFFSET ??_C@_08INENBIFG@?$LI?E?$LI?E?$LD?$LL?$LP?$KK@
  00353	ff b6 8c 0e 00
	00		 push	 DWORD PTR [esi+3724]
  00359	8d 8e 08 04 00
	00		 lea	 ecx, DWORD PTR [esi+1032]
  0035f	e8 00 00 00 00	 call	 ?AddTab@CXTabCtrl@@QAEXPAVCWnd@@PADH@Z ; CXTabCtrl::AddTab

; 587  : 	m_CtlTab.AddTab(m_DlgSooik,"");

  00364	6a 00		 push	 0
  00366	68 00 00 00 00	 push	 OFFSET ??_C@_0L@CPJPEJFL@?$LM?v?$MA?M?$LH?$PM?B?w?F?$KO@
  0036b	ff b6 84 0e 00
	00		 push	 DWORD PTR [esi+3716]
  00371	8d 8e 08 04 00
	00		 lea	 ecx, DWORD PTR [esi+1032]
  00377	e8 00 00 00 00	 call	 ?AddTab@CXTabCtrl@@QAEXPAVCWnd@@PADH@Z ; CXTabCtrl::AddTab

; 588  : 	m_CtlTab.AddTab(m_DlgSonik,"");

  0037c	6a 00		 push	 0
  0037e	68 00 00 00 00	 push	 OFFSET ??_C@_0N@HEBKHCBM@?$LM?U?$MA?M?$LK?P?F?w?B?w?F?$KO@
  00383	ff b6 88 0e 00
	00		 push	 DWORD PTR [esi+3720]
  00389	8d 8e 08 04 00
	00		 lea	 ecx, DWORD PTR [esi+1032]
  0038f	e8 00 00 00 00	 call	 ?AddTab@CXTabCtrl@@QAEXPAVCWnd@@PADH@Z ; CXTabCtrl::AddTab

; 589  : }

  00394	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00397	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0039e	59		 pop	 ecx
  0039f	5f		 pop	 edi
  003a0	5e		 pop	 esi
  003a1	5b		 pop	 ebx
  003a2	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003a5	33 cd		 xor	 ecx, ebp
  003a7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003ac	8b e5		 mov	 esp, ebp
  003ae	5d		 pop	 ebp
  003af	c3		 ret	 0
$LN62@InitTab:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 539  : 		AfxThrowInvalidArgException();

  003b0	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN64@InitTab:
  003b5	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?InitTab@CDlgOptimizer@@QAEXXZ$0:
  00000	8b 45 dc	 mov	 eax, DWORD PTR $T5[ebp]
  00003	50		 push	 eax
  00004	e8 00 00 00 00	 call	 ??3CObject@@SGXPAX@Z	; CObject::operator delete
  00009	c3		 ret	 0
__unwindfunclet$?InitTab@CDlgOptimizer@@QAEXXZ$3:
  0000a	8b 45 dc	 mov	 eax, DWORD PTR $T4[ebp]
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ??3CObject@@SGXPAX@Z	; CObject::operator delete
  00013	c3		 ret	 0
__unwindfunclet$?InitTab@CDlgOptimizer@@QAEXXZ$4:
  00014	8b 45 dc	 mov	 eax, DWORD PTR $T3[ebp]
  00017	50		 push	 eax
  00018	e8 00 00 00 00	 call	 ??3CObject@@SGXPAX@Z	; CObject::operator delete
  0001d	c3		 ret	 0
__unwindfunclet$?InitTab@CDlgOptimizer@@QAEXXZ$5:
  0001e	8b 45 dc	 mov	 eax, DWORD PTR $T2[ebp]
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 ??3CObject@@SGXPAX@Z	; CObject::operator delete
  00027	c3		 ret	 0
  00028	cc		 int	 3
  00029	cc		 int	 3
  0002a	cc		 int	 3
  0002b	cc		 int	 3
  0002c	cc		 int	 3
__ehhandler$?InitTab@CDlgOptimizer@@QAEXXZ:
  0002d	90		 npad	 1
  0002e	90		 npad	 1
  0002f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00033	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00036	8b 4a d8	 mov	 ecx, DWORD PTR [edx-40]
  00039	33 c8		 xor	 ecx, eax
  0003b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00040	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00043	33 c8		 xor	 ecx, eax
  00045	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?InitTab@CDlgOptimizer@@QAEXXZ
  0004f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?InitTab@CDlgOptimizer@@QAEXXZ ENDP			; CDlgOptimizer::InitTab
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
;	COMDAT ??_G?$CArray@PAUST_VALUE@@PAU1@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CArray@PAUST_VALUE@@PAU1@@@UAEPAXI@Z PROC		; CArray<ST_VALUE *,ST_VALUE *>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 355  : {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 356  : 	ASSERT_VALID(this);
; 357  : 
; 358  : 	if (m_pData != NULL)

  00006	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CArray@PAUST_VALUE@@PAU1@@@6B@
  0000f	85 c0		 test	 eax, eax
  00011	74 09		 je	 SHORT $LN11@scalar

; 359  : 	{
; 360  : 		for( int i = 0; i < m_nSize; i++ )
; 361  : 			(m_pData + i)->~TYPE();
; 362  : 		delete[] (BYTE*)m_pData;

  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00019	83 c4 04	 add	 esp, 4
$LN11@scalar:
  0001c	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  0001f	a8 01		 test	 al, 1
  00021	74 1f		 je	 SHORT $LN20@scalar
  00023	a8 04		 test	 al, 4
  00025	75 10		 jne	 SHORT $LN3@scalar
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 112  : 	{ ::operator delete(p); }

  00027	56		 push	 esi
  00028	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0002d	83 c4 04	 add	 esp, 4
  00030	8b c6		 mov	 eax, esi
  00032	5e		 pop	 esi
  00033	5d		 pop	 ebp
  00034	c2 04 00	 ret	 4
$LN3@scalar:
  00037	6a 14		 push	 20			; 00000014H
  00039	56		 push	 esi
  0003a	e8 00 00 00 00	 call	 ?__global_delete@@YAXPAXI@Z ; __global_delete
  0003f	83 c4 08	 add	 esp, 8
$LN20@scalar:
  00042	8b c6		 mov	 eax, esi
  00044	5e		 pop	 esi
  00045	5d		 pop	 ebp
  00046	c2 04 00	 ret	 4
??_G?$CArray@PAUST_VALUE@@PAU1@@@UAEPAXI@Z ENDP		; CArray<ST_VALUE *,ST_VALUE *>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ?Serialize@?$CArray@PAUST_VALUE@@PAU1@@@UAEXAAVCArchive@@@Z
_TEXT	SEGMENT
_pData$1$ = -4						; size = 4
_ar$ = 8						; size = 4
?Serialize@?$CArray@PAUST_VALUE@@PAU1@@@UAEXAAVCArchive@@@Z PROC ; CArray<ST_VALUE *,ST_VALUE *>::Serialize, COMDAT
; _this$ = ecx

; 633  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	8b f9		 mov	 edi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 212  : 	{ return (m_nMode & CArchive::load) == 0; }

  00009	8b 4d 08	 mov	 ecx, DWORD PTR _ar$[ebp]
  0000c	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  0000f	f7 d0		 not	 eax
  00011	a8 01		 test	 al, 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 637  : 	if (ar.IsStoring())

  00013	74 0a		 je	 SHORT $LN2@Serialize

; 638  : 	{
; 639  : 		ar.WriteCount(m_nSize);

  00015	ff 77 08	 push	 DWORD PTR [edi+8]
  00018	e8 00 00 00 00	 call	 ?WriteCount@CArchive@@QAEXK@Z ; CArchive::WriteCount

; 640  : 	}

  0001d	eb 0f		 jmp	 SHORT $LN3@Serialize
$LN2@Serialize:

; 641  : 	else
; 642  : 	{
; 643  : 		DWORD_PTR nOldSize = ar.ReadCount();

  0001f	e8 00 00 00 00	 call	 ?ReadCount@CArchive@@QAEKXZ ; CArchive::ReadCount

; 644  : 		SetSize(nOldSize, -1);

  00024	6a ff		 push	 -1
  00026	50		 push	 eax
  00027	8b cf		 mov	 ecx, edi
  00029	e8 00 00 00 00	 call	 ?SetSize@?$CArray@PAUST_VALUE@@PAU1@@@QAEXHH@Z ; CArray<ST_VALUE *,ST_VALUE *>::SetSize
$LN3@Serialize:

; 645  : 	}
; 646  : 	SerializeElements<TYPE>(ar, m_pData, m_nSize);

  0002e	8b 77 08	 mov	 esi, DWORD PTR [edi+8]
  00031	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00034	89 4d fc	 mov	 DWORD PTR _pData$1$[ebp], ecx

; 68   : 	ENSURE(nCount == 0 || pElements != NULL);

  00037	85 f6		 test	 esi, esi
  00039	74 08		 je	 SHORT $LN8@Serialize
  0003b	85 c9		 test	 ecx, ecx
  0003d	0f 84 8c 00 00
	00		 je	 $LN40@Serialize
$LN8@Serialize:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 212  : 	{ return (m_nMode & CArchive::load) == 0; }

  00043	8b 55 08	 mov	 edx, DWORD PTR _ar$[ebp]
  00046	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00049	f7 d0		 not	 eax
  0004b	a8 01		 test	 al, 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 73   : 	if (ar.IsStoring())

  0004d	74 36		 je	 SHORT $LN16@Serialize

; 74   : 	{
; 75   : 		TYPE* pData;
; 76   : 		UINT_PTR nElementsLeft;
; 77   : 
; 78   : 		nElementsLeft = nCount;
; 79   : 		pData = pElements;
; 80   : 		while( nElementsLeft > 0 )

  0004f	85 f6		 test	 esi, esi
  00051	74 29		 je	 SHORT $LN14@Serialize
$LL11@Serialize:

; 81   : 		{
; 82   : 			UINT nElementsToWrite;
; 83   : 
; 84   : 			nElementsToWrite = UINT(__min(nElementsLeft, INT_MAX/sizeof(TYPE)));

  00053	bb ff ff ff 1f	 mov	 ebx, 536870911		; 1fffffffH
  00058	3b f3		 cmp	 esi, ebx
  0005a	0f 42 de	 cmovb	 ebx, esi

; 85   : 			ar.Write(pData, nElementsToWrite*sizeof(TYPE));

  0005d	8d 3c 9d 00 00
	00 00		 lea	 edi, DWORD PTR [ebx*4]
  00064	57		 push	 edi
  00065	51		 push	 ecx
  00066	8b ca		 mov	 ecx, edx
  00068	e8 00 00 00 00	 call	 ?Write@CArchive@@QAEXPBXI@Z ; CArchive::Write

; 86   : 			nElementsLeft -= nElementsToWrite;
; 87   : 			pData += nElementsToWrite;

  0006d	8b 4d fc	 mov	 ecx, DWORD PTR _pData$1$[ebp]
  00070	8b 55 08	 mov	 edx, DWORD PTR _ar$[ebp]
  00073	03 cf		 add	 ecx, edi
  00075	89 4d fc	 mov	 DWORD PTR _pData$1$[ebp], ecx
  00078	2b f3		 sub	 esi, ebx
  0007a	75 d7		 jne	 SHORT $LL11@Serialize
$LN14@Serialize:
  0007c	5f		 pop	 edi

; 647  : }

  0007d	5e		 pop	 esi
  0007e	5b		 pop	 ebx
  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c2 04 00	 ret	 4
$LN16@Serialize:

; 97   : 		while( nElementsLeft > 0 )

  00085	85 f6		 test	 esi, esi
  00087	74 f3		 je	 SHORT $LN14@Serialize
  00089	0f 1f 80 00 00
	00 00		 npad	 7
$LL13@Serialize:

; 98   : 		{
; 99   : 			UINT nElementsToRead;
; 100  : 
; 101  : 			nElementsToRead = UINT(__min(nElementsLeft, INT_MAX/sizeof(TYPE)));

  00090	bf ff ff ff 1f	 mov	 edi, 536870911		; 1fffffffH
  00095	3b f7		 cmp	 esi, edi
  00097	0f 42 fe	 cmovb	 edi, esi

; 102  : 			ar.EnsureRead(pData, nElementsToRead*sizeof(TYPE));

  0009a	8d 1c bd 00 00
	00 00		 lea	 ebx, DWORD PTR [edi*4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 399  : 	UINT nRead=Read(lpBuf, nCount);

  000a1	53		 push	 ebx
  000a2	51		 push	 ecx
  000a3	8b ca		 mov	 ecx, edx
  000a5	e8 00 00 00 00	 call	 ?Read@CArchive@@QAEIPAXI@Z ; CArchive::Read

; 400  : 	if(nRead!=nCount)

  000aa	3b c3		 cmp	 eax, ebx
  000ac	75 18		 jne	 SHORT $LN30@Serialize
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 97   : 		while( nElementsLeft > 0 )

  000ae	8b 4d fc	 mov	 ecx, DWORD PTR _pData$1$[ebp]
  000b1	8b 55 08	 mov	 edx, DWORD PTR _ar$[ebp]

; 103  : 			nElementsLeft -= nElementsToRead;
; 104  : 			pData += nElementsToRead;

  000b4	03 cb		 add	 ecx, ebx
  000b6	89 4d fc	 mov	 DWORD PTR _pData$1$[ebp], ecx
  000b9	2b f7		 sub	 esi, edi
  000bb	75 d3		 jne	 SHORT $LL13@Serialize

; 647  : }

  000bd	5f		 pop	 edi
  000be	5e		 pop	 esi
  000bf	5b		 pop	 ebx
  000c0	8b e5		 mov	 esp, ebp
  000c2	5d		 pop	 ebp
  000c3	c2 04 00	 ret	 4
$LN30@Serialize:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 402  : 		AfxThrowArchiveException(CArchiveException::endOfFile);

  000c6	6a 00		 push	 0
  000c8	6a 03		 push	 3
  000ca	e8 00 00 00 00	 call	 ?AfxThrowArchiveException@@YGXHPBD@Z ; AfxThrowArchiveException
$LN40@Serialize:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 68   : 	ENSURE(nCount == 0 || pElements != NULL);

  000cf	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN38@Serialize:
  000d4	cc		 int	 3
?Serialize@?$CArray@PAUST_VALUE@@PAU1@@@UAEXAAVCArchive@@@Z ENDP ; CArray<ST_VALUE *,ST_VALUE *>::Serialize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ??1?$CArray@PAUST_VALUE@@PAU1@@@UAE@XZ
_TEXT	SEGMENT
??1?$CArray@PAUST_VALUE@@PAU1@@@UAE@XZ PROC		; CArray<ST_VALUE *,ST_VALUE *>::~CArray<ST_VALUE *,ST_VALUE *>, COMDAT
; _this$ = ecx

; 356  : 	ASSERT_VALID(this);
; 357  : 
; 358  : 	if (m_pData != NULL)

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CArray@PAUST_VALUE@@PAU1@@@6B@
  00009	85 c0		 test	 eax, eax
  0000b	74 07		 je	 SHORT $LN5@CArray

; 359  : 	{
; 360  : 		for( int i = 0; i < m_nSize; i++ )
; 361  : 			(m_pData + i)->~TYPE();
; 362  : 		delete[] (BYTE*)m_pData;

  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00013	59		 pop	 ecx
$LN5@CArray:

; 363  : 	}
; 364  : }

  00014	c3		 ret	 0
??1?$CArray@PAUST_VALUE@@PAU1@@@UAE@XZ ENDP		; CArray<ST_VALUE *,ST_VALUE *>::~CArray<ST_VALUE *,ST_VALUE *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_memcpy_s.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlchecked.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_memcpy_s.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlchecked.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_memcpy_s.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ?SetSize@?$CArray@PAUST_VALUE@@PAU1@@@QAEXHH@Z
_TEXT	SEGMENT
__N$1$ = -4						; size = 4
__S2$1$ = 8						; size = 4
_nNewSize$ = 8						; size = 4
_pNewData$1$ = 12					; size = 4
_nGrowBy$ = 12						; size = 4
?SetSize@?$CArray@PAUST_VALUE@@PAU1@@@QAEXHH@Z PROC	; CArray<ST_VALUE *,ST_VALUE *>::SetSize, COMDAT
; _this$ = ecx

; 368  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi

; 369  : 	ASSERT_VALID(this);
; 370  : 	ASSERT(nNewSize >= 0);
; 371  : 
; 372  : 	if(nNewSize < 0 )

  00006	8b 75 08	 mov	 esi, DWORD PTR _nNewSize$[ebp]
  00009	8b d9		 mov	 ebx, ecx
  0000b	57		 push	 edi
  0000c	85 f6		 test	 esi, esi
  0000e	0f 88 c2 01 00
	00		 js	 $LN70@SetSize

; 373  : 		AfxThrowInvalidArgException();
; 374  : 
; 375  : 	if (nGrowBy >= 0)

  00014	8b 45 0c	 mov	 eax, DWORD PTR _nGrowBy$[ebp]
  00017	85 c0		 test	 eax, eax
  00019	78 03		 js	 SHORT $LN69@SetSize

; 376  : 		m_nGrowBy = nGrowBy;  // set new size

  0001b	89 43 10	 mov	 DWORD PTR [ebx+16], eax
$LN69@SetSize:

; 377  : 
; 378  : 	if (nNewSize == 0)

  0001e	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00021	85 f6		 test	 esi, esi
  00023	75 27		 jne	 SHORT $LN19@SetSize

; 379  : 	{
; 380  : 		// shrink to nothing
; 381  : 		if (m_pData != NULL)

  00025	85 c9		 test	 ecx, ecx
  00027	74 0c		 je	 SHORT $LN21@SetSize

; 382  : 		{
; 383  : 			for( int i = 0; i < m_nSize; i++ )
; 384  : 				(m_pData + i)->~TYPE();
; 385  : 			delete[] (BYTE*)m_pData;

  00029	51		 push	 ecx
  0002a	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0002f	83 c4 04	 add	 esp, 4

; 386  : 			m_pData = NULL;

  00032	89 73 04	 mov	 DWORD PTR [ebx+4], esi
$LN21@SetSize:

; 472  : 		m_nSize = nNewSize;
; 473  : 		m_nMaxSize = nNewMax;
; 474  : 	}
; 475  : }

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	c7 43 0c 00 00
	00 00		 mov	 DWORD PTR [ebx+12], 0
  0003e	c7 43 08 00 00
	00 00		 mov	 DWORD PTR [ebx+8], 0
  00045	5b		 pop	 ebx
  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c2 08 00	 ret	 8
$LN19@SetSize:

; 387  : 		}
; 388  : 		m_nSize = m_nMaxSize = 0;
; 389  : 	}
; 390  : 	else if (m_pData == NULL)

  0004c	85 c9		 test	 ecx, ecx
  0004e	75 36		 jne	 SHORT $LN22@SetSize

; 391  : 	{
; 392  : 		// create buffer big enough to hold number of requested elements or
; 393  : 		// m_nGrowBy elements, whichever is larger.
; 394  : #ifdef SIZE_T_MAX
; 395  : 		ASSERT(nNewSize <= SIZE_T_MAX/sizeof(TYPE));    // no overflow
; 396  : #endif
; 397  : 		size_t nAllocSize = __max(nNewSize, m_nGrowBy);

  00050	8b 7b 10	 mov	 edi, DWORD PTR [ebx+16]
  00053	3b f7		 cmp	 esi, edi
  00055	0f 4f fe	 cmovg	 edi, esi

; 398  : 		m_pData = (TYPE*) new BYTE[(size_t)nAllocSize * sizeof(TYPE)];

  00058	8d 34 bd 00 00
	00 00		 lea	 esi, DWORD PTR [edi*4]
  0005f	56		 push	 esi
  00060	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]

; 399  : 		memset((void*)m_pData, 0, (size_t)nAllocSize * sizeof(TYPE));

  00065	56		 push	 esi
  00066	6a 00		 push	 0
  00068	50		 push	 eax
  00069	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  0006c	e8 00 00 00 00	 call	 _memset

; 400  : 		for( int i = 0; i < nNewSize; i++ )
; 401  : #pragma push_macro("new")
; 402  : #undef new
; 403  : 			::new( (void*)( m_pData + i ) ) TYPE;
; 404  : #pragma pop_macro("new")
; 405  : 		m_nSize = nNewSize;

  00071	8b 45 08	 mov	 eax, DWORD PTR _nNewSize$[ebp]
  00074	83 c4 10	 add	 esp, 16			; 00000010H

; 472  : 		m_nSize = nNewSize;
; 473  : 		m_nMaxSize = nNewMax;
; 474  : 	}
; 475  : }

  00077	89 7b 0c	 mov	 DWORD PTR [ebx+12], edi
  0007a	89 43 08	 mov	 DWORD PTR [ebx+8], eax
  0007d	5f		 pop	 edi
  0007e	5e		 pop	 esi
  0007f	5b		 pop	 ebx
  00080	8b e5		 mov	 esp, ebp
  00082	5d		 pop	 ebp
  00083	c2 08 00	 ret	 8
$LN22@SetSize:

; 406  : 		m_nMaxSize = nAllocSize;
; 407  : 	}
; 408  : 	else if (nNewSize <= m_nMaxSize)

  00086	8b 7b 0c	 mov	 edi, DWORD PTR [ebx+12]
  00089	3b f7		 cmp	 esi, edi
  0008b	7f 29		 jg	 SHORT $LN24@SetSize

; 409  : 	{
; 410  : 		// it fits
; 411  : 		if (nNewSize > m_nSize)

  0008d	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]
  00090	3b f2		 cmp	 esi, edx
  00092	7e 16		 jle	 SHORT $LN26@SetSize

; 412  : 		{
; 413  : 			// initialize the new elements
; 414  : 			memset((void*)(m_pData + m_nSize), 0, (size_t)(nNewSize-m_nSize) * sizeof(TYPE));

  00094	8b c6		 mov	 eax, esi
  00096	2b c2		 sub	 eax, edx
  00098	c1 e0 02	 shl	 eax, 2
  0009b	50		 push	 eax
  0009c	8d 04 91	 lea	 eax, DWORD PTR [ecx+edx*4]
  0009f	6a 00		 push	 0
  000a1	50		 push	 eax
  000a2	e8 00 00 00 00	 call	 _memset
  000a7	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN26@SetSize:

; 415  : 			for( int i = 0; i < nNewSize-m_nSize; i++ )
; 416  : #pragma push_macro("new")
; 417  : #undef new
; 418  : 				::new( (void*)( m_pData + m_nSize + i ) ) TYPE;
; 419  : #pragma pop_macro("new")
; 420  : 		}
; 421  : 		else if (m_nSize > nNewSize)
; 422  : 		{
; 423  : 			// destroy the old elements
; 424  : 			for( int i = 0; i < m_nSize-nNewSize; i++ )
; 425  : 				(m_pData + nNewSize + i)->~TYPE();
; 426  : 		}
; 427  : 		m_nSize = nNewSize;

  000aa	5f		 pop	 edi
  000ab	89 73 08	 mov	 DWORD PTR [ebx+8], esi

; 472  : 		m_nSize = nNewSize;
; 473  : 		m_nMaxSize = nNewMax;
; 474  : 	}
; 475  : }

  000ae	5e		 pop	 esi
  000af	5b		 pop	 ebx
  000b0	8b e5		 mov	 esp, ebp
  000b2	5d		 pop	 ebp
  000b3	c2 08 00	 ret	 8
$LN24@SetSize:

; 428  : 	}
; 429  : 	else
; 430  : 	{
; 431  : 		// otherwise, grow array
; 432  : 		nGrowBy = m_nGrowBy;

  000b6	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]

; 433  : 		if (nGrowBy == 0)

  000b9	85 c0		 test	 eax, eax
  000bb	75 22		 jne	 SHORT $LN37@SetSize

; 434  : 		{
; 435  : 			// heuristically determine growth when nGrowBy == 0
; 436  : 			//  (this avoids heap fragmentation in many situations)
; 437  : 			nGrowBy = m_nSize / 8;

  000bd	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  000c0	99		 cdq
  000c1	83 e2 07	 and	 edx, 7
  000c4	03 c2		 add	 eax, edx
  000c6	c1 f8 03	 sar	 eax, 3

; 438  : 			nGrowBy = (nGrowBy < 4) ? 4 : ((nGrowBy > 1024) ? 1024 : nGrowBy);

  000c9	83 f8 04	 cmp	 eax, 4
  000cc	7d 07		 jge	 SHORT $LN36@SetSize
  000ce	b8 04 00 00 00	 mov	 eax, 4
  000d3	eb 0a		 jmp	 SHORT $LN37@SetSize
$LN36@SetSize:
  000d5	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  000da	3b c1		 cmp	 eax, ecx
  000dc	0f 4f c1	 cmovg	 eax, ecx
$LN37@SetSize:

; 439  : 		}
; 440  : 		INT_PTR nNewMax;
; 441  : 		if (nNewSize < m_nMaxSize + nGrowBy)

  000df	03 f8		 add	 edi, eax
  000e1	3b f7		 cmp	 esi, edi
  000e3	7d 0b		 jge	 SHORT $LN30@SetSize

; 445  : 
; 446  : 		ASSERT(nNewMax >= m_nMaxSize);  // no wrap around
; 447  : 
; 448  : 		if(nNewMax  < m_nMaxSize)

  000e5	3b 7b 0c	 cmp	 edi, DWORD PTR [ebx+12]
  000e8	0f 8c e8 00 00
	00		 jl	 $LN70@SetSize
  000ee	eb 02		 jmp	 SHORT $LN32@SetSize
$LN30@SetSize:

; 442  : 			nNewMax = m_nMaxSize + nGrowBy;  // granularity
; 443  : 		else
; 444  : 			nNewMax = nNewSize;  // no slush

  000f0	8b fe		 mov	 edi, esi
$LN32@SetSize:

; 450  : 
; 451  : #ifdef SIZE_T_MAX
; 452  : 		ASSERT(nNewMax <= SIZE_T_MAX/sizeof(TYPE)); // no overflow
; 453  : #endif
; 454  : 		TYPE* pNewData = (TYPE*) new BYTE[(size_t)nNewMax * sizeof(TYPE)];

  000f2	8d 04 bd 00 00
	00 00		 lea	 eax, DWORD PTR [edi*4]
  000f9	50		 push	 eax
  000fa	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]

; 455  : 
; 456  : 		// copy new data from old
; 457  : 		::ATL::Checked::memcpy_s(pNewData, (size_t)nNewMax * sizeof(TYPE),

  000ff	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  00102	8b c8		 mov	 ecx, eax
  00104	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  00107	83 c4 04	 add	 esp, 4
  0010a	c1 e0 02	 shl	 eax, 2
  0010d	89 4d 0c	 mov	 DWORD PTR _pNewData$1$[ebp], ecx
  00110	89 45 fc	 mov	 DWORD PTR __N$1$[ebp], eax
  00113	89 55 08	 mov	 DWORD PTR __S2$1$[ebp], edx
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_memcpy_s.h

; 46   :         if (_SourceSize == 0)

  00116	85 c0		 test	 eax, eax
  00118	74 76		 je	 SHORT $LN74@SetSize

; 47   :         {
; 48   :             return 0;
; 49   :         }
; 50   : 
; 51   :         _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Destination != NULL, EINVAL);

  0011a	85 c9		 test	 ecx, ecx
  0011c	75 56		 jne	 SHORT $LN42@SetSize
$LN73@SetSize:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlchecked.h

; 69   : 	ATLMFC_CRT_ERRORCHECK(::memcpy_s(_S1, _S1max, _S2, _N));

  0011e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___errno
  00124	c7 00 16 00 00
	00		 mov	 DWORD PTR [eax], 22	; 00000016H
  0012a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo
$LN46@SetSize:
  00130	b8 16 00 00 00	 mov	 eax, 22			; 00000016H
$LN40@SetSize:
  00135	50		 push	 eax
  00136	e8 00 00 00 00	 call	 ?AfxCrtErrorCheck@@YAHH@Z ; AfxCrtErrorCheck
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 462  : 		memset((void*)(pNewData + m_nSize), 0, (size_t)(nNewSize-m_nSize) * sizeof(TYPE));

  0013b	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  0013e	8b c6		 mov	 eax, esi
  00140	2b c1		 sub	 eax, ecx
  00142	c1 e0 02	 shl	 eax, 2
  00145	50		 push	 eax
  00146	8b 45 0c	 mov	 eax, DWORD PTR _pNewData$1$[ebp]
  00149	6a 00		 push	 0
  0014b	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  0014e	50		 push	 eax
  0014f	e8 00 00 00 00	 call	 _memset

; 463  : 		for( int i = 0; i < nNewSize-m_nSize; i++ )
; 464  : #pragma push_macro("new")
; 465  : #undef new
; 466  : 			::new( (void*)( pNewData + m_nSize + i ) ) TYPE;
; 467  : #pragma pop_macro("new")
; 468  : 
; 469  : 		// get rid of old stuff (note: no destructors called)
; 470  : 		delete[] (BYTE*)m_pData;

  00154	ff 73 04	 push	 DWORD PTR [ebx+4]
  00157	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]

; 471  : 		m_pData = pNewData;

  0015c	8b 45 0c	 mov	 eax, DWORD PTR _pNewData$1$[ebp]
  0015f	83 c4 14	 add	 esp, 20			; 00000014H

; 472  : 		m_nSize = nNewSize;
; 473  : 		m_nMaxSize = nNewMax;
; 474  : 	}
; 475  : }

  00162	89 7b 0c	 mov	 DWORD PTR [ebx+12], edi
  00165	89 73 08	 mov	 DWORD PTR [ebx+8], esi
  00168	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  0016b	5f		 pop	 edi
  0016c	5e		 pop	 esi
  0016d	5b		 pop	 ebx
  0016e	8b e5		 mov	 esp, ebp
  00170	5d		 pop	 ebp
  00171	c2 08 00	 ret	 8
$LN42@SetSize:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_memcpy_s.h

; 52   :         if (_Source == NULL || _DestinationSize < _SourceSize)

  00174	85 d2		 test	 edx, edx
  00176	8d 14 bd 00 00
	00 00		 lea	 edx, DWORD PTR [edi*4]
  0017d	74 15		 je	 SHORT $LN44@SetSize
  0017f	3b d0		 cmp	 edx, eax
  00181	72 11		 jb	 SHORT $LN44@SetSize

; 58   : 
; 59   :             // Unreachable, but required to suppress /analyze warnings:
; 60   :             return EINVAL;
; 61   :         }
; 62   :         memcpy(_Destination, _Source, _SourceSize);

  00183	50		 push	 eax
  00184	ff 75 08	 push	 DWORD PTR __S2$1$[ebp]
  00187	51		 push	 ecx
  00188	e8 00 00 00 00	 call	 _memcpy
  0018d	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN74@SetSize:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlchecked.h

; 69   : 	ATLMFC_CRT_ERRORCHECK(::memcpy_s(_S1, _S1max, _S2, _N));

  00190	33 c0		 xor	 eax, eax
  00192	eb a1		 jmp	 SHORT $LN40@SetSize
$LN44@SetSize:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_memcpy_s.h

; 54   :             memset(_Destination, 0, _DestinationSize);

  00194	52		 push	 edx
  00195	6a 00		 push	 0
  00197	51		 push	 ecx
  00198	e8 00 00 00 00	 call	 _memset
  0019d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 55   : 
; 56   :             _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Source != NULL,                 EINVAL);

  001a0	83 7d 08 00	 cmp	 DWORD PTR __S2$1$[ebp], 0
  001a4	0f 84 74 ff ff
	ff		 je	 $LN73@SetSize

; 57   :             _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_DestinationSize >= _SourceSize, ERANGE);

  001aa	8d 04 bd 00 00
	00 00		 lea	 eax, DWORD PTR [edi*4]
  001b1	3b 45 fc	 cmp	 eax, DWORD PTR __N$1$[ebp]
  001b4	0f 83 76 ff ff
	ff		 jae	 $LN46@SetSize
  001ba	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___errno
  001c0	c7 00 22 00 00
	00		 mov	 DWORD PTR [eax], 34	; 00000022H
  001c6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo
  001cc	b8 22 00 00 00	 mov	 eax, 34			; 00000022H
  001d1	e9 5f ff ff ff	 jmp	 $LN40@SetSize
$LN70@SetSize:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 449  : 			AfxThrowInvalidArgException();

  001d6	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN72@SetSize:
  001db	cc		 int	 3
?SetSize@?$CArray@PAUST_VALUE@@PAU1@@@QAEXHH@Z ENDP	; CArray<ST_VALUE *,ST_VALUE *>::SetSize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ??0?$CArray@PAUST_VALUE@@PAU1@@@QAE@XZ
_TEXT	SEGMENT
??0?$CArray@PAUST_VALUE@@PAU1@@@QAE@XZ PROC		; CArray<ST_VALUE *,ST_VALUE *>::CArray<ST_VALUE *,ST_VALUE *>, COMDAT
; _this$ = ecx

; 348  : {

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CArray@PAUST_VALUE@@PAU1@@@6B@

; 349  : 	m_pData = NULL;
; 350  : 	m_nSize = m_nMaxSize = m_nGrowBy = 0;
; 351  : }

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  00016	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0
  0001d	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00024	c3		 ret	 0
??0?$CArray@PAUST_VALUE@@PAU1@@@QAE@XZ ENDP		; CArray<ST_VALUE *,ST_VALUE *>::CArray<ST_VALUE *,ST_VALUE *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
;	COMDAT ??_G?$CArray@PAVCDialog@@PAV1@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CArray@PAVCDialog@@PAV1@@@UAEPAXI@Z PROC		; CArray<CDialog *,CDialog *>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 355  : {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 356  : 	ASSERT_VALID(this);
; 357  : 
; 358  : 	if (m_pData != NULL)

  00006	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CArray@PAVCDialog@@PAV1@@@6B@
  0000f	85 c0		 test	 eax, eax
  00011	74 09		 je	 SHORT $LN11@scalar

; 359  : 	{
; 360  : 		for( int i = 0; i < m_nSize; i++ )
; 361  : 			(m_pData + i)->~TYPE();
; 362  : 		delete[] (BYTE*)m_pData;

  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00019	83 c4 04	 add	 esp, 4
$LN11@scalar:
  0001c	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  0001f	a8 01		 test	 al, 1
  00021	74 1f		 je	 SHORT $LN20@scalar
  00023	a8 04		 test	 al, 4
  00025	75 10		 jne	 SHORT $LN3@scalar
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 112  : 	{ ::operator delete(p); }

  00027	56		 push	 esi
  00028	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0002d	83 c4 04	 add	 esp, 4
  00030	8b c6		 mov	 eax, esi
  00032	5e		 pop	 esi
  00033	5d		 pop	 ebp
  00034	c2 04 00	 ret	 4
$LN3@scalar:
  00037	6a 14		 push	 20			; 00000014H
  00039	56		 push	 esi
  0003a	e8 00 00 00 00	 call	 ?__global_delete@@YAXPAXI@Z ; __global_delete
  0003f	83 c4 08	 add	 esp, 8
$LN20@scalar:
  00042	8b c6		 mov	 eax, esi
  00044	5e		 pop	 esi
  00045	5d		 pop	 ebp
  00046	c2 04 00	 ret	 4
??_G?$CArray@PAVCDialog@@PAV1@@@UAEPAXI@Z ENDP		; CArray<CDialog *,CDialog *>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ?Serialize@?$CArray@PAVCDialog@@PAV1@@@UAEXAAVCArchive@@@Z
_TEXT	SEGMENT
_pData$1$ = -4						; size = 4
_ar$ = 8						; size = 4
?Serialize@?$CArray@PAVCDialog@@PAV1@@@UAEXAAVCArchive@@@Z PROC ; CArray<CDialog *,CDialog *>::Serialize, COMDAT
; _this$ = ecx

; 633  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	8b f9		 mov	 edi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 212  : 	{ return (m_nMode & CArchive::load) == 0; }

  00009	8b 4d 08	 mov	 ecx, DWORD PTR _ar$[ebp]
  0000c	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  0000f	f7 d0		 not	 eax
  00011	a8 01		 test	 al, 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 637  : 	if (ar.IsStoring())

  00013	74 0a		 je	 SHORT $LN2@Serialize

; 638  : 	{
; 639  : 		ar.WriteCount(m_nSize);

  00015	ff 77 08	 push	 DWORD PTR [edi+8]
  00018	e8 00 00 00 00	 call	 ?WriteCount@CArchive@@QAEXK@Z ; CArchive::WriteCount

; 640  : 	}

  0001d	eb 0f		 jmp	 SHORT $LN3@Serialize
$LN2@Serialize:

; 641  : 	else
; 642  : 	{
; 643  : 		DWORD_PTR nOldSize = ar.ReadCount();

  0001f	e8 00 00 00 00	 call	 ?ReadCount@CArchive@@QAEKXZ ; CArchive::ReadCount

; 644  : 		SetSize(nOldSize, -1);

  00024	6a ff		 push	 -1
  00026	50		 push	 eax
  00027	8b cf		 mov	 ecx, edi
  00029	e8 00 00 00 00	 call	 ?SetSize@?$CArray@PAVCDialog@@PAV1@@@QAEXHH@Z ; CArray<CDialog *,CDialog *>::SetSize
$LN3@Serialize:

; 645  : 	}
; 646  : 	SerializeElements<TYPE>(ar, m_pData, m_nSize);

  0002e	8b 77 08	 mov	 esi, DWORD PTR [edi+8]
  00031	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00034	89 4d fc	 mov	 DWORD PTR _pData$1$[ebp], ecx

; 68   : 	ENSURE(nCount == 0 || pElements != NULL);

  00037	85 f6		 test	 esi, esi
  00039	74 08		 je	 SHORT $LN8@Serialize
  0003b	85 c9		 test	 ecx, ecx
  0003d	0f 84 8c 00 00
	00		 je	 $LN40@Serialize
$LN8@Serialize:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 212  : 	{ return (m_nMode & CArchive::load) == 0; }

  00043	8b 55 08	 mov	 edx, DWORD PTR _ar$[ebp]
  00046	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00049	f7 d0		 not	 eax
  0004b	a8 01		 test	 al, 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 73   : 	if (ar.IsStoring())

  0004d	74 36		 je	 SHORT $LN16@Serialize

; 74   : 	{
; 75   : 		TYPE* pData;
; 76   : 		UINT_PTR nElementsLeft;
; 77   : 
; 78   : 		nElementsLeft = nCount;
; 79   : 		pData = pElements;
; 80   : 		while( nElementsLeft > 0 )

  0004f	85 f6		 test	 esi, esi
  00051	74 29		 je	 SHORT $LN14@Serialize
$LL11@Serialize:

; 81   : 		{
; 82   : 			UINT nElementsToWrite;
; 83   : 
; 84   : 			nElementsToWrite = UINT(__min(nElementsLeft, INT_MAX/sizeof(TYPE)));

  00053	bb ff ff ff 1f	 mov	 ebx, 536870911		; 1fffffffH
  00058	3b f3		 cmp	 esi, ebx
  0005a	0f 42 de	 cmovb	 ebx, esi

; 85   : 			ar.Write(pData, nElementsToWrite*sizeof(TYPE));

  0005d	8d 3c 9d 00 00
	00 00		 lea	 edi, DWORD PTR [ebx*4]
  00064	57		 push	 edi
  00065	51		 push	 ecx
  00066	8b ca		 mov	 ecx, edx
  00068	e8 00 00 00 00	 call	 ?Write@CArchive@@QAEXPBXI@Z ; CArchive::Write

; 86   : 			nElementsLeft -= nElementsToWrite;
; 87   : 			pData += nElementsToWrite;

  0006d	8b 4d fc	 mov	 ecx, DWORD PTR _pData$1$[ebp]
  00070	8b 55 08	 mov	 edx, DWORD PTR _ar$[ebp]
  00073	03 cf		 add	 ecx, edi
  00075	89 4d fc	 mov	 DWORD PTR _pData$1$[ebp], ecx
  00078	2b f3		 sub	 esi, ebx
  0007a	75 d7		 jne	 SHORT $LL11@Serialize
$LN14@Serialize:
  0007c	5f		 pop	 edi

; 647  : }

  0007d	5e		 pop	 esi
  0007e	5b		 pop	 ebx
  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c2 04 00	 ret	 4
$LN16@Serialize:

; 97   : 		while( nElementsLeft > 0 )

  00085	85 f6		 test	 esi, esi
  00087	74 f3		 je	 SHORT $LN14@Serialize
  00089	0f 1f 80 00 00
	00 00		 npad	 7
$LL13@Serialize:

; 98   : 		{
; 99   : 			UINT nElementsToRead;
; 100  : 
; 101  : 			nElementsToRead = UINT(__min(nElementsLeft, INT_MAX/sizeof(TYPE)));

  00090	bf ff ff ff 1f	 mov	 edi, 536870911		; 1fffffffH
  00095	3b f7		 cmp	 esi, edi
  00097	0f 42 fe	 cmovb	 edi, esi

; 102  : 			ar.EnsureRead(pData, nElementsToRead*sizeof(TYPE));

  0009a	8d 1c bd 00 00
	00 00		 lea	 ebx, DWORD PTR [edi*4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 399  : 	UINT nRead=Read(lpBuf, nCount);

  000a1	53		 push	 ebx
  000a2	51		 push	 ecx
  000a3	8b ca		 mov	 ecx, edx
  000a5	e8 00 00 00 00	 call	 ?Read@CArchive@@QAEIPAXI@Z ; CArchive::Read

; 400  : 	if(nRead!=nCount)

  000aa	3b c3		 cmp	 eax, ebx
  000ac	75 18		 jne	 SHORT $LN30@Serialize
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 97   : 		while( nElementsLeft > 0 )

  000ae	8b 4d fc	 mov	 ecx, DWORD PTR _pData$1$[ebp]
  000b1	8b 55 08	 mov	 edx, DWORD PTR _ar$[ebp]

; 103  : 			nElementsLeft -= nElementsToRead;
; 104  : 			pData += nElementsToRead;

  000b4	03 cb		 add	 ecx, ebx
  000b6	89 4d fc	 mov	 DWORD PTR _pData$1$[ebp], ecx
  000b9	2b f7		 sub	 esi, edi
  000bb	75 d3		 jne	 SHORT $LL13@Serialize

; 647  : }

  000bd	5f		 pop	 edi
  000be	5e		 pop	 esi
  000bf	5b		 pop	 ebx
  000c0	8b e5		 mov	 esp, ebp
  000c2	5d		 pop	 ebp
  000c3	c2 04 00	 ret	 4
$LN30@Serialize:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 402  : 		AfxThrowArchiveException(CArchiveException::endOfFile);

  000c6	6a 00		 push	 0
  000c8	6a 03		 push	 3
  000ca	e8 00 00 00 00	 call	 ?AfxThrowArchiveException@@YGXHPBD@Z ; AfxThrowArchiveException
$LN40@Serialize:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 68   : 	ENSURE(nCount == 0 || pElements != NULL);

  000cf	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN38@Serialize:
  000d4	cc		 int	 3
?Serialize@?$CArray@PAVCDialog@@PAV1@@@UAEXAAVCArchive@@@Z ENDP ; CArray<CDialog *,CDialog *>::Serialize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ??1?$CArray@PAVCDialog@@PAV1@@@UAE@XZ
_TEXT	SEGMENT
??1?$CArray@PAVCDialog@@PAV1@@@UAE@XZ PROC		; CArray<CDialog *,CDialog *>::~CArray<CDialog *,CDialog *>, COMDAT
; _this$ = ecx

; 356  : 	ASSERT_VALID(this);
; 357  : 
; 358  : 	if (m_pData != NULL)

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CArray@PAVCDialog@@PAV1@@@6B@
  00009	85 c0		 test	 eax, eax
  0000b	74 07		 je	 SHORT $LN5@CArray

; 359  : 	{
; 360  : 		for( int i = 0; i < m_nSize; i++ )
; 361  : 			(m_pData + i)->~TYPE();
; 362  : 		delete[] (BYTE*)m_pData;

  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00013	59		 pop	 ecx
$LN5@CArray:

; 363  : 	}
; 364  : }

  00014	c3		 ret	 0
??1?$CArray@PAVCDialog@@PAV1@@@UAE@XZ ENDP		; CArray<CDialog *,CDialog *>::~CArray<CDialog *,CDialog *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ?SetAtGrow@?$CArray@PAVCDialog@@PAV1@@@QAEXHPAVCDialog@@@Z
_TEXT	SEGMENT
_nIndex$ = 8						; size = 4
_newElement$ = 12					; size = 4
?SetAtGrow@?$CArray@PAVCDialog@@PAV1@@@QAEXHPAVCDialog@@@Z PROC ; CArray<CDialog *,CDialog *>::SetAtGrow, COMDAT
; _this$ = ecx

; 534  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 535  : 	ASSERT_VALID(this);
; 536  : 	ASSERT(nIndex >= 0);
; 537  : 
; 538  : 	if(nIndex < 0)

  00004	8b 75 08	 mov	 esi, DWORD PTR _nIndex$[ebp]
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
  0000a	85 f6		 test	 esi, esi
  0000c	78 1f		 js	 SHORT $LN7@SetAtGrow

; 540  : 
; 541  : 	if (nIndex >= m_nSize)

  0000e	3b 77 08	 cmp	 esi, DWORD PTR [edi+8]
  00011	7c 0b		 jl	 SHORT $LN3@SetAtGrow

; 542  : 		SetSize(nIndex+1, -1);

  00013	6a ff		 push	 -1
  00015	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ?SetSize@?$CArray@PAVCDialog@@PAV1@@@QAEXHH@Z ; CArray<CDialog *,CDialog *>::SetSize
$LN3@SetAtGrow:

; 543  : 	m_pData[nIndex] = newElement;

  0001e	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00021	8b 45 0c	 mov	 eax, DWORD PTR _newElement$[ebp]
  00024	5f		 pop	 edi
  00025	89 04 b1	 mov	 DWORD PTR [ecx+esi*4], eax
  00028	5e		 pop	 esi

; 544  : }

  00029	5d		 pop	 ebp
  0002a	c2 08 00	 ret	 8
$LN7@SetAtGrow:

; 539  : 		AfxThrowInvalidArgException();

  0002d	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN5@SetAtGrow:
  00032	cc		 int	 3
?SetAtGrow@?$CArray@PAVCDialog@@PAV1@@@QAEXHPAVCDialog@@@Z ENDP ; CArray<CDialog *,CDialog *>::SetAtGrow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_memcpy_s.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlchecked.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_memcpy_s.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlchecked.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_memcpy_s.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ?SetSize@?$CArray@PAVCDialog@@PAV1@@@QAEXHH@Z
_TEXT	SEGMENT
__N$1$ = -4						; size = 4
__S2$1$ = 8						; size = 4
_nNewSize$ = 8						; size = 4
_pNewData$1$ = 12					; size = 4
_nGrowBy$ = 12						; size = 4
?SetSize@?$CArray@PAVCDialog@@PAV1@@@QAEXHH@Z PROC	; CArray<CDialog *,CDialog *>::SetSize, COMDAT
; _this$ = ecx

; 368  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi

; 369  : 	ASSERT_VALID(this);
; 370  : 	ASSERT(nNewSize >= 0);
; 371  : 
; 372  : 	if(nNewSize < 0 )

  00006	8b 75 08	 mov	 esi, DWORD PTR _nNewSize$[ebp]
  00009	8b d9		 mov	 ebx, ecx
  0000b	57		 push	 edi
  0000c	85 f6		 test	 esi, esi
  0000e	0f 88 c2 01 00
	00		 js	 $LN70@SetSize

; 373  : 		AfxThrowInvalidArgException();
; 374  : 
; 375  : 	if (nGrowBy >= 0)

  00014	8b 45 0c	 mov	 eax, DWORD PTR _nGrowBy$[ebp]
  00017	85 c0		 test	 eax, eax
  00019	78 03		 js	 SHORT $LN69@SetSize

; 376  : 		m_nGrowBy = nGrowBy;  // set new size

  0001b	89 43 10	 mov	 DWORD PTR [ebx+16], eax
$LN69@SetSize:

; 377  : 
; 378  : 	if (nNewSize == 0)

  0001e	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00021	85 f6		 test	 esi, esi
  00023	75 27		 jne	 SHORT $LN19@SetSize

; 379  : 	{
; 380  : 		// shrink to nothing
; 381  : 		if (m_pData != NULL)

  00025	85 c9		 test	 ecx, ecx
  00027	74 0c		 je	 SHORT $LN21@SetSize

; 382  : 		{
; 383  : 			for( int i = 0; i < m_nSize; i++ )
; 384  : 				(m_pData + i)->~TYPE();
; 385  : 			delete[] (BYTE*)m_pData;

  00029	51		 push	 ecx
  0002a	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0002f	83 c4 04	 add	 esp, 4

; 386  : 			m_pData = NULL;

  00032	89 73 04	 mov	 DWORD PTR [ebx+4], esi
$LN21@SetSize:

; 472  : 		m_nSize = nNewSize;
; 473  : 		m_nMaxSize = nNewMax;
; 474  : 	}
; 475  : }

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	c7 43 0c 00 00
	00 00		 mov	 DWORD PTR [ebx+12], 0
  0003e	c7 43 08 00 00
	00 00		 mov	 DWORD PTR [ebx+8], 0
  00045	5b		 pop	 ebx
  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c2 08 00	 ret	 8
$LN19@SetSize:

; 387  : 		}
; 388  : 		m_nSize = m_nMaxSize = 0;
; 389  : 	}
; 390  : 	else if (m_pData == NULL)

  0004c	85 c9		 test	 ecx, ecx
  0004e	75 36		 jne	 SHORT $LN22@SetSize

; 391  : 	{
; 392  : 		// create buffer big enough to hold number of requested elements or
; 393  : 		// m_nGrowBy elements, whichever is larger.
; 394  : #ifdef SIZE_T_MAX
; 395  : 		ASSERT(nNewSize <= SIZE_T_MAX/sizeof(TYPE));    // no overflow
; 396  : #endif
; 397  : 		size_t nAllocSize = __max(nNewSize, m_nGrowBy);

  00050	8b 7b 10	 mov	 edi, DWORD PTR [ebx+16]
  00053	3b f7		 cmp	 esi, edi
  00055	0f 4f fe	 cmovg	 edi, esi

; 398  : 		m_pData = (TYPE*) new BYTE[(size_t)nAllocSize * sizeof(TYPE)];

  00058	8d 34 bd 00 00
	00 00		 lea	 esi, DWORD PTR [edi*4]
  0005f	56		 push	 esi
  00060	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]

; 399  : 		memset((void*)m_pData, 0, (size_t)nAllocSize * sizeof(TYPE));

  00065	56		 push	 esi
  00066	6a 00		 push	 0
  00068	50		 push	 eax
  00069	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  0006c	e8 00 00 00 00	 call	 _memset

; 400  : 		for( int i = 0; i < nNewSize; i++ )
; 401  : #pragma push_macro("new")
; 402  : #undef new
; 403  : 			::new( (void*)( m_pData + i ) ) TYPE;
; 404  : #pragma pop_macro("new")
; 405  : 		m_nSize = nNewSize;

  00071	8b 45 08	 mov	 eax, DWORD PTR _nNewSize$[ebp]
  00074	83 c4 10	 add	 esp, 16			; 00000010H

; 472  : 		m_nSize = nNewSize;
; 473  : 		m_nMaxSize = nNewMax;
; 474  : 	}
; 475  : }

  00077	89 7b 0c	 mov	 DWORD PTR [ebx+12], edi
  0007a	89 43 08	 mov	 DWORD PTR [ebx+8], eax
  0007d	5f		 pop	 edi
  0007e	5e		 pop	 esi
  0007f	5b		 pop	 ebx
  00080	8b e5		 mov	 esp, ebp
  00082	5d		 pop	 ebp
  00083	c2 08 00	 ret	 8
$LN22@SetSize:

; 406  : 		m_nMaxSize = nAllocSize;
; 407  : 	}
; 408  : 	else if (nNewSize <= m_nMaxSize)

  00086	8b 7b 0c	 mov	 edi, DWORD PTR [ebx+12]
  00089	3b f7		 cmp	 esi, edi
  0008b	7f 29		 jg	 SHORT $LN24@SetSize

; 409  : 	{
; 410  : 		// it fits
; 411  : 		if (nNewSize > m_nSize)

  0008d	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]
  00090	3b f2		 cmp	 esi, edx
  00092	7e 16		 jle	 SHORT $LN26@SetSize

; 412  : 		{
; 413  : 			// initialize the new elements
; 414  : 			memset((void*)(m_pData + m_nSize), 0, (size_t)(nNewSize-m_nSize) * sizeof(TYPE));

  00094	8b c6		 mov	 eax, esi
  00096	2b c2		 sub	 eax, edx
  00098	c1 e0 02	 shl	 eax, 2
  0009b	50		 push	 eax
  0009c	8d 04 91	 lea	 eax, DWORD PTR [ecx+edx*4]
  0009f	6a 00		 push	 0
  000a1	50		 push	 eax
  000a2	e8 00 00 00 00	 call	 _memset
  000a7	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN26@SetSize:

; 415  : 			for( int i = 0; i < nNewSize-m_nSize; i++ )
; 416  : #pragma push_macro("new")
; 417  : #undef new
; 418  : 				::new( (void*)( m_pData + m_nSize + i ) ) TYPE;
; 419  : #pragma pop_macro("new")
; 420  : 		}
; 421  : 		else if (m_nSize > nNewSize)
; 422  : 		{
; 423  : 			// destroy the old elements
; 424  : 			for( int i = 0; i < m_nSize-nNewSize; i++ )
; 425  : 				(m_pData + nNewSize + i)->~TYPE();
; 426  : 		}
; 427  : 		m_nSize = nNewSize;

  000aa	5f		 pop	 edi
  000ab	89 73 08	 mov	 DWORD PTR [ebx+8], esi

; 472  : 		m_nSize = nNewSize;
; 473  : 		m_nMaxSize = nNewMax;
; 474  : 	}
; 475  : }

  000ae	5e		 pop	 esi
  000af	5b		 pop	 ebx
  000b0	8b e5		 mov	 esp, ebp
  000b2	5d		 pop	 ebp
  000b3	c2 08 00	 ret	 8
$LN24@SetSize:

; 428  : 	}
; 429  : 	else
; 430  : 	{
; 431  : 		// otherwise, grow array
; 432  : 		nGrowBy = m_nGrowBy;

  000b6	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]

; 433  : 		if (nGrowBy == 0)

  000b9	85 c0		 test	 eax, eax
  000bb	75 22		 jne	 SHORT $LN37@SetSize

; 434  : 		{
; 435  : 			// heuristically determine growth when nGrowBy == 0
; 436  : 			//  (this avoids heap fragmentation in many situations)
; 437  : 			nGrowBy = m_nSize / 8;

  000bd	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  000c0	99		 cdq
  000c1	83 e2 07	 and	 edx, 7
  000c4	03 c2		 add	 eax, edx
  000c6	c1 f8 03	 sar	 eax, 3

; 438  : 			nGrowBy = (nGrowBy < 4) ? 4 : ((nGrowBy > 1024) ? 1024 : nGrowBy);

  000c9	83 f8 04	 cmp	 eax, 4
  000cc	7d 07		 jge	 SHORT $LN36@SetSize
  000ce	b8 04 00 00 00	 mov	 eax, 4
  000d3	eb 0a		 jmp	 SHORT $LN37@SetSize
$LN36@SetSize:
  000d5	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  000da	3b c1		 cmp	 eax, ecx
  000dc	0f 4f c1	 cmovg	 eax, ecx
$LN37@SetSize:

; 439  : 		}
; 440  : 		INT_PTR nNewMax;
; 441  : 		if (nNewSize < m_nMaxSize + nGrowBy)

  000df	03 f8		 add	 edi, eax
  000e1	3b f7		 cmp	 esi, edi
  000e3	7d 0b		 jge	 SHORT $LN30@SetSize

; 445  : 
; 446  : 		ASSERT(nNewMax >= m_nMaxSize);  // no wrap around
; 447  : 
; 448  : 		if(nNewMax  < m_nMaxSize)

  000e5	3b 7b 0c	 cmp	 edi, DWORD PTR [ebx+12]
  000e8	0f 8c e8 00 00
	00		 jl	 $LN70@SetSize
  000ee	eb 02		 jmp	 SHORT $LN32@SetSize
$LN30@SetSize:

; 442  : 			nNewMax = m_nMaxSize + nGrowBy;  // granularity
; 443  : 		else
; 444  : 			nNewMax = nNewSize;  // no slush

  000f0	8b fe		 mov	 edi, esi
$LN32@SetSize:

; 450  : 
; 451  : #ifdef SIZE_T_MAX
; 452  : 		ASSERT(nNewMax <= SIZE_T_MAX/sizeof(TYPE)); // no overflow
; 453  : #endif
; 454  : 		TYPE* pNewData = (TYPE*) new BYTE[(size_t)nNewMax * sizeof(TYPE)];

  000f2	8d 04 bd 00 00
	00 00		 lea	 eax, DWORD PTR [edi*4]
  000f9	50		 push	 eax
  000fa	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]

; 455  : 
; 456  : 		// copy new data from old
; 457  : 		::ATL::Checked::memcpy_s(pNewData, (size_t)nNewMax * sizeof(TYPE),

  000ff	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  00102	8b c8		 mov	 ecx, eax
  00104	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  00107	83 c4 04	 add	 esp, 4
  0010a	c1 e0 02	 shl	 eax, 2
  0010d	89 4d 0c	 mov	 DWORD PTR _pNewData$1$[ebp], ecx
  00110	89 45 fc	 mov	 DWORD PTR __N$1$[ebp], eax
  00113	89 55 08	 mov	 DWORD PTR __S2$1$[ebp], edx
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_memcpy_s.h

; 46   :         if (_SourceSize == 0)

  00116	85 c0		 test	 eax, eax
  00118	74 76		 je	 SHORT $LN74@SetSize

; 47   :         {
; 48   :             return 0;
; 49   :         }
; 50   : 
; 51   :         _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Destination != NULL, EINVAL);

  0011a	85 c9		 test	 ecx, ecx
  0011c	75 56		 jne	 SHORT $LN42@SetSize
$LN73@SetSize:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlchecked.h

; 69   : 	ATLMFC_CRT_ERRORCHECK(::memcpy_s(_S1, _S1max, _S2, _N));

  0011e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___errno
  00124	c7 00 16 00 00
	00		 mov	 DWORD PTR [eax], 22	; 00000016H
  0012a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo
$LN46@SetSize:
  00130	b8 16 00 00 00	 mov	 eax, 22			; 00000016H
$LN40@SetSize:
  00135	50		 push	 eax
  00136	e8 00 00 00 00	 call	 ?AfxCrtErrorCheck@@YAHH@Z ; AfxCrtErrorCheck
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 462  : 		memset((void*)(pNewData + m_nSize), 0, (size_t)(nNewSize-m_nSize) * sizeof(TYPE));

  0013b	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  0013e	8b c6		 mov	 eax, esi
  00140	2b c1		 sub	 eax, ecx
  00142	c1 e0 02	 shl	 eax, 2
  00145	50		 push	 eax
  00146	8b 45 0c	 mov	 eax, DWORD PTR _pNewData$1$[ebp]
  00149	6a 00		 push	 0
  0014b	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  0014e	50		 push	 eax
  0014f	e8 00 00 00 00	 call	 _memset

; 463  : 		for( int i = 0; i < nNewSize-m_nSize; i++ )
; 464  : #pragma push_macro("new")
; 465  : #undef new
; 466  : 			::new( (void*)( pNewData + m_nSize + i ) ) TYPE;
; 467  : #pragma pop_macro("new")
; 468  : 
; 469  : 		// get rid of old stuff (note: no destructors called)
; 470  : 		delete[] (BYTE*)m_pData;

  00154	ff 73 04	 push	 DWORD PTR [ebx+4]
  00157	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]

; 471  : 		m_pData = pNewData;

  0015c	8b 45 0c	 mov	 eax, DWORD PTR _pNewData$1$[ebp]
  0015f	83 c4 14	 add	 esp, 20			; 00000014H

; 472  : 		m_nSize = nNewSize;
; 473  : 		m_nMaxSize = nNewMax;
; 474  : 	}
; 475  : }

  00162	89 7b 0c	 mov	 DWORD PTR [ebx+12], edi
  00165	89 73 08	 mov	 DWORD PTR [ebx+8], esi
  00168	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  0016b	5f		 pop	 edi
  0016c	5e		 pop	 esi
  0016d	5b		 pop	 ebx
  0016e	8b e5		 mov	 esp, ebp
  00170	5d		 pop	 ebp
  00171	c2 08 00	 ret	 8
$LN42@SetSize:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_memcpy_s.h

; 52   :         if (_Source == NULL || _DestinationSize < _SourceSize)

  00174	85 d2		 test	 edx, edx
  00176	8d 14 bd 00 00
	00 00		 lea	 edx, DWORD PTR [edi*4]
  0017d	74 15		 je	 SHORT $LN44@SetSize
  0017f	3b d0		 cmp	 edx, eax
  00181	72 11		 jb	 SHORT $LN44@SetSize

; 58   : 
; 59   :             // Unreachable, but required to suppress /analyze warnings:
; 60   :             return EINVAL;
; 61   :         }
; 62   :         memcpy(_Destination, _Source, _SourceSize);

  00183	50		 push	 eax
  00184	ff 75 08	 push	 DWORD PTR __S2$1$[ebp]
  00187	51		 push	 ecx
  00188	e8 00 00 00 00	 call	 _memcpy
  0018d	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN74@SetSize:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlchecked.h

; 69   : 	ATLMFC_CRT_ERRORCHECK(::memcpy_s(_S1, _S1max, _S2, _N));

  00190	33 c0		 xor	 eax, eax
  00192	eb a1		 jmp	 SHORT $LN40@SetSize
$LN44@SetSize:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_memcpy_s.h

; 54   :             memset(_Destination, 0, _DestinationSize);

  00194	52		 push	 edx
  00195	6a 00		 push	 0
  00197	51		 push	 ecx
  00198	e8 00 00 00 00	 call	 _memset
  0019d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 55   : 
; 56   :             _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Source != NULL,                 EINVAL);

  001a0	83 7d 08 00	 cmp	 DWORD PTR __S2$1$[ebp], 0
  001a4	0f 84 74 ff ff
	ff		 je	 $LN73@SetSize

; 57   :             _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_DestinationSize >= _SourceSize, ERANGE);

  001aa	8d 04 bd 00 00
	00 00		 lea	 eax, DWORD PTR [edi*4]
  001b1	3b 45 fc	 cmp	 eax, DWORD PTR __N$1$[ebp]
  001b4	0f 83 76 ff ff
	ff		 jae	 $LN46@SetSize
  001ba	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___errno
  001c0	c7 00 22 00 00
	00		 mov	 DWORD PTR [eax], 34	; 00000022H
  001c6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo
  001cc	b8 22 00 00 00	 mov	 eax, 34			; 00000022H
  001d1	e9 5f ff ff ff	 jmp	 $LN40@SetSize
$LN70@SetSize:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 449  : 			AfxThrowInvalidArgException();

  001d6	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN72@SetSize:
  001db	cc		 int	 3
?SetSize@?$CArray@PAVCDialog@@PAV1@@@QAEXHH@Z ENDP	; CArray<CDialog *,CDialog *>::SetSize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ??0?$CArray@PAVCDialog@@PAV1@@@QAE@XZ
_TEXT	SEGMENT
??0?$CArray@PAVCDialog@@PAV1@@@QAE@XZ PROC		; CArray<CDialog *,CDialog *>::CArray<CDialog *,CDialog *>, COMDAT
; _this$ = ecx

; 348  : {

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CArray@PAVCDialog@@PAV1@@@6B@

; 349  : 	m_pData = NULL;
; 350  : 	m_nSize = m_nMaxSize = m_nGrowBy = 0;
; 351  : }

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  00016	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0
  0001d	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00024	c3		 ret	 0
??0?$CArray@PAVCDialog@@PAV1@@@QAE@XZ ENDP		; CArray<CDialog *,CDialog *>::CArray<CDialog *,CDialog *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\GridCtrl_src\GridCtrl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
;	COMDAT ?AutoSizeColumns@CDlgOptimizer@@QAEXXZ
_TEXT	SEGMENT
?AutoSizeColumns@CDlgOptimizer@@QAEXXZ PROC		; CDlgOptimizer::AutoSizeColumns, COMDAT
; _this$ = ecx

; 515  : {

  00000	56		 push	 esi

; 516  : 	if(m_GridTap.GetSafeHwnd())

  00001	8d b1 f0 09 00
	00		 lea	 esi, DWORD PTR [ecx+2544]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl

; 25   : 	{ return this == NULL ? NULL : m_hWnd; }

  00007	85 f6		 test	 esi, esi
  00009	0f 84 8e 00 00
	00		 je	 $LN2@AutoSizeCo
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 516  : 	if(m_GridTap.GetSafeHwnd())

  0000f	83 7e 20 00	 cmp	 DWORD PTR [esi+32], 0
  00013	0f 84 84 00 00
	00		 je	 $LN2@AutoSizeCo
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\GridCtrl_src\GridCtrl.h

; 525  :     BOOL IsVisibleVScroll() { return ( (m_nBarState & GVL_VERT) > 0); } 

  00019	f6 81 e0 0a 00
	00 02		 test	 BYTE PTR [ecx+2784], 2
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 518  : 		if(m_GridTap.IsVisibleVScroll()==FALSE)

  00020	77 06		 ja	 SHORT $LN5@AutoSizeCo
  00022	5e		 pop	 esi

; 519  : 		{
; 520  : 			ReSize();

  00023	e9 00 00 00 00	 jmp	 ?ReSize@CDlgOptimizer@@QAEXXZ ; CDlgOptimizer::ReSize
$LN5@AutoSizeCo:

; 521  : 			return;
; 522  : 		}
; 523  : 
; 524  : 		switch(m_nOptimizerDiv)

  00028	8b 81 70 11 00
	00		 mov	 eax, DWORD PTR [ecx+4464]
  0002e	2d e9 03 00 00	 sub	 eax, 1001		; 000003e9H
  00033	74 41		 je	 SHORT $LN6@AutoSizeCo
  00035	83 e8 01	 sub	 eax, 1
  00038	74 2d		 je	 SHORT $LN7@AutoSizeCo
  0003a	83 e8 01	 sub	 eax, 1
  0003d	75 5e		 jne	 SHORT $LN2@AutoSizeCo

; 533  : 			break;
; 534  : 		case TIME_OPTIMIZER:
; 535  : 			m_GridTap.AutoSizeColumn(1);

  0003f	6a 01		 push	 1
  00041	50		 push	 eax
  00042	6a 01		 push	 1
  00044	8b ce		 mov	 ecx, esi
  00046	e8 00 00 00 00	 call	 ?AutoSizeColumn@CGridCtrl@@QAEHHIH@Z ; CGridCtrl::AutoSizeColumn

; 536  : 			m_GridTap.AutoSizeColumn(4);

  0004b	6a 01		 push	 1
  0004d	6a 00		 push	 0
  0004f	6a 04		 push	 4
  00051	8b ce		 mov	 ecx, esi
  00053	e8 00 00 00 00	 call	 ?AutoSizeColumn@CGridCtrl@@QAEHHIH@Z ; CGridCtrl::AutoSizeColumn

; 537  : 			m_GridTap.AutoSizeColumn(7);

  00058	6a 01		 push	 1
  0005a	6a 00		 push	 0
  0005c	6a 07		 push	 7

; 538  : 			break;
; 539  : 		}
; 540  : 	}
; 541  : }

  0005e	8b ce		 mov	 ecx, esi
  00060	e8 00 00 00 00	 call	 ?AutoSizeColumn@CGridCtrl@@QAEHHIH@Z ; CGridCtrl::AutoSizeColumn
  00065	5e		 pop	 esi
  00066	c3		 ret	 0
$LN7@AutoSizeCo:

; 530  : 			break;
; 531  : 		case VAL_OPTIMIZER:
; 532  : 			m_GridTap.AutoSizeColumn(5);

  00067	6a 01		 push	 1
  00069	6a 00		 push	 0
  0006b	6a 05		 push	 5

; 538  : 			break;
; 539  : 		}
; 540  : 	}
; 541  : }

  0006d	8b ce		 mov	 ecx, esi
  0006f	e8 00 00 00 00	 call	 ?AutoSizeColumn@CGridCtrl@@QAEHHIH@Z ; CGridCtrl::AutoSizeColumn
  00074	5e		 pop	 esi
  00075	c3		 ret	 0
$LN6@AutoSizeCo:

; 525  : 		{
; 526  : 		case INDEX_OPTIMIZER:
; 527  : 			m_GridTap.AutoSizeColumn(1);

  00076	6a 01		 push	 1
  00078	6a 00		 push	 0
  0007a	6a 01		 push	 1
  0007c	8b ce		 mov	 ecx, esi
  0007e	e8 00 00 00 00	 call	 ?AutoSizeColumn@CGridCtrl@@QAEHHIH@Z ; CGridCtrl::AutoSizeColumn

; 528  : 			m_GridTap.AutoSizeColumn(3);

  00083	6a 01		 push	 1
  00085	6a 00		 push	 0
  00087	6a 03		 push	 3
  00089	8b ce		 mov	 ecx, esi
  0008b	e8 00 00 00 00	 call	 ?AutoSizeColumn@CGridCtrl@@QAEHHIH@Z ; CGridCtrl::AutoSizeColumn

; 529  : 			m_GridTap.AutoSizeColumn(8);

  00090	6a 01		 push	 1
  00092	6a 00		 push	 0
  00094	6a 08		 push	 8

; 538  : 			break;
; 539  : 		}
; 540  : 	}
; 541  : }

  00096	8b ce		 mov	 ecx, esi
  00098	e8 00 00 00 00	 call	 ?AutoSizeColumn@CGridCtrl@@QAEHHIH@Z ; CGridCtrl::AutoSizeColumn
$LN2@AutoSizeCo:
  0009d	5e		 pop	 esi
  0009e	c3		 ret	 0
?AutoSizeColumns@CDlgOptimizer@@QAEXXZ ENDP		; CDlgOptimizer::AutoSizeColumns
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
;	COMDAT ?ReSize@CDlgOptimizer@@QAEXXZ
_TEXT	SEGMENT
_psztitle_Time$2 = -376					; size = 60
_psztitle_Val$3 = -316					; size = 60
_str$4 = -256						; size = 4
_this$1$ = -252						; size = 4
tv600 = -248						; size = 4
_Colnum$1$ = -244					; size = 4
_Item$5 = -240						; size = 104
_lWidth_Val$6 = -196					; size = 60
_psztitle$7 = -136					; size = 60
_lWidth$8 = -76						; size = 60
_psztitle_Index$9 = -76					; size = 60
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?ReSize@CDlgOptimizer@@QAEXXZ PROC			; CDlgOptimizer::ReSize, COMDAT
; _this$ = ecx

; 437  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?ReSize@CDlgOptimizer@@QAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 6c 01 00
	00		 sub	 esp, 364		; 0000016cH
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	56		 push	 esi
  00022	57		 push	 edi
  00023	50		 push	 eax
  00024	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00027	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002d	8b f9		 mov	 edi, ecx

; 438  : 	if(m_GridTap.GetSafeHwnd())

  0002f	8d b7 f0 09 00
	00		 lea	 esi, DWORD PTR [edi+2544]
  00035	89 b5 04 ff ff
	ff		 mov	 DWORD PTR _this$1$[ebp], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl

; 25   : 	{ return this == NULL ? NULL : m_hWnd; }

  0003b	85 f6		 test	 esi, esi
  0003d	0f 84 de 03 00
	00		 je	 $LN7@ReSize
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 438  : 	if(m_GridTap.GetSafeHwnd())

  00043	83 7e 20 00	 cmp	 DWORD PTR [esi+32], 0
  00047	0f 84 d4 03 00
	00		 je	 $LN7@ReSize

; 439  : 	{
; 440  : 		char *psztitle_Index[MAX_COL]=
; 441  : 		{"Row","","","","","","","","","ProfitFactor","",""};//;
; 442  : 		char *psztitle_Val[MAX_COL]={"Row","","", "", "", ""};//;
; 443  : 		char *psztitle_Time[MAX_COL]= {"Row","","","","","","",""};//;
; 444  : 		
; 445  : 		int lWidth_Index[MAX_COL]= {0, 100, 70, 60, 70, 60, 75, 75, 60, 80, 45, 45};
; 446  : 		int lWidth_Val[MAX_COL]={0,100, 70, 80, 70, 70};
; 447  : 		int lWidth_Time[MAX_COL]= {0, 120, 7, 75, 50, 75,75,50};
; 448  : 		
; 449  : 		char *psztitle[MAX_COL];
; 450  : 		int  lWidth[MAX_COL];
; 451  : 		switch(m_nOptimizerDiv)

  0004d	8b 87 70 11 00
	00		 mov	 eax, DWORD PTR [edi+4464]
  00053	0f 57 c0	 xorps	 xmm0, xmm0
  00056	0f 28 2d 00 00
	00 00		 movaps	 xmm5, XMMWORD PTR __xmm@0000003c000000460000006400000000
  0005d	0f 57 e4	 xorps	 xmm4, xmm4
  00060	0f 28 35 00 00
	00 00		 movaps	 xmm6, XMMWORD PTR __xmm@0000004b0000004b0000003c00000046
  00067	0f 57 c9	 xorps	 xmm1, xmm1
  0006a	0f 28 3d 00 00
	00 00		 movaps	 xmm7, XMMWORD PTR __xmm@0000002d0000002d000000500000003c
  00071	0f 57 d2	 xorps	 xmm2, xmm2
  00074	0f 28 1d 00 00
	00 00		 movaps	 xmm3, XMMWORD PTR __xmm@00000050000000460000006400000000
  0007b	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _psztitle_Index$9[ebp], OFFSET ??_C@_03JMEKIEOG@Row@
  00082	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _psztitle_Index$9[ebp+4], OFFSET ??_C@_06NEMOAOGB@?$MA?$PM?$LH?$KL?$LI?m@
  00089	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _psztitle_Index$9[ebp+8], OFFSET ??_C@_06GNECPJOA@?C?Q?$LM?U?$MA?M@
  00090	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR _psztitle_Index$9[ebp+12], OFFSET ??_C@_08IANCNINB@?F?r?$LB?U?$LM?U?$MA?M@
  00097	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _psztitle_Index$9[ebp+16], OFFSET ??_C@_06HMHBOMDL@?C?Q?$MA?L?$MA?M@
  0009e	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _psztitle_Index$9[ebp+20], OFFSET ??_C@_06MLIEOKGJ@?C?Q?$LM?U?$LN?G@
  000a5	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _psztitle_Index$9[ebp+24], OFFSET ??_C@_08MKACKNJD@?C?V?$LE?k?$MA?L?$MA?M@
  000ac	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _psztitle_Index$9[ebp+28], OFFSET ??_C@_08HNPHKLMB@?C?V?$LE?k?$LM?U?$LN?G@
  000b3	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _psztitle_Index$9[ebp+32], OFFSET ??_C@_06FDKHGHHF@?$LM?v?$MA?M?$LH?$PM@
  000ba	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _psztitle_Index$9[ebp+36], OFFSET ??_C@_0N@HGEBBOLI@ProfitFactor@
  000c1	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _psztitle_Index$9[ebp+40], OFFSET ??_C@_04HFNGKEOO@?$LN?B?$LH?$PM@
  000c8	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _psztitle_Index$9[ebp+44], OFFSET ??_C@_04BPIEHLPP@?$LA?E?$LH?$KB@
  000cf	c7 85 c4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _psztitle_Val$3[ebp], OFFSET ??_C@_03JMEKIEOG@Row@
  000d9	c7 85 c8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _psztitle_Val$3[ebp+4], OFFSET ??_C@_06GNECPJOA@?C?Q?$LM?U?$MA?M@
  000e3	c7 85 cc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _psztitle_Val$3[ebp+8], OFFSET ??_C@_08IANCNINB@?F?r?$LB?U?$LM?U?$MA?M@
  000ed	c7 85 d0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _psztitle_Val$3[ebp+12], OFFSET ??_C@_06HMHBOMDL@?C?Q?$MA?L?$MA?M@
  000f7	c7 85 d4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _psztitle_Val$3[ebp+16], OFFSET ??_C@_06MLIEOKGJ@?C?Q?$LM?U?$LN?G@
  00101	c7 85 d8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _psztitle_Val$3[ebp+20], OFFSET ??_C@_08MKACKNJD@?C?V?$LE?k?$MA?L?$MA?M@
  0010b	c7 85 88 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _psztitle_Time$2[ebp], OFFSET ??_C@_03JMEKIEOG@Row@
  00115	c7 85 8c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _psztitle_Time$2[ebp+4], OFFSET ??_C@_06MKCPLBEP@?A?v?G?$KF?$LI?m@
  0011f	c7 85 90 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _psztitle_Time$2[ebp+8], OFFSET ??_C@_02DINIKGF@?$LK?$MA@
  00129	c7 85 94 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _psztitle_Time$2[ebp+12], OFFSET ??_C@_06GNECPJOA@?C?Q?$LM?U?$MA?M@
  00133	c7 85 98 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _psztitle_Time$2[ebp+16], OFFSET ??_C@_08IANCNINB@?F?r?$LB?U?$LM?U?$MA?M@
  0013d	c7 85 9c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _psztitle_Time$2[ebp+20], OFFSET ??_C@_06HMHBOMDL@?C?Q?$MA?L?$MA?M@
  00147	c7 85 a0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _psztitle_Time$2[ebp+24], OFFSET ??_C@_06MLIEOKGJ@?C?Q?$LM?U?$LN?G@
  00151	c7 85 a4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _psztitle_Time$2[ebp+28], OFFSET ??_C@_08MKACKNJD@?C?V?$LE?k?$MA?L?$MA?M@
  0015b	c7 85 4c ff ff
	ff 46 00 00 00	 mov	 DWORD PTR _lWidth_Val$6[ebp+16], 70 ; 00000046H
  00165	c7 85 50 ff ff
	ff 46 00 00 00	 mov	 DWORD PTR _lWidth_Val$6[ebp+20], 70 ; 00000046H
  0016f	0f 11 85 dc fe
	ff ff		 movups	 XMMWORD PTR _psztitle_Val$3[ebp+24], xmm0
  00176	0f 11 85 ec fe
	ff ff		 movups	 XMMWORD PTR _psztitle_Val$3[ebp+40], xmm0
  0017d	0f 11 85 54 ff
	ff ff		 movups	 XMMWORD PTR _lWidth_Val$6[ebp+24], xmm0
  00184	0f 11 85 64 ff
	ff ff		 movups	 XMMWORD PTR _lWidth_Val$6[ebp+40], xmm0
  0018b	2d e9 03 00 00	 sub	 eax, 1001		; 000003e9H
  00190	0f 84 a9 00 00
	00		 je	 $LN8@ReSize
  00196	83 e8 01	 sub	 eax, 1
  00199	74 4f		 je	 SHORT $LN9@ReSize
  0019b	83 e8 01	 sub	 eax, 1
  0019e	0f 85 dd 00 00
	00		 jne	 $LN2@ReSize

; 461  : 		case TIME_OPTIMIZER:
; 462  : 			memcpy(psztitle,psztitle_Time,sizeof(psztitle_Time));

  001a4	0f 10 85 88 fe
	ff ff		 movups	 xmm0, XMMWORD PTR _psztitle_Time$2[ebp]
  001ab	0f 11 4d 98	 movups	 XMMWORD PTR _psztitle$7[ebp+32], xmm1
  001af	0f 11 85 78 ff
	ff ff		 movups	 XMMWORD PTR _psztitle$7[ebp], xmm0
  001b6	0f 10 85 98 fe
	ff ff		 movups	 xmm0, XMMWORD PTR _psztitle_Time$2[ebp+16]
  001bd	66 0f d6 4d a8	 movq	 QWORD PTR _psztitle$7[ebp+48], xmm1
  001c2	0f 11 45 88	 movups	 XMMWORD PTR _psztitle$7[ebp+16], xmm0

; 463  : 			memcpy(lWidth, lWidth_Time, sizeof(lWidth_Time));		

  001c6	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@0000004b000000070000007800000000
  001cd	0f 11 45 b4	 movups	 XMMWORD PTR _lWidth$8[ebp], xmm0
  001d1	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@000000320000004b0000004b00000032
  001d8	0f 11 45 c4	 movups	 XMMWORD PTR _lWidth$8[ebp+16], xmm0
  001dc	0f 11 55 d4	 movups	 XMMWORD PTR _lWidth$8[ebp+32], xmm2
  001e0	66 0f d6 55 e4	 movq	 QWORD PTR _lWidth$8[ebp+48], xmm2
  001e5	e9 89 00 00 00	 jmp	 $LN44@ReSize
$LN9@ReSize:

; 456  : 			break;
; 457  : 		case VAL_OPTIMIZER:
; 458  : 			memcpy(psztitle,psztitle_Val,sizeof(psztitle_Val));

  001ea	0f 10 85 c4 fe
	ff ff		 movups	 xmm0, XMMWORD PTR _psztitle_Val$3[ebp]

; 459  : 			memcpy(lWidth, lWidth_Val, sizeof(lWidth_Val));		

  001f1	0f 11 5d b4	 movups	 XMMWORD PTR _lWidth$8[ebp], xmm3
  001f5	0f 11 85 78 ff
	ff ff		 movups	 XMMWORD PTR _psztitle$7[ebp], xmm0
  001fc	0f 10 85 d4 fe
	ff ff		 movups	 xmm0, XMMWORD PTR _psztitle_Val$3[ebp+16]
  00203	0f 11 45 88	 movups	 XMMWORD PTR _psztitle$7[ebp+16], xmm0
  00207	0f 10 85 e4 fe
	ff ff		 movups	 xmm0, XMMWORD PTR _psztitle_Val$3[ebp+32]
  0020e	0f 11 45 98	 movups	 XMMWORD PTR _psztitle$7[ebp+32], xmm0
  00212	f3 0f 7e 85 f4
	fe ff ff	 movq	 xmm0, QWORD PTR _psztitle_Val$3[ebp+48]
  0021a	66 0f d6 45 a8	 movq	 QWORD PTR _psztitle$7[ebp+48], xmm0
  0021f	0f 10 85 4c ff
	ff ff		 movups	 xmm0, XMMWORD PTR _lWidth_Val$6[ebp+16]
  00226	0f 11 45 c4	 movups	 XMMWORD PTR _lWidth$8[ebp+16], xmm0
  0022a	0f 10 85 5c ff
	ff ff		 movups	 xmm0, XMMWORD PTR _lWidth_Val$6[ebp+32]
  00231	0f 11 45 d4	 movups	 XMMWORD PTR _lWidth$8[ebp+32], xmm0
  00235	f3 0f 7e 85 6c
	ff ff ff	 movq	 xmm0, QWORD PTR _lWidth_Val$6[ebp+48]

; 460  : 			break;

  0023d	eb 2f		 jmp	 SHORT $LN45@ReSize
$LN8@ReSize:

; 452  : 		{
; 453  : 		case INDEX_OPTIMIZER:
; 454  : 			memcpy(psztitle,psztitle_Index,sizeof(psztitle_Index));

  0023f	0f 10 45 b4	 movups	 xmm0, XMMWORD PTR _psztitle_Index$9[ebp]
  00243	66 0f d6 65 a8	 movq	 QWORD PTR _psztitle$7[ebp+48], xmm4
  00248	0f 11 85 78 ff
	ff ff		 movups	 XMMWORD PTR _psztitle$7[ebp], xmm0
  0024f	0f 10 45 c4	 movups	 xmm0, XMMWORD PTR _psztitle_Index$9[ebp+16]

; 455  : 			memcpy(lWidth, lWidth_Index, sizeof(lWidth_Index));		

  00253	0f 11 6d b4	 movups	 XMMWORD PTR _lWidth$8[ebp], xmm5
  00257	0f 11 45 88	 movups	 XMMWORD PTR _psztitle$7[ebp+16], xmm0
  0025b	0f 10 45 d4	 movups	 xmm0, XMMWORD PTR _psztitle_Index$9[ebp+32]
  0025f	0f 11 75 c4	 movups	 XMMWORD PTR _lWidth$8[ebp+16], xmm6
  00263	0f 11 45 98	 movups	 XMMWORD PTR _psztitle$7[ebp+32], xmm0
  00267	0f 11 7d d4	 movups	 XMMWORD PTR _lWidth$8[ebp+32], xmm7
  0026b	0f 57 c0	 xorps	 xmm0, xmm0
$LN45@ReSize:

; 464  : 			break;
; 465  : 		}
; 466  : 		
; 467  : 		CString str;

  0026e	66 0f d6 45 e4	 movq	 QWORD PTR _lWidth$8[ebp+48], xmm0
$LN44@ReSize:
  00273	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _psztitle$7[ebp+56], 0
  0027a	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _lWidth$8[ebp+56], 0
$LN2@ReSize:
  00281	8d 8d 00 ff ff
	ff		 lea	 ecx, DWORD PTR _str$4[ebp]
  00287	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0028d	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR _Item$5[ebp+100]
  00293	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0029a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 468  : 		GV_ITEM Item;
; 469  : 		int Colnum =0;
; 470  : 		if(m_nOptimizerDiv!= VAL_OPTIMIZER || m_pDlgTimeSetup ==NULL)

  002a0	81 bf 70 11 00
	00 ea 03 00 00	 cmp	 DWORD PTR [edi+4464], 1002 ; 000003eaH
  002aa	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  002ae	75 28		 jne	 SHORT $LN40@ReSize
  002b0	83 bf 2c 05 00
	00 00		 cmp	 DWORD PTR [edi+1324], 0
  002b7	74 1f		 je	 SHORT $LN40@ReSize

; 472  : 		else// //
; 473  : 		{
; 474  : 			Colnum = 6 + m_STValNum;

  002b9	8b 87 b0 11 00
	00		 mov	 eax, DWORD PTR [edi+4528]

; 475  : 			m_GridTap.SetColumnCount(Colnum);

  002bf	8b ce		 mov	 ecx, esi
  002c1	83 c0 06	 add	 eax, 6
  002c4	50		 push	 eax
  002c5	89 85 0c ff ff
	ff		 mov	 DWORD PTR _Colnum$1$[ebp], eax
  002cb	e8 00 00 00 00	 call	 ?SetColumnCount@CGridCtrl@@QAEHH@Z ; CGridCtrl::SetColumnCount
  002d0	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _Colnum$1$[ebp]
  002d6	eb 0c		 jmp	 SHORT $LN12@ReSize
$LN40@ReSize:

; 471  : 			Colnum = m_GridTap.GetColumnCount();

  002d8	8b 87 10 0b 00
	00		 mov	 eax, DWORD PTR [edi+2832]
  002de	89 85 0c ff ff
	ff		 mov	 DWORD PTR _Colnum$1$[ebp], eax
$LN12@ReSize:

; 476  : 		}
; 477  : 		for (int col = 0; col < Colnum; col++)

  002e4	33 f6		 xor	 esi, esi
  002e6	85 c0		 test	 eax, eax
  002e8	0f 8e 0e 01 00
	00		 jle	 $LN41@ReSize
  002ee	33 c9		 xor	 ecx, ecx
  002f0	89 8d 08 ff ff
	ff		 mov	 DWORD PTR tv600[ebp], ecx
$LL6@ReSize:

; 478  : 		{
; 479  : 			
; 480  :     		Item.mask = GVIF_TEXT;
; 481  : 			Item.row = 0;
; 482  : 			Item.col = col;
; 483  : 			if(m_nOptimizerDiv == VAL_OPTIMIZER && m_pDlgTimeSetup!=NULL)

  002f6	81 bf 70 11 00
	00 ea 03 00 00	 cmp	 DWORD PTR [edi+4464], 1002 ; 000003eaH
  00300	c7 85 18 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR _Item$5[ebp+8], 1
  0030a	c7 85 10 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _Item$5[ebp], 0
  00314	89 b5 14 ff ff
	ff		 mov	 DWORD PTR _Item$5[ebp+4], esi
  0031a	75 69		 jne	 SHORT $LN14@ReSize
  0031c	8b 87 2c 05 00
	00		 mov	 eax, DWORD PTR [edi+1324]
  00322	85 c0		 test	 eax, eax
  00324	74 5f		 je	 SHORT $LN14@ReSize

; 484  : 			{
; 485  : 				if( col < m_STValNum)

  00326	8b 97 b0 11 00
	00		 mov	 edx, DWORD PTR [edi+4528]
  0032c	3b f2		 cmp	 esi, edx
  0032e	7d 30		 jge	 SHORT $LN16@ReSize
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 288  : 	if(nIndex >= 0 && nIndex < m_nSize)

  00330	85 c9		 test	 ecx, ecx
  00332	0f 88 04 01 00
	00		 js	 $LN29@ReSize
  00338	3b b0 dc 00 00
	00		 cmp	 esi, DWORD PTR [eax+220]
  0033e	0f 8d f8 00 00
	00		 jge	 $LN29@ReSize

; 289  : 		return m_pData[nIndex];

  00344	8b 80 d8 00 00
	00		 mov	 eax, DWORD PTR [eax+216]
  0034a	03 c1		 add	 eax, ecx
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 487  : 					Item.strText = m_pDlgTimeSetup->m_ValueOptimizerArray.GetAt(col).nTitle;

  0034c	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR _Item$5[ebp+100]
  00352	50		 push	 eax
  00353	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z

; 488  : 					m_GridTap.SetColumnWidth(col,65);

  00359	b8 41 00 00 00	 mov	 eax, 65			; 00000041H

; 489  : 				}

  0035e	eb 3c		 jmp	 SHORT $LN15@ReSize
$LN16@ReSize:

; 490  : 				else
; 491  : 				{
; 492  : 					Item.strText = psztitle[col-m_STValNum];

  00360	8b c6		 mov	 eax, esi
  00362	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR _Item$5[ebp+100]
  00368	2b c2		 sub	 eax, edx
  0036a	ff b4 85 78 ff
	ff ff		 push	 DWORD PTR _psztitle$7[ebp+eax*4]
  00371	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z

; 493  : 					m_GridTap.SetColumnWidth(col,lWidth[col-m_STValNum]);

  00377	8b c6		 mov	 eax, esi
  00379	2b 87 b0 11 00
	00		 sub	 eax, DWORD PTR [edi+4528]
  0037f	8b 44 85 b4	 mov	 eax, DWORD PTR _lWidth$8[ebp+eax*4]

; 494  : 				}
; 495  : 			}

  00383	eb 17		 jmp	 SHORT $LN15@ReSize
$LN14@ReSize:

; 496  : 			else
; 497  : 			{
; 498  : 				Item.strText = psztitle[col];

  00385	ff b4 b5 78 ff
	ff ff		 push	 DWORD PTR _psztitle$7[ebp+esi*4]
  0038c	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR _Item$5[ebp+100]
  00392	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z

; 499  : 				m_GridTap.SetColumnWidth(col,lWidth[col]);

  00398	8b 44 b5 b4	 mov	 eax, DWORD PTR _lWidth$8[ebp+esi*4]
$LN15@ReSize:

; 500  : 			}
; 501  : 			Item.crBkClr = RGB(230,239,247);//RGB(175,194,221); // or - m_GridSTList.SetItemBkColour(row, col, clr);

  0039c	50		 push	 eax
  0039d	56		 push	 esi
  0039e	8d 8f f0 09 00
	00		 lea	 ecx, DWORD PTR [edi+2544]
  003a4	e8 00 00 00 00	 call	 ?SetColumnWidth@CGridCtrl@@QAEHHH@Z ; CGridCtrl::SetColumnWidth

; 502  : 			Item.crFgClr = RGB(51,51,51);    // or - m_GridSTList.SetItemFgColour(row, col, RGB(255,0,0));				    
; 503  : 			Item.nFormat = DT_CENTER;
; 504  : 			Item.mask    |= (GVIF_BKCLR|GVIF_FGCLR|GVIF_FORMAT);

  003a9	83 8d 18 ff ff
	ff 70		 or	 DWORD PTR _Item$5[ebp+8], 112 ; 00000070H

; 505  : 			
; 506  : 			m_GridTap.SetItem(&Item);

  003b0	8d 85 10 ff ff
	ff		 lea	 eax, DWORD PTR _Item$5[ebp]
  003b6	50		 push	 eax
  003b7	8d 8f f0 09 00
	00		 lea	 ecx, DWORD PTR [edi+2544]
  003bd	c7 85 28 ff ff
	ff e6 ef f7 00	 mov	 DWORD PTR _Item$5[ebp+24], 16248806 ; 00f7efe6H
  003c7	c7 85 2c ff ff
	ff 33 33 33 00	 mov	 DWORD PTR _Item$5[ebp+28], 3355443 ; 00333333H
  003d1	c7 85 20 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR _Item$5[ebp+16], 1
  003db	e8 00 00 00 00	 call	 ?SetItem@CGridCtrl@@QAEHPBU_GV_ITEM@@@Z ; CGridCtrl::SetItem
  003e0	8b 8d 08 ff ff
	ff		 mov	 ecx, DWORD PTR tv600[ebp]
  003e6	46		 inc	 esi
  003e7	83 c1 38	 add	 ecx, 56			; 00000038H
  003ea	89 8d 08 ff ff
	ff		 mov	 DWORD PTR tv600[ebp], ecx
  003f0	3b b5 0c ff ff
	ff		 cmp	 esi, DWORD PTR _Colnum$1$[ebp]
  003f6	0f 8c fa fe ff
	ff		 jl	 $LL6@ReSize
$LN41@ReSize:

; 507  : 
; 508  : 		}
; 509  :   		m_GridTap.ExpandColumnsToFit();	

  003fc	8b 8d 04 ff ff
	ff		 mov	 ecx, DWORD PTR _this$1$[ebp]
  00402	6a 01		 push	 1
  00404	e8 00 00 00 00	 call	 ?ExpandColumnsToFit@CGridCtrl@@QAEXH@Z ; CGridCtrl::ExpandColumnsToFit
  00409	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR _Item$5[ebp+100]
  0040f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 510  : 	}

  00415	8d 8d 00 ff ff
	ff		 lea	 ecx, DWORD PTR _str$4[ebp]
  0041b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$LN7@ReSize:

; 512  : }

  00421	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00424	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0042b	59		 pop	 ecx
  0042c	5f		 pop	 edi
  0042d	5e		 pop	 esi
  0042e	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00431	33 cd		 xor	 ecx, ebp
  00433	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00438	8b e5		 mov	 esp, ebp
  0043a	5d		 pop	 ebp
  0043b	c3		 ret	 0
$LN29@ReSize:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 290  : 	AfxThrowInvalidArgException();

  0043c	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN43@ReSize:
  00441	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ReSize@CDlgOptimizer@@QAEXXZ$0:
  00000	8d 8d 00 ff ff
	ff		 lea	 ecx, DWORD PTR _str$4[ebp]
  00006	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?ReSize@CDlgOptimizer@@QAEXXZ$1:
  0000c	8d 8d 10 ff ff
	ff		 lea	 ecx, DWORD PTR _Item$5[ebp]
  00012	e9 00 00 00 00	 jmp	 ??1_GV_ITEM@@QAE@XZ
  00017	cc		 int	 3
  00018	cc		 int	 3
  00019	cc		 int	 3
  0001a	cc		 int	 3
  0001b	cc		 int	 3
__ehhandler$?ReSize@CDlgOptimizer@@QAEXXZ:
  0001c	90		 npad	 1
  0001d	90		 npad	 1
  0001e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00022	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00025	8b 8a 88 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-376]
  0002b	33 c8		 xor	 ecx, eax
  0002d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00032	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00035	33 c8		 xor	 ecx, eax
  00037	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?ReSize@CDlgOptimizer@@QAEXXZ
  00041	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?ReSize@CDlgOptimizer@@QAEXXZ ENDP			; CDlgOptimizer::ReSize
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
;	COMDAT ?InitCodeInfo@CDlgOptimizer@@QAEXXZ
_TEXT	SEGMENT
?InitCodeInfo@CDlgOptimizer@@QAEXXZ PROC		; CDlgOptimizer::InitCodeInfo, COMDAT
; _this$ = ecx

; 384  : }

  00000	c2 00 00	 ret	 0
?InitCodeInfo@CDlgOptimizer@@QAEXXZ ENDP		; CDlgOptimizer::InitCodeInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\GridCtrl_src\GridCtrl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin1.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
;	COMDAT ?InitGrid@CDlgOptimizer@@QAEXXZ
_TEXT	SEGMENT
_rect1$1 = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
?InitGrid@CDlgOptimizer@@QAEXXZ PROC			; CDlgOptimizer::InitGrid, COMDAT
; _this$ = ecx

; 397  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b f1		 mov	 esi, ecx
  00013	57		 push	 edi

; 399  : 	if(!m_GridTap.GetSafeHwnd())

  00014	8d be f0 09 00
	00		 lea	 edi, DWORD PTR [esi+2544]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl

; 25   : 	{ return this == NULL ? NULL : m_hWnd; }

  0001a	85 ff		 test	 edi, edi
  0001c	74 0a		 je	 SHORT $LN26@InitGrid
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 399  : 	if(!m_GridTap.GetSafeHwnd())

  0001e	83 7f 20 00	 cmp	 DWORD PTR [edi+32], 0
  00022	0f 85 3e 01 00
	00		 jne	 $LN2@InitGrid
$LN26@InitGrid:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h

; 698  : 	::InflateRect(this, -x, -y);

  00028	6a ec		 push	 -20			; ffffffecH
  0002a	6a 00		 push	 0
  0002c	8d 45 ec	 lea	 eax, DWORD PTR _rect1$1[ebp]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 402  : 		rect1.left = 193;

  0002f	c7 45 ec c1 00
	00 00		 mov	 DWORD PTR _rect1$1[ebp], 193 ; 000000c1H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h

; 698  : 	::InflateRect(this, -x, -y);

  00036	50		 push	 eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 403  : 		rect1.right = 860;

  00037	c7 45 f4 5c 03
	00 00		 mov	 DWORD PTR _rect1$1[ebp+8], 860 ; 0000035cH

; 404  : 		rect1.bottom = 195;

  0003e	c7 45 f8 c3 00
	00 00		 mov	 DWORD PTR _rect1$1[ebp+12], 195 ; 000000c3H

; 405  : 		rect1.top = -20;

  00045	c7 45 f0 ec ff
	ff ff		 mov	 DWORD PTR _rect1$1[ebp+4], -20 ; ffffffecH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h

; 698  : 	::InflateRect(this, -x, -y);

  0004c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InflateRect@12
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 408  : 		m_GridTap.Create(rect1,this,IDC_GRID2,WS_CHILD | WS_TABSTOP | WS_VISIBLE   );

  00052	68 00 00 01 50	 push	 1342242816		; 50010000H
  00057	68 11 01 00 00	 push	 273			; 00000111H
  0005c	56		 push	 esi
  0005d	8d 45 ec	 lea	 eax, DWORD PTR _rect1$1[ebp]
  00060	8b cf		 mov	 ecx, edi
  00062	50		 push	 eax
  00063	e8 00 00 00 00	 call	 ?Create@CGridCtrl@@QAEHABUtagRECT@@PAVCWnd@@IK@Z ; CGridCtrl::Create

; 410  : 		m_GridTap.GetDefaultCell(FALSE, FALSE)->SetBackClr(RGB(0xFF, 0xFF, 0xE0));

  00068	8b 86 4c 0b 00
	00		 mov	 eax, DWORD PTR [esi+2892]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\GridCtrl_src\GridCtrl.h

; 795  :     return (CGridCellBase*) &m_cellDefault;

  0006e	8d 8e 4c 0b 00
	00		 lea	 ecx, DWORD PTR [esi+2892]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 410  : 		m_GridTap.GetDefaultCell(FALSE, FALSE)->SetBackClr(RGB(0xFF, 0xFF, 0xE0));

  00074	68 ff ff e0 00	 push	 14745599		; 00e0ffffH
  00079	ff 50 2c	 call	 DWORD PTR [eax+44]

; 411  : 		
; 412  : 		m_GridTap.SetGridLineColor(RGB(204,204,204));
; 413  : 		if(m_nOptimizerDiv == INDEX_OPTIMIZER)

  0007c	8b 86 70 11 00
	00		 mov	 eax, DWORD PTR [esi+4464]
  00082	c7 86 7c 0a 00
	00 cc cc cc 00	 mov	 DWORD PTR [esi+2684], 13421772 ; 00ccccccH
  0008c	3d e9 03 00 00	 cmp	 eax, 1001		; 000003e9H
  00091	75 0f		 jne	 SHORT $LN3@InitGrid

; 414  : 			m_GridTap.SetColumnCount(12);

  00093	6a 0c		 push	 12			; 0000000cH
  00095	8b cf		 mov	 ecx, edi
  00097	e8 00 00 00 00	 call	 ?SetColumnCount@CGridCtrl@@QAEHH@Z ; CGridCtrl::SetColumnCount
  0009c	8b 86 70 11 00
	00		 mov	 eax, DWORD PTR [esi+4464]
$LN3@InitGrid:

; 415  : 		if(m_nOptimizerDiv == TIME_OPTIMIZER)

  000a2	3d eb 03 00 00	 cmp	 eax, 1003		; 000003ebH
  000a7	75 0f		 jne	 SHORT $LN4@InitGrid

; 416  : 			m_GridTap.SetColumnCount(8);

  000a9	6a 08		 push	 8
  000ab	8b cf		 mov	 ecx, edi
  000ad	e8 00 00 00 00	 call	 ?SetColumnCount@CGridCtrl@@QAEHH@Z ; CGridCtrl::SetColumnCount
  000b2	8b 86 70 11 00
	00		 mov	 eax, DWORD PTR [esi+4464]
$LN4@InitGrid:

; 417  : 		if(m_nOptimizerDiv == VAL_OPTIMIZER)

  000b8	3d ea 03 00 00	 cmp	 eax, 1002		; 000003eaH
  000bd	75 09		 jne	 SHORT $LN5@InitGrid

; 418  : 			m_GridTap.SetColumnCount(6);

  000bf	6a 06		 push	 6
  000c1	8b cf		 mov	 ecx, edi
  000c3	e8 00 00 00 00	 call	 ?SetColumnCount@CGridCtrl@@QAEHH@Z ; CGridCtrl::SetColumnCount
$LN5@InitGrid:

; 419  : 		m_GridTap.SetFixedRowCount(1);

  000c8	6a 01		 push	 1
  000ca	8b cf		 mov	 ecx, edi
  000cc	e8 00 00 00 00	 call	 ?SetFixedRowCount@CGridCtrl@@QAEHH@Z ; CGridCtrl::SetFixedRowCount

; 420  : 		m_GridTap.SetColumnResize(TRUE);
; 421  : 		m_GridTap.SetRowCount(1);

  000d1	6a 01		 push	 1
  000d3	8b cf		 mov	 ecx, edi
  000d5	c7 86 e8 0c 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+3304], 1
  000df	e8 00 00 00 00	 call	 ?SetRowCount@CGridCtrl@@QAEHH@Z ; CGridCtrl::SetRowCount

; 422  : 		m_GridTap.SetListMode();

  000e4	6a 01		 push	 1
  000e6	8b cf		 mov	 ecx, edi
  000e8	e8 00 00 00 00	 call	 ?SetListMode@CGridCtrl@@QAEXH@Z ; CGridCtrl::SetListMode

; 423  : 		m_GridTap.SetRowHeight(0,20);

  000ed	6a 14		 push	 20			; 00000014H
  000ef	6a 00		 push	 0
  000f1	8b cf		 mov	 ecx, edi
  000f3	e8 00 00 00 00	 call	 ?SetRowHeight@CGridCtrl@@QAEHHH@Z ; CGridCtrl::SetRowHeight

; 424  : 		m_GridTap.SetBkColor(RGB(255,255,255));		
; 425  : 		m_GridTap.SetEditable(FALSE);
; 426  : 		m_GridTap.EnableTitleTips(FALSE);
; 427  : 		m_GridTap.SetTrackFocusCell(FALSE);
; 428  : 		m_GridTap.SetSingleColSelection(FALSE);
; 429  : 		m_GridTap.SetSingleRowSelection();
; 430  : 		m_GridTap.SetFixedRowSelection(FALSE);
; 431  : 		m_GridTap.SetFixedColumnSelection(FALSE);
; 432  : 		m_GridTap.SetFont(&m_Font);

  000f8	8d 86 f0 12 00
	00		 lea	 eax, DWORD PTR [esi+4848]
  000fe	c7 86 78 0a 00
	00 ff ff ff 00	 mov	 DWORD PTR [esi+2680], 16777215 ; 00ffffffH
  00108	c7 86 a8 0a 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+2728], 0
  00112	c7 86 dc 0a 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+2780], 0
  0011c	c7 86 fc 0a 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+2812], 0
  00126	c7 86 bc 0a 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+2748], 0
  00130	c7 86 b8 0a 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+2744], 1
  0013a	c7 86 c8 0a 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+2760], 0
  00144	c7 86 cc 0a 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+2764], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin1.inl

; 68   : 	{ return this == NULL ? NULL : m_hObject; }

  0014e	85 c0		 test	 eax, eax
  00150	74 03		 je	 SHORT $LN25@InitGrid
$LN24@InitGrid:
  00152	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
$LN25@InitGrid:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl

; 43   : 	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, WM_SETFONT, (WPARAM)pFont->GetSafeHandle(), bRedraw); }

  00155	6a 01		 push	 1
  00157	50		 push	 eax
  00158	6a 30		 push	 48			; 00000030H
  0015a	ff b6 10 0a 00
	00		 push	 DWORD PTR [esi+2576]
  00160	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16
$LN2@InitGrid:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 434  : }

  00166	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00169	5f		 pop	 edi
  0016a	33 cd		 xor	 ecx, ebp
  0016c	5e		 pop	 esi
  0016d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00172	8b e5		 mov	 esp, ebp
  00174	5d		 pop	 ebp
  00175	c3		 ret	 0
?InitGrid@CDlgOptimizer@@QAEXXZ ENDP			; CDlgOptimizer::InitGrid
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
;	COMDAT ?SetSTMessageType@CDlgOptimizer@@QAEXF@Z
_TEXT	SEGMENT
_Smt$ = 8						; size = 2
?SetSTMessageType@CDlgOptimizer@@QAEXF@Z PROC		; CDlgOptimizer::SetSTMessageType, COMDAT
; _this$ = ecx

; 1602 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1603 : 	m_STMessageType = Smt;

  00003	66 8b 45 08	 mov	 ax, WORD PTR _Smt$[ebp]
  00007	66 89 81 28 05
	00 00		 mov	 WORD PTR [ecx+1320], ax

; 1604 : }

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
?SetSTMessageType@CDlgOptimizer@@QAEXF@Z ENDP		; CDlgOptimizer::SetSTMessageType
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
;	COMDAT ?FormLoad@CDlgOptimizer@@QAEXXZ
_TEXT	SEGMENT
?FormLoad@CDlgOptimizer@@QAEXXZ PROC			; CDlgOptimizer::FormLoad, COMDAT
; _this$ = ecx

; 127  : }

  00000	c2 00 00	 ret	 0
?FormLoad@CDlgOptimizer@@QAEXXZ ENDP			; CDlgOptimizer::FormLoad
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
;	COMDAT ?FormInit@CDlgOptimizer@@QAEXXZ
_TEXT	SEGMENT
?FormInit@CDlgOptimizer@@QAEXXZ PROC			; CDlgOptimizer::FormInit, COMDAT
; _this$ = ecx

; 123  : }

  00000	c2 00 00	 ret	 0
?FormInit@CDlgOptimizer@@QAEXXZ ENDP			; CDlgOptimizer::FormInit
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
;	COMDAT ?DestoryTImeSetupDlg@CDlgOptimizer@@QAEXXZ
_TEXT	SEGMENT
?DestoryTImeSetupDlg@CDlgOptimizer@@QAEXXZ PROC		; CDlgOptimizer::DestoryTImeSetupDlg, COMDAT
; _this$ = ecx

; 1758 : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1759 : 	if(m_pDlgTimeSetup) delete m_pDlgTimeSetup;

  00003	8b 8e 2c 05 00
	00		 mov	 ecx, DWORD PTR [esi+1324]
  00009	85 c9		 test	 ecx, ecx
  0000b	74 07		 je	 SHORT $LN6@DestoryTIm
  0000d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000f	6a 01		 push	 1
  00011	ff 50 04	 call	 DWORD PTR [eax+4]
$LN6@DestoryTIm:

; 1760 : 	m_pDlgTimeSetup=NULL;
; 1761 : }

  00014	c7 86 2c 05 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+1324], 0
  0001e	5e		 pop	 esi
  0001f	c3		 ret	 0
?DestoryTImeSetupDlg@CDlgOptimizer@@QAEXXZ ENDP		; CDlgOptimizer::DestoryTImeSetupDlg
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
;	COMDAT ?CreateTImeSetupDlg@CDlgOptimizer@@QAEXXZ
_TEXT	SEGMENT
$T2 = -36						; size = 4
_rect$3 = -32						; size = 16
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?CreateTImeSetupDlg@CDlgOptimizer@@QAEXXZ PROC		; CDlgOptimizer::CreateTImeSetupDlg, COMDAT
; _this$ = ecx

; 1693 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?CreateTImeSetupDlg@CDlgOptimizer@@QAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 18	 sub	 esp, 24			; 00000018H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	56		 push	 esi
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	8b f1		 mov	 esi, ecx

; 1694 : 
; 1695 : 	switch(m_nOptimizerDiv) {

  0002b	8b 86 70 11 00
	00		 mov	 eax, DWORD PTR [esi+4464]
  00031	2d e9 03 00 00	 sub	 eax, 1001		; 000003e9H
  00036	0f 84 ea 01 00
	00		 je	 $LN4@CreateTIme
  0003c	83 e8 01	 sub	 eax, 1
  0003f	0f 84 cc 00 00
	00		 je	 $LN5@CreateTIme
  00045	83 e8 01	 sub	 eax, 1
  00048	74 13		 je	 SHORT $LN7@CreateTIme

; 1751 : 	default:
; 1752 : 		AfxMessageBox("  .");

  0004a	6a 00		 push	 0
  0004c	6a 00		 push	 0
  0004e	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@NADBMJJJ@?C?V?$MA?$PL?H?$KN?$LA?$KB?5?$MA?$NP?$LI?x?5?$LM?$LB?E?C?$LF?G?$LO?z?$LN?$MA?$LE?O?$LE?Y?4@
  00053	e8 00 00 00 00	 call	 ?AfxMessageBox@@YGHPBDII@Z ; AfxMessageBox
  00058	e9 45 02 00 00	 jmp	 $LN2@CreateTIme
$LN7@CreateTIme:

; 1728 : 				GetDlgItem(IDC_STATIC_END)->ShowWindow(SW_HIDE);
; 1729 : 				GetDlgItem(IDC_STATIC_ADV)->ShowWindow(SW_HIDE);
; 1730 : 				GetDlgItem(IDC_EDIT_START)->ShowWindow(SW_HIDE);
; 1731 : 				GetDlgItem(IDC_EDIT_ADV)->ShowWindow(SW_HIDE);
; 1732 : 				GetDlgItem(IDC_EDIT_END)->ShowWindow(SW_HIDE);
; 1733 : 
; 1734 : 			}
; 1735 : 		}
; 1736 : 		break;
; 1737 : 	case TIME_OPTIMIZER://Default ..
; 1738 : 		{
; 1739 : 			GetDlgItem(IDC_STATIC_START)->ShowWindow(SW_SHOW);

  0005d	6a 05		 push	 5
  0005f	68 65 33 00 00	 push	 13157			; 00003365H
  00064	e8 00 00 00 00	 call	 ?GetDlgItem@CWnd@@QBEPAV1@H@Z ; CWnd::GetDlgItem
  00069	8b c8		 mov	 ecx, eax
  0006b	e8 00 00 00 00	 call	 ?ShowWindow@CWnd@@QAEHH@Z ; CWnd::ShowWindow

; 1740 : 			GetDlgItem(IDC_STATIC_END)->ShowWindow(SW_SHOW);

  00070	6a 05		 push	 5
  00072	68 67 33 00 00	 push	 13159			; 00003367H
  00077	8b ce		 mov	 ecx, esi
  00079	e8 00 00 00 00	 call	 ?GetDlgItem@CWnd@@QBEPAV1@H@Z ; CWnd::GetDlgItem
  0007e	8b c8		 mov	 ecx, eax
  00080	e8 00 00 00 00	 call	 ?ShowWindow@CWnd@@QAEHH@Z ; CWnd::ShowWindow

; 1741 : 			GetDlgItem(IDC_STATIC_ADV)->ShowWindow(SW_SHOW);

  00085	6a 05		 push	 5
  00087	68 6a 33 00 00	 push	 13162			; 0000336aH
  0008c	8b ce		 mov	 ecx, esi
  0008e	e8 00 00 00 00	 call	 ?GetDlgItem@CWnd@@QBEPAV1@H@Z ; CWnd::GetDlgItem
  00093	8b c8		 mov	 ecx, eax
  00095	e8 00 00 00 00	 call	 ?ShowWindow@CWnd@@QAEHH@Z ; CWnd::ShowWindow

; 1742 : 			GetDlgItem(IDC_EDIT_START)->ShowWindow(SW_SHOW);

  0009a	6a 05		 push	 5
  0009c	68 ef 32 00 00	 push	 13039			; 000032efH
  000a1	8b ce		 mov	 ecx, esi
  000a3	e8 00 00 00 00	 call	 ?GetDlgItem@CWnd@@QBEPAV1@H@Z ; CWnd::GetDlgItem
  000a8	8b c8		 mov	 ecx, eax
  000aa	e8 00 00 00 00	 call	 ?ShowWindow@CWnd@@QAEHH@Z ; CWnd::ShowWindow

; 1743 : 			GetDlgItem(IDC_EDIT_ADV)->ShowWindow(SW_SHOW);

  000af	6a 05		 push	 5
  000b1	68 f7 32 00 00	 push	 13047			; 000032f7H
  000b6	8b ce		 mov	 ecx, esi
  000b8	e8 00 00 00 00	 call	 ?GetDlgItem@CWnd@@QBEPAV1@H@Z ; CWnd::GetDlgItem
  000bd	8b c8		 mov	 ecx, eax
  000bf	e8 00 00 00 00	 call	 ?ShowWindow@CWnd@@QAEHH@Z ; CWnd::ShowWindow

; 1744 : 			GetDlgItem(IDC_EDIT_END)->ShowWindow(SW_SHOW);

  000c4	6a 05		 push	 5
  000c6	68 f4 32 00 00	 push	 13044			; 000032f4H
  000cb	8b ce		 mov	 ecx, esi
  000cd	e8 00 00 00 00	 call	 ?GetDlgItem@CWnd@@QBEPAV1@H@Z ; CWnd::GetDlgItem
  000d2	8b c8		 mov	 ecx, eax
  000d4	e8 00 00 00 00	 call	 ?ShowWindow@CWnd@@QAEHH@Z ; CWnd::ShowWindow

; 1745 : 			
; 1746 : 			SetDlgItemText(IDC_EDIT_START,"1");

  000d9	68 00 00 00 00	 push	 OFFSET ??_C@_01HIHLOKLC@1@
  000de	68 ef 32 00 00	 push	 13039			; 000032efH
  000e3	8b ce		 mov	 ecx, esi
  000e5	e8 00 00 00 00	 call	 ?SetDlgItemTextA@CWnd@@QAEXHPBD@Z ; CWnd::SetDlgItemTextA

; 1747 : 			SetDlgItemText(IDC_EDIT_END,"5");

  000ea	68 00 00 00 00	 push	 OFFSET ??_C@_01BMBHCPLG@5@
  000ef	68 f4 32 00 00	 push	 13044			; 000032f4H
  000f4	8b ce		 mov	 ecx, esi
  000f6	e8 00 00 00 00	 call	 ?SetDlgItemTextA@CWnd@@QAEXHPBD@Z ; CWnd::SetDlgItemTextA

; 1748 : 			SetDlgItemText(IDC_EDIT_ADV,"1");

  000fb	68 00 00 00 00	 push	 OFFSET ??_C@_01HIHLOKLC@1@
  00100	68 f7 32 00 00	 push	 13047			; 000032f7H
  00105	8b ce		 mov	 ecx, esi
  00107	e8 00 00 00 00	 call	 ?SetDlgItemTextA@CWnd@@QAEXHPBD@Z ; CWnd::SetDlgItemTextA

; 1749 : 		}
; 1750 : 		break;

  0010c	e9 91 01 00 00	 jmp	 $LN2@CreateTIme
$LN5@CreateTIme:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 116  : 	{ return ::operator new(nSize); }

  00111	68 80 06 00 00	 push	 1664			; 00000680H
  00116	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0011b	83 c4 04	 add	 esp, 4
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 1710 : 			m_pDlgTimeSetup = new CDlgTimeSetup;

  0011e	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax
  00121	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00128	85 c0		 test	 eax, eax
  0012a	74 0d		 je	 SHORT $LN10@CreateTIme
  0012c	6a 00		 push	 0
  0012e	8b c8		 mov	 ecx, eax
  00130	e8 00 00 00 00	 call	 ??0CDlgTimeSetup@@QAE@PAVCWnd@@@Z ; CDlgTimeSetup::CDlgTimeSetup
  00135	8b c8		 mov	 ecx, eax
  00137	eb 02		 jmp	 SHORT $LN11@CreateTIme
$LN10@CreateTIme:
  00139	33 c9		 xor	 ecx, ecx
$LN11@CreateTIme:
  0013b	89 8e 2c 05 00
	00		 mov	 DWORD PTR [esi+1324], ecx

; 1711 : 
; 1712 : 			BOOL bRet = m_pDlgTimeSetup->Create(CDlgTimeSetup::IDD, this);

  00141	8b 01		 mov	 eax, DWORD PTR [ecx]
  00143	56		 push	 esi
  00144	68 55 33 00 00	 push	 13141			; 00003355H
  00149	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00150	ff 90 6c 01 00
	00		 call	 DWORD PTR [eax+364]

; 1713 : 
; 1714 : 			if(bRet)

  00156	85 c0		 test	 eax, eax
  00158	0f 84 44 01 00
	00		 je	 $LN2@CreateTIme

; 1717 : 				GetDlgItem(IDC_STATIC_TIME)->GetWindowRect(rect);

  0015e	0f 57 c0	 xorps	 xmm0, xmm0
  00161	8b ce		 mov	 ecx, esi
  00163	68 63 33 00 00	 push	 13155			; 00003363H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h

; 528  : 	left = 0;

  00168	0f 11 45 e0	 movups	 XMMWORD PTR _rect$3[ebp], xmm0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 1717 : 				GetDlgItem(IDC_STATIC_TIME)->GetWindowRect(rect);

  0016c	e8 00 00 00 00	 call	 ?GetDlgItem@CWnd@@QBEPAV1@H@Z ; CWnd::GetDlgItem
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl

; 84   : 	{ ASSERT(::IsWindow(m_hWnd)); ::GetWindowRect(m_hWnd, lpRect); }

  00171	8d 4d e0	 lea	 ecx, DWORD PTR _rect$3[ebp]
  00174	51		 push	 ecx
  00175	ff 70 20	 push	 DWORD PTR [eax+32]
  00178	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowRect@8
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 1718 : 				ScreenToClient(rect);

  0017e	8d 45 e0	 lea	 eax, DWORD PTR _rect$3[ebp]
  00181	8b ce		 mov	 ecx, esi
  00183	50		 push	 eax
  00184	e8 00 00 00 00	 call	 ?ScreenToClient@CWnd@@QBEXPAUtagRECT@@@Z ; CWnd::ScreenToClient

; 1719 : 				rect.top += 1;

  00189	8b 55 e4	 mov	 edx, DWORD PTR _rect$3[ebp+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl

; 73   : 	{ MoveWindow(lpRect->left, lpRect->top, lpRect->right - lpRect->left,

  0018c	8b 45 ec	 mov	 eax, DWORD PTR _rect$3[ebp+12]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 1719 : 				rect.top += 1;

  0018f	42		 inc	 edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl

; 73   : 	{ MoveWindow(lpRect->left, lpRect->top, lpRect->right - lpRect->left,

  00190	8b 4d e0	 mov	 ecx, DWORD PTR _rect$3[ebp]
  00193	2b c2		 sub	 eax, edx
  00195	6a 01		 push	 1
  00197	50		 push	 eax
  00198	8b 45 e8	 mov	 eax, DWORD PTR _rect$3[ebp+8]
  0019b	2b c1		 sub	 eax, ecx
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 1719 : 				rect.top += 1;

  0019d	89 55 e4	 mov	 DWORD PTR _rect$3[ebp+4], edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl

; 73   : 	{ MoveWindow(lpRect->left, lpRect->top, lpRect->right - lpRect->left,

  001a0	50		 push	 eax
  001a1	52		 push	 edx
  001a2	51		 push	 ecx
  001a3	8b 8e 2c 05 00
	00		 mov	 ecx, DWORD PTR [esi+1324]
  001a9	e8 00 00 00 00	 call	 ?MoveWindow@CWnd@@QAEXHHHHH@Z ; CWnd::MoveWindow
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 1721 : 				m_pDlgTimeSetup->ShowWindow(SW_SHOW);

  001ae	8b 8e 2c 05 00
	00		 mov	 ecx, DWORD PTR [esi+1324]
  001b4	6a 05		 push	 5
  001b6	e8 00 00 00 00	 call	 ?ShowWindow@CWnd@@QAEHH@Z ; CWnd::ShowWindow

; 1722 : 				GetDlgItem(IDC_BTN_ADDALL)->ShowWindow(SW_HIDE);

  001bb	6a 00		 push	 0
  001bd	68 eb 32 00 00	 push	 13035			; 000032ebH
  001c2	8b ce		 mov	 ecx, esi
  001c4	e8 00 00 00 00	 call	 ?GetDlgItem@CWnd@@QBEPAV1@H@Z ; CWnd::GetDlgItem
  001c9	8b c8		 mov	 ecx, eax
  001cb	e8 00 00 00 00	 call	 ?ShowWindow@CWnd@@QAEHH@Z ; CWnd::ShowWindow

; 1723 : 				GetDlgItem(IDC_BTN_ADDONE )->ShowWindow(SW_HIDE);

  001d0	6a 00		 push	 0
  001d2	68 05 33 00 00	 push	 13061			; 00003305H
  001d7	8b ce		 mov	 ecx, esi
  001d9	e8 00 00 00 00	 call	 ?GetDlgItem@CWnd@@QBEPAV1@H@Z ; CWnd::GetDlgItem
  001de	8b c8		 mov	 ecx, eax
  001e0	e8 00 00 00 00	 call	 ?ShowWindow@CWnd@@QAEHH@Z ; CWnd::ShowWindow

; 1724 : 				GetDlgItem(IDC_BTN_DELALL )->ShowWindow(SW_HIDE);

  001e5	6a 00		 push	 0
  001e7	68 5c 33 00 00	 push	 13148			; 0000335cH
  001ec	8b ce		 mov	 ecx, esi
  001ee	e8 00 00 00 00	 call	 ?GetDlgItem@CWnd@@QBEPAV1@H@Z ; CWnd::GetDlgItem
  001f3	8b c8		 mov	 ecx, eax
  001f5	e8 00 00 00 00	 call	 ?ShowWindow@CWnd@@QAEHH@Z ; CWnd::ShowWindow

; 1725 : 				GetDlgItem(IDC_BTN_DELONE )->ShowWindow(SW_HIDE);

  001fa	6a 00		 push	 0
  001fc	68 5d 33 00 00	 push	 13149			; 0000335dH
  00201	8b ce		 mov	 ecx, esi
  00203	e8 00 00 00 00	 call	 ?GetDlgItem@CWnd@@QBEPAV1@H@Z ; CWnd::GetDlgItem
  00208	8b c8		 mov	 ecx, eax
  0020a	e8 00 00 00 00	 call	 ?ShowWindow@CWnd@@QAEHH@Z ; CWnd::ShowWindow

; 1726 : 				GetDlgItem(IDC_LIST_ST )->ShowWindow(SW_HIDE);

  0020f	6a 00		 push	 0
  00211	68 5e 33 00 00	 push	 13150			; 0000335eH
  00216	8b ce		 mov	 ecx, esi
  00218	e8 00 00 00 00	 call	 ?GetDlgItem@CWnd@@QBEPAV1@H@Z ; CWnd::GetDlgItem
  0021d	8b c8		 mov	 ecx, eax
  0021f	e8 00 00 00 00	 call	 ?ShowWindow@CWnd@@QAEHH@Z ; CWnd::ShowWindow

; 1727 : 				GetDlgItem(IDC_STATIC_START)->ShowWindow(SW_HIDE);

  00224	8b ce		 mov	 ecx, esi
$LN4@CreateTIme:

; 1753 : 	}
; 1754 : 	
; 1755 : }

  00226	6a 00		 push	 0
  00228	68 65 33 00 00	 push	 13157			; 00003365H
  0022d	e8 00 00 00 00	 call	 ?GetDlgItem@CWnd@@QBEPAV1@H@Z ; CWnd::GetDlgItem
  00232	8b c8		 mov	 ecx, eax
  00234	e8 00 00 00 00	 call	 ?ShowWindow@CWnd@@QAEHH@Z ; CWnd::ShowWindow
  00239	6a 00		 push	 0
  0023b	68 67 33 00 00	 push	 13159			; 00003367H
  00240	8b ce		 mov	 ecx, esi
  00242	e8 00 00 00 00	 call	 ?GetDlgItem@CWnd@@QBEPAV1@H@Z ; CWnd::GetDlgItem
  00247	8b c8		 mov	 ecx, eax
  00249	e8 00 00 00 00	 call	 ?ShowWindow@CWnd@@QAEHH@Z ; CWnd::ShowWindow
  0024e	6a 00		 push	 0
  00250	68 6a 33 00 00	 push	 13162			; 0000336aH
  00255	8b ce		 mov	 ecx, esi
  00257	e8 00 00 00 00	 call	 ?GetDlgItem@CWnd@@QBEPAV1@H@Z ; CWnd::GetDlgItem
  0025c	8b c8		 mov	 ecx, eax
  0025e	e8 00 00 00 00	 call	 ?ShowWindow@CWnd@@QAEHH@Z ; CWnd::ShowWindow
  00263	6a 00		 push	 0
  00265	68 ef 32 00 00	 push	 13039			; 000032efH
  0026a	8b ce		 mov	 ecx, esi
  0026c	e8 00 00 00 00	 call	 ?GetDlgItem@CWnd@@QBEPAV1@H@Z ; CWnd::GetDlgItem
  00271	8b c8		 mov	 ecx, eax
  00273	e8 00 00 00 00	 call	 ?ShowWindow@CWnd@@QAEHH@Z ; CWnd::ShowWindow
  00278	6a 00		 push	 0
  0027a	68 f7 32 00 00	 push	 13047			; 000032f7H
  0027f	8b ce		 mov	 ecx, esi
  00281	e8 00 00 00 00	 call	 ?GetDlgItem@CWnd@@QBEPAV1@H@Z ; CWnd::GetDlgItem
  00286	8b c8		 mov	 ecx, eax
  00288	e8 00 00 00 00	 call	 ?ShowWindow@CWnd@@QAEHH@Z ; CWnd::ShowWindow
  0028d	6a 00		 push	 0
  0028f	68 f4 32 00 00	 push	 13044			; 000032f4H
  00294	8b ce		 mov	 ecx, esi
  00296	e8 00 00 00 00	 call	 ?GetDlgItem@CWnd@@QBEPAV1@H@Z ; CWnd::GetDlgItem
  0029b	8b c8		 mov	 ecx, eax
  0029d	e8 00 00 00 00	 call	 ?ShowWindow@CWnd@@QAEHH@Z ; CWnd::ShowWindow
$LN2@CreateTIme:
  002a2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  002a5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  002ac	59		 pop	 ecx
  002ad	5e		 pop	 esi
  002ae	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002b1	33 cd		 xor	 ecx, ebp
  002b3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002b8	8b e5		 mov	 esp, ebp
  002ba	5d		 pop	 ebp
  002bb	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CreateTImeSetupDlg@CDlgOptimizer@@QAEXXZ$0:
  00000	8b 45 dc	 mov	 eax, DWORD PTR $T2[ebp]
  00003	50		 push	 eax
  00004	e8 00 00 00 00	 call	 ??3CObject@@SGXPAX@Z	; CObject::operator delete
  00009	c3		 ret	 0
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
  0000d	cc		 int	 3
  0000e	cc		 int	 3
__ehhandler$?CreateTImeSetupDlg@CDlgOptimizer@@QAEXXZ:
  0000f	90		 npad	 1
  00010	90		 npad	 1
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00025	33 c8		 xor	 ecx, eax
  00027	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?CreateTImeSetupDlg@CDlgOptimizer@@QAEXXZ
  00031	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?CreateTImeSetupDlg@CDlgOptimizer@@QAEXXZ ENDP		; CDlgOptimizer::CreateTImeSetupDlg
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
;	COMDAT ?GetMessageMap@CDlgOptimizer@@MBEPBUAFX_MSGMAP@@XZ
_TEXT	SEGMENT
?GetMessageMap@CDlgOptimizer@@MBEPBUAFX_MSGMAP@@XZ PROC	; CDlgOptimizer::GetMessageMap, COMDAT
; _this$ = ecx

; 98   : BEGIN_MESSAGE_MAP(CDlgOptimizer, CDialog)

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?messageMap@?1??GetThisMessageMap@CDlgOptimizer@@KGPBUAFX_MSGMAP@@XZ@4U3@B
  00005	c3		 ret	 0
?GetMessageMap@CDlgOptimizer@@MBEPBUAFX_MSGMAP@@XZ ENDP	; CDlgOptimizer::GetMessageMap
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
;	COMDAT ?GetThisMessageMap@CDlgOptimizer@@KGPBUAFX_MSGMAP@@XZ
_TEXT	SEGMENT
?GetThisMessageMap@CDlgOptimizer@@KGPBUAFX_MSGMAP@@XZ PROC ; CDlgOptimizer::GetThisMessageMap, COMDAT

; 99   : 	//{{AFX_MSG_MAP(CDlgOptimizer)
; 100  : 	ON_WM_CTLCOLOR()
; 101  : 	ON_WM_DESTROY()
; 102  : 	ON_BN_CLICKED(IDC_BTN_OPT, OnBtnOpt)
; 103  : 	ON_WM_TIMER()
; 104  : 	ON_BN_CLICKED(IDC_BTN_STOP, OnBtnStop)
; 105  : 	//}}AFX_MSG_MAP
; 106  : //	ON_MESSAGE(WMU_SET_KEYCODE, OnSetKeyCodeChange)
; 107  : 	ON_REGISTERED_MESSAGE(RMSG_STDATAMANAGER_RESULTDATA, OnSTDataManagerMessagge)
; 108  : 	ON_BN_CLICKED(IDC_BTN_ADDALL, OnBnClickedBtnAddall)
; 109  : 	ON_BN_CLICKED(IDC_BTN_ADDONE, OnBnClickedBtnAddone)
; 110  : 	ON_BN_CLICKED(IDC_BTN_DELALL, OnBnClickedBtnDelall)
; 111  : 	ON_BN_CLICKED(IDC_BTN_DELONE, OnBnClickedBtnDelone)
; 112  : 	ON_REGISTERED_MESSAGE(RMSG_OB_ITEMDBLCLK	,OnRmsgObItemDBClk)
; 113  : 	ON_REGISTERED_MESSAGE(RMSG_GETDLLSIZE, OnRmsgGetDllSize)
; 114  : 	ON_LBN_DBLCLK(IDC_LIST_ST, OnLbnDblclkListSt)
; 115  : 	ON_REGISTERED_MESSAGE(RMSG_STTREE_ITEMDBLCLK,OnRmsgSTTreeItemDBClk)
; 116  : END_MESSAGE_MAP()

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?messageMap@?1??GetThisMessageMap@CDlgOptimizer@@KGPBUAFX_MSGMAP@@XZ@4U3@B
  00005	c3		 ret	 0
?GetThisMessageMap@CDlgOptimizer@@KGPBUAFX_MSGMAP@@XZ ENDP ; CDlgOptimizer::GetThisMessageMap
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
;	COMDAT ?OnRmsgGetDllSize@CDlgOptimizer@@IAEJIJ@Z
_TEXT	SEGMENT
_wParam$ = 8						; size = 4
_lParam$ = 12						; size = 4
?OnRmsgGetDllSize@CDlgOptimizer@@IAEJIJ@Z PROC		; CDlgOptimizer::OnRmsgGetDllSize, COMDAT
; _this$ = ecx

; 1882 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1883 : 	CPoint* pSize = (CPoint*)wParam;
; 1884 : 	pSize->x = 865;

  00003	8b 45 08	 mov	 eax, DWORD PTR _wParam$[ebp]
  00006	c7 00 61 03 00
	00		 mov	 DWORD PTR [eax], 865	; 00000361H

; 1885 : 	pSize->y = 532;

  0000c	c7 40 04 14 02
	00 00		 mov	 DWORD PTR [eax+4], 532	; 00000214H

; 1886 : 
; 1887 : 	return 0;

  00013	33 c0		 xor	 eax, eax

; 1888 : }

  00015	5d		 pop	 ebp
  00016	c2 08 00	 ret	 8
?OnRmsgGetDllSize@CDlgOptimizer@@IAEJIJ@Z ENDP		; CDlgOptimizer::OnRmsgGetDllSize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
;	COMDAT ?OnRmsgObItemDBClk@CDlgOptimizer@@IAEJIJ@Z
_TEXT	SEGMENT
$T2 = -36						; size = 4
$T3 = -32						; size = 4
_szRootDir$4 = -28					; size = 4
_strUserPath$5 = -24					; size = 4
$T6 = -20						; size = 4
_szSTName$7 = -16					; size = 4
__$EHRec$ = -12						; size = 12
_wParam$ = 8						; size = 4
$T8 = 12						; size = 4
$T9 = 12						; size = 4
_lParam$ = 12						; size = 4
?OnRmsgObItemDBClk@CDlgOptimizer@@IAEJIJ@Z PROC		; CDlgOptimizer::OnRmsgObItemDBClk, COMDAT
; _this$ = ecx

; 1822 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?OnRmsgObItemDBClk@CDlgOptimizer@@IAEJIJ@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 18	 sub	 esp, 24			; 00000018H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b f9		 mov	 edi, ecx
  0002a	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR $T3[ebp], 0

; 1823 : 	STMNG_ITEMINFO* pArg = (STMNG_ITEMINFO*)lParam;
; 1824 : 	if(m_nOptimizerDiv == VAL_OPTIMIZER)

  00031	81 bf 70 11 00
	00 ea 03 00 00	 cmp	 DWORD PTR [edi+4464], 1002 ; 000003eaH
  0003b	0f 85 b0 01 00
	00		 jne	 $LN2@OnRmsgObIt

; 1825 : 	{
; 1826 : 		CString szRootDir = (LPCSTR)AfxGetPctrData(10);	// 10 : RootDir

  00041	6a 0a		 push	 10			; 0000000aH
  00043	e8 00 00 00 00	 call	 ?AfxGetPctrData@@YGJH@Z	; AfxGetPctrData
  00048	50		 push	 eax
  00049	8d 4d e4	 lea	 ecx, DWORD PTR _szRootDir$4[ebp]
  0004c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z

; 1827 : 		//CString strUserPath = szRootDir +"\\Data\\STData\\VarOptima.cfg";
; 1828 : 		CString strUserPath = szRootDir +"\\Icss\\STData\\VarOptima.cfg";	//@Solomon

  00052	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@EOEHIOGI@?2Icss?2STData?2VarOptima?4cfg@
  00057	8d 45 e4	 lea	 eax, DWORD PTR _szRootDir$4[ebp]
  0005a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00061	50		 push	 eax
  00062	8d 45 e8	 lea	 eax, DWORD PTR _strUserPath$5[ebp]
  00065	50		 push	 eax
  00066	e8 00 00 00 00	 call	 ??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@ABV10@PBD@Z ; ATL::operator+
  0006b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1829 : 		CString szSTName;

  0006e	8d 4d f0	 lea	 ecx, DWORD PTR _szSTName$7[ebp]
  00071	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 1830 : 		m_pDlgTimeSetup->Reset();

  00077	8b 8f 2c 05 00
	00		 mov	 ecx, DWORD PTR [edi+1324]
  0007d	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00081	e8 00 00 00 00	 call	 ?Reset@CDlgTimeSetup@@QAEXXZ ; CDlgTimeSetup::Reset

; 1831 : 		szSTName = pArg->szSTName; 

  00086	8b 75 0c	 mov	 esi, DWORD PTR _lParam$[ebp]
  00089	8d 4d f0	 lea	 ecx, DWORD PTR _szSTName$7[ebp]
  0008c	8d 5e 04	 lea	 ebx, DWORD PTR [esi+4]
  0008f	53		 push	 ebx
  00090	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z

; 1832 : 		szSTName=szSTName.Mid(0, szSTName.Find(gSTGubunKey));

  00096	6a 00		 push	 0
  00098	6a 5e		 push	 94			; 0000005eH
  0009a	8d 4d f0	 lea	 ecx, DWORD PTR _szSTName$7[ebp]
  0009d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Find@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEHDH@Z
  000a3	50		 push	 eax
  000a4	6a 00		 push	 0
  000a6	8d 45 0c	 lea	 eax, DWORD PTR $T9[ebp]
  000a9	50		 push	 eax
  000aa	8d 4d f0	 lea	 ecx, DWORD PTR _szSTName$7[ebp]
  000ad	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Mid@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBE?AV12@HH@Z
  000b3	50		 push	 eax
  000b4	8d 4d f0	 lea	 ecx, DWORD PTR _szSTName$7[ebp]
  000b7	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  000bb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
  000c1	8d 4d 0c	 lea	 ecx, DWORD PTR $T9[ebp]
  000c4	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  000c8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 1833 : 		if(m_pDlgTimeSetup->LoadCFG(strUserPath, szSTName)==FALSE)

  000ce	ff 75 f0	 push	 DWORD PTR _szSTName$7[ebp]
  000d1	8b 8f 2c 05 00
	00		 mov	 ecx, DWORD PTR [edi+1324]
  000d7	ff 75 e8	 push	 DWORD PTR _strUserPath$5[ebp]
  000da	e8 00 00 00 00	 call	 ?LoadCFG@CDlgTimeSetup@@QAEHPBD0@Z ; CDlgTimeSetup::LoadCFG
  000df	85 c0		 test	 eax, eax
  000e1	75 11		 jne	 SHORT $LN4@OnRmsgObIt

; 1834 : 		{
; 1835 : 			AfxMessageBox("     .");

  000e3	50		 push	 eax
  000e4	50		 push	 eax
  000e5	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@JOCOAICG@?$LK?$KP?$LM?v?5?C?V?$MA?$PL?H?$KN?$LP?$KB?$LM?$KN?5?$LL?g?$LP?k?G?R?5?$LM?v?5?$LO?x?$LE?B?5@
  000ea	e8 00 00 00 00	 call	 ?AfxMessageBox@@YGHPBDII@Z ; AfxMessageBox

; 1836 : 			return 0L;

  000ef	e9 e0 00 00 00	 jmp	 $LN57@OnRmsgObIt
$LN4@OnRmsgObIt:

; 1837 : 		}
; 1838 : 		m_pDlgTimeSetup->ParseCFG();

  000f4	8b 8f 2c 05 00
	00		 mov	 ecx, DWORD PTR [edi+1324]
  000fa	e8 00 00 00 00	 call	 ?ParseCFG@CDlgTimeSetup@@QAEXXZ ; CDlgTimeSetup::ParseCFG
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h

; 2401 : 		CStringT strResult( str1.GetManager() );

  000ff	8d 4e 08	 lea	 ecx, DWORD PTR [esi+8]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 1840 : 		m_stPath = pArg->szSTPath + "\\" +pArg->szSTName+".st";

  00102	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h

; 2401 : 		CStringT strResult( str1.GetManager() );

  00106	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetManager@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEPAUIAtlStringMgr@2@XZ
  0010c	50		 push	 eax
  0010d	8d 4d ec	 lea	 ecx, DWORD PTR $T6[ebp]
  00110	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PAUIAtlStringMgr@1@@Z
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h

; 519  : 		return( GetData()->nDataLength );

  00116	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h

; 2403 : 		CThisSimpleString::Concatenate( strResult, str1, str1.GetLength(), psz2, CThisSimpleString::StringLength( psz2 ) );

  00119	6a 01		 push	 1
  0011b	68 00 00 00 00	 push	 OFFSET ??_C@_01KICIPPFI@?2@

; 2404 : 
; 2405 : 		return( strResult );

  00120	c7 45 e0 02 00
	00 00		 mov	 DWORD PTR $T3[ebp], 2
  00127	ff 70 f4	 push	 DWORD PTR [eax-12]
  0012a	50		 push	 eax
  0012b	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  0012e	50		 push	 eax
  0012f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Concatenate@?$CSimpleStringT@D$00@ATL@@KAXAAV12@PBDH1H@Z
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 1840 : 		m_stPath = pArg->szSTPath + "\\" +pArg->szSTName+".st";

  00135	53		 push	 ebx
  00136	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  00139	50		 push	 eax
  0013a	8d 45 dc	 lea	 eax, DWORD PTR $T2[ebp]
  0013d	50		 push	 eax
  0013e	e8 00 00 00 00	 call	 ??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@ABV10@0@Z ; ATL::operator+
  00143	83 c4 20	 add	 esp, 32			; 00000020H
  00146	8b f0		 mov	 esi, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h

; 2401 : 		CStringT strResult( str1.GetManager() );

  00148	8b ce		 mov	 ecx, esi
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 1840 : 		m_stPath = pArg->szSTPath + "\\" +pArg->szSTName+".st";

  0014a	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h

; 2401 : 		CStringT strResult( str1.GetManager() );

  0014e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetManager@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEPAUIAtlStringMgr@2@XZ
  00154	50		 push	 eax
  00155	8d 4d 0c	 lea	 ecx, DWORD PTR $T8[ebp]
  00158	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PAUIAtlStringMgr@1@@Z
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h

; 519  : 		return( GetData()->nDataLength );

  0015e	8b 06		 mov	 eax, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h

; 2403 : 		CThisSimpleString::Concatenate( strResult, str1, str1.GetLength(), psz2, CThisSimpleString::StringLength( psz2 ) );

  00160	6a 03		 push	 3
  00162	68 00 00 00 00	 push	 OFFSET ??_C@_03IDLCJCBF@?4st@

; 2404 : 
; 2405 : 		return( strResult );

  00167	c7 45 e0 06 00
	00 00		 mov	 DWORD PTR $T3[ebp], 6
  0016e	ff 70 f4	 push	 DWORD PTR [eax-12]
  00171	50		 push	 eax
  00172	8d 45 0c	 lea	 eax, DWORD PTR $T8[ebp]
  00175	50		 push	 eax
  00176	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Concatenate@?$CSimpleStringT@D$00@ATL@@KAXAAV12@PBDH1H@Z
  0017c	83 c4 14	 add	 esp, 20			; 00000014H
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 1840 : 		m_stPath = pArg->szSTPath + "\\" +pArg->szSTName+".st";

  0017f	8d 45 0c	 lea	 eax, DWORD PTR $T8[ebp]
  00182	8d 8f ac 11 00
	00		 lea	 ecx, DWORD PTR [edi+4524]
  00188	50		 push	 eax
  00189	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
  0018f	8d 4d 0c	 lea	 ecx, DWORD PTR $T8[ebp]
  00192	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00198	8d 4d dc	 lea	 ecx, DWORD PTR $T2[ebp]
  0019b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  001a1	8d 4d ec	 lea	 ecx, DWORD PTR $T6[ebp]
  001a4	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  001a8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 1841 : 		m_GridTap.SetRowCount(1);

  001ae	6a 01		 push	 1
  001b0	8d 8f f0 09 00
	00		 lea	 ecx, DWORD PTR [edi+2544]
  001b6	e8 00 00 00 00	 call	 ?SetRowCount@CGridCtrl@@QAEHH@Z ; CGridCtrl::SetRowCount

; 1842 : 		m_STValNum =m_pDlgTimeSetup->m_ValueOptimizerArray.GetSize();

  001bb	8b 87 2c 05 00
	00		 mov	 eax, DWORD PTR [edi+1324]

; 1843 : 		
; 1844 : 		ReSize();

  001c1	8b cf		 mov	 ecx, edi
  001c3	8b 80 dc 00 00
	00		 mov	 eax, DWORD PTR [eax+220]
  001c9	89 87 b0 11 00
	00		 mov	 DWORD PTR [edi+4528], eax
  001cf	e8 00 00 00 00	 call	 ?ReSize@CDlgOptimizer@@QAEXXZ ; CDlgOptimizer::ReSize
$LN57@OnRmsgObIt:

; 1849 : 	}
; 1850 : 
; 1851 : 	/*m_xSTAnalysisInput.m_Info.nSTType		= pArg->nSTType;
; 1852 : 	m_xSTAnalysisInput.m_Info.szSTName		= pArg->szSTName;
; 1853 : 	m_xSTAnalysisInput.m_Info.szSTPath		= pArg->szSTPath;
; 1854 : 	m_xSTAnalysisInput.m_Info.szSTRData		= pArg->szSTRData;	
; 1855 : 	m_xSTAnalysisInput.m_Info.nFolderIndx	= pArg->nFolderIndx;
; 1856 : 	m_xSTAnalysisInput.m_Info.nItemIndx		= pArg->nItemIndx;*/
; 1857 : 	return 0L;
; 1858 : }

  001d4	8d 4d f0	 lea	 ecx, DWORD PTR _szSTName$7[ebp]
  001d7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  001dd	8d 4d e8	 lea	 ecx, DWORD PTR _strUserPath$5[ebp]
  001e0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  001e6	8d 4d e4	 lea	 ecx, DWORD PTR _szRootDir$4[ebp]
  001e9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  001ef	eb 05		 jmp	 SHORT $LN3@OnRmsgObIt
$LN2@OnRmsgObIt:

; 1845 : 		
; 1846 : 	}
; 1847 : 	else{
; 1848 : 		OnBnClickedBtnAddone();

  001f1	e8 00 00 00 00	 call	 ?OnBnClickedBtnAddone@CDlgOptimizer@@QAEXXZ ; CDlgOptimizer::OnBnClickedBtnAddone
$LN3@OnRmsgObIt:

; 1849 : 	}
; 1850 : 
; 1851 : 	/*m_xSTAnalysisInput.m_Info.nSTType		= pArg->nSTType;
; 1852 : 	m_xSTAnalysisInput.m_Info.szSTName		= pArg->szSTName;
; 1853 : 	m_xSTAnalysisInput.m_Info.szSTPath		= pArg->szSTPath;
; 1854 : 	m_xSTAnalysisInput.m_Info.szSTRData		= pArg->szSTRData;	
; 1855 : 	m_xSTAnalysisInput.m_Info.nFolderIndx	= pArg->nFolderIndx;
; 1856 : 	m_xSTAnalysisInput.m_Info.nItemIndx		= pArg->nItemIndx;*/
; 1857 : 	return 0L;
; 1858 : }

  001f6	33 c0		 xor	 eax, eax
  001f8	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001fb	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00202	59		 pop	 ecx
  00203	5f		 pop	 edi
  00204	5e		 pop	 esi
  00205	5b		 pop	 ebx
  00206	8b e5		 mov	 esp, ebp
  00208	5d		 pop	 ebp
  00209	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?OnRmsgObItemDBClk@CDlgOptimizer@@IAEJIJ@Z$0:
  00000	8d 4d e4	 lea	 ecx, DWORD PTR _szRootDir$4[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?OnRmsgObItemDBClk@CDlgOptimizer@@IAEJIJ@Z$1:
  00009	8d 4d e8	 lea	 ecx, DWORD PTR _strUserPath$5[ebp]
  0000c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?OnRmsgObItemDBClk@CDlgOptimizer@@IAEJIJ@Z$2:
  00012	8d 4d f0	 lea	 ecx, DWORD PTR _szSTName$7[ebp]
  00015	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?OnRmsgObItemDBClk@CDlgOptimizer@@IAEJIJ@Z$3:
  0001b	8d 4d 0c	 lea	 ecx, DWORD PTR $T9[ebp]
  0001e	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?OnRmsgObItemDBClk@CDlgOptimizer@@IAEJIJ@Z$8:
  00024	8b 45 e0	 mov	 eax, DWORD PTR $T3[ebp]
  00027	83 e0 02	 and	 eax, 2
  0002a	0f 84 0d 00 00
	00		 je	 $LN33@OnRmsgObIt
  00030	83 65 e0 fd	 and	 DWORD PTR $T3[ebp], -3	; fffffffdH
  00034	8d 4d ec	 lea	 ecx, DWORD PTR $T6[ebp]
  00037	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$LN33@OnRmsgObIt:
  0003d	c3		 ret	 0
__unwindfunclet$?OnRmsgObItemDBClk@CDlgOptimizer@@IAEJIJ@Z$5:
  0003e	8d 4d dc	 lea	 ecx, DWORD PTR $T2[ebp]
  00041	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?OnRmsgObItemDBClk@CDlgOptimizer@@IAEJIJ@Z$9:
  00047	8b 45 e0	 mov	 eax, DWORD PTR $T3[ebp]
  0004a	83 e0 04	 and	 eax, 4
  0004d	0f 84 0d 00 00
	00		 je	 $LN46@OnRmsgObIt
  00053	83 65 e0 fb	 and	 DWORD PTR $T3[ebp], -5	; fffffffbH
  00057	8d 4d 0c	 lea	 ecx, DWORD PTR $T8[ebp]
  0005a	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$LN46@OnRmsgObIt:
  00060	c3		 ret	 0
  00061	cc		 int	 3
  00062	cc		 int	 3
  00063	cc		 int	 3
  00064	cc		 int	 3
  00065	cc		 int	 3
__ehhandler$?OnRmsgObItemDBClk@CDlgOptimizer@@IAEJIJ@Z:
  00066	90		 npad	 1
  00067	90		 npad	 1
  00068	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0006c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0006f	8b 4a d8	 mov	 ecx, DWORD PTR [edx-40]
  00072	33 c8		 xor	 ecx, eax
  00074	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00079	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?OnRmsgObItemDBClk@CDlgOptimizer@@IAEJIJ@Z
  0007e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?OnRmsgObItemDBClk@CDlgOptimizer@@IAEJIJ@Z ENDP		; CDlgOptimizer::OnRmsgObItemDBClk
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
;	COMDAT ?OnSetKeyCodeChange@CDlgOptimizer@@IAEJIJ@Z
_TEXT	SEGMENT
_wp$ = 8						; size = 4
_lp$ = 12						; size = 4
?OnSetKeyCodeChange@CDlgOptimizer@@IAEJIJ@Z PROC	; CDlgOptimizer::OnSetKeyCodeChange, COMDAT
; _this$ = ecx

; 388  : 	return TRUE;

  00000	b8 01 00 00 00	 mov	 eax, 1

; 389  : }

  00005	c2 08 00	 ret	 8
?OnSetKeyCodeChange@CDlgOptimizer@@IAEJIJ@Z ENDP	; CDlgOptimizer::OnSetKeyCodeChange
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
;	COMDAT ?OnSTDataManagerMessagge@CDlgOptimizer@@IAEJIJ@Z
_TEXT	SEGMENT
_stVal$2 = -76						; size = 56
_Profit$ = -20						; size = 8
$T3 = -16						; size = 4
$T4 = -16						; size = 4
$T5 = -16						; size = 4
$T6 = -16						; size = 4
$T7 = -16						; size = 4
$T8 = -16						; size = 4
$T9 = -16						; size = 4
$T10 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_str$ = 8						; size = 4
_wParam$ = 8						; size = 4
_Plus$1$ = 12						; size = 4
$T11 = 12						; size = 4
$T12 = 12						; size = 4
$T13 = 12						; size = 4
$T14 = 12						; size = 4
$T15 = 12						; size = 4
$T16 = 12						; size = 4
_stValue$17 = 12					; size = 4
_lParam$ = 12						; size = 4
?OnSTDataManagerMessagge@CDlgOptimizer@@IAEJIJ@Z PROC	; CDlgOptimizer::OnSTDataManagerMessagge, COMDAT
; _this$ = ecx

; 1110 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?OnSTDataManagerMessagge@CDlgOptimizer@@IAEJIJ@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 40	 sub	 esp, 64			; 00000040H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b f9		 mov	 edi, ecx

; 1111 : 	//   
; 1112 : 	m_pStrategyItem = (CIStrategyItem*)wParam;	

  0002a	8b 45 08	 mov	 eax, DWORD PTR _wParam$[ebp]
  0002d	89 87 10 05 00
	00		 mov	 DWORD PTR [edi+1296], eax

; 1113 : 	ST_DRAWINFO* pInfo = (ST_DRAWINFO*)lParam;
; 1114 : 	CPtrArray* pPtrArrayPlot = pInfo->pPtrArraySDataItem;

  00033	8b 45 0c	 mov	 eax, DWORD PTR _lParam$[ebp]
  00036	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl

; 203  : 		if( nIndex < 0 || nIndex >= m_nSize )

  00039	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  0003d	0f 8e ea 07 00
	00		 jle	 $LN51@OnSTDataMa

; 204  : 			AfxThrowInvalidArgException();
; 205  : 		return m_pData[nIndex]; }

  00043	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00046	8b 08		 mov	 ecx, DWORD PTR [eax]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 1115 : 	m_pDataItem = (CISDataItem *)pPtrArrayPlot->GetAt(0);

  00048	89 8f 24 05 00
	00		 mov	 DWORD PTR [edi+1316], ecx

; 1116 : 	long nTotalData	= m_pDataItem->GetSize();

  0004e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00050	ff 50 1c	 call	 DWORD PTR [eax+28]

; 1117 : 	m_pStrategyItem->Stop();

  00053	8b 8f 10 05 00
	00		 mov	 ecx, DWORD PTR [edi+1296]
  00059	8b f0		 mov	 esi, eax
  0005b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0005d	ff 52 1c	 call	 DWORD PTR [edx+28]

; 1118 : 	m_pStrategyItem->CalculateStatisticalInfo(0, nTotalData-1);// ..

  00060	8b 8f 10 05 00
	00		 mov	 ecx, DWORD PTR [edi+1296]
  00066	8d 46 ff	 lea	 eax, DWORD PTR [esi-1]
  00069	50		 push	 eax
  0006a	6a 00		 push	 0
  0006c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0006e	ff 52 44	 call	 DWORD PTR [edx+68]

; 1119 : 	
; 1120 : 	if(m_bGridClick)//       .

  00071	83 bf 8c 11 00
	00 00		 cmp	 DWORD PTR [edi+4492], 0
  00078	74 1b		 je	 SHORT $LN5@OnSTDataMa

; 1121 : 	{
; 1122 : 		m_DlgResult->SetDataSpreadGrid();

  0007a	8b 8f 80 0e 00
	00		 mov	 ecx, DWORD PTR [edi+3712]
  00080	e8 00 00 00 00	 call	 ?SetDataSpreadGrid@CDlgResult@@QAEXXZ ; CDlgResult::SetDataSpreadGrid

; 1123 : 		//m_DlgResult->OpenWebView("\\IndexOptimizerData.htm");
; 1124 : 		m_DlgTrade->SetDataSpreadGrid();

  00085	8b 8f 8c 0e 00
	00		 mov	 ecx, DWORD PTR [edi+3724]
  0008b	e8 00 00 00 00	 call	 ?SetDataSpreadGrid@CDlgTrade@@QAEXXZ ; CDlgTrade::SetDataSpreadGrid

; 1125 : 		//m_DlgTrade->OpenWebView("\\IOTradeData.htm");
; 1126 : 		return 0L;

  00090	e9 82 07 00 00	 jmp	 $LN107@OnSTDataMa
$LN5@OnSTDataMa:

; 1127 : 	}	
; 1128 : 	//   
; 1129 : 	//////            
; 1130 : 	CString str;

  00095	8d 4d 08	 lea	 ecx, DWORD PTR _str$[ebp]
  00098	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 1131 : 	int Plus = 0; //      Column    
; 1132 : 	if(m_nOptimizerDiv == INDEX_OPTIMIZER || m_nOptimizerDiv== TIME_OPTIMIZER)

  0009e	8b 87 70 11 00
	00		 mov	 eax, DWORD PTR [edi+4464]
  000a4	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp_?Format@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAAXPBDZZ
  000aa	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  000b1	c7 45 0c 00 00
	00 00		 mov	 DWORD PTR _Plus$1$[ebp], 0
  000b8	3d e9 03 00 00	 cmp	 eax, 1001		; 000003e9H
  000bd	74 0b		 je	 SHORT $LN7@OnSTDataMa
  000bf	3d eb 03 00 00	 cmp	 eax, 1003		; 000003ebH
  000c4	0f 85 1b 01 00
	00		 jne	 $LN10@OnSTDataMa
$LN7@OnSTDataMa:

; 1133 : 	{
; 1134 : 		m_GridTap.InsertRow("");

  000ca	6a ff		 push	 -1
  000cc	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@@
  000d1	8d 8f f0 09 00
	00		 lea	 ecx, DWORD PTR [edi+2544]
  000d7	e8 00 00 00 00	 call	 ?InsertRow@CGridCtrl@@QAEHPBDH@Z ; CGridCtrl::InsertRow

; 1135 : 		//@@061208  .[[
; 1136 : 		// index     , 0     sd  .
; 1137 : 		//  -1 .
; 1138 : 		//str=m_pStrategyItem->GetName(0);//..
; 1139 : 		//str.Delete(str.GetLength()-3, 3);
; 1140 : 
; 1141 : 		str=m_pStrategyItem->GetName(-1); //

  000dc	8b 8f 10 05 00
	00		 mov	 ecx, DWORD PTR [edi+1296]
  000e2	8d 55 f0	 lea	 edx, DWORD PTR $T10[ebp]
  000e5	6a ff		 push	 -1
  000e7	52		 push	 edx
  000e8	8b 01		 mov	 eax, DWORD PTR [ecx]
  000ea	ff 50 68	 call	 DWORD PTR [eax+104]
  000ed	50		 push	 eax
  000ee	8d 4d 08	 lea	 ecx, DWORD PTR _str$[ebp]
  000f1	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  000f5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
  000fb	8d 4d f0	 lea	 ecx, DWORD PTR $T10[ebp]
  000fe	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00102	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 1142 : 		int nEndPos = -1;
; 1143 : 		if((nEndPos = str.Find(gSTGubunKey)) != -1)

  00108	6a 00		 push	 0
  0010a	6a 5e		 push	 94			; 0000005eH
  0010c	8d 4d 08	 lea	 ecx, DWORD PTR _str$[ebp]
  0010f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Find@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEHDH@Z
  00115	83 f8 ff	 cmp	 eax, -1
  00118	74 29		 je	 SHORT $LN8@OnSTDataMa

; 1144 : 			str = str.Left(nEndPos);

  0011a	50		 push	 eax
  0011b	8d 45 f0	 lea	 eax, DWORD PTR $T9[ebp]
  0011e	50		 push	 eax
  0011f	8d 4d 08	 lea	 ecx, DWORD PTR _str$[ebp]
  00122	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Left@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBE?AV12@H@Z
  00128	50		 push	 eax
  00129	8d 4d 08	 lea	 ecx, DWORD PTR _str$[ebp]
  0012c	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00130	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
  00136	8d 4d f0	 lea	 ecx, DWORD PTR $T9[ebp]
  00139	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0013d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$LN8@OnSTDataMa:

; 1145 : 		if((nEndPos = str.Find('.')) != -1)

  00143	6a 00		 push	 0
  00145	6a 2e		 push	 46			; 0000002eH
  00147	8d 4d 08	 lea	 ecx, DWORD PTR _str$[ebp]
  0014a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Find@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEHDH@Z
  00150	83 f8 ff	 cmp	 eax, -1
  00153	74 29		 je	 SHORT $LN9@OnSTDataMa

; 1146 : 			str= str.Left(nEndPos);

  00155	50		 push	 eax
  00156	8d 45 f0	 lea	 eax, DWORD PTR $T8[ebp]
  00159	50		 push	 eax
  0015a	8d 4d 08	 lea	 ecx, DWORD PTR _str$[ebp]
  0015d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Left@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBE?AV12@H@Z
  00163	50		 push	 eax
  00164	8d 4d 08	 lea	 ecx, DWORD PTR _str$[ebp]
  00167	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  0016b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
  00171	8d 4d f0	 lea	 ecx, DWORD PTR $T8[ebp]
  00174	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00178	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$LN9@OnSTDataMa:

; 1147 : 		//@@061208  .]]
; 1148 : 		m_GridTap.SetItemText(m_GridTap.GetRowCount()-1,1,str);

  0017e	ff 75 08	 push	 DWORD PTR _str$[ebp]
  00181	8b 87 08 0b 00
	00		 mov	 eax, DWORD PTR [edi+2824]
  00187	8d 8f f0 09 00
	00		 lea	 ecx, DWORD PTR [edi+2544]
  0018d	6a 01		 push	 1
  0018f	48		 dec	 eax
  00190	50		 push	 eax
  00191	e8 00 00 00 00	 call	 ?SetItemText@CGridCtrl@@QAEHHHPBD@Z ; CGridCtrl::SetItemText

; 1149 : 		if(m_nOptimizerDiv == TIME_OPTIMIZER)//  

  00196	8b 87 70 11 00
	00		 mov	 eax, DWORD PTR [edi+4464]
  0019c	3d eb 03 00 00	 cmp	 eax, 1003		; 000003ebH
  001a1	75 42		 jne	 SHORT $LN10@OnSTDataMa

; 1150 : 		{
; 1151 : 			str.Format("%d",m_pStrategyItem->GetTimeBong());

  001a3	8b 8f 10 05 00
	00		 mov	 ecx, DWORD PTR [edi+1296]
  001a9	8b 01		 mov	 eax, DWORD PTR [ecx]
  001ab	ff 90 80 00 00
	00		 call	 DWORD PTR [eax+128]
  001b1	50		 push	 eax
  001b2	8d 45 08	 lea	 eax, DWORD PTR _str$[ebp]
  001b5	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  001ba	50		 push	 eax
  001bb	ff d3		 call	 ebx

; 1152 : 			m_GridTap.SetItemText(m_GridTap.GetRowCount()-1,2,str);

  001bd	8b 87 08 0b 00
	00		 mov	 eax, DWORD PTR [edi+2824]
  001c3	8d 8f f0 09 00
	00		 lea	 ecx, DWORD PTR [edi+2544]
  001c9	83 c4 0c	 add	 esp, 12			; 0000000cH
  001cc	48		 dec	 eax
  001cd	ff 75 08	 push	 DWORD PTR _str$[ebp]
  001d0	6a 02		 push	 2
  001d2	50		 push	 eax
  001d3	e8 00 00 00 00	 call	 ?SetItemText@CGridCtrl@@QAEHHHPBD@Z ; CGridCtrl::SetItemText

; 1153 : 			Plus =1;

  001d8	8b 87 70 11 00
	00		 mov	 eax, DWORD PTR [edi+4464]
  001de	c7 45 0c 01 00
	00 00		 mov	 DWORD PTR _Plus$1$[ebp], 1
$LN10@OnSTDataMa:

; 1154 : 		}
; 1155 : 	}
; 1156 : 	if(m_nOptimizerDiv == VAL_OPTIMIZER)

  001e5	8d b7 f0 09 00
	00		 lea	 esi, DWORD PTR [edi+2544]
  001eb	3d ea 03 00 00	 cmp	 eax, 1002		; 000003eaH
  001f0	0f 85 9b 01 00
	00		 jne	 $LN103@OnSTDataMa

; 1157 : 	{	//"%s%d=%lf,
; 1158 : 		m_GridTap.InsertRow("");

  001f6	6a ff		 push	 -1
  001f8	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@@
  001fd	8b ce		 mov	 ecx, esi
  001ff	e8 00 00 00 00	 call	 ?InsertRow@CGridCtrl@@QAEHPBDH@Z ; CGridCtrl::InsertRow

; 1159 : 		str.Format("%s",m_pStrategyItem->GetValOptimizer());

  00204	8b 8f 10 05 00
	00		 mov	 ecx, DWORD PTR [edi+1296]
  0020a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0020c	ff 90 8c 00 00
	00		 call	 DWORD PTR [eax+140]
  00212	50		 push	 eax
  00213	8d 45 08	 lea	 eax, DWORD PTR _str$[ebp]
  00216	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  0021b	50		 push	 eax
  0021c	ff d3		 call	 ebx

; 1160 : 		m_GridTap.SetItemText(m_GridTap.GetRowCount()-1,1,str);//

  0021e	8b 87 08 0b 00
	00		 mov	 eax, DWORD PTR [edi+2824]
  00224	83 c4 0c	 add	 esp, 12			; 0000000cH
  00227	48		 dec	 eax
  00228	8b ce		 mov	 ecx, esi
  0022a	ff 75 08	 push	 DWORD PTR _str$[ebp]
  0022d	6a 01		 push	 1
  0022f	50		 push	 eax
  00230	e8 00 00 00 00	 call	 ?SetItemText@CGridCtrl@@QAEHHHPBD@Z ; CGridCtrl::SetItemText

; 1161 : 		CArray<double,double> *ValData = (CArray<double,double>*)m_pStrategyItem->GetValOptimizer();

  00235	8b 8f 10 05 00
	00		 mov	 ecx, DWORD PTR [edi+1296]
  0023b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0023d	ff 90 8c 00 00
	00		 call	 DWORD PTR [eax+140]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 288  : 	if(nIndex >= 0 && nIndex < m_nSize)

  00243	83 bf a0 11 00
	00 00		 cmp	 DWORD PTR [edi+4512], 0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 1161 : 		CArray<double,double> *ValData = (CArray<double,double>*)m_pStrategyItem->GetValOptimizer();

  0024a	8b d8		 mov	 ebx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 288  : 	if(nIndex >= 0 && nIndex < m_nSize)

  0024c	0f 8e db 05 00
	00		 jle	 $LN51@OnSTDataMa

; 289  : 		return m_pData[nIndex];

  00252	8b b7 9c 11 00
	00		 mov	 esi, DWORD PTR [edi+4508]
  00258	8d 4d b4	 lea	 ecx, DWORD PTR _stVal$2[ebp]
  0025b	56		 push	 esi
  0025c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z
  00262	f2 0f 10 46 08	 movsd	 xmm0, QWORD PTR [esi+8]
  00267	f2 0f 11 45 bc	 movsd	 QWORD PTR _stVal$2[ebp+8], xmm0
  0026c	f2 0f 10 46 10	 movsd	 xmm0, QWORD PTR [esi+16]
  00271	f2 0f 11 45 c4	 movsd	 QWORD PTR _stVal$2[ebp+16], xmm0
  00276	f2 0f 10 46 18	 movsd	 xmm0, QWORD PTR [esi+24]
  0027b	f2 0f 11 45 cc	 movsd	 QWORD PTR _stVal$2[ebp+24], xmm0
  00280	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00283	89 45 d4	 mov	 DWORD PTR _stVal$2[ebp+32], eax
  00286	f2 0f 10 46 28	 movsd	 xmm0, QWORD PTR [esi+40]
  0028b	f2 0f 11 45 dc	 movsd	 QWORD PTR _stVal$2[ebp+40], xmm0
  00290	f2 0f 10 46 30	 movsd	 xmm0, QWORD PTR [esi+48]
  00295	f2 0f 11 45 e4	 movsd	 QWORD PTR _stVal$2[ebp+48], xmm0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 1164 : 		for( j =0;j<ValData->GetSize();j++)// 

  0029a	33 f6		 xor	 esi, esi
  0029c	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  002a0	39 73 08	 cmp	 DWORD PTR [ebx+8], esi
  002a3	0f 8e 94 00 00
	00		 jle	 $LN3@OnSTDataMa
  002a9	0f 1f 80 00 00
	00 00		 npad	 7
$LL4@OnSTDataMa:

; 1165 : 		{
; 1166 : 			CString stValue;

  002b0	8d 4d 0c	 lea	 ecx, DWORD PTR _stValue$17[ebp]
  002b3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  002b9	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 288  : 	if(nIndex >= 0 && nIndex < m_nSize)

  002bd	85 f6		 test	 esi, esi
  002bf	0f 88 68 05 00
	00		 js	 $LN51@OnSTDataMa
  002c5	3b 73 08	 cmp	 esi, DWORD PTR [ebx+8]
  002c8	0f 8d 5f 05 00
	00		 jge	 $LN51@OnSTDataMa
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 1168 : 			if(stVal.nDataType ==2)

  002ce	83 7d d4 02	 cmp	 DWORD PTR _stVal$2[ebp+32], 2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 289  : 		return m_pData[nIndex];

  002d2	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 1167 : 			double Val = ValData->GetAt(j);//  .

  002d5	f2 0f 10 04 f0	 movsd	 xmm0, QWORD PTR [eax+esi*8]

; 1168 : 			if(stVal.nDataType ==2)

  002da	75 1c		 jne	 SHORT $LN12@OnSTDataMa

; 1169 : 				stValue.Format("%.2f",Val);

  002dc	83 ec 08	 sub	 esp, 8
  002df	8d 45 0c	 lea	 eax, DWORD PTR _stValue$17[ebp]
  002e2	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  002e7	68 00 00 00 00	 push	 OFFSET ??_C@_04GEFJINEE@?$CF?42f@
  002ec	50		 push	 eax
  002ed	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Format@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAAXPBDZZ
  002f3	83 c4 10	 add	 esp, 16			; 00000010H
  002f6	eb 17		 jmp	 SHORT $LN13@OnSTDataMa
$LN12@OnSTDataMa:

; 1170 : 			else
; 1171 : 				stValue.Format("%d",(INT)Val);

  002f8	f2 0f 2c c0	 cvttsd2si eax, xmm0
  002fc	50		 push	 eax
  002fd	8d 45 0c	 lea	 eax, DWORD PTR _stValue$17[ebp]
  00300	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  00305	50		 push	 eax
  00306	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Format@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAAXPBDZZ
  0030c	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN13@OnSTDataMa:

; 1172 : 			m_GridTap.SetItemText(m_GridTap.GetRowCount()-1,j,stValue);//

  0030f	ff 75 0c	 push	 DWORD PTR _stValue$17[ebp]
  00312	8b 87 08 0b 00
	00		 mov	 eax, DWORD PTR [edi+2824]
  00318	8d 8f f0 09 00
	00		 lea	 ecx, DWORD PTR [edi+2544]
  0031e	56		 push	 esi
  0031f	48		 dec	 eax
  00320	50		 push	 eax
  00321	e8 00 00 00 00	 call	 ?SetItemText@CGridCtrl@@QAEHHHPBD@Z ; CGridCtrl::SetItemText

; 1173 : 		}

  00326	8d 4d 0c	 lea	 ecx, DWORD PTR _stValue$17[ebp]
  00329	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  0032d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00333	46		 inc	 esi
  00334	3b 73 08	 cmp	 esi, DWORD PTR [ebx+8]
  00337	0f 8c 73 ff ff
	ff		 jl	 $LL4@OnSTDataMa
$LN3@OnSTDataMa:

; 1174 : 		m_GridTap.SetItemText(m_GridTap.GetRowCount()-1,j,m_pStrategyItem->GetSendValString());

  0033d	8b 8f 10 05 00
	00		 mov	 ecx, DWORD PTR [edi+1296]
  00343	8d 55 0c	 lea	 edx, DWORD PTR $T16[ebp]
  00346	52		 push	 edx
  00347	8b 01		 mov	 eax, DWORD PTR [ecx]
  00349	ff 90 90 00 00
	00		 call	 DWORD PTR [eax+144]
  0034f	ff 30		 push	 DWORD PTR [eax]
  00351	8b 87 08 0b 00
	00		 mov	 eax, DWORD PTR [edi+2824]
  00357	8d 8f f0 09 00
	00		 lea	 ecx, DWORD PTR [edi+2544]
  0035d	56		 push	 esi
  0035e	48		 dec	 eax
  0035f	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  00363	50		 push	 eax
  00364	e8 00 00 00 00	 call	 ?SetItemText@CGridCtrl@@QAEHHHPBD@Z ; CGridCtrl::SetItemText
  00369	8d 4d 0c	 lea	 ecx, DWORD PTR $T16[ebp]
  0036c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 1175 : 		Plus =j-1;

  00372	8d 46 ff	 lea	 eax, DWORD PTR [esi-1]

; 1176 : 	}

  00375	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00379	8d 4d b4	 lea	 ecx, DWORD PTR _stVal$2[ebp]
  0037c	89 45 0c	 mov	 DWORD PTR _Plus$1$[ebp], eax
  0037f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00385	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp_?Format@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAAXPBDZZ
  0038b	8d b7 f0 09 00
	00		 lea	 esi, DWORD PTR [edi+2544]
$LN103@OnSTDataMa:

; 1177 : 	//  ??   .3,9,4,5,7,8,0,18,15 
; 1178 : 	////////     /////////////////////
; 1179 : 	double Profit = m_pStrategyItem->GetStatisticalInfo(PROFITLOSSALL);//

  00391	8b 8f 10 05 00
	00		 mov	 ecx, DWORD PTR [edi+1296]
  00397	6a 03		 push	 3
  00399	8b 01		 mov	 eax, DWORD PTR [ecx]
  0039b	8b 40 50	 mov	 eax, DWORD PTR [eax+80]
  0039e	ff d0		 call	 eax
  003a0	dd 5d ec	 fstp	 QWORD PTR _Profit$[ebp]

; 1180 : 	str.Format("%d",(int)Profit);

  003a3	f2 0f 2c 45 ec	 cvttsd2si eax, QWORD PTR _Profit$[ebp]
  003a8	50		 push	 eax
  003a9	8d 45 08	 lea	 eax, DWORD PTR _str$[ebp]
  003ac	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  003b1	50		 push	 eax
  003b2	ff d3		 call	 ebx

; 1181 : 	str = m_DlgResult->GetComma(str);

  003b4	8b 8f 80 0e 00
	00		 mov	 ecx, DWORD PTR [edi+3712]
  003ba	8d 45 f0	 lea	 eax, DWORD PTR $T7[ebp]
  003bd	83 c4 0c	 add	 esp, 12			; 0000000cH
  003c0	ff 75 08	 push	 DWORD PTR _str$[ebp]
  003c3	50		 push	 eax
  003c4	e8 00 00 00 00	 call	 ?GetComma@CDlgResult@@QAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PBD@Z ; CDlgResult::GetComma
  003c9	50		 push	 eax
  003ca	8d 4d 08	 lea	 ecx, DWORD PTR _str$[ebp]
  003cd	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
  003d1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
  003d7	8d 4d f0	 lea	 ecx, DWORD PTR $T7[ebp]
  003da	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  003de	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 1182 : 	m_GridTap.SetItemText(m_GridTap.GetRowCount()-1,2+Plus,str,DT_RIGHT|DT_VCENTER|DT_SINGLELINE|DT_NOPREFIX);

  003e4	8b 45 0c	 mov	 eax, DWORD PTR _Plus$1$[ebp]
  003e7	8b ce		 mov	 ecx, esi
  003e9	68 26 08 00 00	 push	 2086			; 00000826H
  003ee	ff 75 08	 push	 DWORD PTR _str$[ebp]
  003f1	83 c0 02	 add	 eax, 2
  003f4	50		 push	 eax
  003f5	8b 87 08 0b 00
	00		 mov	 eax, DWORD PTR [edi+2824]
  003fb	48		 dec	 eax
  003fc	50		 push	 eax
  003fd	e8 00 00 00 00	 call	 ?SetItemText@CGridCtrl@@QAEHHHPBDK@Z ; CGridCtrl::SetItemText

; 1183 : 	Profit = m_pStrategyItem->GetStatisticalInfo(PROFITLOSSAVG);//

  00402	8b 8f 10 05 00
	00		 mov	 ecx, DWORD PTR [edi+1296]
  00408	6a 09		 push	 9
  0040a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0040c	8b 40 50	 mov	 eax, DWORD PTR [eax+80]
  0040f	ff d0		 call	 eax
  00411	dd 5d ec	 fstp	 QWORD PTR _Profit$[ebp]

; 1184 : 	str.Format("%d",(int)Profit);

  00414	f2 0f 2c 45 ec	 cvttsd2si eax, QWORD PTR _Profit$[ebp]
  00419	50		 push	 eax
  0041a	8d 45 08	 lea	 eax, DWORD PTR _str$[ebp]
  0041d	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  00422	50		 push	 eax
  00423	ff d3		 call	 ebx

; 1185 : 	str = m_DlgResult->GetComma(str);

  00425	8b 8f 80 0e 00
	00		 mov	 ecx, DWORD PTR [edi+3712]
  0042b	8d 45 f0	 lea	 eax, DWORD PTR $T6[ebp]
  0042e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00431	ff 75 08	 push	 DWORD PTR _str$[ebp]
  00434	50		 push	 eax
  00435	e8 00 00 00 00	 call	 ?GetComma@CDlgResult@@QAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PBD@Z ; CDlgResult::GetComma
  0043a	50		 push	 eax
  0043b	8d 4d 08	 lea	 ecx, DWORD PTR _str$[ebp]
  0043e	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
  00442	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
  00448	8d 4d f0	 lea	 ecx, DWORD PTR $T6[ebp]
  0044b	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0044f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 1186 : 	m_GridTap.SetItemText(m_GridTap.GetRowCount()-1,3+Plus,str,DT_RIGHT|DT_VCENTER|DT_SINGLELINE|DT_NOPREFIX);

  00455	8b 45 0c	 mov	 eax, DWORD PTR _Plus$1$[ebp]
  00458	8b ce		 mov	 ecx, esi
  0045a	68 26 08 00 00	 push	 2086			; 00000826H
  0045f	ff 75 08	 push	 DWORD PTR _str$[ebp]
  00462	83 c0 03	 add	 eax, 3
  00465	50		 push	 eax
  00466	8b 87 08 0b 00
	00		 mov	 eax, DWORD PTR [edi+2824]
  0046c	48		 dec	 eax
  0046d	50		 push	 eax
  0046e	e8 00 00 00 00	 call	 ?SetItemText@CGridCtrl@@QAEHHHPBDK@Z ; CGridCtrl::SetItemText

; 1187 : 	Profit = m_pStrategyItem->GetStatisticalInfo(PROFITALL);//

  00473	8b 8f 10 05 00
	00		 mov	 ecx, DWORD PTR [edi+1296]
  00479	6a 04		 push	 4
  0047b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0047d	8b 40 50	 mov	 eax, DWORD PTR [eax+80]
  00480	ff d0		 call	 eax
  00482	dd 5d ec	 fstp	 QWORD PTR _Profit$[ebp]

; 1188 : 	str.Format("%d",(int)Profit);

  00485	f2 0f 2c 45 ec	 cvttsd2si eax, QWORD PTR _Profit$[ebp]
  0048a	50		 push	 eax
  0048b	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  00490	8d 45 08	 lea	 eax, DWORD PTR _str$[ebp]
  00493	50		 push	 eax
  00494	ff d3		 call	 ebx

; 1189 : 	str = m_DlgResult->GetComma(str);

  00496	8b 8f 80 0e 00
	00		 mov	 ecx, DWORD PTR [edi+3712]
  0049c	8d 45 f0	 lea	 eax, DWORD PTR $T5[ebp]
  0049f	83 c4 0c	 add	 esp, 12			; 0000000cH
  004a2	ff 75 08	 push	 DWORD PTR _str$[ebp]
  004a5	50		 push	 eax
  004a6	e8 00 00 00 00	 call	 ?GetComma@CDlgResult@@QAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PBD@Z ; CDlgResult::GetComma
  004ab	50		 push	 eax
  004ac	8d 4d 08	 lea	 ecx, DWORD PTR _str$[ebp]
  004af	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+8], 9
  004b3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
  004b9	8d 4d f0	 lea	 ecx, DWORD PTR $T5[ebp]
  004bc	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  004c0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 1190 : 	m_GridTap.SetItemText(m_GridTap.GetRowCount()-1,4+Plus,str,DT_RIGHT|DT_VCENTER|DT_SINGLELINE|DT_NOPREFIX);

  004c6	8b 45 0c	 mov	 eax, DWORD PTR _Plus$1$[ebp]
  004c9	8b ce		 mov	 ecx, esi
  004cb	68 26 08 00 00	 push	 2086			; 00000826H
  004d0	ff 75 08	 push	 DWORD PTR _str$[ebp]
  004d3	83 c0 04	 add	 eax, 4
  004d6	50		 push	 eax
  004d7	8b 87 08 0b 00
	00		 mov	 eax, DWORD PTR [edi+2824]
  004dd	48		 dec	 eax
  004de	50		 push	 eax
  004df	e8 00 00 00 00	 call	 ?SetItemText@CGridCtrl@@QAEHHHPBDK@Z ; CGridCtrl::SetItemText

; 1191 : 	Profit = m_pStrategyItem->GetStatisticalInfo(LOSSALL);//

  004e4	8b 8f 10 05 00
	00		 mov	 ecx, DWORD PTR [edi+1296]
  004ea	6a 05		 push	 5
  004ec	8b 01		 mov	 eax, DWORD PTR [ecx]
  004ee	8b 40 50	 mov	 eax, DWORD PTR [eax+80]
  004f1	ff d0		 call	 eax
  004f3	dd 5d ec	 fstp	 QWORD PTR _Profit$[ebp]

; 1192 : 	str.Format("%d",(int)Profit);

  004f6	f2 0f 2c 45 ec	 cvttsd2si eax, QWORD PTR _Profit$[ebp]
  004fb	50		 push	 eax
  004fc	8d 45 08	 lea	 eax, DWORD PTR _str$[ebp]
  004ff	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  00504	50		 push	 eax
  00505	ff d3		 call	 ebx

; 1193 : 	str = m_DlgResult->GetComma(str);

  00507	8b 8f 80 0e 00
	00		 mov	 ecx, DWORD PTR [edi+3712]
  0050d	8d 45 f0	 lea	 eax, DWORD PTR $T4[ebp]
  00510	83 c4 0c	 add	 esp, 12			; 0000000cH
  00513	ff 75 08	 push	 DWORD PTR _str$[ebp]
  00516	50		 push	 eax
  00517	e8 00 00 00 00	 call	 ?GetComma@CDlgResult@@QAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PBD@Z ; CDlgResult::GetComma
  0051c	50		 push	 eax
  0051d	8d 4d 08	 lea	 ecx, DWORD PTR _str$[ebp]
  00520	c6 45 fc 0a	 mov	 BYTE PTR __$EHRec$[ebp+8], 10 ; 0000000aH
  00524	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
  0052a	8d 4d f0	 lea	 ecx, DWORD PTR $T4[ebp]
  0052d	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00531	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 1194 : 	m_GridTap.SetItemText(m_GridTap.GetRowCount()-1,5+Plus,str,DT_RIGHT|DT_VCENTER|DT_SINGLELINE|DT_NOPREFIX);

  00537	8b 45 0c	 mov	 eax, DWORD PTR _Plus$1$[ebp]
  0053a	8b ce		 mov	 ecx, esi
  0053c	68 26 08 00 00	 push	 2086			; 00000826H
  00541	ff 75 08	 push	 DWORD PTR _str$[ebp]
  00544	83 c0 05	 add	 eax, 5
  00547	50		 push	 eax
  00548	8b 87 08 0b 00
	00		 mov	 eax, DWORD PTR [edi+2824]
  0054e	48		 dec	 eax
  0054f	50		 push	 eax
  00550	e8 00 00 00 00	 call	 ?SetItemText@CGridCtrl@@QAEHHHPBDK@Z ; CGridCtrl::SetItemText

; 1195 : 	Profit = m_pStrategyItem->GetStatisticalInfo(MAXPROFIT);//

  00555	8b 8f 10 05 00
	00		 mov	 ecx, DWORD PTR [edi+1296]
  0055b	6a 07		 push	 7
  0055d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0055f	8b 40 50	 mov	 eax, DWORD PTR [eax+80]
  00562	ff d0		 call	 eax
  00564	dd 5d ec	 fstp	 QWORD PTR _Profit$[ebp]

; 1196 : 	str.Format("%d",(int)Profit);

  00567	f2 0f 2c 45 ec	 cvttsd2si eax, QWORD PTR _Profit$[ebp]
  0056c	50		 push	 eax
  0056d	8d 45 08	 lea	 eax, DWORD PTR _str$[ebp]
  00570	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  00575	50		 push	 eax
  00576	ff d3		 call	 ebx

; 1197 : 	str = m_DlgResult->GetComma(str);

  00578	8b 8f 80 0e 00
	00		 mov	 ecx, DWORD PTR [edi+3712]
  0057e	8d 45 f0	 lea	 eax, DWORD PTR $T3[ebp]
  00581	83 c4 0c	 add	 esp, 12			; 0000000cH
  00584	ff 75 08	 push	 DWORD PTR _str$[ebp]
  00587	50		 push	 eax
  00588	e8 00 00 00 00	 call	 ?GetComma@CDlgResult@@QAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PBD@Z ; CDlgResult::GetComma
  0058d	50		 push	 eax
  0058e	8d 4d 08	 lea	 ecx, DWORD PTR _str$[ebp]
  00591	c6 45 fc 0b	 mov	 BYTE PTR __$EHRec$[ebp+8], 11 ; 0000000bH
  00595	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
  0059b	8d 4d f0	 lea	 ecx, DWORD PTR $T3[ebp]
  0059e	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  005a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 1198 : 	m_GridTap.SetItemText(m_GridTap.GetRowCount()-1,6+Plus,str,DT_RIGHT|DT_VCENTER|DT_SINGLELINE|DT_NOPREFIX);

  005a8	8b 45 0c	 mov	 eax, DWORD PTR _Plus$1$[ebp]
  005ab	8b ce		 mov	 ecx, esi
  005ad	68 26 08 00 00	 push	 2086			; 00000826H
  005b2	ff 75 08	 push	 DWORD PTR _str$[ebp]
  005b5	83 c0 06	 add	 eax, 6
  005b8	50		 push	 eax
  005b9	8b 87 08 0b 00
	00		 mov	 eax, DWORD PTR [edi+2824]
  005bf	48		 dec	 eax
  005c0	50		 push	 eax
  005c1	e8 00 00 00 00	 call	 ?SetItemText@CGridCtrl@@QAEHHHPBDK@Z ; CGridCtrl::SetItemText

; 1199 : 	//////////////////////////
; 1200 : 	if(m_nOptimizerDiv == INDEX_OPTIMIZER)//  .

  005c6	81 bf 70 11 00
	00 e9 03 00 00	 cmp	 DWORD PTR [edi+4464], 1001 ; 000003e9H
  005d0	0f 85 31 02 00
	00		 jne	 $LN14@OnSTDataMa

; 1201 : 	{
; 1202 : 		Profit = m_pStrategyItem->GetStatisticalInfo(MAXLOSS);//

  005d6	8b 8f 10 05 00
	00		 mov	 ecx, DWORD PTR [edi+1296]
  005dc	6a 08		 push	 8
  005de	8b 01		 mov	 eax, DWORD PTR [ecx]
  005e0	8b 40 50	 mov	 eax, DWORD PTR [eax+80]
  005e3	ff d0		 call	 eax
  005e5	dd 5d ec	 fstp	 QWORD PTR _Profit$[ebp]

; 1203 : 		str.Format("%d",(int)Profit);

  005e8	f2 0f 2c 45 ec	 cvttsd2si eax, QWORD PTR _Profit$[ebp]
  005ed	50		 push	 eax
  005ee	8d 45 08	 lea	 eax, DWORD PTR _str$[ebp]
  005f1	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  005f6	50		 push	 eax
  005f7	ff d3		 call	 ebx

; 1204 : 		str = m_DlgResult->GetComma(str);

  005f9	8b 8f 80 0e 00
	00		 mov	 ecx, DWORD PTR [edi+3712]
  005ff	8d 45 0c	 lea	 eax, DWORD PTR $T15[ebp]
  00602	83 c4 0c	 add	 esp, 12			; 0000000cH
  00605	ff 75 08	 push	 DWORD PTR _str$[ebp]
  00608	50		 push	 eax
  00609	e8 00 00 00 00	 call	 ?GetComma@CDlgResult@@QAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PBD@Z ; CDlgResult::GetComma
  0060e	50		 push	 eax
  0060f	8d 4d 08	 lea	 ecx, DWORD PTR _str$[ebp]
  00612	c6 45 fc 0c	 mov	 BYTE PTR __$EHRec$[ebp+8], 12 ; 0000000cH
  00616	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
  0061c	8d 4d 0c	 lea	 ecx, DWORD PTR $T15[ebp]
  0061f	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00623	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 1205 : 		m_GridTap.SetItemText(m_GridTap.GetRowCount()-1,7,str,DT_RIGHT|DT_VCENTER|DT_SINGLELINE|DT_NOPREFIX);

  00629	8b 87 08 0b 00
	00		 mov	 eax, DWORD PTR [edi+2824]
  0062f	8b ce		 mov	 ecx, esi
  00631	68 26 08 00 00	 push	 2086			; 00000826H
  00636	ff 75 08	 push	 DWORD PTR _str$[ebp]
  00639	48		 dec	 eax
  0063a	6a 07		 push	 7
  0063c	50		 push	 eax
  0063d	e8 00 00 00 00	 call	 ?SetItemText@CGridCtrl@@QAEHHHPBDK@Z ; CGridCtrl::SetItemText

; 1206 : 		Profit = m_pStrategyItem->GetStatisticalInfo(PROFITRATEACCMULATED);//

  00642	8b 8f 10 05 00
	00		 mov	 ecx, DWORD PTR [edi+1296]
  00648	6a 00		 push	 0
  0064a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0064c	8b 40 50	 mov	 eax, DWORD PTR [eax+80]
  0064f	ff d0		 call	 eax

; 1207 : 		str.Format("%.2f",Profit);

  00651	83 ec 08	 sub	 esp, 8
  00654	8d 45 08	 lea	 eax, DWORD PTR _str$[ebp]
  00657	dd 5d ec	 fstp	 QWORD PTR _Profit$[ebp]
  0065a	f2 0f 10 45 ec	 movsd	 xmm0, QWORD PTR _Profit$[ebp]
  0065f	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00664	68 00 00 00 00	 push	 OFFSET ??_C@_04GEFJINEE@?$CF?42f@
  00669	50		 push	 eax
  0066a	ff d3		 call	 ebx

; 1208 : 		str = m_DlgResult->GetComma(str);

  0066c	8b 8f 80 0e 00
	00		 mov	 ecx, DWORD PTR [edi+3712]
  00672	8d 45 0c	 lea	 eax, DWORD PTR $T14[ebp]
  00675	83 c4 10	 add	 esp, 16			; 00000010H
  00678	ff 75 08	 push	 DWORD PTR _str$[ebp]
  0067b	50		 push	 eax
  0067c	e8 00 00 00 00	 call	 ?GetComma@CDlgResult@@QAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PBD@Z ; CDlgResult::GetComma
  00681	50		 push	 eax
  00682	8d 4d 08	 lea	 ecx, DWORD PTR _str$[ebp]
  00685	c6 45 fc 0d	 mov	 BYTE PTR __$EHRec$[ebp+8], 13 ; 0000000dH
  00689	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
  0068f	8d 4d 0c	 lea	 ecx, DWORD PTR $T14[ebp]
  00692	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00696	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 1209 : 		m_GridTap.SetItemText(m_GridTap.GetRowCount()-1,8,str,DT_RIGHT|DT_VCENTER|DT_SINGLELINE|DT_NOPREFIX);

  0069c	8b 87 08 0b 00
	00		 mov	 eax, DWORD PTR [edi+2824]
  006a2	8b ce		 mov	 ecx, esi
  006a4	68 26 08 00 00	 push	 2086			; 00000826H
  006a9	ff 75 08	 push	 DWORD PTR _str$[ebp]
  006ac	48		 dec	 eax
  006ad	6a 08		 push	 8
  006af	50		 push	 eax
  006b0	e8 00 00 00 00	 call	 ?SetItemText@CGridCtrl@@QAEHHHPBDK@Z ; CGridCtrl::SetItemText

; 1210 : 		Profit = m_pStrategyItem->GetStatisticalInfo(PROFITLOSSRATEALL);//Profit Factor

  006b5	8b 8f 10 05 00
	00		 mov	 ecx, DWORD PTR [edi+1296]
  006bb	6a 06		 push	 6
  006bd	8b 01		 mov	 eax, DWORD PTR [ecx]
  006bf	8b 40 50	 mov	 eax, DWORD PTR [eax+80]
  006c2	ff d0		 call	 eax

; 1211 : 		str.Format("%.2f",Profit);

  006c4	83 ec 08	 sub	 esp, 8
  006c7	8d 45 08	 lea	 eax, DWORD PTR _str$[ebp]
  006ca	dd 5d ec	 fstp	 QWORD PTR _Profit$[ebp]
  006cd	f2 0f 10 45 ec	 movsd	 xmm0, QWORD PTR _Profit$[ebp]
  006d2	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  006d7	68 00 00 00 00	 push	 OFFSET ??_C@_04GEFJINEE@?$CF?42f@
  006dc	50		 push	 eax
  006dd	ff d3		 call	 ebx

; 1212 : 		str = m_DlgResult->GetComma(str);

  006df	8b 8f 80 0e 00
	00		 mov	 ecx, DWORD PTR [edi+3712]
  006e5	8d 45 0c	 lea	 eax, DWORD PTR $T13[ebp]
  006e8	83 c4 10	 add	 esp, 16			; 00000010H
  006eb	ff 75 08	 push	 DWORD PTR _str$[ebp]
  006ee	50		 push	 eax
  006ef	e8 00 00 00 00	 call	 ?GetComma@CDlgResult@@QAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PBD@Z ; CDlgResult::GetComma
  006f4	50		 push	 eax
  006f5	8d 4d 08	 lea	 ecx, DWORD PTR _str$[ebp]
  006f8	c6 45 fc 0e	 mov	 BYTE PTR __$EHRec$[ebp+8], 14 ; 0000000eH
  006fc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
  00702	8d 4d 0c	 lea	 ecx, DWORD PTR $T13[ebp]
  00705	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00709	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 1213 : 		m_GridTap.SetItemText(m_GridTap.GetRowCount()-1,9,str,DT_RIGHT|DT_VCENTER|DT_SINGLELINE|DT_NOPREFIX);

  0070f	8b 87 08 0b 00
	00		 mov	 eax, DWORD PTR [edi+2824]
  00715	8b ce		 mov	 ecx, esi
  00717	68 26 08 00 00	 push	 2086			; 00000826H
  0071c	ff 75 08	 push	 DWORD PTR _str$[ebp]
  0071f	48		 dec	 eax
  00720	6a 09		 push	 9
  00722	50		 push	 eax
  00723	e8 00 00 00 00	 call	 ?SetItemText@CGridCtrl@@QAEHHHPBDK@Z ; CGridCtrl::SetItemText

; 1214 : 		Profit = m_pStrategyItem->GetStatisticalInfo(RATEPROFIT);//

  00728	8b 8f 10 05 00
	00		 mov	 ecx, DWORD PTR [edi+1296]
  0072e	6a 13		 push	 19			; 00000013H
  00730	8b 01		 mov	 eax, DWORD PTR [ecx]
  00732	8b 40 50	 mov	 eax, DWORD PTR [eax+80]
  00735	ff d0		 call	 eax

; 1215 : 		str.Format("%.2f",Profit);

  00737	83 ec 08	 sub	 esp, 8
  0073a	8d 45 08	 lea	 eax, DWORD PTR _str$[ebp]
  0073d	dd 5d ec	 fstp	 QWORD PTR _Profit$[ebp]
  00740	f2 0f 10 45 ec	 movsd	 xmm0, QWORD PTR _Profit$[ebp]
  00745	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0074a	68 00 00 00 00	 push	 OFFSET ??_C@_04GEFJINEE@?$CF?42f@
  0074f	50		 push	 eax
  00750	ff d3		 call	 ebx

; 1216 : 		str = m_DlgResult->GetComma(str);

  00752	8b 8f 80 0e 00
	00		 mov	 ecx, DWORD PTR [edi+3712]
  00758	8d 45 0c	 lea	 eax, DWORD PTR $T12[ebp]
  0075b	83 c4 10	 add	 esp, 16			; 00000010H
  0075e	ff 75 08	 push	 DWORD PTR _str$[ebp]
  00761	50		 push	 eax
  00762	e8 00 00 00 00	 call	 ?GetComma@CDlgResult@@QAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PBD@Z ; CDlgResult::GetComma
  00767	50		 push	 eax
  00768	8d 4d 08	 lea	 ecx, DWORD PTR _str$[ebp]
  0076b	c6 45 fc 0f	 mov	 BYTE PTR __$EHRec$[ebp+8], 15 ; 0000000fH
  0076f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
  00775	8d 4d 0c	 lea	 ecx, DWORD PTR $T12[ebp]
  00778	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0077c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 1217 : 		m_GridTap.SetItemText(m_GridTap.GetRowCount()-1,10,str,DT_RIGHT|DT_VCENTER|DT_SINGLELINE|DT_NOPREFIX);

  00782	8b 87 08 0b 00
	00		 mov	 eax, DWORD PTR [edi+2824]
  00788	8b ce		 mov	 ecx, esi
  0078a	68 26 08 00 00	 push	 2086			; 00000826H
  0078f	ff 75 08	 push	 DWORD PTR _str$[ebp]
  00792	48		 dec	 eax
  00793	6a 0a		 push	 10			; 0000000aH
  00795	50		 push	 eax
  00796	e8 00 00 00 00	 call	 ?SetItemText@CGridCtrl@@QAEHHHPBDK@Z ; CGridCtrl::SetItemText

; 1218 : 		Profit = m_pStrategyItem->GetStatisticalInfo(CNTALL);//

  0079b	8b 8f 10 05 00
	00		 mov	 ecx, DWORD PTR [edi+1296]
  007a1	6a 0f		 push	 15			; 0000000fH
  007a3	8b 01		 mov	 eax, DWORD PTR [ecx]
  007a5	8b 40 50	 mov	 eax, DWORD PTR [eax+80]
  007a8	ff d0		 call	 eax
  007aa	dd 5d ec	 fstp	 QWORD PTR _Profit$[ebp]

; 1219 : 		str.Format("%d",(int)Profit);

  007ad	f2 0f 2c 45 ec	 cvttsd2si eax, QWORD PTR _Profit$[ebp]
  007b2	50		 push	 eax
  007b3	8d 45 08	 lea	 eax, DWORD PTR _str$[ebp]
  007b6	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  007bb	50		 push	 eax
  007bc	ff d3		 call	 ebx

; 1220 : 		str = m_DlgResult->GetComma(str);

  007be	8b 8f 80 0e 00
	00		 mov	 ecx, DWORD PTR [edi+3712]
  007c4	8d 45 0c	 lea	 eax, DWORD PTR $T11[ebp]
  007c7	83 c4 0c	 add	 esp, 12			; 0000000cH
  007ca	ff 75 08	 push	 DWORD PTR _str$[ebp]
  007cd	50		 push	 eax
  007ce	e8 00 00 00 00	 call	 ?GetComma@CDlgResult@@QAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PBD@Z ; CDlgResult::GetComma
  007d3	50		 push	 eax
  007d4	8d 4d 08	 lea	 ecx, DWORD PTR _str$[ebp]
  007d7	c6 45 fc 10	 mov	 BYTE PTR __$EHRec$[ebp+8], 16 ; 00000010H
  007db	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
  007e1	8d 4d 0c	 lea	 ecx, DWORD PTR $T11[ebp]
  007e4	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  007e8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 1221 : 		m_GridTap.SetItemText(m_GridTap.GetRowCount()-1,11,str,DT_RIGHT|DT_VCENTER|DT_SINGLELINE|DT_NOPREFIX);

  007ee	8b 87 08 0b 00
	00		 mov	 eax, DWORD PTR [edi+2824]
  007f4	8b ce		 mov	 ecx, esi
  007f6	68 26 08 00 00	 push	 2086			; 00000826H
  007fb	ff 75 08	 push	 DWORD PTR _str$[ebp]
  007fe	48		 dec	 eax
  007ff	6a 0b		 push	 11			; 0000000bH
  00801	50		 push	 eax
  00802	e8 00 00 00 00	 call	 ?SetItemText@CGridCtrl@@QAEHHHPBDK@Z ; CGridCtrl::SetItemText
$LN14@OnSTDataMa:

; 1222 : 	}
; 1223 : 	//AutoSizeColumns();
; 1224 : 	m_GridTap.Refresh();

  00807	8b ce		 mov	 ecx, esi
  00809	e8 00 00 00 00	 call	 ?Refresh@CGridCtrl@@QAEXXZ ; CGridCtrl::Refresh

; 1225 : 	return 0;

  0080e	8d 4d 08	 lea	 ecx, DWORD PTR _str$[ebp]
  00811	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$LN107@OnSTDataMa:

; 1226 : }

  00817	33 c0		 xor	 eax, eax
  00819	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0081c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00823	59		 pop	 ecx
  00824	5f		 pop	 edi
  00825	5e		 pop	 esi
  00826	5b		 pop	 ebx
  00827	8b e5		 mov	 esp, ebp
  00829	5d		 pop	 ebp
  0082a	c2 08 00	 ret	 8
$LN51@OnSTDataMa:
  0082d	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN106@OnSTDataMa:
  00832	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?OnSTDataManagerMessagge@CDlgOptimizer@@IAEJIJ@Z$0:
  00000	8d 4d 08	 lea	 ecx, DWORD PTR _str$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?OnSTDataManagerMessagge@CDlgOptimizer@@IAEJIJ@Z$1:
  00009	8d 4d f0	 lea	 ecx, DWORD PTR $T10[ebp]
  0000c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?OnSTDataManagerMessagge@CDlgOptimizer@@IAEJIJ@Z$2:
  00012	8d 4d f0	 lea	 ecx, DWORD PTR $T9[ebp]
  00015	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?OnSTDataManagerMessagge@CDlgOptimizer@@IAEJIJ@Z$3:
  0001b	8d 4d f0	 lea	 ecx, DWORD PTR $T8[ebp]
  0001e	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?OnSTDataManagerMessagge@CDlgOptimizer@@IAEJIJ@Z$4:
  00024	8d 4d b4	 lea	 ecx, DWORD PTR _stVal$2[ebp]
  00027	e9 00 00 00 00	 jmp	 ??1ST_VALUEOPTIMAZE@@QAE@XZ
__unwindfunclet$?OnSTDataManagerMessagge@CDlgOptimizer@@IAEJIJ@Z$5:
  0002c	8d 4d 0c	 lea	 ecx, DWORD PTR _stValue$17[ebp]
  0002f	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?OnSTDataManagerMessagge@CDlgOptimizer@@IAEJIJ@Z$6:
  00035	8d 4d 0c	 lea	 ecx, DWORD PTR $T16[ebp]
  00038	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?OnSTDataManagerMessagge@CDlgOptimizer@@IAEJIJ@Z$7:
  0003e	8d 4d f0	 lea	 ecx, DWORD PTR $T7[ebp]
  00041	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?OnSTDataManagerMessagge@CDlgOptimizer@@IAEJIJ@Z$8:
  00047	8d 4d f0	 lea	 ecx, DWORD PTR $T6[ebp]
  0004a	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?OnSTDataManagerMessagge@CDlgOptimizer@@IAEJIJ@Z$9:
  00050	8d 4d f0	 lea	 ecx, DWORD PTR $T5[ebp]
  00053	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?OnSTDataManagerMessagge@CDlgOptimizer@@IAEJIJ@Z$10:
  00059	8d 4d f0	 lea	 ecx, DWORD PTR $T4[ebp]
  0005c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?OnSTDataManagerMessagge@CDlgOptimizer@@IAEJIJ@Z$11:
  00062	8d 4d f0	 lea	 ecx, DWORD PTR $T3[ebp]
  00065	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?OnSTDataManagerMessagge@CDlgOptimizer@@IAEJIJ@Z$12:
  0006b	8d 4d 0c	 lea	 ecx, DWORD PTR $T15[ebp]
  0006e	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?OnSTDataManagerMessagge@CDlgOptimizer@@IAEJIJ@Z$13:
  00074	8d 4d 0c	 lea	 ecx, DWORD PTR $T14[ebp]
  00077	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?OnSTDataManagerMessagge@CDlgOptimizer@@IAEJIJ@Z$14:
  0007d	8d 4d 0c	 lea	 ecx, DWORD PTR $T13[ebp]
  00080	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?OnSTDataManagerMessagge@CDlgOptimizer@@IAEJIJ@Z$15:
  00086	8d 4d 0c	 lea	 ecx, DWORD PTR $T12[ebp]
  00089	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?OnSTDataManagerMessagge@CDlgOptimizer@@IAEJIJ@Z$16:
  0008f	8d 4d 0c	 lea	 ecx, DWORD PTR $T11[ebp]
  00092	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00098	cc		 int	 3
  00099	cc		 int	 3
  0009a	cc		 int	 3
  0009b	cc		 int	 3
  0009c	cc		 int	 3
__ehhandler$?OnSTDataManagerMessagge@CDlgOptimizer@@IAEJIJ@Z:
  0009d	90		 npad	 1
  0009e	90		 npad	 1
  0009f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  000a3	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  000a6	8b 4a b0	 mov	 ecx, DWORD PTR [edx-80]
  000a9	33 c8		 xor	 ecx, eax
  000ab	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b0	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?OnSTDataManagerMessagge@CDlgOptimizer@@IAEJIJ@Z
  000b5	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?OnSTDataManagerMessagge@CDlgOptimizer@@IAEJIJ@Z ENDP	; CDlgOptimizer::OnSTDataManagerMessagge
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
;	COMDAT ?OnBtnStop@CDlgOptimizer@@IAEXXZ
_TEXT	SEGMENT
?OnBtnStop@CDlgOptimizer@@IAEXXZ PROC			; CDlgOptimizer::OnBtnStop, COMDAT
; _this$ = ecx

; 1475 : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1476 : 	// TODO: Add your control notification handler code here
; 1477 : 	m_pStrategyItem->Stop();

  00003	8b 8e 10 05 00
	00		 mov	 ecx, DWORD PTR [esi+1296]
  00009	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000b	ff 50 1c	 call	 DWORD PTR [eax+28]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl

; 155  : 	{ ASSERT(::IsWindow(m_hWnd)); return ::KillTimer(m_hWnd, nIDEvent); }

  0000e	ff b6 c4 0e 00
	00		 push	 DWORD PTR [esi+3780]
  00014	ff 76 20	 push	 DWORD PTR [esi+32]
  00017	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KillTimer@8
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 1480 : 	m_lSendNum = Size;

  0001d	8b 86 3c 0f 00
	00		 mov	 eax, DWORD PTR [esi+3900]

; 1481 : 	//m_CtlProgress.SetPos(m_lSendNum);
; 1482 : 	GetDlgItem(IDC_BTN_STOP)->ShowWindow(FALSE);

  00023	8b ce		 mov	 ecx, esi
  00025	6a 00		 push	 0
  00027	68 58 33 00 00	 push	 13144			; 00003358H
  0002c	89 86 b8 0e 00
	00		 mov	 DWORD PTR [esi+3768], eax
  00032	e8 00 00 00 00	 call	 ?GetDlgItem@CWnd@@QBEPAV1@H@Z ; CWnd::GetDlgItem
  00037	8b c8		 mov	 ecx, eax
  00039	e8 00 00 00 00	 call	 ?ShowWindow@CWnd@@QAEHH@Z ; CWnd::ShowWindow

; 1483 : 	GetDlgItem(IDC_BTN_OPT)->ShowWindow(TRUE);

  0003e	6a 01		 push	 1
  00040	68 07 33 00 00	 push	 13063			; 00003307H
  00045	8b ce		 mov	 ecx, esi
  00047	e8 00 00 00 00	 call	 ?GetDlgItem@CWnd@@QBEPAV1@H@Z ; CWnd::GetDlgItem
  0004c	8b c8		 mov	 ecx, eax
  0004e	e8 00 00 00 00	 call	 ?ShowWindow@CWnd@@QAEHH@Z ; CWnd::ShowWindow
  00053	5e		 pop	 esi

; 1484 : 	//SpreadGridData();
; 1485 : 	SetControlState(TRUE);
; 1486 : }

  00054	c3		 ret	 0
?OnBtnStop@CDlgOptimizer@@IAEXXZ ENDP			; CDlgOptimizer::OnBtnStop
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
;	COMDAT ?OnTimer@CDlgOptimizer@@IAEXI@Z
_TEXT	SEGMENT
_nIDEvent$ = 8						; size = 4
?OnTimer@CDlgOptimizer@@IAEXI@Z PROC			; CDlgOptimizer::OnTimer, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl

; 466  : 	{ Default(); }

  00000	e8 00 00 00 00	 call	 ?Default@CWnd@@IAEJXZ	; CWnd::Default
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 1405 : }

  00005	c2 04 00	 ret	 4
?OnTimer@CDlgOptimizer@@IAEXI@Z ENDP			; CDlgOptimizer::OnTimer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
;	COMDAT ?OnBtnOpt@CDlgOptimizer@@IAEXXZ
_TEXT	SEGMENT
_stArraySendData$2 = -236				; size = 20
_stValOtm$3 = -216					; size = 56
_stVal$4 = -160						; size = 56
_stArrayPath$ = -104					; size = 20
_stArraySTPath$ = -84					; size = 20
_strSystemPath$ = -64					; size = 4
_strUserPath$ = -60					; size = 4
_nRoof$1$ = -56						; size = 8
_this$1$ = -52						; size = 4
tv2673 = -52						; size = 4
$T5 = -52						; size = 4
tv2593 = -48						; size = 8
_nCount$1$ = -44					; size = 4
_BongEnd$1$ = -44					; size = 4
_nListCount$1$ = -44					; size = 4
_i$2$ = -40						; size = 4
_BongIncrease$1$ = -40					; size = 4
_pItemInfo$1$ = -40					; size = 4
_szSTPath$ = -36					; size = 4
_nSize$1$ = -32						; size = 4
$T6 = -32						; size = 4
_bRetValue$1$ = -28					; size = 4
$T7 = -28						; size = 4
$T8 = -24						; size = 4
_stOption$9 = -24					; size = 4
_j$1$ = -20						; size = 4
_nBong$1$ = -20						; size = 4
tv2657 = -20						; size = 4
$T10 = -20						; size = 4
_i$1$ = -16						; size = 4
tv2658 = -16						; size = 4
_stValue$11 = -16					; size = 4
$T12 = -16						; size = 4
$T13 = -16						; size = 4
$T14 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?OnBtnOpt@CDlgOptimizer@@IAEXXZ PROC			; CDlgOptimizer::OnBtnOpt, COMDAT
; _this$ = ecx

; 869  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?OnBtnOpt@CDlgOptimizer@@IAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec e0 00 00
	00		 sub	 esp, 224		; 000000e0H
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001f	33 c5		 xor	 eax, ebp
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b f9		 mov	 edi, ecx
  0002d	89 7d cc	 mov	 DWORD PTR _this$1$[ebp], edi
  00030	33 db		 xor	 ebx, ebx

; 870  : 	// TODO: Add your control notification handler code here
; 871  : 	//, ,    //////////////////
; 872  : 	//   
; 873  : 	CString szSTPath;

  00032	8d 4d dc	 lea	 ecx, DWORD PTR _szSTPath$[ebp]
  00035	89 5d e8	 mov	 DWORD PTR $T8[ebp], ebx
  00038	89 5d e4	 mov	 DWORD PTR $T7[ebp], ebx
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 874  : 
; 875  : 	CStringArray stArraySTPath;

  00041	8d 4d ac	 lea	 ecx, DWORD PTR _stArraySTPath$[ebp]
  00044	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ebx
  00047	e8 00 00 00 00	 call	 ??0CStringArray@@QAE@XZ	; CStringArray::CStringArray

; 876  : 	CStringArray stArrayPath;

  0004c	8d 4d 98	 lea	 ecx, DWORD PTR _stArrayPath$[ebp]
  0004f	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00053	e8 00 00 00 00	 call	 ??0CStringArray@@QAE@XZ	; CStringArray::CStringArray

; 877  : 	
; 878  : 	//  .
; 879  : 	//for(int i =1;i<m_GridTap.GetRowCount();i++)
; 880  : 	m_GridTap.SetRowCount(1);

  00058	6a 01		 push	 1
  0005a	8d 8f f0 09 00
	00		 lea	 ecx, DWORD PTR [edi+2544]
  00060	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00064	e8 00 00 00 00	 call	 ?SetRowCount@CGridCtrl@@QAEHH@Z ; CGridCtrl::SetRowCount

; 881  : 	m_bGridClick = FALSE;
; 882  : 	if(m_nOptimizerDiv == TIME_OPTIMIZER || m_nOptimizerDiv == INDEX_OPTIMIZER)

  00069	8b 87 70 11 00
	00		 mov	 eax, DWORD PTR [edi+4464]
  0006f	89 9f 8c 11 00
	00		 mov	 DWORD PTR [edi+4492], ebx
  00075	3d eb 03 00 00	 cmp	 eax, 1003		; 000003ebH
  0007a	74 0b		 je	 SHORT $LN30@OnBtnOpt
  0007c	3d e9 03 00 00	 cmp	 eax, 1001		; 000003e9H
  00081	0f 85 63 01 00
	00		 jne	 $LN3@OnBtnOpt
$LN30@OnBtnOpt:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl

; 664  : 	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_GETCOUNT, 0, 0); }

  00087	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SendMessageA@16
  0008d	6a 00		 push	 0
  0008f	6a 00		 push	 0
  00091	68 8b 01 00 00	 push	 395			; 0000018bH
  00096	ff b7 10 11 00
	00		 push	 DWORD PTR [edi+4368]
  0009c	ff d6		 call	 esi
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 885  : 		int nListCount = m_listST.GetCount();

  0009e	89 45 d4	 mov	 DWORD PTR _nListCount$1$[ebp], eax

; 886  : 		if(nListCount <=0){

  000a1	85 c0		 test	 eax, eax
  000a3	7f 13		 jg	 SHORT $LN31@OnBtnOpt

; 887  : 			AfxMessageBox("  .");

  000a5	6a 00		 push	 0
  000a7	6a 00		 push	 0
  000a9	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@IMFLIICM@?$MA?$PM?$LH?$KL?$MA?L?5?$LI?$KO?$LN?$LK?F?$KO?$LP?$KB?5?$LO?x?$LN?$MA?$LE?O?$LE?Y?4@
  000ae	e8 00 00 00 00	 call	 ?AfxMessageBox@@YGHPBDII@Z ; AfxMessageBox
  000b3	e9 ee 0a 00 00	 jmp	 $LN87@OnBtnOpt
$LN31@OnBtnOpt:

; 891  : 		for(int nIndx = 0; nIndx < nListCount; ++nIndx)

  000b8	33 db		 xor	 ebx, ebx
  000ba	66 0f 1f 44 00
	00		 npad	 6
$LL4@OnBtnOpt:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl

; 683  : 	{ ASSERT(::IsWindow(m_hWnd)); return ::SendMessage(m_hWnd, LB_GETITEMDATA, nIndex, 0); }

  000c0	6a 00		 push	 0
  000c2	53		 push	 ebx
  000c3	68 99 01 00 00	 push	 409			; 00000199H
  000c8	ff b7 10 11 00
	00		 push	 DWORD PTR [edi+4368]
  000ce	ff d6		 call	 esi
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 893  : 			if(pItemInfo = (STMNG_ITEMINFO*)m_listST.GetItemData(nIndx))

  000d0	89 45 d8	 mov	 DWORD PTR _pItemInfo$1$[ebp], eax
  000d3	85 c0		 test	 eax, eax
  000d5	0f 84 02 01 00
	00		 je	 $LN2@OnBtnOpt

; 895  : 				szSTPath	= pItemInfo->szSTPath +"\\"+ pItemInfo->szSTName + ".st";

  000db	8d 70 08	 lea	 esi, DWORD PTR [eax+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h

; 2401 : 		CStringT strResult( str1.GetManager() );

  000de	8b ce		 mov	 ecx, esi
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 895  : 				szSTPath	= pItemInfo->szSTPath +"\\"+ pItemInfo->szSTName + ".st";

  000e0	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h

; 2401 : 		CStringT strResult( str1.GetManager() );

  000e4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetManager@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEPAUIAtlStringMgr@2@XZ
  000ea	50		 push	 eax
  000eb	8d 4d ec	 lea	 ecx, DWORD PTR $T10[ebp]
  000ee	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PAUIAtlStringMgr@1@@Z

; 2405 : 		return( strResult );

  000f4	8b 45 e8	 mov	 eax, DWORD PTR $T8[ebp]
  000f7	83 c8 01	 or	 eax, 1
  000fa	89 45 e8	 mov	 DWORD PTR $T8[ebp], eax
  000fd	89 45 e4	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h

; 519  : 		return( GetData()->nDataLength );

  00100	8b 06		 mov	 eax, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h

; 2403 : 		CThisSimpleString::Concatenate( strResult, str1, str1.GetLength(), psz2, CThisSimpleString::StringLength( psz2 ) );

  00102	6a 01		 push	 1
  00104	68 00 00 00 00	 push	 OFFSET ??_C@_01KICIPPFI@?2@
  00109	ff 70 f4	 push	 DWORD PTR [eax-12]
  0010c	50		 push	 eax
  0010d	8d 45 ec	 lea	 eax, DWORD PTR $T10[ebp]
  00110	50		 push	 eax
  00111	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Concatenate@?$CSimpleStringT@D$00@ATL@@KAXAAV12@PBDH1H@Z
  00117	83 c4 14	 add	 esp, 20			; 00000014H

; 2390 : 		CStringT strResult( str1.GetManager() );

  0011a	8d 4d ec	 lea	 ecx, DWORD PTR $T10[ebp]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 895  : 				szSTPath	= pItemInfo->szSTPath +"\\"+ pItemInfo->szSTName + ".st";

  0011d	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h

; 2390 : 		CStringT strResult( str1.GetManager() );

  00121	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetManager@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEPAUIAtlStringMgr@2@XZ
  00127	50		 push	 eax
  00128	8d 4d e0	 lea	 ecx, DWORD PTR $T6[ebp]
  0012b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PAUIAtlStringMgr@1@@Z
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h

; 519  : 		return( GetData()->nDataLength );

  00131	8b 4d d8	 mov	 ecx, DWORD PTR _pItemInfo$1$[ebp]
  00134	8b 45 ec	 mov	 eax, DWORD PTR $T10[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h

; 2394 : 		return( strResult );

  00137	8b 75 e8	 mov	 esi, DWORD PTR $T8[ebp]
  0013a	83 ce 02	 or	 esi, 2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h

; 519  : 		return( GetData()->nDataLength );

  0013d	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h

; 2394 : 		return( strResult );

  00140	89 75 e4	 mov	 DWORD PTR $T7[ebp], esi
  00143	ff 71 f4	 push	 DWORD PTR [ecx-12]
  00146	51		 push	 ecx
  00147	ff 70 f4	 push	 DWORD PTR [eax-12]
  0014a	50		 push	 eax
  0014b	8d 45 e0	 lea	 eax, DWORD PTR $T6[ebp]
  0014e	50		 push	 eax
  0014f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Concatenate@?$CSimpleStringT@D$00@ATL@@KAXAAV12@PBDH1H@Z
  00155	83 c4 14	 add	 esp, 20			; 00000014H

; 2401 : 		CStringT strResult( str1.GetManager() );

  00158	8d 4d e0	 lea	 ecx, DWORD PTR $T6[ebp]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 895  : 				szSTPath	= pItemInfo->szSTPath +"\\"+ pItemInfo->szSTName + ".st";

  0015b	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h

; 2401 : 		CStringT strResult( str1.GetManager() );

  0015f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetManager@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEPAUIAtlStringMgr@2@XZ
  00165	50		 push	 eax
  00166	8d 4d f0	 lea	 ecx, DWORD PTR $T14[ebp]
  00169	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PAUIAtlStringMgr@1@@Z
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h

; 519  : 		return( GetData()->nDataLength );

  0016f	8b 45 e0	 mov	 eax, DWORD PTR $T6[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h

; 2405 : 		return( strResult );

  00172	83 ce 04	 or	 esi, 4
  00175	6a 03		 push	 3
  00177	68 00 00 00 00	 push	 OFFSET ??_C@_03IDLCJCBF@?4st@
  0017c	89 75 e4	 mov	 DWORD PTR $T7[ebp], esi
  0017f	ff 70 f4	 push	 DWORD PTR [eax-12]
  00182	50		 push	 eax
  00183	8d 45 f0	 lea	 eax, DWORD PTR $T14[ebp]
  00186	50		 push	 eax
  00187	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Concatenate@?$CSimpleStringT@D$00@ATL@@KAXAAV12@PBDH1H@Z
  0018d	83 c4 14	 add	 esp, 20			; 00000014H
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 895  : 				szSTPath	= pItemInfo->szSTPath +"\\"+ pItemInfo->szSTName + ".st";

  00190	8d 45 f0	 lea	 eax, DWORD PTR $T14[ebp]
  00193	8d 4d dc	 lea	 ecx, DWORD PTR _szSTPath$[ebp]
  00196	50		 push	 eax
  00197	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
  0019d	8d 4d f0	 lea	 ecx, DWORD PTR $T14[ebp]
  001a0	83 e6 fb	 and	 esi, -5			; fffffffbH
  001a3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  001a9	8d 4d e0	 lea	 ecx, DWORD PTR $T6[ebp]
  001ac	83 e6 fd	 and	 esi, -3			; fffffffdH
  001af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  001b5	83 e6 fe	 and	 esi, -2			; fffffffeH
  001b8	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  001bc	8d 4d ec	 lea	 ecx, DWORD PTR $T10[ebp]
  001bf	89 75 e8	 mov	 DWORD PTR $T8[ebp], esi
  001c2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl

; 321  : 		SetAtGrow(nIndex, newElement);

  001c8	8d 45 dc	 lea	 eax, DWORD PTR _szSTPath$[ebp]
  001cb	50		 push	 eax
  001cc	ff 75 b4	 push	 DWORD PTR _stArraySTPath$[ebp+8]
  001cf	8d 4d ac	 lea	 ecx, DWORD PTR _stArraySTPath$[ebp]
  001d2	e8 00 00 00 00	 call	 ?SetAtGrow@CStringArray@@QAEXHABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ; CStringArray::SetAtGrow
  001d7	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SendMessageA@16
$LN2@OnBtnOpt:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 891  : 		for(int nIndx = 0; nIndx < nListCount; ++nIndx)

  001dd	43		 inc	 ebx
  001de	3b 5d d4	 cmp	 ebx, DWORD PTR _nListCount$1$[ebp]
  001e1	0f 8c d9 fe ff
	ff		 jl	 $LL4@OnBtnOpt
  001e7	8b 5d e8	 mov	 ebx, DWORD PTR $T8[ebp]
$LN3@OnBtnOpt:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h

; 2401 : 		CStringT strResult( str1.GetManager() );

  001ea	8d 8f 40 05 00
	00		 lea	 ecx, DWORD PTR [edi+1344]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 910  : 	CString strSystemPath = m_strRootPath + "\\" + STSD;

  001f0	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h

; 2401 : 		CStringT strResult( str1.GetManager() );

  001f4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetManager@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEPAUIAtlStringMgr@2@XZ
  001fa	50		 push	 eax
  001fb	8d 4d f0	 lea	 ecx, DWORD PTR $T13[ebp]
  001fe	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PAUIAtlStringMgr@1@@Z
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h

; 519  : 		return( GetData()->nDataLength );

  00204	8b 87 40 05 00
	00		 mov	 eax, DWORD PTR [edi+1344]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h

; 2405 : 		return( strResult );

  0020a	83 cb 08	 or	 ebx, 8
  0020d	6a 01		 push	 1
  0020f	68 00 00 00 00	 push	 OFFSET ??_C@_01KICIPPFI@?2@
  00214	89 5d e4	 mov	 DWORD PTR $T7[ebp], ebx
  00217	ff 70 f4	 push	 DWORD PTR [eax-12]
  0021a	50		 push	 eax
  0021b	8d 45 f0	 lea	 eax, DWORD PTR $T13[ebp]
  0021e	50		 push	 eax
  0021f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Concatenate@?$CSimpleStringT@D$00@ATL@@KAXAAV12@PBDH1H@Z
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 910  : 	CString strSystemPath = m_strRootPath + "\\" + STSD;

  00225	68 00 00 00 00	 push	 OFFSET ??_C@_0P@PJNJDIFE@Icss?2STDATA?2SD@
  0022a	8d 45 f0	 lea	 eax, DWORD PTR $T13[ebp]
  0022d	50		 push	 eax
  0022e	8d 45 c0	 lea	 eax, DWORD PTR _strSystemPath$[ebp]
  00231	50		 push	 eax
  00232	e8 00 00 00 00	 call	 ??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@ABV10@PBD@Z ; ATL::operator+
  00237	83 c4 20	 add	 esp, 32			; 00000020H
  0023a	83 e3 f7	 and	 ebx, -9			; fffffff7H
  0023d	8d 4d f0	 lea	 ecx, DWORD PTR $T13[ebp]
  00240	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h

; 2401 : 		CStringT strResult( str1.GetManager() );

  00246	8d 8f 40 05 00
	00		 lea	 ecx, DWORD PTR [edi+1344]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 911  : 	CString strUserPath = m_strRootPath + "\\" + STUSER;

  0024c	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+8], 9
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h

; 2401 : 		CStringT strResult( str1.GetManager() );

  00250	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetManager@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEPAUIAtlStringMgr@2@XZ
  00256	50		 push	 eax
  00257	8d 4d f0	 lea	 ecx, DWORD PTR $T12[ebp]
  0025a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PAUIAtlStringMgr@1@@Z
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h

; 519  : 		return( GetData()->nDataLength );

  00260	8b 87 40 05 00
	00		 mov	 eax, DWORD PTR [edi+1344]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h

; 2405 : 		return( strResult );

  00266	83 cb 20	 or	 ebx, 32			; 00000020H
  00269	6a 01		 push	 1
  0026b	68 00 00 00 00	 push	 OFFSET ??_C@_01KICIPPFI@?2@
  00270	89 5d e4	 mov	 DWORD PTR $T7[ebp], ebx
  00273	ff 70 f4	 push	 DWORD PTR [eax-12]
  00276	50		 push	 eax
  00277	8d 45 f0	 lea	 eax, DWORD PTR $T12[ebp]
  0027a	50		 push	 eax
  0027b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Concatenate@?$CSimpleStringT@D$00@ATL@@KAXAAV12@PBDH1H@Z
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 911  : 	CString strUserPath = m_strRootPath + "\\" + STUSER;

  00281	68 00 00 00 00	 push	 OFFSET ??_C@_0O@ILIJGNAL@Usr?2STDATA?2SD@
  00286	8d 45 f0	 lea	 eax, DWORD PTR $T12[ebp]
  00289	50		 push	 eax
  0028a	8d 45 c4	 lea	 eax, DWORD PTR _strUserPath$[ebp]
  0028d	50		 push	 eax
  0028e	e8 00 00 00 00	 call	 ??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@ABV10@PBD@Z ; ATL::operator+
  00293	83 c4 20	 add	 esp, 32			; 00000020H
  00296	8d 4d f0	 lea	 ecx, DWORD PTR $T12[ebp]
  00299	c6 45 fc 0b	 mov	 BYTE PTR __$EHRec$[ebp+8], 11 ; 0000000bH
  0029d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl

; 321  : 		SetAtGrow(nIndex, newElement);

  002a3	8d 45 c0	 lea	 eax, DWORD PTR _strSystemPath$[ebp]
  002a6	50		 push	 eax
  002a7	ff 75 a0	 push	 DWORD PTR _stArrayPath$[ebp+8]
  002aa	8d 4d 98	 lea	 ecx, DWORD PTR _stArrayPath$[ebp]
  002ad	e8 00 00 00 00	 call	 ?SetAtGrow@CStringArray@@QAEXHABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ; CStringArray::SetAtGrow
  002b2	8d 45 c4	 lea	 eax, DWORD PTR _strUserPath$[ebp]
  002b5	50		 push	 eax
  002b6	ff 75 a0	 push	 DWORD PTR _stArrayPath$[ebp+8]
  002b9	8d 4d 98	 lea	 ecx, DWORD PTR _stArrayPath$[ebp]
  002bc	e8 00 00 00 00	 call	 ?SetAtGrow@CStringArray@@QAEXHABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ; CStringArray::SetAtGrow
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 917  : 	if(!m_pStrategyItem)

  002c1	83 bf 10 05 00
	00 00		 cmp	 DWORD PTR [edi+1296], 0
  002c8	75 56		 jne	 SHORT $LN35@OnBtnOpt

; 918  : 	{
; 919  : 		m_pStrategyItem = m_strategyLoader.GetStrategyItem();//   

  002ca	8d 8f 14 05 00
	00		 lea	 ecx, DWORD PTR [edi+1300]
  002d0	e8 00 00 00 00	 call	 ?GetStrategyItem@CStrategyLoader@@QAEPAVCIStrategyItem0001@@XZ ; CStrategyLoader::GetStrategyItem
  002d5	89 87 10 05 00
	00		 mov	 DWORD PTR [edi+1296], eax

; 920  : 		if(m_pStrategyItem == NULL) return;

  002db	85 c0		 test	 eax, eax
  002dd	0f 84 b1 08 00
	00		 je	 $LN385@OnBtnOpt

; 921  : 		int nRetValue = m_pStrategyItem->Create(this, (long)m_pStrategyItem,stArrayPath,m_pChartInterface);

  002e3	ff b7 74 11 00
	00		 push	 DWORD PTR [edi+4468]
  002e9	8b 10		 mov	 edx, DWORD PTR [eax]
  002eb	8d 4d 98	 lea	 ecx, DWORD PTR _stArrayPath$[ebp]
  002ee	51		 push	 ecx
  002ef	50		 push	 eax
  002f0	57		 push	 edi
  002f1	8b c8		 mov	 ecx, eax
  002f3	ff 52 04	 call	 DWORD PTR [edx+4]

; 922  : 		if(nRetValue==-1) 

  002f6	83 f8 ff	 cmp	 eax, -1
  002f9	75 25		 jne	 SHORT $LN35@OnBtnOpt

; 923  : 		{
; 924  : 			m_pStrategyItem->DestoryWindow();

  002fb	8b 8f 10 05 00
	00		 mov	 ecx, DWORD PTR [edi+1296]
  00301	8b 01		 mov	 eax, DWORD PTR [ecx]
  00303	ff 50 08	 call	 DWORD PTR [eax+8]

; 925  : 			delete m_pStrategyItem;

  00306	8b 8f 10 05 00
	00		 mov	 ecx, DWORD PTR [edi+1296]
  0030c	85 c9		 test	 ecx, ecx
  0030e	74 06		 je	 SHORT $LN58@OnBtnOpt
  00310	8b 01		 mov	 eax, DWORD PTR [ecx]
  00312	6a 01		 push	 1
  00314	ff 10		 call	 DWORD PTR [eax]
$LN58@OnBtnOpt:

; 926  : 			m_pStrategyItem = NULL;

  00316	c7 87 10 05 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+1296], 0
$LN35@OnBtnOpt:

; 927  : 		}
; 928  : 	}
; 929  : 	m_DlgTrade->SetStrategyItem(m_pStrategyItem);

  00320	ff b7 10 05 00
	00		 push	 DWORD PTR [edi+1296]
  00326	8b 8f 8c 0e 00
	00		 mov	 ecx, DWORD PTR [edi+3724]
  0032c	e8 00 00 00 00	 call	 ?SetStrategyItem@CDlgTrade@@QAEXPAVCIStrategyItem0001@@@Z ; CDlgTrade::SetStrategyItem

; 930  : 	///////////////////////////////////////////////////////////
; 931  : 
; 932  : ///////////////    //////////////////////////////
; 933  : 	BOOL bRetValue;
; 934  : 	if(m_nOptimizerDiv == INDEX_OPTIMIZER)

  00331	8b 87 70 11 00
	00		 mov	 eax, DWORD PTR [edi+4464]
  00337	8b c8		 mov	 ecx, eax
  00339	3d e9 03 00 00	 cmp	 eax, 1001		; 000003e9H
  0033e	75 71		 jne	 SHORT $LN6@OnBtnOpt

; 935  : 	{
; 936  : 		for(int nIndx =0;nIndx< stArraySTPath.GetSize();nIndx++)

  00340	8b 45 b4	 mov	 eax, DWORD PTR _stArraySTPath$[ebp+8]
  00343	33 f6		 xor	 esi, esi
  00345	85 c0		 test	 eax, eax
  00347	0f 8e 47 08 00
	00		 jle	 $LN385@OnBtnOpt
  0034d	0f 1f 00	 npad	 3
$LL7@OnBtnOpt:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl

; 289  : 		if( nIndex < 0 || nIndex >= m_nSize )

  00350	85 f6		 test	 esi, esi
  00352	0f 88 79 08 00
	00		 js	 $LN399@OnBtnOpt
  00358	3b f0		 cmp	 esi, eax
  0035a	0f 8d 71 08 00
	00		 jge	 $LN399@OnBtnOpt

; 291  : 		return m_pData[nIndex]; }

  00360	8b 45 b0	 mov	 eax, DWORD PTR _stArraySTPath$[ebp+4]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 938  : 			szSTPath = stArraySTPath.GetAt(nIndx);

  00363	8d 4d dc	 lea	 ecx, DWORD PTR _szSTPath$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl

; 291  : 		return m_pData[nIndex]; }

  00366	8d 04 b0	 lea	 eax, DWORD PTR [eax+esi*4]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 938  : 			szSTPath = stArraySTPath.GetAt(nIndx);

  00369	50		 push	 eax
  0036a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z

; 939  : 			bRetValue = m_pStrategyItem->LoadST(szSTPath,m_stCode,m_nCount,m_stEndDate); //

  00370	ff b7 80 11 00
	00		 push	 DWORD PTR [edi+4480]
  00376	8b 8f 10 05 00
	00		 mov	 ecx, DWORD PTR [edi+1296]
  0037c	ff b7 7c 11 00
	00		 push	 DWORD PTR [edi+4476]
  00382	ff b7 78 11 00
	00		 push	 DWORD PTR [edi+4472]
  00388	8b 01		 mov	 eax, DWORD PTR [ecx]
  0038a	ff 75 dc	 push	 DWORD PTR _szSTPath$[ebp]
  0038d	ff 50 14	 call	 DWORD PTR [eax+20]

; 940  : 
; 941  : 			if(bRetValue)

  00390	85 c0		 test	 eax, eax
  00392	74 0d		 je	 SHORT $LN5@OnBtnOpt

; 942  : 			{
; 943  : 				m_pStrategyItem->Run();

  00394	8b 8f 10 05 00
	00		 mov	 ecx, DWORD PTR [edi+1296]
  0039a	6a 00		 push	 0
  0039c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0039e	ff 50 18	 call	 DWORD PTR [eax+24]
$LN5@OnBtnOpt:

; 935  : 	{
; 936  : 		for(int nIndx =0;nIndx< stArraySTPath.GetSize();nIndx++)

  003a1	8b 45 b4	 mov	 eax, DWORD PTR _stArraySTPath$[ebp+8]
  003a4	46		 inc	 esi
  003a5	3b f0		 cmp	 esi, eax
  003a7	7c a7		 jl	 SHORT $LL7@OnBtnOpt

; 1063 : 						if(val2 <= m_ValueOptimizerArray.GetAt(k).nEnd)// Break

  003a9	8b 87 70 11 00
	00		 mov	 eax, DWORD PTR [edi+4464]
  003af	8b c8		 mov	 ecx, eax
$LN6@OnBtnOpt:

; 944  : 			}
; 945  : 		}
; 946  : 	}
; 947  : 	if(m_nOptimizerDiv == TIME_OPTIMIZER)

  003b1	3d eb 03 00 00	 cmp	 eax, 1003		; 000003ebH
  003b6	0f 85 1c 01 00
	00		 jne	 $LN9@OnBtnOpt

; 948  : 	{
; 949  : 		//     .
; 950  : 		int BongStart = GetDlgItemInt(IDC_EDIT_START);

  003bc	6a 01		 push	 1
  003be	6a 00		 push	 0
  003c0	68 ef 32 00 00	 push	 13039			; 000032efH
  003c5	8b cf		 mov	 ecx, edi
  003c7	e8 00 00 00 00	 call	 ?GetDlgItemInt@CWnd@@QBEIHPAHH@Z ; CWnd::GetDlgItemInt

; 951  : 		int BongEnd   = GetDlgItemInt(IDC_EDIT_END);

  003cc	6a 01		 push	 1
  003ce	6a 00		 push	 0
  003d0	8b d8		 mov	 ebx, eax
  003d2	8b cf		 mov	 ecx, edi
  003d4	68 f4 32 00 00	 push	 13044			; 000032f4H
  003d9	89 5d ec	 mov	 DWORD PTR _nBong$1$[ebp], ebx
  003dc	e8 00 00 00 00	 call	 ?GetDlgItemInt@CWnd@@QBEIHPAHH@Z ; CWnd::GetDlgItemInt

; 952  : 		int BongIncrease = GetDlgItemInt(IDC_EDIT_ADV);

  003e1	6a 01		 push	 1
  003e3	6a 00		 push	 0
  003e5	8b f0		 mov	 esi, eax
  003e7	8b cf		 mov	 ecx, edi
  003e9	68 f7 32 00 00	 push	 13047			; 000032f7H
  003ee	89 75 d4	 mov	 DWORD PTR _BongEnd$1$[ebp], esi
  003f1	e8 00 00 00 00	 call	 ?GetDlgItemInt@CWnd@@QBEIHPAHH@Z ; CWnd::GetDlgItemInt
  003f6	89 45 d8	 mov	 DWORD PTR _BongIncrease$1$[ebp], eax

; 953  : 		//  
; 954  : 		if(BongStart > BongEnd || BongEnd < BongIncrease || BongEnd ==0 || BongStart ==0)

  003f9	3b de		 cmp	 ebx, esi
  003fb	0f 8f 1d 03 00
	00		 jg	 $LN40@OnBtnOpt
  00401	3b f0		 cmp	 esi, eax
  00403	0f 8c 15 03 00
	00		 jl	 $LN40@OnBtnOpt
  00409	85 f6		 test	 esi, esi
  0040b	0f 84 0d 03 00
	00		 je	 $LN40@OnBtnOpt
  00411	85 db		 test	 ebx, ebx
  00413	0f 84 05 03 00
	00		 je	 $LN40@OnBtnOpt

; 962  : 			return;
; 963  : 		}
; 964  : 
; 965  : 		if(BongStart >= 1000 || BongEnd >= 1000 || BongIncrease >= 1000)

  00419	81 fb e8 03 00
	00		 cmp	 ebx, 1000		; 000003e8H
  0041f	0f 8d c1 02 00
	00		 jge	 $LN42@OnBtnOpt
  00425	81 fe e8 03 00
	00		 cmp	 esi, 1000		; 000003e8H
  0042b	0f 8d b5 02 00
	00		 jge	 $LN42@OnBtnOpt
  00431	3d e8 03 00 00	 cmp	 eax, 1000		; 000003e8H
  00436	0f 8d aa 02 00
	00		 jge	 $LN42@OnBtnOpt
  0043c	0f 1f 40 00	 npad	 4
$LL10@OnBtnOpt:

; 977  : 		{   m_nBong = nBong;
; 978  : 			m_pStrategyItem->SetTimeBong(m_nBong); //   

  00440	8b 8f 10 05 00
	00		 mov	 ecx, DWORD PTR [edi+1296]
  00446	89 9f 94 11 00
	00		 mov	 DWORD PTR [edi+4500], ebx
  0044c	53		 push	 ebx
  0044d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0044f	ff 90 84 00 00
	00		 call	 DWORD PTR [eax+132]

; 979  : 
; 980  : 			for(int nIndx =0;nIndx< stArraySTPath.GetSize();nIndx++)

  00455	8b 45 b4	 mov	 eax, DWORD PTR _stArraySTPath$[ebp+8]
  00458	33 db		 xor	 ebx, ebx
  0045a	85 c0		 test	 eax, eax
  0045c	7e 63		 jle	 SHORT $LN8@OnBtnOpt
  0045e	66 90		 npad	 2
$LL13@OnBtnOpt:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl

; 289  : 		if( nIndex < 0 || nIndex >= m_nSize )

  00460	85 db		 test	 ebx, ebx
  00462	0f 88 69 07 00
	00		 js	 $LN399@OnBtnOpt
  00468	3b d8		 cmp	 ebx, eax
  0046a	0f 8d 61 07 00
	00		 jge	 $LN399@OnBtnOpt

; 291  : 		return m_pData[nIndex]; }

  00470	8b 45 b0	 mov	 eax, DWORD PTR _stArraySTPath$[ebp+4]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 982  : 				szSTPath = stArraySTPath.GetAt(nIndx);

  00473	8d 4d dc	 lea	 ecx, DWORD PTR _szSTPath$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl

; 291  : 		return m_pData[nIndex]; }

  00476	8d 04 98	 lea	 eax, DWORD PTR [eax+ebx*4]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 982  : 				szSTPath = stArraySTPath.GetAt(nIndx);

  00479	50		 push	 eax
  0047a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z

; 983  : 				bRetValue = m_pStrategyItem->LoadST(szSTPath,m_stCode,m_nCount/nBong,m_stEndDate); //

  00480	8b 87 7c 11 00
	00		 mov	 eax, DWORD PTR [edi+4476]
  00486	99		 cdq
  00487	f7 7d ec	 idiv	 DWORD PTR _nBong$1$[ebp]
  0048a	ff b7 80 11 00
	00		 push	 DWORD PTR [edi+4480]
  00490	8b 8f 10 05 00
	00		 mov	 ecx, DWORD PTR [edi+1296]
  00496	50		 push	 eax
  00497	ff b7 78 11 00
	00		 push	 DWORD PTR [edi+4472]
  0049d	8b 31		 mov	 esi, DWORD PTR [ecx]
  0049f	ff 75 dc	 push	 DWORD PTR _szSTPath$[ebp]
  004a2	ff 56 14	 call	 DWORD PTR [esi+20]

; 984  : 				if(bRetValue)

  004a5	85 c0		 test	 eax, eax
  004a7	74 0d		 je	 SHORT $LN11@OnBtnOpt

; 985  : 				{
; 986  : 					m_pStrategyItem->Run();

  004a9	8b 8f 10 05 00
	00		 mov	 ecx, DWORD PTR [edi+1296]
  004af	6a 00		 push	 0
  004b1	8b 01		 mov	 eax, DWORD PTR [ecx]
  004b3	ff 50 18	 call	 DWORD PTR [eax+24]
$LN11@OnBtnOpt:

; 979  : 
; 980  : 			for(int nIndx =0;nIndx< stArraySTPath.GetSize();nIndx++)

  004b6	8b 45 b4	 mov	 eax, DWORD PTR _stArraySTPath$[ebp+8]
  004b9	43		 inc	 ebx
  004ba	3b d8		 cmp	 ebx, eax
  004bc	7c a2		 jl	 SHORT $LL13@OnBtnOpt
  004be	8b 75 d4	 mov	 esi, DWORD PTR _BongEnd$1$[ebp]
$LN8@OnBtnOpt:

; 973  : 			return;
; 974  : 		}
; 975  : 
; 976  : 		for(int nBong = BongStart; nBong<=BongEnd; nBong+=BongIncrease)

  004c1	8b 5d ec	 mov	 ebx, DWORD PTR _nBong$1$[ebp]
  004c4	03 5d d8	 add	 ebx, DWORD PTR _BongIncrease$1$[ebp]
  004c7	89 5d ec	 mov	 DWORD PTR _nBong$1$[ebp], ebx
  004ca	3b de		 cmp	 ebx, esi
  004cc	0f 8e 6e ff ff
	ff		 jle	 $LL10@OnBtnOpt

; 1063 : 						if(val2 <= m_ValueOptimizerArray.GetAt(k).nEnd)// Break

  004d2	8b 8f 70 11 00
	00		 mov	 ecx, DWORD PTR [edi+4464]
$LN9@OnBtnOpt:

; 987  : 				}
; 988  : 			}
; 989  : 		}
; 990  : 	}
; 991  : 
; 992  : 	////////////Calculate SendValue//////////////////////////
; 993  : 	if(m_nOptimizerDiv == VAL_OPTIMIZER)

  004d8	81 f9 ea 03 00
	00		 cmp	 ecx, 1002		; 000003eaH
  004de	0f 85 b0 06 00
	00		 jne	 $LN385@OnBtnOpt

; 994  : 	{
; 995  : 		m_pDlgTimeSetup->SetInputData();//   .

  004e4	8b 8f 2c 05 00
	00		 mov	 ecx, DWORD PTR [edi+1324]
  004ea	e8 00 00 00 00	 call	 ?SetInputData@CDlgTimeSetup@@QAEXXZ ; CDlgTimeSetup::SetInputData

; 996  : 		bRetValue = m_pStrategyItem->LoadST(m_stPath,m_stCode,m_nCount,m_stEndDate); //

  004ef	ff b7 80 11 00
	00		 push	 DWORD PTR [edi+4480]
  004f5	8b 8f 10 05 00
	00		 mov	 ecx, DWORD PTR [edi+1296]
  004fb	ff b7 7c 11 00
	00		 push	 DWORD PTR [edi+4476]
  00501	ff b7 78 11 00
	00		 push	 DWORD PTR [edi+4472]
  00507	8b 01		 mov	 eax, DWORD PTR [ecx]
  00509	ff b7 ac 11 00
	00		 push	 DWORD PTR [edi+4524]
  0050f	ff 50 14	 call	 DWORD PTR [eax+20]

; 997  : 		m_ValueOptimizerArray.Copy(m_pDlgTimeSetup->m_ValueOptimizerArray);//  

  00512	8b 9f 2c 05 00
	00		 mov	 ebx, DWORD PTR [edi+1324]
  00518	8d b7 98 11 00
	00		 lea	 esi, DWORD PTR [edi+4504]
  0051e	81 c3 d4 00 00
	00		 add	 ebx, 212		; 000000d4H
  00524	89 45 e4	 mov	 DWORD PTR _bRetValue$1$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 498  : 	if(this != &src)

  00527	3b f3		 cmp	 esi, ebx
  00529	0f 84 88 00 00
	00		 je	 $LN407@OnBtnOpt

; 499  : 	{
; 500  : 		SetSize(src.m_nSize);

  0052f	6a ff		 push	 -1
  00531	ff 73 08	 push	 DWORD PTR [ebx+8]
  00534	8b ce		 mov	 ecx, esi
  00536	e8 00 00 00 00	 call	 ?SetSize@?$CArray@UST_VALUEOPTIMAZE@@U1@@@QAEXHH@Z ; CArray<ST_VALUEOPTIMAZE,ST_VALUEOPTIMAZE>::SetSize

; 501  : 		CopyElements<TYPE>(m_pData, src.m_pData, src.m_nSize);

  0053b	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  0053e	8b 5b 04	 mov	 ebx, DWORD PTR [ebx+4]
  00541	8b 46 04	 mov	 eax, DWORD PTR [esi+4]

; 54   : 	ENSURE(nCount == 0 || pDest != 0 && pSrc != 0);

  00544	85 c9		 test	 ecx, ecx
  00546	74 6f		 je	 SHORT $LN407@OnBtnOpt
  00548	85 c0		 test	 eax, eax
  0054a	0f 84 81 06 00
	00		 je	 $LN399@OnBtnOpt
  00550	85 db		 test	 ebx, ebx
  00552	0f 84 79 06 00
	00		 je	 $LN399@OnBtnOpt
  00558	8b f8		 mov	 edi, eax
  0055a	66 0f 1f 44 00
	00		 npad	 6
$LL230@OnBtnOpt:

; 55   : 	ASSERT(nCount == 0 ||
; 56   : 		AfxIsValidAddress(pDest, (size_t)nCount * sizeof(TYPE)));
; 57   : 	ASSERT(nCount == 0 ||
; 58   : 		AfxIsValidAddress(pSrc, (size_t)nCount * sizeof(TYPE)));
; 59   : 
; 60   : 	// default is element-copy using assignment
; 61   : 	while (nCount--)

  00560	49		 dec	 ecx

; 62   : 		*pDest++ = *pSrc++;

  00561	8b f7		 mov	 esi, edi
  00563	89 4d d4	 mov	 DWORD PTR _nCount$1$[ebp], ecx
  00566	83 c7 38	 add	 edi, 56			; 00000038H
  00569	53		 push	 ebx
  0056a	8b ce		 mov	 ecx, esi
  0056c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
  00572	f2 0f 10 43 08	 movsd	 xmm0, QWORD PTR [ebx+8]

; 55   : 	ASSERT(nCount == 0 ||
; 56   : 		AfxIsValidAddress(pDest, (size_t)nCount * sizeof(TYPE)));
; 57   : 	ASSERT(nCount == 0 ||
; 58   : 		AfxIsValidAddress(pSrc, (size_t)nCount * sizeof(TYPE)));
; 59   : 
; 60   : 	// default is element-copy using assignment
; 61   : 	while (nCount--)

  00577	8b 4d d4	 mov	 ecx, DWORD PTR _nCount$1$[ebp]
  0057a	f2 0f 11 46 08	 movsd	 QWORD PTR [esi+8], xmm0
  0057f	f2 0f 10 43 10	 movsd	 xmm0, QWORD PTR [ebx+16]
  00584	f2 0f 11 46 10	 movsd	 QWORD PTR [esi+16], xmm0
  00589	f2 0f 10 43 18	 movsd	 xmm0, QWORD PTR [ebx+24]
  0058e	f2 0f 11 46 18	 movsd	 QWORD PTR [esi+24], xmm0
  00593	8b 43 20	 mov	 eax, DWORD PTR [ebx+32]
  00596	89 46 20	 mov	 DWORD PTR [esi+32], eax
  00599	f2 0f 10 43 28	 movsd	 xmm0, QWORD PTR [ebx+40]
  0059e	f2 0f 11 46 28	 movsd	 QWORD PTR [esi+40], xmm0
  005a3	f2 0f 10 43 30	 movsd	 xmm0, QWORD PTR [ebx+48]

; 62   : 		*pDest++ = *pSrc++;

  005a8	83 c3 38	 add	 ebx, 56			; 00000038H
  005ab	f2 0f 11 46 30	 movsd	 QWORD PTR [esi+48], xmm0

; 55   : 	ASSERT(nCount == 0 ||
; 56   : 		AfxIsValidAddress(pDest, (size_t)nCount * sizeof(TYPE)));
; 57   : 	ASSERT(nCount == 0 ||
; 58   : 		AfxIsValidAddress(pSrc, (size_t)nCount * sizeof(TYPE)));
; 59   : 
; 60   : 	// default is element-copy using assignment
; 61   : 	while (nCount--)

  005b0	85 c9		 test	 ecx, ecx
  005b2	75 ac		 jne	 SHORT $LL230@OnBtnOpt
  005b4	8b 7d cc	 mov	 edi, DWORD PTR _this$1$[ebp]
$LN407@OnBtnOpt:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 998  : 		int nSize = m_ValueOptimizerArray.GetSize();

  005b7	8b 87 a0 11 00
	00		 mov	 eax, DWORD PTR [edi+4512]
  005bd	89 45 e0	 mov	 DWORD PTR _nSize$1$[ebp], eax

; 999  : 		// nSize 0   .
; 1000 : 		//if(!nSize) 
; 1001 : 		//{
; 1002 : 		//	m_pStrategyItem->DestoryWindow();
; 1003 : 		//	delete m_pStrategyItem;
; 1004 : 		//	m_pStrategyItem = NULL;
; 1005 : 		//	AfxMessageBox("...");
; 1006 : 		//	return;
; 1007 : 		//}
; 1008 : 		if(nSize > 0) 

  005c0	85 c0		 test	 eax, eax
  005c2	0f 8e d0 00 00
	00		 jle	 $LN252@OnBtnOpt

; 1009 : 		{
; 1010 : 			ST_VALOTM stValOtm;

  005c8	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _stValOtm$3[ebp]
  005ce	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 1011 : 			for(int nValIndx = 0; nValIndx < nSize; ++nValIndx)

  005d4	33 db		 xor	 ebx, ebx
  005d6	c6 45 fc 0c	 mov	 BYTE PTR __$EHRec$[ebp+8], 12 ; 0000000cH
  005da	33 c0		 xor	 eax, eax
  005dc	89 45 f0	 mov	 DWORD PTR tv2658[ebp], eax
  005df	90		 npad	 1
$LL16@OnBtnOpt:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 288  : 	if(nIndex >= 0 && nIndex < m_nSize)

  005e0	85 c0		 test	 eax, eax
  005e2	0f 88 e9 05 00
	00		 js	 $LN399@OnBtnOpt
  005e8	3b 9f a0 11 00
	00		 cmp	 ebx, DWORD PTR [edi+4512]
  005ee	0f 8d dd 05 00
	00		 jge	 $LN399@OnBtnOpt

; 289  : 		return m_pData[nIndex];

  005f4	8b b7 9c 11 00
	00		 mov	 esi, DWORD PTR [edi+4508]
  005fa	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _stValOtm$3[ebp]
  00600	03 f0		 add	 esi, eax
  00602	56		 push	 esi
  00603	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
  00609	f2 0f 10 4e 08	 movsd	 xmm1, QWORD PTR [esi+8]
  0060e	f2 0f 11 8d 30
	ff ff ff	 movsd	 QWORD PTR _stValOtm$3[ebp+8], xmm1
  00616	f2 0f 10 56 10	 movsd	 xmm2, QWORD PTR [esi+16]
  0061b	f2 0f 11 95 38
	ff ff ff	 movsd	 QWORD PTR _stValOtm$3[ebp+16], xmm2
  00623	f2 0f 10 5e 18	 movsd	 xmm3, QWORD PTR [esi+24]
  00628	f2 0f 11 9d 40
	ff ff ff	 movsd	 QWORD PTR _stValOtm$3[ebp+24], xmm3
  00630	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00633	89 85 48 ff ff
	ff		 mov	 DWORD PTR _stValOtm$3[ebp+32], eax
  00639	f2 0f 10 46 28	 movsd	 xmm0, QWORD PTR [esi+40]
  0063e	f2 0f 11 85 50
	ff ff ff	 movsd	 QWORD PTR _stValOtm$3[ebp+40], xmm0
  00646	f2 0f 10 46 30	 movsd	 xmm0, QWORD PTR [esi+48]
  0064b	f2 0f 11 85 58
	ff ff ff	 movsd	 QWORD PTR _stValOtm$3[ebp+48], xmm0
  00653	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@408f400000000000
  0065b	66 0f 2f c8	 comisd	 xmm1, xmm0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 1014 : 				if(stValOtm.nStart >= 1000 || stValOtm.nEnd >= 1000 || stValOtm.nAdv >= 1000)

  0065f	0f 83 f1 00 00
	00		 jae	 $LN400@OnBtnOpt
  00665	66 0f 2f d0	 comisd	 xmm2, xmm0
  00669	0f 83 e7 00 00
	00		 jae	 $LN400@OnBtnOpt
  0066f	66 0f 2f d8	 comisd	 xmm3, xmm0
  00673	0f 83 dd 00 00
	00		 jae	 $LN400@OnBtnOpt

; 1011 : 			for(int nValIndx = 0; nValIndx < nSize; ++nValIndx)

  00679	8b 45 f0	 mov	 eax, DWORD PTR tv2658[ebp]
  0067c	43		 inc	 ebx
  0067d	83 c0 38	 add	 eax, 56			; 00000038H
  00680	89 45 f0	 mov	 DWORD PTR tv2658[ebp], eax
  00683	3b 5d e0	 cmp	 ebx, DWORD PTR _nSize$1$[ebp]
  00686	0f 8c 54 ff ff
	ff		 jl	 $LL16@OnBtnOpt
  0068c	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _stValOtm$3[ebp]
  00692	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$LN252@OnBtnOpt:
  00698	8d 8d 60 ff ff
	ff		 lea	 ecx, DWORD PTR _stVal$4[ebp]
  0069e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 116  : 	{ return ::operator new(nSize); }

  006a4	6a 14		 push	 20			; 00000014H
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 1027 : 		ST_VALOTM stVal;

  006a6	c6 45 fc 0d	 mov	 BYTE PTR __$EHRec$[ebp+8], 13 ; 0000000dH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 116  : 	{ return ::operator new(nSize); }

  006aa	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 1029 : 		CArray<double,double> *nStart = new CArray<double,double>;

  006af	8b d8		 mov	 ebx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 116  : 	{ return ::operator new(nSize); }

  006b1	83 c4 04	 add	 esp, 4
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 1029 : 		CArray<double,double> *nStart = new CArray<double,double>;

  006b4	89 5d cc	 mov	 DWORD PTR $T5[ebp], ebx
  006b7	85 db		 test	 ebx, ebx
  006b9	0f 84 d5 00 00
	00		 je	 $LN66@OnBtnOpt
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 348  : {

  006bf	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], OFFSET ??_7?$CArray@NN@@6B@

; 349  : 	m_pData = NULL;

  006c5	c7 43 04 00 00
	00 00		 mov	 DWORD PTR [ebx+4], 0

; 350  : 	m_nSize = m_nMaxSize = m_nGrowBy = 0;

  006cc	c7 43 10 00 00
	00 00		 mov	 DWORD PTR [ebx+16], 0
  006d3	c7 43 0c 00 00
	00 00		 mov	 DWORD PTR [ebx+12], 0
  006da	c7 43 08 00 00
	00 00		 mov	 DWORD PTR [ebx+8], 0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 1029 : 		CArray<double,double> *nStart = new CArray<double,double>;

  006e1	e9 b0 00 00 00	 jmp	 $LN67@OnBtnOpt
$LN42@OnBtnOpt:

; 966  : 		{
; 967  : 			{
; 968  : 				m_pStrategyItem->DestoryWindow();

  006e6	8b 8f 10 05 00
	00		 mov	 ecx, DWORD PTR [edi+1296]
  006ec	8b 01		 mov	 eax, DWORD PTR [ecx]
  006ee	ff 50 08	 call	 DWORD PTR [eax+8]

; 969  : 				delete m_pStrategyItem;

  006f1	8b 8f 10 05 00
	00		 mov	 ecx, DWORD PTR [edi+1296]
  006f7	85 c9		 test	 ecx, ecx
  006f9	74 06		 je	 SHORT $LN62@OnBtnOpt
  006fb	8b 01		 mov	 eax, DWORD PTR [ecx]
  006fd	6a 01		 push	 1
  006ff	ff 10		 call	 DWORD PTR [eax]
$LN62@OnBtnOpt:

; 970  : 				m_pStrategyItem = NULL;
; 971  : 			}		
; 972  : 			AfxMessageBox("1000     .  .");

  00701	6a 00		 push	 0
  00703	6a 00		 push	 0
  00705	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@FCBICJNP@1000?5?$MA?L?$LL?s?$MA?G?5?$LA?$KK?$MA?$LK?5?$LL?g?$LP?k?G?R?5?$LM?v?5?$LO?x?$LN?$MA@
  0070a	c7 87 10 05 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+1296], 0
  00714	e8 00 00 00 00	 call	 ?AfxMessageBox@@YGHPBDII@Z ; AfxMessageBox
  00719	e9 76 04 00 00	 jmp	 $LN385@OnBtnOpt
$LN40@OnBtnOpt:

; 955  : 		{
; 956  : 			{
; 957  : 				m_pStrategyItem->DestoryWindow();

  0071e	8b 8f 10 05 00
	00		 mov	 ecx, DWORD PTR [edi+1296]
  00724	8b 01		 mov	 eax, DWORD PTR [ecx]
  00726	ff 50 08	 call	 DWORD PTR [eax+8]

; 958  : 				delete m_pStrategyItem;

  00729	8b 8f 10 05 00
	00		 mov	 ecx, DWORD PTR [edi+1296]
  0072f	85 c9		 test	 ecx, ecx
  00731	74 06		 je	 SHORT $LN60@OnBtnOpt
  00733	8b 01		 mov	 eax, DWORD PTR [ecx]
  00735	6a 01		 push	 1
  00737	ff 10		 call	 DWORD PTR [eax]
$LN60@OnBtnOpt:

; 959  : 				m_pStrategyItem = NULL;
; 960  : 			}
; 961  : 			AfxMessageBox("   .  ");

  00739	6a 00		 push	 0
  0073b	6a 00		 push	 0
  0073d	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@KKHNOAOO@?$LK?$MA?5?$MA?T?$LH?B?$LA?$KK?$MA?L?5?$MA?$NP?$LI?x?5?$LM?$LD?A?$KE?$LF?G?$LO?z?$LN?$MA?$LE?O?$LE?Y@
  00742	c7 87 10 05 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+1296], 0
  0074c	e8 00 00 00 00	 call	 ?AfxMessageBox@@YGHPBDII@Z ; AfxMessageBox
  00751	e9 3e 04 00 00	 jmp	 $LN385@OnBtnOpt
$LN400@OnBtnOpt:

; 1015 : 				{
; 1016 : 					{
; 1017 : 						m_pStrategyItem->DestoryWindow();

  00756	8b 8f 10 05 00
	00		 mov	 ecx, DWORD PTR [edi+1296]
  0075c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0075e	ff 50 08	 call	 DWORD PTR [eax+8]

; 1018 : 						delete m_pStrategyItem;

  00761	8b 8f 10 05 00
	00		 mov	 ecx, DWORD PTR [edi+1296]
  00767	85 c9		 test	 ecx, ecx
  00769	74 06		 je	 SHORT $LN64@OnBtnOpt
  0076b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0076d	6a 01		 push	 1
  0076f	ff 10		 call	 DWORD PTR [eax]
$LN64@OnBtnOpt:

; 1019 : 						m_pStrategyItem = NULL;
; 1020 : 					}		
; 1021 : 					AfxMessageBox("1000     .  .");

  00771	6a 00		 push	 0
  00773	6a 00		 push	 0
  00775	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@FCBICJNP@1000?5?$MA?L?$LL?s?$MA?G?5?$LA?$KK?$MA?$LK?5?$LL?g?$LP?k?G?R?5?$LM?v?5?$LO?x?$LN?$MA@
  0077a	c7 87 10 05 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+1296], 0
  00784	e8 00 00 00 00	 call	 ?AfxMessageBox@@YGHPBDII@Z ; AfxMessageBox
  00789	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _stValOtm$3[ebp]
  0078f	e9 fa 03 00 00	 jmp	 $LN451@OnBtnOpt
$LN66@OnBtnOpt:

; 1029 : 		CArray<double,double> *nStart = new CArray<double,double>;

  00794	33 db		 xor	 ebx, ebx
$LN67@OnBtnOpt:

; 1030 : 		double nRoof=1;

  00796	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@3ff0000000000000

; 1031 : 		CStringArray stArraySendData;

  0079e	8d 8d 14 ff ff
	ff		 lea	 ecx, DWORD PTR _stArraySendData$2[ebp]
  007a4	f2 0f 11 45 c8	 movsd	 QWORD PTR _nRoof$1$[ebp], xmm0
  007a9	e8 00 00 00 00	 call	 ??0CStringArray@@QAE@XZ	; CStringArray::CStringArray

; 1032 : 		int i = 0;
; 1033 : 		for( i=0;i<m_ValueOptimizerArray.GetSize();i++)//  .

  007ae	8b 97 a0 11 00
	00		 mov	 edx, DWORD PTR [edi+4512]
  007b4	33 c0		 xor	 eax, eax
  007b6	c6 45 fc 0e	 mov	 BYTE PTR __$EHRec$[ebp+8], 14 ; 0000000eH
  007ba	89 45 f0	 mov	 DWORD PTR _i$1$[ebp], eax
  007bd	85 d2		 test	 edx, edx
  007bf	0f 8e fd 00 00
	00		 jle	 $LN448@OnBtnOpt

; 1030 : 		double nRoof=1;

  007c5	33 c9		 xor	 ecx, ecx
  007c7	89 4d ec	 mov	 DWORD PTR tv2657[ebp], ecx
  007ca	66 0f 1f 44 00
	00		 npad	 6
$LL19@OnBtnOpt:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 288  : 	if(nIndex >= 0 && nIndex < m_nSize)

  007d0	85 c9		 test	 ecx, ecx
  007d2	0f 88 f9 03 00
	00		 js	 $LN399@OnBtnOpt
  007d8	3b c2		 cmp	 eax, edx
  007da	0f 8d f1 03 00
	00		 jge	 $LN399@OnBtnOpt

; 289  : 		return m_pData[nIndex];

  007e0	8b b7 9c 11 00
	00		 mov	 esi, DWORD PTR [edi+4508]
  007e6	03 f1		 add	 esi, ecx
  007e8	8d 8d 60 ff ff
	ff		 lea	 ecx, DWORD PTR _stVal$4[ebp]
  007ee	56		 push	 esi
  007ef	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
  007f5	f2 0f 10 46 08	 movsd	 xmm0, QWORD PTR [esi+8]
  007fa	f2 0f 11 85 68
	ff ff ff	 movsd	 QWORD PTR _stVal$4[ebp+8], xmm0
  00802	f2 0f 11 45 d0	 movsd	 QWORD PTR tv2593[ebp], xmm0
  00807	f2 0f 10 46 10	 movsd	 xmm0, QWORD PTR [esi+16]
  0080c	f2 0f 11 85 70
	ff ff ff	 movsd	 QWORD PTR _stVal$4[ebp+16], xmm0
  00814	f2 0f 10 46 18	 movsd	 xmm0, QWORD PTR [esi+24]
  00819	f2 0f 11 85 78
	ff ff ff	 movsd	 QWORD PTR _stVal$4[ebp+24], xmm0
  00821	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00824	89 45 80	 mov	 DWORD PTR _stVal$4[ebp+32], eax
  00827	f2 0f 10 46 28	 movsd	 xmm0, QWORD PTR [esi+40]
  0082c	f2 0f 11 45 88	 movsd	 QWORD PTR _stVal$4[ebp+40], xmm0
  00831	f2 0f 10 46 30	 movsd	 xmm0, QWORD PTR [esi+48]
  00836	f2 0f 11 45 90	 movsd	 QWORD PTR _stVal$4[ebp+48], xmm0

; 333  : 	{ INT_PTR nIndex = m_nSize;

  0083b	8b 73 08	 mov	 esi, DWORD PTR [ebx+8]

; 538  : 	if(nIndex < 0)

  0083e	85 f6		 test	 esi, esi
  00840	0f 88 8b 03 00
	00		 js	 $LN399@OnBtnOpt

; 539  : 		AfxThrowInvalidArgException();
; 540  : 
; 541  : 	if (nIndex >= m_nSize)
; 542  : 		SetSize(nIndex+1, -1);

  00846	6a ff		 push	 -1
  00848	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  0084b	8b cb		 mov	 ecx, ebx
  0084d	50		 push	 eax
  0084e	e8 00 00 00 00	 call	 ?SetSize@?$CArray@NN@@QAEXHH@Z ; CArray<double,double>::SetSize

; 543  : 	m_pData[nIndex] = newElement;

  00853	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00856	f2 0f 10 45 d0	 movsd	 xmm0, QWORD PTR tv2593[ebp]
  0085b	f2 0f 11 04 f0	 movsd	 QWORD PTR [eax+esi*8], xmm0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 1039 : 			if(stVal.nEnd == stVal.nStart)

  00860	f2 0f 10 85 70
	ff ff ff	 movsd	 xmm0, QWORD PTR _stVal$4[ebp+16]
  00868	f2 0f 10 8d 68
	ff ff ff	 movsd	 xmm1, QWORD PTR _stVal$4[ebp+8]
  00870	66 0f 2e c1	 ucomisd xmm0, xmm1
  00874	9f		 lahf
  00875	f6 c4 44	 test	 ah, 68			; 00000044H
  00878	7a 0a		 jp	 SHORT $LN48@OnBtnOpt

; 1040 : 				nRoof1 = 1;

  0087a	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@3ff0000000000000
  00882	eb 14		 jmp	 SHORT $LN49@OnBtnOpt
$LN48@OnBtnOpt:

; 1041 : 			else
; 1042 : 				nRoof1 = ((stVal.nEnd - stVal.nStart)/stVal.nAdv)+1; 

  00884	f2 0f 5c c1	 subsd	 xmm0, xmm1
  00888	f2 0f 5e 85 78
	ff ff ff	 divsd	 xmm0, QWORD PTR _stVal$4[ebp+24]
  00890	f2 0f 58 05 00
	00 00 00	 addsd	 xmm0, QWORD PTR __real@3ff0000000000000
$LN49@OnBtnOpt:

; 1043 : 			nRoof *= nRoof1;

  00898	f2 0f 59 45 c8	 mulsd	 xmm0, QWORD PTR _nRoof$1$[ebp]
  0089d	8b 45 f0	 mov	 eax, DWORD PTR _i$1$[ebp]
  008a0	8b 4d ec	 mov	 ecx, DWORD PTR tv2657[ebp]
  008a3	40		 inc	 eax
  008a4	8b 97 a0 11 00
	00		 mov	 edx, DWORD PTR [edi+4512]
  008aa	83 c1 38	 add	 ecx, 56			; 00000038H
  008ad	89 45 f0	 mov	 DWORD PTR _i$1$[ebp], eax
  008b0	f2 0f 11 45 c8	 movsd	 QWORD PTR _nRoof$1$[ebp], xmm0
  008b5	89 4d ec	 mov	 DWORD PTR tv2657[ebp], ecx
  008b8	3b c2		 cmp	 eax, edx
  008ba	0f 8c 10 ff ff
	ff		 jl	 $LL19@OnBtnOpt

; 1063 : 						if(val2 <= m_ValueOptimizerArray.GetAt(k).nEnd)// Break

  008c0	eb 08		 jmp	 SHORT $LN18@OnBtnOpt
$LN448@OnBtnOpt:

; 1032 : 		int i = 0;
; 1033 : 		for( i=0;i<m_ValueOptimizerArray.GetSize();i++)//  .

  008c2	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@3ff0000000000000
$LN18@OnBtnOpt:

; 1044 : 		}
; 1045 : 
; 1046 : 		int nFlag = 0;//     Index   .
; 1047 : 		for(i =0; i<(int)nRoof;i++)

  008ca	f2 0f 2c c0	 cvttsd2si eax, xmm0
  008ce	33 f6		 xor	 esi, esi
  008d0	89 75 d8	 mov	 DWORD PTR _i$2$[ebp], esi
  008d3	89 45 cc	 mov	 DWORD PTR tv2673[ebp], eax
  008d6	85 c0		 test	 eax, eax
  008d8	0f 8e 71 02 00
	00		 jle	 $LN21@OnBtnOpt
  008de	66 90		 npad	 2
$LL22@OnBtnOpt:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 288  : 	if(nIndex >= 0 && nIndex < m_nSize)

  008e0	3b 73 08	 cmp	 esi, DWORD PTR [ebx+8]
  008e3	0f 8d e8 02 00
	00		 jge	 $LN399@OnBtnOpt

; 289  : 		return m_pData[nIndex];

  008e9	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]

; 288  : 	if(nIndex >= 0 && nIndex < m_nSize)

  008ec	3b b7 a0 11 00
	00		 cmp	 esi, DWORD PTR [edi+4512]
  008f2	0f 8d d9 02 00
	00		 jge	 $LN399@OnBtnOpt

; 289  : 		return m_pData[nIndex];

  008f8	8b 97 9c 11 00
	00		 mov	 edx, DWORD PTR [edi+4508]
  008fe	8d 04 f5 00 00
	00 00		 lea	 eax, DWORD PTR [esi*8]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 1049 : 			if(nStart->GetAt(nFlag) > m_ValueOptimizerArray.GetAt(nFlag).nEnd)

  00905	f2 0f 10 04 f1	 movsd	 xmm0, QWORD PTR [ecx+esi*8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 289  : 		return m_pData[nIndex];

  0090a	2b c6		 sub	 eax, esi
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 1049 : 			if(nStart->GetAt(nFlag) > m_ValueOptimizerArray.GetAt(nFlag).nEnd)

  0090c	66 0f 2f 44 c2
	10		 comisd	 xmm0, QWORD PTR [edx+eax*8+16]
  00912	0f 86 89 00 00
	00		 jbe	 $LN52@OnBtnOpt
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 305  : 		m_pData[nIndex] = newElement;

  00918	f2 0f 10 44 c2
	08		 movsd	 xmm0, QWORD PTR [edx+eax*8+8]
  0091e	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  00921	f2 0f 11 04 f1	 movsd	 QWORD PTR [ecx+esi*8], xmm0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 1057 : 				if(nFlag<nSize)//    ..

  00926	33 f6		 xor	 esi, esi
  00928	3b 45 e0	 cmp	 eax, DWORD PTR _nSize$1$[ebp]
  0092b	0f 45 f0	 cmovne	 esi, eax
  0092e	3b 75 e0	 cmp	 esi, DWORD PTR _nSize$1$[ebp]
  00931	7d 6e		 jge	 SHORT $LN52@OnBtnOpt

; 1059 : 					for(int k=nFlag;k<nStart->GetSize();k++)// .

  00933	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  00936	3b f1		 cmp	 esi, ecx
  00938	7d 65		 jge	 SHORT $LN297@OnBtnOpt
  0093a	8d 04 f5 00 00
	00 00		 lea	 eax, DWORD PTR [esi*8]
  00941	2b c6		 sub	 eax, esi
  00943	c1 e0 03	 shl	 eax, 3
$LL25@OnBtnOpt:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 288  : 	if(nIndex >= 0 && nIndex < m_nSize)

  00946	85 c0		 test	 eax, eax
  00948	0f 88 83 02 00
	00		 js	 $LN399@OnBtnOpt
  0094e	3b f1		 cmp	 esi, ecx
  00950	0f 8d 7b 02 00
	00		 jge	 $LN399@OnBtnOpt

; 289  : 		return m_pData[nIndex];

  00956	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]

; 288  : 	if(nIndex >= 0 && nIndex < m_nSize)

  00959	3b b7 a0 11 00
	00		 cmp	 esi, DWORD PTR [edi+4512]
  0095f	0f 8d 6c 02 00
	00		 jge	 $LN399@OnBtnOpt

; 289  : 		return m_pData[nIndex];

  00965	8b 8f 9c 11 00
	00		 mov	 ecx, DWORD PTR [edi+4508]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 1062 : 						val2+= m_ValueOptimizerArray.GetAt(k).nAdv;

  0096b	f2 0f 10 4c 08
	18		 movsd	 xmm1, QWORD PTR [eax+ecx+24]
  00971	f2 0f 58 0c f2	 addsd	 xmm1, QWORD PTR [edx+esi*8]

; 1063 : 						if(val2 <= m_ValueOptimizerArray.GetAt(k).nEnd)// Break

  00976	f2 0f 10 44 08
	10		 movsd	 xmm0, QWORD PTR [eax+ecx+16]
  0097c	66 0f 2f c1	 comisd	 xmm0, xmm1
  00980	73 18		 jae	 SHORT $LN402@OnBtnOpt
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 305  : 		m_pData[nIndex] = newElement;

  00982	f2 0f 10 44 08
	08		 movsd	 xmm0, QWORD PTR [eax+ecx+8]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 1059 : 					for(int k=nFlag;k<nStart->GetSize();k++)// .

  00988	83 c0 38	 add	 eax, 56			; 00000038H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 305  : 		m_pData[nIndex] = newElement;

  0098b	f2 0f 11 04 f2	 movsd	 QWORD PTR [edx+esi*8], xmm0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 1059 : 					for(int k=nFlag;k<nStart->GetSize();k++)// .

  00990	46		 inc	 esi
  00991	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  00994	3b f1		 cmp	 esi, ecx
  00996	7c ae		 jl	 SHORT $LL25@OnBtnOpt

; 1063 : 						if(val2 <= m_ValueOptimizerArray.GetAt(k).nEnd)// Break

  00998	eb 05		 jmp	 SHORT $LN297@OnBtnOpt
$LN402@OnBtnOpt:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 305  : 		m_pData[nIndex] = newElement;

  0099a	f2 0f 11 0c f2	 movsd	 QWORD PTR [edx+esi*8], xmm1
$LN297@OnBtnOpt:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 1073 : 					nFlag = 0;

  0099f	33 f6		 xor	 esi, esi
$LN52@OnBtnOpt:

; 1074 : 				}
; 1075 : 			}
; 1076 : 
; 1077 : 			CString stOption;

  009a1	8d 4d e8	 lea	 ecx, DWORD PTR _stOption$9[ebp]
  009a4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 1078 : 			for(int j =0;j<nStart->GetSize();j++)// 

  009aa	33 c0		 xor	 eax, eax
  009ac	c6 45 fc 0f	 mov	 BYTE PTR __$EHRec$[ebp+8], 15 ; 0000000fH
  009b0	89 45 ec	 mov	 DWORD PTR _j$1$[ebp], eax
  009b3	39 43 08	 cmp	 DWORD PTR [ebx+8], eax
  009b6	7e 77		 jle	 SHORT $LN27@OnBtnOpt
  009b8	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL28@OnBtnOpt:

; 1080 : 				CString stValue;

  009c0	8d 4d f0	 lea	 ecx, DWORD PTR _stValue$11[ebp]
  009c3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 288  : 	if(nIndex >= 0 && nIndex < m_nSize)

  009c9	8b 4d ec	 mov	 ecx, DWORD PTR _j$1$[ebp]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 1080 : 				CString stValue;

  009cc	c6 45 fc 10	 mov	 BYTE PTR __$EHRec$[ebp+8], 16 ; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 288  : 	if(nIndex >= 0 && nIndex < m_nSize)

  009d0	85 c9		 test	 ecx, ecx
  009d2	0f 88 f9 01 00
	00		 js	 $LN399@OnBtnOpt
  009d8	3b 4b 08	 cmp	 ecx, DWORD PTR [ebx+8]
  009db	0f 8d f0 01 00
	00		 jge	 $LN399@OnBtnOpt

; 289  : 		return m_pData[nIndex];

  009e1	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 1082 : 				stValue.Format("%s%d=%.2f,",INPUTVALUE, j, Val);//Grid   Wnd .

  009e4	83 ec 08	 sub	 esp, 8
  009e7	f2 0f 10 04 c8	 movsd	 xmm0, QWORD PTR [eax+ecx*8]
  009ec	8d 45 f0	 lea	 eax, DWORD PTR _stValue$11[ebp]
  009ef	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  009f4	51		 push	 ecx
  009f5	68 00 00 00 00	 push	 OFFSET ??_C@_05DCDOHKAB@Input@
  009fa	68 00 00 00 00	 push	 OFFSET ??_C@_0L@CNGHBHNE@?$CFs?$CFd?$DN?$CF?42f?0@
  009ff	50		 push	 eax
  00a00	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Format@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAAXPBDZZ
  00a06	83 c4 18	 add	 esp, 24			; 00000018H

; 1083 : 				stOption += stValue;

  00a09	8d 45 f0	 lea	 eax, DWORD PTR _stValue$11[ebp]
  00a0c	8d 4d e8	 lea	 ecx, DWORD PTR _stOption$9[ebp]
  00a0f	50		 push	 eax
  00a10	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV?$CSimpleStringT@D$00@1@@Z

; 1084 : 			}

  00a16	8d 4d f0	 lea	 ecx, DWORD PTR _stValue$11[ebp]
  00a19	c6 45 fc 0f	 mov	 BYTE PTR __$EHRec$[ebp+8], 15 ; 0000000fH
  00a1d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00a23	8b 45 ec	 mov	 eax, DWORD PTR _j$1$[ebp]
  00a26	40		 inc	 eax
  00a27	89 45 ec	 mov	 DWORD PTR _j$1$[ebp], eax
  00a2a	3b 43 08	 cmp	 eax, DWORD PTR [ebx+8]
  00a2d	7c 91		 jl	 SHORT $LL28@OnBtnOpt
$LN27@OnBtnOpt:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h

; 519  : 		return( GetData()->nDataLength );

  00a2f	8b 45 e8	 mov	 eax, DWORD PTR _stOption$9[ebp]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 1086 : 			stOption.Delete(stOption.GetLength()-1,1);

  00a32	8d 4d e8	 lea	 ecx, DWORD PTR _stOption$9[ebp]
  00a35	6a 01		 push	 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h

; 519  : 		return( GetData()->nDataLength );

  00a37	8b 40 f4	 mov	 eax, DWORD PTR [eax-12]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 1086 : 			stOption.Delete(stOption.GetLength()-1,1);

  00a3a	48		 dec	 eax
  00a3b	50		 push	 eax
  00a3c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Delete@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEHHH@Z

; 1087 : 			if(bRetValue)

  00a42	83 7d e4 00	 cmp	 DWORD PTR _bRetValue$1$[ebp], 0
  00a46	74 5e		 je	 SHORT $LN55@OnBtnOpt

; 1088 : 			{
; 1089 : 				m_pStrategyItem->SetSendValString(stOption);

  00a48	51		 push	 ecx
  00a49	8d 45 e8	 lea	 eax, DWORD PTR _stOption$9[ebp]
  00a4c	8b cc		 mov	 ecx, esp
  00a4e	50		 push	 eax
  00a4f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z
  00a55	8b 8f 10 05 00
	00		 mov	 ecx, DWORD PTR [edi+1296]
  00a5b	8b 01		 mov	 eax, DWORD PTR [ecx]
  00a5d	ff 90 94 00 00
	00		 call	 DWORD PTR [eax+148]

; 1090 : 				m_pStrategyItem->SetValOptimizer((LONG)nStart);

  00a63	8b 8f 10 05 00
	00		 mov	 ecx, DWORD PTR [edi+1296]
  00a69	53		 push	 ebx
  00a6a	8b 01		 mov	 eax, DWORD PTR [ecx]
  00a6c	ff 90 88 00 00
	00		 call	 DWORD PTR [eax+136]

; 1091 : 				bRetValue = m_pStrategyItem->LoadST(m_stPath,m_stCode,m_nCount,m_stEndDate); //

  00a72	ff b7 80 11 00
	00		 push	 DWORD PTR [edi+4480]
  00a78	8b 8f 10 05 00
	00		 mov	 ecx, DWORD PTR [edi+1296]
  00a7e	ff b7 7c 11 00
	00		 push	 DWORD PTR [edi+4476]
  00a84	ff b7 78 11 00
	00		 push	 DWORD PTR [edi+4472]
  00a8a	8b 01		 mov	 eax, DWORD PTR [ecx]
  00a8c	ff b7 ac 11 00
	00		 push	 DWORD PTR [edi+4524]
  00a92	ff 50 14	 call	 DWORD PTR [eax+20]

; 1092 : 				m_pStrategyItem->Run(stOption);

  00a95	8b 8f 10 05 00
	00		 mov	 ecx, DWORD PTR [edi+1296]
  00a9b	ff 75 e8	 push	 DWORD PTR _stOption$9[ebp]
  00a9e	89 45 e4	 mov	 DWORD PTR _bRetValue$1$[ebp], eax
  00aa1	8b 01		 mov	 eax, DWORD PTR [ecx]
  00aa3	ff 50 18	 call	 DWORD PTR [eax+24]
$LN55@OnBtnOpt:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 288  : 	if(nIndex >= 0 && nIndex < m_nSize)

  00aa6	85 f6		 test	 esi, esi
  00aa8	0f 88 23 01 00
	00		 js	 $LN399@OnBtnOpt
  00aae	3b b7 a0 11 00
	00		 cmp	 esi, DWORD PTR [edi+4512]
  00ab4	0f 8d 17 01 00
	00		 jge	 $LN399@OnBtnOpt

; 289  : 		return m_pData[nIndex];

  00aba	8b 87 9c 11 00
	00		 mov	 eax, DWORD PTR [edi+4508]
  00ac0	8d 0c f5 00 00
	00 00		 lea	 ecx, DWORD PTR [esi*8]
  00ac7	2b ce		 sub	 ecx, esi
  00ac9	0f 57 c9	 xorps	 xmm1, xmm1
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 1095 : 			if( m_ValueOptimizerArray.GetAt(nFlag).nAdv==0 && nSize > nFlag+1)

  00acc	f2 0f 10 44 c8
	18		 movsd	 xmm0, QWORD PTR [eax+ecx*8+24]
  00ad2	66 0f 2e c1	 ucomisd xmm0, xmm1
  00ad6	9f		 lahf
  00ad7	f6 c4 44	 test	 ah, 68			; 00000044H
  00ada	7a 09		 jp	 SHORT $LN56@OnBtnOpt
  00adc	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  00adf	39 45 e0	 cmp	 DWORD PTR _nSize$1$[ebp], eax
  00ae2	0f 4f f0	 cmovg	 esi, eax
$LN56@OnBtnOpt:

; 1096 : 				nFlag++;
; 1097 : 			stOption ="";

  00ae5	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@@
  00aea	8d 4d e8	 lea	 ecx, DWORD PTR _stOption$9[ebp]
  00aed	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 288  : 	if(nIndex >= 0 && nIndex < m_nSize)

  00af3	85 f6		 test	 esi, esi
  00af5	0f 88 d6 00 00
	00		 js	 $LN399@OnBtnOpt
  00afb	3b 73 08	 cmp	 esi, DWORD PTR [ebx+8]
  00afe	0f 8d cd 00 00
	00		 jge	 $LN399@OnBtnOpt

; 289  : 		return m_pData[nIndex];

  00b04	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]

; 288  : 	if(nIndex >= 0 && nIndex < m_nSize)

  00b07	3b b7 a0 11 00
	00		 cmp	 esi, DWORD PTR [edi+4512]
  00b0d	0f 8d be 00 00
	00		 jge	 $LN399@OnBtnOpt

; 289  : 		return m_pData[nIndex];

  00b13	8b 87 9c 11 00
	00		 mov	 eax, DWORD PTR [edi+4508]
  00b19	8d 0c f5 00 00
	00 00		 lea	 ecx, DWORD PTR [esi*8]
  00b20	2b ce		 sub	 ecx, esi
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 1102 : 		}

  00b22	c6 45 fc 0e	 mov	 BYTE PTR __$EHRec$[ebp+8], 14 ; 0000000eH
  00b26	f2 0f 10 44 c8
	18		 movsd	 xmm0, QWORD PTR [eax+ecx*8+24]
  00b2c	8d 4d e8	 lea	 ecx, DWORD PTR _stOption$9[ebp]
  00b2f	f2 0f 58 04 f2	 addsd	 xmm0, QWORD PTR [edx+esi*8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 305  : 		m_pData[nIndex] = newElement;

  00b34	f2 0f 11 04 f2	 movsd	 QWORD PTR [edx+esi*8], xmm0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 1102 : 		}

  00b39	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00b3f	8b 4d d8	 mov	 ecx, DWORD PTR _i$2$[ebp]
  00b42	41		 inc	 ecx
  00b43	89 4d d8	 mov	 DWORD PTR _i$2$[ebp], ecx
  00b46	3b 4d cc	 cmp	 ecx, DWORD PTR tv2673[ebp]
  00b49	0f 8c 91 fd ff
	ff		 jl	 $LL22@OnBtnOpt
$LN21@OnBtnOpt:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 381  : 		if (m_pData != NULL)

  00b4f	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00b52	85 c0		 test	 eax, eax
  00b54	74 10		 je	 SHORT $LN356@OnBtnOpt

; 382  : 		{
; 383  : 			for( int i = 0; i < m_nSize; i++ )
; 384  : 				(m_pData + i)->~TYPE();
; 385  : 			delete[] (BYTE*)m_pData;

  00b56	50		 push	 eax
  00b57	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00b5c	83 c4 04	 add	 esp, 4

; 386  : 			m_pData = NULL;

  00b5f	c7 43 04 00 00
	00 00		 mov	 DWORD PTR [ebx+4], 0
$LN356@OnBtnOpt:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 1105 : 		delete nStart;

  00b66	8b 03		 mov	 eax, DWORD PTR [ebx]
  00b68	8b cb		 mov	 ecx, ebx
  00b6a	6a 01		 push	 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 388  : 		m_nSize = m_nMaxSize = 0;

  00b6c	c7 43 0c 00 00
	00 00		 mov	 DWORD PTR [ebx+12], 0
  00b73	c7 43 08 00 00
	00 00		 mov	 DWORD PTR [ebx+8], 0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 1105 : 		delete nStart;

  00b7a	ff 50 04	 call	 DWORD PTR [eax+4]

; 1106 : 	}

  00b7d	8d 8d 14 ff ff
	ff		 lea	 ecx, DWORD PTR _stArraySendData$2[ebp]
  00b83	e8 00 00 00 00	 call	 ??1CStringArray@@UAE@XZ	; CStringArray::~CStringArray
  00b88	8d 8d 60 ff ff
	ff		 lea	 ecx, DWORD PTR _stVal$4[ebp]
$LN451@OnBtnOpt:

; 1107 : }

  00b8e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$LN385@OnBtnOpt:
  00b94	8d 4d c4	 lea	 ecx, DWORD PTR _strUserPath$[ebp]
  00b97	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00b9d	8d 4d c0	 lea	 ecx, DWORD PTR _strSystemPath$[ebp]
  00ba0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$LN87@OnBtnOpt:
  00ba6	8d 4d 98	 lea	 ecx, DWORD PTR _stArrayPath$[ebp]
  00ba9	e8 00 00 00 00	 call	 ??1CStringArray@@UAE@XZ	; CStringArray::~CStringArray
  00bae	8d 4d ac	 lea	 ecx, DWORD PTR _stArraySTPath$[ebp]
  00bb1	e8 00 00 00 00	 call	 ??1CStringArray@@UAE@XZ	; CStringArray::~CStringArray
  00bb6	8d 4d dc	 lea	 ecx, DWORD PTR _szSTPath$[ebp]
  00bb9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00bbf	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00bc2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00bc9	59		 pop	 ecx
  00bca	5f		 pop	 edi
  00bcb	5e		 pop	 esi
  00bcc	5b		 pop	 ebx
  00bcd	8b e5		 mov	 esp, ebp
  00bcf	5d		 pop	 ebp
  00bd0	c3		 ret	 0
$LN399@OnBtnOpt:
  00bd1	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN450@OnBtnOpt:
  00bd6	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?OnBtnOpt@CDlgOptimizer@@IAEXXZ$0:
  00000	8d 4d dc	 lea	 ecx, DWORD PTR _szSTPath$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?OnBtnOpt@CDlgOptimizer@@IAEXXZ$1:
  00009	8d 4d ac	 lea	 ecx, DWORD PTR _stArraySTPath$[ebp]
  0000c	e9 00 00 00 00	 jmp	 ??1CStringArray@@UAE@XZ	; CStringArray::~CStringArray
__unwindfunclet$?OnBtnOpt@CDlgOptimizer@@IAEXXZ$2:
  00011	8d 4d 98	 lea	 ecx, DWORD PTR _stArrayPath$[ebp]
  00014	e9 00 00 00 00	 jmp	 ??1CStringArray@@UAE@XZ	; CStringArray::~CStringArray
__unwindfunclet$?OnBtnOpt@CDlgOptimizer@@IAEXXZ$17:
  00019	8b 45 e4	 mov	 eax, DWORD PTR $T7[ebp]
  0001c	83 e0 01	 and	 eax, 1
  0001f	0f 84 0d 00 00
	00		 je	 $LN99@OnBtnOpt
  00025	83 65 e4 fe	 and	 DWORD PTR $T7[ebp], -2	; fffffffeH
  00029	8d 4d ec	 lea	 ecx, DWORD PTR $T10[ebp]
  0002c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$LN99@OnBtnOpt:
  00032	c3		 ret	 0
__unwindfunclet$?OnBtnOpt@CDlgOptimizer@@IAEXXZ$18:
  00033	8b 45 e4	 mov	 eax, DWORD PTR $T7[ebp]
  00036	83 e0 02	 and	 eax, 2
  00039	0f 84 0d 00 00
	00		 je	 $LN112@OnBtnOpt
  0003f	83 65 e4 fd	 and	 DWORD PTR $T7[ebp], -3	; fffffffdH
  00043	8d 4d e0	 lea	 ecx, DWORD PTR $T6[ebp]
  00046	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$LN112@OnBtnOpt:
  0004c	c3		 ret	 0
__unwindfunclet$?OnBtnOpt@CDlgOptimizer@@IAEXXZ$19:
  0004d	8b 45 e4	 mov	 eax, DWORD PTR $T7[ebp]
  00050	83 e0 04	 and	 eax, 4
  00053	0f 84 0d 00 00
	00		 je	 $LN128@OnBtnOpt
  00059	83 65 e4 fb	 and	 DWORD PTR $T7[ebp], -5	; fffffffbH
  0005d	8d 4d f0	 lea	 ecx, DWORD PTR $T14[ebp]
  00060	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$LN128@OnBtnOpt:
  00066	c3		 ret	 0
__unwindfunclet$?OnBtnOpt@CDlgOptimizer@@IAEXXZ$20:
  00067	8b 45 e4	 mov	 eax, DWORD PTR $T7[ebp]
  0006a	83 e0 08	 and	 eax, 8
  0006d	0f 84 0d 00 00
	00		 je	 $LN143@OnBtnOpt
  00073	83 65 e4 f7	 and	 DWORD PTR $T7[ebp], -9	; fffffff7H
  00077	8d 4d f0	 lea	 ecx, DWORD PTR $T13[ebp]
  0007a	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$LN143@OnBtnOpt:
  00080	c3		 ret	 0
__unwindfunclet$?OnBtnOpt@CDlgOptimizer@@IAEXXZ$7:
  00081	8d 4d c0	 lea	 ecx, DWORD PTR _strSystemPath$[ebp]
  00084	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?OnBtnOpt@CDlgOptimizer@@IAEXXZ$22:
  0008a	8b 45 e4	 mov	 eax, DWORD PTR $T7[ebp]
  0008d	83 e0 20	 and	 eax, 32			; 00000020H
  00090	0f 84 0d 00 00
	00		 je	 $LN169@OnBtnOpt
  00096	83 65 e4 df	 and	 DWORD PTR $T7[ebp], -33	; ffffffdfH
  0009a	8d 4d f0	 lea	 ecx, DWORD PTR $T12[ebp]
  0009d	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$LN169@OnBtnOpt:
  000a3	c3		 ret	 0
__unwindfunclet$?OnBtnOpt@CDlgOptimizer@@IAEXXZ$9:
  000a4	8d 4d c4	 lea	 ecx, DWORD PTR _strUserPath$[ebp]
  000a7	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?OnBtnOpt@CDlgOptimizer@@IAEXXZ$10:
  000ad	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _stValOtm$3[ebp]
  000b3	e9 00 00 00 00	 jmp	 ??1ST_VALUEOPTIMAZE@@QAE@XZ
__unwindfunclet$?OnBtnOpt@CDlgOptimizer@@IAEXXZ$11:
  000b8	8d 8d 60 ff ff
	ff		 lea	 ecx, DWORD PTR _stVal$4[ebp]
  000be	e9 00 00 00 00	 jmp	 ??1ST_VALUEOPTIMAZE@@QAE@XZ
__unwindfunclet$?OnBtnOpt@CDlgOptimizer@@IAEXXZ$13:
  000c3	8d 8d 14 ff ff
	ff		 lea	 ecx, DWORD PTR _stArraySendData$2[ebp]
  000c9	e9 00 00 00 00	 jmp	 ??1CStringArray@@UAE@XZ	; CStringArray::~CStringArray
__unwindfunclet$?OnBtnOpt@CDlgOptimizer@@IAEXXZ$14:
  000ce	8d 4d e8	 lea	 ecx, DWORD PTR _stOption$9[ebp]
  000d1	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?OnBtnOpt@CDlgOptimizer@@IAEXXZ$15:
  000d7	8d 4d f0	 lea	 ecx, DWORD PTR _stValue$11[ebp]
  000da	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  000e0	cc		 int	 3
  000e1	cc		 int	 3
  000e2	cc		 int	 3
  000e3	cc		 int	 3
  000e4	cc		 int	 3
__ehhandler$?OnBtnOpt@CDlgOptimizer@@IAEXXZ:
  000e5	90		 npad	 1
  000e6	90		 npad	 1
  000e7	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  000eb	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  000ee	8b 8a 10 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-240]
  000f4	33 c8		 xor	 ecx, eax
  000f6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000fb	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?OnBtnOpt@CDlgOptimizer@@IAEXXZ
  00100	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?OnBtnOpt@CDlgOptimizer@@IAEXXZ ENDP			; CDlgOptimizer::OnBtnOpt
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin1.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
;	COMDAT ?OnDestroy@CDlgOptimizer@@IAEXXZ
_TEXT	SEGMENT
_nSize$1$ = -4						; size = 4
?OnDestroy@CDlgOptimizer@@IAEXXZ PROC			; CDlgOptimizer::OnDestroy, COMDAT
; _this$ = ecx

; 592  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	57		 push	 edi
  00005	8b f9		 mov	 edi, ecx

; 593  : 	if(m_Font.GetSafeHandle())

  00007	8d 8f f0 12 00
	00		 lea	 ecx, DWORD PTR [edi+4848]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin1.inl

; 68   : 	{ return this == NULL ? NULL : m_hObject; }

  0000d	85 c9		 test	 ecx, ecx
  0000f	74 0b		 je	 SHORT $LN8@OnDestroy
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 593  : 	if(m_Font.GetSafeHandle())

  00011	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  00015	74 05		 je	 SHORT $LN8@OnDestroy

; 594  : 		m_Font.DeleteObject();

  00017	e8 00 00 00 00	 call	 ?DeleteObject@CGdiObject@@QAEHXZ ; CGdiObject::DeleteObject
$LN8@OnDestroy:

; 595  : 	
; 596  : 	CDialog::OnDestroy();

  0001c	8b cf		 mov	 ecx, edi
  0001e	e8 00 00 00 00	 call	 ?OnDestroy@CWnd@@IAEXXZ	; CWnd::OnDestroy

; 597  : 
; 598  : 	m_ImageListIcon.DeleteImageList();

  00023	8d 8f cc 10 00
	00		 lea	 ecx, DWORD PTR [edi+4300]
  00029	e8 00 00 00 00	 call	 ?DeleteImageList@CImageList@@QAEHXZ ; CImageList::DeleteImageList

; 599  : 	m_ImageOutbarIcon.DeleteImageList();

  0002e	8d 8f d4 10 00
	00		 lea	 ecx, DWORD PTR [edi+4308]
  00034	e8 00 00 00 00	 call	 ?DeleteImageList@CImageList@@QAEHXZ ; CImageList::DeleteImageList

; 1759 : 	if(m_pDlgTimeSetup) delete m_pDlgTimeSetup;

  00039	8b 8f 2c 05 00
	00		 mov	 ecx, DWORD PTR [edi+1324]
  0003f	85 c9		 test	 ecx, ecx
  00041	74 07		 je	 SHORT $LN24@OnDestroy
  00043	8b 01		 mov	 eax, DWORD PTR [ecx]
  00045	6a 01		 push	 1
  00047	ff 50 04	 call	 DWORD PTR [eax+4]
$LN24@OnDestroy:

; 600  : 
; 601  : 	DestoryTImeSetupDlg();
; 602  : 
; 603  : 	if(m_pStrategyItem)

  0004a	8b 8f 10 05 00
	00		 mov	 ecx, DWORD PTR [edi+1296]

; 1760 : 	m_pDlgTimeSetup=NULL;

  00050	c7 87 2c 05 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+1324], 0

; 600  : 
; 601  : 	DestoryTImeSetupDlg();
; 602  : 
; 603  : 	if(m_pStrategyItem)

  0005a	85 c9		 test	 ecx, ecx
  0005c	74 1f		 je	 SHORT $LN9@OnDestroy

; 604  : 	{
; 605  : 		m_pStrategyItem->DestoryWindow();

  0005e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00060	ff 50 08	 call	 DWORD PTR [eax+8]

; 606  : 		delete m_pStrategyItem;

  00063	8b 8f 10 05 00
	00		 mov	 ecx, DWORD PTR [edi+1296]
  00069	85 c9		 test	 ecx, ecx
  0006b	74 06		 je	 SHORT $LN13@OnDestroy
  0006d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0006f	6a 01		 push	 1
  00071	ff 10		 call	 DWORD PTR [eax]
$LN13@OnDestroy:

; 607  : 		m_pStrategyItem = NULL;

  00073	c7 87 10 05 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+1296], 0
$LN9@OnDestroy:
  0007d	53		 push	 ebx
  0007e	56		 push	 esi

; 608  : 	}
; 609  : 
; 610  : 	OnBnClickedBtnDelall();

  0007f	8b cf		 mov	 ecx, edi
  00081	e8 00 00 00 00	 call	 ?OnBnClickedBtnDelall@CDlgOptimizer@@QAEXXZ ; CDlgOptimizer::OnBnClickedBtnDelall

; 611  : 	// TODO: Add your message handler code here
; 612  : 	CDialog *pTabDlg = NULL;
; 613  : 	int nSize = m_arrayTab.GetSize();

  00086	8b 87 98 0e 00
	00		 mov	 eax, DWORD PTR [edi+3736]

; 614  : 	for(int nPos=0;nPos<nSize;nPos++)

  0008c	33 db		 xor	 ebx, ebx
  0008e	89 45 fc	 mov	 DWORD PTR _nSize$1$[ebp], eax
  00091	85 c0		 test	 eax, eax
  00093	7e 33		 jle	 SHORT $LN3@OnDestroy
$LL4@OnDestroy:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 288  : 	if(nIndex >= 0 && nIndex < m_nSize)

  00095	85 db		 test	 ebx, ebx
  00097	0f 88 1b 01 00
	00		 js	 $LN31@OnDestroy
  0009d	3b 9f 98 0e 00
	00		 cmp	 ebx, DWORD PTR [edi+3736]
  000a3	0f 8d 0f 01 00
	00		 jge	 $LN31@OnDestroy
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 616  : 		pTabDlg = m_arrayTab.GetAt(nPos);

  000a9	8b 87 94 0e 00
	00		 mov	 eax, DWORD PTR [edi+3732]
  000af	8b 34 98	 mov	 esi, DWORD PTR [eax+ebx*4]

; 617  : 		pTabDlg->DestroyWindow();

  000b2	8b ce		 mov	 ecx, esi
  000b4	8b 06		 mov	 eax, DWORD PTR [esi]
  000b6	ff 50 68	 call	 DWORD PTR [eax+104]

; 618  : 		delete pTabDlg;

  000b9	8b 06		 mov	 eax, DWORD PTR [esi]
  000bb	8b ce		 mov	 ecx, esi
  000bd	6a 01		 push	 1
  000bf	ff 50 04	 call	 DWORD PTR [eax+4]
  000c2	43		 inc	 ebx
  000c3	3b 5d fc	 cmp	 ebx, DWORD PTR _nSize$1$[ebp]
  000c6	7c cd		 jl	 SHORT $LL4@OnDestroy
$LN3@OnDestroy:

; 619  : 	}
; 620  : 
; 621  : 	ST_VALUESET *ValueSet;
; 622  : 	for(int i =0 ;i< m_arrayValue.GetSize();i++)

  000c8	8b 87 ac 0e 00
	00		 mov	 eax, DWORD PTR [edi+3756]
  000ce	33 f6		 xor	 esi, esi
  000d0	85 c0		 test	 eax, eax
  000d2	7e 2e		 jle	 SHORT $LN6@OnDestroy
$LL7@OnDestroy:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 288  : 	if(nIndex >= 0 && nIndex < m_nSize)

  000d4	85 f6		 test	 esi, esi
  000d6	0f 88 dc 00 00
	00		 js	 $LN31@OnDestroy
  000dc	3b f0		 cmp	 esi, eax
  000de	0f 8d d4 00 00
	00		 jge	 $LN31@OnDestroy
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 625  : 		delete ValueSet;

  000e4	8b 87 a8 0e 00
	00		 mov	 eax, DWORD PTR [edi+3752]
  000ea	6a 1c		 push	 28			; 0000001cH
  000ec	ff 34 b0	 push	 DWORD PTR [eax+esi*4]
  000ef	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  000f4	8b 87 ac 0e 00
	00		 mov	 eax, DWORD PTR [edi+3756]
  000fa	46		 inc	 esi
  000fb	83 c4 08	 add	 esp, 8
  000fe	3b f0		 cmp	 esi, eax
  00100	7c d2		 jl	 SHORT $LL7@OnDestroy
$LN6@OnDestroy:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 381  : 		if (m_pData != NULL)

  00102	8b 87 94 0e 00
	00		 mov	 eax, DWORD PTR [edi+3732]
  00108	85 c0		 test	 eax, eax
  0010a	74 13		 je	 SHORT $LN55@OnDestroy

; 382  : 		{
; 383  : 			for( int i = 0; i < m_nSize; i++ )
; 384  : 				(m_pData + i)->~TYPE();
; 385  : 			delete[] (BYTE*)m_pData;

  0010c	50		 push	 eax
  0010d	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00112	83 c4 04	 add	 esp, 4

; 386  : 			m_pData = NULL;

  00115	c7 87 94 0e 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+3732], 0
$LN55@OnDestroy:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 1864 : 	if(!m_pSTLoadMnger) return;

  0011f	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetProcAddress@8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 388  : 		m_nSize = m_nMaxSize = 0;

  00125	c7 87 9c 0e 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+3740], 0
  0012f	c7 87 98 0e 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+3736], 0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 1864 : 	if(!m_pSTLoadMnger) return;

  00139	83 bf c8 10 00
	00 00		 cmp	 DWORD PTR [edi+4296], 0
  00140	74 34		 je	 SHORT $LN101@OnDestroy

; 1865 : 
; 1866 : 	typedef	void (FPSCW_DeleteInterfaceOfStrategy)(LONG dwKey, LONG dwType);
; 1867 : 	if(hTradeInst == NULL) return;

  00142	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hTradeInst@@3PAUHINSTANCE__@@A ; hTradeInst
  00147	85 c0		 test	 eax, eax
  00149	74 30		 je	 SHORT $LN87@OnDestroy

; 1868 : 
; 1869 : 	FPSCW_DeleteInterfaceOfStrategy* pFunc = (FPSCW_DeleteInterfaceOfStrategy*)GetProcAddress(hTradeInst,_T("SCW_DeleteInterfaceOfStrategy"));

  0014b	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@CPKKMKKO@SCW_DeleteInterfaceOfStrategy@
  00150	50		 push	 eax
  00151	ff d6		 call	 esi
  00153	8b d8		 mov	 ebx, eax

; 1870 : 	if(pFunc == NULL) return ;

  00155	85 db		 test	 ebx, ebx
  00157	74 1d		 je	 SHORT $LN101@OnDestroy

; 1871 : 
; 1872 : 	LONG dwType = 0;	//CSTLoadManager*
; 1873 : 	if(m_pSTLoadMnger)

  00159	8b 97 c8 10 00
	00		 mov	 edx, DWORD PTR [edi+4296]
  0015f	85 d2		 test	 edx, edx
  00161	74 13		 je	 SHORT $LN101@OnDestroy

; 1874 : 	{
; 1875 : 		m_pSTLoadMnger->UnloadST();

  00163	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00165	52		 push	 edx
  00166	ff 51 08	 call	 DWORD PTR [ecx+8]

; 1876 : 		pFunc((LONG)m_pSTLoadMnger, dwType);

  00169	6a 00		 push	 0
  0016b	ff b7 c8 10 00
	00		 push	 DWORD PTR [edi+4296]
  00171	ff d3		 call	 ebx
  00173	83 c4 08	 add	 esp, 8
$LN101@OnDestroy:

; 626  : 	}
; 627  : 	m_arrayTab.RemoveAll();	
; 628  : 
; 629  : 	//@@@06.12.07[[
; 630  : 	{
; 631  : 		UnLoadSTList();
; 632  : 	   FreeLibrary(hTradeInst);

  00176	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hTradeInst@@3PAUHINSTANCE__@@A ; hTradeInst
$LN87@OnDestroy:
  0017b	50		 push	 eax
  0017c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FreeLibrary@4

; 633  : 		typedef	LONG (FnSCW_IGfxOutBarCtrl)(int nType, long dwValue, long dwReserved1);
; 634  : 
; 635  : 		FnSCW_IGfxOutBarCtrl* pFunc = (FnSCW_IGfxOutBarCtrl*)GetProcAddress(m_hSTConfigureWizardInst ,_T("SCW_IGfxOutBarCtrl"));

  00182	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@CNEELEMP@SCW_IGfxOutBarCtrl@
  00187	ff b7 b4 11 00
	00		 push	 DWORD PTR [edi+4532]
  0018d	ff d6		 call	 esi
  0018f	5e		 pop	 esi
  00190	5b		 pop	 ebx

; 636  : 		if(pFunc == NULL) return ;

  00191	85 c0		 test	 eax, eax
  00193	74 1e		 je	 SHORT $LN11@OnDestroy

; 637  : 
; 638  : 		if(m_pWndOutBar) {

  00195	8b 8f b8 11 00
	00		 mov	 ecx, DWORD PTR [edi+4536]
  0019b	85 c9		 test	 ecx, ecx
  0019d	74 14		 je	 SHORT $LN11@OnDestroy

; 639  : 			// m_pWndOutBar->GetCoutBarCtrl()->DestroyWindow();
; 640  : 			pFunc(1, (long)m_pWndOutBar, 0);

  0019f	6a 00		 push	 0
  001a1	51		 push	 ecx
  001a2	6a 01		 push	 1
  001a4	ff d0		 call	 eax
  001a6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 641  : 			m_pWndOutBar = NULL;

  001a9	c7 87 b8 11 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+4536], 0
$LN11@OnDestroy:
  001b3	5f		 pop	 edi

; 645  : }

  001b4	8b e5		 mov	 esp, ebp
  001b6	5d		 pop	 ebp
  001b7	c3		 ret	 0
$LN31@OnDestroy:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 290  : 	AfxThrowInvalidArgException();

  001b8	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN102@OnDestroy:
  001bd	cc		 int	 3
?OnDestroy@CDlgOptimizer@@IAEXXZ ENDP			; CDlgOptimizer::OnDestroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin1.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin1.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
;	COMDAT ?OnCtlColor@CDlgOptimizer@@IAEPAUHBRUSH__@@PAVCDC@@PAVCWnd@@I@Z
_TEXT	SEGMENT
_pDC$ = 8						; size = 4
_pWnd$ = 12						; size = 4
_nCtlColor$ = 16					; size = 4
?OnCtlColor@CDlgOptimizer@@IAEPAUHBRUSH__@@PAVCDC@@PAVCWnd@@I@Z PROC ; CDlgOptimizer::OnCtlColor, COMDAT
; _this$ = ecx

; 364  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 365  : 	HBRUSH hbr = CDialog::OnCtlColor(pDC, pWnd, nCtlColor);

  00004	8b 5d 08	 mov	 ebx, DWORD PTR _pDC$[ebp]
  00007	56		 push	 esi
  00008	8b 75 10	 mov	 esi, DWORD PTR _nCtlColor$[ebp]
  0000b	57		 push	 edi
  0000c	56		 push	 esi
  0000d	ff 75 0c	 push	 DWORD PTR _pWnd$[ebp]
  00010	8b f9		 mov	 edi, ecx
  00012	53		 push	 ebx
  00013	e8 00 00 00 00	 call	 ?OnCtlColor@CWnd@@IAEPAUHBRUSH__@@PAVCDC@@PAV1@I@Z ; CWnd::OnCtlColor

; 366  : 	
; 367  : 	// TODO: Change any attributes of the DC here
; 368  : 	switch(nCtlColor) 

  00018	83 ee 01	 sub	 esi, 1
  0001b	74 26		 je	 SHORT $LN1@OnCtlColor
  0001d	83 ee 01	 sub	 esi, 1
  00020	74 21		 je	 SHORT $LN1@OnCtlColor

; 369  : 	{
; 370  : 	case CTLCOLOR_EDIT:
; 371  : 	case CTLCOLOR_LISTBOX:
; 372  : 		return hbr;
; 373  : 		break;
; 374  : 	default:
; 375  : 		pDC->SetBkColor(m_crBk);

  00022	8b 03		 mov	 eax, DWORD PTR [ebx]
  00024	8b cb		 mov	 ecx, ebx
  00026	ff b7 58 05 00
	00		 push	 DWORD PTR [edi+1368]
  0002c	ff 50 34	 call	 DWORD PTR [eax+52]

; 376  : 		return m_brBkColor;		

  0002f	8d 87 50 05 00
	00		 lea	 eax, DWORD PTR [edi+1360]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin1.inl

; 124  : 	{ return (HBRUSH)(this == NULL ? NULL : m_hObject); }

  00035	85 c0		 test	 eax, eax
  00037	75 07		 jne	 SHORT $LN10@OnCtlColor
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 381  : }

  00039	5f		 pop	 edi
  0003a	5e		 pop	 esi
  0003b	5b		 pop	 ebx
  0003c	5d		 pop	 ebp
  0003d	c2 0c 00	 ret	 12			; 0000000cH
$LN10@OnCtlColor:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin1.inl

; 124  : 	{ return (HBRUSH)(this == NULL ? NULL : m_hObject); }

  00040	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
$LN1@OnCtlColor:
  00043	5f		 pop	 edi
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 381  : }

  00044	5e		 pop	 esi
  00045	5b		 pop	 ebx
  00046	5d		 pop	 ebp
  00047	c2 0c 00	 ret	 12			; 0000000cH
?OnCtlColor@CDlgOptimizer@@IAEPAUHBRUSH__@@PAVCDC@@PAVCWnd@@I@Z ENDP ; CDlgOptimizer::OnCtlColor
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin1.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin1.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin1.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin1.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin1.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\GridCtrl_src\GridCtrl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin1.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
;	COMDAT ?OnInitDialog@CDlgOptimizer@@MAEHXZ
_TEXT	SEGMENT
_lf$ = -92						; size = 60
_rect1$2 = -32						; size = 16
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?OnInitDialog@CDlgOptimizer@@MAEHXZ PROC		; CDlgOptimizer::OnInitDialog, COMDAT
; _this$ = ecx

; 130  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?OnInitDialog@CDlgOptimizer@@MAEHXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b f1		 mov	 esi, ecx

; 131  : 	CDialog::OnInitDialog();

  0002d	e8 00 00 00 00	 call	 ?OnInitDialog@CDialog@@UAEHXZ ; CDialog::OnInitDialog

; 132  : 
; 133  : 	AfxEnableControlContainer();

  00032	6a 00		 push	 0
  00034	e8 00 00 00 00	 call	 ?AfxEnableControlContainer@@YAXPAVCOccManager@@@Z ; AfxEnableControlContainer
  00039	83 c4 04	 add	 esp, 4

; 134  : 
; 135  : 	// TODO: Add extra initialization here
; 136  : 	
; 137  : 	//IKSLibManager* pKSLibMng = (IKSLibManager*)AfxGetPctrInterface(UUID_IKSLibManager);
; 138  : 	//if(pKSLibMng)
; 139  : 	//	m_crBk = pKSLibMng->Lib_KSLink_GetColor(1);	//  
; 140  : 	//else
; 141  : 	m_crBk = DEFAULT_BKGRND_COLOR;

  0003c	c7 86 58 05 00
	00 f7 f8 fc 00	 mov	 DWORD PTR [esi+1368], 16578807 ; 00fcf8f7H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin1.inl

; 132  : 	{ return Attach(::CreateSolidBrush(crColor)); }

  00046	68 f7 f8 fc 00	 push	 16578807		; 00fcf8f7H
  0004b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateSolidBrush@4
  00051	50		 push	 eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 143  : 	m_brBkColor.CreateSolidBrush(m_crBk);

  00052	8d 8e 50 05 00
	00		 lea	 ecx, DWORD PTR [esi+1360]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin1.inl

; 132  : 	{ return Attach(::CreateSolidBrush(crColor)); }

  00058	e8 00 00 00 00	 call	 ?Attach@CGdiObject@@QAEHPAX@Z ; CGdiObject::Attach
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 162  : 	strcpy(lf.lfFaceName, "");

  0005d	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_C@_06MFMMLLPC@?$LB?$LM?$LI?$LC?C?$LM@

; 164  : 	m_Font.CreateFontIndirect(&lf);

  00062	8d 9e f0 12 00
	00		 lea	 ebx, DWORD PTR [esi+4848]
  00068	89 45 c0	 mov	 DWORD PTR _lf$[ebp+28], eax
  0006b	0f 57 c0	 xorps	 xmm0, xmm0
  0006e	66 a1 04 00 00
	00		 mov	 ax, WORD PTR ??_C@_06MFMMLLPC@?$LB?$LM?$LI?$LC?C?$LM@+4
  00074	66 89 45 c4	 mov	 WORD PTR _lf$[ebp+32], ax
  00078	a0 06 00 00 00	 mov	 al, BYTE PTR ??_C@_06MFMMLLPC@?$LB?$LM?$LI?$LC?C?$LM@+6
  0007d	88 45 c6	 mov	 BYTE PTR _lf$[ebp+34], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin1.inl

; 157  : 	{ return Attach(::CreateFontIndirect(lpLogFont)); }

  00080	8d 45 a4	 lea	 eax, DWORD PTR _lf$[ebp]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 149  : 	::memset(&lf, 0x00, sizeof(LOGFONT));

  00083	66 0f 13 45 c7	 movlpd	 QWORD PTR _lf$[ebp+35], xmm0
  00088	66 0f 13 45 cf	 movlpd	 QWORD PTR _lf$[ebp+43], xmm0
  0008d	66 0f 13 45 d7	 movlpd	 QWORD PTR _lf$[ebp+51], xmm0

; 150  : 	lf.lfWidth = 0; 

  00092	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@00000190000000000000000000000000
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin1.inl

; 157  : 	{ return Attach(::CreateFontIndirect(lpLogFont)); }

  00099	50		 push	 eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 149  : 	::memset(&lf, 0x00, sizeof(LOGFONT));

  0009a	c6 45 df 00	 mov	 BYTE PTR _lf$[ebp+59], 0

; 150  : 	lf.lfWidth = 0; 

  0009e	0f 11 45 a8	 movups	 XMMWORD PTR _lf$[ebp+4], xmm0

; 151  : 	lf.lfEscapement = 0; 
; 152  : 	lf.lfOrientation = 0; 
; 153  : 	lf.lfWeight = FW_NORMAL; 
; 154  : 	lf.lfItalic = 0; 

  000a2	c7 45 b8 00 00
	00 01		 mov	 DWORD PTR _lf$[ebp+20], 16777216 ; 01000000H

; 155  : 	lf.lfUnderline = 0; 
; 156  : 	lf.lfStrikeOut = 0; 
; 157  : 	lf.lfCharSet = DEFAULT_CHARSET; 
; 158  : 	lf.lfOutPrecision = OUT_DEFAULT_PRECIS; 

  000a9	c7 45 bc 00 00
	00 10		 mov	 DWORD PTR _lf$[ebp+24], 268435456 ; 10000000H

; 163  : 	lf.lfHeight = 12;

  000b0	c7 45 a4 0c 00
	00 00		 mov	 DWORD PTR _lf$[ebp], 12	; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin1.inl

; 157  : 	{ return Attach(::CreateFontIndirect(lpLogFont)); }

  000b7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFontIndirectA@4
  000bd	50		 push	 eax
  000be	8b cb		 mov	 ecx, ebx
  000c0	e8 00 00 00 00	 call	 ?Attach@CGdiObject@@QAEHPAX@Z ; CGdiObject::Attach
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 167  : 	InitTab();

  000c5	8b ce		 mov	 ecx, esi
  000c7	e8 00 00 00 00	 call	 ?InitTab@CDlgOptimizer@@QAEXXZ ; CDlgOptimizer::InitTab

; 399  : 	if(!m_GridTap.GetSafeHwnd())

  000cc	8d be f0 09 00
	00		 lea	 edi, DWORD PTR [esi+2544]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl

; 25   : 	{ return this == NULL ? NULL : m_hWnd; }

  000d2	85 ff		 test	 edi, edi
  000d4	74 0a		 je	 SHORT $LN93@OnInitDial
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 399  : 	if(!m_GridTap.GetSafeHwnd())

  000d6	83 7f 20 00	 cmp	 DWORD PTR [edi+32], 0
  000da	0f 85 3c 01 00
	00		 jne	 $LN8@OnInitDial
$LN93@OnInitDial:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h

; 698  : 	::InflateRect(this, -x, -y);

  000e0	6a ec		 push	 -20			; ffffffecH
  000e2	6a 00		 push	 0
  000e4	8d 45 e0	 lea	 eax, DWORD PTR _rect1$2[ebp]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 402  : 		rect1.left = 193;

  000e7	c7 45 e0 c1 00
	00 00		 mov	 DWORD PTR _rect1$2[ebp], 193 ; 000000c1H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h

; 698  : 	::InflateRect(this, -x, -y);

  000ee	50		 push	 eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 403  : 		rect1.right = 860;

  000ef	c7 45 e8 5c 03
	00 00		 mov	 DWORD PTR _rect1$2[ebp+8], 860 ; 0000035cH

; 404  : 		rect1.bottom = 195;

  000f6	c7 45 ec c3 00
	00 00		 mov	 DWORD PTR _rect1$2[ebp+12], 195 ; 000000c3H

; 405  : 		rect1.top = -20;

  000fd	c7 45 e4 ec ff
	ff ff		 mov	 DWORD PTR _rect1$2[ebp+4], -20 ; ffffffecH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atltypes.h

; 698  : 	::InflateRect(this, -x, -y);

  00104	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InflateRect@12
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 408  : 		m_GridTap.Create(rect1,this,IDC_GRID2,WS_CHILD | WS_TABSTOP | WS_VISIBLE   );

  0010a	68 00 00 01 50	 push	 1342242816		; 50010000H
  0010f	68 11 01 00 00	 push	 273			; 00000111H
  00114	56		 push	 esi
  00115	8d 45 e0	 lea	 eax, DWORD PTR _rect1$2[ebp]
  00118	8b cf		 mov	 ecx, edi
  0011a	50		 push	 eax
  0011b	e8 00 00 00 00	 call	 ?Create@CGridCtrl@@QAEHABUtagRECT@@PAVCWnd@@IK@Z ; CGridCtrl::Create

; 410  : 		m_GridTap.GetDefaultCell(FALSE, FALSE)->SetBackClr(RGB(0xFF, 0xFF, 0xE0));

  00120	8b 86 4c 0b 00
	00		 mov	 eax, DWORD PTR [esi+2892]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\GridCtrl_src\GridCtrl.h

; 795  :     return (CGridCellBase*) &m_cellDefault;

  00126	8d 8e 4c 0b 00
	00		 lea	 ecx, DWORD PTR [esi+2892]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 410  : 		m_GridTap.GetDefaultCell(FALSE, FALSE)->SetBackClr(RGB(0xFF, 0xFF, 0xE0));

  0012c	68 ff ff e0 00	 push	 14745599		; 00e0ffffH
  00131	ff 50 2c	 call	 DWORD PTR [eax+44]

; 411  : 		
; 412  : 		m_GridTap.SetGridLineColor(RGB(204,204,204));
; 413  : 		if(m_nOptimizerDiv == INDEX_OPTIMIZER)

  00134	8b 86 70 11 00
	00		 mov	 eax, DWORD PTR [esi+4464]
  0013a	c7 86 7c 0a 00
	00 cc cc cc 00	 mov	 DWORD PTR [esi+2684], 13421772 ; 00ccccccH
  00144	3d e9 03 00 00	 cmp	 eax, 1001		; 000003e9H
  00149	75 0f		 jne	 SHORT $LN9@OnInitDial

; 414  : 			m_GridTap.SetColumnCount(12);

  0014b	6a 0c		 push	 12			; 0000000cH
  0014d	8b cf		 mov	 ecx, edi
  0014f	e8 00 00 00 00	 call	 ?SetColumnCount@CGridCtrl@@QAEHH@Z ; CGridCtrl::SetColumnCount
  00154	8b 86 70 11 00
	00		 mov	 eax, DWORD PTR [esi+4464]
$LN9@OnInitDial:

; 415  : 		if(m_nOptimizerDiv == TIME_OPTIMIZER)

  0015a	3d eb 03 00 00	 cmp	 eax, 1003		; 000003ebH
  0015f	75 0f		 jne	 SHORT $LN10@OnInitDial

; 416  : 			m_GridTap.SetColumnCount(8);

  00161	6a 08		 push	 8
  00163	8b cf		 mov	 ecx, edi
  00165	e8 00 00 00 00	 call	 ?SetColumnCount@CGridCtrl@@QAEHH@Z ; CGridCtrl::SetColumnCount
  0016a	8b 86 70 11 00
	00		 mov	 eax, DWORD PTR [esi+4464]
$LN10@OnInitDial:

; 417  : 		if(m_nOptimizerDiv == VAL_OPTIMIZER)

  00170	3d ea 03 00 00	 cmp	 eax, 1002		; 000003eaH
  00175	75 09		 jne	 SHORT $LN11@OnInitDial

; 418  : 			m_GridTap.SetColumnCount(6);

  00177	6a 06		 push	 6
  00179	8b cf		 mov	 ecx, edi
  0017b	e8 00 00 00 00	 call	 ?SetColumnCount@CGridCtrl@@QAEHH@Z ; CGridCtrl::SetColumnCount
$LN11@OnInitDial:

; 419  : 		m_GridTap.SetFixedRowCount(1);

  00180	6a 01		 push	 1
  00182	8b cf		 mov	 ecx, edi
  00184	e8 00 00 00 00	 call	 ?SetFixedRowCount@CGridCtrl@@QAEHH@Z ; CGridCtrl::SetFixedRowCount

; 420  : 		m_GridTap.SetColumnResize(TRUE);
; 421  : 		m_GridTap.SetRowCount(1);

  00189	6a 01		 push	 1
  0018b	8b cf		 mov	 ecx, edi
  0018d	c7 86 e8 0c 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+3304], 1
  00197	e8 00 00 00 00	 call	 ?SetRowCount@CGridCtrl@@QAEHH@Z ; CGridCtrl::SetRowCount

; 422  : 		m_GridTap.SetListMode();

  0019c	6a 01		 push	 1
  0019e	8b cf		 mov	 ecx, edi
  001a0	e8 00 00 00 00	 call	 ?SetListMode@CGridCtrl@@QAEXH@Z ; CGridCtrl::SetListMode

; 423  : 		m_GridTap.SetRowHeight(0,20);

  001a5	6a 14		 push	 20			; 00000014H
  001a7	6a 00		 push	 0
  001a9	8b cf		 mov	 ecx, edi
  001ab	e8 00 00 00 00	 call	 ?SetRowHeight@CGridCtrl@@QAEHHH@Z ; CGridCtrl::SetRowHeight

; 424  : 		m_GridTap.SetBkColor(RGB(255,255,255));		

  001b0	c7 86 78 0a 00
	00 ff ff ff 00	 mov	 DWORD PTR [esi+2680], 16777215 ; 00ffffffH

; 425  : 		m_GridTap.SetEditable(FALSE);

  001ba	c7 86 a8 0a 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+2728], 0

; 426  : 		m_GridTap.EnableTitleTips(FALSE);

  001c4	c7 86 dc 0a 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+2780], 0

; 427  : 		m_GridTap.SetTrackFocusCell(FALSE);

  001ce	c7 86 fc 0a 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+2812], 0

; 428  : 		m_GridTap.SetSingleColSelection(FALSE);

  001d8	c7 86 bc 0a 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+2748], 0

; 429  : 		m_GridTap.SetSingleRowSelection();

  001e2	c7 86 b8 0a 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+2744], 1

; 430  : 		m_GridTap.SetFixedRowSelection(FALSE);

  001ec	c7 86 c8 0a 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+2760], 0

; 431  : 		m_GridTap.SetFixedColumnSelection(FALSE);

  001f6	c7 86 cc 0a 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+2764], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin1.inl

; 68   : 	{ return this == NULL ? NULL : m_hObject; }

  00200	85 db		 test	 ebx, ebx
  00202	75 04		 jne	 SHORT $LN30@OnInitDial
  00204	33 c0		 xor	 eax, eax
  00206	eb 03		 jmp	 SHORT $LN31@OnInitDial
$LN30@OnInitDial:
  00208	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
$LN31@OnInitDial:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl

; 43   : 	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, WM_SETFONT, (WPARAM)pFont->GetSafeHandle(), bRedraw); }

  0020b	6a 01		 push	 1
  0020d	50		 push	 eax
  0020e	6a 30		 push	 48			; 00000030H
  00210	ff b6 10 0a 00
	00		 push	 DWORD PTR [esi+2576]
  00216	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16
$LN8@OnInitDial:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 169  : 	ReSize();

  0021c	8b ce		 mov	 ecx, esi
  0021e	e8 00 00 00 00	 call	 ?ReSize@CDlgOptimizer@@QAEXXZ ; CDlgOptimizer::ReSize

; 170  : 	InitControls();
; 171  : 	LoadOutlookBar();//KHD : OutlookBar

  00223	8b ce		 mov	 ecx, esi
  00225	e8 00 00 00 00	 call	 ?LoadOutlookBar@CDlgOptimizer@@QAEXXZ ; CDlgOptimizer::LoadOutlookBar

; 172  : 	InitStrategy();
; 173  : 	InitSkin();
; 174  : 	CreateTImeSetupDlg();

  0022a	8b ce		 mov	 ecx, esi
  0022c	e8 00 00 00 00	 call	 ?CreateTImeSetupDlg@CDlgOptimizer@@QAEXXZ ; CDlgOptimizer::CreateTImeSetupDlg

; 175  : 	
; 176  : 
; 177  : 	
; 178  : 	return TRUE;  // return TRUE unless you set the focus to a control

  00231	b8 01 00 00 00	 mov	 eax, 1

; 179  : 	              // EXCEPTION: OCX Property Pages should return FALSE
; 180  : }

  00236	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00239	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00240	59		 pop	 ecx
  00241	5f		 pop	 edi
  00242	5e		 pop	 esi
  00243	5b		 pop	 ebx
  00244	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00247	33 cd		 xor	 ecx, ebp
  00249	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0024e	8b e5		 mov	 esp, ebp
  00250	5d		 pop	 ebp
  00251	c3		 ret	 0
  00252	cc		 int	 3
  00253	cc		 int	 3
  00254	cc		 int	 3
  00255	cc		 int	 3
  00256	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?OnInitDialog@CDlgOptimizer@@MAEHXZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00016	33 c8		 xor	 ecx, eax
  00018	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?OnInitDialog@CDlgOptimizer@@MAEHXZ
  00022	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?OnInitDialog@CDlgOptimizer@@MAEHXZ ENDP		; CDlgOptimizer::OnInitDialog
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
;	COMDAT ?OnNotify@CDlgOptimizer@@MAEHIJPAJ@Z
_TEXT	SEGMENT
$T2 = -36						; size = 4
$T3 = -36						; size = 4
$T4 = -36						; size = 4
$T5 = -32						; size = 4
$T6 = -32						; size = 4
$T7 = -32						; size = 4
_pItemInfo$1$ = -28					; size = 4
_nListCount$1$ = -24					; size = 4
$T8 = -24						; size = 4
$T9 = -20						; size = 4
_stSTName$10 = -16					; size = 4
__$EHRec$ = -12						; size = 12
_wParam$ = 8						; size = 4
_stSendVal$11 = 12					; size = 4
_szSTPath$12 = 12					; size = 4
_lParam$ = 12						; size = 4
_pResult$ = 16						; size = 4
?OnNotify@CDlgOptimizer@@MAEHIJPAJ@Z PROC		; CDlgOptimizer::OnNotify, COMDAT
; _this$ = ecx

; 1527 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?OnNotify@CDlgOptimizer@@MAEHIJPAJ@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 18	 sub	 esp, 24			; 00000018H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b f9		 mov	 edi, ecx

; 1528 : 	// TODO: Add your specialized code here and/or call the base class
; 1529 : 	//Grid     SendMessage    
; 1530 : 	//  .
; 1531 : 	
; 1532 : 	NM_GRIDVIEW *pNmgv = (NM_GRIDVIEW *)lParam;
; 1533 : 	//Grid    .
; 1534 : 	if(wParam==IDC_GRID2)

  0002a	81 7d 08 11 01
	00 00		 cmp	 DWORD PTR _wParam$[ebp], 273 ; 00000111H
  00031	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR $T5[ebp], 0
  00038	8b 5d 0c	 mov	 ebx, DWORD PTR _lParam$[ebp]
  0003b	0f 85 8a 03 00
	00		 jne	 $LN12@OnNotify

; 1535 : 	{
; 1536 : 		if(pNmgv->hdr.code==NM_CLICK)

  00041	83 7b 08 fe	 cmp	 DWORD PTR [ebx+8], -2	; fffffffeH
  00045	0f 85 80 03 00
	00		 jne	 $LN12@OnNotify

; 1537 : 		{
; 1538 : 			if(pNmgv->iRow < 0)

  0004b	83 7b 0c 00	 cmp	 DWORD PTR [ebx+12], 0
  0004f	7d 0e		 jge	 SHORT $LN7@OnNotify

; 1539 : 				return CDialog::OnNotify(wParam, lParam, pResult);

  00051	ff 75 10	 push	 DWORD PTR _pResult$[ebp]
  00054	53		 push	 ebx
  00055	68 11 01 00 00	 push	 273			; 00000111H
  0005a	e9 75 03 00 00	 jmp	 $LN90@OnNotify
$LN7@OnNotify:

; 1540 : 			
; 1541 : 			m_bGridClick = TRUE;
; 1542 : 			if(pNmgv->iRow ==0)

  0005f	8b 87 70 11 00
	00		 mov	 eax, DWORD PTR [edi+4464]
  00065	c7 87 8c 11 00
	00 01 00 00 00	 mov	 DWORD PTR [edi+4492], 1
  0006f	83 7b 0c 00	 cmp	 DWORD PTR [ebx+12], 0
  00073	75 55		 jne	 SHORT $LN8@OnNotify

; 1543 : 			{
; 1544 : 				//m_GridTap.SetSortColumn(pNmgv->iColumn);
; 1545 : 				if(m_nOptimizerDiv == INDEX_OPTIMIZER && pNmgv->iColumn==1 )

  00075	3d e9 03 00 00	 cmp	 eax, 1001		; 000003e9H
  0007a	75 12		 jne	 SHORT $LN87@OnNotify
  0007c	83 7b 10 01	 cmp	 DWORD PTR [ebx+16], 1
  00080	75 0c		 jne	 SHORT $LN87@OnNotify

; 1546 : 					m_GridTap.SortItems(m_GridTap.pfnCellTextCompare,pNmgv->iColumn,!m_GridTap.GetSortAscending());

  00082	b9 00 00 00 00	 mov	 ecx, OFFSET ?pfnCellTextCompare@CGridCtrl@@SGHJJJ@Z ; CGridCtrl::pfnCellTextCompare
  00087	ba 01 00 00 00	 mov	 edx, 1
  0008c	eb 08		 jmp	 SHORT $LN91@OnNotify
$LN87@OnNotify:

; 1547 : 				else
; 1548 : 					m_GridTap.SortItems(m_GridTap.pfnCellNumericCompare,pNmgv->iColumn,!m_GridTap.GetSortAscending());

  0008e	8b 53 10	 mov	 edx, DWORD PTR [ebx+16]
  00091	b9 00 00 00 00	 mov	 ecx, OFFSET ?pfnCellNumericCompare@CGridCtrl@@SGHJJJ@Z ; CGridCtrl::pfnCellNumericCompare
$LN91@OnNotify:

; 1549 : 				m_GridTap.Refresh();

  00096	33 c0		 xor	 eax, eax
  00098	39 87 50 0e 00
	00		 cmp	 DWORD PTR [edi+3664], eax
  0009e	6a 00		 push	 0
  000a0	0f 94 c0	 sete	 al
  000a3	50		 push	 eax
  000a4	52		 push	 edx
  000a5	51		 push	 ecx
  000a6	8d 8f f0 09 00
	00		 lea	 ecx, DWORD PTR [edi+2544]
  000ac	e8 00 00 00 00	 call	 ?SortItems@CGridCtrl@@QAEHP6GHJJJ@ZHHJ@Z ; CGridCtrl::SortItems
  000b1	8d 8f f0 09 00
	00		 lea	 ecx, DWORD PTR [edi+2544]
  000b7	e8 00 00 00 00	 call	 ?Refresh@CGridCtrl@@QAEXXZ ; CGridCtrl::Refresh

; 1550 : 				return CDialog::OnNotify(wParam, lParam, pResult);

  000bc	ff 75 10	 push	 DWORD PTR _pResult$[ebp]
  000bf	53		 push	 ebx
  000c0	68 11 01 00 00	 push	 273			; 00000111H
  000c5	e9 08 03 00 00	 jmp	 $LN92@OnNotify
$LN8@OnNotify:

; 1551 : 			}
; 1552 : 			if(m_nOptimizerDiv!=VAL_OPTIMIZER)

  000ca	3d ea 03 00 00	 cmp	 eax, 1002		; 000003eaH
  000cf	0f 84 6e 02 00
	00		 je	 $LN11@OnNotify

; 1553 : 			{
; 1554 : 				CString stSTName;

  000d5	8d 4d f0	 lea	 ecx, DWORD PTR _stSTName$10[ebp]
  000d8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 1555 : 				stSTName = m_GridTap.GetItemText(pNmgv->iRow,1);// . 

  000de	6a 01		 push	 1
  000e0	ff 73 0c	 push	 DWORD PTR [ebx+12]
  000e3	8d 45 e0	 lea	 eax, DWORD PTR $T7[ebp]
  000e6	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  000ed	50		 push	 eax
  000ee	8d 8f f0 09 00
	00		 lea	 ecx, DWORD PTR [edi+2544]
  000f4	e8 00 00 00 00	 call	 ?GetItemText@CGridCtrl@@QBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HH@Z ; CGridCtrl::GetItemText
  000f9	50		 push	 eax
  000fa	8d 4d f0	 lea	 ecx, DWORD PTR _stSTName$10[ebp]
  000fd	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00101	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
  00107	8d 4d e0	 lea	 ecx, DWORD PTR $T7[ebp]
  0010a	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0010e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h

; 2486 : 		return(str1.Compare(psz2) == 0);

  00114	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@@
  00119	8d 4d f0	 lea	 ecx, DWORD PTR _stSTName$10[ebp]
  0011c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Compare@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEHPBD@Z
  00122	85 c0		 test	 eax, eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 1556 : 				if(stSTName=="") return CDialog::OnNotify(wParam, lParam, pResult);

  00124	75 31		 jne	 SHORT $LN13@OnNotify
  00126	ff 75 10	 push	 DWORD PTR _pResult$[ebp]
  00129	8b cf		 mov	 ecx, edi
  0012b	53		 push	 ebx
  0012c	68 11 01 00 00	 push	 273			; 00000111H
  00131	e8 00 00 00 00	 call	 ?OnNotify@CWnd@@MAEHIJPAJ@Z ; CWnd::OnNotify
  00136	8d 4d f0	 lea	 ecx, DWORD PTR _stSTName$10[ebp]
  00139	8b f0		 mov	 esi, eax
  0013b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00141	8b c6		 mov	 eax, esi

; 1599 : }

  00143	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00146	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0014d	59		 pop	 ecx
  0014e	5f		 pop	 edi
  0014f	5e		 pop	 esi
  00150	5b		 pop	 ebx
  00151	8b e5		 mov	 esp, ebp
  00153	5d		 pop	 ebp
  00154	c2 0c 00	 ret	 12			; 0000000cH
$LN13@OnNotify:

; 1557 : 				CString szSTPath;

  00157	8d 4d 0c	 lea	 ecx, DWORD PTR _szSTPath$12[ebp]
  0015a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 1558 : 				int nListCount = m_listST.GetCount();

  00160	8d 8f f0 10 00
	00		 lea	 ecx, DWORD PTR [edi+4336]
  00166	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  0016a	e8 00 00 00 00	 call	 ?GetCount@CListBox@@QBEHXZ ; CListBox::GetCount

; 1559 : 				STMNG_ITEMINFO* pItemInfo = NULL;
; 1560 : 				for(int nIndx = 0; nIndx < nListCount; ++nIndx)

  0016f	33 f6		 xor	 esi, esi
  00171	89 45 e8	 mov	 DWORD PTR _nListCount$1$[ebp], eax
  00174	85 c0		 test	 eax, eax
  00176	0f 8e 36 01 00
	00		 jle	 $LN88@OnNotify
  0017c	0f 1f 40 00	 npad	 4
$LL4@OnNotify:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl

; 683  : 	{ ASSERT(::IsWindow(m_hWnd)); return ::SendMessage(m_hWnd, LB_GETITEMDATA, nIndex, 0); }

  00180	6a 00		 push	 0
  00182	56		 push	 esi
  00183	68 99 01 00 00	 push	 409			; 00000199H
  00188	ff b7 10 11 00
	00		 push	 DWORD PTR [edi+4368]
  0018e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 1562 : 					if(pItemInfo = (STMNG_ITEMINFO*)m_listST.GetItemData(nIndx))

  00194	89 45 e4	 mov	 DWORD PTR _pItemInfo$1$[ebp], eax
  00197	85 c0		 test	 eax, eax
  00199	74 58		 je	 SHORT $LN2@OnNotify

; 1563 : 					{	
; 1564 : 						szSTPath = pItemInfo->szSTName;

  0019b	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  0019e	51		 push	 ecx
  0019f	8d 4d 0c	 lea	 ecx, DWORD PTR _szSTPath$12[ebp]
  001a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z

; 1565 : 						int nEndPos = -1;
; 1566 : 						if((nEndPos = szSTPath.Find(gSTGubunKey)) != -1)

  001a8	6a 00		 push	 0
  001aa	6a 5e		 push	 94			; 0000005eH
  001ac	8d 4d 0c	 lea	 ecx, DWORD PTR _szSTPath$12[ebp]
  001af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Find@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEHDH@Z
  001b5	83 f8 ff	 cmp	 eax, -1
  001b8	74 29		 je	 SHORT $LN15@OnNotify

; 1567 : 							szSTPath = szSTPath.Left(nEndPos);

  001ba	50		 push	 eax
  001bb	8d 45 e0	 lea	 eax, DWORD PTR $T6[ebp]
  001be	50		 push	 eax
  001bf	8d 4d 0c	 lea	 ecx, DWORD PTR _szSTPath$12[ebp]
  001c2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Left@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBE?AV12@H@Z
  001c8	50		 push	 eax
  001c9	8d 4d 0c	 lea	 ecx, DWORD PTR _szSTPath$12[ebp]
  001cc	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  001d0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
  001d6	8d 4d e0	 lea	 ecx, DWORD PTR $T6[ebp]
  001d9	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  001dd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$LN15@OnNotify:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h

; 2479 : 		return(str1.Compare(str2) == 0);

  001e3	ff 75 f0	 push	 DWORD PTR _stSTName$10[ebp]
  001e6	8d 4d 0c	 lea	 ecx, DWORD PTR _szSTPath$12[ebp]
  001e9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Compare@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEHPBD@Z
  001ef	85 c0		 test	 eax, eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 1568 : 						if(szSTPath == stSTName)

  001f1	74 0b		 je	 SHORT $LN82@OnNotify
$LN2@OnNotify:

; 1559 : 				STMNG_ITEMINFO* pItemInfo = NULL;
; 1560 : 				for(int nIndx = 0; nIndx < nListCount; ++nIndx)

  001f3	46		 inc	 esi
  001f4	3b 75 e8	 cmp	 esi, DWORD PTR _nListCount$1$[ebp]
  001f7	7c 87		 jl	 SHORT $LL4@OnNotify
  001f9	e9 b4 00 00 00	 jmp	 $LN88@OnNotify
$LN82@OnNotify:

; 1570 : 							szSTPath	= pItemInfo->szSTPath +"\\"+ pItemInfo->szSTName + ".st";

  001fe	8b 75 e4	 mov	 esi, DWORD PTR _pItemInfo$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h

; 2401 : 		CStringT strResult( str1.GetManager() );

  00201	8d 4e 08	 lea	 ecx, DWORD PTR [esi+8]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 1570 : 							szSTPath	= pItemInfo->szSTPath +"\\"+ pItemInfo->szSTName + ".st";

  00204	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h

; 2401 : 		CStringT strResult( str1.GetManager() );

  00208	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetManager@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEPAUIAtlStringMgr@2@XZ
  0020e	50		 push	 eax
  0020f	8d 4d e8	 lea	 ecx, DWORD PTR $T8[ebp]
  00212	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PAUIAtlStringMgr@1@@Z
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h

; 519  : 		return( GetData()->nDataLength );

  00218	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h

; 2403 : 		CThisSimpleString::Concatenate( strResult, str1, str1.GetLength(), psz2, CThisSimpleString::StringLength( psz2 ) );

  0021b	6a 01		 push	 1
  0021d	68 00 00 00 00	 push	 OFFSET ??_C@_01KICIPPFI@?2@

; 2404 : 
; 2405 : 		return( strResult );

  00222	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR $T5[ebp], 1
  00229	ff 70 f4	 push	 DWORD PTR [eax-12]
  0022c	50		 push	 eax
  0022d	8d 45 e8	 lea	 eax, DWORD PTR $T8[ebp]
  00230	50		 push	 eax
  00231	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Concatenate@?$CSimpleStringT@D$00@ATL@@KAXAAV12@PBDH1H@Z
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 1570 : 							szSTPath	= pItemInfo->szSTPath +"\\"+ pItemInfo->szSTName + ".st";

  00237	8b c6		 mov	 eax, esi
  00239	83 c0 04	 add	 eax, 4
  0023c	50		 push	 eax
  0023d	8d 45 e8	 lea	 eax, DWORD PTR $T8[ebp]
  00240	50		 push	 eax
  00241	8d 45 dc	 lea	 eax, DWORD PTR $T4[ebp]
  00244	50		 push	 eax
  00245	e8 00 00 00 00	 call	 ??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@ABV10@0@Z ; ATL::operator+
  0024a	83 c4 20	 add	 esp, 32			; 00000020H
  0024d	8b f0		 mov	 esi, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h

; 2401 : 		CStringT strResult( str1.GetManager() );

  0024f	8b ce		 mov	 ecx, esi
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 1570 : 							szSTPath	= pItemInfo->szSTPath +"\\"+ pItemInfo->szSTName + ".st";

  00251	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h

; 2401 : 		CStringT strResult( str1.GetManager() );

  00255	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetManager@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEPAUIAtlStringMgr@2@XZ
  0025b	50		 push	 eax
  0025c	8d 4d ec	 lea	 ecx, DWORD PTR $T9[ebp]
  0025f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PAUIAtlStringMgr@1@@Z
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h

; 519  : 		return( GetData()->nDataLength );

  00265	8b 06		 mov	 eax, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h

; 2403 : 		CThisSimpleString::Concatenate( strResult, str1, str1.GetLength(), psz2, CThisSimpleString::StringLength( psz2 ) );

  00267	6a 03		 push	 3
  00269	68 00 00 00 00	 push	 OFFSET ??_C@_03IDLCJCBF@?4st@

; 2404 : 
; 2405 : 		return( strResult );

  0026e	c7 45 e0 03 00
	00 00		 mov	 DWORD PTR $T5[ebp], 3
  00275	ff 70 f4	 push	 DWORD PTR [eax-12]
  00278	50		 push	 eax
  00279	8d 45 ec	 lea	 eax, DWORD PTR $T9[ebp]
  0027c	50		 push	 eax
  0027d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Concatenate@?$CSimpleStringT@D$00@ATL@@KAXAAV12@PBDH1H@Z
  00283	83 c4 14	 add	 esp, 20			; 00000014H
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 1570 : 							szSTPath	= pItemInfo->szSTPath +"\\"+ pItemInfo->szSTName + ".st";

  00286	8d 45 ec	 lea	 eax, DWORD PTR $T9[ebp]
  00289	8d 4d 0c	 lea	 ecx, DWORD PTR _szSTPath$12[ebp]
  0028c	50		 push	 eax
  0028d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
  00293	8d 4d ec	 lea	 ecx, DWORD PTR $T9[ebp]
  00296	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0029c	8d 4d dc	 lea	 ecx, DWORD PTR $T4[ebp]
  0029f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  002a5	8d 4d e8	 lea	 ecx, DWORD PTR $T8[ebp]
  002a8	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  002ac	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$LN88@OnNotify:

; 1571 : 							
; 1572 : 							break;
; 1573 : 						}
; 1574 : 					}
; 1575 : 				}
; 1576 : 				if(m_nOptimizerDiv == TIME_OPTIMIZER)// .

  002b2	81 bf 70 11 00
	00 eb 03 00 00	 cmp	 DWORD PTR [edi+4464], 1003 ; 000003ebH
  002bc	75 46		 jne	 SHORT $LN17@OnNotify

; 1578 : 					m_pStrategyItem->SetTimeBong(atoi(m_GridTap.GetItemText(pNmgv->iRow,2)));

  002be	6a 02		 push	 2
  002c0	ff 73 0c	 push	 DWORD PTR [ebx+12]
  002c3	8d 45 dc	 lea	 eax, DWORD PTR $T3[ebp]
  002c6	50		 push	 eax
  002c7	8d 8f f0 09 00
	00		 lea	 ecx, DWORD PTR [edi+2544]
  002cd	e8 00 00 00 00	 call	 ?GetItemText@CGridCtrl@@QBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HH@Z ; CGridCtrl::GetItemText
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h

; 377  : 		return( m_pszData );

  002d2	8b 08		 mov	 ecx, DWORD PTR [eax]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 1578 : 					m_pStrategyItem->SetTimeBong(atoi(m_GridTap.GetItemText(pNmgv->iRow,2)));

  002d4	8b 87 10 05 00
	00		 mov	 eax, DWORD PTR [edi+1296]
  002da	51		 push	 ecx
  002db	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
  002df	8b 30		 mov	 esi, DWORD PTR [eax]
  002e1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  002e7	8b 8f 10 05 00
	00		 mov	 ecx, DWORD PTR [edi+1296]
  002ed	83 c4 04	 add	 esp, 4
  002f0	50		 push	 eax
  002f1	ff 96 84 00 00
	00		 call	 DWORD PTR [esi+132]
  002f7	8d 4d dc	 lea	 ecx, DWORD PTR $T3[ebp]
  002fa	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  002fe	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$LN17@OnNotify:

; 1579 : 				}
; 1580 : 				//          Run .
; 1581 : 				BOOL bRetValue = m_pStrategyItem->LoadST(szSTPath,m_stCode,m_nCount,m_stEndDate); //

  00304	ff b7 80 11 00
	00		 push	 DWORD PTR [edi+4480]
  0030a	8b 8f 10 05 00
	00		 mov	 ecx, DWORD PTR [edi+1296]
  00310	ff b7 7c 11 00
	00		 push	 DWORD PTR [edi+4476]
  00316	ff b7 78 11 00
	00		 push	 DWORD PTR [edi+4472]
  0031c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0031e	ff 75 0c	 push	 DWORD PTR _szSTPath$12[ebp]
  00321	ff 50 14	 call	 DWORD PTR [eax+20]

; 1582 : 				if(bRetValue)

  00324	85 c0		 test	 eax, eax
  00326	74 0d		 je	 SHORT $LN18@OnNotify

; 1583 : 				{
; 1584 : 					m_pStrategyItem->Run();

  00328	8b 8f 10 05 00
	00		 mov	 ecx, DWORD PTR [edi+1296]
  0032e	6a 00		 push	 0
  00330	8b 01		 mov	 eax, DWORD PTR [ecx]
  00332	ff 50 18	 call	 DWORD PTR [eax+24]
$LN18@OnNotify:

; 1585 : 				}
; 1586 : 			}else{//  .....

  00335	8d 4d 0c	 lea	 ecx, DWORD PTR _szSTPath$12[ebp]
  00338	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0033e	8d 4d f0	 lea	 ecx, DWORD PTR _stSTName$10[ebp]
  00341	eb 7b		 jmp	 SHORT $LN93@OnNotify
$LN11@OnNotify:

; 1587 : 				CString stSendVal;

  00343	8d 4d 0c	 lea	 ecx, DWORD PTR _stSendVal$11[ebp]
  00346	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 1588 : 				stSendVal = m_GridTap.GetItemText(pNmgv->iRow,m_STValNum);

  0034c	ff b7 b0 11 00
	00		 push	 DWORD PTR [edi+4528]
  00352	8d 45 dc	 lea	 eax, DWORD PTR $T2[ebp]
  00355	c7 45 fc 08 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 8
  0035c	ff 73 0c	 push	 DWORD PTR [ebx+12]
  0035f	8d 8f f0 09 00
	00		 lea	 ecx, DWORD PTR [edi+2544]
  00365	50		 push	 eax
  00366	e8 00 00 00 00	 call	 ?GetItemText@CGridCtrl@@QBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@HH@Z ; CGridCtrl::GetItemText
  0036b	50		 push	 eax
  0036c	8d 4d 0c	 lea	 ecx, DWORD PTR _stSendVal$11[ebp]
  0036f	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+8], 9
  00373	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
  00379	8d 4d dc	 lea	 ecx, DWORD PTR $T2[ebp]
  0037c	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
  00380	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 1589 : 				BOOL bRetValue = m_pStrategyItem->LoadST(m_stPath,m_stCode,m_nCount,m_stEndDate);

  00386	ff b7 80 11 00
	00		 push	 DWORD PTR [edi+4480]
  0038c	8b 8f 10 05 00
	00		 mov	 ecx, DWORD PTR [edi+1296]
  00392	ff b7 7c 11 00
	00		 push	 DWORD PTR [edi+4476]
  00398	ff b7 78 11 00
	00		 push	 DWORD PTR [edi+4472]
  0039e	8b 01		 mov	 eax, DWORD PTR [ecx]
  003a0	ff b7 ac 11 00
	00		 push	 DWORD PTR [edi+4524]
  003a6	ff 50 14	 call	 DWORD PTR [eax+20]

; 1590 : 				if(bRetValue)

  003a9	85 c0		 test	 eax, eax
  003ab	74 0e		 je	 SHORT $LN19@OnNotify

; 1591 : 				{
; 1592 : 					m_pStrategyItem->Run(stSendVal);

  003ad	8b 8f 10 05 00
	00		 mov	 ecx, DWORD PTR [edi+1296]
  003b3	ff 75 0c	 push	 DWORD PTR _stSendVal$11[ebp]
  003b6	8b 01		 mov	 eax, DWORD PTR [ecx]
  003b8	ff 50 18	 call	 DWORD PTR [eax+24]
$LN19@OnNotify:

; 1593 : 				}
; 1594 : 			}

  003bb	8d 4d 0c	 lea	 ecx, DWORD PTR _stSendVal$11[ebp]
$LN93@OnNotify:

; 1595 : 
; 1596 : 		}  
; 1597 : 	}
; 1598 : 	return CDialog::OnNotify(wParam, lParam, pResult);

  003be	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  003c5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$LN12@OnNotify:
  003cb	ff 75 10	 push	 DWORD PTR _pResult$[ebp]
  003ce	53		 push	 ebx
  003cf	ff 75 08	 push	 DWORD PTR _wParam$[ebp]
$LN92@OnNotify:

; 1599 : }

  003d2	8b cf		 mov	 ecx, edi
$LN90@OnNotify:
  003d4	e8 00 00 00 00	 call	 ?OnNotify@CWnd@@MAEHIJPAJ@Z ; CWnd::OnNotify
  003d9	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  003dc	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  003e3	59		 pop	 ecx
  003e4	5f		 pop	 edi
  003e5	5e		 pop	 esi
  003e6	5b		 pop	 ebx
  003e7	8b e5		 mov	 esp, ebp
  003e9	5d		 pop	 ebp
  003ea	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?OnNotify@CDlgOptimizer@@MAEHIJPAJ@Z$0:
  00000	8d 4d f0	 lea	 ecx, DWORD PTR _stSTName$10[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?OnNotify@CDlgOptimizer@@MAEHIJPAJ@Z$1:
  00009	8d 4d e0	 lea	 ecx, DWORD PTR $T7[ebp]
  0000c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?OnNotify@CDlgOptimizer@@MAEHIJPAJ@Z$2:
  00012	8d 4d 0c	 lea	 ecx, DWORD PTR _szSTPath$12[ebp]
  00015	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?OnNotify@CDlgOptimizer@@MAEHIJPAJ@Z$3:
  0001b	8d 4d e0	 lea	 ecx, DWORD PTR $T6[ebp]
  0001e	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?OnNotify@CDlgOptimizer@@MAEHIJPAJ@Z$10:
  00024	8b 45 e0	 mov	 eax, DWORD PTR $T5[ebp]
  00027	83 e0 01	 and	 eax, 1
  0002a	0f 84 0d 00 00
	00		 je	 $LN42@OnNotify
  00030	83 65 e0 fe	 and	 DWORD PTR $T5[ebp], -2	; fffffffeH
  00034	8d 4d e8	 lea	 ecx, DWORD PTR $T8[ebp]
  00037	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$LN42@OnNotify:
  0003d	c3		 ret	 0
__unwindfunclet$?OnNotify@CDlgOptimizer@@MAEHIJPAJ@Z$5:
  0003e	8d 4d dc	 lea	 ecx, DWORD PTR $T4[ebp]
  00041	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?OnNotify@CDlgOptimizer@@MAEHIJPAJ@Z$11:
  00047	8b 45 e0	 mov	 eax, DWORD PTR $T5[ebp]
  0004a	83 e0 02	 and	 eax, 2
  0004d	0f 84 0d 00 00
	00		 je	 $LN55@OnNotify
  00053	83 65 e0 fd	 and	 DWORD PTR $T5[ebp], -3	; fffffffdH
  00057	8d 4d ec	 lea	 ecx, DWORD PTR $T9[ebp]
  0005a	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$LN55@OnNotify:
  00060	c3		 ret	 0
__unwindfunclet$?OnNotify@CDlgOptimizer@@MAEHIJPAJ@Z$7:
  00061	8d 4d dc	 lea	 ecx, DWORD PTR $T3[ebp]
  00064	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?OnNotify@CDlgOptimizer@@MAEHIJPAJ@Z$8:
  0006a	8d 4d 0c	 lea	 ecx, DWORD PTR _stSendVal$11[ebp]
  0006d	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?OnNotify@CDlgOptimizer@@MAEHIJPAJ@Z$9:
  00073	8d 4d dc	 lea	 ecx, DWORD PTR $T2[ebp]
  00076	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0007c	cc		 int	 3
  0007d	cc		 int	 3
  0007e	cc		 int	 3
  0007f	cc		 int	 3
  00080	cc		 int	 3
__ehhandler$?OnNotify@CDlgOptimizer@@MAEHIJPAJ@Z:
  00081	90		 npad	 1
  00082	90		 npad	 1
  00083	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00087	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0008a	8b 4a d8	 mov	 ecx, DWORD PTR [edx-40]
  0008d	33 c8		 xor	 ecx, eax
  0008f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00094	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?OnNotify@CDlgOptimizer@@MAEHIJPAJ@Z
  00099	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?OnNotify@CDlgOptimizer@@MAEHIJPAJ@Z ENDP		; CDlgOptimizer::OnNotify
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
;	COMDAT ?WindowProc@CDlgOptimizer@@MAEJIIJ@Z
_TEXT	SEGMENT
_message$ = 8						; size = 4
_wParam$ = 12						; size = 4
_lParam$ = 16						; size = 4
?WindowProc@CDlgOptimizer@@MAEJIIJ@Z PROC		; CDlgOptimizer::WindowProc, COMDAT
; _this$ = ecx

; 1363 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1367 : }

  00003	5d		 pop	 ebp

; 1364 : 	// TODO: Add your specialized code here and/or call the base class
; 1365 : 	
; 1366 : 	return CDialog::WindowProc(message, wParam, lParam);

  00004	e9 00 00 00 00	 jmp	 ?WindowProc@CWnd@@MAEJIIJ@Z ; CWnd::WindowProc
?WindowProc@CDlgOptimizer@@MAEJIIJ@Z ENDP		; CDlgOptimizer::WindowProc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
;	COMDAT ?DoDataExchange@CDlgOptimizer@@MAEXPAVCDataExchange@@@Z
_TEXT	SEGMENT
_pDX$ = 8						; size = 4
?DoDataExchange@CDlgOptimizer@@MAEXPAVCDataExchange@@@Z PROC ; CDlgOptimizer::DoDataExchange, COMDAT
; _this$ = ecx

; 82   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 83   : 	CDialog::DoDataExchange(pDX);
; 84   : 	//{{AFX_DATA_MAP(CDlgOptimizer)
; 85   : 	DDX_Control(pDX, IDC_BTN_ADDALL, m_CtlAddAll);

  00004	8b 75 08	 mov	 esi, DWORD PTR _pDX$[ebp]
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
  0000a	8d 87 a8 00 00
	00		 lea	 eax, DWORD PTR [edi+168]
  00010	50		 push	 eax
  00011	68 eb 32 00 00	 push	 13035			; 000032ebH
  00016	56		 push	 esi
  00017	e8 00 00 00 00	 call	 ?DDX_Control@@YGXPAVCDataExchange@@HAAVCWnd@@@Z ; DDX_Control

; 86   : 	DDX_Control(pDX, IDC_BTN_ADDONE, m_CtlAddOne);

  0001c	8d 87 38 01 00
	00		 lea	 eax, DWORD PTR [edi+312]
  00022	50		 push	 eax
  00023	68 05 33 00 00	 push	 13061			; 00003305H
  00028	56		 push	 esi
  00029	e8 00 00 00 00	 call	 ?DDX_Control@@YGXPAVCDataExchange@@HAAVCWnd@@@Z ; DDX_Control

; 87   : 	DDX_Control(pDX, IDC_BTN_DELALL, m_CtlDelAll);

  0002e	8d 87 c8 01 00
	00		 lea	 eax, DWORD PTR [edi+456]
  00034	50		 push	 eax
  00035	68 5c 33 00 00	 push	 13148			; 0000335cH
  0003a	56		 push	 esi
  0003b	e8 00 00 00 00	 call	 ?DDX_Control@@YGXPAVCDataExchange@@HAAVCWnd@@@Z ; DDX_Control

; 88   : 	DDX_Control(pDX, IDC_BTN_DELONE, m_CtlDelOne);

  00040	8d 87 58 02 00
	00		 lea	 eax, DWORD PTR [edi+600]
  00046	50		 push	 eax
  00047	68 5d 33 00 00	 push	 13149			; 0000335dH
  0004c	56		 push	 esi
  0004d	e8 00 00 00 00	 call	 ?DDX_Control@@YGXPAVCDataExchange@@HAAVCWnd@@@Z ; DDX_Control

; 89   : 	DDX_Control(pDX, IDC_BTN_STOP, m_BtnStop);

  00052	8d 87 e8 02 00
	00		 lea	 eax, DWORD PTR [edi+744]
  00058	50		 push	 eax
  00059	68 58 33 00 00	 push	 13144			; 00003358H
  0005e	56		 push	 esi
  0005f	e8 00 00 00 00	 call	 ?DDX_Control@@YGXPAVCDataExchange@@HAAVCWnd@@@Z ; DDX_Control

; 90   : 	DDX_Control(pDX, IDC_BTN_OPT, m_BtnOpt);

  00064	8d 87 78 03 00
	00		 lea	 eax, DWORD PTR [edi+888]
  0006a	50		 push	 eax
  0006b	68 07 33 00 00	 push	 13063			; 00003307H
  00070	56		 push	 esi
  00071	e8 00 00 00 00	 call	 ?DDX_Control@@YGXPAVCDataExchange@@HAAVCWnd@@@Z ; DDX_Control

; 91   : 	DDX_Control(pDX, IDC_TAB1, m_CtlTab);

  00076	8d 87 08 04 00
	00		 lea	 eax, DWORD PTR [edi+1032]
  0007c	50		 push	 eax
  0007d	68 fc 32 00 00	 push	 13052			; 000032fcH
  00082	56		 push	 esi
  00083	e8 00 00 00 00	 call	 ?DDX_Control@@YGXPAVCDataExchange@@HAAVCWnd@@@Z ; DDX_Control

; 92   : 	DDX_Control(pDX, IDC_LIST_ST, m_listST);

  00088	8d 87 f0 10 00
	00		 lea	 eax, DWORD PTR [edi+4336]
  0008e	50		 push	 eax
  0008f	68 5e 33 00 00	 push	 13150			; 0000335eH
  00094	56		 push	 esi
  00095	e8 00 00 00 00	 call	 ?DDX_Control@@YGXPAVCDataExchange@@HAAVCWnd@@@Z ; DDX_Control
  0009a	5f		 pop	 edi
  0009b	5e		 pop	 esi

; 93   : 	//}}AFX_DATA_MAP
; 94   : 	//DDX_Control(pDX, IDC_PROGRESS, m_CtlProgress);
; 95   : }

  0009c	5d		 pop	 ebp
  0009d	c2 04 00	 ret	 4
?DoDataExchange@CDlgOptimizer@@MAEXPAVCDataExchange@@@Z ENDP ; CDlgOptimizer::DoDataExchange
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\Common_ST\EscDialog.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin1.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin1.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
;	COMDAT ??0CDlgOptimizer@@QAE@PAVCWnd@@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_pParent$ = 8						; size = 4
??0CDlgOptimizer@@QAE@PAVCWnd@@@Z PROC			; CDlgOptimizer::CDlgOptimizer, COMDAT
; _this$ = ecx

; 60   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	53		 push	 ebx
  00013	56		 push	 esi
  00014	57		 push	 edi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8b f1		 mov	 esi, ecx
  00028	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\Common_ST\EscDialog.h

; 33   : 	: CDialog(nIDD, pParent)

  0002b	ff 75 08	 push	 DWORD PTR _pParent$[ebp]
  0002e	68 e7 32 00 00	 push	 13031			; 000032e7H
  00033	e8 00 00 00 00	 call	 ??0CDialog@@QAE@IPAVCWnd@@@Z ; CDialog::CDialog
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 60   : {

  00038	6a 00		 push	 0
  0003a	8d 8e a8 00 00
	00		 lea	 ecx, DWORD PTR [esi+168]
  00040	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00047	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CDlgOptimizer@@6B@
  0004d	e8 00 00 00 00	 call	 ??0CExDrawButton@@QAE@H@Z ; CExDrawButton::CExDrawButton
  00052	6a 00		 push	 0
  00054	8d 8e 38 01 00
	00		 lea	 ecx, DWORD PTR [esi+312]
  0005a	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0005e	e8 00 00 00 00	 call	 ??0CExDrawButton@@QAE@H@Z ; CExDrawButton::CExDrawButton
  00063	6a 00		 push	 0
  00065	8d 8e c8 01 00
	00		 lea	 ecx, DWORD PTR [esi+456]
  0006b	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  0006f	e8 00 00 00 00	 call	 ??0CExDrawButton@@QAE@H@Z ; CExDrawButton::CExDrawButton
  00074	6a 00		 push	 0
  00076	8d 8e 58 02 00
	00		 lea	 ecx, DWORD PTR [esi+600]
  0007c	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  00080	e8 00 00 00 00	 call	 ??0CExDrawButton@@QAE@H@Z ; CExDrawButton::CExDrawButton
  00085	6a 00		 push	 0
  00087	8d 8e e8 02 00
	00		 lea	 ecx, DWORD PTR [esi+744]
  0008d	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  00091	e8 00 00 00 00	 call	 ??0CExDrawButton@@QAE@H@Z ; CExDrawButton::CExDrawButton
  00096	6a 00		 push	 0
  00098	8d 8e 78 03 00
	00		 lea	 ecx, DWORD PTR [esi+888]
  0009e	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  000a2	e8 00 00 00 00	 call	 ??0CExDrawButton@@QAE@H@Z ; CExDrawButton::CExDrawButton
  000a7	8d 8e 08 04 00
	00		 lea	 ecx, DWORD PTR [esi+1032]
  000ad	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  000b1	e8 00 00 00 00	 call	 ??0CXTabCtrl@@QAE@XZ	; CXTabCtrl::CXTabCtrl
  000b6	8d 8e 14 05 00
	00		 lea	 ecx, DWORD PTR [esi+1300]
  000bc	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
  000c0	e8 00 00 00 00	 call	 ??0CStrategyLoader@@QAE@XZ ; CStrategyLoader::CStrategyLoader
  000c5	8d 8e 38 05 00
	00		 lea	 ecx, DWORD PTR [esi+1336]
  000cb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  000d1	8d 8e 3c 05 00
	00		 lea	 ecx, DWORD PTR [esi+1340]
  000d7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  000dd	8d 8e 40 05 00
	00		 lea	 ecx, DWORD PTR [esi+1344]
  000e3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  000e9	8d 8e 44 05 00
	00		 lea	 ecx, DWORD PTR [esi+1348]
  000ef	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  000f5	8d 8e 48 05 00
	00		 lea	 ecx, DWORD PTR [esi+1352]
  000fb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00101	8d 8e 4c 05 00
	00		 lea	 ecx, DWORD PTR [esi+1356]
  00107	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin1.inl

; 70   : 	{ m_hObject = NULL; }

  0010d	c7 86 54 05 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+1364], 0

; 128  : 	{ }

  00117	c7 86 50 05 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+1360], OFFSET ??_7CBrush@@6B@
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 60   : {

  00121	6a 00		 push	 0
  00123	6a 00		 push	 0
  00125	6a 00		 push	 0
  00127	6a 00		 push	 0
  00129	8d 8e 60 05 00
	00		 lea	 ecx, DWORD PTR [esi+1376]
  0012f	c6 45 fc 0f	 mov	 BYTE PTR __$EHRec$[ebp+8], 15 ; 0000000fH
  00133	e8 00 00 00 00	 call	 ??0CGridCtrl@@QAE@HHHH@Z ; CGridCtrl::CGridCtrl
  00138	6a 00		 push	 0
  0013a	6a 00		 push	 0
  0013c	6a 00		 push	 0
  0013e	6a 00		 push	 0
  00140	8d 8e f0 09 00
	00		 lea	 ecx, DWORD PTR [esi+2544]
  00146	c6 45 fc 10	 mov	 BYTE PTR __$EHRec$[ebp+8], 16 ; 00000010H
  0014a	e8 00 00 00 00	 call	 ??0CGridCtrl@@QAE@HHHH@Z ; CGridCtrl::CGridCtrl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 348  : {

  0014f	c7 86 90 0e 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+3728], OFFSET ??_7?$CArray@PAVCDialog@@PAV1@@@6B@

; 349  : 	m_pData = NULL;

  00159	c7 86 94 0e 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+3732], 0

; 350  : 	m_nSize = m_nMaxSize = m_nGrowBy = 0;

  00163	c7 86 a0 0e 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+3744], 0
  0016d	c7 86 9c 0e 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+3740], 0
  00177	c7 86 98 0e 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+3736], 0

; 348  : {

  00181	c7 86 a4 0e 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+3748], OFFSET ??_7?$CArray@PAUST_VALUE@@PAU1@@@6B@

; 349  : 	m_pData = NULL;

  0018b	c7 86 a8 0e 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+3752], 0

; 350  : 	m_nSize = m_nMaxSize = m_nGrowBy = 0;

  00195	c7 86 b4 0e 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+3764], 0
  0019f	c7 86 b0 0e 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+3760], 0
  001a9	c7 86 ac 0e 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+3756], 0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 60   : {

  001b3	8d 8e cc 0e 00
	00		 lea	 ecx, DWORD PTR [esi+3788]
  001b9	c6 45 fc 13	 mov	 BYTE PTR __$EHRec$[ebp+8], 19 ; 00000013H
  001bd	e8 00 00 00 00	 call	 ??0CStringArray@@QAE@XZ	; CStringArray::CStringArray
  001c2	8d 8e e0 0e 00
	00		 lea	 ecx, DWORD PTR [esi+3808]
  001c8	c6 45 fc 14	 mov	 BYTE PTR __$EHRec$[ebp+8], 20 ; 00000014H
  001cc	e8 00 00 00 00	 call	 ??0CStringArray@@QAE@XZ	; CStringArray::CStringArray
  001d1	8d 9e f4 0e 00
	00		 lea	 ebx, DWORD PTR [esi+3828]
  001d7	8b cb		 mov	 ecx, ebx
  001d9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  001df	8d 8e f8 0e 00
	00		 lea	 ecx, DWORD PTR [esi+3832]
  001e5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  001eb	8d 8e fc 0e 00
	00		 lea	 ecx, DWORD PTR [esi+3836]
  001f1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  001f7	8d be 04 0f 00
	00		 lea	 edi, DWORD PTR [esi+3844]
  001fd	8b cf		 mov	 ecx, edi
  001ff	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 348  : {

  00205	c7 86 0c 0f 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+3852], OFFSET ??_7?$CArray@UST_RUNVALUE@@U1@@@6B@

; 349  : 	m_pData = NULL;

  0020f	c7 86 10 0f 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+3856], 0

; 350  : 	m_nSize = m_nMaxSize = m_nGrowBy = 0;

  00219	c7 86 1c 0f 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+3868], 0
  00223	c7 86 18 0f 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+3864], 0
  0022d	c7 86 14 0f 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+3860], 0

; 348  : {

  00237	c7 86 20 0f 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+3872], OFFSET ??_7?$CArray@UST_GRIDDATA@@U1@@@6B@

; 349  : 	m_pData = NULL;

  00241	c7 86 24 0f 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+3876], 0

; 350  : 	m_nSize = m_nMaxSize = m_nGrowBy = 0;

  0024b	c7 86 30 0f 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+3888], 0
  00255	c7 86 2c 0f 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+3884], 0
  0025f	c7 86 28 0f 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+3880], 0

; 348  : {

  00269	c7 86 34 0f 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+3892], OFFSET ??_7?$CArray@UST_STRGRIDDATA@@U1@@@6B@

; 349  : 	m_pData = NULL;

  00273	c7 86 38 0f 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+3896], 0

; 350  : 	m_nSize = m_nMaxSize = m_nGrowBy = 0;

  0027d	c7 86 44 0f 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+3908], 0
  00287	c7 86 40 0f 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+3904], 0
  00291	c7 86 3c 0f 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+3900], 0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 60   : {

  0029b	8d 8e 48 0f 00
	00		 lea	 ecx, DWORD PTR [esi+3912]
  002a1	c6 45 fc 1c	 mov	 BYTE PTR __$EHRec$[ebp+8], 28 ; 0000001cH
  002a5	e8 00 00 00 00	 call	 ??0CStringArray@@QAE@XZ	; CStringArray::CStringArray
  002aa	8d 8e 60 0f 00
	00		 lea	 ecx, DWORD PTR [esi+3936]
  002b0	c6 45 fc 1d	 mov	 BYTE PTR __$EHRec$[ebp+8], 29 ; 0000001dH
  002b4	e8 00 00 00 00	 call	 ??0CSTGfxOutBarCtrl@@QAE@XZ ; CSTGfxOutBarCtrl::CSTGfxOutBarCtrl
  002b9	8d 8e cc 10 00
	00		 lea	 ecx, DWORD PTR [esi+4300]
  002bf	c6 45 fc 1e	 mov	 BYTE PTR __$EHRec$[ebp+8], 30 ; 0000001eH
  002c3	e8 00 00 00 00	 call	 ??0CImageList@@QAE@XZ	; CImageList::CImageList
  002c8	8d 8e d4 10 00
	00		 lea	 ecx, DWORD PTR [esi+4308]
  002ce	c6 45 fc 1f	 mov	 BYTE PTR __$EHRec$[ebp+8], 31 ; 0000001fH
  002d2	e8 00 00 00 00	 call	 ??0CImageList@@QAE@XZ	; CImageList::CImageList
  002d7	8d 8e dc 10 00
	00		 lea	 ecx, DWORD PTR [esi+4316]
  002dd	c6 45 fc 20	 mov	 BYTE PTR __$EHRec$[ebp+8], 32 ; 00000020H
  002e1	e8 00 00 00 00	 call	 ??0CStringArray@@QAE@XZ	; CStringArray::CStringArray
  002e6	81 c6 f0 10 00
	00		 add	 esi, 4336		; 000010f0H
  002ec	c6 45 fc 21	 mov	 BYTE PTR __$EHRec$[ebp+8], 33 ; 00000021H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl

; 662  : 	{ }

  002f0	8b ce		 mov	 ecx, esi
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 60   : {

  002f2	89 75 08	 mov	 DWORD PTR _this$[ebp], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl

; 662  : 	{ }

  002f5	e8 00 00 00 00	 call	 ??0CWnd@@QAE@XZ		; CWnd::CWnd
  002fa	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CListBox@@6B@
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 60   : {

  00300	8b 75 f0	 mov	 esi, DWORD PTR _this$[ebp]
  00303	8d 8e 78 11 00
	00		 lea	 ecx, DWORD PTR [esi+4472]
  00309	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0030f	8d 8e 80 11 00
	00		 lea	 ecx, DWORD PTR [esi+4480]
  00315	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0031b	8d 8e 84 11 00
	00		 lea	 ecx, DWORD PTR [esi+4484]
  00321	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00327	c7 86 90 11 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+4496], OFFSET ??_7CSTUserData@CDlgOptimizer@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 348  : {

  00331	c7 86 98 11 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+4504], OFFSET ??_7?$CArray@UST_VALUEOPTIMAZE@@U1@@@6B@

; 349  : 	m_pData = NULL;

  0033b	c7 86 9c 11 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+4508], 0

; 350  : 	m_nSize = m_nMaxSize = m_nGrowBy = 0;

  00345	c7 86 a8 11 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+4520], 0
  0034f	c7 86 a4 11 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+4516], 0
  00359	c7 86 a0 11 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+4512], 0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 60   : {

  00363	8d 8e ac 11 00
	00		 lea	 ecx, DWORD PTR [esi+4524]
  00369	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0036f	8d 8e c0 11 00
	00		 lea	 ecx, DWORD PTR [esi+4544]
  00375	c6 45 fc 27	 mov	 BYTE PTR __$EHRec$[ebp+8], 39 ; 00000027H
  00379	e8 00 00 00 00	 call	 ??0CSTBasicTree@@QAE@XZ	; CSTBasicTree::CSTBasicTree
  0037e	8d 8e 58 12 00
	00		 lea	 ecx, DWORD PTR [esi+4696]
  00384	c6 45 fc 28	 mov	 BYTE PTR __$EHRec$[ebp+8], 40 ; 00000028H
  00388	e8 00 00 00 00	 call	 ??0CSTExtTree@@QAE@XZ	; CSTExtTree::CSTExtTree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin1.inl

; 70   : 	{ m_hObject = NULL; }

  0038d	c7 86 f4 12 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+4852], 0

; 153  : 	{ }

  00397	c7 86 f0 12 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+4848], OFFSET ??_7CFont@@6B@
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp

; 66   : 	m_strGijun = "";

  003a1	68 00 00 00 00	 push	 OFFSET ??_C@_02NNHDHLCM@?$MA?O@
  003a6	8b cf		 mov	 ecx, edi
  003a8	c6 45 fc 2a	 mov	 BYTE PTR __$EHRec$[ebp+8], 42 ; 0000002aH
  003ac	c7 86 58 05 00
	00 d3 df f1 00	 mov	 DWORD PTR [esi+1368], 15851475 ; 00f1dfd3H
  003b6	c7 86 10 05 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+1296], 0
  003c0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z

; 67   : 	m_Code = "";

  003c6	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@@
  003cb	8b cb		 mov	 ecx, ebx
  003cd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z

; 68   : 	m_nGijun = G_DATE;

  003d3	b8 02 00 00 00	 mov	 eax, 2

; 69   : 	m_bReceive = FALSE;

  003d8	c7 86 bc 0e 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+3772], 0
  003e2	66 89 86 08 0f
	00 00		 mov	 WORD PTR [esi+3848], ax

; 70   : 	m_nTest =0;
; 71   : 	m_lSendNum =0;
; 72   : 
; 73   : 	m_pDlgTimeSetup = NULL;
; 74   : 	m_nOptimizerDiv = 1001;
; 75   : 	m_pChartInterface = NULL;
; 76   : 	m_bGridClick = FALSE;
; 77   : 	m_STValNum = 0;
; 78   : }

  003e9	8b c6		 mov	 eax, esi
  003eb	c7 86 c0 0e 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+3776], 0
  003f5	c7 86 b8 0e 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+3768], 0
  003ff	c7 86 2c 05 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+1324], 0
  00409	c7 86 70 11 00
	00 e9 03 00 00	 mov	 DWORD PTR [esi+4464], 1001 ; 000003e9H
  00413	c7 86 74 11 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+4468], 0
  0041d	c7 86 8c 11 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+4492], 0
  00427	c7 86 b0 11 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+4528], 0
  00431	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00434	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0043b	59		 pop	 ecx
  0043c	5f		 pop	 edi
  0043d	5e		 pop	 esi
  0043e	5b		 pop	 ebx
  0043f	8b e5		 mov	 esp, ebp
  00441	5d		 pop	 ebp
  00442	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CEscDialog@@UAE@XZ
__unwindfunclet$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	81 c1 a8 00 00
	00		 add	 ecx, 168		; 000000a8H
  00011	e9 00 00 00 00	 jmp	 ??1CExDrawButton@@UAE@XZ ; CExDrawButton::~CExDrawButton
__unwindfunclet$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z$2:
  00016	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	81 c1 38 01 00
	00		 add	 ecx, 312		; 00000138H
  0001f	e9 00 00 00 00	 jmp	 ??1CExDrawButton@@UAE@XZ ; CExDrawButton::~CExDrawButton
__unwindfunclet$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z$3:
  00024	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	81 c1 c8 01 00
	00		 add	 ecx, 456		; 000001c8H
  0002d	e9 00 00 00 00	 jmp	 ??1CExDrawButton@@UAE@XZ ; CExDrawButton::~CExDrawButton
__unwindfunclet$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z$4:
  00032	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	81 c1 58 02 00
	00		 add	 ecx, 600		; 00000258H
  0003b	e9 00 00 00 00	 jmp	 ??1CExDrawButton@@UAE@XZ ; CExDrawButton::~CExDrawButton
__unwindfunclet$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z$5:
  00040	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	81 c1 e8 02 00
	00		 add	 ecx, 744		; 000002e8H
  00049	e9 00 00 00 00	 jmp	 ??1CExDrawButton@@UAE@XZ ; CExDrawButton::~CExDrawButton
__unwindfunclet$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z$6:
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	81 c1 78 03 00
	00		 add	 ecx, 888		; 00000378H
  00057	e9 00 00 00 00	 jmp	 ??1CExDrawButton@@UAE@XZ ; CExDrawButton::~CExDrawButton
__unwindfunclet$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z$7:
  0005c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0005f	81 c1 08 04 00
	00		 add	 ecx, 1032		; 00000408H
  00065	e9 00 00 00 00	 jmp	 ??1CXTabCtrl@@UAE@XZ	; CXTabCtrl::~CXTabCtrl
__unwindfunclet$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z$8:
  0006a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0006d	81 c1 14 05 00
	00		 add	 ecx, 1300		; 00000514H
  00073	e9 00 00 00 00	 jmp	 ??1CStrategyLoader@@UAE@XZ ; CStrategyLoader::~CStrategyLoader
__unwindfunclet$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z$9:
  00078	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0007b	81 c1 38 05 00
	00		 add	 ecx, 1336		; 00000538H
  00081	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z$10:
  00087	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0008a	81 c1 3c 05 00
	00		 add	 ecx, 1340		; 0000053cH
  00090	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z$11:
  00096	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00099	81 c1 40 05 00
	00		 add	 ecx, 1344		; 00000540H
  0009f	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z$12:
  000a5	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000a8	81 c1 44 05 00
	00		 add	 ecx, 1348		; 00000544H
  000ae	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z$13:
  000b4	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000b7	81 c1 48 05 00
	00		 add	 ecx, 1352		; 00000548H
  000bd	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z$14:
  000c3	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000c6	81 c1 4c 05 00
	00		 add	 ecx, 1356		; 0000054cH
  000cc	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z$15:
  000d2	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000d5	81 c1 50 05 00
	00		 add	 ecx, 1360		; 00000550H
  000db	e9 00 00 00 00	 jmp	 ??1CBrush@@UAE@XZ	; CBrush::~CBrush
__unwindfunclet$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z$16:
  000e0	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000e3	81 c1 60 05 00
	00		 add	 ecx, 1376		; 00000560H
  000e9	e9 00 00 00 00	 jmp	 ??1CGridCtrl@@UAE@XZ	; CGridCtrl::~CGridCtrl
__unwindfunclet$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z$17:
  000ee	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000f1	81 c1 f0 09 00
	00		 add	 ecx, 2544		; 000009f0H
  000f7	e9 00 00 00 00	 jmp	 ??1CGridCtrl@@UAE@XZ	; CGridCtrl::~CGridCtrl
__unwindfunclet$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z$18:
  000fc	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000ff	81 c1 90 0e 00
	00		 add	 ecx, 3728		; 00000e90H
  00105	e9 00 00 00 00	 jmp	 ??1?$CArray@PAVCDialog@@PAV1@@@UAE@XZ ; CArray<CDialog *,CDialog *>::~CArray<CDialog *,CDialog *>
__unwindfunclet$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z$19:
  0010a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0010d	81 c1 a4 0e 00
	00		 add	 ecx, 3748		; 00000ea4H
  00113	e9 00 00 00 00	 jmp	 ??1?$CArray@PAUST_VALUE@@PAU1@@@UAE@XZ ; CArray<ST_VALUE *,ST_VALUE *>::~CArray<ST_VALUE *,ST_VALUE *>
__unwindfunclet$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z$20:
  00118	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0011b	81 c1 cc 0e 00
	00		 add	 ecx, 3788		; 00000eccH
  00121	e9 00 00 00 00	 jmp	 ??1CStringArray@@UAE@XZ	; CStringArray::~CStringArray
__unwindfunclet$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z$21:
  00126	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00129	81 c1 e0 0e 00
	00		 add	 ecx, 3808		; 00000ee0H
  0012f	e9 00 00 00 00	 jmp	 ??1CStringArray@@UAE@XZ	; CStringArray::~CStringArray
__unwindfunclet$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z$22:
  00134	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00137	81 c1 f4 0e 00
	00		 add	 ecx, 3828		; 00000ef4H
  0013d	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z$23:
  00143	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00146	81 c1 f8 0e 00
	00		 add	 ecx, 3832		; 00000ef8H
  0014c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z$24:
  00152	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00155	81 c1 fc 0e 00
	00		 add	 ecx, 3836		; 00000efcH
  0015b	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z$25:
  00161	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00164	81 c1 04 0f 00
	00		 add	 ecx, 3844		; 00000f04H
  0016a	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z$26:
  00170	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00173	81 c1 0c 0f 00
	00		 add	 ecx, 3852		; 00000f0cH
  00179	e9 00 00 00 00	 jmp	 ??1?$CArray@UST_RUNVALUE@@U1@@@UAE@XZ ; CArray<ST_RUNVALUE,ST_RUNVALUE>::~CArray<ST_RUNVALUE,ST_RUNVALUE>
__unwindfunclet$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z$27:
  0017e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00181	81 c1 20 0f 00
	00		 add	 ecx, 3872		; 00000f20H
  00187	e9 00 00 00 00	 jmp	 ??1?$CArray@UST_GRIDDATA@@U1@@@UAE@XZ ; CArray<ST_GRIDDATA,ST_GRIDDATA>::~CArray<ST_GRIDDATA,ST_GRIDDATA>
__unwindfunclet$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z$28:
  0018c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0018f	81 c1 34 0f 00
	00		 add	 ecx, 3892		; 00000f34H
  00195	e9 00 00 00 00	 jmp	 ??1?$CArray@UST_STRGRIDDATA@@U1@@@UAE@XZ ; CArray<ST_STRGRIDDATA,ST_STRGRIDDATA>::~CArray<ST_STRGRIDDATA,ST_STRGRIDDATA>
__unwindfunclet$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z$29:
  0019a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0019d	81 c1 48 0f 00
	00		 add	 ecx, 3912		; 00000f48H
  001a3	e9 00 00 00 00	 jmp	 ??1CStringArray@@UAE@XZ	; CStringArray::~CStringArray
__unwindfunclet$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z$30:
  001a8	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  001ab	81 c1 60 0f 00
	00		 add	 ecx, 3936		; 00000f60H
  001b1	e9 00 00 00 00	 jmp	 ??1CSTGfxOutBarCtrl@@UAE@XZ ; CSTGfxOutBarCtrl::~CSTGfxOutBarCtrl
__unwindfunclet$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z$31:
  001b6	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  001b9	81 c1 cc 10 00
	00		 add	 ecx, 4300		; 000010ccH
  001bf	e9 00 00 00 00	 jmp	 ??1CImageList@@UAE@XZ	; CImageList::~CImageList
__unwindfunclet$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z$32:
  001c4	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  001c7	81 c1 d4 10 00
	00		 add	 ecx, 4308		; 000010d4H
  001cd	e9 00 00 00 00	 jmp	 ??1CImageList@@UAE@XZ	; CImageList::~CImageList
__unwindfunclet$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z$33:
  001d2	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  001d5	81 c1 dc 10 00
	00		 add	 ecx, 4316		; 000010dcH
  001db	e9 00 00 00 00	 jmp	 ??1CStringArray@@UAE@XZ	; CStringArray::~CStringArray
__unwindfunclet$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z$34:
  001e0	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  001e3	81 c1 f0 10 00
	00		 add	 ecx, 4336		; 000010f0H
  001e9	e9 00 00 00 00	 jmp	 ??1CListBox@@UAE@XZ	; CListBox::~CListBox
__unwindfunclet$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z$35:
  001ee	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  001f1	81 c1 78 11 00
	00		 add	 ecx, 4472		; 00001178H
  001f7	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z$36:
  001fd	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00200	81 c1 80 11 00
	00		 add	 ecx, 4480		; 00001180H
  00206	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z$37:
  0020c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0020f	81 c1 84 11 00
	00		 add	 ecx, 4484		; 00001184H
  00215	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z$38:
  0021b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0021e	81 c1 98 11 00
	00		 add	 ecx, 4504		; 00001198H
  00224	e9 00 00 00 00	 jmp	 ??1?$CArray@UST_VALUEOPTIMAZE@@U1@@@UAE@XZ ; CArray<ST_VALUEOPTIMAZE,ST_VALUEOPTIMAZE>::~CArray<ST_VALUEOPTIMAZE,ST_VALUEOPTIMAZE>
__unwindfunclet$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z$39:
  00229	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0022c	81 c1 ac 11 00
	00		 add	 ecx, 4524		; 000011acH
  00232	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z$40:
  00238	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0023b	81 c1 c0 11 00
	00		 add	 ecx, 4544		; 000011c0H
  00241	e9 00 00 00 00	 jmp	 ??1CSTBasicTree@@UAE@XZ	; CSTBasicTree::~CSTBasicTree
__unwindfunclet$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z$41:
  00246	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00249	81 c1 58 12 00
	00		 add	 ecx, 4696		; 00001258H
  0024f	e9 00 00 00 00	 jmp	 ??1CSTExtTree@@UAE@XZ	; CSTExtTree::~CSTExtTree
__unwindfunclet$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z$42:
  00254	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00257	81 c1 f0 12 00
	00		 add	 ecx, 4848		; 000012f0H
  0025d	e9 00 00 00 00	 jmp	 ??1CFont@@UAE@XZ	; CFont::~CFont
  00262	cc		 int	 3
  00263	cc		 int	 3
  00264	cc		 int	 3
  00265	cc		 int	 3
  00266	cc		 int	 3
__ehhandler$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z:
  00267	90		 npad	 1
  00268	90		 npad	 1
  00269	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0026d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00270	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00273	33 c8		 xor	 ecx, eax
  00275	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0027a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CDlgOptimizer@@QAE@PAVCWnd@@@Z
  0027f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CDlgOptimizer@@QAE@PAVCWnd@@@Z ENDP			; CDlgOptimizer::CDlgOptimizer
; Function compile flags: /Ogtp
;	COMDAT ??1ST_VALUEOPTIMAZE@@QAE@XZ
_TEXT	SEGMENT
??1ST_VALUEOPTIMAZE@@QAE@XZ PROC			; ST_VALUEOPTIMAZE::~ST_VALUEOPTIMAZE, COMDAT
; _this$ = ecx
  00000	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
??1ST_VALUEOPTIMAZE@@QAE@XZ ENDP			; ST_VALUEOPTIMAZE::~ST_VALUEOPTIMAZE
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1ST_GRIDDATA@@QAE@XZ
_TEXT	SEGMENT
??1ST_GRIDDATA@@QAE@XZ PROC				; ST_GRIDDATA::~ST_GRIDDATA, COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8d 8e 90 00 00
	00		 lea	 ecx, DWORD PTR [esi+144]
  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0000f	8d 8e 8c 00 00
	00		 lea	 ecx, DWORD PTR [esi+140]
  00015	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0001b	8d 8e 88 00 00
	00		 lea	 ecx, DWORD PTR [esi+136]
  00021	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00027	8d 8e 84 00 00
	00		 lea	 ecx, DWORD PTR [esi+132]
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00033	8d 8e 80 00 00
	00		 lea	 ecx, DWORD PTR [esi+128]
  00039	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0003f	8d 4e 7c	 lea	 ecx, DWORD PTR [esi+124]
  00042	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00048	8d 4e 78	 lea	 ecx, DWORD PTR [esi+120]
  0004b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00051	8d 4e 74	 lea	 ecx, DWORD PTR [esi+116]
  00054	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0005a	8d 4e 70	 lea	 ecx, DWORD PTR [esi+112]
  0005d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00063	8d 4e 6c	 lea	 ecx, DWORD PTR [esi+108]
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0006c	8d 4e 68	 lea	 ecx, DWORD PTR [esi+104]
  0006f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00075	8d 4e 64	 lea	 ecx, DWORD PTR [esi+100]
  00078	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0007e	8d 4e 60	 lea	 ecx, DWORD PTR [esi+96]
  00081	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00087	8d 4e 5c	 lea	 ecx, DWORD PTR [esi+92]
  0008a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00090	8d 4e 58	 lea	 ecx, DWORD PTR [esi+88]
  00093	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00099	8d 4e 54	 lea	 ecx, DWORD PTR [esi+84]
  0009c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  000a2	8d 4e 50	 lea	 ecx, DWORD PTR [esi+80]
  000a5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  000ab	8d 4e 4c	 lea	 ecx, DWORD PTR [esi+76]
  000ae	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  000b4	8d 4e 48	 lea	 ecx, DWORD PTR [esi+72]
  000b7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  000bd	8d 4e 44	 lea	 ecx, DWORD PTR [esi+68]
  000c0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  000c6	8d 4e 40	 lea	 ecx, DWORD PTR [esi+64]
  000c9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  000cf	8d 4e 3c	 lea	 ecx, DWORD PTR [esi+60]
  000d2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  000d8	8d 4e 38	 lea	 ecx, DWORD PTR [esi+56]
  000db	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  000e1	8d 4e 34	 lea	 ecx, DWORD PTR [esi+52]
  000e4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  000ea	8d 4e 30	 lea	 ecx, DWORD PTR [esi+48]
  000ed	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  000f3	8d 4e 2c	 lea	 ecx, DWORD PTR [esi+44]
  000f6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  000fc	8d 4e 28	 lea	 ecx, DWORD PTR [esi+40]
  000ff	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00105	8d 4e 24	 lea	 ecx, DWORD PTR [esi+36]
  00108	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0010e	8d 4e 20	 lea	 ecx, DWORD PTR [esi+32]
  00111	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00117	8d 4e 1c	 lea	 ecx, DWORD PTR [esi+28]
  0011a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00120	8d 4e 18	 lea	 ecx, DWORD PTR [esi+24]
  00123	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00129	8d 4e 14	 lea	 ecx, DWORD PTR [esi+20]
  0012c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00132	8d 4e 10	 lea	 ecx, DWORD PTR [esi+16]
  00135	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0013b	8d 4e 0c	 lea	 ecx, DWORD PTR [esi+12]
  0013e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00144	8d 4e 08	 lea	 ecx, DWORD PTR [esi+8]
  00147	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0014d	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00150	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00156	8b ce		 mov	 ecx, esi
  00158	5e		 pop	 esi
  00159	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
??1ST_GRIDDATA@@QAE@XZ ENDP				; ST_GRIDDATA::~ST_GRIDDATA
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0ST_GRIDDATA@@QAE@XZ
_TEXT	SEGMENT
??0ST_GRIDDATA@@QAE@XZ PROC				; ST_GRIDDATA::ST_GRIDDATA, COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00009	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  0000c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00012	8d 4e 08	 lea	 ecx, DWORD PTR [esi+8]
  00015	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0001b	8d 4e 0c	 lea	 ecx, DWORD PTR [esi+12]
  0001e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00024	8d 4e 10	 lea	 ecx, DWORD PTR [esi+16]
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0002d	8d 4e 14	 lea	 ecx, DWORD PTR [esi+20]
  00030	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00036	8d 4e 18	 lea	 ecx, DWORD PTR [esi+24]
  00039	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0003f	8d 4e 1c	 lea	 ecx, DWORD PTR [esi+28]
  00042	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00048	8d 4e 20	 lea	 ecx, DWORD PTR [esi+32]
  0004b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00051	8d 4e 24	 lea	 ecx, DWORD PTR [esi+36]
  00054	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0005a	8d 4e 28	 lea	 ecx, DWORD PTR [esi+40]
  0005d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00063	8d 4e 2c	 lea	 ecx, DWORD PTR [esi+44]
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0006c	8d 4e 30	 lea	 ecx, DWORD PTR [esi+48]
  0006f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00075	8d 4e 34	 lea	 ecx, DWORD PTR [esi+52]
  00078	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0007e	8d 4e 38	 lea	 ecx, DWORD PTR [esi+56]
  00081	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00087	8d 4e 3c	 lea	 ecx, DWORD PTR [esi+60]
  0008a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00090	8d 4e 40	 lea	 ecx, DWORD PTR [esi+64]
  00093	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00099	8d 4e 44	 lea	 ecx, DWORD PTR [esi+68]
  0009c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  000a2	8d 4e 48	 lea	 ecx, DWORD PTR [esi+72]
  000a5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  000ab	8d 4e 4c	 lea	 ecx, DWORD PTR [esi+76]
  000ae	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  000b4	8d 4e 50	 lea	 ecx, DWORD PTR [esi+80]
  000b7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  000bd	8d 4e 54	 lea	 ecx, DWORD PTR [esi+84]
  000c0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  000c6	8d 4e 58	 lea	 ecx, DWORD PTR [esi+88]
  000c9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  000cf	8d 4e 5c	 lea	 ecx, DWORD PTR [esi+92]
  000d2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  000d8	8d 4e 60	 lea	 ecx, DWORD PTR [esi+96]
  000db	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  000e1	8d 4e 64	 lea	 ecx, DWORD PTR [esi+100]
  000e4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  000ea	8d 4e 68	 lea	 ecx, DWORD PTR [esi+104]
  000ed	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  000f3	8d 4e 6c	 lea	 ecx, DWORD PTR [esi+108]
  000f6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  000fc	8d 4e 70	 lea	 ecx, DWORD PTR [esi+112]
  000ff	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00105	8d 4e 74	 lea	 ecx, DWORD PTR [esi+116]
  00108	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0010e	8d 4e 78	 lea	 ecx, DWORD PTR [esi+120]
  00111	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00117	8d 4e 7c	 lea	 ecx, DWORD PTR [esi+124]
  0011a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00120	8d 8e 80 00 00
	00		 lea	 ecx, DWORD PTR [esi+128]
  00126	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0012c	8d 8e 84 00 00
	00		 lea	 ecx, DWORD PTR [esi+132]
  00132	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00138	8d 8e 88 00 00
	00		 lea	 ecx, DWORD PTR [esi+136]
  0013e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00144	8d 8e 8c 00 00
	00		 lea	 ecx, DWORD PTR [esi+140]
  0014a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00150	8d 8e 90 00 00
	00		 lea	 ecx, DWORD PTR [esi+144]
  00156	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0015c	8b c6		 mov	 eax, esi
  0015e	5e		 pop	 esi
  0015f	c3		 ret	 0
??0ST_GRIDDATA@@QAE@XZ ENDP				; ST_GRIDDATA::ST_GRIDDATA
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\Common_ST\STTreeCtrl.h
;	COMDAT ??__ERMSG_STTREE_ITEMDBLCLK@@YAXXZ
text$di	SEGMENT
??__ERMSG_STTREE_ITEMDBLCLK@@YAXXZ PROC			; `dynamic initializer for 'RMSG_STTREE_ITEMDBLCLK'', COMDAT

; 12   : const UINT RMSG_STTREE_ITEMDBLCLK	= ::RegisterWindowMessage("RMSG_STTREE_ITEMDBLCLK");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@LAAMLACL@RMSG_STTREE_ITEMDBLCLK@
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegisterWindowMessageA@4
  0000b	a3 00 00 00 00	 mov	 DWORD PTR ?RMSG_STTREE_ITEMDBLCLK@@3IB, eax
  00010	c3		 ret	 0
??__ERMSG_STTREE_ITEMDBLCLK@@YAXXZ ENDP			; `dynamic initializer for 'RMSG_STTREE_ITEMDBLCLK''
text$di	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\Common_ST\STTreeCtrl.h
;	COMDAT ??__ERMSG_STTREE_ITEMCLICK@@YAXXZ
text$di	SEGMENT
??__ERMSG_STTREE_ITEMCLICK@@YAXXZ PROC			; `dynamic initializer for 'RMSG_STTREE_ITEMCLICK'', COMDAT

; 11   : const UINT RMSG_STTREE_ITEMCLICK	= ::RegisterWindowMessage("RMSG_STTREE_ITEMCLICK");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@OHIMHJEO@RMSG_STTREE_ITEMCLICK@
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegisterWindowMessageA@4
  0000b	a3 00 00 00 00	 mov	 DWORD PTR ?RMSG_STTREE_ITEMCLICK@@3IB, eax
  00010	c3		 ret	 0
??__ERMSG_STTREE_ITEMCLICK@@YAXXZ ENDP			; `dynamic initializer for 'RMSG_STTREE_ITEMCLICK''
text$di	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
;	COMDAT ??_G?$CArray@UST_VALUEOPTIMAZE@@U1@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CArray@UST_VALUEOPTIMAZE@@U1@@@UAEPAXI@Z PROC	; CArray<ST_VALUEOPTIMAZE,ST_VALUEOPTIMAZE>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1?$CArray@UST_VALUEOPTIMAZE@@U1@@@UAE@XZ ; CArray<ST_VALUEOPTIMAZE,ST_VALUEOPTIMAZE>::~CArray<ST_VALUEOPTIMAZE,ST_VALUEOPTIMAZE>
  0000b	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  0000e	a8 01		 test	 al, 1
  00010	74 1f		 je	 SHORT $LN9@scalar
  00012	a8 04		 test	 al, 4
  00014	75 10		 jne	 SHORT $LN3@scalar

; 112  : 	{ ::operator delete(p); }

  00016	56		 push	 esi
  00017	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001c	83 c4 04	 add	 esp, 4
  0001f	8b c6		 mov	 eax, esi
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
$LN3@scalar:
  00026	6a 14		 push	 20			; 00000014H
  00028	56		 push	 esi
  00029	e8 00 00 00 00	 call	 ?__global_delete@@YAXPAXI@Z ; __global_delete
  0002e	83 c4 08	 add	 esp, 8
$LN9@scalar:
  00031	8b c6		 mov	 eax, esi
  00033	5e		 pop	 esi
  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
??_G?$CArray@UST_VALUEOPTIMAZE@@U1@@@UAEPAXI@Z ENDP	; CArray<ST_VALUEOPTIMAZE,ST_VALUEOPTIMAZE>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ?Serialize@?$CArray@UST_VALUEOPTIMAZE@@U1@@@UAEXAAVCArchive@@@Z
_TEXT	SEGMENT
_pData$1$ = -4						; size = 4
_ar$ = 8						; size = 4
?Serialize@?$CArray@UST_VALUEOPTIMAZE@@U1@@@UAEXAAVCArchive@@@Z PROC ; CArray<ST_VALUEOPTIMAZE,ST_VALUEOPTIMAZE>::Serialize, COMDAT
; _this$ = ecx

; 633  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	8b f9		 mov	 edi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 212  : 	{ return (m_nMode & CArchive::load) == 0; }

  00009	8b 4d 08	 mov	 ecx, DWORD PTR _ar$[ebp]
  0000c	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  0000f	f7 d0		 not	 eax
  00011	a8 01		 test	 al, 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 637  : 	if (ar.IsStoring())

  00013	74 0a		 je	 SHORT $LN2@Serialize

; 638  : 	{
; 639  : 		ar.WriteCount(m_nSize);

  00015	ff 77 08	 push	 DWORD PTR [edi+8]
  00018	e8 00 00 00 00	 call	 ?WriteCount@CArchive@@QAEXK@Z ; CArchive::WriteCount

; 640  : 	}

  0001d	eb 0f		 jmp	 SHORT $LN3@Serialize
$LN2@Serialize:

; 641  : 	else
; 642  : 	{
; 643  : 		DWORD_PTR nOldSize = ar.ReadCount();

  0001f	e8 00 00 00 00	 call	 ?ReadCount@CArchive@@QAEKXZ ; CArchive::ReadCount

; 644  : 		SetSize(nOldSize, -1);

  00024	6a ff		 push	 -1
  00026	50		 push	 eax
  00027	8b cf		 mov	 ecx, edi
  00029	e8 00 00 00 00	 call	 ?SetSize@?$CArray@UST_VALUEOPTIMAZE@@U1@@@QAEXHH@Z ; CArray<ST_VALUEOPTIMAZE,ST_VALUEOPTIMAZE>::SetSize
$LN3@Serialize:

; 645  : 	}
; 646  : 	SerializeElements<TYPE>(ar, m_pData, m_nSize);

  0002e	8b 77 08	 mov	 esi, DWORD PTR [edi+8]
  00031	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00034	89 4d fc	 mov	 DWORD PTR _pData$1$[ebp], ecx

; 68   : 	ENSURE(nCount == 0 || pElements != NULL);

  00037	85 f6		 test	 esi, esi
  00039	74 08		 je	 SHORT $LN8@Serialize
  0003b	85 c9		 test	 ecx, ecx
  0003d	0f 84 91 00 00
	00		 je	 $LN40@Serialize
$LN8@Serialize:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 212  : 	{ return (m_nMode & CArchive::load) == 0; }

  00043	8b 55 08	 mov	 edx, DWORD PTR _ar$[ebp]
  00046	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00049	f7 d0		 not	 eax
  0004b	a8 01		 test	 al, 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 73   : 	if (ar.IsStoring())

  0004d	74 3b		 je	 SHORT $LN16@Serialize

; 74   : 	{
; 75   : 		TYPE* pData;
; 76   : 		UINT_PTR nElementsLeft;
; 77   : 
; 78   : 		nElementsLeft = nCount;
; 79   : 		pData = pElements;
; 80   : 		while( nElementsLeft > 0 )

  0004f	85 f6		 test	 esi, esi
  00051	74 2e		 je	 SHORT $LN14@Serialize
$LL11@Serialize:

; 81   : 		{
; 82   : 			UINT nElementsToWrite;
; 83   : 
; 84   : 			nElementsToWrite = UINT(__min(nElementsLeft, INT_MAX/sizeof(TYPE)));

  00053	bb 92 24 49 02	 mov	 ebx, 38347922		; 02492492H
  00058	3b f3		 cmp	 esi, ebx
  0005a	0f 42 de	 cmovb	 ebx, esi

; 85   : 			ar.Write(pData, nElementsToWrite*sizeof(TYPE));

  0005d	8d 3c dd 00 00
	00 00		 lea	 edi, DWORD PTR [ebx*8]
  00064	2b fb		 sub	 edi, ebx
  00066	c1 e7 03	 shl	 edi, 3
  00069	57		 push	 edi
  0006a	51		 push	 ecx
  0006b	8b ca		 mov	 ecx, edx
  0006d	e8 00 00 00 00	 call	 ?Write@CArchive@@QAEXPBXI@Z ; CArchive::Write

; 86   : 			nElementsLeft -= nElementsToWrite;
; 87   : 			pData += nElementsToWrite;

  00072	8b 4d fc	 mov	 ecx, DWORD PTR _pData$1$[ebp]
  00075	8b 55 08	 mov	 edx, DWORD PTR _ar$[ebp]
  00078	03 cf		 add	 ecx, edi
  0007a	89 4d fc	 mov	 DWORD PTR _pData$1$[ebp], ecx
  0007d	2b f3		 sub	 esi, ebx
  0007f	75 d2		 jne	 SHORT $LL11@Serialize
$LN14@Serialize:
  00081	5f		 pop	 edi

; 647  : }

  00082	5e		 pop	 esi
  00083	5b		 pop	 ebx
  00084	8b e5		 mov	 esp, ebp
  00086	5d		 pop	 ebp
  00087	c2 04 00	 ret	 4
$LN16@Serialize:

; 97   : 		while( nElementsLeft > 0 )

  0008a	85 f6		 test	 esi, esi
  0008c	74 f3		 je	 SHORT $LN14@Serialize
  0008e	66 90		 npad	 2
$LL13@Serialize:

; 98   : 		{
; 99   : 			UINT nElementsToRead;
; 100  : 
; 101  : 			nElementsToRead = UINT(__min(nElementsLeft, INT_MAX/sizeof(TYPE)));

  00090	bb 92 24 49 02	 mov	 ebx, 38347922		; 02492492H
  00095	3b f3		 cmp	 esi, ebx
  00097	0f 42 de	 cmovb	 ebx, esi

; 102  : 			ar.EnsureRead(pData, nElementsToRead*sizeof(TYPE));

  0009a	8d 3c dd 00 00
	00 00		 lea	 edi, DWORD PTR [ebx*8]
  000a1	2b fb		 sub	 edi, ebx
  000a3	c1 e7 03	 shl	 edi, 3
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 399  : 	UINT nRead=Read(lpBuf, nCount);

  000a6	57		 push	 edi
  000a7	51		 push	 ecx
  000a8	8b ca		 mov	 ecx, edx
  000aa	e8 00 00 00 00	 call	 ?Read@CArchive@@QAEIPAXI@Z ; CArchive::Read

; 400  : 	if(nRead!=nCount)

  000af	3b c7		 cmp	 eax, edi
  000b1	75 18		 jne	 SHORT $LN30@Serialize
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 97   : 		while( nElementsLeft > 0 )

  000b3	8b 4d fc	 mov	 ecx, DWORD PTR _pData$1$[ebp]
  000b6	8b 55 08	 mov	 edx, DWORD PTR _ar$[ebp]

; 103  : 			nElementsLeft -= nElementsToRead;
; 104  : 			pData += nElementsToRead;

  000b9	03 cf		 add	 ecx, edi
  000bb	89 4d fc	 mov	 DWORD PTR _pData$1$[ebp], ecx
  000be	2b f3		 sub	 esi, ebx
  000c0	75 ce		 jne	 SHORT $LL13@Serialize

; 647  : }

  000c2	5f		 pop	 edi
  000c3	5e		 pop	 esi
  000c4	5b		 pop	 ebx
  000c5	8b e5		 mov	 esp, ebp
  000c7	5d		 pop	 ebp
  000c8	c2 04 00	 ret	 4
$LN30@Serialize:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 402  : 		AfxThrowArchiveException(CArchiveException::endOfFile);

  000cb	6a 00		 push	 0
  000cd	6a 03		 push	 3
  000cf	e8 00 00 00 00	 call	 ?AfxThrowArchiveException@@YGXHPBD@Z ; AfxThrowArchiveException
$LN40@Serialize:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 68   : 	ENSURE(nCount == 0 || pElements != NULL);

  000d4	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN38@Serialize:
  000d9	cc		 int	 3
?Serialize@?$CArray@UST_VALUEOPTIMAZE@@U1@@@UAEXAAVCArchive@@@Z ENDP ; CArray<ST_VALUEOPTIMAZE,ST_VALUEOPTIMAZE>::Serialize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ??1?$CArray@UST_VALUEOPTIMAZE@@U1@@@UAE@XZ
_TEXT	SEGMENT
??1?$CArray@UST_VALUEOPTIMAZE@@U1@@@UAE@XZ PROC		; CArray<ST_VALUEOPTIMAZE,ST_VALUEOPTIMAZE>::~CArray<ST_VALUEOPTIMAZE,ST_VALUEOPTIMAZE>, COMDAT
; _this$ = ecx

; 355  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 356  : 	ASSERT_VALID(this);
; 357  : 
; 358  : 	if (m_pData != NULL)

  00003	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00006	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CArray@UST_VALUEOPTIMAZE@@U1@@@6B@
  0000c	85 c0		 test	 eax, eax
  0000e	74 32		 je	 SHORT $LN5@CArray

; 359  : 	{
; 360  : 		for( int i = 0; i < m_nSize; i++ )

  00010	53		 push	 ebx
  00011	33 db		 xor	 ebx, ebx
  00013	39 5e 08	 cmp	 DWORD PTR [esi+8], ebx
  00016	7e 20		 jle	 SHORT $LN3@CArray
  00018	57		 push	 edi
  00019	33 ff		 xor	 edi, edi
  0001b	0f 1f 44 00 00	 npad	 5
$LL4@CArray:

; 361  : 			(m_pData + i)->~TYPE();

  00020	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00023	03 cf		 add	 ecx, edi
  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0002b	43		 inc	 ebx
  0002c	83 c7 38	 add	 edi, 56			; 00000038H
  0002f	3b 5e 08	 cmp	 ebx, DWORD PTR [esi+8]
  00032	7c ec		 jl	 SHORT $LL4@CArray
  00034	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00037	5f		 pop	 edi
$LN3@CArray:

; 362  : 		delete[] (BYTE*)m_pData;

  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0003e	83 c4 04	 add	 esp, 4
  00041	5b		 pop	 ebx
$LN5@CArray:

; 363  : 	}
; 364  : }

  00042	5e		 pop	 esi
  00043	c3		 ret	 0
??1?$CArray@UST_VALUEOPTIMAZE@@U1@@@UAE@XZ ENDP		; CArray<ST_VALUEOPTIMAZE,ST_VALUEOPTIMAZE>::~CArray<ST_VALUEOPTIMAZE,ST_VALUEOPTIMAZE>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ?Copy@?$CArray@UST_VALUEOPTIMAZE@@U1@@@QAEXABV1@@Z
_TEXT	SEGMENT
_nCount$1$ = 8						; size = 4
_src$ = 8						; size = 4
?Copy@?$CArray@UST_VALUEOPTIMAZE@@U1@@@QAEXABV1@@Z PROC	; CArray<ST_VALUEOPTIMAZE,ST_VALUEOPTIMAZE>::Copy, COMDAT
; _this$ = ecx

; 494  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	57		 push	 edi

; 495  : 	ASSERT_VALID(this);
; 496  : 	ASSERT(this != &src);   // cannot append to itself
; 497  : 
; 498  : 	if(this != &src)

  00005	8b 7d 08	 mov	 edi, DWORD PTR _src$[ebp]
  00008	8b d9		 mov	 ebx, ecx
  0000a	3b df		 cmp	 ebx, edi
  0000c	74 77		 je	 SHORT $LN19@Copy

; 499  : 	{
; 500  : 		SetSize(src.m_nSize);

  0000e	6a ff		 push	 -1
  00010	ff 77 08	 push	 DWORD PTR [edi+8]
  00013	e8 00 00 00 00	 call	 ?SetSize@?$CArray@UST_VALUEOPTIMAZE@@U1@@@QAEXHH@Z ; CArray<ST_VALUEOPTIMAZE,ST_VALUEOPTIMAZE>::SetSize

; 501  : 		CopyElements<TYPE>(m_pData, src.m_pData, src.m_nSize);

  00018	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  0001b	8b 7f 04	 mov	 edi, DWORD PTR [edi+4]
  0001e	8b 5b 04	 mov	 ebx, DWORD PTR [ebx+4]

; 54   : 	ENSURE(nCount == 0 || pDest != 0 && pSrc != 0);

  00021	85 c0		 test	 eax, eax
  00023	74 60		 je	 SHORT $LN19@Copy
  00025	85 db		 test	 ebx, ebx
  00027	74 62		 je	 SHORT $LN23@Copy
  00029	85 ff		 test	 edi, edi
  0002b	74 5e		 je	 SHORT $LN23@Copy
  0002d	56		 push	 esi
  0002e	66 90		 npad	 2
$LL8@Copy:

; 62   : 		*pDest++ = *pSrc++;

  00030	8b f3		 mov	 esi, ebx
  00032	48		 dec	 eax
  00033	57		 push	 edi
  00034	8b ce		 mov	 ecx, esi

; 55   : 	ASSERT(nCount == 0 ||
; 56   : 		AfxIsValidAddress(pDest, (size_t)nCount * sizeof(TYPE)));
; 57   : 	ASSERT(nCount == 0 ||
; 58   : 		AfxIsValidAddress(pSrc, (size_t)nCount * sizeof(TYPE)));
; 59   : 
; 60   : 	// default is element-copy using assignment
; 61   : 	while (nCount--)

  00036	89 45 08	 mov	 DWORD PTR _nCount$1$[ebp], eax

; 62   : 		*pDest++ = *pSrc++;

  00039	83 c3 38	 add	 ebx, 56			; 00000038H
  0003c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
  00042	f2 0f 10 47 08	 movsd	 xmm0, QWORD PTR [edi+8]
  00047	f2 0f 11 46 08	 movsd	 QWORD PTR [esi+8], xmm0
  0004c	f2 0f 10 47 10	 movsd	 xmm0, QWORD PTR [edi+16]
  00051	f2 0f 11 46 10	 movsd	 QWORD PTR [esi+16], xmm0
  00056	f2 0f 10 47 18	 movsd	 xmm0, QWORD PTR [edi+24]
  0005b	f2 0f 11 46 18	 movsd	 QWORD PTR [esi+24], xmm0
  00060	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  00063	89 46 20	 mov	 DWORD PTR [esi+32], eax
  00066	f2 0f 10 47 28	 movsd	 xmm0, QWORD PTR [edi+40]

; 55   : 	ASSERT(nCount == 0 ||
; 56   : 		AfxIsValidAddress(pDest, (size_t)nCount * sizeof(TYPE)));
; 57   : 	ASSERT(nCount == 0 ||
; 58   : 		AfxIsValidAddress(pSrc, (size_t)nCount * sizeof(TYPE)));
; 59   : 
; 60   : 	// default is element-copy using assignment
; 61   : 	while (nCount--)

  0006b	8b 45 08	 mov	 eax, DWORD PTR _nCount$1$[ebp]
  0006e	f2 0f 11 46 28	 movsd	 QWORD PTR [esi+40], xmm0
  00073	f2 0f 10 47 30	 movsd	 xmm0, QWORD PTR [edi+48]

; 62   : 		*pDest++ = *pSrc++;

  00078	83 c7 38	 add	 edi, 56			; 00000038H
  0007b	f2 0f 11 46 30	 movsd	 QWORD PTR [esi+48], xmm0

; 55   : 	ASSERT(nCount == 0 ||
; 56   : 		AfxIsValidAddress(pDest, (size_t)nCount * sizeof(TYPE)));
; 57   : 	ASSERT(nCount == 0 ||
; 58   : 		AfxIsValidAddress(pSrc, (size_t)nCount * sizeof(TYPE)));
; 59   : 
; 60   : 	// default is element-copy using assignment
; 61   : 	while (nCount--)

  00080	85 c0		 test	 eax, eax
  00082	75 ac		 jne	 SHORT $LL8@Copy
  00084	5e		 pop	 esi
$LN19@Copy:
  00085	5f		 pop	 edi

; 502  : 	}
; 503  : }

  00086	5b		 pop	 ebx
  00087	5d		 pop	 ebp
  00088	c2 04 00	 ret	 4
$LN23@Copy:

; 54   : 	ENSURE(nCount == 0 || pDest != 0 && pSrc != 0);

  0008b	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN27@Copy:
  00090	cc		 int	 3
?Copy@?$CArray@UST_VALUEOPTIMAZE@@U1@@@QAEXABV1@@Z ENDP	; CArray<ST_VALUEOPTIMAZE,ST_VALUEOPTIMAZE>::Copy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_memcpy_s.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlchecked.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_memcpy_s.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ?SetSize@?$CArray@UST_VALUEOPTIMAZE@@U1@@@QAEXHH@Z
_TEXT	SEGMENT
__N$1$ = -12						; size = 4
__S2$1$ = -8						; size = 4
_nNewMax$1$ = -4					; size = 4
_nAllocSize$1$ = -4					; size = 4
__S1max$1$ = 8						; size = 4
_i$1$ = 8						; size = 4
_nNewSize$ = 8						; size = 4
_pNewData$1$ = 12					; size = 4
tv564 = 12						; size = 4
_nGrowBy$ = 12						; size = 4
?SetSize@?$CArray@UST_VALUEOPTIMAZE@@U1@@@QAEXHH@Z PROC	; CArray<ST_VALUEOPTIMAZE,ST_VALUEOPTIMAZE>::SetSize, COMDAT
; _this$ = ecx

; 368  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx
  00007	8b 5d 08	 mov	 ebx, DWORD PTR _nNewSize$[ebp]
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b f9		 mov	 edi, ecx

; 369  : 	ASSERT_VALID(this);
; 370  : 	ASSERT(nNewSize >= 0);
; 371  : 
; 372  : 	if(nNewSize < 0 )

  0000e	85 db		 test	 ebx, ebx
  00010	0f 88 0c 03 00
	00		 js	 $LN91@SetSize

; 373  : 		AfxThrowInvalidArgException();
; 374  : 
; 375  : 	if (nGrowBy >= 0)

  00016	8b 45 0c	 mov	 eax, DWORD PTR _nGrowBy$[ebp]
  00019	85 c0		 test	 eax, eax
  0001b	78 03		 js	 SHORT $LN90@SetSize

; 376  : 		m_nGrowBy = nGrowBy;  // set new size

  0001d	89 47 10	 mov	 DWORD PTR [edi+16], eax
$LN90@SetSize:

; 377  : 
; 378  : 	if (nNewSize == 0)

  00020	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
  00023	85 db		 test	 ebx, ebx
  00025	75 49		 jne	 SHORT $LN19@SetSize

; 379  : 	{
; 380  : 		// shrink to nothing
; 381  : 		if (m_pData != NULL)

  00027	85 f6		 test	 esi, esi
  00029	74 2e		 je	 SHORT $LN21@SetSize

; 382  : 		{
; 383  : 			for( int i = 0; i < m_nSize; i++ )

  0002b	39 5f 08	 cmp	 DWORD PTR [edi+8], ebx
  0002e	7e 19		 jle	 SHORT $LN3@SetSize
  00030	33 f6		 xor	 esi, esi
$LL4@SetSize:

; 384  : 				(m_pData + i)->~TYPE();

  00032	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00035	03 ce		 add	 ecx, esi
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0003d	43		 inc	 ebx
  0003e	83 c6 38	 add	 esi, 56			; 00000038H
  00041	3b 5f 08	 cmp	 ebx, DWORD PTR [edi+8]
  00044	7c ec		 jl	 SHORT $LL4@SetSize
  00046	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
$LN3@SetSize:

; 385  : 			delete[] (BYTE*)m_pData;

  00049	56		 push	 esi
  0004a	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0004f	83 c4 04	 add	 esp, 4

; 386  : 			m_pData = NULL;

  00052	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0
$LN21@SetSize:

; 387  : 		}
; 388  : 		m_nSize = m_nMaxSize = 0;

  00059	c7 47 0c 00 00
	00 00		 mov	 DWORD PTR [edi+12], 0
  00060	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0
  00067	5f		 pop	 edi

; 472  : 		m_nSize = nNewSize;
; 473  : 		m_nMaxSize = nNewMax;
; 474  : 	}
; 475  : }

  00068	5e		 pop	 esi
  00069	5b		 pop	 ebx
  0006a	8b e5		 mov	 esp, ebp
  0006c	5d		 pop	 ebp
  0006d	c2 08 00	 ret	 8
$LN19@SetSize:

; 389  : 	}
; 390  : 	else if (m_pData == NULL)

  00070	85 f6		 test	 esi, esi
  00072	75 64		 jne	 SHORT $LN22@SetSize

; 391  : 	{
; 392  : 		// create buffer big enough to hold number of requested elements or
; 393  : 		// m_nGrowBy elements, whichever is larger.
; 394  : #ifdef SIZE_T_MAX
; 395  : 		ASSERT(nNewSize <= SIZE_T_MAX/sizeof(TYPE));    // no overflow
; 396  : #endif
; 397  : 		size_t nAllocSize = __max(nNewSize, m_nGrowBy);

  00074	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00077	3b d8		 cmp	 ebx, eax
  00079	0f 4f c3	 cmovg	 eax, ebx
  0007c	89 45 fc	 mov	 DWORD PTR _nAllocSize$1$[ebp], eax

; 398  : 		m_pData = (TYPE*) new BYTE[(size_t)nAllocSize * sizeof(TYPE)];

  0007f	8d 34 c5 00 00
	00 00		 lea	 esi, DWORD PTR [eax*8]
  00086	2b f0		 sub	 esi, eax
  00088	c1 e6 03	 shl	 esi, 3
  0008b	56		 push	 esi
  0008c	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]

; 399  : 		memset((void*)m_pData, 0, (size_t)nAllocSize * sizeof(TYPE));

  00091	56		 push	 esi
  00092	6a 00		 push	 0
  00094	50		 push	 eax
  00095	89 47 04	 mov	 DWORD PTR [edi+4], eax
  00098	e8 00 00 00 00	 call	 _memset
  0009d	83 c4 10	 add	 esp, 16			; 00000010H

; 400  : 		for( int i = 0; i < nNewSize; i++ )

  000a0	85 db		 test	 ebx, ebx
  000a2	7e 22		 jle	 SHORT $LN6@SetSize

; 398  : 		m_pData = (TYPE*) new BYTE[(size_t)nAllocSize * sizeof(TYPE)];

  000a4	33 f6		 xor	 esi, esi
  000a6	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL7@SetSize:

; 401  : #pragma push_macro("new")
; 402  : #undef new
; 403  : 			::new( (void*)( m_pData + i ) ) TYPE;

  000b0	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  000b3	03 ce		 add	 ecx, esi
  000b5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  000bb	83 c6 38	 add	 esi, 56			; 00000038H
  000be	83 eb 01	 sub	 ebx, 1
  000c1	75 ed		 jne	 SHORT $LL7@SetSize
  000c3	8b 5d 08	 mov	 ebx, DWORD PTR _nNewSize$[ebp]
$LN6@SetSize:

; 472  : 		m_nSize = nNewSize;
; 473  : 		m_nMaxSize = nNewMax;
; 474  : 	}
; 475  : }

  000c6	8b 45 fc	 mov	 eax, DWORD PTR _nNewMax$1$[ebp]
  000c9	89 47 0c	 mov	 DWORD PTR [edi+12], eax
$LN12@SetSize:
  000cc	89 5f 08	 mov	 DWORD PTR [edi+8], ebx
  000cf	5f		 pop	 edi
  000d0	5e		 pop	 esi
  000d1	5b		 pop	 ebx
  000d2	8b e5		 mov	 esp, ebp
  000d4	5d		 pop	 ebp
  000d5	c2 08 00	 ret	 8
$LN22@SetSize:

; 404  : #pragma pop_macro("new")
; 405  : 		m_nSize = nNewSize;
; 406  : 		m_nMaxSize = nAllocSize;
; 407  : 	}
; 408  : 	else if (nNewSize <= m_nMaxSize)

  000d8	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  000db	3b d9		 cmp	 ebx, ecx
  000dd	0f 8f ba 00 00
	00		 jg	 $LN24@SetSize

; 409  : 	{
; 410  : 		// it fits
; 411  : 		if (nNewSize > m_nSize)

  000e3	8b 57 08	 mov	 edx, DWORD PTR [edi+8]
  000e6	3b da		 cmp	 ebx, edx
  000e8	7e 66		 jle	 SHORT $LN26@SetSize

; 412  : 		{
; 413  : 			// initialize the new elements
; 414  : 			memset((void*)(m_pData + m_nSize), 0, (size_t)(nNewSize-m_nSize) * sizeof(TYPE));

  000ea	8b cb		 mov	 ecx, ebx
  000ec	2b ca		 sub	 ecx, edx
  000ee	8d 04 cd 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*8]
  000f5	2b c1		 sub	 eax, ecx
  000f7	c1 e0 03	 shl	 eax, 3
  000fa	50		 push	 eax
  000fb	8d 04 d5 00 00
	00 00		 lea	 eax, DWORD PTR [edx*8]
  00102	2b c2		 sub	 eax, edx
  00104	6a 00		 push	 0
  00106	8d 04 c6	 lea	 eax, DWORD PTR [esi+eax*8]
  00109	50		 push	 eax
  0010a	e8 00 00 00 00	 call	 _memset

; 415  : 			for( int i = 0; i < nNewSize-m_nSize; i++ )

  0010f	8b c3		 mov	 eax, ebx
  00111	83 c4 0c	 add	 esp, 12			; 0000000cH
  00114	2b 47 08	 sub	 eax, DWORD PTR [edi+8]
  00117	33 f6		 xor	 esi, esi
  00119	85 c0		 test	 eax, eax
  0011b	7e af		 jle	 SHORT $LN12@SetSize
  0011d	0f 1f 00	 npad	 3
$LL10@SetSize:

; 416  : #pragma push_macro("new")
; 417  : #undef new
; 418  : 				::new( (void*)( m_pData + m_nSize + i ) ) TYPE;

  00120	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00123	03 c6		 add	 eax, esi
  00125	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*8]
  0012c	2b c8		 sub	 ecx, eax
  0012e	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00131	8d 0c c8	 lea	 ecx, DWORD PTR [eax+ecx*8]
  00134	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0013a	8b c3		 mov	 eax, ebx
  0013c	46		 inc	 esi
  0013d	2b 47 08	 sub	 eax, DWORD PTR [edi+8]
  00140	3b f0		 cmp	 esi, eax
  00142	7c dc		 jl	 SHORT $LL10@SetSize

; 472  : 		m_nSize = nNewSize;
; 473  : 		m_nMaxSize = nNewMax;
; 474  : 	}
; 475  : }

  00144	89 5f 08	 mov	 DWORD PTR [edi+8], ebx
  00147	5f		 pop	 edi
  00148	5e		 pop	 esi
  00149	5b		 pop	 ebx
  0014a	8b e5		 mov	 esp, ebp
  0014c	5d		 pop	 ebp
  0014d	c2 08 00	 ret	 8
$LN26@SetSize:

; 419  : #pragma pop_macro("new")
; 420  : 		}
; 421  : 		else if (m_nSize > nNewSize)

  00150	0f 8d 76 ff ff
	ff		 jge	 $LN12@SetSize

; 422  : 		{
; 423  : 			// destroy the old elements
; 424  : 			for( int i = 0; i < m_nSize-nNewSize; i++ )

  00156	2b d3		 sub	 edx, ebx
  00158	c7 45 08 00 00
	00 00		 mov	 DWORD PTR _i$1$[ebp], 0
  0015f	85 d2		 test	 edx, edx
  00161	0f 8e 65 ff ff
	ff		 jle	 $LN12@SetSize
  00167	8d 34 dd 00 00
	00 00		 lea	 esi, DWORD PTR [ebx*8]
  0016e	2b f3		 sub	 esi, ebx
  00170	c1 e6 03	 shl	 esi, 3
$LL13@SetSize:

; 425  : 				(m_pData + nNewSize + i)->~TYPE();

  00173	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00176	03 ce		 add	 ecx, esi
  00178	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0017e	8b 4d 08	 mov	 ecx, DWORD PTR _i$1$[ebp]
  00181	83 c6 38	 add	 esi, 56			; 00000038H
  00184	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00187	41		 inc	 ecx
  00188	2b c3		 sub	 eax, ebx
  0018a	89 4d 08	 mov	 DWORD PTR _i$1$[ebp], ecx
  0018d	3b c8		 cmp	 ecx, eax
  0018f	7c e2		 jl	 SHORT $LL13@SetSize

; 472  : 		m_nSize = nNewSize;
; 473  : 		m_nMaxSize = nNewMax;
; 474  : 	}
; 475  : }

  00191	89 5f 08	 mov	 DWORD PTR [edi+8], ebx
  00194	5f		 pop	 edi
  00195	5e		 pop	 esi
  00196	5b		 pop	 ebx
  00197	8b e5		 mov	 esp, ebp
  00199	5d		 pop	 ebp
  0019a	c2 08 00	 ret	 8
$LN24@SetSize:

; 426  : 		}
; 427  : 		m_nSize = nNewSize;
; 428  : 	}
; 429  : 	else
; 430  : 	{
; 431  : 		// otherwise, grow array
; 432  : 		nGrowBy = m_nGrowBy;

  0019d	8b 47 10	 mov	 eax, DWORD PTR [edi+16]

; 433  : 		if (nGrowBy == 0)

  001a0	85 c0		 test	 eax, eax
  001a2	75 22		 jne	 SHORT $LN37@SetSize

; 434  : 		{
; 435  : 			// heuristically determine growth when nGrowBy == 0
; 436  : 			//  (this avoids heap fragmentation in many situations)
; 437  : 			nGrowBy = m_nSize / 8;

  001a4	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  001a7	99		 cdq
  001a8	83 e2 07	 and	 edx, 7
  001ab	03 c2		 add	 eax, edx
  001ad	c1 f8 03	 sar	 eax, 3

; 438  : 			nGrowBy = (nGrowBy < 4) ? 4 : ((nGrowBy > 1024) ? 1024 : nGrowBy);

  001b0	83 f8 04	 cmp	 eax, 4
  001b3	7d 07		 jge	 SHORT $LN36@SetSize
  001b5	b8 04 00 00 00	 mov	 eax, 4
  001ba	eb 0a		 jmp	 SHORT $LN37@SetSize
$LN36@SetSize:
  001bc	ba 00 04 00 00	 mov	 edx, 1024		; 00000400H
  001c1	3b c2		 cmp	 eax, edx
  001c3	0f 4f c2	 cmovg	 eax, edx
$LN37@SetSize:

; 439  : 		}
; 440  : 		INT_PTR nNewMax;
; 441  : 		if (nNewSize < m_nMaxSize + nGrowBy)

  001c6	03 c8		 add	 ecx, eax
  001c8	89 4d fc	 mov	 DWORD PTR _nNewMax$1$[ebp], ecx
  001cb	3b d9		 cmp	 ebx, ecx
  001cd	7d 0b		 jge	 SHORT $LN30@SetSize

; 445  : 
; 446  : 		ASSERT(nNewMax >= m_nMaxSize);  // no wrap around
; 447  : 
; 448  : 		if(nNewMax  < m_nMaxSize)

  001cf	3b 4f 0c	 cmp	 ecx, DWORD PTR [edi+12]
  001d2	0f 8c 4a 01 00
	00		 jl	 $LN91@SetSize
  001d8	eb 05		 jmp	 SHORT $LN32@SetSize
$LN30@SetSize:

; 442  : 			nNewMax = m_nMaxSize + nGrowBy;  // granularity
; 443  : 		else
; 444  : 			nNewMax = nNewSize;  // no slush

  001da	8b cb		 mov	 ecx, ebx
  001dc	89 5d fc	 mov	 DWORD PTR _nNewMax$1$[ebp], ebx
$LN32@SetSize:

; 450  : 
; 451  : #ifdef SIZE_T_MAX
; 452  : 		ASSERT(nNewMax <= SIZE_T_MAX/sizeof(TYPE)); // no overflow
; 453  : #endif
; 454  : 		TYPE* pNewData = (TYPE*) new BYTE[(size_t)nNewMax * sizeof(TYPE)];

  001df	8d 04 cd 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*8]
  001e6	2b c1		 sub	 eax, ecx
  001e8	c1 e0 03	 shl	 eax, 3
  001eb	50		 push	 eax
  001ec	89 45 08	 mov	 DWORD PTR __S1max$1$[ebp], eax
  001ef	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]

; 455  : 
; 456  : 		// copy new data from old
; 457  : 		::ATL::Checked::memcpy_s(pNewData, (size_t)nNewMax * sizeof(TYPE),

  001f4	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  001f7	83 c4 04	 add	 esp, 4
  001fa	8b f0		 mov	 esi, eax
  001fc	89 75 0c	 mov	 DWORD PTR _pNewData$1$[ebp], esi
  001ff	8d 14 cd 00 00
	00 00		 lea	 edx, DWORD PTR [ecx*8]
  00206	2b d1		 sub	 edx, ecx
  00208	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  0020b	c1 e2 03	 shl	 edx, 3
  0020e	89 55 f4	 mov	 DWORD PTR __N$1$[ebp], edx
  00211	89 4d f8	 mov	 DWORD PTR __S2$1$[ebp], ecx
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_memcpy_s.h

; 46   :         if (_SourceSize == 0)

  00214	85 d2		 test	 edx, edx
  00216	75 04		 jne	 SHORT $LN59@SetSize

; 47   :         {
; 48   :             return 0;

  00218	33 c0		 xor	 eax, eax
  0021a	eb 1f		 jmp	 SHORT $LN58@SetSize
$LN59@SetSize:

; 49   :         }
; 50   : 
; 51   :         _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Destination != NULL, EINVAL);

  0021c	85 f6		 test	 esi, esi
  0021e	0f 85 a3 00 00
	00		 jne	 $LN60@SetSize
$LN94@SetSize:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlchecked.h

; 69   : 	ATLMFC_CRT_ERRORCHECK(::memcpy_s(_S1, _S1max, _S2, _N));

  00224	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___errno
  0022a	c7 00 16 00 00
	00		 mov	 DWORD PTR [eax], 22	; 00000016H
  00230	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo
$LN64@SetSize:
  00236	b8 16 00 00 00	 mov	 eax, 22			; 00000016H
$LN58@SetSize:
  0023b	50		 push	 eax
  0023c	e8 00 00 00 00	 call	 ?AfxCrtErrorCheck@@YAHH@Z ; AfxCrtErrorCheck
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 462  : 		memset((void*)(pNewData + m_nSize), 0, (size_t)(nNewSize-m_nSize) * sizeof(TYPE));

  00241	8b 57 08	 mov	 edx, DWORD PTR [edi+8]
  00244	8b cb		 mov	 ecx, ebx
  00246	2b ca		 sub	 ecx, edx
  00248	8d 04 cd 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*8]
  0024f	2b c1		 sub	 eax, ecx
  00251	c1 e0 03	 shl	 eax, 3
  00254	50		 push	 eax
  00255	8d 04 d5 00 00
	00 00		 lea	 eax, DWORD PTR [edx*8]
  0025c	2b c2		 sub	 eax, edx
  0025e	6a 00		 push	 0
  00260	8d 04 c6	 lea	 eax, DWORD PTR [esi+eax*8]
  00263	50		 push	 eax
  00264	e8 00 00 00 00	 call	 _memset

; 463  : 		for( int i = 0; i < nNewSize-m_nSize; i++ )

  00269	8b c3		 mov	 eax, ebx
  0026b	83 c4 10	 add	 esp, 16			; 00000010H
  0026e	2b 47 08	 sub	 eax, DWORD PTR [edi+8]
  00271	33 f6		 xor	 esi, esi
  00273	85 c0		 test	 eax, eax
  00275	7e 2d		 jle	 SHORT $LN15@SetSize
  00277	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL16@SetSize:

; 464  : #pragma push_macro("new")
; 465  : #undef new
; 466  : 			::new( (void*)( pNewData + m_nSize + i ) ) TYPE;

  00280	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00283	03 ce		 add	 ecx, esi
  00285	8d 04 cd 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*8]
  0028c	2b c1		 sub	 eax, ecx
  0028e	8b 4d 0c	 mov	 ecx, DWORD PTR _pNewData$1$[ebp]
  00291	8d 0c c1	 lea	 ecx, DWORD PTR [ecx+eax*8]
  00294	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0029a	8b c3		 mov	 eax, ebx
  0029c	46		 inc	 esi
  0029d	2b 47 08	 sub	 eax, DWORD PTR [edi+8]
  002a0	3b f0		 cmp	 esi, eax
  002a2	7c dc		 jl	 SHORT $LL16@SetSize
$LN15@SetSize:

; 467  : #pragma pop_macro("new")
; 468  : 
; 469  : 		// get rid of old stuff (note: no destructors called)
; 470  : 		delete[] (BYTE*)m_pData;

  002a4	ff 77 04	 push	 DWORD PTR [edi+4]
  002a7	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]

; 471  : 		m_pData = pNewData;

  002ac	8b 45 0c	 mov	 eax, DWORD PTR _pNewData$1$[ebp]
  002af	83 c4 04	 add	 esp, 4
  002b2	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 472  : 		m_nSize = nNewSize;
; 473  : 		m_nMaxSize = nNewMax;
; 474  : 	}
; 475  : }

  002b5	8b 45 fc	 mov	 eax, DWORD PTR _nNewMax$1$[ebp]
  002b8	89 5f 08	 mov	 DWORD PTR [edi+8], ebx
  002bb	89 47 0c	 mov	 DWORD PTR [edi+12], eax
  002be	5f		 pop	 edi
  002bf	5e		 pop	 esi
  002c0	5b		 pop	 ebx
  002c1	8b e5		 mov	 esp, ebp
  002c3	5d		 pop	 ebp
  002c4	c2 08 00	 ret	 8
$LN60@SetSize:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_memcpy_s.h

; 52   :         if (_Source == NULL || _DestinationSize < _SourceSize)

  002c7	8b 45 08	 mov	 eax, DWORD PTR __S1max$1$[ebp]
  002ca	85 c9		 test	 ecx, ecx
  002cc	74 16		 je	 SHORT $LN62@SetSize
  002ce	3b c2		 cmp	 eax, edx
  002d0	72 12		 jb	 SHORT $LN62@SetSize

; 58   : 
; 59   :             // Unreachable, but required to suppress /analyze warnings:
; 60   :             return EINVAL;
; 61   :         }
; 62   :         memcpy(_Destination, _Source, _SourceSize);

  002d2	52		 push	 edx
  002d3	51		 push	 ecx
  002d4	56		 push	 esi
  002d5	e8 00 00 00 00	 call	 _memcpy
  002da	83 c4 0c	 add	 esp, 12			; 0000000cH

; 63   :         return 0;

  002dd	33 c0		 xor	 eax, eax
  002df	e9 57 ff ff ff	 jmp	 $LN58@SetSize
$LN62@SetSize:

; 53   :         {
; 54   :             memset(_Destination, 0, _DestinationSize);

  002e4	50		 push	 eax
  002e5	6a 00		 push	 0
  002e7	56		 push	 esi
  002e8	e8 00 00 00 00	 call	 _memset
  002ed	83 c4 0c	 add	 esp, 12			; 0000000cH

; 55   : 
; 56   :             _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Source != NULL,                 EINVAL);

  002f0	83 7d f8 00	 cmp	 DWORD PTR __S2$1$[ebp], 0
  002f4	0f 84 2a ff ff
	ff		 je	 $LN94@SetSize

; 57   :             _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_DestinationSize >= _SourceSize, ERANGE);

  002fa	8b 45 f4	 mov	 eax, DWORD PTR __N$1$[ebp]
  002fd	39 45 08	 cmp	 DWORD PTR __S1max$1$[ebp], eax
  00300	0f 83 30 ff ff
	ff		 jae	 $LN64@SetSize
  00306	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___errno
  0030c	c7 00 22 00 00
	00		 mov	 DWORD PTR [eax], 34	; 00000022H
  00312	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo
  00318	b8 22 00 00 00	 mov	 eax, 34			; 00000022H
  0031d	e9 19 ff ff ff	 jmp	 $LN58@SetSize
$LN91@SetSize:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 449  : 			AfxThrowInvalidArgException();

  00322	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN93@SetSize:
  00327	cc		 int	 3
?SetSize@?$CArray@UST_VALUEOPTIMAZE@@U1@@@QAEXHH@Z ENDP	; CArray<ST_VALUEOPTIMAZE,ST_VALUEOPTIMAZE>::SetSize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ??0?$CArray@UST_VALUEOPTIMAZE@@U1@@@QAE@XZ
_TEXT	SEGMENT
??0?$CArray@UST_VALUEOPTIMAZE@@U1@@@QAE@XZ PROC		; CArray<ST_VALUEOPTIMAZE,ST_VALUEOPTIMAZE>::CArray<ST_VALUEOPTIMAZE,ST_VALUEOPTIMAZE>, COMDAT
; _this$ = ecx

; 348  : {

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CArray@UST_VALUEOPTIMAZE@@U1@@@6B@

; 349  : 	m_pData = NULL;
; 350  : 	m_nSize = m_nMaxSize = m_nGrowBy = 0;
; 351  : }

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  00016	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0
  0001d	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00024	c3		 ret	 0
??0?$CArray@UST_VALUEOPTIMAZE@@U1@@@QAE@XZ ENDP		; CArray<ST_VALUEOPTIMAZE,ST_VALUEOPTIMAZE>::CArray<ST_VALUEOPTIMAZE,ST_VALUEOPTIMAZE>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
;	COMDAT ??_G?$CArray@NN@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CArray@NN@@UAEPAXI@Z PROC				; CArray<double,double>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 355  : {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 356  : 	ASSERT_VALID(this);
; 357  : 
; 358  : 	if (m_pData != NULL)

  00006	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CArray@NN@@6B@
  0000f	85 c0		 test	 eax, eax
  00011	74 09		 je	 SHORT $LN11@scalar

; 359  : 	{
; 360  : 		for( int i = 0; i < m_nSize; i++ )
; 361  : 			(m_pData + i)->~TYPE();
; 362  : 		delete[] (BYTE*)m_pData;

  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00019	83 c4 04	 add	 esp, 4
$LN11@scalar:
  0001c	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  0001f	a8 01		 test	 al, 1
  00021	74 1f		 je	 SHORT $LN20@scalar
  00023	a8 04		 test	 al, 4
  00025	75 10		 jne	 SHORT $LN3@scalar
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 112  : 	{ ::operator delete(p); }

  00027	56		 push	 esi
  00028	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0002d	83 c4 04	 add	 esp, 4
  00030	8b c6		 mov	 eax, esi
  00032	5e		 pop	 esi
  00033	5d		 pop	 ebp
  00034	c2 04 00	 ret	 4
$LN3@scalar:
  00037	6a 14		 push	 20			; 00000014H
  00039	56		 push	 esi
  0003a	e8 00 00 00 00	 call	 ?__global_delete@@YAXPAXI@Z ; __global_delete
  0003f	83 c4 08	 add	 esp, 8
$LN20@scalar:
  00042	8b c6		 mov	 eax, esi
  00044	5e		 pop	 esi
  00045	5d		 pop	 ebp
  00046	c2 04 00	 ret	 4
??_G?$CArray@NN@@UAEPAXI@Z ENDP				; CArray<double,double>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ?Serialize@?$CArray@NN@@UAEXAAVCArchive@@@Z
_TEXT	SEGMENT
_pData$1$ = -4						; size = 4
_ar$ = 8						; size = 4
?Serialize@?$CArray@NN@@UAEXAAVCArchive@@@Z PROC	; CArray<double,double>::Serialize, COMDAT
; _this$ = ecx

; 633  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	8b f9		 mov	 edi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 212  : 	{ return (m_nMode & CArchive::load) == 0; }

  00009	8b 4d 08	 mov	 ecx, DWORD PTR _ar$[ebp]
  0000c	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  0000f	f7 d0		 not	 eax
  00011	a8 01		 test	 al, 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 637  : 	if (ar.IsStoring())

  00013	74 0a		 je	 SHORT $LN2@Serialize

; 638  : 	{
; 639  : 		ar.WriteCount(m_nSize);

  00015	ff 77 08	 push	 DWORD PTR [edi+8]
  00018	e8 00 00 00 00	 call	 ?WriteCount@CArchive@@QAEXK@Z ; CArchive::WriteCount

; 640  : 	}

  0001d	eb 0f		 jmp	 SHORT $LN3@Serialize
$LN2@Serialize:

; 641  : 	else
; 642  : 	{
; 643  : 		DWORD_PTR nOldSize = ar.ReadCount();

  0001f	e8 00 00 00 00	 call	 ?ReadCount@CArchive@@QAEKXZ ; CArchive::ReadCount

; 644  : 		SetSize(nOldSize, -1);

  00024	6a ff		 push	 -1
  00026	50		 push	 eax
  00027	8b cf		 mov	 ecx, edi
  00029	e8 00 00 00 00	 call	 ?SetSize@?$CArray@NN@@QAEXHH@Z ; CArray<double,double>::SetSize
$LN3@Serialize:

; 645  : 	}
; 646  : 	SerializeElements<TYPE>(ar, m_pData, m_nSize);

  0002e	8b 77 08	 mov	 esi, DWORD PTR [edi+8]
  00031	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00034	89 4d fc	 mov	 DWORD PTR _pData$1$[ebp], ecx

; 68   : 	ENSURE(nCount == 0 || pElements != NULL);

  00037	85 f6		 test	 esi, esi
  00039	74 08		 je	 SHORT $LN8@Serialize
  0003b	85 c9		 test	 ecx, ecx
  0003d	0f 84 8c 00 00
	00		 je	 $LN40@Serialize
$LN8@Serialize:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 212  : 	{ return (m_nMode & CArchive::load) == 0; }

  00043	8b 55 08	 mov	 edx, DWORD PTR _ar$[ebp]
  00046	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00049	f7 d0		 not	 eax
  0004b	a8 01		 test	 al, 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 73   : 	if (ar.IsStoring())

  0004d	74 36		 je	 SHORT $LN16@Serialize

; 74   : 	{
; 75   : 		TYPE* pData;
; 76   : 		UINT_PTR nElementsLeft;
; 77   : 
; 78   : 		nElementsLeft = nCount;
; 79   : 		pData = pElements;
; 80   : 		while( nElementsLeft > 0 )

  0004f	85 f6		 test	 esi, esi
  00051	74 29		 je	 SHORT $LN14@Serialize
$LL11@Serialize:

; 81   : 		{
; 82   : 			UINT nElementsToWrite;
; 83   : 
; 84   : 			nElementsToWrite = UINT(__min(nElementsLeft, INT_MAX/sizeof(TYPE)));

  00053	bb ff ff ff 0f	 mov	 ebx, 268435455		; 0fffffffH
  00058	3b f3		 cmp	 esi, ebx
  0005a	0f 42 de	 cmovb	 ebx, esi

; 85   : 			ar.Write(pData, nElementsToWrite*sizeof(TYPE));

  0005d	8d 3c dd 00 00
	00 00		 lea	 edi, DWORD PTR [ebx*8]
  00064	57		 push	 edi
  00065	51		 push	 ecx
  00066	8b ca		 mov	 ecx, edx
  00068	e8 00 00 00 00	 call	 ?Write@CArchive@@QAEXPBXI@Z ; CArchive::Write

; 86   : 			nElementsLeft -= nElementsToWrite;
; 87   : 			pData += nElementsToWrite;

  0006d	8b 4d fc	 mov	 ecx, DWORD PTR _pData$1$[ebp]
  00070	8b 55 08	 mov	 edx, DWORD PTR _ar$[ebp]
  00073	03 cf		 add	 ecx, edi
  00075	89 4d fc	 mov	 DWORD PTR _pData$1$[ebp], ecx
  00078	2b f3		 sub	 esi, ebx
  0007a	75 d7		 jne	 SHORT $LL11@Serialize
$LN14@Serialize:
  0007c	5f		 pop	 edi

; 647  : }

  0007d	5e		 pop	 esi
  0007e	5b		 pop	 ebx
  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c2 04 00	 ret	 4
$LN16@Serialize:

; 97   : 		while( nElementsLeft > 0 )

  00085	85 f6		 test	 esi, esi
  00087	74 f3		 je	 SHORT $LN14@Serialize
  00089	0f 1f 80 00 00
	00 00		 npad	 7
$LL13@Serialize:

; 98   : 		{
; 99   : 			UINT nElementsToRead;
; 100  : 
; 101  : 			nElementsToRead = UINT(__min(nElementsLeft, INT_MAX/sizeof(TYPE)));

  00090	bf ff ff ff 0f	 mov	 edi, 268435455		; 0fffffffH
  00095	3b f7		 cmp	 esi, edi
  00097	0f 42 fe	 cmovb	 edi, esi

; 102  : 			ar.EnsureRead(pData, nElementsToRead*sizeof(TYPE));

  0009a	8d 1c fd 00 00
	00 00		 lea	 ebx, DWORD PTR [edi*8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 399  : 	UINT nRead=Read(lpBuf, nCount);

  000a1	53		 push	 ebx
  000a2	51		 push	 ecx
  000a3	8b ca		 mov	 ecx, edx
  000a5	e8 00 00 00 00	 call	 ?Read@CArchive@@QAEIPAXI@Z ; CArchive::Read

; 400  : 	if(nRead!=nCount)

  000aa	3b c3		 cmp	 eax, ebx
  000ac	75 18		 jne	 SHORT $LN30@Serialize
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 97   : 		while( nElementsLeft > 0 )

  000ae	8b 4d fc	 mov	 ecx, DWORD PTR _pData$1$[ebp]
  000b1	8b 55 08	 mov	 edx, DWORD PTR _ar$[ebp]

; 103  : 			nElementsLeft -= nElementsToRead;
; 104  : 			pData += nElementsToRead;

  000b4	03 cb		 add	 ecx, ebx
  000b6	89 4d fc	 mov	 DWORD PTR _pData$1$[ebp], ecx
  000b9	2b f7		 sub	 esi, edi
  000bb	75 d3		 jne	 SHORT $LL13@Serialize

; 647  : }

  000bd	5f		 pop	 edi
  000be	5e		 pop	 esi
  000bf	5b		 pop	 ebx
  000c0	8b e5		 mov	 esp, ebp
  000c2	5d		 pop	 ebp
  000c3	c2 04 00	 ret	 4
$LN30@Serialize:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 402  : 		AfxThrowArchiveException(CArchiveException::endOfFile);

  000c6	6a 00		 push	 0
  000c8	6a 03		 push	 3
  000ca	e8 00 00 00 00	 call	 ?AfxThrowArchiveException@@YGXHPBD@Z ; AfxThrowArchiveException
$LN40@Serialize:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 68   : 	ENSURE(nCount == 0 || pElements != NULL);

  000cf	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN38@Serialize:
  000d4	cc		 int	 3
?Serialize@?$CArray@NN@@UAEXAAVCArchive@@@Z ENDP	; CArray<double,double>::Serialize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ??1?$CArray@NN@@UAE@XZ
_TEXT	SEGMENT
??1?$CArray@NN@@UAE@XZ PROC				; CArray<double,double>::~CArray<double,double>, COMDAT
; _this$ = ecx

; 356  : 	ASSERT_VALID(this);
; 357  : 
; 358  : 	if (m_pData != NULL)

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CArray@NN@@6B@
  00009	85 c0		 test	 eax, eax
  0000b	74 07		 je	 SHORT $LN5@CArray

; 359  : 	{
; 360  : 		for( int i = 0; i < m_nSize; i++ )
; 361  : 			(m_pData + i)->~TYPE();
; 362  : 		delete[] (BYTE*)m_pData;

  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00013	59		 pop	 ecx
$LN5@CArray:

; 363  : 	}
; 364  : }

  00014	c3		 ret	 0
??1?$CArray@NN@@UAE@XZ ENDP				; CArray<double,double>::~CArray<double,double>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ?SetAtGrow@?$CArray@NN@@QAEXHN@Z
_TEXT	SEGMENT
_nIndex$ = 8						; size = 4
_newElement$ = 12					; size = 8
?SetAtGrow@?$CArray@NN@@QAEXHN@Z PROC			; CArray<double,double>::SetAtGrow, COMDAT
; _this$ = ecx

; 534  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 535  : 	ASSERT_VALID(this);
; 536  : 	ASSERT(nIndex >= 0);
; 537  : 
; 538  : 	if(nIndex < 0)

  00004	8b 75 08	 mov	 esi, DWORD PTR _nIndex$[ebp]
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
  0000a	85 f6		 test	 esi, esi
  0000c	78 23		 js	 SHORT $LN7@SetAtGrow

; 540  : 
; 541  : 	if (nIndex >= m_nSize)

  0000e	3b 77 08	 cmp	 esi, DWORD PTR [edi+8]
  00011	7c 0b		 jl	 SHORT $LN3@SetAtGrow

; 542  : 		SetSize(nIndex+1, -1);

  00013	6a ff		 push	 -1
  00015	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ?SetSize@?$CArray@NN@@QAEXHH@Z ; CArray<double,double>::SetSize
$LN3@SetAtGrow:

; 543  : 	m_pData[nIndex] = newElement;

  0001e	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00021	f2 0f 10 45 0c	 movsd	 xmm0, QWORD PTR _newElement$[ebp]
  00026	5f		 pop	 edi
  00027	f2 0f 11 04 f0	 movsd	 QWORD PTR [eax+esi*8], xmm0
  0002c	5e		 pop	 esi

; 544  : }

  0002d	5d		 pop	 ebp
  0002e	c2 0c 00	 ret	 12			; 0000000cH
$LN7@SetAtGrow:

; 539  : 		AfxThrowInvalidArgException();

  00031	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN5@SetAtGrow:
  00036	cc		 int	 3
?SetAtGrow@?$CArray@NN@@QAEXHN@Z ENDP			; CArray<double,double>::SetAtGrow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_memcpy_s.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlchecked.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_memcpy_s.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlchecked.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_memcpy_s.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ?SetSize@?$CArray@NN@@QAEXHH@Z
_TEXT	SEGMENT
__N$1$ = -4						; size = 4
__S2$1$ = 8						; size = 4
_nNewSize$ = 8						; size = 4
_pNewData$1$ = 12					; size = 4
_nGrowBy$ = 12						; size = 4
?SetSize@?$CArray@NN@@QAEXHH@Z PROC			; CArray<double,double>::SetSize, COMDAT
; _this$ = ecx

; 368  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi

; 369  : 	ASSERT_VALID(this);
; 370  : 	ASSERT(nNewSize >= 0);
; 371  : 
; 372  : 	if(nNewSize < 0 )

  00006	8b 75 08	 mov	 esi, DWORD PTR _nNewSize$[ebp]
  00009	8b d9		 mov	 ebx, ecx
  0000b	57		 push	 edi
  0000c	85 f6		 test	 esi, esi
  0000e	0f 88 c2 01 00
	00		 js	 $LN70@SetSize

; 373  : 		AfxThrowInvalidArgException();
; 374  : 
; 375  : 	if (nGrowBy >= 0)

  00014	8b 45 0c	 mov	 eax, DWORD PTR _nGrowBy$[ebp]
  00017	85 c0		 test	 eax, eax
  00019	78 03		 js	 SHORT $LN69@SetSize

; 376  : 		m_nGrowBy = nGrowBy;  // set new size

  0001b	89 43 10	 mov	 DWORD PTR [ebx+16], eax
$LN69@SetSize:

; 377  : 
; 378  : 	if (nNewSize == 0)

  0001e	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00021	85 f6		 test	 esi, esi
  00023	75 27		 jne	 SHORT $LN19@SetSize

; 379  : 	{
; 380  : 		// shrink to nothing
; 381  : 		if (m_pData != NULL)

  00025	85 c9		 test	 ecx, ecx
  00027	74 0c		 je	 SHORT $LN21@SetSize

; 382  : 		{
; 383  : 			for( int i = 0; i < m_nSize; i++ )
; 384  : 				(m_pData + i)->~TYPE();
; 385  : 			delete[] (BYTE*)m_pData;

  00029	51		 push	 ecx
  0002a	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0002f	83 c4 04	 add	 esp, 4

; 386  : 			m_pData = NULL;

  00032	89 73 04	 mov	 DWORD PTR [ebx+4], esi
$LN21@SetSize:

; 472  : 		m_nSize = nNewSize;
; 473  : 		m_nMaxSize = nNewMax;
; 474  : 	}
; 475  : }

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	c7 43 0c 00 00
	00 00		 mov	 DWORD PTR [ebx+12], 0
  0003e	c7 43 08 00 00
	00 00		 mov	 DWORD PTR [ebx+8], 0
  00045	5b		 pop	 ebx
  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c2 08 00	 ret	 8
$LN19@SetSize:

; 387  : 		}
; 388  : 		m_nSize = m_nMaxSize = 0;
; 389  : 	}
; 390  : 	else if (m_pData == NULL)

  0004c	85 c9		 test	 ecx, ecx
  0004e	75 36		 jne	 SHORT $LN22@SetSize

; 391  : 	{
; 392  : 		// create buffer big enough to hold number of requested elements or
; 393  : 		// m_nGrowBy elements, whichever is larger.
; 394  : #ifdef SIZE_T_MAX
; 395  : 		ASSERT(nNewSize <= SIZE_T_MAX/sizeof(TYPE));    // no overflow
; 396  : #endif
; 397  : 		size_t nAllocSize = __max(nNewSize, m_nGrowBy);

  00050	8b 7b 10	 mov	 edi, DWORD PTR [ebx+16]
  00053	3b f7		 cmp	 esi, edi
  00055	0f 4f fe	 cmovg	 edi, esi

; 398  : 		m_pData = (TYPE*) new BYTE[(size_t)nAllocSize * sizeof(TYPE)];

  00058	8d 34 fd 00 00
	00 00		 lea	 esi, DWORD PTR [edi*8]
  0005f	56		 push	 esi
  00060	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]

; 399  : 		memset((void*)m_pData, 0, (size_t)nAllocSize * sizeof(TYPE));

  00065	56		 push	 esi
  00066	6a 00		 push	 0
  00068	50		 push	 eax
  00069	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  0006c	e8 00 00 00 00	 call	 _memset

; 400  : 		for( int i = 0; i < nNewSize; i++ )
; 401  : #pragma push_macro("new")
; 402  : #undef new
; 403  : 			::new( (void*)( m_pData + i ) ) TYPE;
; 404  : #pragma pop_macro("new")
; 405  : 		m_nSize = nNewSize;

  00071	8b 45 08	 mov	 eax, DWORD PTR _nNewSize$[ebp]
  00074	83 c4 10	 add	 esp, 16			; 00000010H

; 472  : 		m_nSize = nNewSize;
; 473  : 		m_nMaxSize = nNewMax;
; 474  : 	}
; 475  : }

  00077	89 7b 0c	 mov	 DWORD PTR [ebx+12], edi
  0007a	89 43 08	 mov	 DWORD PTR [ebx+8], eax
  0007d	5f		 pop	 edi
  0007e	5e		 pop	 esi
  0007f	5b		 pop	 ebx
  00080	8b e5		 mov	 esp, ebp
  00082	5d		 pop	 ebp
  00083	c2 08 00	 ret	 8
$LN22@SetSize:

; 406  : 		m_nMaxSize = nAllocSize;
; 407  : 	}
; 408  : 	else if (nNewSize <= m_nMaxSize)

  00086	8b 7b 0c	 mov	 edi, DWORD PTR [ebx+12]
  00089	3b f7		 cmp	 esi, edi
  0008b	7f 29		 jg	 SHORT $LN24@SetSize

; 409  : 	{
; 410  : 		// it fits
; 411  : 		if (nNewSize > m_nSize)

  0008d	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]
  00090	3b f2		 cmp	 esi, edx
  00092	7e 16		 jle	 SHORT $LN26@SetSize

; 412  : 		{
; 413  : 			// initialize the new elements
; 414  : 			memset((void*)(m_pData + m_nSize), 0, (size_t)(nNewSize-m_nSize) * sizeof(TYPE));

  00094	8b c6		 mov	 eax, esi
  00096	2b c2		 sub	 eax, edx
  00098	c1 e0 03	 shl	 eax, 3
  0009b	50		 push	 eax
  0009c	8d 04 d1	 lea	 eax, DWORD PTR [ecx+edx*8]
  0009f	6a 00		 push	 0
  000a1	50		 push	 eax
  000a2	e8 00 00 00 00	 call	 _memset
  000a7	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN26@SetSize:

; 415  : 			for( int i = 0; i < nNewSize-m_nSize; i++ )
; 416  : #pragma push_macro("new")
; 417  : #undef new
; 418  : 				::new( (void*)( m_pData + m_nSize + i ) ) TYPE;
; 419  : #pragma pop_macro("new")
; 420  : 		}
; 421  : 		else if (m_nSize > nNewSize)
; 422  : 		{
; 423  : 			// destroy the old elements
; 424  : 			for( int i = 0; i < m_nSize-nNewSize; i++ )
; 425  : 				(m_pData + nNewSize + i)->~TYPE();
; 426  : 		}
; 427  : 		m_nSize = nNewSize;

  000aa	5f		 pop	 edi
  000ab	89 73 08	 mov	 DWORD PTR [ebx+8], esi

; 472  : 		m_nSize = nNewSize;
; 473  : 		m_nMaxSize = nNewMax;
; 474  : 	}
; 475  : }

  000ae	5e		 pop	 esi
  000af	5b		 pop	 ebx
  000b0	8b e5		 mov	 esp, ebp
  000b2	5d		 pop	 ebp
  000b3	c2 08 00	 ret	 8
$LN24@SetSize:

; 428  : 	}
; 429  : 	else
; 430  : 	{
; 431  : 		// otherwise, grow array
; 432  : 		nGrowBy = m_nGrowBy;

  000b6	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]

; 433  : 		if (nGrowBy == 0)

  000b9	85 c0		 test	 eax, eax
  000bb	75 22		 jne	 SHORT $LN37@SetSize

; 434  : 		{
; 435  : 			// heuristically determine growth when nGrowBy == 0
; 436  : 			//  (this avoids heap fragmentation in many situations)
; 437  : 			nGrowBy = m_nSize / 8;

  000bd	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  000c0	99		 cdq
  000c1	83 e2 07	 and	 edx, 7
  000c4	03 c2		 add	 eax, edx
  000c6	c1 f8 03	 sar	 eax, 3

; 438  : 			nGrowBy = (nGrowBy < 4) ? 4 : ((nGrowBy > 1024) ? 1024 : nGrowBy);

  000c9	83 f8 04	 cmp	 eax, 4
  000cc	7d 07		 jge	 SHORT $LN36@SetSize
  000ce	b8 04 00 00 00	 mov	 eax, 4
  000d3	eb 0a		 jmp	 SHORT $LN37@SetSize
$LN36@SetSize:
  000d5	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  000da	3b c1		 cmp	 eax, ecx
  000dc	0f 4f c1	 cmovg	 eax, ecx
$LN37@SetSize:

; 439  : 		}
; 440  : 		INT_PTR nNewMax;
; 441  : 		if (nNewSize < m_nMaxSize + nGrowBy)

  000df	03 f8		 add	 edi, eax
  000e1	3b f7		 cmp	 esi, edi
  000e3	7d 0b		 jge	 SHORT $LN30@SetSize

; 445  : 
; 446  : 		ASSERT(nNewMax >= m_nMaxSize);  // no wrap around
; 447  : 
; 448  : 		if(nNewMax  < m_nMaxSize)

  000e5	3b 7b 0c	 cmp	 edi, DWORD PTR [ebx+12]
  000e8	0f 8c e8 00 00
	00		 jl	 $LN70@SetSize
  000ee	eb 02		 jmp	 SHORT $LN32@SetSize
$LN30@SetSize:

; 442  : 			nNewMax = m_nMaxSize + nGrowBy;  // granularity
; 443  : 		else
; 444  : 			nNewMax = nNewSize;  // no slush

  000f0	8b fe		 mov	 edi, esi
$LN32@SetSize:

; 450  : 
; 451  : #ifdef SIZE_T_MAX
; 452  : 		ASSERT(nNewMax <= SIZE_T_MAX/sizeof(TYPE)); // no overflow
; 453  : #endif
; 454  : 		TYPE* pNewData = (TYPE*) new BYTE[(size_t)nNewMax * sizeof(TYPE)];

  000f2	8d 04 fd 00 00
	00 00		 lea	 eax, DWORD PTR [edi*8]
  000f9	50		 push	 eax
  000fa	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]

; 455  : 
; 456  : 		// copy new data from old
; 457  : 		::ATL::Checked::memcpy_s(pNewData, (size_t)nNewMax * sizeof(TYPE),

  000ff	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  00102	8b c8		 mov	 ecx, eax
  00104	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  00107	83 c4 04	 add	 esp, 4
  0010a	c1 e0 03	 shl	 eax, 3
  0010d	89 4d 0c	 mov	 DWORD PTR _pNewData$1$[ebp], ecx
  00110	89 45 fc	 mov	 DWORD PTR __N$1$[ebp], eax
  00113	89 55 08	 mov	 DWORD PTR __S2$1$[ebp], edx
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_memcpy_s.h

; 46   :         if (_SourceSize == 0)

  00116	85 c0		 test	 eax, eax
  00118	74 76		 je	 SHORT $LN74@SetSize

; 47   :         {
; 48   :             return 0;
; 49   :         }
; 50   : 
; 51   :         _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Destination != NULL, EINVAL);

  0011a	85 c9		 test	 ecx, ecx
  0011c	75 56		 jne	 SHORT $LN42@SetSize
$LN73@SetSize:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlchecked.h

; 69   : 	ATLMFC_CRT_ERRORCHECK(::memcpy_s(_S1, _S1max, _S2, _N));

  0011e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___errno
  00124	c7 00 16 00 00
	00		 mov	 DWORD PTR [eax], 22	; 00000016H
  0012a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo
$LN46@SetSize:
  00130	b8 16 00 00 00	 mov	 eax, 22			; 00000016H
$LN40@SetSize:
  00135	50		 push	 eax
  00136	e8 00 00 00 00	 call	 ?AfxCrtErrorCheck@@YAHH@Z ; AfxCrtErrorCheck
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 462  : 		memset((void*)(pNewData + m_nSize), 0, (size_t)(nNewSize-m_nSize) * sizeof(TYPE));

  0013b	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  0013e	8b c6		 mov	 eax, esi
  00140	2b c1		 sub	 eax, ecx
  00142	c1 e0 03	 shl	 eax, 3
  00145	50		 push	 eax
  00146	8b 45 0c	 mov	 eax, DWORD PTR _pNewData$1$[ebp]
  00149	6a 00		 push	 0
  0014b	8d 04 c8	 lea	 eax, DWORD PTR [eax+ecx*8]
  0014e	50		 push	 eax
  0014f	e8 00 00 00 00	 call	 _memset

; 463  : 		for( int i = 0; i < nNewSize-m_nSize; i++ )
; 464  : #pragma push_macro("new")
; 465  : #undef new
; 466  : 			::new( (void*)( pNewData + m_nSize + i ) ) TYPE;
; 467  : #pragma pop_macro("new")
; 468  : 
; 469  : 		// get rid of old stuff (note: no destructors called)
; 470  : 		delete[] (BYTE*)m_pData;

  00154	ff 73 04	 push	 DWORD PTR [ebx+4]
  00157	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]

; 471  : 		m_pData = pNewData;

  0015c	8b 45 0c	 mov	 eax, DWORD PTR _pNewData$1$[ebp]
  0015f	83 c4 14	 add	 esp, 20			; 00000014H

; 472  : 		m_nSize = nNewSize;
; 473  : 		m_nMaxSize = nNewMax;
; 474  : 	}
; 475  : }

  00162	89 7b 0c	 mov	 DWORD PTR [ebx+12], edi
  00165	89 73 08	 mov	 DWORD PTR [ebx+8], esi
  00168	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  0016b	5f		 pop	 edi
  0016c	5e		 pop	 esi
  0016d	5b		 pop	 ebx
  0016e	8b e5		 mov	 esp, ebp
  00170	5d		 pop	 ebp
  00171	c2 08 00	 ret	 8
$LN42@SetSize:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_memcpy_s.h

; 52   :         if (_Source == NULL || _DestinationSize < _SourceSize)

  00174	85 d2		 test	 edx, edx
  00176	8d 14 fd 00 00
	00 00		 lea	 edx, DWORD PTR [edi*8]
  0017d	74 15		 je	 SHORT $LN44@SetSize
  0017f	3b d0		 cmp	 edx, eax
  00181	72 11		 jb	 SHORT $LN44@SetSize

; 58   : 
; 59   :             // Unreachable, but required to suppress /analyze warnings:
; 60   :             return EINVAL;
; 61   :         }
; 62   :         memcpy(_Destination, _Source, _SourceSize);

  00183	50		 push	 eax
  00184	ff 75 08	 push	 DWORD PTR __S2$1$[ebp]
  00187	51		 push	 ecx
  00188	e8 00 00 00 00	 call	 _memcpy
  0018d	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN74@SetSize:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlchecked.h

; 69   : 	ATLMFC_CRT_ERRORCHECK(::memcpy_s(_S1, _S1max, _S2, _N));

  00190	33 c0		 xor	 eax, eax
  00192	eb a1		 jmp	 SHORT $LN40@SetSize
$LN44@SetSize:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_memcpy_s.h

; 54   :             memset(_Destination, 0, _DestinationSize);

  00194	52		 push	 edx
  00195	6a 00		 push	 0
  00197	51		 push	 ecx
  00198	e8 00 00 00 00	 call	 _memset
  0019d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 55   : 
; 56   :             _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Source != NULL,                 EINVAL);

  001a0	83 7d 08 00	 cmp	 DWORD PTR __S2$1$[ebp], 0
  001a4	0f 84 74 ff ff
	ff		 je	 $LN73@SetSize

; 57   :             _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_DestinationSize >= _SourceSize, ERANGE);

  001aa	8d 04 fd 00 00
	00 00		 lea	 eax, DWORD PTR [edi*8]
  001b1	3b 45 fc	 cmp	 eax, DWORD PTR __N$1$[ebp]
  001b4	0f 83 76 ff ff
	ff		 jae	 $LN46@SetSize
  001ba	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___errno
  001c0	c7 00 22 00 00
	00		 mov	 DWORD PTR [eax], 34	; 00000022H
  001c6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo
  001cc	b8 22 00 00 00	 mov	 eax, 34			; 00000022H
  001d1	e9 5f ff ff ff	 jmp	 $LN40@SetSize
$LN70@SetSize:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 449  : 			AfxThrowInvalidArgException();

  001d6	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN72@SetSize:
  001db	cc		 int	 3
?SetSize@?$CArray@NN@@QAEXHH@Z ENDP			; CArray<double,double>::SetSize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ??0?$CArray@NN@@QAE@XZ
_TEXT	SEGMENT
??0?$CArray@NN@@QAE@XZ PROC				; CArray<double,double>::CArray<double,double>, COMDAT
; _this$ = ecx

; 348  : {

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CArray@NN@@6B@

; 349  : 	m_pData = NULL;
; 350  : 	m_nSize = m_nMaxSize = m_nGrowBy = 0;
; 351  : }

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  00016	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0
  0001d	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00024	c3		 ret	 0
??0?$CArray@NN@@QAE@XZ ENDP				; CArray<double,double>::CArray<double,double>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1_GV_ITEM@@QAE@XZ
_TEXT	SEGMENT
??1_GV_ITEM@@QAE@XZ PROC				; _GV_ITEM::~_GV_ITEM, COMDAT
; _this$ = ecx
  00000	83 c1 64	 add	 ecx, 100		; 00000064H
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
??1_GV_ITEM@@QAE@XZ ENDP				; _GV_ITEM::~_GV_ITEM
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
;	COMDAT ??_GCEscDialog@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCEscDialog@@UAEPAXI@Z PROC				; CEscDialog::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CDialog@@UAE@XZ	; CDialog::~CDialog
  0000b	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  0000e	a8 01		 test	 al, 1
  00010	74 22		 je	 SHORT $LN12@scalar
  00012	a8 04		 test	 al, 4
  00014	75 10		 jne	 SHORT $LN3@scalar

; 112  : 	{ ::operator delete(p); }

  00016	56		 push	 esi
  00017	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001c	83 c4 04	 add	 esp, 4
  0001f	8b c6		 mov	 eax, esi
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
$LN3@scalar:
  00026	68 a8 00 00 00	 push	 168			; 000000a8H
  0002b	56		 push	 esi
  0002c	e8 00 00 00 00	 call	 ?__global_delete@@YAXPAXI@Z ; __global_delete
  00031	83 c4 08	 add	 esp, 8
$LN12@scalar:
  00034	8b c6		 mov	 eax, esi
  00036	5e		 pop	 esi
  00037	5d		 pop	 ebp
  00038	c2 04 00	 ret	 4
??_GCEscDialog@@UAEPAXI@Z ENDP				; CEscDialog::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1CEscDialog@@UAE@XZ
_TEXT	SEGMENT
??1CEscDialog@@UAE@XZ PROC				; CEscDialog::~CEscDialog, COMDAT
; _this$ = ecx
  00000	e9 00 00 00 00	 jmp	 ??1CDialog@@UAE@XZ	; CDialog::~CDialog
??1CEscDialog@@UAE@XZ ENDP				; CEscDialog::~CEscDialog
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\Common_ST\EscDialog.h
;	COMDAT ?PreTranslateMessage@CEscDialog@@MAEHPAUtagMSG@@@Z
_TEXT	SEGMENT
_pMsg$ = 8						; size = 4
?PreTranslateMessage@CEscDialog@@MAEHPAUtagMSG@@@Z PROC	; CEscDialog::PreTranslateMessage, COMDAT
; _this$ = ecx

; 40   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 41   : 	//     		JSJ_Modify_040421
; 42   : 	if(pMsg->message == WM_KEYDOWN)   

  00004	8b 75 08	 mov	 esi, DWORD PTR _pMsg$[ebp]
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
  0000a	81 7e 04 00 01
	00 00		 cmp	 DWORD PTR [esi+4], 256	; 00000100H
  00011	75 42		 jne	 SHORT $LN4@PreTransla

; 43   : 	{
; 44   : 		if(pMsg->wParam == VK_F4 && (::GetKeyState(VK_CONTROL) & 0x8000))

  00013	83 7e 08 73	 cmp	 DWORD PTR [esi+8], 115	; 00000073H
  00017	75 36		 jne	 SHORT $LN11@PreTransla
  00019	6a 11		 push	 17			; 00000011H
  0001b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetKeyState@4
  00021	66 0f ba e0 0f	 bt	 ax, 15			; 0000000fH
  00026	73 27		 jae	 SHORT $LN11@PreTransla

; 45   : 		{
; 46   : 			pMsg->wParam = VK_ESCAPE;

  00028	c7 46 08 1b 00
	00 00		 mov	 DWORD PTR [esi+8], 27	; 0000001bH
$LN12@PreTransla:

; 56   : }

  0002f	ff 77 20	 push	 DWORD PTR [edi+32]
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetParent@4
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 ?FromHandle@CWnd@@SGPAV1@PAUHWND__@@@Z ; CWnd::FromHandle
  0003e	56		 push	 esi
  0003f	8b c8		 mov	 ecx, eax
  00041	8b 10		 mov	 edx, DWORD PTR [eax]
  00043	ff 92 14 01 00
	00		 call	 DWORD PTR [edx+276]
  00049	5f		 pop	 edi
  0004a	5e		 pop	 esi
  0004b	5d		 pop	 ebp
  0004c	c2 04 00	 ret	 4
$LN11@PreTransla:

; 47   : 			return GetParent()->PreTranslateMessage(pMsg);
; 48   : 		}
; 49   : 		if(pMsg->wParam == VK_ESCAPE)

  0004f	83 7e 08 1b	 cmp	 DWORD PTR [esi+8], 27	; 0000001bH
  00053	74 da		 je	 SHORT $LN12@PreTransla
$LN4@PreTransla:

; 50   : 		{
; 51   : 			return GetParent()->PreTranslateMessage(pMsg);
; 52   : 		}
; 53   : 	}
; 54   : 	
; 55   : 	return CDialog::PreTranslateMessage(pMsg);

  00055	56		 push	 esi
  00056	8b cf		 mov	 ecx, edi
  00058	e8 00 00 00 00	 call	 ?PreTranslateMessage@CDialog@@UAEHPAUtagMSG@@@Z ; CDialog::PreTranslateMessage
  0005d	5f		 pop	 edi

; 56   : }

  0005e	5e		 pop	 esi
  0005f	5d		 pop	 ebp
  00060	c2 04 00	 ret	 4
?PreTranslateMessage@CEscDialog@@MAEHPAUtagMSG@@@Z ENDP	; CEscDialog::PreTranslateMessage
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\inc\IBaseDefine.h
;	COMDAT ?AfxGetPctrData@@YGJH@Z
_TEXT	SEGMENT
_hMainWnd$ = -36					; size = 4
_szClipFormat$2 = -32					; size = 4
_aBufWnd$3 = -28					; size = 9
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_nID$ = 8						; size = 4
?AfxGetPctrData@@YGJH@Z PROC				; AfxGetPctrData, COMDAT

; 270  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?AfxGetPctrData@@YGJH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 18	 sub	 esp, 24			; 00000018H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	0f 57 c0	 xorps	 xmm0, xmm0

; 271  : 	HWND hMainWnd;
; 272  : 	AfxGetHanaroMainWnd(hMainWnd);

  0002b	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _hMainWnd$[ebp], 0
  00032	8d 4d e0	 lea	 ecx, DWORD PTR _szClipFormat$2[ebp]
  00035	66 0f d6 45 e4	 movq	 QWORD PTR _aBufWnd$3[ebp], xmm0
  0003a	c6 45 ec 00	 mov	 BYTE PTR _aBufWnd$3[ebp+8], 0
  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00044	68 00 00 00 00	 push	 OFFSET ??_C@_0M@CBBNGGHM@PcTrMng?4dll@
  00049	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleHandleA@4
  00056	50		 push	 eax
  00057	68 00 00 00 00	 push	 OFFSET ??_C@_0P@IDMAJEGN@HANAROPCTRMAIN@
  0005c	8d 45 e0	 lea	 eax, DWORD PTR _szClipFormat$2[ebp]
  0005f	68 00 00 00 00	 push	 OFFSET ??_C@_06NDLAHCHE@?$CFs?$CF08X@
  00064	50		 push	 eax
  00065	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Format@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAAXPBDZZ
  0006b	83 c4 10	 add	 esp, 16			; 00000010H
  0006e	8d 45 e4	 lea	 eax, DWORD PTR _aBufWnd$3[ebp]
  00071	6a 09		 push	 9
  00073	50		 push	 eax
  00074	ff 75 e0	 push	 DWORD PTR _szClipFormat$2[ebp]
  00077	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetEnvironmentVariableA@12
  0007d	8d 45 dc	 lea	 eax, DWORD PTR _hMainWnd$[ebp]
  00080	50		 push	 eax
  00081	8d 45 e4	 lea	 eax, DWORD PTR _aBufWnd$3[ebp]
  00084	68 00 00 00 00	 push	 OFFSET ??_C@_02EMFKHFLK@?$CFX@
  00089	50		 push	 eax
  0008a	e8 00 00 00 00	 call	 _sscanf
  0008f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00092	8d 4d e0	 lea	 ecx, DWORD PTR _szClipFormat$2[ebp]
  00095	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 273  : 
; 274  : 	return ::SendMessage(hMainWnd, RMSG_GETPCTRDATA, (WPARAM)'A', (LPARAM)nID);

  0009b	ff 75 08	 push	 DWORD PTR _nID$[ebp]
  0009e	6a 41		 push	 65			; 00000041H
  000a0	ff 35 00 00 00
	00		 push	 DWORD PTR ?RMSG_GETPCTRDATA@@3IB
  000a6	ff 75 dc	 push	 DWORD PTR _hMainWnd$[ebp]
  000a9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16

; 275  : }

  000af	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000b2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000b9	59		 pop	 ecx
  000ba	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000bd	33 cd		 xor	 ecx, ebp
  000bf	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c4	8b e5		 mov	 esp, ebp
  000c6	5d		 pop	 ebp
  000c7	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AfxGetPctrData@@YGJH@Z$0:
  00000	8d 4d e0	 lea	 ecx, DWORD PTR _szClipFormat$2[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
  0000d	cc		 int	 3
__ehhandler$?AfxGetPctrData@@YGJH@Z:
  0000e	90		 npad	 1
  0000f	90		 npad	 1
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00024	33 c8		 xor	 ecx, eax
  00026	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?AfxGetPctrData@@YGJH@Z
  00030	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?AfxGetPctrData@@YGJH@Z ENDP				; AfxGetPctrData
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\inc\IBaseDefine.h
;	COMDAT ??__ERMSG_GETPCTRDATA@@YAXXZ
text$di	SEGMENT
??__ERMSG_GETPCTRDATA@@YAXXZ PROC			; `dynamic initializer for 'RMSG_GETPCTRDATA'', COMDAT

; 171  : const UINT RMSG_GETPCTRDATA = ::RegisterWindowMessage("RMSG_GETPCTRDATA");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@GOOPDKI@RMSG_GETPCTRDATA@
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegisterWindowMessageA@4
  0000b	a3 00 00 00 00	 mov	 DWORD PTR ?RMSG_GETPCTRDATA@@3IB, eax
  00010	c3		 ret	 0
??__ERMSG_GETPCTRDATA@@YAXXZ ENDP			; `dynamic initializer for 'RMSG_GETPCTRDATA''
text$di	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
;	COMDAT ??_GCListBox@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCListBox@@UAEPAXI@Z PROC				; CListBox::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CListBox@@UAE@XZ	; CListBox::~CListBox
  0000b	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  0000e	a8 01		 test	 al, 1
  00010	74 22		 je	 SHORT $LN9@scalar
  00012	a8 04		 test	 al, 4
  00014	75 10		 jne	 SHORT $LN3@scalar

; 112  : 	{ ::operator delete(p); }

  00016	56		 push	 esi
  00017	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001c	83 c4 04	 add	 esp, 4
  0001f	8b c6		 mov	 eax, esi
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
$LN3@scalar:
  00026	68 80 00 00 00	 push	 128			; 00000080H
  0002b	56		 push	 esi
  0002c	e8 00 00 00 00	 call	 ?__global_delete@@YAXPAXI@Z ; __global_delete
  00031	83 c4 08	 add	 esp, 8
$LN9@scalar:
  00034	8b c6		 mov	 eax, esi
  00036	5e		 pop	 esi
  00037	5d		 pop	 ebp
  00038	c2 04 00	 ret	 4
??_GCListBox@@UAEPAXI@Z ENDP				; CListBox::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
;	COMDAT ?GetCount@CListBox@@QBEHXZ
_TEXT	SEGMENT
?GetCount@CListBox@@QBEHXZ PROC				; CListBox::GetCount, COMDAT
; _this$ = ecx

; 664  : 	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_GETCOUNT, 0, 0); }

  00000	6a 00		 push	 0
  00002	6a 00		 push	 0
  00004	68 8b 01 00 00	 push	 395			; 0000018bH
  00009	ff 71 20	 push	 DWORD PTR [ecx+32]
  0000c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16
  00012	c3		 ret	 0
?GetCount@CListBox@@QBEHXZ ENDP				; CListBox::GetCount
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
;	COMDAT ?Create@CDialog@@UAEHIPAVCWnd@@@Z
_TEXT	SEGMENT
_nIDTemplate$ = 8					; size = 4
_pParentWnd$ = 12					; size = 4
?Create@CDialog@@UAEHIPAVCWnd@@@Z PROC			; CDialog::Create, COMDAT
; _this$ = ecx

; 585  : 	{ return CDialog::Create(ATL_MAKEINTRESOURCE(nIDTemplate), pParentWnd); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	0f b7 45 08	 movzx	 eax, WORD PTR _nIDTemplate$[ebp]
  00007	89 45 08	 mov	 DWORD PTR _nIDTemplate$[ebp], eax
  0000a	5d		 pop	 ebp
  0000b	e9 00 00 00 00	 jmp	 ?Create@CDialog@@UAEHPBDPAVCWnd@@@Z ; CDialog::Create
?Create@CDialog@@UAEHIPAVCWnd@@@Z ENDP			; CDialog::Create
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
;	COMDAT ?EndModalState@CWnd@@UAEXXZ
_TEXT	SEGMENT
?EndModalState@CWnd@@UAEXXZ PROC			; CWnd::EndModalState, COMDAT
; _this$ = ecx

; 567  : 	{ ::EnableWindow(m_hWnd, TRUE); }

  00000	6a 01		 push	 1
  00002	ff 71 20	 push	 DWORD PTR [ecx+32]
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnableWindow@8
  0000b	c3		 ret	 0
?EndModalState@CWnd@@UAEXXZ ENDP			; CWnd::EndModalState
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
;	COMDAT ?BeginModalState@CWnd@@UAEXXZ
_TEXT	SEGMENT
?BeginModalState@CWnd@@UAEXXZ PROC			; CWnd::BeginModalState, COMDAT
; _this$ = ecx

; 565  : 	{ ::EnableWindow(m_hWnd, FALSE); }

  00000	6a 00		 push	 0
  00002	ff 71 20	 push	 DWORD PTR [ecx+32]
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnableWindow@8
  0000b	c3		 ret	 0
?BeginModalState@CWnd@@UAEXXZ ENDP			; CWnd::BeginModalState
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin2.inl
;	COMDAT ?DoDataExchange@CWnd@@MAEXPAVCDataExchange@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?DoDataExchange@CWnd@@MAEXPAVCDataExchange@@@Z PROC	; CWnd::DoDataExchange, COMDAT
; _this$ = ecx

; 561  : 	{ } // default does nothing

  00000	c2 04 00	 ret	 4
?DoDataExchange@CWnd@@MAEXPAVCDataExchange@@@Z ENDP	; CWnd::DoDataExchange
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin1.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
;	COMDAT ??_GCBitmap@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCBitmap@@UAEPAXI@Z PROC				; CBitmap::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin1.inl

; 179  : 	{ }

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CBitmap@@6B@
  0000c	e8 00 00 00 00	 call	 ??1CGdiObject@@UAE@XZ	; CGdiObject::~CGdiObject
  00011	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00014	a8 01		 test	 al, 1
  00016	74 1f		 je	 SHORT $LN12@scalar
  00018	a8 04		 test	 al, 4
  0001a	75 10		 jne	 SHORT $LN3@scalar
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 112  : 	{ ::operator delete(p); }

  0001c	56		 push	 esi
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	83 c4 04	 add	 esp, 4
  00025	8b c6		 mov	 eax, esi
  00027	5e		 pop	 esi
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
$LN3@scalar:
  0002c	6a 08		 push	 8
  0002e	56		 push	 esi
  0002f	e8 00 00 00 00	 call	 ?__global_delete@@YAXPAXI@Z ; __global_delete
  00034	83 c4 08	 add	 esp, 8
$LN12@scalar:
  00037	8b c6		 mov	 eax, esi
  00039	5e		 pop	 esi
  0003a	5d		 pop	 ebp
  0003b	c2 04 00	 ret	 4
??_GCBitmap@@UAEPAXI@Z ENDP				; CBitmap::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin1.inl
;	COMDAT ??1CBitmap@@UAE@XZ
_TEXT	SEGMENT
??1CBitmap@@UAE@XZ PROC					; CBitmap::~CBitmap, COMDAT
; _this$ = ecx

; 179  : 	{ }

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CBitmap@@6B@
  00006	e9 00 00 00 00	 jmp	 ??1CGdiObject@@UAE@XZ	; CGdiObject::~CGdiObject
??1CBitmap@@UAE@XZ ENDP					; CBitmap::~CBitmap
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin1.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
;	COMDAT ??_GCFont@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCFont@@UAEPAXI@Z PROC				; CFont::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin1.inl

; 155  : 	{ }

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CFont@@6B@
  0000c	e8 00 00 00 00	 call	 ??1CGdiObject@@UAE@XZ	; CGdiObject::~CGdiObject
  00011	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00014	a8 01		 test	 al, 1
  00016	74 1f		 je	 SHORT $LN12@scalar
  00018	a8 04		 test	 al, 4
  0001a	75 10		 jne	 SHORT $LN3@scalar
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 112  : 	{ ::operator delete(p); }

  0001c	56		 push	 esi
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	83 c4 04	 add	 esp, 4
  00025	8b c6		 mov	 eax, esi
  00027	5e		 pop	 esi
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
$LN3@scalar:
  0002c	6a 08		 push	 8
  0002e	56		 push	 esi
  0002f	e8 00 00 00 00	 call	 ?__global_delete@@YAXPAXI@Z ; __global_delete
  00034	83 c4 08	 add	 esp, 8
$LN12@scalar:
  00037	8b c6		 mov	 eax, esi
  00039	5e		 pop	 esi
  0003a	5d		 pop	 ebp
  0003b	c2 04 00	 ret	 4
??_GCFont@@UAEPAXI@Z ENDP				; CFont::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin1.inl
;	COMDAT ??1CFont@@UAE@XZ
_TEXT	SEGMENT
??1CFont@@UAE@XZ PROC					; CFont::~CFont, COMDAT
; _this$ = ecx

; 155  : 	{ }

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CFont@@6B@
  00006	e9 00 00 00 00	 jmp	 ??1CGdiObject@@UAE@XZ	; CGdiObject::~CGdiObject
??1CFont@@UAE@XZ ENDP					; CFont::~CFont
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin1.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
;	COMDAT ??_GCBrush@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCBrush@@UAEPAXI@Z PROC				; CBrush::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin1.inl

; 130  : 	{ }

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CBrush@@6B@
  0000c	e8 00 00 00 00	 call	 ??1CGdiObject@@UAE@XZ	; CGdiObject::~CGdiObject
  00011	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00014	a8 01		 test	 al, 1
  00016	74 1f		 je	 SHORT $LN12@scalar
  00018	a8 04		 test	 al, 4
  0001a	75 10		 jne	 SHORT $LN3@scalar
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl

; 112  : 	{ ::operator delete(p); }

  0001c	56		 push	 esi
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	83 c4 04	 add	 esp, 4
  00025	8b c6		 mov	 eax, esi
  00027	5e		 pop	 esi
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
$LN3@scalar:
  0002c	6a 08		 push	 8
  0002e	56		 push	 esi
  0002f	e8 00 00 00 00	 call	 ?__global_delete@@YAXPAXI@Z ; __global_delete
  00034	83 c4 08	 add	 esp, 8
$LN12@scalar:
  00037	8b c6		 mov	 eax, esi
  00039	5e		 pop	 esi
  0003a	5d		 pop	 ebp
  0003b	c2 04 00	 ret	 4
??_GCBrush@@UAEPAXI@Z ENDP				; CBrush::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin1.inl
;	COMDAT ??1CBrush@@UAE@XZ
_TEXT	SEGMENT
??1CBrush@@UAE@XZ PROC					; CBrush::~CBrush, COMDAT
; _this$ = ecx

; 130  : 	{ }

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CBrush@@6B@
  00006	e9 00 00 00 00	 jmp	 ??1CGdiObject@@UAE@XZ	; CGdiObject::~CGdiObject
??1CBrush@@UAE@XZ ENDP					; CBrush::~CBrush
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
;	COMDAT ??_GCGdiObject@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCGdiObject@@UAEPAXI@Z PROC				; CGdiObject::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CGdiObject@@UAE@XZ	; CGdiObject::~CGdiObject
  0000b	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  0000e	a8 01		 test	 al, 1
  00010	74 1f		 je	 SHORT $LN9@scalar
  00012	a8 04		 test	 al, 4
  00014	75 10		 jne	 SHORT $LN3@scalar

; 112  : 	{ ::operator delete(p); }

  00016	56		 push	 esi
  00017	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001c	83 c4 04	 add	 esp, 4
  0001f	8b c6		 mov	 eax, esi
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
$LN3@scalar:
  00026	6a 08		 push	 8
  00028	56		 push	 esi
  00029	e8 00 00 00 00	 call	 ?__global_delete@@YAXPAXI@Z ; __global_delete
  0002e	83 c4 08	 add	 esp, 8
$LN9@scalar:
  00031	8b c6		 mov	 eax, esi
  00033	5e		 pop	 esi
  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
??_GCGdiObject@@UAEPAXI@Z ENDP				; CGdiObject::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxwin1.inl
;	COMDAT ??1CGdiObject@@UAE@XZ
_TEXT	SEGMENT
_pException$2 = -540					; size = 4
_strMsg$3 = -536					; size = 4
_szErrorMessage$4 = -532				; size = 512
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
??1CGdiObject@@UAE@XZ PROC				; CGdiObject::~CGdiObject, COMDAT
; _this$ = ecx

; 74   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CGdiObject@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 10 02 00
	00		 sub	 esp, 528		; 00000210H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00031	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CGdiObject@@6B@

; 75   : 	AFX_BEGIN_DESTRUCTOR

  00037	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 76   : 	DeleteObject();

  0003e	e8 00 00 00 00	 call	 ?DeleteObject@CGdiObject@@QAEHXZ ; CGdiObject::DeleteObject
$LN18@CGdiObject:

; 78   : }

  00043	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00046	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0004d	59		 pop	 ecx
  0004e	5f		 pop	 edi
  0004f	5e		 pop	 esi
  00050	5b		 pop	 ebx
  00051	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00054	33 cd		 xor	 ecx, ebp
  00056	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005b	8b e5		 mov	 esp, ebp
  0005d	5d		 pop	 ebp
  0005e	c3		 ret	 0
__catch$??1CGdiObject@@UAE@XZ$0:

; 77   : 	AFX_END_DESTRUCTOR

  0005f	8d 8d e8 fd ff
	ff		 lea	 ecx, DWORD PTR _strMsg$3[ebp]
  00065	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0006b	8b b5 e4 fd ff
	ff		 mov	 esi, DWORD PTR _pException$2[ebp]
  00071	8d 8d ec fd ff
	ff		 lea	 ecx, DWORD PTR _szErrorMessage$4[ebp]
  00077	6a 00		 push	 0
  00079	68 00 02 00 00	 push	 512			; 00000200H
  0007e	51		 push	 ecx
  0007f	8b 06		 mov	 eax, DWORD PTR [esi]
  00081	8b ce		 mov	 ecx, esi
  00083	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
  00087	ff 50 14	 call	 DWORD PTR [eax+20]
  0008a	85 c0		 test	 eax, eax
  0008c	74 2a		 je	 SHORT $LN9@CGdiObject
  0008e	8d 85 ec fd ff
	ff		 lea	 eax, DWORD PTR _szErrorMessage$4[ebp]
  00094	50		 push	 eax
  00095	6a 4d		 push	 77			; 0000004dH
  00097	68 00 00 00 00	 push	 OFFSET ??_C@_0HD@JJCHHHNK@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
  0009c	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@OIEOKIDM@Exception?5thrown?5in?5destructor@
  000a1	8d 85 e8 fd ff
	ff		 lea	 eax, DWORD PTR _strMsg$3[ebp]
  000a7	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@HBOOMJBF@?$CFTs?5?$CI?$CFTs?3?$CFd?$CJ?6?$CFTs@
  000ac	50		 push	 eax
  000ad	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Format@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAAXPBDZZ
  000b3	83 c4 18	 add	 esp, 24			; 00000018H
  000b6	eb 21		 jmp	 SHORT $LN10@CGdiObject
$LN9@CGdiObject:
  000b8	6a 4d		 push	 77			; 0000004dH
  000ba	68 00 00 00 00	 push	 OFFSET ??_C@_0HD@JJCHHHNK@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
  000bf	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@OIEOKIDM@Exception?5thrown?5in?5destructor@
  000c4	8d 85 e8 fd ff
	ff		 lea	 eax, DWORD PTR _strMsg$3[ebp]
  000ca	68 00 00 00 00	 push	 OFFSET ??_C@_0N@OMEMOKLE@?$CFTs?5?$CI?$CFTs?3?$CFd?$CJ@
  000cf	50		 push	 eax
  000d0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Format@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAAXPBDZZ
  000d6	83 c4 14	 add	 esp, 20			; 00000014H
$LN10@CGdiObject:
  000d9	6a 00		 push	 0
  000db	6a 00		 push	 0
  000dd	ff b5 e8 fd ff
	ff		 push	 DWORD PTR _strMsg$3[ebp]
  000e3	e8 00 00 00 00	 call	 ?AfxMessageBox@@YGHPBDII@Z ; AfxMessageBox
  000e8	8d 8d e8 fd ff
	ff		 lea	 ecx, DWORD PTR _strMsg$3[ebp]
  000ee	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  000f4	8b 06		 mov	 eax, DWORD PTR [esi]
  000f6	8b ce		 mov	 ecx, esi
  000f8	6a 01		 push	 1
  000fa	ff 50 04	 call	 DWORD PTR [eax+4]
  000fd	b8 00 00 00 00	 mov	 eax, $LN18@CGdiObject
  00102	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CGdiObject@@UAE@XZ$2:
  00000	8d 8d e8 fd ff
	ff		 lea	 ecx, DWORD PTR _strMsg$3[ebp]
  00006	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0000c	cc		 int	 3
  0000d	cc		 int	 3
  0000e	cc		 int	 3
  0000f	cc		 int	 3
  00010	cc		 int	 3
__ehhandler$??1CGdiObject@@UAE@XZ:
  00011	90		 npad	 1
  00012	90		 npad	 1
  00013	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00017	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001a	8b 8a e0 fd ff
	ff		 mov	 ecx, DWORD PTR [edx-544]
  00020	33 c8		 xor	 ecx, eax
  00022	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00027	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0002a	33 c8		 xor	 ecx, eax
  0002c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00031	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CGdiObject@@UAE@XZ
  00036	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CGdiObject@@UAE@XZ ENDP				; CGdiObject::~CGdiObject
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h
;	COMDAT ??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@ABV10@PBD@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_str1$ = 12						; size = 4
_psz2$ = 16						; size = 4
??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@ABV10@PBD@Z PROC ; ATL::operator+, COMDAT

; 2400 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@ABV10@PBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	53		 push	 ebx
  00013	56		 push	 esi
  00014	57		 push	 edi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 2401 : 		CStringT strResult( str1.GetManager() );

  00026	8b 5d 0c	 mov	 ebx, DWORD PTR _str1$[ebp]
  00029	8b cb		 mov	 ecx, ebx
  0002b	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetManager@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEPAUIAtlStringMgr@2@XZ
  00038	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  0003b	8b cf		 mov	 ecx, edi
  0003d	50		 push	 eax
  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PAUIAtlStringMgr@1@@Z
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h

; 722  : 		if( psz == NULL )

  00044	8b 75 10	 mov	 esi, DWORD PTR _psz2$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h

; 2405 : 		return( strResult );

  00047	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0004e	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR $T2[ebp], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h

; 722  : 		if( psz == NULL )

  00055	85 f6		 test	 esi, esi
  00057	75 04		 jne	 SHORT $LN6@operator

; 723  : 		{
; 724  : 			return( 0 );

  00059	33 d2		 xor	 edx, edx
  0005b	eb 0e		 jmp	 SHORT $LN5@operator
$LN6@operator:

; 725  : 		}
; 726  : 		return( int( strlen( psz ) ) );

  0005d	8b d6		 mov	 edx, esi
  0005f	8d 4a 01	 lea	 ecx, DWORD PTR [edx+1]
$LL14@operator:
  00062	8a 02		 mov	 al, BYTE PTR [edx]
  00064	42		 inc	 edx
  00065	84 c0		 test	 al, al
  00067	75 f9		 jne	 SHORT $LL14@operator
  00069	2b d1		 sub	 edx, ecx
$LN5@operator:

; 519  : 		return( GetData()->nDataLength );

  0006b	8b 0b		 mov	 ecx, DWORD PTR [ebx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h

; 2403 : 		CThisSimpleString::Concatenate( strResult, str1, str1.GetLength(), psz2, CThisSimpleString::StringLength( psz2 ) );

  0006d	52		 push	 edx
  0006e	56		 push	 esi
  0006f	ff 71 f4	 push	 DWORD PTR [ecx-12]
  00072	51		 push	 ecx
  00073	57		 push	 edi
  00074	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Concatenate@?$CSimpleStringT@D$00@ATL@@KAXAAV12@PBDH1H@Z
  0007a	83 c4 14	 add	 esp, 20			; 00000014H

; 2405 : 		return( strResult );

  0007d	8b c7		 mov	 eax, edi

; 2406 : 	}

  0007f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00082	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00089	59		 pop	 ecx
  0008a	5f		 pop	 edi
  0008b	5e		 pop	 esi
  0008c	5b		 pop	 ebx
  0008d	8b e5		 mov	 esp, ebp
  0008f	5d		 pop	 ebp
  00090	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@ABV10@PBD@Z$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0d 00 00
	00		 je	 $LN4@operator
  0000c	83 65 f0 fe	 and	 DWORD PTR $T2[ebp], -2	; fffffffeH
  00010	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00013	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$LN4@operator:
  00019	c3		 ret	 0
  0001a	cc		 int	 3
  0001b	cc		 int	 3
  0001c	cc		 int	 3
  0001d	cc		 int	 3
  0001e	cc		 int	 3
__ehhandler$??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@ABV10@PBD@Z:
  0001f	90		 npad	 1
  00020	90		 npad	 1
  00021	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00025	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00028	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  0002b	33 c8		 xor	 ecx, eax
  0002d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00032	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@ABV10@PBD@Z
  00037	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@ABV10@PBD@Z ENDP ; ATL::operator+
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h
;	COMDAT ??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@ABV10@0@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_str1$ = 12						; size = 4
_str2$ = 16						; size = 4
??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@ABV10@0@Z PROC ; ATL::operator+, COMDAT

; 2389 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@ABV10@0@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 2390 : 		CStringT strResult( str1.GetManager() );

  00025	8b 75 0c	 mov	 esi, DWORD PTR _str1$[ebp]
  00028	8b ce		 mov	 ecx, esi
  0002a	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0
  00031	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetManager@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEPAUIAtlStringMgr@2@XZ
  00037	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  0003a	8b cf		 mov	 ecx, edi
  0003c	50		 push	 eax
  0003d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PAUIAtlStringMgr@1@@Z
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h

; 519  : 		return( GetData()->nDataLength );

  00043	8b 45 10	 mov	 eax, DWORD PTR _str2$[ebp]
  00046	8b 16		 mov	 edx, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h

; 2394 : 		return( strResult );

  00048	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0004f	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR $T2[ebp], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h

; 519  : 		return( GetData()->nDataLength );

  00056	8b 08		 mov	 ecx, DWORD PTR [eax]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h

; 2392 : 		CThisSimpleString::Concatenate( strResult, str1, str1.GetLength(), str2, str2.GetLength() );

  00058	ff 71 f4	 push	 DWORD PTR [ecx-12]
  0005b	51		 push	 ecx
  0005c	ff 72 f4	 push	 DWORD PTR [edx-12]
  0005f	52		 push	 edx
  00060	57		 push	 edi
  00061	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Concatenate@?$CSimpleStringT@D$00@ATL@@KAXAAV12@PBDH1H@Z
  00067	83 c4 14	 add	 esp, 20			; 00000014H

; 2394 : 		return( strResult );

  0006a	8b c7		 mov	 eax, edi

; 2395 : 	}

  0006c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00076	59		 pop	 ecx
  00077	5f		 pop	 edi
  00078	5e		 pop	 esi
  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@ABV10@0@Z$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0d 00 00
	00		 je	 $LN4@operator
  0000c	83 65 f0 fe	 and	 DWORD PTR $T2[ebp], -2	; fffffffeH
  00010	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00013	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$LN4@operator:
  00019	c3		 ret	 0
  0001a	cc		 int	 3
  0001b	cc		 int	 3
  0001c	cc		 int	 3
  0001d	cc		 int	 3
  0001e	cc		 int	 3
__ehhandler$??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@ABV10@0@Z:
  0001f	90		 npad	 1
  00020	90		 npad	 1
  00021	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00025	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00028	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0002b	33 c8		 xor	 ecx, eax
  0002d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00032	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@ABV10@0@Z
  00037	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@ABV10@0@Z ENDP ; ATL::operator+
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
;	COMDAT ?Dump@CObject@@UBEXAAVCDumpContext@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?Dump@CObject@@UBEXAAVCDumpContext@@@Z PROC		; CObject::Dump, COMDAT
; _this$ = ecx

; 122  : 	{ /* no dumping in release builds */ }

  00000	c2 04 00	 ret	 4
?Dump@CObject@@UBEXAAVCDumpContext@@@Z ENDP		; CObject::Dump
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
;	COMDAT ?AssertValid@CObject@@UBEXXZ
_TEXT	SEGMENT
?AssertValid@CObject@@UBEXXZ PROC			; CObject::AssertValid, COMDAT
; _this$ = ecx

; 120  : 	{ /* no asserts in release builds */ }

  00000	c2 00 00	 ret	 0
?AssertValid@CObject@@UBEXXZ ENDP			; CObject::AssertValid
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
;	COMDAT ?Serialize@CObject@@UAEXAAVCArchive@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?Serialize@CObject@@UAEXAAVCArchive@@@Z PROC		; CObject::Serialize, COMDAT
; _this$ = ecx

; 106  : 	{ /* CObject does not serialize anything by default */ }

  00000	c2 04 00	 ret	 4
?Serialize@CObject@@UAEXAAVCArchive@@@Z ENDP		; CObject::Serialize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
;	COMDAT ??3CObject@@SGXPAX@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
??3CObject@@SGXPAX@Z PROC				; CObject::operator delete, COMDAT

; 112  : 	{ ::operator delete(p); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	ff 75 08	 push	 DWORD PTR _p$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4
  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
??3CObject@@SGXPAX@Z ENDP				; CObject::operator delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
;	COMDAT ??1CObject@@UAE@XZ
_TEXT	SEGMENT
??1CObject@@UAE@XZ PROC					; CObject::~CObject, COMDAT
; _this$ = ecx

; 104  : 	{ }

  00000	c2 00 00	 ret	 0
??1CObject@@UAE@XZ ENDP					; CObject::~CObject
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.h
;	COMDAT ?AfxCrtErrorCheck@@YAHH@Z
_TEXT	SEGMENT
_error$ = 8						; size = 4
?AfxCrtErrorCheck@@YAHH@Z PROC				; AfxCrtErrorCheck, COMDAT

; 503  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 504  : 	switch(error)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _error$[ebp]
  00006	83 f9 50	 cmp	 ecx, 80			; 00000050H
  00009	77 17		 ja	 SHORT $LN9@AfxCrtErro
  0000b	0f b6 81 00 00
	00 00		 movzx	 eax, BYTE PTR $LN11@AfxCrtErro[ecx]
  00012	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN12@AfxCrtErro[eax*4]
$LN4@AfxCrtErro:

; 505  : 	{
; 506  : 	case ENOMEM:
; 507  : 		AfxThrowMemoryException();

  00019	e9 00 00 00 00	 jmp	 ?AfxThrowMemoryException@@YGXXZ ; AfxThrowMemoryException
$LN7@AfxCrtErro:

; 518  : 		break;
; 519  : 	}
; 520  : 	return error;

  0001e	8b c1		 mov	 eax, ecx

; 521  : }

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
$LN9@AfxCrtErro:

; 508  : 		break;
; 509  : 	case EINVAL:
; 510  : 	case ERANGE:
; 511  : 		AfxThrowInvalidArgException();
; 512  : 		break;
; 513  : 	case STRUNCATE:
; 514  : 	case 0:
; 515  : 		break;
; 516  : 	default:
; 517  : 		AfxThrowInvalidArgException();

  00022	e9 00 00 00 00	 jmp	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
  00027	90		 npad	 1
$LN12@AfxCrtErro:

; 521  : }

  00028	00 00 00 00	 DD	 $LN7@AfxCrtErro
  0002c	00 00 00 00	 DD	 $LN4@AfxCrtErro
  00030	00 00 00 00	 DD	 $LN9@AfxCrtErro
  00034	00 00 00 00	 DD	 $LN9@AfxCrtErro
$LN11@AfxCrtErro:
  00038	00		 DB	 0
  00039	03		 DB	 3
  0003a	03		 DB	 3
  0003b	03		 DB	 3
  0003c	03		 DB	 3
  0003d	03		 DB	 3
  0003e	03		 DB	 3
  0003f	03		 DB	 3
  00040	03		 DB	 3
  00041	03		 DB	 3
  00042	03		 DB	 3
  00043	03		 DB	 3
  00044	01		 DB	 1
  00045	03		 DB	 3
  00046	03		 DB	 3
  00047	03		 DB	 3
  00048	03		 DB	 3
  00049	03		 DB	 3
  0004a	03		 DB	 3
  0004b	03		 DB	 3
  0004c	03		 DB	 3
  0004d	03		 DB	 3
  0004e	02		 DB	 2
  0004f	03		 DB	 3
  00050	03		 DB	 3
  00051	03		 DB	 3
  00052	03		 DB	 3
  00053	03		 DB	 3
  00054	03		 DB	 3
  00055	03		 DB	 3
  00056	03		 DB	 3
  00057	03		 DB	 3
  00058	03		 DB	 3
  00059	03		 DB	 3
  0005a	02		 DB	 2
  0005b	03		 DB	 3
  0005c	03		 DB	 3
  0005d	03		 DB	 3
  0005e	03		 DB	 3
  0005f	03		 DB	 3
  00060	03		 DB	 3
  00061	03		 DB	 3
  00062	03		 DB	 3
  00063	03		 DB	 3
  00064	03		 DB	 3
  00065	03		 DB	 3
  00066	03		 DB	 3
  00067	03		 DB	 3
  00068	03		 DB	 3
  00069	03		 DB	 3
  0006a	03		 DB	 3
  0006b	03		 DB	 3
  0006c	03		 DB	 3
  0006d	03		 DB	 3
  0006e	03		 DB	 3
  0006f	03		 DB	 3
  00070	03		 DB	 3
  00071	03		 DB	 3
  00072	03		 DB	 3
  00073	03		 DB	 3
  00074	03		 DB	 3
  00075	03		 DB	 3
  00076	03		 DB	 3
  00077	03		 DB	 3
  00078	03		 DB	 3
  00079	03		 DB	 3
  0007a	03		 DB	 3
  0007b	03		 DB	 3
  0007c	03		 DB	 3
  0007d	03		 DB	 3
  0007e	03		 DB	 3
  0007f	03		 DB	 3
  00080	03		 DB	 3
  00081	03		 DB	 3
  00082	03		 DB	 3
  00083	03		 DB	 3
  00084	03		 DB	 3
  00085	03		 DB	 3
  00086	03		 DB	 3
  00087	03		 DB	 3
  00088	00		 DB	 0
?AfxCrtErrorCheck@@YAHH@Z ENDP				; AfxCrtErrorCheck
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _sscanf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sscanf	PROC						; COMDAT

; 2247 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2153 :         return __stdio_common_vsscanf(

  00003	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00006	50		 push	 eax
  00007	6a 00		 push	 0
  00009	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000c	6a ff		 push	 -1
  0000e	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00011	e8 00 00 00 00	 call	 ___local_stdio_scanf_options
  00016	ff 70 04	 push	 DWORD PTR [eax+4]
  00019	ff 30		 push	 DWORD PTR [eax]
  0001b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vsscanf
  00021	83 c4 1c	 add	 esp, 28			; 0000001cH

; 2248 :         int _Result;
; 2249 :         va_list _ArgList;
; 2250 :         __crt_va_start(_ArgList, _Format);
; 2251 :         _Result = _vsscanf_l(_Buffer, _Format, NULL, _ArgList);
; 2252 :         __crt_va_end(_ArgList);
; 2253 :         return _Result;
; 2254 :     }

  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
_sscanf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_scanf_options
_TEXT	SEGMENT
___local_stdio_scanf_options PROC			; COMDAT

; 101  :         static unsigned __int64 _OptionsStorage;
; 102  :         return &_OptionsStorage;

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_scanf_options@@9@4_KA ; `__local_stdio_scanf_options'::`2'::_OptionsStorage

; 103  :     }

  00005	c3		 ret	 0
___local_stdio_scanf_options ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	c2 00 00	 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Chart\INDEXOPTIMIZER\DlgOptimizer.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

  00000	c2 00 00	 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b 75 10	 mov	 esi, DWORD PTR ___n$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 16		 je	 SHORT $LN6@vector
  0000b	53		 push	 ebx
  0000c	8b 5d 14	 mov	 ebx, DWORD PTR ___f$[ebp]
  0000f	57		 push	 edi
  00010	8b 7d 08	 mov	 edi, DWORD PTR ___t$[ebp]
$LL2@vector:
  00013	8b cf		 mov	 ecx, edi
  00015	ff d3		 call	 ebx
  00017	03 7d 0c	 add	 edi, DWORD PTR ___s$[ebp]
  0001a	83 ee 01	 sub	 esi, 1
  0001d	75 f4		 jne	 SHORT $LL2@vector
  0001f	5f		 pop	 edi
  00020	5b		 pop	 ebx
$LN6@vector:
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
