; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30145.0 

	TITLE	D:\git\src\IBK\IBK_DRFN\#DRfn-CS\_Obj\ChartCommonAddIn\BmpFile.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	??0BMPFile@@QAE@XZ				; BMPFile::BMPFile
PUBLIC	?LoadBMP@BMPFile@@QAEPAEV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAI1@Z ; BMPFile::LoadBMP
PUBLIC	?SaveBMP@BMPFile@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAEII@Z ; BMPFile::SaveBMP
PUBLIC	?SaveBMP@BMPFile@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAEIIHHPAUtagRGBQUAD@@@Z ; BMPFile::SaveBMP
PUBLIC	??_C@_02GIPFHKNO@OK@				; `string'
PUBLIC	??_C@_02JDPG@rb@				; `string'
PUBLIC	??_C@_0BP@HHLNPFOM@Can?8t?5open?5file?5for?5reading?5?3?6@ ; `string'
PUBLIC	??_C@_0M@NIFBBBPK@Read?5Error?$CB@		; `string'
PUBLIC	??_C@_0BF@PABLBDHA@Not?5a?5valid?5BMP?5File@	; `string'
PUBLIC	??_C@_0BL@HNHBJFDG@This?5is?5a?5compressed?5file?4@ ; `string'
PUBLIC	??_C@_0O@NALGGDJF@Out?5of?5memory@		; `string'
PUBLIC	??_C@_0BA@OMCPEENF@Corrupt?5palette@		; `string'
PUBLIC	??_C@_0BE@DEKFFFHK@Memory?5alloc?5Failed@	; `string'
PUBLIC	??_C@_0L@BAFDDAPG@Read?5Error@			; `string'
PUBLIC	??_C@_02GMLFBBN@wb@				; `string'
PUBLIC	??_C@_0BM@MLGNCOGE@Can?8t?5open?5file?5for?5writing@ ; `string'
PUBLIC	??_C@_0BH@JHDCCPGH@fwrite?5error?6Giving?5up@	; `string'
PUBLIC	??_C@_0CI@JHJLBHOM@We?5don?8t?5do?524?9bit?5files?5in?5her@ ; `string'
PUBLIC	??_C@_0L@JJJALOCC@Can?8t?5Open@			; `string'
PUBLIC	??_C@_0BG@ONGNELDN@Error?5?3?5nBits?5?$DO?58?$DP?$DP?$DP?$DP@ ; `string'
PUBLIC	??_C@_0BJ@ODLNGDFJ@byteswritten?5?$CB?$DN?5filesize@ ; `string'
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	__imp__fclose:PROC
EXTRN	__imp__fopen:PROC
EXTRN	__imp__fread:PROC
EXTRN	__imp__fwrite:PROC
EXTRN	__imp__putc:PROC
EXTRN	__imp_?Concatenate@?$CSimpleStringT@D$00@ATL@@KAXAAV12@PBDH1H@Z:PROC
EXTRN	__imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ:PROC
EXTRN	__imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PAUIAtlStringMgr@1@@Z:PROC
EXTRN	__imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ:PROC
EXTRN	__imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z:PROC
EXTRN	__imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z:PROC
EXTRN	__imp_?GetManager@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEPAUIAtlStringMgr@2@XZ:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	___security_cookie:DWORD
;	COMDAT ??_C@_0BJ@ODLNGDFJ@byteswritten?5?$CB?$DN?5filesize@
CONST	SEGMENT
??_C@_0BJ@ODLNGDFJ@byteswritten?5?$CB?$DN?5filesize@ DB 'byteswritten != '
	DB	'filesize', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@ONGNELDN@Error?5?3?5nBits?5?$DO?58?$DP?$DP?$DP?$DP@
CONST	SEGMENT
??_C@_0BG@ONGNELDN@Error?5?3?5nBits?5?$DO?58?$DP?$DP?$DP?$DP@ DB 'Error :'
	DB	' nBits > 8????', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@JJJALOCC@Can?8t?5Open@
CONST	SEGMENT
??_C@_0L@JJJALOCC@Can?8t?5Open@ DB 'Can''t Open', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@JHJLBHOM@We?5don?8t?5do?524?9bit?5files?5in?5her@
CONST	SEGMENT
??_C@_0CI@JHJLBHOM@We?5don?8t?5do?524?9bit?5files?5in?5her@ DB 'We don''t'
	DB	' do 24-bit files in here, sorry', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@JHDCCPGH@fwrite?5error?6Giving?5up@
CONST	SEGMENT
??_C@_0BH@JHDCCPGH@fwrite?5error?6Giving?5up@ DB 'fwrite error', 0aH, 'Gi'
	DB	'ving up', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@MLGNCOGE@Can?8t?5open?5file?5for?5writing@
CONST	SEGMENT
??_C@_0BM@MLGNCOGE@Can?8t?5open?5file?5for?5writing@ DB 'Can''t open file'
	DB	' for writing', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02GMLFBBN@wb@
CONST	SEGMENT
??_C@_02GMLFBBN@wb@ DB 'wb', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BAFDDAPG@Read?5Error@
CONST	SEGMENT
??_C@_0L@BAFDDAPG@Read?5Error@ DB 'Read Error', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@DEKFFFHK@Memory?5alloc?5Failed@
CONST	SEGMENT
??_C@_0BE@DEKFFFHK@Memory?5alloc?5Failed@ DB 'Memory alloc Failed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@OMCPEENF@Corrupt?5palette@
CONST	SEGMENT
??_C@_0BA@OMCPEENF@Corrupt?5palette@ DB 'Corrupt palette', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NALGGDJF@Out?5of?5memory@
CONST	SEGMENT
??_C@_0O@NALGGDJF@Out?5of?5memory@ DB 'Out of memory', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@HNHBJFDG@This?5is?5a?5compressed?5file?4@
CONST	SEGMENT
??_C@_0BL@HNHBJFDG@This?5is?5a?5compressed?5file?4@ DB 'This is a compres'
	DB	'sed file.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@PABLBDHA@Not?5a?5valid?5BMP?5File@
CONST	SEGMENT
??_C@_0BF@PABLBDHA@Not?5a?5valid?5BMP?5File@ DB 'Not a valid BMP File', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NIFBBBPK@Read?5Error?$CB@
CONST	SEGMENT
??_C@_0M@NIFBBBPK@Read?5Error?$CB@ DB 'Read Error!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@HHLNPFOM@Can?8t?5open?5file?5for?5reading?5?3?6@
CONST	SEGMENT
??_C@_0BP@HHLNPFOM@Can?8t?5open?5file?5for?5reading?5?3?6@ DB 'Can''t ope'
	DB	'n file for reading :', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02JDPG@rb@
CONST	SEGMENT
??_C@_02JDPG@rb@ DB 'rb', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02GIPFHKNO@OK@
CONST	SEGMENT
??_C@_02GIPFHKNO@OK@ DB 'OK', 00H			; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?SaveBMP@BMPFile@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAEIIHHPAUtagRGBQUAD@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SaveBMP@BMPFile@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAEIIHHPAUtagRGBQUAD@@@Z$0
__ehfuncinfo$?SaveBMP@BMPFile@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAEIIHHPAUtagRGBQUAD@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SaveBMP@BMPFile@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAEIIHHPAUtagRGBQUAD@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?SaveBMP@BMPFile@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAEII@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SaveBMP@BMPFile@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAEII@Z$0
__ehfuncinfo$?SaveBMP@BMPFile@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAEII@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SaveBMP@BMPFile@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAEII@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?LoadBMP@BMPFile@@QAEPAEV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAI1@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LoadBMP@BMPFile@@QAEPAEV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAI1@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadBMP@BMPFile@@QAEPAEV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAI1@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LoadBMP@BMPFile@@QAEPAEV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAI1@Z$3
__ehfuncinfo$?LoadBMP@BMPFile@@QAEPAEV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAI1@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?LoadBMP@BMPFile@@QAEPAEV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAI1@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0BMPFile@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0BMPFile@@QAE@XZ$0
__ehfuncinfo$??0BMPFile@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0BMPFile@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@PBDABV10@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@PBDABV10@@Z$0
__ehfuncinfo$??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@PBDABV10@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@PBDABV10@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\BmpFile.cpp
;	COMDAT ?SaveBMP@BMPFile@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAEIIHHPAUtagRGBQUAD@@@Z
_TEXT	SEGMENT
_colormap$GSCopy$1$ = -104				; size = 4
_this$GSCopy$1$ = -100					; size = 4
_filesize$1$ = -96					; size = 4
_colormappedbuffer$GSCopy$1$ = -92			; size = 4
_pixeloffset$1$ = -88					; size = 4
_datasize$1$ = -84					; size = 4
_pixbuf$2 = -84						; size = 4
_fp$1$ = -80						; size = 4
_row$1$ = -76						; size = 4
_bm$ = -76						; size = 2
_bmih$ = -72						; size = 40
_bmfh$ = -32						; size = 14
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_fileName$ = 8						; size = 4
_colormappedbuffer$ = 12				; size = 4
_width$ = 16						; size = 4
_height$ = 20						; size = 4
_bitsperpixel$ = 24					; size = 4
_colors$ = 28						; size = 4
_colormap$ = 32						; size = 4
?SaveBMP@BMPFile@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAEIIHHPAUtagRGBQUAD@@@Z PROC ; BMPFile::SaveBMP, COMDAT
; _this$ = ecx

; 459  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?SaveBMP@BMPFile@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAEIIHHPAUtagRGBQUAD@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b f1		 mov	 esi, ecx
  0002d	89 75 9c	 mov	 DWORD PTR _this$GSCopy$1$[ebp], esi
  00030	8b 45 0c	 mov	 eax, DWORD PTR _colormappedbuffer$[ebp]
  00033	89 45 a4	 mov	 DWORD PTR _colormappedbuffer$GSCopy$1$[ebp], eax
  00036	8b 45 20	 mov	 eax, DWORD PTR _colormap$[ebp]
  00039	89 45 98	 mov	 DWORD PTR _colormap$GSCopy$1$[ebp], eax

; 460  : 	int datasize, cmapsize, byteswritten, row, col;
; 461  : 
; 462  : 	m_errorText="OK";

  0003c	68 00 00 00 00	 push	 OFFSET ??_C@_02GIPFHKNO@OK@
  00041	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z

; 463  : 
; 464  : 	if (bitsperpixel == 24) {

  0004e	8b 4d 18	 mov	 ecx, DWORD PTR _bitsperpixel$[ebp]
  00051	83 f9 18	 cmp	 ecx, 24			; 00000018H
  00054	75 12		 jne	 SHORT $LN13@SaveBMP

; 465  : 		// the routines could be combined, but i don't feel like it
; 466  : 		m_errorText="We don't do 24-bit files in here, sorry";

  00056	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@JHJLBHOM@We?5don?8t?5do?524?9bit?5files?5in?5her@
  0005b	8b ce		 mov	 ecx, esi
  0005d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z
  00063	e9 f4 01 00 00	 jmp	 $LN25@SaveBMP
$LN13@SaveBMP:

; 467  : 		return;
; 468  : 	} else
; 469  : 		cmapsize = colors * 4;
; 470  : 
; 471  : 	datasize = BMP_PIXELSIZE(width, height, bitsperpixel);

  00068	8b 45 10	 mov	 eax, DWORD PTR _width$[ebp]
  0006b	8b 7d 1c	 mov	 edi, DWORD PTR _colors$[ebp]
  0006e	0f af c1	 imul	 eax, ecx

; 472  : 
; 473  : 	long filesize = BMP_HEADERSIZE + cmapsize + datasize;
; 474  : 	int res1, res2;
; 475  : 	res1 = res2 = 0;
; 476  : 
; 477  : 	long pixeloffset = BMP_HEADERSIZE + cmapsize;
; 478  : 
; 479  : 	int bmisize = 40;
; 480  : 	long cols = width;
; 481  : 	long rows = height;
; 482  : 	WORD planes = 1;
; 483  : 	long compression =0;
; 484  : 	long cmpsize = datasize;
; 485  : 	long xscale = 0;
; 486  : 	long yscale = 0;
; 487  : 	long impcolors = colors;
; 488  : 
; 489  : 	FILE *fp;
; 490  : 	fp = fopen(fileName, "wb");

  00071	68 00 00 00 00	 push	 OFFSET ??_C@_02GMLFBBN@wb@
  00076	ff 75 08	 push	 DWORD PTR _fileName$[ebp]
  00079	8d 14 bd 00 00
	00 00		 lea	 edx, DWORD PTR [edi*4]
  00080	83 c0 1f	 add	 eax, 31			; 0000001fH
  00083	c1 e8 05	 shr	 eax, 5
  00086	0f af 45 14	 imul	 eax, DWORD PTR _height$[ebp]
  0008a	c1 e0 02	 shl	 eax, 2
  0008d	89 45 ac	 mov	 DWORD PTR _datasize$1$[ebp], eax
  00090	83 c0 36	 add	 eax, 54			; 00000036H
  00093	03 c2		 add	 eax, edx
  00095	89 45 a0	 mov	 DWORD PTR _filesize$1$[ebp], eax
  00098	8d 42 36	 lea	 eax, DWORD PTR [edx+54]
  0009b	89 45 a8	 mov	 DWORD PTR _pixeloffset$1$[ebp], eax
  0009e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  000a4	8b d8		 mov	 ebx, eax
  000a6	83 c4 08	 add	 esp, 8
  000a9	89 5d b0	 mov	 DWORD PTR _fp$1$[ebp], ebx

; 491  : 	if (fp==NULL) {

  000ac	85 db		 test	 ebx, ebx
  000ae	75 12		 jne	 SHORT $LN15@SaveBMP

; 492  : 		m_errorText="Can't Open";

  000b0	68 00 00 00 00	 push	 OFFSET ??_C@_0L@JJJALOCC@Can?8t?5Open@
  000b5	8b ce		 mov	 ecx, esi
  000b7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z
  000bd	e9 9a 01 00 00	 jmp	 $LN25@SaveBMP
$LN15@SaveBMP:

; 493  : 		return;
; 494  : 	}
; 495  : 	char bm[2];
; 496  : 	bm[0]='B';
; 497  : 	bm[1]='M';
; 498  : 
; 499  : 	// header stuff
; 500  : 	BITMAPFILEHEADER bmfh;
; 501  : 	bmfh.bfType=*(WORD *)&bm; 
; 502  :     bmfh.bfSize= filesize; 
; 503  :     bmfh.bfReserved1=0; 
; 504  :     bmfh.bfReserved2=0; 
; 505  :     bmfh.bfOffBits=pixeloffset; 
; 506  : 
; 507  : 	fwrite(&bmfh, sizeof (BITMAPFILEHEADER), 1, fp);

  000c2	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__fwrite
  000c8	66 c7 45 b4 42
	4d		 mov	 WORD PTR _bm$[ebp], 19778 ; 00004d42H
  000ce	66 8b 45 b4	 mov	 ax, WORD PTR _bm$[ebp]
  000d2	66 89 45 e0	 mov	 WORD PTR _bmfh$[ebp], ax
  000d6	8b 45 a0	 mov	 eax, DWORD PTR _filesize$1$[ebp]
  000d9	89 45 e2	 mov	 DWORD PTR _bmfh$[ebp+2], eax
  000dc	33 c0		 xor	 eax, eax
  000de	53		 push	 ebx
  000df	89 45 e6	 mov	 DWORD PTR _bmfh$[ebp+6], eax
  000e2	8b 45 a8	 mov	 eax, DWORD PTR _pixeloffset$1$[ebp]
  000e5	6a 01		 push	 1
  000e7	89 45 ea	 mov	 DWORD PTR _bmfh$[ebp+10], eax
  000ea	8d 45 e0	 lea	 eax, DWORD PTR _bmfh$[ebp]
  000ed	6a 0e		 push	 14			; 0000000eH
  000ef	50		 push	 eax
  000f0	ff d6		 call	 esi

; 508  : 
; 509  : 
; 510  : 	BITMAPINFOHEADER bmih;
; 511  : 	bmih.biSize = bmisize; 
; 512  : 	bmih.biWidth = cols; 

  000f2	8b 45 10	 mov	 eax, DWORD PTR _width$[ebp]
  000f5	89 45 bc	 mov	 DWORD PTR _bmih$[ebp+4], eax

; 513  : 	bmih.biHeight = rows; 

  000f8	8b 45 14	 mov	 eax, DWORD PTR _height$[ebp]
  000fb	89 45 c0	 mov	 DWORD PTR _bmih$[ebp+8], eax

; 514  : 	bmih.biPlanes = planes; 

  000fe	b8 01 00 00 00	 mov	 eax, 1
  00103	66 89 45 c4	 mov	 WORD PTR _bmih$[ebp+12], ax

; 515  : 	bmih.biBitCount =bitsperpixel;

  00107	8b 45 18	 mov	 eax, DWORD PTR _bitsperpixel$[ebp]

; 516  : 	bmih.biCompression = compression; 
; 517  : 	bmih.biSizeImage = cmpsize; 
; 518  : 	bmih.biXPelsPerMeter = xscale; 
; 519  : 	bmih.biYPelsPerMeter = yscale; 
; 520  : 	bmih.biClrUsed = colors;
; 521  : 	bmih.biClrImportant = impcolors;
; 522  : 	
; 523  : 	fwrite(&bmih, sizeof (BITMAPINFOHEADER), 1, fp);

  0010a	53		 push	 ebx
  0010b	66 89 45 c6	 mov	 WORD PTR _bmih$[ebp+14], ax
  0010f	8b 45 ac	 mov	 eax, DWORD PTR _datasize$1$[ebp]
  00112	6a 01		 push	 1
  00114	89 45 cc	 mov	 DWORD PTR _bmih$[ebp+20], eax
  00117	8d 45 b8	 lea	 eax, DWORD PTR _bmih$[ebp]
  0011a	6a 28		 push	 40			; 00000028H
  0011c	50		 push	 eax
  0011d	c7 45 b8 28 00
	00 00		 mov	 DWORD PTR _bmih$[ebp], 40 ; 00000028H
  00124	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _bmih$[ebp+16], 0
  0012b	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _bmih$[ebp+24], 0
  00132	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _bmih$[ebp+28], 0
  00139	89 7d d8	 mov	 DWORD PTR _bmih$[ebp+32], edi
  0013c	89 7d dc	 mov	 DWORD PTR _bmih$[ebp+36], edi
  0013f	ff d6		 call	 esi

; 524  : 
; 525  : 	if (cmapsize) {

  00141	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__putc
  00147	8d 04 bd 00 00
	00 00		 lea	 eax, DWORD PTR [edi*4]
  0014e	83 c4 20	 add	 esp, 32			; 00000020H
  00151	85 c0		 test	 eax, eax
  00153	74 33		 je	 SHORT $LN3@SaveBMP

; 526  : 		int i;
; 527  : 		for (i = 0; i< colors; i++) {

  00155	85 ff		 test	 edi, edi
  00157	7e 2f		 jle	 SHORT $LN3@SaveBMP
  00159	8b 7d 98	 mov	 edi, DWORD PTR _colormap$GSCopy$1$[ebp]
  0015c	47		 inc	 edi
  0015d	0f 1f 00	 npad	 3
$LL4@SaveBMP:

; 528  : 			putc(colormap[i].rgbRed, fp);

  00160	0f b6 47 01	 movzx	 eax, BYTE PTR [edi+1]
  00164	53		 push	 ebx
  00165	50		 push	 eax
  00166	ff d6		 call	 esi

; 529  : 			putc(colormap[i].rgbGreen, fp);

  00168	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  0016b	53		 push	 ebx
  0016c	50		 push	 eax
  0016d	ff d6		 call	 esi

; 530  : 			putc(colormap[i].rgbBlue, fp);

  0016f	0f b6 47 ff	 movzx	 eax, BYTE PTR [edi-1]
  00173	53		 push	 ebx
  00174	50		 push	 eax
  00175	ff d6		 call	 esi

; 531  : 			putc(0, fp);	// dummy

  00177	53		 push	 ebx
  00178	6a 00		 push	 0
  0017a	ff d6		 call	 esi
  0017c	83 c4 20	 add	 esp, 32			; 00000020H
  0017f	8d 7f 04	 lea	 edi, DWORD PTR [edi+4]
  00182	83 6d 1c 01	 sub	 DWORD PTR _colors$[ebp], 1
  00186	75 d8		 jne	 SHORT $LL4@SaveBMP
$LN3@SaveBMP:

; 532  : 		}
; 533  : 	}
; 534  : 
; 535  : 	byteswritten = BMP_HEADERSIZE + cmapsize;

  00188	8b 75 a8	 mov	 esi, DWORD PTR _pixeloffset$1$[ebp]

; 536  : 
; 537  : 	for (row = 0; row< (int)height; row++) {

  0018b	33 c9		 xor	 ecx, ecx
  0018d	89 4d b4	 mov	 DWORD PTR _row$1$[ebp], ecx
  00190	39 4d 14	 cmp	 DWORD PTR _height$[ebp], ecx
  00193	0f 8e a6 00 00
	00		 jle	 $LN45@SaveBMP

; 532  : 		}
; 533  : 	}
; 534  : 
; 535  : 	byteswritten = BMP_HEADERSIZE + cmapsize;

  00199	8b 7d ac	 mov	 edi, DWORD PTR _pixbuf$2[ebp]
  0019c	8b 45 10	 mov	 eax, DWORD PTR _width$[ebp]
  0019f	90		 npad	 1
$LL7@SaveBMP:

; 538  : 		int pixbuf;
; 539  : 		int nbits = 0;

  001a0	33 d2		 xor	 edx, edx

; 540  : 
; 541  : 		for (col =0 ; col < (int)width; col++) {

  001a2	33 db		 xor	 ebx, ebx
  001a4	85 c0		 test	 eax, eax
  001a6	7e 5b		 jle	 SHORT $LN31@SaveBMP
  001a8	8b 4d 18	 mov	 ecx, DWORD PTR _bitsperpixel$[ebp]
  001ab	0f 1f 44 00 00	 npad	 5
$LL10@SaveBMP:

; 542  : 			int offset = row * width + col;	// offset into our color-mapped RGB buffer
; 543  : 			BYTE pval = *(colormappedbuffer + offset);
; 544  : 
; 545  : 			pixbuf = (pixbuf << bitsperpixel) | pval;

  001b0	8b 45 a4	 mov	 eax, DWORD PTR _colormappedbuffer$GSCopy$1$[ebp]

; 546  : 
; 547  : 			nbits += bitsperpixel;

  001b3	03 d1		 add	 edx, ecx
  001b5	d3 e7		 shl	 edi, cl
  001b7	0f b6 04 18	 movzx	 eax, BYTE PTR [eax+ebx]
  001bb	0b f8		 or	 edi, eax
  001bd	89 7d ac	 mov	 DWORD PTR _pixbuf$2[ebp], edi

; 548  : 
; 549  : 			if (nbits > 8) {

  001c0	83 fa 08	 cmp	 edx, 8
  001c3	0f 8f ba 00 00
	00		 jg	 $LN32@SaveBMP

; 552  : 				return;
; 553  : 			}
; 554  : 
; 555  : 			if (nbits == 8) {

  001c9	75 18		 jne	 SHORT $LN8@SaveBMP

; 556  : 				putc(pixbuf, fp);

  001cb	ff 75 b0	 push	 DWORD PTR _fp$1$[ebp]
  001ce	57		 push	 edi
  001cf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__putc
  001d5	8b 4d 18	 mov	 ecx, DWORD PTR _bitsperpixel$[ebp]

; 557  : 				pixbuf=0;

  001d8	33 ff		 xor	 edi, edi
  001da	83 c4 08	 add	 esp, 8
  001dd	89 7d ac	 mov	 DWORD PTR _pixbuf$2[ebp], edi

; 558  : 				nbits=0;

  001e0	33 d2		 xor	 edx, edx

; 559  : 				byteswritten++;

  001e2	46		 inc	 esi
$LN8@SaveBMP:

; 540  : 
; 541  : 		for (col =0 ; col < (int)width; col++) {

  001e3	8b 45 10	 mov	 eax, DWORD PTR _width$[ebp]
  001e6	43		 inc	 ebx
  001e7	3b d8		 cmp	 ebx, eax
  001e9	7c c5		 jl	 SHORT $LL10@SaveBMP

; 560  : 			}
; 561  : 		} // cols
; 562  : 
; 563  : 		if (nbits > 0) {

  001eb	85 d2		 test	 edx, edx
  001ed	7e 11		 jle	 SHORT $LN47@SaveBMP

; 564  : 			putc(pixbuf, fp);		// write partially filled byte

  001ef	ff 75 b0	 push	 DWORD PTR _fp$1$[ebp]
  001f2	57		 push	 edi
  001f3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__putc
  001f9	8b 45 10	 mov	 eax, DWORD PTR _width$[ebp]
  001fc	83 c4 08	 add	 esp, 8

; 565  : 			byteswritten++;

  001ff	46		 inc	 esi
$LN47@SaveBMP:

; 566  : 		}
; 567  : 
; 568  : 		// DWORD align
; 569  : 		while ((byteswritten -pixeloffset) & 3) {

  00200	8b 4d b4	 mov	 ecx, DWORD PTR _row$1$[ebp]
$LN31@SaveBMP:
  00203	8b de		 mov	 ebx, esi
  00205	2b 5d a8	 sub	 ebx, DWORD PTR _pixeloffset$1$[ebp]
  00208	f6 c3 03	 test	 bl, 3
  0020b	74 1f		 je	 SHORT $LN5@SaveBMP
  0020d	8b 7d b0	 mov	 edi, DWORD PTR _fp$1$[ebp]
$LL11@SaveBMP:

; 570  : 			putc(0, fp);

  00210	57		 push	 edi
  00211	6a 00		 push	 0
  00213	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__putc

; 571  : 			byteswritten++;

  00219	43		 inc	 ebx
  0021a	83 c4 08	 add	 esp, 8
  0021d	46		 inc	 esi
  0021e	f6 c3 03	 test	 bl, 3
  00221	75 ed		 jne	 SHORT $LL11@SaveBMP
  00223	8b 7d ac	 mov	 edi, DWORD PTR _pixbuf$2[ebp]
  00226	8b 45 10	 mov	 eax, DWORD PTR _width$[ebp]
  00229	8b 4d b4	 mov	 ecx, DWORD PTR _row$1$[ebp]
$LN5@SaveBMP:

; 536  : 
; 537  : 	for (row = 0; row< (int)height; row++) {

  0022c	01 45 a4	 add	 DWORD PTR _colormappedbuffer$GSCopy$1$[ebp], eax
  0022f	41		 inc	 ecx
  00230	89 4d b4	 mov	 DWORD PTR _row$1$[ebp], ecx
  00233	3b 4d 14	 cmp	 ecx, DWORD PTR _height$[ebp]
  00236	0f 8c 64 ff ff
	ff		 jl	 $LL7@SaveBMP
  0023c	8b 5d b0	 mov	 ebx, DWORD PTR _fp$1$[ebp]
$LN45@SaveBMP:

; 572  : 		}
; 573  : 
; 574  : 	}	//rows
; 575  : 
; 576  : 	if (byteswritten!=filesize) {

  0023f	3b 75 a0	 cmp	 esi, DWORD PTR _filesize$1$[ebp]
  00242	74 0e		 je	 SHORT $LN20@SaveBMP

; 577  : 		m_errorText="byteswritten != filesize";

  00244	8b 4d 9c	 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  00247	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@ODLNGDFJ@byteswritten?5?$CB?$DN?5filesize@
  0024c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z
$LN20@SaveBMP:

; 578  : 	}
; 579  : 
; 580  : 	fclose(fp);

  00252	53		 push	 ebx
$LN49@SaveBMP:

; 581  : }

  00253	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  00259	83 c4 04	 add	 esp, 4
$LN25@SaveBMP:
  0025c	8d 4d 08	 lea	 ecx, DWORD PTR _fileName$[ebp]
  0025f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00265	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00268	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0026f	59		 pop	 ecx
  00270	5f		 pop	 edi
  00271	5e		 pop	 esi
  00272	5b		 pop	 ebx
  00273	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00276	33 cd		 xor	 ecx, ebp
  00278	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0027d	8b e5		 mov	 esp, ebp
  0027f	5d		 pop	 ebp
  00280	c2 1c 00	 ret	 28			; 0000001cH
$LN32@SaveBMP:

; 550  : 				m_errorText="Error : nBits > 8????";

  00283	8b 4d 9c	 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  00286	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@ONGNELDN@Error?5?3?5nBits?5?$DO?58?$DP?$DP?$DP?$DP@
  0028b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z

; 551  : 				fclose(fp);

  00291	ff 75 b0	 push	 DWORD PTR _fp$1$[ebp]
  00294	eb bd		 jmp	 SHORT $LN49@SaveBMP
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SaveBMP@BMPFile@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAEIIHHPAUtagRGBQUAD@@@Z$0:
  00000	8d 4d 08	 lea	 ecx, DWORD PTR _fileName$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
  0000d	cc		 int	 3
__ehhandler$?SaveBMP@BMPFile@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAEIIHHPAUtagRGBQUAD@@@Z:
  0000e	90		 npad	 1
  0000f	90		 npad	 1
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a 94	 mov	 ecx, DWORD PTR [edx-108]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00024	33 c8		 xor	 ecx, eax
  00026	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?SaveBMP@BMPFile@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAEIIHHPAUtagRGBQUAD@@@Z
  00030	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?SaveBMP@BMPFile@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAEIIHHPAUtagRGBQUAD@@@Z ENDP ; BMPFile::SaveBMP
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\BmpFile.cpp
;	COMDAT ?SaveBMP@BMPFile@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAEII@Z
_TEXT	SEGMENT
_this$GSCopy$1$ = -96					; size = 4
_widthDW$1$ = -92					; size = 4
_pixoff$ = -88						; size = 4
_res2$ = -84						; size = 2
_res1$ = -80						; size = 2
_bmfsize$ = -76						; size = 4
_row$1$ = -72						; size = 4
_row_size$1$ = -68					; size = 4
_buf$GSCopy$1$ = -64					; size = 4
_dummy$2 = -59						; size = 1
_m2$ = -58						; size = 1
_m1$ = -57						; size = 1
_header$ = -56						; size = 40
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_fileName$ = 8						; size = 4
_buf$ = 12						; size = 4
_width$ = 16						; size = 4
_height$ = 20						; size = 4
?SaveBMP@BMPFile@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAEII@Z PROC ; BMPFile::SaveBMP, COMDAT
; _this$ = ecx

; 363  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?SaveBMP@BMPFile@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAEII@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 54	 sub	 esp, 84			; 00000054H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b d9		 mov	 ebx, ecx
  0002d	89 5d a0	 mov	 DWORD PTR _this$GSCopy$1$[ebp], ebx
  00030	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  00033	89 45 c0	 mov	 DWORD PTR _buf$GSCopy$1$[ebp], eax

; 364  : 	short res1=0;
; 365  :     short res2=0;
; 366  :     long pixoff=54;
; 367  :     long compression=0;
; 368  :     long cmpsize=0;
; 369  :     long colors=0;
; 370  :     long impcol=0;
; 371  : 	char m1='B';
; 372  : 	char m2='M';
; 373  : 
; 374  : 	m_errorText="OK";

  00036	68 00 00 00 00	 push	 OFFSET ??_C@_02GIPFHKNO@OK@
  0003b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00042	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _res1$[ebp], 0
  00049	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR _res2$[ebp], 0
  00050	c7 45 a8 36 00
	00 00		 mov	 DWORD PTR _pixoff$[ebp], 54 ; 00000036H
  00057	c6 45 c7 42	 mov	 BYTE PTR _m1$[ebp], 66	; 00000042H
  0005b	c6 45 c6 4d	 mov	 BYTE PTR _m2$[ebp], 77	; 0000004dH
  0005f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z

; 375  : 
; 376  : 	DWORD widthDW = WIDTHBYTES(width * 24);

  00065	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]

; 377  : 
; 378  : 	long bmfsize=sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER) +

  00068	8b 4d 14	 mov	 ecx, DWORD PTR _height$[ebp]

; 379  :   							widthDW * height;	
; 380  : 	long byteswritten=0;
; 381  : 
; 382  : 	BITMAPINFOHEADER header;
; 383  :   	header.biSize=40; 						// header size
; 384  : 	header.biWidth=width;
; 385  : 	header.biHeight=height;
; 386  : 	header.biPlanes=1;
; 387  : 	header.biBitCount=24;					// RGB encoded, 24 bit
; 388  : 	header.biCompression=BI_RGB;			// no compression
; 389  : 	header.biSizeImage=0;
; 390  : 	header.biXPelsPerMeter=0;
; 391  : 	header.biYPelsPerMeter=0;
; 392  : 	header.biClrUsed=0;
; 393  : 	header.biClrImportant=0;
; 394  : 
; 395  : 	FILE *fp;	
; 396  : 	fp=fopen(fileName,"wb");

  0006b	68 00 00 00 00	 push	 OFFSET ??_C@_02GMLFBBN@wb@
  00070	ff 75 08	 push	 DWORD PTR _fileName$[ebp]
  00073	8d 04 52	 lea	 eax, DWORD PTR [edx+edx*2]
  00076	c7 45 c8 28 00
	00 00		 mov	 DWORD PTR _header$[ebp], 40 ; 00000028H
  0007d	8d 04 c5 1f 00
	00 00		 lea	 eax, DWORD PTR [eax*8+31]
  00084	89 55 cc	 mov	 DWORD PTR _header$[ebp+4], edx
  00087	c1 e8 05	 shr	 eax, 5
  0008a	c1 e0 02	 shl	 eax, 2
  0008d	89 45 a4	 mov	 DWORD PTR _widthDW$1$[ebp], eax
  00090	0f af c1	 imul	 eax, ecx
  00093	89 4d d0	 mov	 DWORD PTR _header$[ebp+8], ecx
  00096	c7 45 d4 01 00
	18 00		 mov	 DWORD PTR _header$[ebp+12], 1572865 ; 00180001H
  0009d	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _header$[ebp+16], 0
  000a4	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _header$[ebp+20], 0
  000ab	83 c0 36	 add	 eax, 54			; 00000036H
  000ae	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _header$[ebp+24], 0
  000b5	89 45 b4	 mov	 DWORD PTR _bmfsize$[ebp], eax
  000b8	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _header$[ebp+28], 0
  000bf	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _header$[ebp+32], 0
  000c6	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _header$[ebp+36], 0
  000cd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  000d3	8b f8		 mov	 edi, eax
  000d5	83 c4 08	 add	 esp, 8

; 397  : 	if (fp==NULL) {

  000d8	85 ff		 test	 edi, edi
  000da	75 12		 jne	 SHORT $LN8@SaveBMP

; 398  : 		m_errorText="Can't open file for writing";

  000dc	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@MLGNCOGE@Can?8t?5open?5file?5for?5writing@
  000e1	8b cb		 mov	 ecx, ebx
  000e3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z
  000e9	e9 da 00 00 00	 jmp	 $LN12@SaveBMP
$LN8@SaveBMP:

; 399  : 		return;
; 400  : 	}
; 401  : 
; 402  : 	// should probably check for write errors here...
; 403  : 	
; 404  : 	fwrite((BYTE  *)&(m1),1,1,fp); byteswritten+=1;

  000ee	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__fwrite
  000f4	8d 45 c7	 lea	 eax, DWORD PTR _m1$[ebp]
  000f7	57		 push	 edi
  000f8	6a 01		 push	 1
  000fa	6a 01		 push	 1
  000fc	50		 push	 eax
  000fd	ff d3		 call	 ebx

; 405  : 	fwrite((BYTE  *)&(m2),1,1,fp); byteswritten+=1;

  000ff	57		 push	 edi
  00100	6a 01		 push	 1
  00102	8d 45 c6	 lea	 eax, DWORD PTR _m2$[ebp]
  00105	6a 01		 push	 1
  00107	50		 push	 eax
  00108	ff d3		 call	 ebx

; 406  : 	fwrite((long  *)&(bmfsize),4,1,fp);	byteswritten+=4;

  0010a	57		 push	 edi
  0010b	6a 01		 push	 1
  0010d	8d 45 b4	 lea	 eax, DWORD PTR _bmfsize$[ebp]
  00110	6a 04		 push	 4
  00112	50		 push	 eax
  00113	ff d3		 call	 ebx

; 407  : 	fwrite((int  *)&(res1),2,1,fp); byteswritten+=2;

  00115	57		 push	 edi
  00116	6a 01		 push	 1
  00118	8d 45 b0	 lea	 eax, DWORD PTR _res1$[ebp]
  0011b	6a 02		 push	 2
  0011d	50		 push	 eax
  0011e	ff d3		 call	 ebx
  00120	83 c4 40	 add	 esp, 64			; 00000040H

; 408  : 	fwrite((int  *)&(res2),2,1,fp); byteswritten+=2;

  00123	8d 45 ac	 lea	 eax, DWORD PTR _res2$[ebp]
  00126	57		 push	 edi
  00127	6a 01		 push	 1
  00129	6a 02		 push	 2
  0012b	50		 push	 eax
  0012c	ff d3		 call	 ebx

; 409  : 	fwrite((long  *)&(pixoff),4,1,fp); byteswritten+=4;

  0012e	57		 push	 edi
  0012f	6a 01		 push	 1
  00131	8d 45 a8	 lea	 eax, DWORD PTR _pixoff$[ebp]
  00134	6a 04		 push	 4
  00136	50		 push	 eax
  00137	ff d3		 call	 ebx

; 410  : 
; 411  : 	fwrite((BITMAPINFOHEADER *)&header,sizeof(BITMAPINFOHEADER),1,fp);

  00139	57		 push	 edi
  0013a	6a 01		 push	 1
  0013c	8d 45 c8	 lea	 eax, DWORD PTR _header$[ebp]
  0013f	6a 28		 push	 40			; 00000028H
  00141	50		 push	 eax
  00142	ff d3		 call	 ebx

; 412  : 	byteswritten+=sizeof(BITMAPINFOHEADER);
; 413  : 	
; 414  : 	long row=0;
; 415  : 	long rowidx;
; 416  : 	long row_size;
; 417  : 	row_size=header.biWidth*3;

  00144	8b 45 cc	 mov	 eax, DWORD PTR _header$[ebp+4]

; 418  :     long rc;
; 419  : 	for (row=0;row<header.biHeight;row++) {

  00147	33 f6		 xor	 esi, esi
  00149	83 c4 30	 add	 esp, 48			; 00000030H
  0014c	89 75 b8	 mov	 DWORD PTR _row$1$[ebp], esi
  0014f	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00152	89 45 bc	 mov	 DWORD PTR _row_size$1$[ebp], eax
  00155	39 75 d0	 cmp	 DWORD PTR _header$[ebp+8], esi
  00158	7e 64		 jle	 SHORT $LN3@SaveBMP
  0015a	8b 4d c0	 mov	 ecx, DWORD PTR _buf$GSCopy$1$[ebp]
  0015d	0f 1f 00	 npad	 3
$LL4@SaveBMP:

; 420  : 		rowidx=(long unsigned)row*row_size;						      
; 421  : 
; 422  : 		// write a row
; 423  : 		rc=fwrite((void  *)(buf+rowidx),row_size,1,fp);

  00160	57		 push	 edi
  00161	6a 01		 push	 1
  00163	50		 push	 eax
  00164	51		 push	 ecx
  00165	ff d3		 call	 ebx
  00167	83 c4 10	 add	 esp, 16			; 00000010H

; 424  : 		if (rc!=1) {

  0016a	83 f8 01	 cmp	 eax, 1
  0016d	75 41		 jne	 SHORT $LN17@SaveBMP

; 426  : 			break;
; 427  : 		}
; 428  : 		byteswritten+=row_size;	
; 429  : 
; 430  : 		// pad to DWORD
; 431  : 		for (DWORD count=row_size;count<widthDW;count++) {

  0016f	8b 45 bc	 mov	 eax, DWORD PTR _row_size$1$[ebp]
  00172	8b 4d a4	 mov	 ecx, DWORD PTR _widthDW$1$[ebp]
  00175	3b c1		 cmp	 eax, ecx
  00177	73 24		 jae	 SHORT $LN2@SaveBMP
  00179	8b f1		 mov	 esi, ecx
  0017b	2b f0		 sub	 esi, eax
  0017d	0f 1f 00	 npad	 3
$LL7@SaveBMP:

; 432  : 			char dummy=0;
; 433  : 			fwrite(&dummy,1,1,fp);

  00180	57		 push	 edi
  00181	6a 01		 push	 1
  00183	8d 45 c5	 lea	 eax, DWORD PTR _dummy$2[ebp]
  00186	c6 45 c5 00	 mov	 BYTE PTR _dummy$2[ebp], 0
  0018a	6a 01		 push	 1
  0018c	50		 push	 eax
  0018d	ff d3		 call	 ebx
  0018f	83 c4 10	 add	 esp, 16			; 00000010H
  00192	83 ee 01	 sub	 esi, 1
  00195	75 e9		 jne	 SHORT $LL7@SaveBMP
  00197	8b 45 bc	 mov	 eax, DWORD PTR _row_size$1$[ebp]
  0019a	8b 75 b8	 mov	 esi, DWORD PTR _row$1$[ebp]
$LN2@SaveBMP:

; 418  :     long rc;
; 419  : 	for (row=0;row<header.biHeight;row++) {

  0019d	8b 4d c0	 mov	 ecx, DWORD PTR _buf$GSCopy$1$[ebp]
  001a0	46		 inc	 esi
  001a1	03 c8		 add	 ecx, eax
  001a3	89 75 b8	 mov	 DWORD PTR _row$1$[ebp], esi
  001a6	89 4d c0	 mov	 DWORD PTR _buf$GSCopy$1$[ebp], ecx
  001a9	3b 75 d0	 cmp	 esi, DWORD PTR _header$[ebp+8]
  001ac	7c b2		 jl	 SHORT $LL4@SaveBMP

; 424  : 		if (rc!=1) {

  001ae	eb 0e		 jmp	 SHORT $LN3@SaveBMP
$LN17@SaveBMP:

; 425  : 			m_errorText="fwrite error\nGiving up";

  001b0	8b 4d a0	 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  001b3	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@JHDCCPGH@fwrite?5error?6Giving?5up@
  001b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z
$LN3@SaveBMP:

; 434  : 			byteswritten++;							  
; 435  : 		}
; 436  : 
; 437  : 	}
; 438  :            
; 439  : 	fclose(fp);

  001be	57		 push	 edi
  001bf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  001c5	83 c4 04	 add	 esp, 4
$LN12@SaveBMP:

; 440  : }

  001c8	8d 4d 08	 lea	 ecx, DWORD PTR _fileName$[ebp]
  001cb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  001d1	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001d4	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001db	59		 pop	 ecx
  001dc	5f		 pop	 edi
  001dd	5e		 pop	 esi
  001de	5b		 pop	 ebx
  001df	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001e2	33 cd		 xor	 ecx, ebp
  001e4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001e9	8b e5		 mov	 esp, ebp
  001eb	5d		 pop	 ebp
  001ec	c2 10 00	 ret	 16			; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SaveBMP@BMPFile@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAEII@Z$0:
  00000	8d 4d 08	 lea	 ecx, DWORD PTR _fileName$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
  0000d	cc		 int	 3
__ehhandler$?SaveBMP@BMPFile@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAEII@Z:
  0000e	90		 npad	 1
  0000f	90		 npad	 1
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a 9c	 mov	 ecx, DWORD PTR [edx-100]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00024	33 c8		 xor	 ecx, eax
  00026	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?SaveBMP@BMPFile@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAEII@Z
  00030	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?SaveBMP@BMPFile@@QAEXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAEII@Z ENDP ; BMPFile::SaveBMP
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\BmpFile.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\BmpFile.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\BmpFile.cpp
;	COMDAT ?LoadBMP@BMPFile@@QAEPAEV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAI1@Z
_TEXT	SEGMENT
_impcol$ = -136						; size = 4
_yscale$ = -132						; size = 4
_xscale$ = -128						; size = 4
_sizeimage$ = -124					; size = 4
_bmisize$ = -120					; size = 4
_filesize$ = -116					; size = 4
_inBM$ = -112						; size = 24
_mask$1$ = -88						; size = 4
_bit_count$1$ = -84					; size = 4
_this$1$ = -80						; size = 4
_compression$ = -76					; size = 4
_res2$ = -72						; size = 2
_res1$ = -68						; size = 2
_col$1$ = -64						; size = 4
_w$1$ = -60						; size = 4
tv1162 = -56						; size = 4
_row$1$ = -52						; size = 4
$T2 = -52						; size = 4
$T3 = -48						; size = 4
_colors$ = -44						; size = 4
_pixel$4 = -40						; size = 3
_i$1$ = -36						; size = 4
tv1158 = -36						; size = 4
_row_size$1$ = -32					; size = 4
tv1165 = -32						; size = 4
_pixoff$ = -28						; size = 4
_colormap$1$ = -24					; size = 4
_b$5 = -18						; size = 1
_g$6 = -17						; size = 1
_r$7 = -16						; size = 1
_m2$ = -15						; size = 1
_m1$ = -14						; size = 1
_dummy$8 = -13						; size = 1
_dummy$9 = -13						; size = 1
_dummy$10 = -13						; size = 1
__$EHRec$ = -12						; size = 12
_fileName$ = 8						; size = 4
tv1173 = 12						; size = 4
$T11 = 12						; size = 4
_width$ = 12						; size = 4
_inbyte$12 = 15						; size = 1
_msg$13 = 16						; size = 4
_height$ = 16						; size = 4
_dummy$14 = 19						; size = 1
?LoadBMP@BMPFile@@QAEPAEV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAI1@Z PROC ; BMPFile::LoadBMP, COMDAT
; _this$ = ecx

; 31   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?LoadBMP@BMPFile@@QAEPAEV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAI1@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 7c	 sub	 esp, 124		; 0000007cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b f1		 mov	 esi, ecx
  0002a	89 75 b0	 mov	 DWORD PTR _this$1$[ebp], esi
  0002d	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0

; 32   : 	BITMAP inBM;
; 33   : 
; 34   : 	BYTE m1,m2;
; 35   :     long filesize;
; 36   :     short res1,res2;
; 37   :     long pixoff;
; 38   :     long bmisize;                    
; 39   :     long compression;
; 40   :     unsigned long sizeimage;
; 41   :     long xscale, yscale;
; 42   :     long colors;
; 43   :     long impcol;
; 44   :     
; 45   : 
; 46   : 	BYTE *outBuf=NULL;
; 47   : 	
; 48   : 	// for safety
; 49   : 	*width=0; *height=0;

  00034	8b 45 0c	 mov	 eax, DWORD PTR _width$[ebp]

; 50   : 
; 51   : 	// init
; 52   : 	m_errorText="OK";

  00037	68 00 00 00 00	 push	 OFFSET ??_C@_02GIPFHKNO@OK@
  0003c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00043	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00049	8b 45 10	 mov	 eax, DWORD PTR _height$[ebp]
  0004c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00052	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z

; 53   : 	m_bytesRead=0;
; 54   : 
; 55   : 	FILE *fp;
; 56   : 	
; 57   : 	fp=fopen(fileName,"rb");

  00058	68 00 00 00 00	 push	 OFFSET ??_C@_02JDPG@rb@
  0005d	ff 75 08	 push	 DWORD PTR _fileName$[ebp]
  00060	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00067	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  0006d	8b d8		 mov	 ebx, eax
  0006f	83 c4 08	 add	 esp, 8

; 58   : 	if (fp==NULL) {

  00072	85 db		 test	 ebx, ebx
  00074	75 76		 jne	 SHORT $LN22@LoadBMP

; 59   : 		CString msg;                    

  00076	8d 4d 10	 lea	 ecx, DWORD PTR _msg$13[ebp]
  00079	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h

; 2412 : 		CStringT strResult( str2.GetManager() );

  0007f	8d 4d 08	 lea	 ecx, DWORD PTR _fileName$[ebp]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\BmpFile.cpp

; 60   : 		msg="Can't open file for reading :\n"+fileName;

  00082	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h

; 2412 : 		CStringT strResult( str2.GetManager() );

  00086	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetManager@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEPAUIAtlStringMgr@2@XZ
  0008c	50		 push	 eax
  0008d	8d 4d 0c	 lea	 ecx, DWORD PTR $T11[ebp]
  00090	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PAUIAtlStringMgr@1@@Z
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h

; 519  : 		return( GetData()->nDataLength );

  00096	8b 45 08	 mov	 eax, DWORD PTR _fileName$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h

; 2416 : 		return( strResult );

  00099	c7 45 cc 01 00
	00 00		 mov	 DWORD PTR $T2[ebp], 1
  000a0	ff 70 f4	 push	 DWORD PTR [eax-12]
  000a3	50		 push	 eax
  000a4	6a 1e		 push	 30			; 0000001eH
  000a6	8d 45 0c	 lea	 eax, DWORD PTR $T11[ebp]
  000a9	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@HHLNPFOM@Can?8t?5open?5file?5for?5reading?5?3?6@
  000ae	50		 push	 eax
  000af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Concatenate@?$CSimpleStringT@D$00@ATL@@KAXAAV12@PBDH1H@Z
  000b5	83 c4 14	 add	 esp, 20			; 00000014H
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\BmpFile.cpp

; 60   : 		msg="Can't open file for reading :\n"+fileName;

  000b8	8d 45 0c	 lea	 eax, DWORD PTR $T11[ebp]
  000bb	8d 4d 10	 lea	 ecx, DWORD PTR _msg$13[ebp]
  000be	50		 push	 eax
  000bf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
  000c5	8d 4d 0c	 lea	 ecx, DWORD PTR $T11[ebp]
  000c8	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  000cc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 61   : 		m_errorText=msg;

  000d2	8d 45 10	 lea	 eax, DWORD PTR _msg$13[ebp]
  000d5	8b ce		 mov	 ecx, esi
  000d7	50		 push	 eax
  000d8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z

; 62   : 		return NULL;

  000de	8d 4d 10	 lea	 ecx, DWORD PTR _msg$13[ebp]
  000e1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  000e7	e9 f3 05 00 00	 jmp	 $LN71@LoadBMP
$LN22@LoadBMP:

; 63   : 	} else {
; 64   : 	    long rc;
; 65   : 		rc=fread((BYTE  *)&(m1),1,1,fp); m_bytesRead+=1;

  000ec	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__fread
  000f2	8d 45 f2	 lea	 eax, DWORD PTR _m1$[ebp]
  000f5	53		 push	 ebx
  000f6	6a 01		 push	 1
  000f8	6a 01		 push	 1
  000fa	50		 push	 eax
  000fb	ff d7		 call	 edi
  000fd	ff 46 04	 inc	 DWORD PTR [esi+4]
  00100	83 c4 10	 add	 esp, 16			; 00000010H

; 66   : 		if (rc==-1) {m_errorText="Read Error!"; fclose(fp); return NULL;}

  00103	83 f8 ff	 cmp	 eax, -1
  00106	75 0a		 jne	 SHORT $LN24@LoadBMP
$LN153@LoadBMP:

; 71   : 			m_errorText="Not a valid BMP File";

  00108	68 00 00 00 00	 push	 OFFSET ??_C@_0M@NIFBBBPK@Read?5Error?$CB@
  0010d	e9 bb 05 00 00	 jmp	 $LN160@LoadBMP
$LN24@LoadBMP:

; 67   : 
; 68   : 		rc=fread((BYTE  *)&(m2),1,1,fp); m_bytesRead+=1;

  00112	53		 push	 ebx
  00113	6a 01		 push	 1
  00115	8d 45 f1	 lea	 eax, DWORD PTR _m2$[ebp]
  00118	6a 01		 push	 1
  0011a	50		 push	 eax
  0011b	ff d7		 call	 edi
  0011d	ff 46 04	 inc	 DWORD PTR [esi+4]
  00120	83 c4 10	 add	 esp, 16			; 00000010H

; 69   : 		if (rc==-1) m_errorText="Read Error!";

  00123	83 f8 ff	 cmp	 eax, -1
  00126	75 0d		 jne	 SHORT $LN25@LoadBMP
  00128	68 00 00 00 00	 push	 OFFSET ??_C@_0M@NIFBBBPK@Read?5Error?$CB@
  0012d	8b ce		 mov	 ecx, esi
  0012f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z
$LN25@LoadBMP:

; 70   : 		if ((m1!='B') || (m2!='M')) {

  00135	80 7d f2 42	 cmp	 BYTE PTR _m1$[ebp], 66	; 00000042H
  00139	0f 85 89 05 00
	00		 jne	 $LN27@LoadBMP
  0013f	80 7d f1 4d	 cmp	 BYTE PTR _m2$[ebp], 77	; 0000004dH
  00143	0f 85 7f 05 00
	00		 jne	 $LN27@LoadBMP

; 73   : 			return NULL;
; 74   :         }
; 75   :         
; 76   : 		////////////////////////////////////////////////////////////////////////////
; 77   : 		//
; 78   : 		//	read a ton of header stuff
; 79   : 
; 80   : 		rc=fread((long  *)&(filesize),4,1,fp); m_bytesRead+=4;

  00149	53		 push	 ebx
  0014a	6a 01		 push	 1
  0014c	8d 45 8c	 lea	 eax, DWORD PTR _filesize$[ebp]
  0014f	6a 04		 push	 4
  00151	50		 push	 eax
  00152	ff d7		 call	 edi
  00154	83 46 04 04	 add	 DWORD PTR [esi+4], 4
  00158	83 c4 10	 add	 esp, 16			; 00000010H

; 81   : 		if (rc!=1) {m_errorText="Read Error!"; fclose(fp); return NULL;}

  0015b	83 f8 01	 cmp	 eax, 1
  0015e	75 a8		 jne	 SHORT $LN153@LoadBMP

; 82   : 
; 83   : 		rc=fread((int  *)&(res1),2,1,fp); m_bytesRead+=2;

  00160	53		 push	 ebx
  00161	50		 push	 eax
  00162	8d 45 bc	 lea	 eax, DWORD PTR _res1$[ebp]
  00165	6a 02		 push	 2
  00167	50		 push	 eax
  00168	ff d7		 call	 edi
  0016a	83 46 04 02	 add	 DWORD PTR [esi+4], 2
  0016e	83 c4 10	 add	 esp, 16			; 00000010H

; 84   : 		if (rc!=1) {m_errorText="Read Error!"; fclose(fp); return NULL;}

  00171	83 f8 01	 cmp	 eax, 1
  00174	75 92		 jne	 SHORT $LN153@LoadBMP

; 85   : 
; 86   : 		rc=fread((int  *)&(res2),2,1,fp); m_bytesRead+=2;

  00176	53		 push	 ebx
  00177	50		 push	 eax
  00178	8d 45 b8	 lea	 eax, DWORD PTR _res2$[ebp]
  0017b	6a 02		 push	 2
  0017d	50		 push	 eax
  0017e	ff d7		 call	 edi
  00180	83 46 04 02	 add	 DWORD PTR [esi+4], 2
  00184	83 c4 10	 add	 esp, 16			; 00000010H

; 87   : 		if (rc!=1) {m_errorText="Read Error!"; fclose(fp); return NULL;}

  00187	83 f8 01	 cmp	 eax, 1
  0018a	0f 85 78 ff ff
	ff		 jne	 $LN153@LoadBMP

; 88   : 
; 89   : 		rc=fread((long  *)&(pixoff),4,1,fp); m_bytesRead+=4;

  00190	53		 push	 ebx
  00191	50		 push	 eax
  00192	8d 45 e4	 lea	 eax, DWORD PTR _pixoff$[ebp]
  00195	6a 04		 push	 4
  00197	50		 push	 eax
  00198	ff d7		 call	 edi
  0019a	83 46 04 04	 add	 DWORD PTR [esi+4], 4
  0019e	83 c4 10	 add	 esp, 16			; 00000010H

; 90   : 		if (rc!=1) {m_errorText="Read Error!"; fclose(fp); return NULL;}

  001a1	83 f8 01	 cmp	 eax, 1
  001a4	0f 85 5e ff ff
	ff		 jne	 $LN153@LoadBMP

; 91   : 
; 92   : 		rc=fread((long  *)&(bmisize),4,1,fp); m_bytesRead+=4;

  001aa	53		 push	 ebx
  001ab	50		 push	 eax
  001ac	8d 45 88	 lea	 eax, DWORD PTR _bmisize$[ebp]
  001af	6a 04		 push	 4
  001b1	50		 push	 eax
  001b2	ff d7		 call	 edi
  001b4	83 46 04 04	 add	 DWORD PTR [esi+4], 4
  001b8	83 c4 10	 add	 esp, 16			; 00000010H

; 93   : 		if (rc!=1) {m_errorText="Read Error!"; fclose(fp); return NULL;}

  001bb	83 f8 01	 cmp	 eax, 1
  001be	0f 85 44 ff ff
	ff		 jne	 $LN153@LoadBMP

; 94   : 
; 95   : 		rc=fread((long  *)&(inBM.bmWidth),4,1,fp);	 m_bytesRead+=4;

  001c4	53		 push	 ebx
  001c5	50		 push	 eax
  001c6	8d 45 94	 lea	 eax, DWORD PTR _inBM$[ebp+4]
  001c9	6a 04		 push	 4
  001cb	50		 push	 eax
  001cc	ff d7		 call	 edi
  001ce	83 46 04 04	 add	 DWORD PTR [esi+4], 4
  001d2	83 c4 10	 add	 esp, 16			; 00000010H

; 96   : 		if (rc!=1) {m_errorText="Read Error!"; fclose(fp); return NULL;}

  001d5	83 f8 01	 cmp	 eax, 1
  001d8	0f 85 2a ff ff
	ff		 jne	 $LN153@LoadBMP

; 97   : 
; 98   : 		rc=fread((long  *)&(inBM.bmHeight),4,1,fp); m_bytesRead+=4;

  001de	53		 push	 ebx
  001df	50		 push	 eax
  001e0	8d 45 98	 lea	 eax, DWORD PTR _inBM$[ebp+8]
  001e3	6a 04		 push	 4
  001e5	50		 push	 eax
  001e6	ff d7		 call	 edi
  001e8	83 46 04 04	 add	 DWORD PTR [esi+4], 4
  001ec	83 c4 10	 add	 esp, 16			; 00000010H

; 99   : 		if (rc!=1) {m_errorText="Read Error!"; fclose(fp); return NULL;}

  001ef	83 f8 01	 cmp	 eax, 1
  001f2	0f 85 10 ff ff
	ff		 jne	 $LN153@LoadBMP

; 100  : 
; 101  : 		rc=fread((int  *)&(inBM.bmPlanes),2,1,fp); m_bytesRead+=2;

  001f8	53		 push	 ebx
  001f9	50		 push	 eax
  001fa	8d 45 a0	 lea	 eax, DWORD PTR _inBM$[ebp+16]
  001fd	6a 02		 push	 2
  001ff	50		 push	 eax
  00200	ff d7		 call	 edi
  00202	83 46 04 02	 add	 DWORD PTR [esi+4], 2
  00206	83 c4 10	 add	 esp, 16			; 00000010H

; 102  : 		if (rc!=1) {m_errorText="Read Error!"; fclose(fp); return NULL;}

  00209	83 f8 01	 cmp	 eax, 1
  0020c	0f 85 f6 fe ff
	ff		 jne	 $LN153@LoadBMP

; 103  : 
; 104  : 		rc=fread((int  *)&(inBM.bmBitsPixel),2,1,fp); m_bytesRead+=2;

  00212	53		 push	 ebx
  00213	50		 push	 eax
  00214	8d 45 a2	 lea	 eax, DWORD PTR _inBM$[ebp+18]
  00217	6a 02		 push	 2
  00219	50		 push	 eax
  0021a	ff d7		 call	 edi
  0021c	83 46 04 02	 add	 DWORD PTR [esi+4], 2
  00220	83 c4 10	 add	 esp, 16			; 00000010H

; 105  : 		if (rc!=1) {m_errorText="Read Error!"; fclose(fp); return NULL;}

  00223	83 f8 01	 cmp	 eax, 1
  00226	0f 85 dc fe ff
	ff		 jne	 $LN153@LoadBMP

; 106  : 
; 107  : 		rc=fread((long  *)&(compression),4,1,fp); m_bytesRead+=4;

  0022c	53		 push	 ebx
  0022d	50		 push	 eax
  0022e	8d 45 b4	 lea	 eax, DWORD PTR _compression$[ebp]
  00231	6a 04		 push	 4
  00233	50		 push	 eax
  00234	ff d7		 call	 edi
  00236	83 46 04 04	 add	 DWORD PTR [esi+4], 4
  0023a	83 c4 10	 add	 esp, 16			; 00000010H

; 108  : 		if (rc!=1) {m_errorText="Read Error!"; fclose(fp); return NULL;}

  0023d	83 f8 01	 cmp	 eax, 1
  00240	0f 85 c2 fe ff
	ff		 jne	 $LN153@LoadBMP

; 109  : 
; 110  : 		rc=fread((long  *)&(sizeimage),4,1,fp); m_bytesRead+=4;

  00246	53		 push	 ebx
  00247	50		 push	 eax
  00248	8d 45 84	 lea	 eax, DWORD PTR _sizeimage$[ebp]
  0024b	6a 04		 push	 4
  0024d	50		 push	 eax
  0024e	ff d7		 call	 edi
  00250	83 46 04 04	 add	 DWORD PTR [esi+4], 4
  00254	83 c4 10	 add	 esp, 16			; 00000010H

; 111  : 		if (rc!=1) {m_errorText="Read Error!"; fclose(fp); return NULL;}

  00257	83 f8 01	 cmp	 eax, 1
  0025a	0f 85 a8 fe ff
	ff		 jne	 $LN153@LoadBMP

; 112  : 
; 113  : 		rc=fread((long  *)&(xscale),4,1,fp); m_bytesRead+=4;

  00260	53		 push	 ebx
  00261	50		 push	 eax
  00262	8d 45 80	 lea	 eax, DWORD PTR _xscale$[ebp]
  00265	6a 04		 push	 4
  00267	50		 push	 eax
  00268	ff d7		 call	 edi
  0026a	83 46 04 04	 add	 DWORD PTR [esi+4], 4
  0026e	83 c4 10	 add	 esp, 16			; 00000010H

; 114  : 		if (rc!=1) {m_errorText="Read Error!"; fclose(fp); return NULL;}

  00271	83 f8 01	 cmp	 eax, 1
  00274	0f 85 8e fe ff
	ff		 jne	 $LN153@LoadBMP

; 115  : 
; 116  : 		rc=fread((long  *)&(yscale),4,1,fp); m_bytesRead+=4;

  0027a	53		 push	 ebx
  0027b	50		 push	 eax
  0027c	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _yscale$[ebp]
  00282	6a 04		 push	 4
  00284	50		 push	 eax
  00285	ff d7		 call	 edi
  00287	83 46 04 04	 add	 DWORD PTR [esi+4], 4
  0028b	83 c4 10	 add	 esp, 16			; 00000010H

; 117  : 		if (rc!=1) {m_errorText="Read Error!"; fclose(fp); return NULL;}

  0028e	83 f8 01	 cmp	 eax, 1
  00291	0f 85 71 fe ff
	ff		 jne	 $LN153@LoadBMP

; 118  : 
; 119  : 		rc=fread((long  *)&(colors),4,1,fp); m_bytesRead+=4;

  00297	53		 push	 ebx
  00298	50		 push	 eax
  00299	8d 45 d4	 lea	 eax, DWORD PTR _colors$[ebp]
  0029c	6a 04		 push	 4
  0029e	50		 push	 eax
  0029f	ff d7		 call	 edi
  002a1	83 46 04 04	 add	 DWORD PTR [esi+4], 4
  002a5	83 c4 10	 add	 esp, 16			; 00000010H

; 120  : 		if (rc!=1) {m_errorText="Read Error!"; fclose(fp); return NULL;}

  002a8	83 f8 01	 cmp	 eax, 1
  002ab	0f 85 57 fe ff
	ff		 jne	 $LN153@LoadBMP

; 121  : 
; 122  : 		rc=fread((long  *)&(impcol),4,1,fp); m_bytesRead+=4;

  002b1	53		 push	 ebx
  002b2	50		 push	 eax
  002b3	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR _impcol$[ebp]
  002b9	6a 04		 push	 4
  002bb	50		 push	 eax
  002bc	ff d7		 call	 edi
  002be	83 46 04 04	 add	 DWORD PTR [esi+4], 4
  002c2	83 c4 10	 add	 esp, 16			; 00000010H

; 123  : 		if (rc!=1) {m_errorText="Read Error!"; fclose(fp); return NULL;}

  002c5	83 f8 01	 cmp	 eax, 1
  002c8	0f 85 3a fe ff
	ff		 jne	 $LN153@LoadBMP

; 124  : 
; 125  : 		////////////////////////////////////////////////////////////////////////////
; 126  : 		//	i don't do RLE files
; 127  : 
; 128  : 		if (compression!=BI_RGB) {

  002ce	83 7d b4 00	 cmp	 DWORD PTR _compression$[ebp], 0
  002d2	74 0a		 je	 SHORT $LN43@LoadBMP

; 129  : 	    	m_errorText="This is a compressed file.";

  002d4	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@HNHBJFDG@This?5is?5a?5compressed?5file?4@

; 130  : 	    	fclose(fp);
; 131  : 	    	return NULL;

  002d9	e9 ef 03 00 00	 jmp	 $LN160@LoadBMP
$LN43@LoadBMP:

; 132  : 	    }
; 133  : 
; 134  : 		if (colors == 0) {

  002de	8b 45 d4	 mov	 eax, DWORD PTR _colors$[ebp]
  002e1	8b 55 a2	 mov	 edx, DWORD PTR _inBM$[ebp+18]
  002e4	85 c0		 test	 eax, eax
  002e6	75 0c		 jne	 SHORT $LN44@LoadBMP

; 135  : 			colors = 1 << inBM.bmBitsPixel;

  002e8	b8 01 00 00 00	 mov	 eax, 1
  002ed	8a ca		 mov	 cl, dl
  002ef	d3 e0		 shl	 eax, cl
  002f1	89 45 d4	 mov	 DWORD PTR _colors$[ebp], eax
$LN44@LoadBMP:

; 136  : 		}
; 137  : 
; 138  : 
; 139  : 		////////////////////////////////////////////////////////////////////////////
; 140  : 		// read colormap
; 141  : 
; 142  : 		RGBQUAD *colormap = NULL;
; 143  : 
; 144  : 		switch (inBM.bmBitsPixel) {

  002f4	0f b7 ca	 movzx	 ecx, dx
  002f7	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _colormap$1$[ebp], 0
  002fe	83 e9 01	 sub	 ecx, 1
  00301	74 0e		 je	 SHORT $LN46@LoadBMP
  00303	83 e9 03	 sub	 ecx, 3
  00306	74 09		 je	 SHORT $LN46@LoadBMP
  00308	83 e9 04	 sub	 ecx, 4
  0030b	0f 85 d8 00 00
	00		 jne	 $LN5@LoadBMP
$LN46@LoadBMP:

; 145  : 		case 24:
; 146  : 			break;
; 147  : 			// read pallete 
; 148  : 		case 1:
; 149  : 		case 4:
; 150  : 		case 8:
; 151  : 			colormap = new RGBQUAD[colors];

  00311	33 c9		 xor	 ecx, ecx
  00313	ba 04 00 00 00	 mov	 edx, 4
  00318	f7 e2		 mul	 edx
  0031a	0f 90 c1	 seto	 cl
  0031d	f7 d9		 neg	 ecx
  0031f	0b c8		 or	 ecx, eax
  00321	51		 push	 ecx
  00322	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00327	83 c4 04	 add	 esp, 4
  0032a	89 45 e8	 mov	 DWORD PTR _colormap$1$[ebp], eax

; 152  : 			if (colormap==NULL) {

  0032d	85 c0		 test	 eax, eax
  0032f	75 1c		 jne	 SHORT $LN49@LoadBMP

; 153  : 				fclose(fp);

  00331	53		 push	 ebx
  00332	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  00338	83 c4 04	 add	 esp, 4

; 154  : 				m_errorText="Out of memory";

  0033b	8b ce		 mov	 ecx, esi
  0033d	68 00 00 00 00	 push	 OFFSET ??_C@_0O@NALGGDJF@Out?5of?5memory@
  00342	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z

; 155  : 				return NULL;

  00348	e9 92 03 00 00	 jmp	 $LN71@LoadBMP
$LN49@LoadBMP:

; 156  : 			}
; 157  : 
; 158  : 			int i;
; 159  : 			for (i=0;i<colors;i++) {

  0034d	83 7d d4 00	 cmp	 DWORD PTR _colors$[ebp], 0
  00351	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _i$1$[ebp], 0
  00358	0f 8e 8b 00 00
	00		 jle	 $LN5@LoadBMP
  0035e	40		 inc	 eax
  0035f	89 45 e0	 mov	 DWORD PTR tv1165[ebp], eax
$LL6@LoadBMP:

; 160  : 				BYTE r,g,b, dummy;
; 161  : 
; 162  : 				rc=fread((BYTE *)&(b),1,1,fp);

  00362	53		 push	 ebx
  00363	6a 01		 push	 1
  00365	8d 45 ee	 lea	 eax, DWORD PTR _b$5[ebp]
  00368	6a 01		 push	 1
  0036a	50		 push	 eax
  0036b	ff d7		 call	 edi

; 163  : 				m_bytesRead++;

  0036d	ff 46 04	 inc	 DWORD PTR [esi+4]
  00370	83 c4 10	 add	 esp, 16			; 00000010H

; 164  : 				if (rc!=1) {

  00373	83 f8 01	 cmp	 eax, 1
  00376	0f 85 a1 00 00
	00		 jne	 $LN123@LoadBMP

; 165  : 					m_errorText="Read Error!";	
; 166  : 					delete [] colormap;
; 167  : 					fclose(fp);
; 168  : 					return NULL;
; 169  : 				}
; 170  : 
; 171  : 				rc=fread((BYTE  *)&(g),1,1,fp); 

  0037c	53		 push	 ebx
  0037d	50		 push	 eax
  0037e	50		 push	 eax
  0037f	8d 45 ef	 lea	 eax, DWORD PTR _g$6[ebp]
  00382	50		 push	 eax
  00383	ff d7		 call	 edi

; 172  : 				m_bytesRead++;

  00385	ff 46 04	 inc	 DWORD PTR [esi+4]
  00388	83 c4 10	 add	 esp, 16			; 00000010H

; 173  : 				if (rc!=1) {

  0038b	83 f8 01	 cmp	 eax, 1
  0038e	0f 85 89 00 00
	00		 jne	 $LN123@LoadBMP

; 174  : 					m_errorText="Read Error!";	
; 175  : 					delete [] colormap;
; 176  : 					fclose(fp);
; 177  : 					return NULL;
; 178  : 				}
; 179  : 
; 180  : 				rc=fread((BYTE  *)&(r),1,1,fp); 

  00394	53		 push	 ebx
  00395	50		 push	 eax
  00396	50		 push	 eax
  00397	8d 45 f0	 lea	 eax, DWORD PTR _r$7[ebp]
  0039a	50		 push	 eax
  0039b	ff d7		 call	 edi

; 181  : 				m_bytesRead++;

  0039d	ff 46 04	 inc	 DWORD PTR [esi+4]
  003a0	83 c4 10	 add	 esp, 16			; 00000010H

; 182  : 				if (rc!=1) {

  003a3	83 f8 01	 cmp	 eax, 1
  003a6	75 75		 jne	 SHORT $LN123@LoadBMP

; 183  : 					m_errorText="Read Error!";	
; 184  : 					delete [] colormap;
; 185  : 					fclose(fp);
; 186  : 					return NULL;
; 187  : 				}
; 188  : 
; 189  : 
; 190  : 				rc=fread((BYTE  *)&(dummy),1,1,fp); 

  003a8	53		 push	 ebx
  003a9	50		 push	 eax
  003aa	50		 push	 eax
  003ab	8d 45 f3	 lea	 eax, DWORD PTR _dummy$10[ebp]
  003ae	50		 push	 eax
  003af	ff d7		 call	 edi

; 191  : 				m_bytesRead++;

  003b1	ff 46 04	 inc	 DWORD PTR [esi+4]
  003b4	83 c4 10	 add	 esp, 16			; 00000010H

; 192  : 				if (rc!=1) {

  003b7	83 f8 01	 cmp	 eax, 1
  003ba	75 61		 jne	 SHORT $LN123@LoadBMP

; 197  : 				}
; 198  : 
; 199  : 				colormap[i].rgbRed=r;

  003bc	8b 4d e0	 mov	 ecx, DWORD PTR tv1165[ebp]
  003bf	0f b6 45 f0	 movzx	 eax, BYTE PTR _r$7[ebp]
  003c3	88 41 01	 mov	 BYTE PTR [ecx+1], al

; 200  : 				colormap[i].rgbGreen=g;

  003c6	0f b6 45 ef	 movzx	 eax, BYTE PTR _g$6[ebp]
  003ca	88 01		 mov	 BYTE PTR [ecx], al

; 201  : 				colormap[i].rgbBlue=b;

  003cc	0f b6 45 ee	 movzx	 eax, BYTE PTR _b$5[ebp]
  003d0	88 41 ff	 mov	 BYTE PTR [ecx-1], al
  003d3	83 c1 04	 add	 ecx, 4
  003d6	8b 45 dc	 mov	 eax, DWORD PTR _i$1$[ebp]
  003d9	40		 inc	 eax
  003da	89 4d e0	 mov	 DWORD PTR tv1165[ebp], ecx
  003dd	89 45 dc	 mov	 DWORD PTR _i$1$[ebp], eax
  003e0	3b 45 d4	 cmp	 eax, DWORD PTR _colors$[ebp]
  003e3	0f 8c 79 ff ff
	ff		 jl	 $LL6@LoadBMP
$LN5@LoadBMP:

; 202  : 			}
; 203  : 			break;
; 204  : 		}
; 205  : 
; 206  : 
; 207  : 		if ((long)m_bytesRead>pixoff) {

  003e9	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  003ec	3b 45 e4	 cmp	 eax, DWORD PTR _pixoff$[ebp]
  003ef	7e 50		 jle	 SHORT $LN114@LoadBMP

; 208  : 			fclose(fp);

  003f1	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__fclose
  003f7	53		 push	 ebx
  003f8	ff d7		 call	 edi
  003fa	83 c4 04	 add	 esp, 4

; 209  : 			m_errorText="Corrupt palette";

  003fd	8b ce		 mov	 ecx, esi
  003ff	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@OMCPEENF@Corrupt?5palette@
  00404	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z

; 210  : 			delete [] colormap;

  0040a	ff 75 e8	 push	 DWORD PTR _colormap$1$[ebp]
  0040d	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]

; 211  : 			fclose(fp);

  00412	53		 push	 ebx
  00413	ff d7		 call	 edi
  00415	83 c4 08	 add	 esp, 8

; 212  : 			return NULL;

  00418	e9 c2 02 00 00	 jmp	 $LN71@LoadBMP
$LN123@LoadBMP:

; 193  : 					m_errorText="Read Error!";	

  0041d	68 00 00 00 00	 push	 OFFSET ??_C@_0M@NIFBBBPK@Read?5Error?$CB@
  00422	8b ce		 mov	 ecx, esi
  00424	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z

; 194  : 					delete [] colormap;

  0042a	ff 75 e8	 push	 DWORD PTR _colormap$1$[ebp]
  0042d	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]

; 195  : 					fclose(fp);

  00432	53		 push	 ebx
  00433	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  00439	83 c4 08	 add	 esp, 8

; 196  : 					return NULL;

  0043c	e9 9e 02 00 00	 jmp	 $LN71@LoadBMP
$LN114@LoadBMP:

; 213  : 		}
; 214  : 
; 215  : 		while ((long)m_bytesRead<pixoff) {

  00441	7d 19		 jge	 SHORT $LN151@LoadBMP
$LL7@LoadBMP:

; 216  : 			char dummy;
; 217  : 			fread(&dummy,1,1,fp);

  00443	53		 push	 ebx
  00444	6a 01		 push	 1
  00446	8d 45 f3	 lea	 eax, DWORD PTR _dummy$9[ebp]
  00449	6a 01		 push	 1
  0044b	50		 push	 eax
  0044c	ff d7		 call	 edi

; 218  : 			m_bytesRead++;

  0044e	ff 46 04	 inc	 DWORD PTR [esi+4]
  00451	83 c4 10	 add	 esp, 16			; 00000010H
  00454	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00457	3b 45 e4	 cmp	 eax, DWORD PTR _pixoff$[ebp]
  0045a	7c e7		 jl	 SHORT $LL7@LoadBMP
$LN151@LoadBMP:

; 219  : 		}
; 220  : 
; 221  : 		int w=inBM.bmWidth;
; 222  : 		int h=inBM.bmHeight;
; 223  : 
; 224  : 		// set the output params
; 225  : 		*width=w;

  0045c	8b 45 0c	 mov	 eax, DWORD PTR _width$[ebp]
  0045f	8b 55 94	 mov	 edx, DWORD PTR _inBM$[ebp+4]

; 226  : 		*height=h;

  00462	8b 4d 98	 mov	 ecx, DWORD PTR _inBM$[ebp+8]
  00465	89 55 c4	 mov	 DWORD PTR _w$1$[ebp], edx
  00468	89 10		 mov	 DWORD PTR [eax], edx
  0046a	8b 45 10	 mov	 eax, DWORD PTR _height$[ebp]
  0046d	89 08		 mov	 DWORD PTR [eax], ecx
  0046f	8d 04 52	 lea	 eax, DWORD PTR [edx+edx*2]
  00472	89 45 e0	 mov	 DWORD PTR _row_size$1$[ebp], eax

; 227  : 
; 228  : 		long row_size = w * 3;
; 229  : 
; 230  : 		long bufsize = (long)w * 3 * (long)h;

  00475	8b c2		 mov	 eax, edx
  00477	0f af c1	 imul	 eax, ecx
  0047a	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]

; 231  : 
; 232  : 		////////////////////////////////////////////////////////////////////////////
; 233  : 		// alloc our buffer
; 234  : 
; 235  : 		outBuf=(BYTE *) new BYTE [bufsize];

  0047d	50		 push	 eax
  0047e	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00483	8b d0		 mov	 edx, eax
  00485	83 c4 04	 add	 esp, 4
  00488	89 55 d0	 mov	 DWORD PTR $T3[ebp], edx

; 236  : 		memset(outBuf, 0, sizeof(outBuf));

  0048b	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 237  : 		if (outBuf==NULL) {

  00491	85 d2		 test	 edx, edx
  00493	75 2f		 jne	 SHORT $LN55@LoadBMP

; 238  : 			m_errorText="Memory alloc Failed";

  00495	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@DEKFFFHK@Memory?5alloc?5Failed@
  0049a	8b ce		 mov	 ecx, esi
  0049c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z
$LN154@LoadBMP:

; 334  : 					}
; 335  : 				}
; 336  : 			}
; 337  : 		
; 338  : 		}
; 339  : 
; 340  : 		if (colormap) {

  004a2	8b 45 e8	 mov	 eax, DWORD PTR _colormap$1$[ebp]
  004a5	85 c0		 test	 eax, eax
  004a7	74 09		 je	 SHORT $LN65@LoadBMP

; 341  : 			delete [] colormap;

  004a9	50		 push	 eax
  004aa	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  004af	83 c4 04	 add	 esp, 4
$LN65@LoadBMP:

; 342  : 		}
; 343  : 
; 344  : 		fclose(fp);

  004b2	53		 push	 ebx
  004b3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose

; 345  : 
; 346  :     }
; 347  : 
; 348  : 	return outBuf;

  004b9	8b 75 d0	 mov	 esi, DWORD PTR $T3[ebp]
  004bc	83 c4 04	 add	 esp, 4
  004bf	e9 1d 02 00 00	 jmp	 $LN97@LoadBMP
$LN55@LoadBMP:

; 239  : 		} else {
; 240  : 
; 241  : 			////////////////////////////////////////////////////////////////////////////
; 242  : 			//	read it
; 243  : 
; 244  : 			long row=0;
; 245  : 			long rowOffset=0;
; 246  : 
; 247  : 			// read rows in reverse order
; 248  : 			for (row=inBM.bmHeight-1;row>=0;row--) {

  004c4	8b 4d 98	 mov	 ecx, DWORD PTR _inBM$[ebp+8]
  004c7	83 e9 01	 sub	 ecx, 1
  004ca	89 4d cc	 mov	 DWORD PTR _row$1$[ebp], ecx
  004cd	78 d3		 js	 SHORT $LN154@LoadBMP
  004cf	8b c1		 mov	 eax, ecx
  004d1	0f af 45 e0	 imul	 eax, DWORD PTR _row_size$1$[ebp]
  004d5	40		 inc	 eax
  004d6	03 c2		 add	 eax, edx
  004d8	89 45 dc	 mov	 DWORD PTR tv1158[ebp], eax
  004db	0f 1f 44 00 00	 npad	 5
$LL11@LoadBMP:

; 249  : 
; 250  : 				// which row are we working on?
; 251  : 				rowOffset=(long unsigned)row*row_size;						      
; 252  : 
; 253  : 				if (inBM.bmBitsPixel==24) {

  004e0	66 83 7d a2 18	 cmp	 WORD PTR _inBM$[ebp+18], 24 ; 00000018H
  004e5	0f 85 7e 00 00
	00		 jne	 $LN57@LoadBMP

; 254  : 
; 255  : 					for (int col=0;col<w;col++) {

  004eb	8b 4d c4	 mov	 ecx, DWORD PTR _w$1$[ebp]
  004ee	85 c9		 test	 ecx, ecx
  004f0	7e 39		 jle	 SHORT $LN13@LoadBMP
  004f2	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
  004f5	89 4d 0c	 mov	 DWORD PTR tv1173[ebp], ecx
$LL14@LoadBMP:

; 256  : 						long offset = col * 3;
; 257  : 						char pixel[3];
; 258  : 
; 259  : 						if (fread((void  *)(pixel),1,3,fp)==3) {

  004f8	53		 push	 ebx
  004f9	6a 03		 push	 3
  004fb	8d 45 d8	 lea	 eax, DWORD PTR _pixel$4[ebp]
  004fe	6a 01		 push	 1
  00500	50		 push	 eax
  00501	ff d7		 call	 edi
  00503	83 c4 10	 add	 esp, 16			; 00000010H
  00506	83 f8 03	 cmp	 eax, 3
  00509	75 14		 jne	 SHORT $LN12@LoadBMP

; 260  : 							// we swap red and blue here
; 261  : 							*(outBuf + rowOffset + offset + 0)=pixel[2];		// r

  0050b	0f b6 45 da	 movzx	 eax, BYTE PTR _pixel$4[ebp+2]
  0050f	88 46 fe	 mov	 BYTE PTR [esi-2], al

; 262  : 							*(outBuf + rowOffset + offset + 1)=pixel[1];		// g

  00512	0f b6 45 d9	 movzx	 eax, BYTE PTR _pixel$4[ebp+1]
  00516	88 46 ff	 mov	 BYTE PTR [esi-1], al

; 263  : 							*(outBuf + rowOffset + offset + 2)=pixel[0];		// b

  00519	0f b6 45 d8	 movzx	 eax, BYTE PTR _pixel$4[ebp]
  0051d	88 06		 mov	 BYTE PTR [esi], al
$LN12@LoadBMP:

; 254  : 
; 255  : 					for (int col=0;col<w;col++) {

  0051f	83 c6 03	 add	 esi, 3
  00522	83 6d 0c 01	 sub	 DWORD PTR tv1173[ebp], 1
  00526	75 d0		 jne	 SHORT $LL14@LoadBMP
  00528	8b 75 b0	 mov	 esi, DWORD PTR _this$1$[ebp]
$LN13@LoadBMP:

; 264  : 						}
; 265  : 
; 266  : 					}
; 267  : 
; 268  : 					m_bytesRead+=row_size;

  0052b	8b 45 e0	 mov	 eax, DWORD PTR _row_size$1$[ebp]
  0052e	01 46 04	 add	 DWORD PTR [esi+4], eax
  00531	8b 46 04	 mov	 eax, DWORD PTR [esi+4]

; 269  : 					
; 270  : 					// read DWORD padding
; 271  : 					while ((m_bytesRead-pixoff)&3) {

  00534	2b 45 e4	 sub	 eax, DWORD PTR _pixoff$[ebp]
  00537	a8 03		 test	 al, 3
  00539	0f 84 f5 00 00
	00		 je	 $LN9@LoadBMP
  0053f	90		 npad	 1
$LL15@LoadBMP:

; 272  : 						char dummy;
; 273  : 						if (fread(&dummy,1,1,fp)!=1) {

  00540	53		 push	 ebx
  00541	6a 01		 push	 1
  00543	8d 45 13	 lea	 eax, DWORD PTR _dummy$14[ebp]
  00546	6a 01		 push	 1
  00548	50		 push	 eax
  00549	ff d7		 call	 edi
  0054b	83 c4 10	 add	 esp, 16			; 00000010H
  0054e	83 f8 01	 cmp	 eax, 1
  00551	0f 85 fa 00 00
	00		 jne	 $LN124@LoadBMP

; 278  : 						}
; 279  : 
; 280  : 						m_bytesRead++;

  00557	ff 46 04	 inc	 DWORD PTR [esi+4]
  0055a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0055d	2b 45 e4	 sub	 eax, DWORD PTR _pixoff$[ebp]
  00560	a8 03		 test	 al, 3
  00562	75 dc		 jne	 SHORT $LL15@LoadBMP

; 269  : 					
; 270  : 					// read DWORD padding
; 271  : 					while ((m_bytesRead-pixoff)&3) {

  00564	e9 cb 00 00 00	 jmp	 $LN9@LoadBMP
$LN57@LoadBMP:

; 290  : 					UINT mask = (1 << inBM.bmBitsPixel) - 1;

  00569	8a 4d a2	 mov	 cl, BYTE PTR _inBM$[ebp+18]
  0056c	b8 01 00 00 00	 mov	 eax, 1
  00571	33 d2		 xor	 edx, edx
  00573	d3 e0		 shl	 eax, cl
  00575	48		 dec	 eax

; 291  : 
; 292  : 					BYTE inbyte=0;

  00576	88 55 0f	 mov	 BYTE PTR _inbyte$12[ebp], dl
  00579	89 45 a8	 mov	 DWORD PTR _mask$1$[ebp], eax

; 293  : 
; 294  : 					for (int col=0;col<w;col++) {

  0057c	89 55 c0	 mov	 DWORD PTR _col$1$[ebp], edx
  0057f	39 55 c4	 cmp	 DWORD PTR _w$1$[ebp], edx
  00582	0f 8e 77 00 00
	00		 jle	 $LN158@LoadBMP

; 281  : 					}
; 282  :  
; 283  : 					
; 284  : 				} else {	// 1, 4, or 8 bit image
; 285  : 
; 286  : 					////////////////////////////////////////////////////////////////
; 287  : 					// pixels are packed as 1 , 4 or 8 bit vals. need to unpack them
; 288  : 
; 289  : 					int bit_count = 0;

  00588	8b 45 dc	 mov	 eax, DWORD PTR tv1158[ebp]
  0058b	89 45 c8	 mov	 DWORD PTR tv1162[ebp], eax
  0058e	66 90		 npad	 2
$LL19@LoadBMP:

; 295  : 						
; 296  : 						int pix=0;
; 297  : 
; 298  : 						// if we need another byte
; 299  : 						if (bit_count <= 0) {

  00590	85 d2		 test	 edx, edx
  00592	7f 24		 jg	 SHORT $LN152@LoadBMP

; 300  : 							bit_count = 8;
; 301  : 							if (fread(&inbyte,1,1,fp)!=1) {

  00594	53		 push	 ebx
  00595	6a 01		 push	 1
  00597	8d 45 0f	 lea	 eax, DWORD PTR _inbyte$12[ebp]
  0059a	c7 45 ac 08 00
	00 00		 mov	 DWORD PTR _bit_count$1$[ebp], 8
  005a1	6a 01		 push	 1
  005a3	50		 push	 eax
  005a4	ff d7		 call	 edi
  005a6	83 c4 10	 add	 esp, 16			; 00000010H
  005a9	83 f8 01	 cmp	 eax, 1
  005ac	0f 85 c1 00 00
	00		 jne	 $LN125@LoadBMP

; 307  : 							}
; 308  : 							m_bytesRead++;

  005b2	ff 46 04	 inc	 DWORD PTR [esi+4]
  005b5	8b 55 ac	 mov	 edx, DWORD PTR _bit_count$1$[ebp]
$LN152@LoadBMP:

; 309  : 						}
; 310  : 
; 311  : 						// keep track of where we are in the bytes
; 312  : 						bit_count -= inBM.bmBitsPixel;

  005b8	0f b7 45 a2	 movzx	 eax, WORD PTR _inBM$[ebp+18]

; 313  : 						pix = ( inbyte >> bit_count) & mask;
; 314  : 
; 315  : 						// lookup the color from the colormap - stuff it in our buffer
; 316  : 						// swap red and blue
; 317  : 						*(outBuf + rowOffset + col * 3 + 2) = colormap[pix].rgbBlue;

  005bc	8b 7d c8	 mov	 edi, DWORD PTR tv1162[ebp]
  005bf	2b d0		 sub	 edx, eax
  005c1	0f b6 45 0f	 movzx	 eax, BYTE PTR _inbyte$12[ebp]
  005c5	8a ca		 mov	 cl, dl
  005c7	d3 e8		 shr	 eax, cl
  005c9	23 45 a8	 and	 eax, DWORD PTR _mask$1$[ebp]
  005cc	8b 4d e8	 mov	 ecx, DWORD PTR _colormap$1$[ebp]
  005cf	8d 0c 81	 lea	 ecx, DWORD PTR [ecx+eax*4]
  005d2	0f b6 01	 movzx	 eax, BYTE PTR [ecx]
  005d5	88 47 01	 mov	 BYTE PTR [edi+1], al

; 318  : 						*(outBuf + rowOffset + col * 3 + 1) = colormap[pix].rgbGreen;

  005d8	0f b6 41 01	 movzx	 eax, BYTE PTR [ecx+1]
  005dc	88 07		 mov	 BYTE PTR [edi], al

; 319  : 						*(outBuf + rowOffset + col * 3 + 0) = colormap[pix].rgbRed;

  005de	0f b6 41 02	 movzx	 eax, BYTE PTR [ecx+2]
  005e2	8b cf		 mov	 ecx, edi
  005e4	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__fread
  005ea	88 41 ff	 mov	 BYTE PTR [ecx-1], al
  005ed	83 c1 03	 add	 ecx, 3
  005f0	8b 45 c0	 mov	 eax, DWORD PTR _col$1$[ebp]
  005f3	40		 inc	 eax
  005f4	89 4d c8	 mov	 DWORD PTR tv1162[ebp], ecx
  005f7	89 45 c0	 mov	 DWORD PTR _col$1$[ebp], eax
  005fa	3b 45 c4	 cmp	 eax, DWORD PTR _w$1$[ebp]
  005fd	7c 91		 jl	 SHORT $LL19@LoadBMP
$LN158@LoadBMP:

; 320  : 					}
; 321  : 
; 322  : 					// read DWORD padding
; 323  : 					while ((m_bytesRead-pixoff)&3) {

  005ff	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00602	2b 45 e4	 sub	 eax, DWORD PTR _pixoff$[ebp]
  00605	a8 03		 test	 al, 3
  00607	74 2b		 je	 SHORT $LN9@LoadBMP
  00609	0f 1f 80 00 00
	00 00		 npad	 7
$LL20@LoadBMP:

; 324  : 						char dummy;
; 325  : 						if (fread(&dummy,1,1,fp)!=1) {

  00610	53		 push	 ebx
  00611	6a 01		 push	 1
  00613	8d 45 f3	 lea	 eax, DWORD PTR _dummy$8[ebp]
  00616	6a 01		 push	 1
  00618	50		 push	 eax
  00619	ff d7		 call	 edi
  0061b	83 c4 10	 add	 esp, 16			; 00000010H
  0061e	83 f8 01	 cmp	 eax, 1
  00621	0f 85 76 00 00
	00		 jne	 $LN126@LoadBMP

; 332  : 						}
; 333  : 						m_bytesRead++;

  00627	ff 46 04	 inc	 DWORD PTR [esi+4]
  0062a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0062d	2b 45 e4	 sub	 eax, DWORD PTR _pixoff$[ebp]
  00630	a8 03		 test	 al, 3
  00632	75 dc		 jne	 SHORT $LL20@LoadBMP
$LN9@LoadBMP:

; 239  : 		} else {
; 240  : 
; 241  : 			////////////////////////////////////////////////////////////////////////////
; 242  : 			//	read it
; 243  : 
; 244  : 			long row=0;
; 245  : 			long rowOffset=0;
; 246  : 
; 247  : 			// read rows in reverse order
; 248  : 			for (row=inBM.bmHeight-1;row>=0;row--) {

  00634	8b 4d cc	 mov	 ecx, DWORD PTR _row$1$[ebp]
  00637	8b 45 dc	 mov	 eax, DWORD PTR tv1158[ebp]
  0063a	49		 dec	 ecx
  0063b	2b 45 e0	 sub	 eax, DWORD PTR _row_size$1$[ebp]
  0063e	89 4d cc	 mov	 DWORD PTR _row$1$[ebp], ecx
  00641	89 45 dc	 mov	 DWORD PTR tv1158[ebp], eax
  00644	85 c9		 test	 ecx, ecx
  00646	0f 89 94 fe ff
	ff		 jns	 $LL11@LoadBMP
  0064c	e9 51 fe ff ff	 jmp	 $LN154@LoadBMP
$LN124@LoadBMP:

; 274  : 							m_errorText="Read Error";

  00651	68 00 00 00 00	 push	 OFFSET ??_C@_0L@BAFDDAPG@Read?5Error@
  00656	8b ce		 mov	 ecx, esi
  00658	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z

; 275  : 							delete [] outBuf;

  0065e	8b 75 d0	 mov	 esi, DWORD PTR $T3[ebp]
  00661	56		 push	 esi
  00662	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]

; 276  : 							fclose(fp);

  00667	53		 push	 ebx
  00668	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  0066e	83 c4 08	 add	 esp, 8

; 277  : 							return NULL;

  00671	eb 6c		 jmp	 SHORT $LN71@LoadBMP
$LN125@LoadBMP:

; 302  : 								m_errorText="Read Error";

  00673	68 00 00 00 00	 push	 OFFSET ??_C@_0L@BAFDDAPG@Read?5Error@
  00678	8b ce		 mov	 ecx, esi
  0067a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z

; 303  : 								delete [] outBuf;

  00680	8b 75 d0	 mov	 esi, DWORD PTR $T3[ebp]
  00683	56		 push	 esi
  00684	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]

; 304  : 								delete [] colormap;

  00689	ff 75 e8	 push	 DWORD PTR _colormap$1$[ebp]
  0068c	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]

; 305  : 								fclose(fp);

  00691	53		 push	 ebx
  00692	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  00698	83 c4 0c	 add	 esp, 12			; 0000000cH

; 306  : 								return NULL;

  0069b	eb 42		 jmp	 SHORT $LN71@LoadBMP
$LN126@LoadBMP:

; 326  : 							m_errorText="Read Error";

  0069d	68 00 00 00 00	 push	 OFFSET ??_C@_0L@BAFDDAPG@Read?5Error@
  006a2	8b ce		 mov	 ecx, esi
  006a4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z

; 327  : 							delete [] outBuf;

  006aa	8b 75 d0	 mov	 esi, DWORD PTR $T3[ebp]
  006ad	56		 push	 esi
  006ae	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]

; 328  : 							if (colormap)

  006b3	8b 45 e8	 mov	 eax, DWORD PTR _colormap$1$[ebp]
  006b6	83 c4 04	 add	 esp, 4
  006b9	85 c0		 test	 eax, eax
  006bb	74 18		 je	 SHORT $LN64@LoadBMP

; 329  : 								delete [] colormap;

  006bd	50		 push	 eax
  006be	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  006c3	83 c4 04	 add	 esp, 4

; 330  : 							fclose(fp);
; 331  : 							return NULL;

  006c6	eb 0d		 jmp	 SHORT $LN64@LoadBMP
$LN27@LoadBMP:

; 71   : 			m_errorText="Not a valid BMP File";

  006c8	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@PABLBDHA@Not?5a?5valid?5BMP?5File@
$LN160@LoadBMP:
  006cd	8b ce		 mov	 ecx, esi
  006cf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z
$LN64@LoadBMP:

; 72   : 			fclose(fp);

  006d5	53		 push	 ebx
  006d6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  006dc	83 c4 04	 add	 esp, 4
$LN71@LoadBMP:
  006df	33 f6		 xor	 esi, esi
$LN97@LoadBMP:

; 345  : 
; 346  :     }
; 347  : 
; 348  : 	return outBuf;

  006e1	8d 4d 08	 lea	 ecx, DWORD PTR _fileName$[ebp]
  006e4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  006ea	8b c6		 mov	 eax, esi

; 349  : }

  006ec	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  006ef	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  006f6	59		 pop	 ecx
  006f7	5f		 pop	 edi
  006f8	5e		 pop	 esi
  006f9	5b		 pop	 ebx
  006fa	8b e5		 mov	 esp, ebp
  006fc	5d		 pop	 ebp
  006fd	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LoadBMP@BMPFile@@QAEPAEV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAI1@Z$0:
  00000	8d 4d 08	 lea	 ecx, DWORD PTR _fileName$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?LoadBMP@BMPFile@@QAEPAEV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAI1@Z$1:
  00009	8d 4d 10	 lea	 ecx, DWORD PTR _msg$13[ebp]
  0000c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?LoadBMP@BMPFile@@QAEPAEV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAI1@Z$3:
  00012	8b 45 cc	 mov	 eax, DWORD PTR $T2[ebp]
  00015	83 e0 01	 and	 eax, 1
  00018	0f 84 0d 00 00
	00		 je	 $LN103@LoadBMP
  0001e	83 65 cc fe	 and	 DWORD PTR $T2[ebp], -2	; fffffffeH
  00022	8d 4d 0c	 lea	 ecx, DWORD PTR $T11[ebp]
  00025	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$LN103@LoadBMP:
  0002b	c3		 ret	 0
  0002c	cc		 int	 3
  0002d	cc		 int	 3
  0002e	cc		 int	 3
  0002f	cc		 int	 3
  00030	cc		 int	 3
__ehhandler$?LoadBMP@BMPFile@@QAEPAEV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAI1@Z:
  00031	90		 npad	 1
  00032	90		 npad	 1
  00033	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00037	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0003a	8b 8a 74 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-140]
  00040	33 c8		 xor	 ecx, eax
  00042	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00047	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?LoadBMP@BMPFile@@QAEPAEV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAI1@Z
  0004c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?LoadBMP@BMPFile@@QAEPAEV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAI1@Z ENDP ; BMPFile::LoadBMP
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\BmpFile.cpp
;	COMDAT ??0BMPFile@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0BMPFile@@QAE@XZ PROC					; BMPFile::BMPFile, COMDAT
; _this$ = ecx

; 18   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0BMPFile@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
  00026	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 19   : 	m_errorText="OK";

  0002f	68 00 00 00 00	 push	 OFFSET ??_C@_02GIPFHKNO@OK@
  00034	8b ce		 mov	 ecx, esi
  00036	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z

; 20   : }

  00043	8b c6		 mov	 eax, esi
  00045	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00048	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0004f	59		 pop	 ecx
  00050	5e		 pop	 esi
  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0BMPFile@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
  0000d	cc		 int	 3
__ehhandler$??0BMPFile@@QAE@XZ:
  0000e	90		 npad	 1
  0000f	90		 npad	 1
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0BMPFile@@QAE@XZ
  00026	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0BMPFile@@QAE@XZ ENDP					; BMPFile::BMPFile
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\BmpFile.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	c2 00 00	 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\BmpFile.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

  00000	c2 00 00	 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
