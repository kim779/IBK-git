; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30145.0 

	TITLE	D:\git\src\IBK\IBK_DRFN\#DRfn-CS\_Obj\ChartCommonAddIn\Jpegfile.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	___local_stdio_printf_options
PUBLIC	_sprintf
PUBLIC	?JpegFileToRGB@JpegFile@@SAPAEV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAI1@Z ; JpegFile::JpegFileToRGB
PUBLIC	?RGBToJpegFile@JpegFile@@SAHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAEIIHH@Z ; JpegFile::RGBToJpegFile
PUBLIC	?GetJPGDimensions@JpegFile@@SAHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAI1@Z ; JpegFile::GetJPGDimensions
PUBLIC	?MakeDwordAlignedBuf@JpegFile@@SAPAEPAEIIPAI@Z	; JpegFile::MakeDwordAlignedBuf
PUBLIC	?RGBFromDWORDAligned@JpegFile@@SAPAEPAEIII@Z	; JpegFile::RGBFromDWORDAligned
PUBLIC	?VertFlipBuf@JpegFile@@SAHPAEII@Z		; JpegFile::VertFlipBuf
PUBLIC	?MakeGrayScale@JpegFile@@SAHPAEII@Z		; JpegFile::MakeGrayScale
PUBLIC	?BGRFromRGB@JpegFile@@SAHPAEII@Z		; JpegFile::BGRFromRGB
PUBLIC	??0JpegFile@@QAE@XZ				; JpegFile::JpegFile
PUBLIC	??1JpegFile@@QAE@XZ				; JpegFile::~JpegFile
PUBLIC	?j_putRGBScanline@@YAXPAEH0H@Z			; j_putRGBScanline
PUBLIC	?j_putGrayScanlineToRGB@@YAXPAEH0H@Z		; j_putGrayScanlineToRGB
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_C@_02JDPG@rb@				; `string'
PUBLIC	??_C@_0BG@GDCAJJII@JPEG?5?3?6Can?8t?5open?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0BJ@OCPMFGIG@JpegFile?5?3?6Out?5of?5memory@ ; `string'
PUBLIC	??_C@_0N@OHBPFNDO@Memory?5error@		; `string'
PUBLIC	??_C@_02GMLFBBN@wb@				; `string'
PUBLIC	??_C@_0BK@MBGBNCJG@JpegFile?5?3?6Can?8t?5open?5?$CFs?6@ ; `string'
PUBLIC	__real@3fbd2f1a9fbe76c9
PUBLIC	__real@3fd322d0e5604189
PUBLIC	__real@3fe2c8b439581062
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	__imp__fclose:PROC
EXTRN	__imp__fopen:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	_longjmp:PROC
EXTRN	__imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ:PROC
EXTRN	?AfxMessageBox@@YGHPBDII@Z:PROC			; AfxMessageBox
EXTRN	_jpeg_std_error:PROC
EXTRN	_jpeg_CreateCompress:PROC
EXTRN	_jpeg_CreateDecompress:PROC
EXTRN	_jpeg_destroy_compress:PROC
EXTRN	_jpeg_destroy_decompress:PROC
EXTRN	_jpeg_stdio_dest:PROC
EXTRN	_jpeg_stdio_src:PROC
EXTRN	_jpeg_set_defaults:PROC
EXTRN	_jpeg_set_quality:PROC
EXTRN	_jpeg_start_compress:PROC
EXTRN	_jpeg_write_scanlines:PROC
EXTRN	_jpeg_finish_compress:PROC
EXTRN	_jpeg_read_header:PROC
EXTRN	_jpeg_start_decompress:PROC
EXTRN	_jpeg_read_scanlines:PROC
EXTRN	_jpeg_finish_decompress:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	___CxxLongjmpUnwind@4:PROC
EXTRN	__setjmp3:PROC
EXTRN	_memcpy:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT __real@3fe2c8b439581062
CONST	SEGMENT
__real@3fe2c8b439581062 DQ 03fe2c8b439581062r	; 0.587
CONST	ENDS
;	COMDAT __real@3fd322d0e5604189
CONST	SEGMENT
__real@3fd322d0e5604189 DQ 03fd322d0e5604189r	; 0.299
CONST	ENDS
;	COMDAT __real@3fbd2f1a9fbe76c9
CONST	SEGMENT
__real@3fbd2f1a9fbe76c9 DQ 03fbd2f1a9fbe76c9r	; 0.114
CONST	ENDS
;	COMDAT ??_C@_0BK@MBGBNCJG@JpegFile?5?3?6Can?8t?5open?5?$CFs?6@
CONST	SEGMENT
??_C@_0BK@MBGBNCJG@JpegFile?5?3?6Can?8t?5open?5?$CFs?6@ DB 'JpegFile :', 0aH
	DB	'Can''t open %s', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02GMLFBBN@wb@
CONST	SEGMENT
??_C@_02GMLFBBN@wb@ DB 'wb', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@OHBPFNDO@Memory?5error@
CONST	SEGMENT
??_C@_0N@OHBPFNDO@Memory?5error@ DB 'Memory error', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@OCPMFGIG@JpegFile?5?3?6Out?5of?5memory@
CONST	SEGMENT
??_C@_0BJ@OCPMFGIG@JpegFile?5?3?6Out?5of?5memory@ DB 'JpegFile :', 0aH, 'O'
	DB	'ut of memory', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@GDCAJJII@JPEG?5?3?6Can?8t?5open?5?$CFs?6@
CONST	SEGMENT
??_C@_0BG@GDCAJJII@JPEG?5?3?6Can?8t?5open?5?$CFs?6@ DB 'JPEG :', 0aH, 'Ca'
	DB	'n''t open %s', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02JDPG@rb@
CONST	SEGMENT
??_C@_02JDPG@rb@ DB 'rb', 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?GetJPGDimensions@JpegFile@@SAHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAI1@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetJPGDimensions@JpegFile@@SAHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAI1@Z$0
__ehfuncinfo$?GetJPGDimensions@JpegFile@@SAHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAI1@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetJPGDimensions@JpegFile@@SAHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAI1@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?RGBToJpegFile@JpegFile@@SAHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAEIIHH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?RGBToJpegFile@JpegFile@@SAHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAEIIHH@Z$0
__ehfuncinfo$?RGBToJpegFile@JpegFile@@SAHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAEIIHH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?RGBToJpegFile@JpegFile@@SAHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAEIIHH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?JpegFileToRGB@JpegFile@@SAPAEV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAI1@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?JpegFileToRGB@JpegFile@@SAPAEV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAI1@Z$0
__ehfuncinfo$?JpegFileToRGB@JpegFile@@SAPAEV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAI1@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?JpegFileToRGB@JpegFile@@SAPAEV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAI1@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\Jpegfile.cpp
;	COMDAT ?j_putGrayScanlineToRGB@@YAXPAEH0H@Z
_TEXT	SEGMENT
_jpegline$ = 8						; size = 4
_widthPix$ = 12						; size = 4
_outBuf$ = 16						; size = 4
_row$ = 20						; size = 4
?j_putGrayScanlineToRGB@@YAXPAEH0H@Z PROC		; j_putGrayScanlineToRGB, COMDAT

; 615  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 617  : 	int count;
; 618  : 	for (count=0;count<widthPix;count++) {

  00004	8b 75 0c	 mov	 esi, DWORD PTR _widthPix$[ebp]
  00007	33 d2		 xor	 edx, edx
  00009	85 f6		 test	 esi, esi
  0000b	7e 2a		 jle	 SHORT $LN3@j_putGrayS

; 616  : 	int offset = row * widthPix * 3;

  0000d	8b 45 10	 mov	 eax, DWORD PTR _outBuf$[ebp]
  00010	8b ce		 mov	 ecx, esi
  00012	0f af 4d 14	 imul	 ecx, DWORD PTR _row$[ebp]
  00016	57		 push	 edi
  00017	8b 7d 08	 mov	 edi, DWORD PTR _jpegline$[ebp]
  0001a	8d 04 48	 lea	 eax, DWORD PTR [eax+ecx*2]
  0001d	83 c0 02	 add	 eax, 2
  00020	03 c1		 add	 eax, ecx
$LL4@j_putGrayS:

; 619  : 
; 620  : 		BYTE iGray;
; 621  : 
; 622  : 		// get our grayscale value
; 623  : 		iGray = *(jpegline + count);

  00022	8a 0c 3a	 mov	 cl, BYTE PTR [edx+edi]
  00025	8d 40 03	 lea	 eax, DWORD PTR [eax+3]
  00028	42		 inc	 edx

; 624  : 
; 625  : 		*(outBuf + offset + count * 3 + 0) = iGray;

  00029	88 48 fb	 mov	 BYTE PTR [eax-5], cl

; 626  : 		*(outBuf + offset + count * 3 + 1) = iGray;

  0002c	88 48 fc	 mov	 BYTE PTR [eax-4], cl

; 627  : 		*(outBuf + offset + count * 3 + 2) = iGray;

  0002f	88 48 fd	 mov	 BYTE PTR [eax-3], cl
  00032	3b d6		 cmp	 edx, esi
  00034	7c ec		 jl	 SHORT $LL4@j_putGrayS
  00036	5f		 pop	 edi
$LN3@j_putGrayS:
  00037	5e		 pop	 esi

; 628  : 	}
; 629  : }

  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
?j_putGrayScanlineToRGB@@YAXPAEH0H@Z ENDP		; j_putGrayScanlineToRGB
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\Jpegfile.cpp
;	COMDAT ?j_putRGBScanline@@YAXPAEH0H@Z
_TEXT	SEGMENT
_jpegline$ = 8						; size = 4
_widthPix$ = 12						; size = 4
_outBuf$ = 16						; size = 4
_row$ = 20						; size = 4
?j_putRGBScanline@@YAXPAEH0H@Z PROC			; j_putRGBScanline, COMDAT

; 596  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 598  : 	int count;
; 599  : 	for (count=0;count<widthPix;count++) 

  00004	8b 75 0c	 mov	 esi, DWORD PTR _widthPix$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	7e 37		 jle	 SHORT $LN3@j_putRGBSc

; 597  : 	int offset = row * widthPix * 3;

  0000b	8b 45 10	 mov	 eax, DWORD PTR _outBuf$[ebp]
  0000e	8b ce		 mov	 ecx, esi
  00010	0f af 4d 14	 imul	 ecx, DWORD PTR _row$[ebp]
  00014	8b 55 08	 mov	 edx, DWORD PTR _jpegline$[ebp]
  00017	83 c2 02	 add	 edx, 2
  0001a	8d 04 48	 lea	 eax, DWORD PTR [eax+ecx*2]
  0001d	83 c0 02	 add	 eax, 2
  00020	03 c1		 add	 eax, ecx
$LL4@j_putRGBSc:

; 600  : 	{
; 601  : 		*(outBuf + offset + count * 3 + 0) = *(jpegline + count * 3 + 0);

  00022	0f b6 4a fe	 movzx	 ecx, BYTE PTR [edx-2]
  00026	8d 52 03	 lea	 edx, DWORD PTR [edx+3]
  00029	88 48 fe	 mov	 BYTE PTR [eax-2], cl
  0002c	8d 40 03	 lea	 eax, DWORD PTR [eax+3]

; 602  : 		*(outBuf + offset + count * 3 + 1) = *(jpegline + count * 3 + 1);

  0002f	0f b6 4a fc	 movzx	 ecx, BYTE PTR [edx-4]
  00033	88 48 fc	 mov	 BYTE PTR [eax-4], cl

; 603  : 		*(outBuf + offset + count * 3 + 2) = *(jpegline + count * 3 + 2);

  00036	0f b6 4a fd	 movzx	 ecx, BYTE PTR [edx-3]
  0003a	88 48 fd	 mov	 BYTE PTR [eax-3], cl
  0003d	83 ee 01	 sub	 esi, 1
  00040	75 e0		 jne	 SHORT $LL4@j_putRGBSc
$LN3@j_putRGBSc:
  00042	5e		 pop	 esi

; 604  : 	}
; 605  : }

  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
?j_putRGBScanline@@YAXPAEH0H@Z ENDP			; j_putRGBScanline
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\Jpegfile.cpp
;	COMDAT ?my_error_exit@@YAXPAUjpeg_common_struct@@@Z
_TEXT	SEGMENT
_buffer$ = -204						; size = 200
__$ArrayPad$ = -4					; size = 4
_cinfo$ = 8						; size = 4
?my_error_exit@@YAXPAUjpeg_common_struct@@@Z PROC	; my_error_exit, COMDAT

; 63   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 08	 mov	 eax, DWORD PTR _cinfo$[ebp]

; 64   : 	/* cinfo->err really points to a my_error_mgr struct, so coerce pointer */
; 65   : 	my_error_ptr myerr = (my_error_ptr) cinfo->err;
; 66   : 
; 67   : 	char buffer[JMSG_LENGTH_MAX];
; 68   : 
; 69   : 	/* Create the message */
; 70   : 	(*cinfo->err->format_message) (cinfo, buffer);

  00016	8d 8d 34 ff ff
	ff		 lea	 ecx, DWORD PTR _buffer$[ebp]
  0001c	56		 push	 esi
  0001d	51		 push	 ecx
  0001e	50		 push	 eax
  0001f	8b 30		 mov	 esi, DWORD PTR [eax]
  00021	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00024	ff d0		 call	 eax
  00026	83 c4 08	 add	 esp, 8

; 71   : 
; 72   : 	/* Always display the message. */
; 73   : 	//MessageBox(NULL,buffer,"JPEG Fatal Error",MB_ICONSTOP);
; 74   : 
; 75   : 
; 76   : 	/* Return control to the setjmp point */
; 77   : 	longjmp(myerr->setjmp_buffer, 1);

  00029	8d 86 84 00 00
	00		 lea	 eax, DWORD PTR [esi+132]
  0002f	6a 01		 push	 1
  00031	50		 push	 eax
  00032	e8 00 00 00 00	 call	 _longjmp
$LN3@my_error_e:
  00037	cc		 int	 3
?my_error_exit@@YAXPAUjpeg_common_struct@@@Z ENDP	; my_error_exit
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\Jpegfile.cpp
;	COMDAT ??1JpegFile@@QAE@XZ
_TEXT	SEGMENT
??1JpegFile@@QAE@XZ PROC				; JpegFile::~JpegFile, COMDAT
; _this$ = ecx

; 106  : }

  00000	c2 00 00	 ret	 0
??1JpegFile@@QAE@XZ ENDP				; JpegFile::~JpegFile
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\Jpegfile.cpp
;	COMDAT ??0JpegFile@@QAE@XZ
_TEXT	SEGMENT
??0JpegFile@@QAE@XZ PROC				; JpegFile::JpegFile, COMDAT
; _this$ = ecx

; 98   : }

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0JpegFile@@QAE@XZ ENDP				; JpegFile::JpegFile
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\Jpegfile.cpp
;	COMDAT ?BGRFromRGB@JpegFile@@SAHPAEII@Z
_TEXT	SEGMENT
tv322 = 8						; size = 4
_buf$ = 8						; size = 4
_widthPix$ = 12						; size = 4
_height$ = 16						; size = 4
?BGRFromRGB@JpegFile@@SAHPAEII@Z PROC			; JpegFile::BGRFromRGB, COMDAT

; 745  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 746  : 	if (buf==NULL)

  00004	8b 7d 08	 mov	 edi, DWORD PTR _buf$[ebp]
  00007	85 ff		 test	 edi, edi
  00009	75 05		 jne	 SHORT $LN8@BGRFromRGB

; 747  : 		return FALSE;

  0000b	33 c0		 xor	 eax, eax
  0000d	5f		 pop	 edi

; 765  : }

  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
$LN8@BGRFromRGB:
  00010	53		 push	 ebx

; 748  : 
; 749  : 	UINT col, row;
; 750  : 	for (row=0;row<height;row++) {

  00011	8b 5d 10	 mov	 ebx, DWORD PTR _height$[ebp]
  00014	85 db		 test	 ebx, ebx
  00016	74 3a		 je	 SHORT $LN3@BGRFromRGB
  00018	8b 4d 0c	 mov	 ecx, DWORD PTR _widthPix$[ebp]
  0001b	56		 push	 esi
  0001c	8d 04 49	 lea	 eax, DWORD PTR [ecx+ecx*2]
  0001f	89 45 08	 mov	 DWORD PTR tv322[ebp], eax
$LL4@BGRFromRGB:

; 751  : 		for (col=0;col<widthPix;col++) {

  00022	85 c9		 test	 ecx, ecx
  00024	74 24		 je	 SHORT $LN2@BGRFromRGB
  00026	8b c7		 mov	 eax, edi
  00028	8b f1		 mov	 esi, ecx
  0002a	66 0f 1f 44 00
	00		 npad	 6
$LL7@BGRFromRGB:

; 752  : 			LPBYTE pRed, pGrn, pBlu;
; 753  : 			pRed = buf + row * widthPix * 3 + col * 3;
; 754  : 			pGrn = buf + row * widthPix * 3 + col * 3 + 1;
; 755  : 			pBlu = buf + row * widthPix * 3 + col * 3 + 2;
; 756  : 
; 757  : 			// swap red and blue
; 758  : 			BYTE tmp;
; 759  : 			tmp = *pRed;
; 760  : 			*pRed = *pBlu;

  00030	8a 48 02	 mov	 cl, BYTE PTR [eax+2]
  00033	8d 40 03	 lea	 eax, DWORD PTR [eax+3]
  00036	8a 50 fd	 mov	 dl, BYTE PTR [eax-3]
  00039	88 48 fd	 mov	 BYTE PTR [eax-3], cl

; 761  : 			*pBlu = tmp;

  0003c	88 50 ff	 mov	 BYTE PTR [eax-1], dl
  0003f	83 ee 01	 sub	 esi, 1
  00042	75 ec		 jne	 SHORT $LL7@BGRFromRGB
  00044	8b 4d 0c	 mov	 ecx, DWORD PTR _widthPix$[ebp]
  00047	8b 45 08	 mov	 eax, DWORD PTR tv322[ebp]
$LN2@BGRFromRGB:

; 748  : 
; 749  : 	UINT col, row;
; 750  : 	for (row=0;row<height;row++) {

  0004a	03 f8		 add	 edi, eax
  0004c	83 eb 01	 sub	 ebx, 1
  0004f	75 d1		 jne	 SHORT $LL4@BGRFromRGB
  00051	5e		 pop	 esi
$LN3@BGRFromRGB:

; 762  : 		}
; 763  : 	}
; 764  : 	return TRUE;

  00052	5b		 pop	 ebx
  00053	b8 01 00 00 00	 mov	 eax, 1
  00058	5f		 pop	 edi

; 765  : }

  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
?BGRFromRGB@JpegFile@@SAHPAEII@Z ENDP			; JpegFile::BGRFromRGB
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\Jpegfile.cpp
;	COMDAT ?MakeGrayScale@JpegFile@@SAHPAEII@Z
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_widthPix$ = 12						; size = 4
_height$ = 16						; size = 4
?MakeGrayScale@JpegFile@@SAHPAEII@Z PROC		; JpegFile::MakeGrayScale, COMDAT

; 773  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 774  : 	if (buf==NULL)

  00004	8b 75 08	 mov	 esi, DWORD PTR _buf$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	75 05		 jne	 SHORT $LN8@MakeGraySc

; 775  : 		return FALSE;

  0000b	33 c0		 xor	 eax, eax
  0000d	5e		 pop	 esi

; 794  : }

  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
$LN8@MakeGraySc:
  00010	57		 push	 edi

; 776  : 
; 777  : 	UINT row,col;
; 778  : 	for (row=0;row<height;row++) {

  00011	8b 7d 10	 mov	 edi, DWORD PTR _height$[ebp]
  00014	85 ff		 test	 edi, edi
  00016	0f 84 8a 00 00
	00		 je	 $LN3@MakeGraySc
  0001c	f2 0f 10 15 00
	00 00 00	 movsd	 xmm2, QWORD PTR __real@3fe2c8b439581062
  00024	83 c6 02	 add	 esi, 2
  00027	f2 0f 10 1d 00
	00 00 00	 movsd	 xmm3, QWORD PTR __real@3fd322d0e5604189
  0002f	f2 0f 10 25 00
	00 00 00	 movsd	 xmm4, QWORD PTR __real@3fbd2f1a9fbe76c9
  00037	53		 push	 ebx
  00038	8b 5d 0c	 mov	 ebx, DWORD PTR _widthPix$[ebp]
  0003b	8d 04 5b	 lea	 eax, DWORD PTR [ebx+ebx*2]
  0003e	66 90		 npad	 2
$LL4@MakeGraySc:

; 779  : 		for (col=0;col<widthPix;col++) {

  00040	85 db		 test	 ebx, ebx
  00042	74 5a		 je	 SHORT $LN2@MakeGraySc
  00044	8b ce		 mov	 ecx, esi
  00046	8b d3		 mov	 edx, ebx
  00048	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL7@MakeGraySc:

; 780  : 			LPBYTE pRed, pGrn, pBlu;
; 781  : 			pRed = buf + row * widthPix * 3 + col * 3;
; 782  : 			pGrn = buf + row * widthPix * 3 + col * 3 + 1;
; 783  : 			pBlu = buf + row * widthPix * 3 + col * 3 + 2;
; 784  : 
; 785  : 			// luminance
; 786  : 			int lum = (int)(.299 * (double)(*pRed) + .587 * (double)(*pGrn) + .114 * (double)(*pBlu));

  00050	0f b6 41 ff	 movzx	 eax, BYTE PTR [ecx-1]
  00054	66 0f 6e c8	 movd	 xmm1, eax
  00058	0f b6 41 fe	 movzx	 eax, BYTE PTR [ecx-2]
  0005c	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1
  00060	66 0f 6e c0	 movd	 xmm0, eax
  00064	0f b6 01	 movzx	 eax, BYTE PTR [ecx]
  00067	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  0006b	f2 0f 59 ca	 mulsd	 xmm1, xmm2
  0006f	f2 0f 59 c3	 mulsd	 xmm0, xmm3
  00073	f2 0f 58 c8	 addsd	 xmm1, xmm0
  00077	66 0f 6e c0	 movd	 xmm0, eax
  0007b	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  0007f	f2 0f 59 c4	 mulsd	 xmm0, xmm4
  00083	f2 0f 58 c8	 addsd	 xmm1, xmm0
  00087	f2 0f 2c c1	 cvttsd2si eax, xmm1

; 787  : 
; 788  : 			*pRed = (BYTE)lum;

  0008b	88 41 fe	 mov	 BYTE PTR [ecx-2], al

; 789  : 			*pGrn = (BYTE)lum;

  0008e	88 41 ff	 mov	 BYTE PTR [ecx-1], al

; 790  : 			*pBlu = (BYTE)lum;

  00091	88 01		 mov	 BYTE PTR [ecx], al
  00093	83 c1 03	 add	 ecx, 3
  00096	83 ea 01	 sub	 edx, 1
  00099	75 b5		 jne	 SHORT $LL7@MakeGraySc
  0009b	8d 04 5b	 lea	 eax, DWORD PTR [ebx+ebx*2]
$LN2@MakeGraySc:

; 776  : 
; 777  : 	UINT row,col;
; 778  : 	for (row=0;row<height;row++) {

  0009e	03 f0		 add	 esi, eax
  000a0	83 ef 01	 sub	 edi, 1
  000a3	75 9b		 jne	 SHORT $LL4@MakeGraySc
  000a5	5b		 pop	 ebx
$LN3@MakeGraySc:

; 791  : 		}
; 792  : 	}
; 793  : 	return TRUE;

  000a6	5f		 pop	 edi
  000a7	b8 01 00 00 00	 mov	 eax, 1
  000ac	5e		 pop	 esi

; 794  : }

  000ad	5d		 pop	 ebp
  000ae	c3		 ret	 0
?MakeGrayScale@JpegFile@@SAHPAEII@Z ENDP		; JpegFile::MakeGrayScale
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\Jpegfile.cpp
;	COMDAT ?VertFlipBuf@JpegFile@@SAHPAEII@Z
_TEXT	SEGMENT
tv333 = -8						; size = 4
_tb2$1$ = -4						; size = 4
_tb1$1$ = 8						; size = 4
_inbuf$ = 8						; size = 4
_widthBytes$ = 12					; size = 4
_height$ = 16						; size = 4
?VertFlipBuf@JpegFile@@SAHPAEII@Z PROC			; JpegFile::VertFlipBuf, COMDAT

; 693  : {   

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b 75 0c	 mov	 esi, DWORD PTR _widthBytes$[ebp]
  0000b	57		 push	 edi

; 694  : 	BYTE  *tb1;
; 695  : 	BYTE  *tb2;
; 696  : 
; 697  : 	if (inbuf==NULL)

  0000c	8b 7d 08	 mov	 edi, DWORD PTR _inbuf$[ebp]
  0000f	85 ff		 test	 edi, edi
  00011	74 2b		 je	 SHORT $LN13@VertFlipBu

; 698  : 		return FALSE;
; 699  : 
; 700  : 	UINT bufsize;
; 701  : 
; 702  : 	bufsize=widthBytes;
; 703  : 
; 704  : 	tb1= (BYTE *)new BYTE[bufsize];

  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00019	8b d8		 mov	 ebx, eax
  0001b	83 c4 04	 add	 esp, 4
  0001e	89 5d 08	 mov	 DWORD PTR _tb1$1$[ebp], ebx

; 705  : 	if (tb1==NULL) {

  00021	85 db		 test	 ebx, ebx
  00023	74 19		 je	 SHORT $LN13@VertFlipBu

; 706  : 		return FALSE;
; 707  : 	}
; 708  : 
; 709  : 	tb2= (BYTE *)new BYTE [bufsize];

  00025	56		 push	 esi
  00026	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  0002b	83 c4 04	 add	 esp, 4
  0002e	89 45 fc	 mov	 DWORD PTR _tb2$1$[ebp], eax

; 710  : 	if (tb2==NULL) {

  00031	85 c0		 test	 eax, eax
  00033	75 12		 jne	 SHORT $LN7@VertFlipBu

; 711  : 		delete [] tb1;

  00035	53		 push	 ebx
  00036	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0003b	83 c4 04	 add	 esp, 4
$LN13@VertFlipBu:

; 733  : }        

  0003e	5f		 pop	 edi
  0003f	5e		 pop	 esi
  00040	33 c0		 xor	 eax, eax
  00042	5b		 pop	 ebx
  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
$LN7@VertFlipBu:

; 712  : 		return FALSE;
; 713  : 	}
; 714  : 	
; 715  : 	UINT row_cnt;     
; 716  : 	ULONG off1=0;
; 717  : 	ULONG off2=0;
; 718  : 
; 719  : 	for (row_cnt=0;row_cnt<(height+1)/2;row_cnt++) {

  00047	8b 4d 10	 mov	 ecx, DWORD PTR _height$[ebp]
  0004a	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  0004d	d1 e8		 shr	 eax, 1
  0004f	89 45 f8	 mov	 DWORD PTR tv333[ebp], eax
  00052	74 44		 je	 SHORT $LN3@VertFlipBu
  00054	8d 59 ff	 lea	 ebx, DWORD PTR [ecx-1]
  00057	0f af de	 imul	 ebx, esi
  0005a	03 df		 add	 ebx, edi
  0005c	0f 1f 40 00	 npad	 4
$LL4@VertFlipBu:

; 720  : 		off1=row_cnt*bufsize;
; 721  : 		off2=((height-1)-row_cnt)*bufsize;   
; 722  : 		
; 723  : 		memcpy(tb1,inbuf+off1,bufsize);

  00060	56		 push	 esi
  00061	57		 push	 edi
  00062	ff 75 08	 push	 DWORD PTR _tb1$1$[ebp]
  00065	e8 00 00 00 00	 call	 _memcpy

; 724  : 		memcpy(tb2,inbuf+off2,bufsize);	

  0006a	56		 push	 esi
  0006b	53		 push	 ebx
  0006c	ff 75 fc	 push	 DWORD PTR _tb2$1$[ebp]
  0006f	e8 00 00 00 00	 call	 _memcpy

; 725  : 		memcpy(inbuf+off1,tb2,bufsize);

  00074	56		 push	 esi
  00075	ff 75 fc	 push	 DWORD PTR _tb2$1$[ebp]
  00078	57		 push	 edi
  00079	e8 00 00 00 00	 call	 _memcpy

; 726  : 		memcpy(inbuf+off2,tb1,bufsize);

  0007e	56		 push	 esi
  0007f	ff 75 08	 push	 DWORD PTR _tb1$1$[ebp]
  00082	53		 push	 ebx
  00083	e8 00 00 00 00	 call	 _memcpy
  00088	83 c4 30	 add	 esp, 48			; 00000030H
  0008b	03 fe		 add	 edi, esi
  0008d	2b de		 sub	 ebx, esi
  0008f	83 6d f8 01	 sub	 DWORD PTR tv333[ebp], 1
  00093	75 cb		 jne	 SHORT $LL4@VertFlipBu
  00095	8b 5d 08	 mov	 ebx, DWORD PTR _tb1$1$[ebp]
$LN3@VertFlipBu:

; 727  : 	}	
; 728  : 
; 729  : 	delete [] tb1;

  00098	53		 push	 ebx
  00099	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]

; 730  : 	delete [] tb2;

  0009e	ff 75 fc	 push	 DWORD PTR _tb2$1$[ebp]
  000a1	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  000a6	83 c4 08	 add	 esp, 8

; 731  : 
; 732  : 	return TRUE;

  000a9	b8 01 00 00 00	 mov	 eax, 1
  000ae	5f		 pop	 edi

; 733  : }        

  000af	5e		 pop	 esi
  000b0	5b		 pop	 ebx
  000b1	8b e5		 mov	 esp, ebp
  000b3	5d		 pop	 ebp
  000b4	c3		 ret	 0
?VertFlipBuf@JpegFile@@SAHPAEII@Z ENDP			; JpegFile::VertFlipBuf
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\Jpegfile.cpp
;	COMDAT ?RGBFromDWORDAligned@JpegFile@@SAPAEPAEIII@Z
_TEXT	SEGMENT
_tmp$1$ = 8						; size = 4
_inBuf$ = 8						; size = 4
_widthPix$ = 12						; size = 4
_widthBytes$ = 16					; size = 4
_height$ = 20						; size = 4
?RGBFromDWORDAligned@JpegFile@@SAPAEPAEIII@Z PROC	; JpegFile::RGBFromDWORDAligned, COMDAT

; 400  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 401  : 	if (inBuf==NULL)

  00005	8b 75 08	 mov	 esi, DWORD PTR _inBuf$[ebp]
  00008	57		 push	 edi
  00009	85 f6		 test	 esi, esi
  0000b	74 4e		 je	 SHORT $LN12@RGBFromDWO

; 402  : 		return NULL;
; 403  : 
; 404  : 
; 405  : 	BYTE *tmp;
; 406  : 	tmp=(BYTE *)new BYTE[height * widthPix * 3];

  0000d	8b 7d 0c	 mov	 edi, DWORD PTR _widthPix$[ebp]
  00010	8b c7		 mov	 eax, edi
  00012	8b 5d 14	 mov	 ebx, DWORD PTR _height$[ebp]
  00015	0f af c3	 imul	 eax, ebx
  00018	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00021	8b c8		 mov	 ecx, eax
  00023	83 c4 04	 add	 esp, 4
  00026	89 4d 08	 mov	 DWORD PTR _tmp$1$[ebp], ecx

; 407  : 	if (tmp==NULL)

  00029	85 c9		 test	 ecx, ecx
  0002b	74 2e		 je	 SHORT $LN12@RGBFromDWO

; 408  : 		return NULL;
; 409  : 
; 410  : 	UINT row;
; 411  : 
; 412  : 	for (row=0;row<height;row++) {

  0002d	85 db		 test	 ebx, ebx
  0002f	74 23		 je	 SHORT $LN3@RGBFromDWO
  00031	8d 04 7f	 lea	 eax, DWORD PTR [edi+edi*2]
  00034	8b f9		 mov	 edi, ecx
$LL4@RGBFromDWO:

; 413  : 		memcpy((tmp+row * widthPix * 3), 

  00036	50		 push	 eax
  00037	56		 push	 esi
  00038	57		 push	 edi
  00039	e8 00 00 00 00	 call	 _memcpy
  0003e	8b 4d 0c	 mov	 ecx, DWORD PTR _widthPix$[ebp]
  00041	83 c4 0c	 add	 esp, 12			; 0000000cH
  00044	03 75 10	 add	 esi, DWORD PTR _widthBytes$[ebp]
  00047	8d 04 49	 lea	 eax, DWORD PTR [ecx+ecx*2]
  0004a	03 f8		 add	 edi, eax
  0004c	83 eb 01	 sub	 ebx, 1
  0004f	75 e5		 jne	 SHORT $LL4@RGBFromDWO
  00051	8b 4d 08	 mov	 ecx, DWORD PTR _tmp$1$[ebp]
$LN3@RGBFromDWO:
  00054	5f		 pop	 edi

; 414  : 				(inBuf + row * widthBytes), 
; 415  : 				widthPix * 3);
; 416  : 	}
; 417  : 
; 418  : 	return tmp;
; 419  : }

  00055	5e		 pop	 esi
  00056	8b c1		 mov	 eax, ecx
  00058	5b		 pop	 ebx
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
$LN12@RGBFromDWO:
  0005b	5f		 pop	 edi
  0005c	5e		 pop	 esi
  0005d	33 c0		 xor	 eax, eax
  0005f	5b		 pop	 ebx
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
?RGBFromDWORDAligned@JpegFile@@SAPAEPAEIII@Z ENDP	; JpegFile::RGBFromDWORDAligned
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\Jpegfile.cpp
;	COMDAT ?MakeDwordAlignedBuf@JpegFile@@SAPAEPAEIIPAI@Z
_TEXT	SEGMENT
_pNew$1$ = -4						; size = 4
_uiWidthBytes$1$ = 8					; size = 4
_dataBuf$ = 8						; size = 4
_widthPix$ = 12						; size = 4
_height$ = 16						; size = 4
_uiOutWidthBytes$ = 20					; size = 4
?MakeDwordAlignedBuf@JpegFile@@SAPAEPAEIIPAI@Z PROC	; JpegFile::MakeDwordAlignedBuf, COMDAT

; 640  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi

; 641  : 	////////////////////////////////////////////////////////////
; 642  : 	// what's going on here? this certainly means trouble 
; 643  : 	if (dataBuf==NULL)

  00006	8b 75 08	 mov	 esi, DWORD PTR _dataBuf$[ebp]
  00009	57		 push	 edi
  0000a	85 f6		 test	 esi, esi
  0000c	74 75		 je	 SHORT $LN12@MakeDwordA

; 644  : 		return NULL;
; 645  : 
; 646  : 	////////////////////////////////////////////////////////////
; 647  : 	// how big is the smallest DWORD-aligned buffer that we can use?
; 648  : 	UINT uiWidthBytes;
; 649  : 	uiWidthBytes = WIDTHBYTES(widthPix * 24);

  0000e	8b 7d 0c	 mov	 edi, DWORD PTR _widthPix$[ebp]

; 650  : 
; 651  : 	DWORD dwNewsize=(DWORD)((DWORD)uiWidthBytes * 

  00011	8b 5d 10	 mov	 ebx, DWORD PTR _height$[ebp]
  00014	8d 04 7f	 lea	 eax, DWORD PTR [edi+edi*2]
  00017	8d 04 c5 1f 00
	00 00		 lea	 eax, DWORD PTR [eax*8+31]
  0001e	c1 e8 05	 shr	 eax, 5
  00021	c1 e0 02	 shl	 eax, 2
  00024	89 45 08	 mov	 DWORD PTR _uiWidthBytes$1$[ebp], eax
  00027	0f af c3	 imul	 eax, ebx

; 652  : 							(DWORD)height);
; 653  : 	BYTE *pNew;
; 654  : 
; 655  : 	////////////////////////////////////////////////////////////
; 656  : 	// alloc and open our new buffer
; 657  : 	pNew=(BYTE *)new BYTE[dwNewsize];

  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00030	8b c8		 mov	 ecx, eax
  00032	83 c4 04	 add	 esp, 4
  00035	89 4d fc	 mov	 DWORD PTR _pNew$1$[ebp], ecx

; 658  : 	if (pNew==NULL) {

  00038	85 c9		 test	 ecx, ecx
  0003a	74 47		 je	 SHORT $LN12@MakeDwordA

; 659  : 		return NULL;
; 660  : 	}
; 661  : 	
; 662  : 	////////////////////////////////////////////////////////////
; 663  : 	// copy row-by-row
; 664  : 	UINT uiInWidthBytes = widthPix * 3;

  0003c	8d 04 7f	 lea	 eax, DWORD PTR [edi+edi*2]

; 665  : 	UINT uiCount;
; 666  : 	for (uiCount=0;uiCount < height;uiCount++) {

  0003f	85 db		 test	 ebx, ebx
  00041	74 2e		 je	 SHORT $LN13@MakeDwordA

; 659  : 		return NULL;
; 660  : 	}
; 661  : 	
; 662  : 	////////////////////////////////////////////////////////////
; 663  : 	// copy row-by-row
; 664  : 	UINT uiInWidthBytes = widthPix * 3;

  00043	8b f9		 mov	 edi, ecx
$LL4@MakeDwordA:

; 667  : 		BYTE * bpInAdd;
; 668  : 		BYTE * bpOutAdd;
; 669  : 		ULONG lInOff;
; 670  : 		ULONG lOutOff;
; 671  : 
; 672  : 		lInOff=uiInWidthBytes * uiCount;
; 673  : 		lOutOff=uiWidthBytes * uiCount;
; 674  : 
; 675  : 		bpInAdd= dataBuf + lInOff;
; 676  : 		bpOutAdd= pNew + lOutOff;
; 677  : 
; 678  : 		memcpy(bpOutAdd,bpInAdd,uiInWidthBytes);

  00045	50		 push	 eax
  00046	56		 push	 esi
  00047	57		 push	 edi
  00048	e8 00 00 00 00	 call	 _memcpy
  0004d	8b 4d 0c	 mov	 ecx, DWORD PTR _widthPix$[ebp]
  00050	83 c4 0c	 add	 esp, 12			; 0000000cH
  00053	8d 04 49	 lea	 eax, DWORD PTR [ecx+ecx*2]
  00056	8b 4d 08	 mov	 ecx, DWORD PTR _uiWidthBytes$1$[ebp]
  00059	03 f0		 add	 esi, eax
  0005b	03 f9		 add	 edi, ecx
  0005d	83 eb 01	 sub	 ebx, 1
  00060	75 e3		 jne	 SHORT $LL4@MakeDwordA

; 679  : 	}
; 680  : 
; 681  : 	*uiOutWidthBytes=uiWidthBytes;

  00062	8b 45 14	 mov	 eax, DWORD PTR _uiOutWidthBytes$[ebp]
  00065	5f		 pop	 edi

; 682  : 	return pNew;
; 683  : }

  00066	5e		 pop	 esi
  00067	5b		 pop	 ebx
  00068	89 08		 mov	 DWORD PTR [eax], ecx
  0006a	8b 45 fc	 mov	 eax, DWORD PTR _pNew$1$[ebp]
  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c3		 ret	 0
$LN13@MakeDwordA:

; 679  : 	}
; 680  : 
; 681  : 	*uiOutWidthBytes=uiWidthBytes;

  00071	8b 45 14	 mov	 eax, DWORD PTR _uiOutWidthBytes$[ebp]
  00074	8b 4d 08	 mov	 ecx, DWORD PTR _uiWidthBytes$1$[ebp]
  00077	5f		 pop	 edi

; 682  : 	return pNew;
; 683  : }

  00078	5e		 pop	 esi
  00079	89 08		 mov	 DWORD PTR [eax], ecx
  0007b	8b 45 fc	 mov	 eax, DWORD PTR _pNew$1$[ebp]
  0007e	5b		 pop	 ebx
  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c3		 ret	 0
$LN12@MakeDwordA:
  00083	5f		 pop	 edi
  00084	5e		 pop	 esi
  00085	33 c0		 xor	 eax, eax
  00087	5b		 pop	 ebx
  00088	8b e5		 mov	 esp, ebp
  0008a	5d		 pop	 ebp
  0008b	c3		 ret	 0
?MakeDwordAlignedBuf@JpegFile@@SAPAEPAEIIPAI@Z ENDP	; JpegFile::MakeDwordAlignedBuf
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\Jpegfile.cpp
;	COMDAT ?GetJPGDimensions@JpegFile@@SAHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAI1@Z
_TEXT	SEGMENT
_height$GSCopy$ = -900					; size = 4
_width$GSCopy$ = -896					; size = 4
_infile$ = -892						; size = 4
_jerr$ = -888						; size = 196
_cinfo$ = -692						; size = 424
_buf$ = -268						; size = 250
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_fileName$ = 8						; size = 4
_width$ = 12						; size = 4
_height$ = 16						; size = 4
?GetJPGDimensions@JpegFile@@SAHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAI1@Z PROC ; JpegFile::GetJPGDimensions, COMDAT

; 304  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?GetJPGDimensions@JpegFile@@SAHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAI1@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 78 03 00
	00		 sub	 esp, 888		; 00000378H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	56		 push	 esi
  00022	50		 push	 eax
  00023	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00026	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002c	8b 45 0c	 mov	 eax, DWORD PTR _width$[ebp]
  0002f	89 85 80 fc ff
	ff		 mov	 DWORD PTR _width$GSCopy$[ebp], eax
  00035	8b 45 10	 mov	 eax, DWORD PTR _height$[ebp]
  00038	89 85 7c fc ff
	ff		 mov	 DWORD PTR _height$GSCopy$[ebp], eax

; 305  : 	// basic code from IJG Jpeg Code v6 example.c
; 306  : 
; 307  : 	/* This struct contains the JPEG decompression parameters and pointers to
; 308  : 	* working space (which is allocated as needed by the JPEG library).
; 309  : 	*/
; 310  : 	struct jpeg_decompress_struct cinfo;
; 311  : 	/* We use our private extension JPEG error handler.
; 312  : 	* Note that this struct must live as long as the main JPEG parameter
; 313  : 	* struct, to avoid dangling-pointer problems.
; 314  : 	*/
; 315  : 	struct my_error_mgr jerr;
; 316  : 	/* More stuff */
; 317  : 	FILE * infile=NULL;		/* source file */
; 318  : 	char buf[250];
; 319  : 
; 320  : 	/* In this example we want to open the input file before doing anything else,
; 321  : 	* so that the setjmp() error recovery below can assume the file is open.
; 322  : 	* VERY IMPORTANT: use "b" option to fopen() if you are on a machine that
; 323  : 	* requires it in order to read binary files.
; 324  : 	*/
; 325  : 
; 326  : 	if ((infile = fopen(fileName, "rb")) == NULL) {

  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_02JDPG@rb@
  00043	ff 75 08	 push	 DWORD PTR _fileName$[ebp]
  00046	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0004d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  00053	83 c4 08	 add	 esp, 8
  00056	89 85 84 fc ff
	ff		 mov	 DWORD PTR _infile$[ebp], eax
  0005c	85 c0		 test	 eax, eax
  0005e	75 2e		 jne	 SHORT $LN2@GetJPGDime

; 327  : 		sprintf(buf, "JPEG :\nCan't open %s\n", fileName);

  00060	ff 75 08	 push	 DWORD PTR _fileName$[ebp]
  00063	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR _buf$[ebp]
  00069	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@GDCAJJII@JPEG?5?3?6Can?8t?5open?5?$CFs?6@
  0006e	50		 push	 eax
  0006f	e8 00 00 00 00	 call	 _sprintf
  00074	83 c4 0c	 add	 esp, 12			; 0000000cH

; 328  : 		AfxMessageBox(buf);

  00077	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR _buf$[ebp]
  0007d	6a 00		 push	 0
  0007f	6a 00		 push	 0
  00081	50		 push	 eax
  00082	e8 00 00 00 00	 call	 ?AfxMessageBox@@YGHPBDII@Z ; AfxMessageBox
  00087	33 f6		 xor	 esi, esi
  00089	e9 cb 00 00 00	 jmp	 $LN8@GetJPGDime
$LN2@GetJPGDime:

; 329  : 		return FALSE;
; 330  : 	}
; 331  : 
; 332  : 	/* Step 1: allocate and initialize JPEG decompression object */
; 333  : 
; 334  : 	/* We set up the normal JPEG error routines, then override error_exit. */
; 335  : 	cinfo.err = jpeg_std_error(&jerr.pub);

  0008e	8d 85 88 fc ff
	ff		 lea	 eax, DWORD PTR _jerr$[ebp]
  00094	50		 push	 eax
  00095	e8 00 00 00 00	 call	 _jpeg_std_error

; 336  : 	jerr.pub.error_exit = my_error_exit;
; 337  : 
; 338  : 
; 339  : 	/* Establish the setjmp return context for my_error_exit to use. */
; 340  : 	if (setjmp(jerr.setjmp_buffer)) {

  0009a	68 00 00 00 00	 push	 OFFSET __ehfuncinfo$?GetJPGDimensions@JpegFile@@SAHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAI1@Z
  0009f	89 85 4c fd ff
	ff		 mov	 DWORD PTR _cinfo$[ebp], eax
  000a5	8d 8d 0c fd ff
	ff		 lea	 ecx, DWORD PTR _jerr$[ebp+132]
  000ab	8b 45 fc	 mov	 eax, DWORD PTR __$EHRec$[ebp+8]
  000ae	50		 push	 eax
  000af	68 00 00 00 00	 push	 OFFSET ___CxxLongjmpUnwind@4
  000b4	6a 03		 push	 3
  000b6	51		 push	 ecx
  000b7	c7 85 88 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _jerr$[ebp], OFFSET ?my_error_exit@@YAXPAUjpeg_common_struct@@@Z ; my_error_exit
  000c1	e8 00 00 00 00	 call	 __setjmp3
  000c6	83 c4 18	 add	 esp, 24			; 00000018H
  000c9	85 c0		 test	 eax, eax
  000cb	8d 85 4c fd ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  000d1	74 21		 je	 SHORT $LN3@GetJPGDime

; 341  : 		/* If we get here, the JPEG code has signaled an error.
; 342  : 		 * We need to clean up the JPEG object, close the input file, and return.
; 343  : 		 */
; 344  : 
; 345  : 		jpeg_destroy_decompress(&cinfo);

  000d3	50		 push	 eax
  000d4	e8 00 00 00 00	 call	 _jpeg_destroy_decompress

; 346  : 
; 347  : 		if (infile!=NULL)

  000d9	8b 85 84 fc ff
	ff		 mov	 eax, DWORD PTR _infile$[ebp]
  000df	83 c4 04	 add	 esp, 4
  000e2	85 c0		 test	 eax, eax
  000e4	74 0a		 je	 SHORT $LN4@GetJPGDime

; 348  : 			fclose(infile);

  000e6	50		 push	 eax
  000e7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  000ed	83 c4 04	 add	 esp, 4
$LN4@GetJPGDime:
  000f0	33 f6		 xor	 esi, esi
  000f2	eb 65		 jmp	 SHORT $LN8@GetJPGDime
$LN3@GetJPGDime:

; 349  : 		return FALSE;
; 350  : 	}
; 351  : 
; 352  : 	/* Now we can initialize the JPEG decompression object. */
; 353  : 	jpeg_create_decompress(&cinfo);

  000f4	68 a8 01 00 00	 push	 424			; 000001a8H
  000f9	6a 3d		 push	 61			; 0000003dH
  000fb	50		 push	 eax
  000fc	e8 00 00 00 00	 call	 _jpeg_CreateDecompress

; 354  : 
; 355  : 	/* Step 2: specify data source (eg, a file) */
; 356  : 
; 357  : 	jpeg_stdio_src(&cinfo, infile);

  00101	8b b5 84 fc ff
	ff		 mov	 esi, DWORD PTR _infile$[ebp]
  00107	8d 85 4c fd ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  0010d	56		 push	 esi
  0010e	50		 push	 eax
  0010f	e8 00 00 00 00	 call	 _jpeg_stdio_src

; 358  : 
; 359  : 	/* Step 3: read file parameters with jpeg_read_header() */
; 360  : 
; 361  : 	(void) jpeg_read_header(&cinfo, TRUE);

  00114	8d 85 4c fd ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  0011a	6a 01		 push	 1
  0011c	50		 push	 eax
  0011d	e8 00 00 00 00	 call	 _jpeg_read_header

; 362  : 	/* We can ignore the return value from jpeg_read_header since
; 363  : 	*   (a) suspension is not possible with the stdio data source, and
; 364  : 	*   (b) we passed TRUE to reject a tables-only JPEG file as an error.
; 365  : 	* See libjpeg.doc for more info.
; 366  : 	*/
; 367  : 
; 368  : 
; 369  : 	// how big is this thing ?
; 370  : 	*width = cinfo.image_width;

  00122	8b 85 80 fc ff
	ff		 mov	 eax, DWORD PTR _width$GSCopy$[ebp]
  00128	8b 8d 64 fd ff
	ff		 mov	 ecx, DWORD PTR _cinfo$[ebp+24]
  0012e	89 08		 mov	 DWORD PTR [eax], ecx

; 371  : 	*height = cinfo.image_height;

  00130	8b 85 7c fc ff
	ff		 mov	 eax, DWORD PTR _height$GSCopy$[ebp]
  00136	8b 8d 68 fd ff
	ff		 mov	 ecx, DWORD PTR _cinfo$[ebp+28]
  0013c	89 08		 mov	 DWORD PTR [eax], ecx

; 372  : 
; 373  : 	/* Step 8: Release JPEG decompression object */
; 374  : 
; 375  : 	/* This is an important step since it will release a good deal of memory. */
; 376  : 	jpeg_destroy_decompress(&cinfo);

  0013e	8d 85 4c fd ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  00144	50		 push	 eax
  00145	e8 00 00 00 00	 call	 _jpeg_destroy_decompress

; 377  : 
; 378  : 	/* After finish_decompress, we can close the input file.
; 379  : 	* Here we postpone it until after no more JPEG errors are possible,
; 380  : 	* so as to simplify the setjmp error logic above.  (Actually, I don't
; 381  : 	* think that jpeg_destroy can do an error exit, but why assume anything...)
; 382  : 	*/
; 383  : 	fclose(infile);

  0014a	56		 push	 esi
  0014b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  00151	83 c4 24	 add	 esp, 36			; 00000024H

; 384  : 
; 385  : 	/* At this point you may want to check to see whether any corrupt-data
; 386  : 	* warnings occurred (test whether jerr.pub.num_warnings is nonzero).
; 387  : 	*/
; 388  : 
; 389  : 	return TRUE;

  00154	be 01 00 00 00	 mov	 esi, 1
$LN8@GetJPGDime:
  00159	8d 4d 08	 lea	 ecx, DWORD PTR _fileName$[ebp]
  0015c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00162	8b c6		 mov	 eax, esi

; 390  : }

  00164	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00167	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0016e	59		 pop	 ecx
  0016f	5e		 pop	 esi
  00170	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00173	33 cd		 xor	 ecx, ebp
  00175	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0017a	8b e5		 mov	 esp, ebp
  0017c	5d		 pop	 ebp
  0017d	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetJPGDimensions@JpegFile@@SAHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAI1@Z$0:
  00000	8d 4d 08	 lea	 ecx, DWORD PTR _fileName$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
  0000d	cc		 int	 3
__ehhandler$?GetJPGDimensions@JpegFile@@SAHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAI1@Z:
  0000e	90		 npad	 1
  0000f	90		 npad	 1
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 8a 80 fc ff
	ff		 mov	 ecx, DWORD PTR [edx-896]
  0001d	33 c8		 xor	 ecx, eax
  0001f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00024	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00027	33 c8		 xor	 ecx, eax
  00029	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002e	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?GetJPGDimensions@JpegFile@@SAHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAI1@Z
  00033	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?GetJPGDimensions@JpegFile@@SAHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAI1@Z ENDP ; JpegFile::GetJPGDimensions
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\Jpegfile.cpp
;	COMDAT ?RGBToJpegFile@JpegFile@@SAHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAEIIHH@Z
_TEXT	SEGMENT
_outRow$2 = -840					; size = 4
_dataBuf$GSCopy$ = -836					; size = 4
_height$GSCopy$ = -832					; size = 4
_widthPix$GSCopy$ = -828				; size = 4
_height$GSCopy$1$ = -824				; size = 4
_tmp$ = -820						; size = 4
_outfile$ = -816					; size = 4
_dataBuf$GSCopy$1$ = -812				; size = 4
tv657 = -812						; size = 4
_jerr$ = -808						; size = 196
_cinfo$ = -612						; size = 344
_buf$3 = -268						; size = 250
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_fileName$ = 8						; size = 4
_dataBuf$ = 12						; size = 4
_widthPix$ = 16						; size = 4
_height$ = 20						; size = 4
_color$ = 24						; size = 4
_quality$ = 28						; size = 4
?RGBToJpegFile@JpegFile@@SAHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAEIIHH@Z PROC ; JpegFile::RGBToJpegFile, COMDAT

; 431  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?RGBToJpegFile@JpegFile@@SAHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAEIIHH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 3c 03 00
	00		 sub	 esp, 828		; 0000033cH
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	8b 45 0c	 mov	 eax, DWORD PTR _dataBuf$[ebp]
  00031	8b 7d 14	 mov	 edi, DWORD PTR _height$[ebp]
  00034	8b 75 10	 mov	 esi, DWORD PTR _widthPix$[ebp]
  00037	89 85 d4 fc ff
	ff		 mov	 DWORD PTR _dataBuf$GSCopy$1$[ebp], eax
  0003d	89 85 bc fc ff
	ff		 mov	 DWORD PTR _dataBuf$GSCopy$[ebp], eax
  00043	89 b5 c4 fc ff
	ff		 mov	 DWORD PTR _widthPix$GSCopy$[ebp], esi
  00049	89 bd c8 fc ff
	ff		 mov	 DWORD PTR _height$GSCopy$1$[ebp], edi
  0004f	89 bd c0 fc ff
	ff		 mov	 DWORD PTR _height$GSCopy$[ebp], edi
  00055	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 432  : 	if (dataBuf==NULL)

  0005c	85 c0		 test	 eax, eax
  0005e	74 38		 je	 SHORT $LN30@RGBToJpegF

; 433  : 		return FALSE;
; 434  : 	if (widthPix==0)

  00060	85 f6		 test	 esi, esi
  00062	74 34		 je	 SHORT $LN30@RGBToJpegF

; 435  : 		return FALSE;
; 436  : 	if (height==0)

  00064	85 ff		 test	 edi, edi
  00066	74 30		 je	 SHORT $LN30@RGBToJpegF

; 437  : 		return FALSE;
; 438  : 
; 439  : 	LPBYTE tmp;
; 440  : 	if (!color) {

  00068	83 7d 18 00	 cmp	 DWORD PTR _color$[ebp], 0
  0006c	0f 85 f8 00 00
	00		 jne	 $LN3@RGBToJpegF

; 441  : 		tmp = (BYTE*)new BYTE[widthPix*height];

  00072	8b c7		 mov	 eax, edi
  00074	0f af c6	 imul	 eax, esi
  00077	50		 push	 eax
  00078	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  0007d	8b d8		 mov	 ebx, eax
  0007f	83 c4 04	 add	 esp, 4
  00082	89 9d cc fc ff
	ff		 mov	 DWORD PTR _tmp$[ebp], ebx

; 442  : 		if (tmp==NULL) {

  00088	85 db		 test	 ebx, ebx
  0008a	75 35		 jne	 SHORT $LN14@RGBToJpegF

; 443  : 			AfxMessageBox("Memory error");

  0008c	50		 push	 eax
  0008d	50		 push	 eax
  0008e	68 00 00 00 00	 push	 OFFSET ??_C@_0N@OHBPFNDO@Memory?5error@
$LN47@RGBToJpegF:

; 501  : 		AfxMessageBox(buf);

  00093	e8 00 00 00 00	 call	 ?AfxMessageBox@@YGHPBDII@Z ; AfxMessageBox
$LN30@RGBToJpegF:
  00098	33 f6		 xor	 esi, esi
$LN31@RGBToJpegF:

; 583  :   /* And we're done! */
; 584  : 
; 585  :   return TRUE;

  0009a	8d 4d 08	 lea	 ecx, DWORD PTR _fileName$[ebp]
  0009d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  000a3	8b c6		 mov	 eax, esi

; 586  : }

  000a5	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a8	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000af	59		 pop	 ecx
  000b0	5f		 pop	 edi
  000b1	5e		 pop	 esi
  000b2	5b		 pop	 ebx
  000b3	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b6	33 cd		 xor	 ecx, ebp
  000b8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000bd	8b e5		 mov	 esp, ebp
  000bf	5d		 pop	 ebp
  000c0	c3		 ret	 0
$LN14@RGBToJpegF:

; 444  : 			return FALSE;
; 445  : 		}
; 446  : 
; 447  : 		UINT row,col;
; 448  : 		for (row=0;row<height;row++) {

  000c1	85 ff		 test	 edi, edi
  000c3	0f 84 a1 00 00
	00		 je	 $LN3@RGBToJpegF
  000c9	8b 85 d4 fc ff
	ff		 mov	 eax, DWORD PTR _dataBuf$GSCopy$1$[ebp]
  000cf	8d 0c 76	 lea	 ecx, DWORD PTR [esi+esi*2]
  000d2	f2 0f 10 15 00
	00 00 00	 movsd	 xmm2, QWORD PTR __real@3fe2c8b439581062
  000da	83 c0 02	 add	 eax, 2
  000dd	f2 0f 10 1d 00
	00 00 00	 movsd	 xmm3, QWORD PTR __real@3fd322d0e5604189
  000e5	f2 0f 10 25 00
	00 00 00	 movsd	 xmm4, QWORD PTR __real@3fbd2f1a9fbe76c9
  000ed	89 85 d4 fc ff
	ff		 mov	 DWORD PTR tv657[ebp], eax
$LL4@RGBToJpegF:

; 449  : 			for (col=0;col<widthPix;col++) {

  000f3	85 f6		 test	 esi, esi
  000f5	74 5e		 je	 SHORT $LN2@RGBToJpegF
  000f7	8b d3		 mov	 edx, ebx
  000f9	8b c8		 mov	 ecx, eax
  000fb	8b fe		 mov	 edi, esi
  000fd	0f 1f 00	 npad	 3
$LL7@RGBToJpegF:

; 450  : 				LPBYTE pRed, pGrn, pBlu;
; 451  : 				pRed = dataBuf + row * widthPix * 3 + col * 3;
; 452  : 				pGrn = dataBuf + row * widthPix * 3 + col * 3 + 1;
; 453  : 				pBlu = dataBuf + row * widthPix * 3 + col * 3 + 2;
; 454  : 
; 455  : 				// luminance
; 456  : 				int lum = (int)(.299 * (double)(*pRed) + .587 * (double)(*pGrn) + .114 * (double)(*pBlu));

  00100	0f b6 41 ff	 movzx	 eax, BYTE PTR [ecx-1]
  00104	66 0f 6e c8	 movd	 xmm1, eax
  00108	0f b6 41 fe	 movzx	 eax, BYTE PTR [ecx-2]
  0010c	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1
  00110	66 0f 6e c0	 movd	 xmm0, eax
  00114	0f b6 01	 movzx	 eax, BYTE PTR [ecx]
  00117	83 c1 03	 add	 ecx, 3
  0011a	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  0011e	f2 0f 59 ca	 mulsd	 xmm1, xmm2
  00122	f2 0f 59 c3	 mulsd	 xmm0, xmm3
  00126	f2 0f 58 c8	 addsd	 xmm1, xmm0
  0012a	66 0f 6e c0	 movd	 xmm0, eax
  0012e	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00132	f2 0f 59 c4	 mulsd	 xmm0, xmm4
  00136	f2 0f 58 c8	 addsd	 xmm1, xmm0
  0013a	f2 0f 2c c1	 cvttsd2si eax, xmm1

; 457  : 				LPBYTE pGray;
; 458  : 				pGray = tmp + row * widthPix + col;
; 459  : 				*pGray = (BYTE)lum;

  0013e	88 02		 mov	 BYTE PTR [edx], al
  00140	42		 inc	 edx
  00141	83 ef 01	 sub	 edi, 1
  00144	75 ba		 jne	 SHORT $LL7@RGBToJpegF
  00146	8b bd c8 fc ff
	ff		 mov	 edi, DWORD PTR _height$GSCopy$1$[ebp]
  0014c	8d 0c 76	 lea	 ecx, DWORD PTR [esi+esi*2]
  0014f	8b 85 d4 fc ff
	ff		 mov	 eax, DWORD PTR tv657[ebp]
$LN2@RGBToJpegF:

; 444  : 			return FALSE;
; 445  : 		}
; 446  : 
; 447  : 		UINT row,col;
; 448  : 		for (row=0;row<height;row++) {

  00155	03 c1		 add	 eax, ecx
  00157	03 de		 add	 ebx, esi
  00159	83 ef 01	 sub	 edi, 1
  0015c	89 85 d4 fc ff
	ff		 mov	 DWORD PTR tv657[ebp], eax
  00162	89 bd c8 fc ff
	ff		 mov	 DWORD PTR _height$GSCopy$1$[ebp], edi
  00168	75 89		 jne	 SHORT $LL4@RGBToJpegF
$LN3@RGBToJpegF:

; 460  : 			}
; 461  : 		}
; 462  : 	}
; 463  : 
; 464  : 	struct jpeg_compress_struct cinfo;
; 465  : 	/* More stuff */
; 466  : 	FILE * outfile=NULL;			/* target file */
; 467  : 	int row_stride;			/* physical row widthPix in image buffer */
; 468  : 
; 469  : 	struct my_error_mgr jerr;
; 470  : 
; 471  : 	/* Step 1: allocate and initialize JPEG compression object */
; 472  : 	cinfo.err = jpeg_std_error(&jerr.pub);

  0016a	8d 85 d8 fc ff
	ff		 lea	 eax, DWORD PTR _jerr$[ebp]
  00170	c7 85 d0 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _outfile$[ebp], 0
  0017a	50		 push	 eax
  0017b	e8 00 00 00 00	 call	 _jpeg_std_error

; 473  : 	jerr.pub.error_exit = my_error_exit;
; 474  : 
; 475  : 	/* Establish the setjmp return context for my_error_exit to use. */
; 476  : 	if (setjmp(jerr.setjmp_buffer)) {

  00180	68 00 00 00 00	 push	 OFFSET __ehfuncinfo$?RGBToJpegFile@JpegFile@@SAHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAEIIHH@Z
  00185	89 85 9c fd ff
	ff		 mov	 DWORD PTR _cinfo$[ebp], eax
  0018b	8d 8d 5c fd ff
	ff		 lea	 ecx, DWORD PTR _jerr$[ebp+132]
  00191	8b 45 fc	 mov	 eax, DWORD PTR __$EHRec$[ebp+8]
  00194	50		 push	 eax
  00195	68 00 00 00 00	 push	 OFFSET ___CxxLongjmpUnwind@4
  0019a	6a 03		 push	 3
  0019c	51		 push	 ecx
  0019d	c7 85 d8 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _jerr$[ebp], OFFSET ?my_error_exit@@YAXPAUjpeg_common_struct@@@Z ; my_error_exit
  001a7	e8 00 00 00 00	 call	 __setjmp3
  001ac	83 c4 18	 add	 esp, 24			; 00000018H
  001af	85 c0		 test	 eax, eax
  001b1	8d 85 9c fd ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  001b7	74 3a		 je	 SHORT $LN15@RGBToJpegF

; 477  : 		/* If we get here, the JPEG code has signaled an error.
; 478  : 		 * We need to clean up the JPEG object, close the input file, and return.
; 479  : 		 */
; 480  : 
; 481  : 		jpeg_destroy_compress(&cinfo);

  001b9	50		 push	 eax
  001ba	e8 00 00 00 00	 call	 _jpeg_destroy_compress

; 482  : 
; 483  : 		if (outfile!=NULL)

  001bf	8b 85 d0 fc ff
	ff		 mov	 eax, DWORD PTR _outfile$[ebp]
  001c5	83 c4 04	 add	 esp, 4
  001c8	85 c0		 test	 eax, eax
  001ca	74 0a		 je	 SHORT $LN16@RGBToJpegF

; 484  : 			fclose(outfile);

  001cc	50		 push	 eax
  001cd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  001d3	83 c4 04	 add	 esp, 4
$LN16@RGBToJpegF:

; 485  : 
; 486  : 		if (!color) {

  001d6	83 7d 18 00	 cmp	 DWORD PTR _color$[ebp], 0
  001da	0f 85 b8 fe ff
	ff		 jne	 $LN30@RGBToJpegF

; 487  : 			delete [] tmp;

  001e0	ff b5 cc fc ff
	ff		 push	 DWORD PTR _tmp$[ebp]
  001e6	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  001eb	83 c4 04	 add	 esp, 4
  001ee	e9 a5 fe ff ff	 jmp	 $LN30@RGBToJpegF
$LN15@RGBToJpegF:

; 488  : 		}
; 489  : 		return FALSE;
; 490  : 	}
; 491  : 
; 492  : 	/* Now we can initialize the JPEG compression object. */
; 493  : 	jpeg_create_compress(&cinfo);

  001f3	68 58 01 00 00	 push	 344			; 00000158H
  001f8	6a 3d		 push	 61			; 0000003dH
  001fa	50		 push	 eax
  001fb	e8 00 00 00 00	 call	 _jpeg_CreateCompress

; 494  : 
; 495  : 	/* Step 2: specify data destination (eg, a file) */
; 496  : 	/* Note: steps 2 and 3 can be done in either order. */
; 497  : 
; 498  : 	if ((outfile = fopen(fileName, "wb")) == NULL) {

  00200	68 00 00 00 00	 push	 OFFSET ??_C@_02GMLFBBN@wb@
  00205	ff 75 08	 push	 DWORD PTR _fileName$[ebp]
  00208	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  0020e	83 c4 14	 add	 esp, 20			; 00000014H
  00211	89 85 d0 fc ff
	ff		 mov	 DWORD PTR _outfile$[ebp], eax
  00217	85 c0		 test	 eax, eax
  00219	75 27		 jne	 SHORT $LN18@RGBToJpegF

; 499  : 		char buf[250];
; 500  : 		sprintf(buf, "JpegFile :\nCan't open %s\n", fileName);

  0021b	ff 75 08	 push	 DWORD PTR _fileName$[ebp]
  0021e	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR _buf$3[ebp]
  00224	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@MBGBNCJG@JpegFile?5?3?6Can?8t?5open?5?$CFs?6@
  00229	50		 push	 eax
  0022a	e8 00 00 00 00	 call	 _sprintf
  0022f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 501  : 		AfxMessageBox(buf);

  00232	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR _buf$3[ebp]
  00238	6a 00		 push	 0
  0023a	6a 00		 push	 0
  0023c	50		 push	 eax
  0023d	e9 51 fe ff ff	 jmp	 $LN47@RGBToJpegF
$LN18@RGBToJpegF:

; 502  : 		return FALSE;
; 503  : 	}
; 504  : 
; 505  : 	jpeg_stdio_dest(&cinfo, outfile);

  00242	50		 push	 eax
  00243	8d 85 9c fd ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  00249	50		 push	 eax
  0024a	e8 00 00 00 00	 call	 _jpeg_stdio_dest

; 506  : 
; 507  : 	/* Step 3: set parameters for compression */
; 508  : 												    
; 509  : 	/* First we supply a description of the input image.
; 510  : 	* Four fields of the cinfo struct must be filled in:
; 511  : 	*/
; 512  : 	cinfo.image_width = widthPix; 	/* image widthPix and height, in pixels */
; 513  : 	cinfo.image_height = height;
; 514  : 	if (color) {

  0024f	8b 5d 18	 mov	 ebx, DWORD PTR _color$[ebp]
  00252	83 c4 08	 add	 esp, 8
  00255	8b bd c4 fc ff
	ff		 mov	 edi, DWORD PTR _widthPix$GSCopy$[ebp]
  0025b	8b 85 c0 fc ff
	ff		 mov	 eax, DWORD PTR _height$GSCopy$[ebp]
  00261	89 bd b4 fd ff
	ff		 mov	 DWORD PTR _cinfo$[ebp+24], edi
  00267	89 85 b8 fd ff
	ff		 mov	 DWORD PTR _cinfo$[ebp+28], eax
  0026d	85 db		 test	 ebx, ebx
  0026f	74 16		 je	 SHORT $LN19@RGBToJpegF

; 515  : 		cinfo.input_components = 3;		/* # of color components per pixel */

  00271	c7 85 bc fd ff
	ff 03 00 00 00	 mov	 DWORD PTR _cinfo$[ebp+32], 3

; 516  : 		cinfo.in_color_space = JCS_RGB; 	/* colorspace of input image */

  0027b	c7 85 c0 fd ff
	ff 02 00 00 00	 mov	 DWORD PTR _cinfo$[ebp+36], 2

; 517  : 	} else {

  00285	eb 14		 jmp	 SHORT $LN20@RGBToJpegF
$LN19@RGBToJpegF:

; 518  : 		cinfo.input_components = 1;		/* # of color components per pixel */

  00287	c7 85 bc fd ff
	ff 01 00 00 00	 mov	 DWORD PTR _cinfo$[ebp+32], 1

; 519  : 		cinfo.in_color_space = JCS_GRAYSCALE; 	/* colorspace of input image */

  00291	c7 85 c0 fd ff
	ff 01 00 00 00	 mov	 DWORD PTR _cinfo$[ebp+36], 1
$LN20@RGBToJpegF:

; 520  : 	}
; 521  : 
; 522  :  
; 523  : /* Now use the library's routine to set default compression parameters.
; 524  :    * (You must set at least cinfo.in_color_space before calling this,
; 525  :    * since the defaults depend on the source color space.)
; 526  :    */
; 527  : 
; 528  :   jpeg_set_defaults(&cinfo);

  0029b	8d 85 9c fd ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  002a1	50		 push	 eax
  002a2	e8 00 00 00 00	 call	 _jpeg_set_defaults

; 529  :   /* Now you can set any non-default parameters you wish to.
; 530  :    * Here we just illustrate the use of quality (quantization table) scaling:
; 531  :    */
; 532  :   jpeg_set_quality(&cinfo, quality, TRUE /* limit to baseline-JPEG values */);

  002a7	6a 01		 push	 1
  002a9	ff 75 1c	 push	 DWORD PTR _quality$[ebp]
  002ac	8d 85 9c fd ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  002b2	50		 push	 eax
  002b3	e8 00 00 00 00	 call	 _jpeg_set_quality

; 533  : 
; 534  :   /* Step 4: Start compressor */
; 535  : 
; 536  :   /* TRUE ensures that we will write a complete interchange-JPEG file.
; 537  :    * Pass TRUE unless you are very sure of what you're doing.
; 538  :    */
; 539  :   jpeg_start_compress(&cinfo, TRUE);

  002b8	8d 85 9c fd ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  002be	6a 01		 push	 1
  002c0	50		 push	 eax
  002c1	e8 00 00 00 00	 call	 _jpeg_start_compress

; 540  : 
; 541  :   /* Step 5: while (scan lines remain to be written) */
; 542  :   /*           jpeg_write_scanlines(...); */
; 543  : 
; 544  :   /* Here we use the library's state variable cinfo.next_scanline as the
; 545  :    * loop counter, so that we don't have to keep track ourselves.
; 546  :    * To keep things simple, we pass one scanline per call; you can pass
; 547  :    * more if you wish, though.
; 548  :    */
; 549  :   row_stride = widthPix * 3;	/* JSAMPLEs per row in image_buffer */
; 550  : 
; 551  :  	UINT scanline = 0;

  002c6	33 f6		 xor	 esi, esi
  002c8	83 c4 18	 add	 esp, 24			; 00000018H

; 552  : 	while (scanline < cinfo.image_height) {

  002cb	39 b5 b8 fd ff
	ff		 cmp	 DWORD PTR _cinfo$[ebp+28], esi
  002d1	76 50		 jbe	 SHORT $LN9@RGBToJpegF
$LL8@RGBToJpegF:

; 553  : //  while (cinfo.next_scanline < cinfo.image_height) {
; 554  :     /* jpeg_write_scanlines expects an array of pointers to scanlines.
; 555  :      * Here the array is only one element long, but you could pass
; 556  :      * more than one scanline at a time if that's more convenient.
; 557  :      */
; 558  : 	LPBYTE outRow;
; 559  : 	if (color) {

  002d3	85 db		 test	 ebx, ebx
  002d5	74 16		 je	 SHORT $LN21@RGBToJpegF

; 560  : 		outRow = dataBuf + (cinfo.next_scanline * widthPix * 3);

  002d7	8b 8d bc fc ff
	ff		 mov	 ecx, DWORD PTR _dataBuf$GSCopy$[ebp]
  002dd	8b c7		 mov	 eax, edi
  002df	0f af 85 60 fe
	ff ff		 imul	 eax, DWORD PTR _cinfo$[ebp+196]
  002e6	8d 0c 41	 lea	 ecx, DWORD PTR [ecx+eax*2]
  002e9	03 c8		 add	 ecx, eax

; 561  : 	} else {

  002eb	eb 0f		 jmp	 SHORT $LN22@RGBToJpegF
$LN21@RGBToJpegF:

; 562  : 		outRow = tmp + (cinfo.next_scanline * widthPix);

  002ed	8b cf		 mov	 ecx, edi
  002ef	0f af 8d 60 fe
	ff ff		 imul	 ecx, DWORD PTR _cinfo$[ebp+196]
  002f6	03 8d cc fc ff
	ff		 add	 ecx, DWORD PTR _tmp$[ebp]
$LN22@RGBToJpegF:

; 563  : 	}
; 564  : 
; 565  :     (void) jpeg_write_scanlines(&cinfo, &outRow, 1);

  002fc	6a 01		 push	 1
  002fe	8d 85 b8 fc ff
	ff		 lea	 eax, DWORD PTR _outRow$2[ebp]
  00304	89 8d b8 fc ff
	ff		 mov	 DWORD PTR _outRow$2[ebp], ecx
  0030a	50		 push	 eax
  0030b	8d 85 9c fd ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  00311	50		 push	 eax
  00312	e8 00 00 00 00	 call	 _jpeg_write_scanlines

; 566  : 	scanline++;

  00317	46		 inc	 esi
  00318	83 c4 0c	 add	 esp, 12			; 0000000cH
  0031b	3b b5 b8 fd ff
	ff		 cmp	 esi, DWORD PTR _cinfo$[ebp+28]
  00321	72 b0		 jb	 SHORT $LL8@RGBToJpegF
$LN9@RGBToJpegF:

; 567  :   }
; 568  : 
; 569  :   /* Step 6: Finish compression */
; 570  : 
; 571  :   jpeg_finish_compress(&cinfo);

  00323	8d 85 9c fd ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  00329	50		 push	 eax
  0032a	e8 00 00 00 00	 call	 _jpeg_finish_compress

; 572  : 
; 573  :   /* After finish_compress, we can close the output file. */
; 574  :   fclose(outfile);

  0032f	ff b5 d0 fc ff
	ff		 push	 DWORD PTR _outfile$[ebp]
  00335	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose

; 575  : 
; 576  :   /* Step 7: release JPEG compression object */
; 577  : 
; 578  :   /* This is an important step since it will release a good deal of memory. */
; 579  :   jpeg_destroy_compress(&cinfo);

  0033b	8d 85 9c fd ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  00341	50		 push	 eax
  00342	e8 00 00 00 00	 call	 _jpeg_destroy_compress
  00347	83 c4 0c	 add	 esp, 12			; 0000000cH

; 580  : 
; 581  :   if (!color)

  0034a	85 db		 test	 ebx, ebx
  0034c	75 0e		 jne	 SHORT $LN23@RGBToJpegF

; 582  : 	  delete [] tmp;

  0034e	ff b5 cc fc ff
	ff		 push	 DWORD PTR _tmp$[ebp]
  00354	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00359	83 c4 04	 add	 esp, 4
$LN23@RGBToJpegF:

; 583  :   /* And we're done! */
; 584  : 
; 585  :   return TRUE;

  0035c	be 01 00 00 00	 mov	 esi, 1
  00361	e9 34 fd ff ff	 jmp	 $LN31@RGBToJpegF
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?RGBToJpegFile@JpegFile@@SAHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAEIIHH@Z$0:
  00000	8d 4d 08	 lea	 ecx, DWORD PTR _fileName$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
  0000d	cc		 int	 3
__ehhandler$?RGBToJpegFile@JpegFile@@SAHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAEIIHH@Z:
  0000e	90		 npad	 1
  0000f	90		 npad	 1
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 8a b4 fc ff
	ff		 mov	 ecx, DWORD PTR [edx-844]
  0001d	33 c8		 xor	 ecx, eax
  0001f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00024	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00027	33 c8		 xor	 ecx, eax
  00029	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002e	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?RGBToJpegFile@JpegFile@@SAHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAEIIHH@Z
  00033	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?RGBToJpegFile@JpegFile@@SAHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAEIIHH@Z ENDP ; JpegFile::RGBToJpegFile
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\Jpegfile.cpp
;	COMDAT ?JpegFileToRGB@JpegFile@@SAPAEV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAI1@Z
_TEXT	SEGMENT
_height$GSCopy$ = -916					; size = 4
_dataBuf$ = -912					; size = 4
_widthPix$1$ = -908					; size = 4
_widthPix$1$ = -908					; size = 4
_infile$ = -904						; size = 4
_buffer$1$ = -900					; size = 4
_jpegline$1$ = -896					; size = 4
tv547 = -896						; size = 4
_width$GSCopy$ = -892					; size = 4
_jerr$ = -888						; size = 196
_cinfo$ = -692						; size = 424
_buf$ = -268						; size = 250
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_fileName$ = 8						; size = 4
_width$ = 12						; size = 4
_height$ = 16						; size = 4
?JpegFileToRGB@JpegFile@@SAPAEV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAI1@Z PROC ; JpegFile::JpegFileToRGB, COMDAT

; 116  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?JpegFileToRGB@JpegFile@@SAPAEV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAI1@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 88 03 00
	00		 sub	 esp, 904		; 00000388H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	8b 4d 0c	 mov	 ecx, DWORD PTR _width$[ebp]
  00031	8b 45 10	 mov	 eax, DWORD PTR _height$[ebp]
  00034	89 8d 84 fc ff
	ff		 mov	 DWORD PTR _width$GSCopy$[ebp], ecx
  0003a	89 85 6c fc ff
	ff		 mov	 DWORD PTR _height$GSCopy$[ebp], eax

; 117  : 	// get our buffer set to hold data
; 118  : 	BYTE *dataBuf = NULL;
; 119  : 
; 120  : 	// basic code from IJG Jpeg Code v6 example.c
; 121  : 
; 122  : 	*width=0;

  00040	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 123  : 	*height=0;

  00046	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 124  : 
; 125  : 	/* This struct contains the JPEG decompression parameters and pointers to
; 126  : 	* working space (which is allocated as needed by the JPEG library).
; 127  : 	*/
; 128  : 	struct jpeg_decompress_struct cinfo;
; 129  : 	/* We use our private extension JPEG error handler.
; 130  : 	* Note that this struct must live as long as the main JPEG parameter
; 131  : 	* struct, to avoid dangling-pointer problems.
; 132  : 	*/
; 133  : 	struct my_error_mgr jerr;
; 134  : 	/* More stuff */
; 135  : 	FILE * infile=NULL;		/* source file */
; 136  : 
; 137  : 	JSAMPARRAY buffer;		/* Output row buffer */
; 138  : 	int row_stride;		/* physical row width in output buffer */
; 139  : 	char buf[250];
; 140  : 
; 141  : 	/* In this example we want to open the input file before doing anything else,
; 142  : 	* so that the setjmp() error recovery below can assume the file is open.
; 143  : 	* VERY IMPORTANT: use "b" option to fopen() if you are on a machine that
; 144  : 	* requires it in order to read binary files.
; 145  : 	*/
; 146  : 
; 147  : 	if ((infile = fopen(fileName, "rb")) == NULL) {

  0004c	68 00 00 00 00	 push	 OFFSET ??_C@_02JDPG@rb@
  00051	ff 75 08	 push	 DWORD PTR _fileName$[ebp]
  00054	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0005b	c7 85 70 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _dataBuf$[ebp], 0
  00065	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  0006b	83 c4 08	 add	 esp, 8
  0006e	89 85 78 fc ff
	ff		 mov	 DWORD PTR _infile$[ebp], eax
  00074	85 c0		 test	 eax, eax
  00076	75 2e		 jne	 SHORT $LN4@JpegFileTo

; 148  : 		sprintf(buf, "JPEG :\nCan't open %s\n", fileName);

  00078	ff 75 08	 push	 DWORD PTR _fileName$[ebp]
  0007b	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR _buf$[ebp]
  00081	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@GDCAJJII@JPEG?5?3?6Can?8t?5open?5?$CFs?6@
  00086	50		 push	 eax
  00087	e8 00 00 00 00	 call	 _sprintf
  0008c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 149  : 		AfxMessageBox(buf);

  0008f	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR _buf$[ebp]
  00095	6a 00		 push	 0
  00097	6a 00		 push	 0
  00099	50		 push	 eax
  0009a	e8 00 00 00 00	 call	 ?AfxMessageBox@@YGHPBDII@Z ; AfxMessageBox
  0009f	33 ff		 xor	 edi, edi
  000a1	e9 7d 02 00 00	 jmp	 $LN16@JpegFileTo
$LN4@JpegFileTo:

; 150  : 		return NULL;
; 151  : 	}
; 152  : 
; 153  : 	/* Step 1: allocate and initialize JPEG decompression object */
; 154  : 
; 155  : 	/* We set up the normal JPEG error routines, then override error_exit. */
; 156  : 	cinfo.err = jpeg_std_error(&jerr.pub);

  000a6	8d 85 88 fc ff
	ff		 lea	 eax, DWORD PTR _jerr$[ebp]
  000ac	50		 push	 eax
  000ad	e8 00 00 00 00	 call	 _jpeg_std_error

; 157  : 	jerr.pub.error_exit = my_error_exit;
; 158  : 
; 159  : 
; 160  : 	/* Establish the setjmp return context for my_error_exit to use. */
; 161  : 	if (setjmp(jerr.setjmp_buffer)) {

  000b2	68 00 00 00 00	 push	 OFFSET __ehfuncinfo$?JpegFileToRGB@JpegFile@@SAPAEV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAI1@Z
  000b7	89 85 4c fd ff
	ff		 mov	 DWORD PTR _cinfo$[ebp], eax
  000bd	8d 8d 0c fd ff
	ff		 lea	 ecx, DWORD PTR _jerr$[ebp+132]
  000c3	8b 45 fc	 mov	 eax, DWORD PTR __$EHRec$[ebp+8]
  000c6	50		 push	 eax
  000c7	68 00 00 00 00	 push	 OFFSET ___CxxLongjmpUnwind@4
  000cc	6a 03		 push	 3
  000ce	51		 push	 ecx
  000cf	c7 85 88 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _jerr$[ebp], OFFSET ?my_error_exit@@YAXPAUjpeg_common_struct@@@Z ; my_error_exit
  000d9	e8 00 00 00 00	 call	 __setjmp3
  000de	83 c4 18	 add	 esp, 24			; 00000018H
  000e1	85 c0		 test	 eax, eax
  000e3	8d 85 4c fd ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  000e9	74 3b		 je	 SHORT $LN5@JpegFileTo

; 162  : 		/* If we get here, the JPEG code has signaled an error.
; 163  : 		 * We need to clean up the JPEG object, close the input file, and return.
; 164  : 		 */
; 165  : 
; 166  : 		jpeg_destroy_decompress(&cinfo);

  000eb	50		 push	 eax
  000ec	e8 00 00 00 00	 call	 _jpeg_destroy_decompress

; 167  : 
; 168  : 		if (infile!=NULL)

  000f1	8b 85 78 fc ff
	ff		 mov	 eax, DWORD PTR _infile$[ebp]
  000f7	83 c4 04	 add	 esp, 4
  000fa	85 c0		 test	 eax, eax
  000fc	74 0a		 je	 SHORT $LN6@JpegFileTo

; 169  : 			fclose(infile);

  000fe	50		 push	 eax
  000ff	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  00105	83 c4 04	 add	 esp, 4
$LN6@JpegFileTo:

; 170  : 
; 171  :       if (dataBuf!=NULL)

  00108	8b 85 70 fc ff
	ff		 mov	 eax, DWORD PTR _dataBuf$[ebp]
  0010e	85 c0		 test	 eax, eax
  00110	0f 84 92 00 00
	00		 je	 $LN15@JpegFileTo

; 172  :       {
; 173  :          delete [] dataBuf;

  00116	50		 push	 eax
  00117	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0011c	83 c4 04	 add	 esp, 4
  0011f	33 ff		 xor	 edi, edi
  00121	e9 fd 01 00 00	 jmp	 $LN16@JpegFileTo
$LN5@JpegFileTo:

; 174  :       }
; 175  : 
; 176  : 		return NULL;
; 177  : 	}
; 178  : 
; 179  : 	/* Now we can initialize the JPEG decompression object. */
; 180  : 	jpeg_create_decompress(&cinfo);

  00126	68 a8 01 00 00	 push	 424			; 000001a8H
  0012b	6a 3d		 push	 61			; 0000003dH
  0012d	50		 push	 eax
  0012e	e8 00 00 00 00	 call	 _jpeg_CreateDecompress

; 181  : 
; 182  : 	/* Step 2: specify data source (eg, a file) */
; 183  : 
; 184  : 	jpeg_stdio_src(&cinfo, infile);

  00133	8b 9d 78 fc ff
	ff		 mov	 ebx, DWORD PTR _infile$[ebp]
  00139	8d 85 4c fd ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  0013f	53		 push	 ebx
  00140	50		 push	 eax
  00141	e8 00 00 00 00	 call	 _jpeg_stdio_src

; 185  : 
; 186  : 	/* Step 3: read file parameters with jpeg_read_header() */
; 187  : 
; 188  : 	(void) jpeg_read_header(&cinfo, TRUE);

  00146	8d 85 4c fd ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  0014c	6a 01		 push	 1
  0014e	50		 push	 eax
  0014f	e8 00 00 00 00	 call	 _jpeg_read_header

; 189  : 	/* We can ignore the return value from jpeg_read_header since
; 190  : 	*   (a) suspension is not possible with the stdio data source, and
; 191  : 	*   (b) we passed TRUE to reject a tables-only JPEG file as an error.
; 192  : 	* See libjpeg.doc for more info.
; 193  : 	*/
; 194  : 
; 195  : 	/* Step 4: set parameters for decompression */
; 196  : 
; 197  : 	/* In this example, we don't need to change any of the defaults set by
; 198  : 	* jpeg_read_header(), so we do nothing here.
; 199  : 	*/
; 200  : 
; 201  : 	/* Step 5: Start decompressor */
; 202  : 
; 203  : 	(void) jpeg_start_decompress(&cinfo);

  00154	8d 85 4c fd ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  0015a	50		 push	 eax
  0015b	e8 00 00 00 00	 call	 _jpeg_start_decompress

; 204  : 	/* We can ignore the return value since suspension is not possible
; 205  : 	* with the stdio data source.
; 206  : 	*/
; 207  : 
; 208  : 	/* We may need to do some setup of our own at this point before reading
; 209  : 	* the data.  After jpeg_start_decompress() we have the correct scaled
; 210  : 	* output image dimensions available, as well as the output colormap
; 211  : 	* if we asked for color quantization.
; 212  : 	* In this example, we need to make an output work buffer of the right size.
; 213  : 	*/ 
; 214  : 
; 215  : 	////////////////////////////////////////////////////////////
; 216  : 	// alloc and open our new buffer
; 217  : 	dataBuf=(BYTE *)new BYTE[cinfo.output_width * 3 * cinfo.output_height];

  00160	8b 85 ac fd ff
	ff		 mov	 eax, DWORD PTR _cinfo$[ebp+96]
  00166	0f af 85 a8 fd
	ff ff		 imul	 eax, DWORD PTR _cinfo$[ebp+92]
  0016d	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00170	50		 push	 eax
  00171	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00176	8b f8		 mov	 edi, eax
  00178	83 c4 24	 add	 esp, 36			; 00000024H
  0017b	89 bd 70 fc ff
	ff		 mov	 DWORD PTR _dataBuf$[ebp], edi

; 218  : 	if (dataBuf==NULL) {

  00181	85 ff		 test	 edi, edi
  00183	75 2a		 jne	 SHORT $LN8@JpegFileTo

; 219  : 
; 220  : 		AfxMessageBox("JpegFile :\nOut of memory",MB_ICONSTOP);

  00185	50		 push	 eax
  00186	6a 10		 push	 16			; 00000010H
  00188	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@OCPMFGIG@JpegFile?5?3?6Out?5of?5memory@
  0018d	e8 00 00 00 00	 call	 ?AfxMessageBox@@YGHPBDII@Z ; AfxMessageBox

; 221  : 
; 222  : 		jpeg_destroy_decompress(&cinfo);

  00192	8d 85 4c fd ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  00198	50		 push	 eax
  00199	e8 00 00 00 00	 call	 _jpeg_destroy_decompress

; 223  : 		
; 224  : 		fclose(infile);

  0019e	53		 push	 ebx
  0019f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  001a5	83 c4 08	 add	 esp, 8
$LN15@JpegFileTo:
  001a8	33 ff		 xor	 edi, edi
  001aa	e9 74 01 00 00	 jmp	 $LN16@JpegFileTo
$LN8@JpegFileTo:

; 225  : 
; 226  : 		return NULL;
; 227  : 	}
; 228  : 
; 229  : 	// how big is this thing gonna be?
; 230  : 	*width = cinfo.output_width;

  001af	8b b5 84 fc ff
	ff		 mov	 esi, DWORD PTR _width$GSCopy$[ebp]
  001b5	8b 85 a8 fd ff
	ff		 mov	 eax, DWORD PTR _cinfo$[ebp+92]

; 231  : 	*height = cinfo.output_height;
; 232  : 	
; 233  : 	/* JSAMPLEs per row in output buffer */
; 234  : 	row_stride = cinfo.output_width * cinfo.output_components;
; 235  : 
; 236  : 	/* Make a one-row-high sample array that will go away when done with image */
; 237  : 	buffer = (*cinfo.mem->alloc_sarray)

  001bb	6a 01		 push	 1
  001bd	89 06		 mov	 DWORD PTR [esi], eax
  001bf	8b 85 6c fc ff
	ff		 mov	 eax, DWORD PTR _height$GSCopy$[ebp]
  001c5	8b 8d ac fd ff
	ff		 mov	 ecx, DWORD PTR _cinfo$[ebp+96]
  001cb	89 08		 mov	 DWORD PTR [eax], ecx
  001cd	8b 85 b4 fd ff
	ff		 mov	 eax, DWORD PTR _cinfo$[ebp+104]
  001d3	0f af 85 a8 fd
	ff ff		 imul	 eax, DWORD PTR _cinfo$[ebp+92]
  001da	50		 push	 eax
  001db	8d 85 4c fd ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  001e1	6a 01		 push	 1
  001e3	50		 push	 eax
  001e4	8b 85 50 fd ff
	ff		 mov	 eax, DWORD PTR _cinfo$[ebp+4]
  001ea	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  001ed	ff d0		 call	 eax

; 238  : 		((j_common_ptr) &cinfo, JPOOL_IMAGE, row_stride, 1);
; 239  : 
; 240  : 	/* Step 6: while (scan lines remain to be read) */
; 241  : 	/*           jpeg_read_scanlines(...); */
; 242  : 
; 243  : 	/* Here we use the library's state variable cinfo.output_scanline as the
; 244  : 	* loop counter, so that we don't have to keep track ourselves.
; 245  : 	*/
; 246  : 	while (cinfo.output_scanline < cinfo.output_height) {

  001ef	8b 8d c4 fd ff
	ff		 mov	 ecx, DWORD PTR _cinfo$[ebp+120]
  001f5	83 c4 10	 add	 esp, 16			; 00000010H
  001f8	8b d8		 mov	 ebx, eax
  001fa	89 9d 7c fc ff
	ff		 mov	 DWORD PTR _buffer$1$[ebp], ebx
  00200	3b 8d ac fd ff
	ff		 cmp	 ecx, DWORD PTR _cinfo$[ebp+96]
  00206	0f 83 f0 00 00
	00		 jae	 $LN3@JpegFileTo
  0020c	0f 1f 40 00	 npad	 4
$LL2@JpegFileTo:

; 247  : 		/* jpeg_read_scanlines expects an array of pointers to scanlines.
; 248  : 		 * Here the array is only one element long, but you could ask for
; 249  : 		 * more than one scanline at a time if that's more convenient.
; 250  : 		 */
; 251  : 		(void) jpeg_read_scanlines(&cinfo, buffer, 1);

  00210	6a 01		 push	 1
  00212	8d 85 4c fd ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  00218	53		 push	 ebx
  00219	50		 push	 eax
  0021a	e8 00 00 00 00	 call	 _jpeg_read_scanlines

; 252  : 		/* Assume put_scanline_someplace wants a pointer and sample count. */
; 253  : 
; 254  : 		// asuumer all 3-components are RGBs
; 255  : 		if (cinfo.out_color_components==3) {

  0021f	8b 85 b0 fd ff
	ff		 mov	 eax, DWORD PTR _cinfo$[ebp+100]
  00225	83 c4 0c	 add	 esp, 12			; 0000000cH
  00228	83 f8 03	 cmp	 eax, 3
  0022b	75 63		 jne	 SHORT $LN9@JpegFileTo

; 256  : 			
; 257  : 			j_putRGBScanline(buffer[0], 

  0022d	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0022f	8b 85 c4 fd ff
	ff		 mov	 eax, DWORD PTR _cinfo$[ebp+120]
  00235	8b 33		 mov	 esi, DWORD PTR [ebx]
  00237	48		 dec	 eax

; 597  : 	int offset = row * widthPix * 3;

  00238	0f af c1	 imul	 eax, ecx

; 256  : 			
; 257  : 			j_putRGBScanline(buffer[0], 

  0023b	33 db		 xor	 ebx, ebx
  0023d	89 8d 74 fc ff
	ff		 mov	 DWORD PTR _widthPix$1$[ebp], ecx

; 597  : 	int offset = row * widthPix * 3;

  00243	89 85 80 fc ff
	ff		 mov	 DWORD PTR tv547[ebp], eax

; 598  : 	int count;
; 599  : 	for (count=0;count<widthPix;count++) 

  00249	85 c9		 test	 ecx, ecx
  0024b	0f 8e 8d 00 00
	00		 jle	 $LN41@JpegFileTo

; 256  : 			
; 257  : 			j_putRGBScanline(buffer[0], 

  00251	83 c6 02	 add	 esi, 2
$LL22@JpegFileTo:

; 601  : 		*(outBuf + offset + count * 3 + 0) = *(jpegline + count * 3 + 0);

  00254	8d 14 18	 lea	 edx, DWORD PTR [eax+ebx]
  00257	0f b6 46 fe	 movzx	 eax, BYTE PTR [esi-2]
  0025b	8d 0c 57	 lea	 ecx, DWORD PTR [edi+edx*2]
  0025e	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  00261	8d 76 03	 lea	 esi, DWORD PTR [esi+3]

; 602  : 		*(outBuf + offset + count * 3 + 1) = *(jpegline + count * 3 + 1);

  00264	8b 8d 80 fc ff
	ff		 mov	 ecx, DWORD PTR tv547[ebp]
  0026a	03 cb		 add	 ecx, ebx
  0026c	43		 inc	 ebx
  0026d	8d 04 4f	 lea	 eax, DWORD PTR [edi+ecx*2]
  00270	03 c8		 add	 ecx, eax
  00272	0f b6 46 fc	 movzx	 eax, BYTE PTR [esi-4]
  00276	88 41 01	 mov	 BYTE PTR [ecx+1], al

; 603  : 		*(outBuf + offset + count * 3 + 2) = *(jpegline + count * 3 + 2);

  00279	0f b6 46 fd	 movzx	 eax, BYTE PTR [esi-3]
  0027d	88 41 02	 mov	 BYTE PTR [ecx+2], al
  00280	8b 85 80 fc ff
	ff		 mov	 eax, DWORD PTR tv547[ebp]
  00286	3b 9d 74 fc ff
	ff		 cmp	 ebx, DWORD PTR _widthPix$1$[ebp]
  0028c	7c c6		 jl	 SHORT $LL22@JpegFileTo

; 604  : 	}
; 605  : }

  0028e	eb 4e		 jmp	 SHORT $LN41@JpegFileTo
$LN9@JpegFileTo:

; 258  : 								*width,
; 259  : 								dataBuf,
; 260  : 								cinfo.output_scanline-1);
; 261  : 
; 262  : 		} else if (cinfo.out_color_components==1) {

  00290	83 f8 01	 cmp	 eax, 1
  00293	75 55		 jne	 SHORT $LN40@JpegFileTo

; 263  : 
; 264  : 			// assume all single component images are grayscale
; 265  : 			j_putGrayScanlineToRGB(buffer[0], 

  00295	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00297	33 c0		 xor	 eax, eax
  00299	8b b5 c4 fd ff
	ff		 mov	 esi, DWORD PTR _cinfo$[ebp+120]
  0029f	8b 13		 mov	 edx, DWORD PTR [ebx]
  002a1	4e		 dec	 esi

; 616  : 	int offset = row * widthPix * 3;

  002a2	0f af f1	 imul	 esi, ecx

; 263  : 
; 264  : 			// assume all single component images are grayscale
; 265  : 			j_putGrayScanlineToRGB(buffer[0], 

  002a5	89 8d 74 fc ff
	ff		 mov	 DWORD PTR _widthPix$1$[ebp], ecx
  002ab	89 95 80 fc ff
	ff		 mov	 DWORD PTR _jpegline$1$[ebp], edx

; 618  : 	for (count=0;count<widthPix;count++) {

  002b1	85 c9		 test	 ecx, ecx
  002b3	7e 2f		 jle	 SHORT $LN42@JpegFileTo
$LL27@JpegFileTo:

; 619  : 
; 620  : 		BYTE iGray;
; 621  : 
; 622  : 		// get our grayscale value
; 623  : 		iGray = *(jpegline + count);

  002b5	8a 1c 10	 mov	 bl, BYTE PTR [eax+edx]

; 624  : 
; 625  : 		*(outBuf + offset + count * 3 + 0) = iGray;

  002b8	8d 14 06	 lea	 edx, DWORD PTR [esi+eax]
  002bb	8d 0c 57	 lea	 ecx, DWORD PTR [edi+edx*2]
  002be	88 1c 0a	 mov	 BYTE PTR [edx+ecx], bl

; 626  : 		*(outBuf + offset + count * 3 + 1) = iGray;

  002c1	8d 14 06	 lea	 edx, DWORD PTR [esi+eax]
  002c4	8d 0c 57	 lea	 ecx, DWORD PTR [edi+edx*2]
  002c7	40		 inc	 eax
  002c8	88 5c 0a 01	 mov	 BYTE PTR [edx+ecx+1], bl

; 627  : 		*(outBuf + offset + count * 3 + 2) = iGray;

  002cc	88 5c 0a 02	 mov	 BYTE PTR [edx+ecx+2], bl
  002d0	8b 95 80 fc ff
	ff		 mov	 edx, DWORD PTR _jpegline$1$[ebp]
  002d6	3b 85 74 fc ff
	ff		 cmp	 eax, DWORD PTR _widthPix$1$[ebp]
  002dc	7c d7		 jl	 SHORT $LL27@JpegFileTo
$LN41@JpegFileTo:

; 238  : 		((j_common_ptr) &cinfo, JPOOL_IMAGE, row_stride, 1);
; 239  : 
; 240  : 	/* Step 6: while (scan lines remain to be read) */
; 241  : 	/*           jpeg_read_scanlines(...); */
; 242  : 
; 243  : 	/* Here we use the library's state variable cinfo.output_scanline as the
; 244  : 	* loop counter, so that we don't have to keep track ourselves.
; 245  : 	*/
; 246  : 	while (cinfo.output_scanline < cinfo.output_height) {

  002de	8b 9d 7c fc ff
	ff		 mov	 ebx, DWORD PTR _buffer$1$[ebp]
$LN42@JpegFileTo:
  002e4	8b b5 84 fc ff
	ff		 mov	 esi, DWORD PTR _width$GSCopy$[ebp]
$LN40@JpegFileTo:
  002ea	8b 85 c4 fd ff
	ff		 mov	 eax, DWORD PTR _cinfo$[ebp+120]
  002f0	3b 85 ac fd ff
	ff		 cmp	 eax, DWORD PTR _cinfo$[ebp+96]
  002f6	0f 82 14 ff ff
	ff		 jb	 $LL2@JpegFileTo
$LN3@JpegFileTo:

; 266  : 								*width,
; 267  : 								dataBuf,
; 268  : 								cinfo.output_scanline-1);
; 269  : 
; 270  : 		}
; 271  : 
; 272  : 	}
; 273  : 
; 274  : 	/* Step 7: Finish decompression */
; 275  : 
; 276  : 	(void) jpeg_finish_decompress(&cinfo);

  002fc	8d 85 4c fd ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  00302	50		 push	 eax
  00303	e8 00 00 00 00	 call	 _jpeg_finish_decompress

; 277  : 	/* We can ignore the return value since suspension is not possible
; 278  : 	* with the stdio data source.
; 279  : 	*/
; 280  : 
; 281  : 	/* Step 8: Release JPEG decompression object */
; 282  : 
; 283  : 	/* This is an important step since it will release a good deal of memory. */
; 284  : 	jpeg_destroy_decompress(&cinfo);

  00308	8d 85 4c fd ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  0030e	50		 push	 eax
  0030f	e8 00 00 00 00	 call	 _jpeg_destroy_decompress

; 285  : 
; 286  : 	/* After finish_decompress, we can close the input file.
; 287  : 	* Here we postpone it until after no more JPEG errors are possible,
; 288  : 	* so as to simplify the setjmp error logic above.  (Actually, I don't
; 289  : 	* think that jpeg_destroy can do an error exit, but why assume anything...)
; 290  : 	*/
; 291  : 	fclose(infile);

  00314	ff b5 78 fc ff
	ff		 push	 DWORD PTR _infile$[ebp]
  0031a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  00320	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN16@JpegFileTo:

; 292  : 
; 293  : 	/* At this point you may want to check to see whether any corrupt-data
; 294  : 	* warnings occurred (test whether jerr.pub.num_warnings is nonzero).
; 295  : 	*/
; 296  : 
; 297  : 	return dataBuf;

  00323	8d 4d 08	 lea	 ecx, DWORD PTR _fileName$[ebp]
  00326	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0032c	8b c7		 mov	 eax, edi

; 298  : }

  0032e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00331	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00338	59		 pop	 ecx
  00339	5f		 pop	 edi
  0033a	5e		 pop	 esi
  0033b	5b		 pop	 ebx
  0033c	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0033f	33 cd		 xor	 ecx, ebp
  00341	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00346	8b e5		 mov	 esp, ebp
  00348	5d		 pop	 ebp
  00349	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?JpegFileToRGB@JpegFile@@SAPAEV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAI1@Z$0:
  00000	8d 4d 08	 lea	 ecx, DWORD PTR _fileName$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
  0000d	cc		 int	 3
__ehhandler$?JpegFileToRGB@JpegFile@@SAPAEV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAI1@Z:
  0000e	90		 npad	 1
  0000f	90		 npad	 1
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 8a 68 fc ff
	ff		 mov	 ecx, DWORD PTR [edx-920]
  0001d	33 c8		 xor	 ecx, eax
  0001f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00024	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00027	33 c8		 xor	 ecx, eax
  00029	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002e	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?JpegFileToRGB@JpegFile@@SAPAEV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAI1@Z
  00033	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?JpegFileToRGB@JpegFile@@SAPAEV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAI1@Z ENDP ; JpegFile::JpegFileToRGB
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1771 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1392 :         int const _Result = __stdio_common_vsprintf(

  00003	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00006	50		 push	 eax
  00007	6a 00		 push	 0
  00009	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000c	6a ff		 push	 -1
  0000e	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00011	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00016	8b 08		 mov	 ecx, DWORD PTR [eax]
  00018	ff 70 04	 push	 DWORD PTR [eax+4]
  0001b	83 c9 01	 or	 ecx, 1
  0001e	51		 push	 ecx
  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vsprintf

; 1393 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1394 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1395 : 
; 1396 :         return _Result < 0 ? -1 : _Result;

  00025	83 c9 ff	 or	 ecx, -1
  00028	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002b	85 c0		 test	 eax, eax
  0002d	0f 48 c1	 cmovs	 eax, ecx

; 1772 :         int _Result;
; 1773 :         va_list _ArgList;
; 1774 :         __crt_va_start(_ArgList, _Format);
; 1775 : 
; 1776 :         _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);
; 1777 : 
; 1778 :         __crt_va_end(_ArgList);
; 1779 :         return _Result;
; 1780 :     }

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00005	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\Jpegfile.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	c2 00 00	 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\Jpegfile.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

  00000	c2 00 00	 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
