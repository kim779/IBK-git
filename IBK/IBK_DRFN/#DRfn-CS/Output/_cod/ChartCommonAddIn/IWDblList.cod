; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30145.0 

	TITLE	D:\git\src\IBK\IBK_DRFN\#DRfn-CS\_Obj\ChartCommonAddIn\IWDblList.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?Serialize@CObject@@UAEXAAVCArchive@@@Z		; CObject::Serialize
PUBLIC	?AssertValid@CObject@@UBEXXZ			; CObject::AssertValid
PUBLIC	?Dump@CObject@@UBEXAAVCDumpContext@@@Z		; CObject::Dump
PUBLIC	??_R0?AVCObject@@@8				; CObject `RTTI Type Descriptor'
PUBLIC	??_R3CObject@@8					; CObject::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CObject@@8					; CObject::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CObject@@8			; CObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@CPtrList@@8			; CPtrList::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCPtrList@@@8				; CPtrList `RTTI Type Descriptor'
PUBLIC	??_R3CPtrList@@8				; CPtrList::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CPtrList@@8				; CPtrList::`RTTI Base Class Array'
PUBLIC	?m_nObjectCount@CIWDblList@@1JA			; CIWDblList::m_nObjectCount
PUBLIC	??_7?$_CTypedPtrList@VCPtrList@@PAUIDblList@@@@6B@ ; _CTypedPtrList<CPtrList,IDblList *>::`vftable'
PUBLIC	??_G?$_CTypedPtrList@VCPtrList@@PAUIDblList@@@@UAEPAXI@Z ; _CTypedPtrList<CPtrList,IDblList *>::`scalar deleting destructor'
PUBLIC	??_7?$CTypedPtrList@VCPtrList@@PAUIDblList@@@@6B@ ; CTypedPtrList<CPtrList,IDblList *>::`vftable'
PUBLIC	??_G?$CTypedPtrList@VCPtrList@@PAUIDblList@@@@UAEPAXI@Z ; CTypedPtrList<CPtrList,IDblList *>::`scalar deleting destructor'
PUBLIC	??_7CIWrapperManager@CIWDblList@@6B@		; CIWDblList::CIWrapperManager::`vftable'
PUBLIC	??_GCIWrapperManager@CIWDblList@@UAEPAXI@Z	; CIWDblList::CIWrapperManager::`scalar deleting destructor'
PUBLIC	??_R4?$CTypedPtrList@VCPtrList@@PAUIDblList@@@@6B@ ; CTypedPtrList<CPtrList,IDblList *>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CTypedPtrList@VCPtrList@@PAUIDblList@@@@@8 ; CTypedPtrList<CPtrList,IDblList *> `RTTI Type Descriptor'
PUBLIC	??_R3?$CTypedPtrList@VCPtrList@@PAUIDblList@@@@8 ; CTypedPtrList<CPtrList,IDblList *>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CTypedPtrList@VCPtrList@@PAUIDblList@@@@8 ; CTypedPtrList<CPtrList,IDblList *>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CTypedPtrList@VCPtrList@@PAUIDblList@@@@8 ; CTypedPtrList<CPtrList,IDblList *>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@?$_CTypedPtrList@VCPtrList@@PAUIDblList@@@@8 ; _CTypedPtrList<CPtrList,IDblList *>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$_CTypedPtrList@VCPtrList@@PAUIDblList@@@@@8 ; _CTypedPtrList<CPtrList,IDblList *> `RTTI Type Descriptor'
PUBLIC	??_R3?$_CTypedPtrList@VCPtrList@@PAUIDblList@@@@8 ; _CTypedPtrList<CPtrList,IDblList *>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$_CTypedPtrList@VCPtrList@@PAUIDblList@@@@8 ; _CTypedPtrList<CPtrList,IDblList *>::`RTTI Base Class Array'
PUBLIC	??_R4CIWrapperManager@CIWDblList@@6B@		; CIWDblList::CIWrapperManager::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCIWrapperManager@CIWDblList@@@8		; CIWDblList::CIWrapperManager `RTTI Type Descriptor'
PUBLIC	??_R3CIWrapperManager@CIWDblList@@8		; CIWDblList::CIWrapperManager::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CIWrapperManager@CIWDblList@@8		; CIWDblList::CIWrapperManager::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CIWrapperManager@CIWDblList@@8	; CIWDblList::CIWrapperManager::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$_CTypedPtrList@VCPtrList@@PAUIDblList@@@@6B@ ; _CTypedPtrList<CPtrList,IDblList *>::`RTTI Complete Object Locator'
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_E?$_CTypedPtrList@VCPtrList@@PAUIDblList@@@@UAEPAXI@Z:PROC ; _CTypedPtrList<CPtrList,IDblList *>::`vector deleting destructor'
EXTRN	??_E?$CTypedPtrList@VCPtrList@@PAUIDblList@@@@UAEPAXI@Z:PROC ; CTypedPtrList<CPtrList,IDblList *>::`vector deleting destructor'
EXTRN	??_ECIWrapperManager@CIWDblList@@UAEPAXI@Z:PROC	; CIWDblList::CIWrapperManager::`vector deleting destructor'
EXTRN	?GetRuntimeClass@CPtrList@@UBEPAUCRuntimeClass@@XZ:PROC ; CPtrList::GetRuntimeClass
_BSS	SEGMENT
?m_nObjectCount@CIWDblList@@1JA DD 01H DUP (?)		; CIWDblList::m_nObjectCount
_BSS	ENDS
;	COMDAT ??_R4?$_CTypedPtrList@VCPtrList@@PAUIDblList@@@@6B@
rdata$r	SEGMENT
??_R4?$_CTypedPtrList@VCPtrList@@PAUIDblList@@@@6B@ DD 00H ; _CTypedPtrList<CPtrList,IDblList *>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$_CTypedPtrList@VCPtrList@@PAUIDblList@@@@@8
	DD	FLAT:??_R3?$_CTypedPtrList@VCPtrList@@PAUIDblList@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CIWrapperManager@CIWDblList@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CIWrapperManager@CIWDblList@@8 DD FLAT:??_R0?AVCIWrapperManager@CIWDblList@@@8 ; CIWDblList::CIWrapperManager::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CIWrapperManager@CIWDblList@@8
rdata$r	ENDS
;	COMDAT ??_R2CIWrapperManager@CIWDblList@@8
rdata$r	SEGMENT
??_R2CIWrapperManager@CIWDblList@@8 DD FLAT:??_R1A@?0A@EA@CIWrapperManager@CIWDblList@@8 ; CIWDblList::CIWrapperManager::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$CTypedPtrList@VCPtrList@@PAUIDblList@@@@8
	DD	FLAT:??_R1A@?0A@EA@?$_CTypedPtrList@VCPtrList@@PAUIDblList@@@@8
	DD	FLAT:??_R1A@?0A@EA@CPtrList@@8
	DD	FLAT:??_R1A@?0A@EA@CObject@@8
rdata$r	ENDS
;	COMDAT ??_R3CIWrapperManager@CIWDblList@@8
rdata$r	SEGMENT
??_R3CIWrapperManager@CIWDblList@@8 DD 00H		; CIWDblList::CIWrapperManager::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	05H
	DD	FLAT:??_R2CIWrapperManager@CIWDblList@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCIWrapperManager@CIWDblList@@@8
data$rs	SEGMENT
??_R0?AVCIWrapperManager@CIWDblList@@@8 DD FLAT:??_7type_info@@6B@ ; CIWDblList::CIWrapperManager `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCIWrapperManager@CIWDblList@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CIWrapperManager@CIWDblList@@6B@
rdata$r	SEGMENT
??_R4CIWrapperManager@CIWDblList@@6B@ DD 00H		; CIWDblList::CIWrapperManager::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCIWrapperManager@CIWDblList@@@8
	DD	FLAT:??_R3CIWrapperManager@CIWDblList@@8
rdata$r	ENDS
;	COMDAT ??_R2?$_CTypedPtrList@VCPtrList@@PAUIDblList@@@@8
rdata$r	SEGMENT
??_R2?$_CTypedPtrList@VCPtrList@@PAUIDblList@@@@8 DD FLAT:??_R1A@?0A@EA@?$_CTypedPtrList@VCPtrList@@PAUIDblList@@@@8 ; _CTypedPtrList<CPtrList,IDblList *>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CPtrList@@8
	DD	FLAT:??_R1A@?0A@EA@CObject@@8
rdata$r	ENDS
;	COMDAT ??_R3?$_CTypedPtrList@VCPtrList@@PAUIDblList@@@@8
rdata$r	SEGMENT
??_R3?$_CTypedPtrList@VCPtrList@@PAUIDblList@@@@8 DD 00H ; _CTypedPtrList<CPtrList,IDblList *>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2?$_CTypedPtrList@VCPtrList@@PAUIDblList@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$_CTypedPtrList@VCPtrList@@PAUIDblList@@@@@8
data$rs	SEGMENT
??_R0?AV?$_CTypedPtrList@VCPtrList@@PAUIDblList@@@@@8 DD FLAT:??_7type_info@@6B@ ; _CTypedPtrList<CPtrList,IDblList *> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$_CTypedPtrList@VCPtrList@@PAUIDblList@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@?$_CTypedPtrList@VCPtrList@@PAUIDblList@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$_CTypedPtrList@VCPtrList@@PAUIDblList@@@@8 DD FLAT:??_R0?AV?$_CTypedPtrList@VCPtrList@@PAUIDblList@@@@@8 ; _CTypedPtrList<CPtrList,IDblList *>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$_CTypedPtrList@VCPtrList@@PAUIDblList@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CTypedPtrList@VCPtrList@@PAUIDblList@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CTypedPtrList@VCPtrList@@PAUIDblList@@@@8 DD FLAT:??_R0?AV?$CTypedPtrList@VCPtrList@@PAUIDblList@@@@@8 ; CTypedPtrList<CPtrList,IDblList *>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CTypedPtrList@VCPtrList@@PAUIDblList@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CTypedPtrList@VCPtrList@@PAUIDblList@@@@8
rdata$r	SEGMENT
??_R2?$CTypedPtrList@VCPtrList@@PAUIDblList@@@@8 DD FLAT:??_R1A@?0A@EA@?$CTypedPtrList@VCPtrList@@PAUIDblList@@@@8 ; CTypedPtrList<CPtrList,IDblList *>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$_CTypedPtrList@VCPtrList@@PAUIDblList@@@@8
	DD	FLAT:??_R1A@?0A@EA@CPtrList@@8
	DD	FLAT:??_R1A@?0A@EA@CObject@@8
rdata$r	ENDS
;	COMDAT ??_R3?$CTypedPtrList@VCPtrList@@PAUIDblList@@@@8
rdata$r	SEGMENT
??_R3?$CTypedPtrList@VCPtrList@@PAUIDblList@@@@8 DD 00H	; CTypedPtrList<CPtrList,IDblList *>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2?$CTypedPtrList@VCPtrList@@PAUIDblList@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CTypedPtrList@VCPtrList@@PAUIDblList@@@@@8
data$rs	SEGMENT
??_R0?AV?$CTypedPtrList@VCPtrList@@PAUIDblList@@@@@8 DD FLAT:??_7type_info@@6B@ ; CTypedPtrList<CPtrList,IDblList *> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CTypedPtrList@VCPtrList@@PAUIDblList@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CTypedPtrList@VCPtrList@@PAUIDblList@@@@6B@
rdata$r	SEGMENT
??_R4?$CTypedPtrList@VCPtrList@@PAUIDblList@@@@6B@ DD 00H ; CTypedPtrList<CPtrList,IDblList *>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CTypedPtrList@VCPtrList@@PAUIDblList@@@@@8
	DD	FLAT:??_R3?$CTypedPtrList@VCPtrList@@PAUIDblList@@@@8
rdata$r	ENDS
;	COMDAT ??_7CIWrapperManager@CIWDblList@@6B@
CONST	SEGMENT
??_7CIWrapperManager@CIWDblList@@6B@ DD FLAT:??_R4CIWrapperManager@CIWDblList@@6B@ ; CIWDblList::CIWrapperManager::`vftable'
	DD	FLAT:?GetRuntimeClass@CPtrList@@UBEPAUCRuntimeClass@@XZ
	DD	FLAT:??_ECIWrapperManager@CIWDblList@@UAEPAXI@Z
	DD	FLAT:?Serialize@CObject@@UAEXAAVCArchive@@@Z
	DD	FLAT:?AssertValid@CObject@@UBEXXZ
	DD	FLAT:?Dump@CObject@@UBEXAAVCDumpContext@@@Z
CONST	ENDS
;	COMDAT ??_7?$CTypedPtrList@VCPtrList@@PAUIDblList@@@@6B@
CONST	SEGMENT
??_7?$CTypedPtrList@VCPtrList@@PAUIDblList@@@@6B@ DD FLAT:??_R4?$CTypedPtrList@VCPtrList@@PAUIDblList@@@@6B@ ; CTypedPtrList<CPtrList,IDblList *>::`vftable'
	DD	FLAT:?GetRuntimeClass@CPtrList@@UBEPAUCRuntimeClass@@XZ
	DD	FLAT:??_E?$CTypedPtrList@VCPtrList@@PAUIDblList@@@@UAEPAXI@Z
	DD	FLAT:?Serialize@CObject@@UAEXAAVCArchive@@@Z
	DD	FLAT:?AssertValid@CObject@@UBEXXZ
	DD	FLAT:?Dump@CObject@@UBEXAAVCDumpContext@@@Z
CONST	ENDS
;	COMDAT ??_7?$_CTypedPtrList@VCPtrList@@PAUIDblList@@@@6B@
CONST	SEGMENT
??_7?$_CTypedPtrList@VCPtrList@@PAUIDblList@@@@6B@ DD FLAT:??_R4?$_CTypedPtrList@VCPtrList@@PAUIDblList@@@@6B@ ; _CTypedPtrList<CPtrList,IDblList *>::`vftable'
	DD	FLAT:?GetRuntimeClass@CPtrList@@UBEPAUCRuntimeClass@@XZ
	DD	FLAT:??_E?$_CTypedPtrList@VCPtrList@@PAUIDblList@@@@UAEPAXI@Z
	DD	FLAT:?Serialize@CObject@@UAEXAAVCArchive@@@Z
	DD	FLAT:?AssertValid@CObject@@UBEXXZ
	DD	FLAT:?Dump@CObject@@UBEXAAVCDumpContext@@@Z
CONST	ENDS
;	COMDAT ??_R2CPtrList@@8
rdata$r	SEGMENT
??_R2CPtrList@@8 DD FLAT:??_R1A@?0A@EA@CPtrList@@8	; CPtrList::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CObject@@8
rdata$r	ENDS
;	COMDAT ??_R3CPtrList@@8
rdata$r	SEGMENT
??_R3CPtrList@@8 DD 00H					; CPtrList::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CPtrList@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCPtrList@@@8
data$rs	SEGMENT
??_R0?AVCPtrList@@@8 DD FLAT:??_7type_info@@6B@		; CPtrList `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCPtrList@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@CPtrList@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CPtrList@@8 DD FLAT:??_R0?AVCPtrList@@@8	; CPtrList::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CPtrList@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CObject@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CObject@@8 DD FLAT:??_R0?AVCObject@@@8	; CObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CObject@@8
rdata$r	ENDS
;	COMDAT ??_R2CObject@@8
rdata$r	SEGMENT
??_R2CObject@@8 DD FLAT:??_R1A@?0A@EA@CObject@@8	; CObject::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CObject@@8
rdata$r	SEGMENT
??_R3CObject@@8 DD 00H					; CObject::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CObject@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCObject@@@8
data$rs	SEGMENT
??_R0?AVCObject@@@8 DD FLAT:??_7type_info@@6B@		; CObject `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCObject@@', 00H
data$rs	ENDS
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	??1CIWrapperManager@CIWDblList@@UAE@XZ		; CIWDblList::CIWrapperManager::~CIWrapperManager
PUBLIC	?GetCount@CIWDblList@@MBEHXZ			; CIWDblList::GetCount
PUBLIC	?IsEmpty@CIWDblList@@MBEHXZ			; CIWDblList::IsEmpty
PUBLIC	?GetHead@CIWDblList@@MBEHAAN@Z			; CIWDblList::GetHead
PUBLIC	?GetTail@CIWDblList@@MBEHAAN@Z			; CIWDblList::GetTail
PUBLIC	?RemoveHead@CIWDblList@@MAEHAAN@Z		; CIWDblList::RemoveHead
PUBLIC	?RemoveTail@CIWDblList@@MAEHAAN@Z		; CIWDblList::RemoveTail
PUBLIC	?AddHead@CIWDblList@@MAEPAU__POSITION@@N@Z	; CIWDblList::AddHead
PUBLIC	?AddTail@CIWDblList@@MAEPAU__POSITION@@N@Z	; CIWDblList::AddTail
PUBLIC	?RemoveAll@CIWDblList@@MAEXXZ			; CIWDblList::RemoveAll
PUBLIC	?GetHeadPosition@CIWDblList@@MBEPAU__POSITION@@XZ ; CIWDblList::GetHeadPosition
PUBLIC	?GetTailPosition@CIWDblList@@MBEPAU__POSITION@@XZ ; CIWDblList::GetTailPosition
PUBLIC	?GetNext@CIWDblList@@MBEHAAPAU__POSITION@@AAN@Z	; CIWDblList::GetNext
PUBLIC	?GetPrev@CIWDblList@@MBEHAAPAU__POSITION@@AAN@Z	; CIWDblList::GetPrev
PUBLIC	?GetAt@CIWDblList@@MBEHPAU__POSITION@@AAN@Z	; CIWDblList::GetAt
PUBLIC	?SetAt@CIWDblList@@MAEXPAU__POSITION@@N@Z	; CIWDblList::SetAt
PUBLIC	?RemoveAt@CIWDblList@@MAEXPAU__POSITION@@@Z	; CIWDblList::RemoveAt
PUBLIC	?InsertBefore@CIWDblList@@MAEPAU__POSITION@@PAU2@N@Z ; CIWDblList::InsertBefore
PUBLIC	?InsertAfter@CIWDblList@@MAEPAU__POSITION@@PAU2@N@Z ; CIWDblList::InsertAfter
PUBLIC	?Find@CIWDblList@@MBEPAU__POSITION@@NPAU2@@Z	; CIWDblList::Find
PUBLIC	?FindIndex@CIWDblList@@MBEPAU__POSITION@@H@Z	; CIWDblList::FindIndex
PUBLIC	?RemoveHead@?$CList@NN@@QAENXZ			; CList<double,double>::RemoveHead
PUBLIC	?RemoveTail@?$CList@NN@@QAENXZ			; CList<double,double>::RemoveTail
PUBLIC	?AddHead@?$CList@NN@@QAEPAU__POSITION@@N@Z	; CList<double,double>::AddHead
PUBLIC	?AddTail@?$CList@NN@@QAEPAU__POSITION@@N@Z	; CList<double,double>::AddTail
PUBLIC	?RemoveAll@?$CList@NN@@QAEXXZ			; CList<double,double>::RemoveAll
PUBLIC	?RemoveAt@?$CList@NN@@QAEXPAU__POSITION@@@Z	; CList<double,double>::RemoveAt
PUBLIC	?InsertBefore@?$CList@NN@@QAEPAU__POSITION@@PAU2@N@Z ; CList<double,double>::InsertBefore
PUBLIC	?InsertAfter@?$CList@NN@@QAEPAU__POSITION@@PAU2@N@Z ; CList<double,double>::InsertAfter
PUBLIC	?Find@?$CList@NN@@QBEPAU__POSITION@@NPAU2@@Z	; CList<double,double>::Find
PUBLIC	?FindIndex@?$CList@NN@@QBEPAU__POSITION@@H@Z	; CList<double,double>::FindIndex
PUBLIC	?NewNode@?$CList@NN@@IAEPAUCNode@1@PAU21@0@Z	; CList<double,double>::NewNode
PUBLIC	?FreeNode@?$CList@NN@@IAEXPAUCNode@1@@Z		; CList<double,double>::FreeNode
PUBLIC	??$CompareElements@NN@@YGHPBN0@Z		; CompareElements<double,double>
PUBLIC	?m_lReleaseMgr@CIWDblList@@1VCIWrapperManager@1@A ; CIWDblList::m_lReleaseMgr
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	?__global_delete@@YAXPAXI@Z:PROC		; __global_delete
EXTRN	_atexit:PROC
EXTRN	?AfxThrowInvalidArgException@@YGXXZ:PROC	; AfxThrowInvalidArgException
EXTRN	??0CPtrList@@QAE@H@Z:PROC			; CPtrList::CPtrList
EXTRN	?RemoveHead@CPtrList@@QAEPAXXZ:PROC		; CPtrList::RemoveHead
EXTRN	??1CPtrList@@UAE@XZ:PROC			; CPtrList::~CPtrList
EXTRN	?Create@CPlex@@SGPAU1@AAPAU1@II@Z:PROC		; CPlex::Create
EXTRN	?FreeDataChain@CPlex@@QAEXXZ:PROC		; CPlex::FreeDataChain
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
?m_lReleaseMgr@CIWDblList@@1VCIWrapperManager@1@A DB 01cH DUP (?) ; CIWDblList::m_lReleaseMgr
_BSS	ENDS
CRT$XCU	SEGMENT
??m_lReleaseMgr$initializer$@CIWDblList@@1P6AXXZA@@3P6AXXZA DD FLAT:??__E?m_lReleaseMgr@CIWDblList@@1VCIWrapperManager@1@A@@YAXXZ ; ??m_lReleaseMgr$initializer$@CIWDblList@@1P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CIWrapperManager@CIWDblList@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ??$CompareElements@NN@@YGHPBN0@Z
_TEXT	SEGMENT
_pElement1$ = 8						; size = 4
_pElement2$ = 12					; size = 4
??$CompareElements@NN@@YGHPBN0@Z PROC			; CompareElements<double,double>, COMDAT

; 151  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 152  : 	ENSURE(pElement1 != NULL && pElement2 != NULL);

  00003	8b 45 08	 mov	 eax, DWORD PTR _pElement1$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 23		 je	 SHORT $LN7@CompareEle
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR _pElement2$[ebp]
  0000d	85 c9		 test	 ecx, ecx
  0000f	74 1c		 je	 SHORT $LN7@CompareEle

; 153  : 	ASSERT(AfxIsValidAddress(pElement1, sizeof(TYPE), FALSE));
; 154  : 	ASSERT(AfxIsValidAddress(pElement2, sizeof(ARG_TYPE), FALSE));
; 155  : 
; 156  : 	return *pElement1 == *pElement2;

  00011	f2 0f 10 00	 movsd	 xmm0, QWORD PTR [eax]
  00015	ba 01 00 00 00	 mov	 edx, 1
  0001a	66 0f 2e 01	 ucomisd xmm0, QWORD PTR [ecx]
  0001e	9f		 lahf
  0001f	33 c9		 xor	 ecx, ecx
  00021	f6 c4 44	 test	 ah, 68			; 00000044H
  00024	0f 4b ca	 cmovnp	 ecx, edx
  00027	8b c1		 mov	 eax, ecx

; 157  : }

  00029	5d		 pop	 ebp
  0002a	c2 08 00	 ret	 8
$LN7@CompareEle:

; 152  : 	ENSURE(pElement1 != NULL && pElement2 != NULL);

  0002d	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN12@CompareEle:
  00032	cc		 int	 3
??$CompareElements@NN@@YGHPBN0@Z ENDP			; CompareElements<double,double>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__F?m_lReleaseMgr@CIWDblList@@1VCIWrapperManager@1@A@@YAXXZ
text$yd	SEGMENT
??__F?m_lReleaseMgr@CIWDblList@@1VCIWrapperManager@1@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CIWDblList::m_lReleaseMgr'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?m_lReleaseMgr@CIWDblList@@1VCIWrapperManager@1@A ; CIWDblList::m_lReleaseMgr
  00005	e9 00 00 00 00	 jmp	 ??1CIWrapperManager@CIWDblList@@UAE@XZ ; CIWDblList::CIWrapperManager::~CIWrapperManager
??__F?m_lReleaseMgr@CIWDblList@@1VCIWrapperManager@1@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CIWDblList::m_lReleaseMgr''
text$yd	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\IWDblList.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\IWDblList.cpp
;	COMDAT ??__E?m_lReleaseMgr@CIWDblList@@1VCIWrapperManager@1@A@@YAXXZ
text$di	SEGMENT
??__E?m_lReleaseMgr@CIWDblList@@1VCIWrapperManager@1@A@@YAXXZ PROC ; `dynamic initializer for 'CIWDblList::m_lReleaseMgr'', COMDAT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 1876 : 		: BASE_CLASS(nBlockSize) { }

  00000	6a 0a		 push	 10			; 0000000aH
  00002	b9 00 00 00 00	 mov	 ecx, OFFSET ?m_lReleaseMgr@CIWDblList@@1VCIWrapperManager@1@A ; CIWDblList::m_lReleaseMgr
  00007	e8 00 00 00 00	 call	 ??0CPtrList@@QAE@H@Z	; CPtrList::CPtrList
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\IWDblList.cpp

; 17   : _IWRAPPER_IUNKNOWN_MANAGER_IMP( CIWDblList)

  0000c	68 00 00 00 00	 push	 OFFSET ??__F?m_lReleaseMgr@CIWDblList@@1VCIWrapperManager@1@A@@YAXXZ ; `dynamic atexit destructor for 'CIWDblList::m_lReleaseMgr''
  00011	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?m_lReleaseMgr@CIWDblList@@1VCIWrapperManager@1@A, OFFSET ??_7CIWrapperManager@CIWDblList@@6B@
  0001b	e8 00 00 00 00	 call	 _atexit
  00020	59		 pop	 ecx
  00021	c3		 ret	 0
??__E?m_lReleaseMgr@CIWDblList@@1VCIWrapperManager@1@A@@YAXXZ ENDP ; `dynamic initializer for 'CIWDblList::m_lReleaseMgr''
text$di	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ?FreeNode@?$CList@NN@@IAEXPAUCNode@1@@Z
_TEXT	SEGMENT
_pNode$ = 8						; size = 4
?FreeNode@?$CList@NN@@IAEXPAUCNode@1@@Z PROC		; CList<double,double>::FreeNode, COMDAT
; _this$ = ecx

; 936  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 937  : 	pNode->data.~TYPE();
; 938  : 	pNode->pNext = m_pNodeFree;

  00003	8b 55 08	 mov	 edx, DWORD PTR _pNode$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0000c	89 02		 mov	 DWORD PTR [edx], eax

; 939  : 	m_pNodeFree = pNode;
; 940  : 	m_nCount--;

  0000e	83 46 0c ff	 add	 DWORD PTR [esi+12], -1
  00012	89 56 10	 mov	 DWORD PTR [esi+16], edx

; 941  : 	ASSERT(m_nCount >= 0);  // make sure we don't underflow
; 942  : 
; 943  : 	// if no more elements, cleanup completely
; 944  : 	if (m_nCount == 0)

  00015	75 2b		 jne	 SHORT $LN2@FreeNode

; 872  : 	m_pBlocks->FreeDataChain();

  00017	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  0001a	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  00021	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00028	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  0002f	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00036	e8 00 00 00 00	 call	 ?FreeDataChain@CPlex@@QAEXXZ ; CPlex::FreeDataChain

; 873  : 	m_pBlocks = NULL;

  0003b	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
$LN2@FreeNode:
  00042	5e		 pop	 esi

; 945  : 		RemoveAll();
; 946  : }

  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
?FreeNode@?$CList@NN@@IAEXPAUCNode@1@@Z ENDP		; CList<double,double>::FreeNode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ?NewNode@?$CList@NN@@IAEPAUCNode@1@PAU21@0@Z
_TEXT	SEGMENT
_pPrev$ = 8						; size = 4
_pNext$ = 12						; size = 4
?NewNode@?$CList@NN@@IAEPAUCNode@1@PAU21@0@Z PROC	; CList<double,double>::NewNode, COMDAT
; _this$ = ecx

; 901  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 902  : 	if (m_pNodeFree == NULL)

  00006	83 7e 10 00	 cmp	 DWORD PTR [esi+16], 0
  0000a	75 34		 jne	 SHORT $LN7@NewNode

; 903  : 	{
; 904  : 		// add another block
; 905  : 		CPlex* pNewBlock = CPlex::Create(m_pBlocks, m_nBlockSize,

  0000c	6a 10		 push	 16			; 00000010H
  0000e	ff 76 18	 push	 DWORD PTR [esi+24]
  00011	8d 46 14	 lea	 eax, DWORD PTR [esi+20]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ?Create@CPlex@@SGPAU1@AAPAU1@II@Z ; CPlex::Create

; 906  : 				 sizeof(CNode));
; 907  : 
; 908  : 		// chain them into free list
; 909  : 		CNode* pNode = (CNode*) pNewBlock->data();
; 910  : 		// free in reverse order to make it easier to debug
; 911  : 		pNode += m_nBlockSize - 1;

  0001a	8b 56 18	 mov	 edx, DWORD PTR [esi+24]
  0001d	83 c0 08	 add	 eax, 8
  00020	8b ca		 mov	 ecx, edx
  00022	c1 e1 04	 shl	 ecx, 4
  00025	83 c1 f0	 add	 ecx, -16		; fffffff0H
  00028	03 c1		 add	 eax, ecx

; 912  : 		for (INT_PTR i = m_nBlockSize-1; i >= 0; i--, pNode--)

  0002a	83 c2 ff	 add	 edx, -1
  0002d	78 11		 js	 SHORT $LN7@NewNode
  0002f	90		 npad	 1
$LL4@NewNode:

; 913  : 		{
; 914  : 			pNode->pNext = m_pNodeFree;

  00030	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00033	89 08		 mov	 DWORD PTR [eax], ecx

; 915  : 			m_pNodeFree = pNode;

  00035	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00038	83 e8 10	 sub	 eax, 16			; 00000010H
  0003b	83 ea 01	 sub	 edx, 1
  0003e	79 f0		 jns	 SHORT $LL4@NewNode
$LN7@NewNode:

; 916  : 		}
; 917  : 	}
; 918  : 	ENSURE(m_pNodeFree != NULL);  // we must have something

  00040	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00043	85 c0		 test	 eax, eax
  00045	74 18		 je	 SHORT $LN17@NewNode

; 919  : 
; 920  : 	CList::CNode* pNode = m_pNodeFree;
; 921  : 	m_pNodeFree = m_pNodeFree->pNext;

  00047	8b 08		 mov	 ecx, DWORD PTR [eax]
  00049	89 4e 10	 mov	 DWORD PTR [esi+16], ecx

; 922  : 	pNode->pPrev = pPrev;

  0004c	8b 4d 08	 mov	 ecx, DWORD PTR _pPrev$[ebp]
  0004f	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 923  : 	pNode->pNext = pNext;

  00052	8b 4d 0c	 mov	 ecx, DWORD PTR _pNext$[ebp]
  00055	89 08		 mov	 DWORD PTR [eax], ecx

; 924  : 	m_nCount++;

  00057	ff 46 0c	 inc	 DWORD PTR [esi+12]

; 925  : 	ASSERT(m_nCount > 0);  // make sure we don't overflow
; 926  : 
; 927  : #pragma push_macro("new")
; 928  : #undef new
; 929  : 	::new( (void*)( &pNode->data ) ) TYPE;
; 930  : #pragma pop_macro("new")
; 931  : 	return pNode;

  0005a	5e		 pop	 esi

; 932  : }

  0005b	5d		 pop	 ebp
  0005c	c2 08 00	 ret	 8
$LN17@NewNode:

; 916  : 		}
; 917  : 	}
; 918  : 	ENSURE(m_pNodeFree != NULL);  // we must have something

  0005f	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN15@NewNode:
  00064	cc		 int	 3
?NewNode@?$CList@NN@@IAEPAUCNode@1@PAU21@0@Z ENDP	; CList<double,double>::NewNode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ?FindIndex@?$CList@NN@@QBEPAU__POSITION@@H@Z
_TEXT	SEGMENT
_nIndex$ = 8						; size = 4
?FindIndex@?$CList@NN@@QBEPAU__POSITION@@H@Z PROC	; CList<double,double>::FindIndex, COMDAT
; _this$ = ecx

; 1130 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1131 : 	ASSERT_VALID(this);
; 1132 : 
; 1133 : 	if (nIndex >= m_nCount || nIndex < 0)

  00003	8b 55 08	 mov	 edx, DWORD PTR _nIndex$[ebp]
  00006	3b 51 0c	 cmp	 edx, DWORD PTR [ecx+12]
  00009	7d 14		 jge	 SHORT $LN5@FindIndex
  0000b	85 d2		 test	 edx, edx
  0000d	78 10		 js	 SHORT $LN5@FindIndex

; 1135 : 
; 1136 : 	CNode* pNode = m_pNodeHead;

  0000f	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 1137 : 	while (nIndex--)

  00012	74 0d		 je	 SHORT $LN1@FindIndex
$LL2@FindIndex:

; 1138 : 	{
; 1139 : 		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 1140 : 		pNode = pNode->pNext;

  00014	8b 00		 mov	 eax, DWORD PTR [eax]
  00016	83 ea 01	 sub	 edx, 1
  00019	75 f9		 jne	 SHORT $LL2@FindIndex

; 1141 : 	}
; 1142 : 	return (POSITION) pNode;
; 1143 : }

  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
$LN5@FindIndex:

; 1134 : 		return NULL;  // went too far

  0001f	33 c0		 xor	 eax, eax
$LN1@FindIndex:

; 1141 : 	}
; 1142 : 	return (POSITION) pNode;
; 1143 : }

  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
?FindIndex@?$CList@NN@@QBEPAU__POSITION@@H@Z ENDP	; CList<double,double>::FindIndex
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ?Find@?$CList@NN@@QBEPAU__POSITION@@NPAU2@@Z
_TEXT	SEGMENT
_searchValue$ = 8					; size = 8
_startAfter$ = 16					; size = 4
?Find@?$CList@NN@@QBEPAU__POSITION@@NPAU2@@Z PROC	; CList<double,double>::Find, COMDAT
; _this$ = ecx

; 1147 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 10	 mov	 ecx, DWORD PTR _startAfter$[ebp]

; 1148 : 	ASSERT_VALID(this);
; 1149 : 
; 1150 : 	CNode* pNode = (CNode*) startAfter;
; 1151 : 	if (pNode == NULL)

  00008	85 c9		 test	 ecx, ecx
  0000a	75 03		 jne	 SHORT $LN5@Find

; 1152 : 	{
; 1153 : 		pNode = m_pNodeHead;  // start at head

  0000c	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
$LN5@Find:

; 1154 : 	}
; 1155 : 	else
; 1156 : 	{
; 1157 : 		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 1158 : 		pNode = pNode->pNext;  // start after the one specified
; 1159 : 	}
; 1160 : 
; 1161 : 	for (; pNode != NULL; pNode = pNode->pNext)

  0000f	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00011	85 c9		 test	 ecx, ecx
  00013	74 26		 je	 SHORT $LN3@Find
  00015	f2 0f 10 4d 08	 movsd	 xmm1, QWORD PTR _searchValue$[ebp]
  0001a	66 0f 1f 44 00
	00		 npad	 6
$LL4@Find:

; 1162 : 		if (CompareElements<TYPE>(&pNode->data, &searchValue))

  00020	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]

; 152  : 	ENSURE(pElement1 != NULL && pElement2 != NULL);

  00023	85 c0		 test	 eax, eax
  00025	74 20		 je	 SHORT $LN21@Find

; 153  : 	ASSERT(AfxIsValidAddress(pElement1, sizeof(TYPE), FALSE));
; 154  : 	ASSERT(AfxIsValidAddress(pElement2, sizeof(ARG_TYPE), FALSE));
; 155  : 
; 156  : 	return *pElement1 == *pElement2;

  00027	f2 0f 10 00	 movsd	 xmm0, QWORD PTR [eax]
  0002b	66 0f 2e c1	 ucomisd xmm0, xmm1
  0002f	9f		 lahf
  00030	f6 c4 44	 test	 ah, 68			; 00000044H
  00033	7b 0c		 jnp	 SHORT $LN22@Find

; 1154 : 	}
; 1155 : 	else
; 1156 : 	{
; 1157 : 		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 1158 : 		pNode = pNode->pNext;  // start after the one specified
; 1159 : 	}
; 1160 : 
; 1161 : 	for (; pNode != NULL; pNode = pNode->pNext)

  00035	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00037	85 c9		 test	 ecx, ecx
  00039	75 e5		 jne	 SHORT $LL4@Find
$LN3@Find:

; 1164 : 	return NULL;

  0003b	33 c0		 xor	 eax, eax

; 1165 : }

  0003d	5d		 pop	 ebp
  0003e	c2 0c 00	 ret	 12			; 0000000cH
$LN22@Find:

; 1163 : 			return (POSITION)pNode;

  00041	8b c1		 mov	 eax, ecx

; 1165 : }

  00043	5d		 pop	 ebp
  00044	c2 0c 00	 ret	 12			; 0000000cH
$LN21@Find:

; 152  : 	ENSURE(pElement1 != NULL && pElement2 != NULL);

  00047	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN30@Find:
  0004c	cc		 int	 3
?Find@?$CList@NN@@QBEPAU__POSITION@@NPAU2@@Z ENDP	; CList<double,double>::Find
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ?InsertAfter@?$CList@NN@@QAEPAU__POSITION@@PAU2@N@Z
_TEXT	SEGMENT
_position$ = 8						; size = 4
_newElement$ = 12					; size = 8
?InsertAfter@?$CList@NN@@QAEPAU__POSITION@@PAU2@N@Z PROC ; CList<double,double>::InsertAfter, COMDAT
; _this$ = ecx

; 1072 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 1073 : 	ASSERT_VALID(this);
; 1074 : 
; 1075 : 	if (position == NULL)

  00005	8b 7d 08	 mov	 edi, DWORD PTR _position$[ebp]
  00008	8b f1		 mov	 esi, ecx
  0000a	85 ff		 test	 edi, edi
  0000c	75 31		 jne	 SHORT $LN2@InsertAfte

; 968  : 	CNode* pNewNode = NewNode(m_pNodeTail, NULL);

  0000e	57		 push	 edi
  0000f	ff 76 08	 push	 DWORD PTR [esi+8]
  00012	e8 00 00 00 00	 call	 ?NewNode@?$CList@NN@@IAEPAUCNode@1@PAU21@0@Z ; CList<double,double>::NewNode

; 969  : 	pNewNode->data = newElement;

  00017	f2 0f 10 45 0c	 movsd	 xmm0, QWORD PTR _newElement$[ebp]
  0001c	f2 0f 11 40 08	 movsd	 QWORD PTR [eax+8], xmm0

; 970  : 	if (m_pNodeTail != NULL)

  00021	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00024	85 c9		 test	 ecx, ecx
  00026	74 0b		 je	 SHORT $LN7@InsertAfte

; 971  : 		m_pNodeTail->pNext = pNewNode;

  00028	89 01		 mov	 DWORD PTR [ecx], eax
  0002a	5f		 pop	 edi

; 974  : 	m_pNodeTail = pNewNode;

  0002b	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 1095 : 	return (POSITION) pNewNode;
; 1096 : }

  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 0c 00	 ret	 12			; 0000000cH
$LN7@InsertAfte:
  00033	5f		 pop	 edi

; 973  : 		m_pNodeHead = pNewNode;

  00034	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 974  : 	m_pNodeTail = pNewNode;

  00037	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 1095 : 	return (POSITION) pNewNode;
; 1096 : }

  0003a	5e		 pop	 esi
  0003b	5d		 pop	 ebp
  0003c	c2 0c 00	 ret	 12			; 0000000cH
$LN2@InsertAfte:

; 1076 : 		return AddTail(newElement); // insert after nothing -> tail of the list
; 1077 : 
; 1078 : 	// Insert it before position
; 1079 : 	CNode* pOldNode = (CNode*) position;
; 1080 : 	ASSERT(AfxIsValidAddress(pOldNode, sizeof(CNode)));
; 1081 : 	CNode* pNewNode = NewNode(pOldNode, pOldNode->pNext);

  0003f	ff 37		 push	 DWORD PTR [edi]
  00041	57		 push	 edi
  00042	e8 00 00 00 00	 call	 ?NewNode@?$CList@NN@@IAEPAUCNode@1@PAU21@0@Z ; CList<double,double>::NewNode

; 1082 : 	pNewNode->data = newElement;

  00047	f2 0f 10 45 0c	 movsd	 xmm0, QWORD PTR _newElement$[ebp]
  0004c	f2 0f 11 40 08	 movsd	 QWORD PTR [eax+8], xmm0

; 1083 : 
; 1084 : 	if (pOldNode->pNext != NULL)

  00051	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00053	85 c9		 test	 ecx, ecx
  00055	74 0b		 je	 SHORT $LN3@InsertAfte

; 1085 : 	{
; 1086 : 		ASSERT(AfxIsValidAddress(pOldNode->pNext, sizeof(CNode)));
; 1087 : 		pOldNode->pNext->pPrev = pNewNode;

  00057	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1093 : 	}
; 1094 : 	pOldNode->pNext = pNewNode;

  0005a	89 07		 mov	 DWORD PTR [edi], eax
  0005c	5f		 pop	 edi

; 1095 : 	return (POSITION) pNewNode;
; 1096 : }

  0005d	5e		 pop	 esi
  0005e	5d		 pop	 ebp
  0005f	c2 0c 00	 ret	 12			; 0000000cH
$LN3@InsertAfte:

; 1088 : 	}
; 1089 : 	else
; 1090 : 	{
; 1091 : 		ASSERT(pOldNode == m_pNodeTail);
; 1092 : 		m_pNodeTail = pNewNode;

  00062	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 1093 : 	}
; 1094 : 	pOldNode->pNext = pNewNode;

  00065	89 07		 mov	 DWORD PTR [edi], eax
  00067	5f		 pop	 edi

; 1095 : 	return (POSITION) pNewNode;
; 1096 : }

  00068	5e		 pop	 esi
  00069	5d		 pop	 ebp
  0006a	c2 0c 00	 ret	 12			; 0000000cH
?InsertAfter@?$CList@NN@@QAEPAU__POSITION@@PAU2@N@Z ENDP ; CList<double,double>::InsertAfter
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ?InsertBefore@?$CList@NN@@QAEPAU__POSITION@@PAU2@N@Z
_TEXT	SEGMENT
_position$ = 8						; size = 4
_newElement$ = 12					; size = 8
?InsertBefore@?$CList@NN@@QAEPAU__POSITION@@PAU2@N@Z PROC ; CList<double,double>::InsertBefore, COMDAT
; _this$ = ecx

; 1045 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 1046 : 	ASSERT_VALID(this);
; 1047 : 
; 1048 : 	if (position == NULL)

  00005	8b 7d 08	 mov	 edi, DWORD PTR _position$[ebp]
  00008	8b f1		 mov	 esi, ecx
  0000a	85 ff		 test	 edi, edi
  0000c	75 32		 jne	 SHORT $LN2@InsertBefo

; 953  : 	CNode* pNewNode = NewNode(NULL, m_pNodeHead);

  0000e	ff 76 04	 push	 DWORD PTR [esi+4]
  00011	57		 push	 edi
  00012	e8 00 00 00 00	 call	 ?NewNode@?$CList@NN@@IAEPAUCNode@1@PAU21@0@Z ; CList<double,double>::NewNode

; 954  : 	pNewNode->data = newElement;

  00017	f2 0f 10 45 0c	 movsd	 xmm0, QWORD PTR _newElement$[ebp]
  0001c	f2 0f 11 40 08	 movsd	 QWORD PTR [eax+8], xmm0

; 955  : 	if (m_pNodeHead != NULL)

  00021	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00024	85 c9		 test	 ecx, ecx
  00026	74 0c		 je	 SHORT $LN7@InsertBefo

; 956  : 		m_pNodeHead->pPrev = pNewNode;

  00028	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0002b	5f		 pop	 edi

; 959  : 	m_pNodeHead = pNewNode;

  0002c	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 1067 : 	return (POSITION) pNewNode;
; 1068 : }

  0002f	5e		 pop	 esi
  00030	5d		 pop	 ebp
  00031	c2 0c 00	 ret	 12			; 0000000cH
$LN7@InsertBefo:
  00034	5f		 pop	 edi

; 958  : 		m_pNodeTail = pNewNode;

  00035	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 959  : 	m_pNodeHead = pNewNode;

  00038	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 1067 : 	return (POSITION) pNewNode;
; 1068 : }

  0003b	5e		 pop	 esi
  0003c	5d		 pop	 ebp
  0003d	c2 0c 00	 ret	 12			; 0000000cH
$LN2@InsertBefo:

; 1049 : 		return AddHead(newElement); // insert before nothing -> head of the list
; 1050 : 
; 1051 : 	// Insert it before position
; 1052 : 	CNode* pOldNode = (CNode*) position;
; 1053 : 	CNode* pNewNode = NewNode(pOldNode->pPrev, pOldNode);

  00040	57		 push	 edi
  00041	ff 77 04	 push	 DWORD PTR [edi+4]
  00044	e8 00 00 00 00	 call	 ?NewNode@?$CList@NN@@IAEPAUCNode@1@PAU21@0@Z ; CList<double,double>::NewNode

; 1054 : 	pNewNode->data = newElement;

  00049	f2 0f 10 45 0c	 movsd	 xmm0, QWORD PTR _newElement$[ebp]
  0004e	f2 0f 11 40 08	 movsd	 QWORD PTR [eax+8], xmm0

; 1055 : 
; 1056 : 	if (pOldNode->pPrev != NULL)

  00053	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00056	85 c9		 test	 ecx, ecx
  00058	74 0b		 je	 SHORT $LN3@InsertBefo

; 1057 : 	{
; 1058 : 		ASSERT(AfxIsValidAddress(pOldNode->pPrev, sizeof(CNode)));
; 1059 : 		pOldNode->pPrev->pNext = pNewNode;

  0005a	89 01		 mov	 DWORD PTR [ecx], eax

; 1065 : 	}
; 1066 : 	pOldNode->pPrev = pNewNode;

  0005c	89 47 04	 mov	 DWORD PTR [edi+4], eax
  0005f	5f		 pop	 edi

; 1067 : 	return (POSITION) pNewNode;
; 1068 : }

  00060	5e		 pop	 esi
  00061	5d		 pop	 ebp
  00062	c2 0c 00	 ret	 12			; 0000000cH
$LN3@InsertBefo:

; 1060 : 	}
; 1061 : 	else
; 1062 : 	{
; 1063 : 		ASSERT(pOldNode == m_pNodeHead);
; 1064 : 		m_pNodeHead = pNewNode;

  00065	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 1065 : 	}
; 1066 : 	pOldNode->pPrev = pNewNode;

  00068	89 47 04	 mov	 DWORD PTR [edi+4], eax
  0006b	5f		 pop	 edi

; 1067 : 	return (POSITION) pNewNode;
; 1068 : }

  0006c	5e		 pop	 esi
  0006d	5d		 pop	 ebp
  0006e	c2 0c 00	 ret	 12			; 0000000cH
?InsertBefore@?$CList@NN@@QAEPAU__POSITION@@PAU2@N@Z ENDP ; CList<double,double>::InsertBefore
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ?RemoveAt@?$CList@NN@@QAEXPAU__POSITION@@@Z
_TEXT	SEGMENT
_position$ = 8						; size = 4
?RemoveAt@?$CList@NN@@QAEXPAU__POSITION@@@Z PROC	; CList<double,double>::RemoveAt, COMDAT
; _this$ = ecx

; 1100 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 1101 : 	ASSERT_VALID(this);
; 1102 : 
; 1103 : 	CNode* pOldNode = (CNode*) position;
; 1104 : 	ASSERT(AfxIsValidAddress(pOldNode, sizeof(CNode)));
; 1105 : 
; 1106 : 	// remove pOldNode from list
; 1107 : 	if (pOldNode == m_pNodeHead)

  00006	8b 4d 08	 mov	 ecx, DWORD PTR _position$[ebp]
  00009	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000b	3b 4e 04	 cmp	 ecx, DWORD PTR [esi+4]
  0000e	75 05		 jne	 SHORT $LN2@RemoveAt

; 1108 : 	{
; 1109 : 		m_pNodeHead = pOldNode->pNext;

  00010	89 56 04	 mov	 DWORD PTR [esi+4], edx

; 1110 : 	}

  00013	eb 05		 jmp	 SHORT $LN3@RemoveAt
$LN2@RemoveAt:

; 1111 : 	else
; 1112 : 	{
; 1113 : 		ASSERT(AfxIsValidAddress(pOldNode->pPrev, sizeof(CNode)));
; 1114 : 		pOldNode->pPrev->pNext = pOldNode->pNext;

  00015	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00018	89 10		 mov	 DWORD PTR [eax], edx
$LN3@RemoveAt:

; 1115 : 	}
; 1116 : 	if (pOldNode == m_pNodeTail)

  0001a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0001d	3b 4e 08	 cmp	 ecx, DWORD PTR [esi+8]
  00020	75 05		 jne	 SHORT $LN4@RemoveAt

; 1117 : 	{
; 1118 : 		m_pNodeTail = pOldNode->pPrev;

  00022	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 1119 : 	}

  00025	eb 05		 jmp	 SHORT $LN5@RemoveAt
$LN4@RemoveAt:

; 1120 : 	else
; 1121 : 	{
; 1122 : 		ASSERT(AfxIsValidAddress(pOldNode->pNext, sizeof(CNode)));
; 1123 : 		pOldNode->pNext->pPrev = pOldNode->pPrev;

  00027	8b 01		 mov	 eax, DWORD PTR [ecx]
  00029	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN5@RemoveAt:

; 938  : 	pNode->pNext = m_pNodeFree;

  0002c	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0002f	89 01		 mov	 DWORD PTR [ecx], eax

; 939  : 	m_pNodeFree = pNode;
; 940  : 	m_nCount--;

  00031	83 46 0c ff	 add	 DWORD PTR [esi+12], -1
  00035	89 4e 10	 mov	 DWORD PTR [esi+16], ecx

; 941  : 	ASSERT(m_nCount >= 0);  // make sure we don't underflow
; 942  : 
; 943  : 	// if no more elements, cleanup completely
; 944  : 	if (m_nCount == 0)

  00038	75 2b		 jne	 SHORT $LN8@RemoveAt

; 872  : 	m_pBlocks->FreeDataChain();

  0003a	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  0003d	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  00044	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0004b	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00052	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00059	e8 00 00 00 00	 call	 ?FreeDataChain@CPlex@@QAEXXZ ; CPlex::FreeDataChain

; 873  : 	m_pBlocks = NULL;

  0005e	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
$LN8@RemoveAt:
  00065	5e		 pop	 esi

; 1124 : 	}
; 1125 : 	FreeNode(pOldNode);
; 1126 : }

  00066	5d		 pop	 ebp
  00067	c2 04 00	 ret	 4
?RemoveAt@?$CList@NN@@QAEXPAU__POSITION@@@Z ENDP	; CList<double,double>::RemoveAt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ?RemoveAll@?$CList@NN@@QAEXXZ
_TEXT	SEGMENT
?RemoveAll@?$CList@NN@@QAEXXZ PROC			; CList<double,double>::RemoveAll, COMDAT
; _this$ = ecx

; 862  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 863  : 	ASSERT_VALID(this);
; 864  : 
; 865  : 	// destroy elements
; 866  : 	CNode* pNode;
; 867  : 	for (pNode = m_pNodeHead; pNode != NULL; pNode = pNode->pNext)
; 868  : 		pNode->data.~TYPE();
; 869  : 
; 870  : 	m_nCount = 0;
; 871  : 	m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
; 872  : 	m_pBlocks->FreeDataChain();

  00003	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00006	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  0000d	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00014	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  0001b	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00022	e8 00 00 00 00	 call	 ?FreeDataChain@CPlex@@QAEXXZ ; CPlex::FreeDataChain

; 873  : 	m_pBlocks = NULL;

  00027	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
  0002e	5e		 pop	 esi

; 874  : }

  0002f	c3		 ret	 0
?RemoveAll@?$CList@NN@@QAEXXZ ENDP			; CList<double,double>::RemoveAll
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ?AddTail@?$CList@NN@@QAEPAU__POSITION@@N@Z
_TEXT	SEGMENT
_newElement$ = 8					; size = 8
?AddTail@?$CList@NN@@QAEPAU__POSITION@@N@Z PROC		; CList<double,double>::AddTail, COMDAT
; _this$ = ecx

; 965  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 966  : 	ASSERT_VALID(this);
; 967  : 
; 968  : 	CNode* pNewNode = NewNode(m_pNodeTail, NULL);

  00006	6a 00		 push	 0
  00008	ff 76 08	 push	 DWORD PTR [esi+8]
  0000b	e8 00 00 00 00	 call	 ?NewNode@?$CList@NN@@IAEPAUCNode@1@PAU21@0@Z ; CList<double,double>::NewNode

; 969  : 	pNewNode->data = newElement;

  00010	f2 0f 10 45 08	 movsd	 xmm0, QWORD PTR _newElement$[ebp]
  00015	f2 0f 11 40 08	 movsd	 QWORD PTR [eax+8], xmm0

; 970  : 	if (m_pNodeTail != NULL)

  0001a	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0001d	85 c9		 test	 ecx, ecx
  0001f	74 0a		 je	 SHORT $LN2@AddTail

; 971  : 		m_pNodeTail->pNext = pNewNode;

  00021	89 01		 mov	 DWORD PTR [ecx], eax

; 974  : 	m_pNodeTail = pNewNode;
; 975  : 	return (POSITION) pNewNode;
; 976  : }

  00023	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00026	5e		 pop	 esi
  00027	5d		 pop	 ebp
  00028	c2 08 00	 ret	 8
$LN2@AddTail:

; 972  : 	else
; 973  : 		m_pNodeHead = pNewNode;

  0002b	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 974  : 	m_pNodeTail = pNewNode;
; 975  : 	return (POSITION) pNewNode;
; 976  : }

  0002e	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00031	5e		 pop	 esi
  00032	5d		 pop	 ebp
  00033	c2 08 00	 ret	 8
?AddTail@?$CList@NN@@QAEPAU__POSITION@@N@Z ENDP		; CList<double,double>::AddTail
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ?AddHead@?$CList@NN@@QAEPAU__POSITION@@N@Z
_TEXT	SEGMENT
_newElement$ = 8					; size = 8
?AddHead@?$CList@NN@@QAEPAU__POSITION@@N@Z PROC		; CList<double,double>::AddHead, COMDAT
; _this$ = ecx

; 950  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 951  : 	ASSERT_VALID(this);
; 952  : 
; 953  : 	CNode* pNewNode = NewNode(NULL, m_pNodeHead);

  00006	ff 76 04	 push	 DWORD PTR [esi+4]
  00009	6a 00		 push	 0
  0000b	e8 00 00 00 00	 call	 ?NewNode@?$CList@NN@@IAEPAUCNode@1@PAU21@0@Z ; CList<double,double>::NewNode

; 954  : 	pNewNode->data = newElement;

  00010	f2 0f 10 45 08	 movsd	 xmm0, QWORD PTR _newElement$[ebp]
  00015	f2 0f 11 40 08	 movsd	 QWORD PTR [eax+8], xmm0

; 955  : 	if (m_pNodeHead != NULL)

  0001a	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0001d	85 c9		 test	 ecx, ecx
  0001f	74 0b		 je	 SHORT $LN2@AddHead

; 956  : 		m_pNodeHead->pPrev = pNewNode;

  00021	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 959  : 	m_pNodeHead = pNewNode;
; 960  : 	return (POSITION) pNewNode;
; 961  : }

  00024	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00027	5e		 pop	 esi
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
$LN2@AddHead:

; 957  : 	else
; 958  : 		m_pNodeTail = pNewNode;

  0002c	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 959  : 	m_pNodeHead = pNewNode;
; 960  : 	return (POSITION) pNewNode;
; 961  : }

  0002f	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00032	5e		 pop	 esi
  00033	5d		 pop	 ebp
  00034	c2 08 00	 ret	 8
?AddHead@?$CList@NN@@QAEPAU__POSITION@@N@Z ENDP		; CList<double,double>::AddHead
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ?RemoveTail@?$CList@NN@@QAENXZ
_TEXT	SEGMENT
_returnValue$ = -8					; size = 8
?RemoveTail@?$CList@NN@@QAENXZ PROC			; CList<double,double>::RemoveTail, COMDAT
; _this$ = ecx

; 1026 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx

; 1027 : 	ASSERT_VALID(this);
; 1028 : 	ENSURE(m_pNodeTail != NULL);  // don't call on empty list !!!

  00009	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0000c	85 c9		 test	 ecx, ecx
  0000e	74 64		 je	 SHORT $LN24@RemoveTail

; 1029 : 	ASSERT(AfxIsValidAddress(m_pNodeTail, sizeof(CNode)));
; 1030 : 
; 1031 : 	CNode* pOldNode = m_pNodeTail;
; 1032 : 	TYPE returnValue = pOldNode->data;

  00010	f2 0f 10 41 08	 movsd	 xmm0, QWORD PTR [ecx+8]

; 1033 : 
; 1034 : 	m_pNodeTail = pOldNode->pPrev;

  00015	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00018	f2 0f 11 45 f8	 movsd	 QWORD PTR _returnValue$[ebp], xmm0
  0001d	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 1035 : 	if (m_pNodeTail != NULL)

  00020	85 c0		 test	 eax, eax
  00022	74 08		 je	 SHORT $LN6@RemoveTail

; 1036 : 		m_pNodeTail->pNext = NULL;

  00024	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0002a	eb 07		 jmp	 SHORT $LN7@RemoveTail
$LN6@RemoveTail:

; 1037 : 	else
; 1038 : 		m_pNodeHead = NULL;

  0002c	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
$LN7@RemoveTail:

; 938  : 	pNode->pNext = m_pNodeFree;

  00033	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00036	89 01		 mov	 DWORD PTR [ecx], eax

; 939  : 	m_pNodeFree = pNode;
; 940  : 	m_nCount--;

  00038	83 46 0c ff	 add	 DWORD PTR [esi+12], -1
  0003c	89 4e 10	 mov	 DWORD PTR [esi+16], ecx

; 941  : 	ASSERT(m_nCount >= 0);  // make sure we don't underflow
; 942  : 
; 943  : 	// if no more elements, cleanup completely
; 944  : 	if (m_nCount == 0)

  0003f	75 2b		 jne	 SHORT $LN10@RemoveTail

; 872  : 	m_pBlocks->FreeDataChain();

  00041	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00044	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  0004b	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00052	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00059	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00060	e8 00 00 00 00	 call	 ?FreeDataChain@CPlex@@QAEXXZ ; CPlex::FreeDataChain

; 873  : 	m_pBlocks = NULL;

  00065	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
$LN10@RemoveTail:

; 1039 : 	FreeNode(pOldNode);
; 1040 : 	return returnValue;

  0006c	dd 45 f8	 fld	 QWORD PTR _returnValue$[ebp]
  0006f	5e		 pop	 esi

; 1041 : }

  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c3		 ret	 0
$LN24@RemoveTail:

; 1027 : 	ASSERT_VALID(this);
; 1028 : 	ENSURE(m_pNodeTail != NULL);  // don't call on empty list !!!

  00074	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN22@RemoveTail:
  00079	cc		 int	 3
?RemoveTail@?$CList@NN@@QAENXZ ENDP			; CList<double,double>::RemoveTail
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ?RemoveHead@?$CList@NN@@QAENXZ
_TEXT	SEGMENT
_returnValue$ = -8					; size = 8
?RemoveHead@?$CList@NN@@QAENXZ PROC			; CList<double,double>::RemoveHead, COMDAT
; _this$ = ecx

; 1007 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx

; 1008 : 	ASSERT_VALID(this);
; 1009 : 	ENSURE(m_pNodeHead != NULL);  // don't call on empty list !!!

  00009	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0000c	85 c9		 test	 ecx, ecx
  0000e	74 64		 je	 SHORT $LN24@RemoveHead

; 1010 : 	ASSERT(AfxIsValidAddress(m_pNodeHead, sizeof(CNode)));
; 1011 : 
; 1012 : 	CNode* pOldNode = m_pNodeHead;
; 1013 : 	TYPE returnValue = pOldNode->data;

  00010	f2 0f 10 41 08	 movsd	 xmm0, QWORD PTR [ecx+8]

; 1014 : 
; 1015 : 	m_pNodeHead = pOldNode->pNext;

  00015	8b 01		 mov	 eax, DWORD PTR [ecx]
  00017	f2 0f 11 45 f8	 movsd	 QWORD PTR _returnValue$[ebp], xmm0
  0001c	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 1016 : 	if (m_pNodeHead != NULL)

  0001f	85 c0		 test	 eax, eax
  00021	74 09		 je	 SHORT $LN6@RemoveHead

; 1017 : 		m_pNodeHead->pPrev = NULL;

  00023	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  0002a	eb 07		 jmp	 SHORT $LN7@RemoveHead
$LN6@RemoveHead:

; 1018 : 	else
; 1019 : 		m_pNodeTail = NULL;

  0002c	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN7@RemoveHead:

; 938  : 	pNode->pNext = m_pNodeFree;

  00033	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00036	89 01		 mov	 DWORD PTR [ecx], eax

; 939  : 	m_pNodeFree = pNode;
; 940  : 	m_nCount--;

  00038	83 46 0c ff	 add	 DWORD PTR [esi+12], -1
  0003c	89 4e 10	 mov	 DWORD PTR [esi+16], ecx

; 941  : 	ASSERT(m_nCount >= 0);  // make sure we don't underflow
; 942  : 
; 943  : 	// if no more elements, cleanup completely
; 944  : 	if (m_nCount == 0)

  0003f	75 2b		 jne	 SHORT $LN10@RemoveHead

; 872  : 	m_pBlocks->FreeDataChain();

  00041	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00044	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  0004b	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00052	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00059	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00060	e8 00 00 00 00	 call	 ?FreeDataChain@CPlex@@QAEXXZ ; CPlex::FreeDataChain

; 873  : 	m_pBlocks = NULL;

  00065	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
$LN10@RemoveHead:

; 1020 : 	FreeNode(pOldNode);
; 1021 : 	return returnValue;

  0006c	dd 45 f8	 fld	 QWORD PTR _returnValue$[ebp]
  0006f	5e		 pop	 esi

; 1022 : }

  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c3		 ret	 0
$LN24@RemoveHead:

; 1008 : 	ASSERT_VALID(this);
; 1009 : 	ENSURE(m_pNodeHead != NULL);  // don't call on empty list !!!

  00074	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN22@RemoveHead:
  00079	cc		 int	 3
?RemoveHead@?$CList@NN@@QAENXZ ENDP			; CList<double,double>::RemoveHead
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\IWDblList.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\IWDblList.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\IWDblList.cpp
;	COMDAT ?FindIndex@CIWDblList@@MBEPAU__POSITION@@H@Z
_TEXT	SEGMENT
_nIndex$ = 8						; size = 4
?FindIndex@CIWDblList@@MBEPAU__POSITION@@H@Z PROC	; CIWDblList::FindIndex, COMDAT
; _this$ = ecx

; 144  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 145  : 	if( !m_plDblList) return NULL;

  00003	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  00006	85 c9		 test	 ecx, ecx
  00008	75 06		 jne	 SHORT $LN2@FindIndex
  0000a	33 c0		 xor	 eax, eax

; 147  : }

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
$LN2@FindIndex:

; 146  : 	return m_plDblList->FindIndex( nIndex);

  00010	8b 45 08	 mov	 eax, DWORD PTR _nIndex$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 1133 : 	if (nIndex >= m_nCount || nIndex < 0)

  00013	3b 41 0c	 cmp	 eax, DWORD PTR [ecx+12]
  00016	7d 16		 jge	 SHORT $LN8@FindIndex
  00018	85 c0		 test	 eax, eax
  0001a	78 12		 js	 SHORT $LN8@FindIndex

; 1135 : 
; 1136 : 	CNode* pNode = m_pNodeHead;

  0001c	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]

; 1137 : 	while (nIndex--)

  0001f	74 0f		 je	 SHORT $LN4@FindIndex
$LL5@FindIndex:

; 1138 : 	{
; 1139 : 		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 1140 : 		pNode = pNode->pNext;

  00021	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00023	83 e8 01	 sub	 eax, 1
  00026	75 f9		 jne	 SHORT $LL5@FindIndex
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\IWDblList.cpp

; 146  : 	return m_plDblList->FindIndex( nIndex);

  00028	8b c1		 mov	 eax, ecx

; 147  : }

  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
$LN8@FindIndex:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 1134 : 		return NULL;  // went too far

  0002e	33 c9		 xor	 ecx, ecx
$LN4@FindIndex:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\IWDblList.cpp

; 146  : 	return m_plDblList->FindIndex( nIndex);

  00030	8b c1		 mov	 eax, ecx

; 147  : }

  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
?FindIndex@CIWDblList@@MBEPAU__POSITION@@H@Z ENDP	; CIWDblList::FindIndex
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\IWDblList.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\IWDblList.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\IWDblList.cpp
;	COMDAT ?Find@CIWDblList@@MBEPAU__POSITION@@NPAU2@@Z
_TEXT	SEGMENT
_searchValue$ = 8					; size = 8
_startAfter$ = 16					; size = 4
?Find@CIWDblList@@MBEPAU__POSITION@@NPAU2@@Z PROC	; CIWDblList::Find, COMDAT
; _this$ = ecx

; 138  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 139  : 	if( !m_plDblList) return NULL;

  00003	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  00006	8b 45 10	 mov	 eax, DWORD PTR _startAfter$[ebp]
  00009	85 c9		 test	 ecx, ecx
  0000b	75 06		 jne	 SHORT $LN2@Find
  0000d	33 c0		 xor	 eax, eax

; 141  : }

  0000f	5d		 pop	 ebp
  00010	c2 0c 00	 ret	 12			; 0000000cH
$LN2@Find:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 1151 : 	if (pNode == NULL)

  00013	85 c0		 test	 eax, eax
  00015	75 03		 jne	 SHORT $LN8@Find

; 1152 : 	{
; 1153 : 		pNode = m_pNodeHead;  // start at head

  00017	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
$LN8@Find:

; 1154 : 	}
; 1155 : 	else
; 1156 : 	{
; 1157 : 		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 1158 : 		pNode = pNode->pNext;  // start after the one specified
; 1159 : 	}
; 1160 : 
; 1161 : 	for (; pNode != NULL; pNode = pNode->pNext)

  0001a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001c	85 c9		 test	 ecx, ecx
  0001e	74 20		 je	 SHORT $LN6@Find
  00020	f2 0f 10 4d 08	 movsd	 xmm1, QWORD PTR _searchValue$[ebp]
$LL7@Find:

; 1162 : 		if (CompareElements<TYPE>(&pNode->data, &searchValue))

  00025	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]

; 152  : 	ENSURE(pElement1 != NULL && pElement2 != NULL);

  00028	85 c0		 test	 eax, eax
  0002a	74 1c		 je	 SHORT $LN25@Find

; 153  : 	ASSERT(AfxIsValidAddress(pElement1, sizeof(TYPE), FALSE));
; 154  : 	ASSERT(AfxIsValidAddress(pElement2, sizeof(ARG_TYPE), FALSE));
; 155  : 
; 156  : 	return *pElement1 == *pElement2;

  0002c	f2 0f 10 00	 movsd	 xmm0, QWORD PTR [eax]
  00030	66 0f 2e c1	 ucomisd xmm0, xmm1
  00034	9f		 lahf
  00035	f6 c4 44	 test	 ah, 68			; 00000044H
  00038	7b 08		 jnp	 SHORT $LN4@Find

; 1161 : 	for (; pNode != NULL; pNode = pNode->pNext)

  0003a	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0003c	85 c9		 test	 ecx, ecx
  0003e	75 e5		 jne	 SHORT $LL7@Find
$LN6@Find:

; 1163 : 			return (POSITION)pNode;
; 1164 : 	return NULL;

  00040	33 c9		 xor	 ecx, ecx
$LN4@Find:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\IWDblList.cpp

; 140  : 	return m_plDblList->Find( searchValue, startAfter);

  00042	8b c1		 mov	 eax, ecx

; 141  : }

  00044	5d		 pop	 ebp
  00045	c2 0c 00	 ret	 12			; 0000000cH
$LN25@Find:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 152  : 	ENSURE(pElement1 != NULL && pElement2 != NULL);

  00048	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN34@Find:
  0004d	cc		 int	 3
?Find@CIWDblList@@MBEPAU__POSITION@@NPAU2@@Z ENDP	; CIWDblList::Find
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\IWDblList.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\IWDblList.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\IWDblList.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\IWDblList.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\IWDblList.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\IWDblList.cpp
;	COMDAT ?InsertAfter@CIWDblList@@MAEPAU__POSITION@@PAU2@N@Z
_TEXT	SEGMENT
_position$ = 8						; size = 4
_newElement$ = 12					; size = 8
?InsertAfter@CIWDblList@@MAEPAU__POSITION@@PAU2@N@Z PROC ; CIWDblList::InsertAfter, COMDAT
; _this$ = ecx

; 130  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 131  : 	if( !m_plDblList) return NULL;

  00004	8b 71 0c	 mov	 esi, DWORD PTR [ecx+12]
  00007	85 f6		 test	 esi, esi
  00009	75 07		 jne	 SHORT $LN2@InsertAfte
  0000b	33 c0		 xor	 eax, eax
  0000d	5e		 pop	 esi

; 133  : }

  0000e	5d		 pop	 ebp
  0000f	c2 0c 00	 ret	 12			; 0000000cH
$LN2@InsertAfte:
  00012	57		 push	 edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 1075 : 	if (position == NULL)

  00013	8b 7d 08	 mov	 edi, DWORD PTR _position$[ebp]
  00016	8b ce		 mov	 ecx, esi
  00018	85 ff		 test	 edi, edi
  0001a	75 31		 jne	 SHORT $LN5@InsertAfte

; 968  : 	CNode* pNewNode = NewNode(m_pNodeTail, NULL);

  0001c	57		 push	 edi
  0001d	ff 76 08	 push	 DWORD PTR [esi+8]
  00020	e8 00 00 00 00	 call	 ?NewNode@?$CList@NN@@IAEPAUCNode@1@PAU21@0@Z ; CList<double,double>::NewNode

; 969  : 	pNewNode->data = newElement;

  00025	f2 0f 10 45 0c	 movsd	 xmm0, QWORD PTR _newElement$[ebp]
  0002a	f2 0f 11 40 08	 movsd	 QWORD PTR [eax+8], xmm0

; 970  : 	if (m_pNodeTail != NULL)

  0002f	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00032	85 c9		 test	 ecx, ecx
  00034	74 0b		 je	 SHORT $LN10@InsertAfte

; 971  : 		m_pNodeTail->pNext = pNewNode;

  00036	89 01		 mov	 DWORD PTR [ecx], eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\IWDblList.cpp

; 132  : 	return m_plDblList->InsertAfter( position, newElement);

  00038	5f		 pop	 edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 974  : 	m_pNodeTail = pNewNode;

  00039	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0003c	5e		 pop	 esi
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\IWDblList.cpp

; 133  : }

  0003d	5d		 pop	 ebp
  0003e	c2 0c 00	 ret	 12			; 0000000cH
$LN10@InsertAfte:

; 132  : 	return m_plDblList->InsertAfter( position, newElement);

  00041	5f		 pop	 edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 973  : 		m_pNodeHead = pNewNode;

  00042	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 974  : 	m_pNodeTail = pNewNode;

  00045	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00048	5e		 pop	 esi
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\IWDblList.cpp

; 133  : }

  00049	5d		 pop	 ebp
  0004a	c2 0c 00	 ret	 12			; 0000000cH
$LN5@InsertAfte:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 1081 : 	CNode* pNewNode = NewNode(pOldNode, pOldNode->pNext);

  0004d	ff 37		 push	 DWORD PTR [edi]
  0004f	57		 push	 edi
  00050	e8 00 00 00 00	 call	 ?NewNode@?$CList@NN@@IAEPAUCNode@1@PAU21@0@Z ; CList<double,double>::NewNode

; 1082 : 	pNewNode->data = newElement;

  00055	f2 0f 10 45 0c	 movsd	 xmm0, QWORD PTR _newElement$[ebp]
  0005a	f2 0f 11 40 08	 movsd	 QWORD PTR [eax+8], xmm0

; 1083 : 
; 1084 : 	if (pOldNode->pNext != NULL)

  0005f	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00061	85 c9		 test	 ecx, ecx
  00063	74 0b		 je	 SHORT $LN6@InsertAfte

; 1085 : 	{
; 1086 : 		ASSERT(AfxIsValidAddress(pOldNode->pNext, sizeof(CNode)));
; 1087 : 		pOldNode->pNext->pPrev = pNewNode;

  00065	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1093 : 	}
; 1094 : 	pOldNode->pNext = pNewNode;

  00068	89 07		 mov	 DWORD PTR [edi], eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\IWDblList.cpp

; 132  : 	return m_plDblList->InsertAfter( position, newElement);

  0006a	5f		 pop	 edi
  0006b	5e		 pop	 esi

; 133  : }

  0006c	5d		 pop	 ebp
  0006d	c2 0c 00	 ret	 12			; 0000000cH
$LN6@InsertAfte:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 1092 : 		m_pNodeTail = pNewNode;

  00070	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 1093 : 	}
; 1094 : 	pOldNode->pNext = pNewNode;

  00073	89 07		 mov	 DWORD PTR [edi], eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\IWDblList.cpp

; 132  : 	return m_plDblList->InsertAfter( position, newElement);

  00075	5f		 pop	 edi
  00076	5e		 pop	 esi

; 133  : }

  00077	5d		 pop	 ebp
  00078	c2 0c 00	 ret	 12			; 0000000cH
?InsertAfter@CIWDblList@@MAEPAU__POSITION@@PAU2@N@Z ENDP ; CIWDblList::InsertAfter
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\IWDblList.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\IWDblList.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\IWDblList.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\IWDblList.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\IWDblList.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\IWDblList.cpp
;	COMDAT ?InsertBefore@CIWDblList@@MAEPAU__POSITION@@PAU2@N@Z
_TEXT	SEGMENT
_position$ = 8						; size = 4
_newElement$ = 12					; size = 8
?InsertBefore@CIWDblList@@MAEPAU__POSITION@@PAU2@N@Z PROC ; CIWDblList::InsertBefore, COMDAT
; _this$ = ecx

; 125  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 126  : 	if( !m_plDblList) return NULL;

  00004	8b 71 0c	 mov	 esi, DWORD PTR [ecx+12]
  00007	85 f6		 test	 esi, esi
  00009	75 07		 jne	 SHORT $LN2@InsertBefo
  0000b	33 c0		 xor	 eax, eax
  0000d	5e		 pop	 esi

; 128  : }

  0000e	5d		 pop	 ebp
  0000f	c2 0c 00	 ret	 12			; 0000000cH
$LN2@InsertBefo:
  00012	57		 push	 edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 1048 : 	if (position == NULL)

  00013	8b 7d 08	 mov	 edi, DWORD PTR _position$[ebp]
  00016	8b ce		 mov	 ecx, esi
  00018	85 ff		 test	 edi, edi
  0001a	75 32		 jne	 SHORT $LN5@InsertBefo

; 953  : 	CNode* pNewNode = NewNode(NULL, m_pNodeHead);

  0001c	ff 76 04	 push	 DWORD PTR [esi+4]
  0001f	57		 push	 edi
  00020	e8 00 00 00 00	 call	 ?NewNode@?$CList@NN@@IAEPAUCNode@1@PAU21@0@Z ; CList<double,double>::NewNode

; 954  : 	pNewNode->data = newElement;

  00025	f2 0f 10 45 0c	 movsd	 xmm0, QWORD PTR _newElement$[ebp]
  0002a	f2 0f 11 40 08	 movsd	 QWORD PTR [eax+8], xmm0

; 955  : 	if (m_pNodeHead != NULL)

  0002f	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00032	85 c9		 test	 ecx, ecx
  00034	74 0c		 je	 SHORT $LN10@InsertBefo

; 956  : 		m_pNodeHead->pPrev = pNewNode;

  00036	89 41 04	 mov	 DWORD PTR [ecx+4], eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\IWDblList.cpp

; 127  : 	return m_plDblList->InsertBefore( position, newElement);

  00039	5f		 pop	 edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 959  : 	m_pNodeHead = pNewNode;

  0003a	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0003d	5e		 pop	 esi
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\IWDblList.cpp

; 128  : }

  0003e	5d		 pop	 ebp
  0003f	c2 0c 00	 ret	 12			; 0000000cH
$LN10@InsertBefo:

; 127  : 	return m_plDblList->InsertBefore( position, newElement);

  00042	5f		 pop	 edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 958  : 		m_pNodeTail = pNewNode;

  00043	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 959  : 	m_pNodeHead = pNewNode;

  00046	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00049	5e		 pop	 esi
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\IWDblList.cpp

; 128  : }

  0004a	5d		 pop	 ebp
  0004b	c2 0c 00	 ret	 12			; 0000000cH
$LN5@InsertBefo:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 1053 : 	CNode* pNewNode = NewNode(pOldNode->pPrev, pOldNode);

  0004e	57		 push	 edi
  0004f	ff 77 04	 push	 DWORD PTR [edi+4]
  00052	e8 00 00 00 00	 call	 ?NewNode@?$CList@NN@@IAEPAUCNode@1@PAU21@0@Z ; CList<double,double>::NewNode

; 1054 : 	pNewNode->data = newElement;

  00057	f2 0f 10 45 0c	 movsd	 xmm0, QWORD PTR _newElement$[ebp]
  0005c	f2 0f 11 40 08	 movsd	 QWORD PTR [eax+8], xmm0

; 1055 : 
; 1056 : 	if (pOldNode->pPrev != NULL)

  00061	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00064	85 c9		 test	 ecx, ecx
  00066	74 0b		 je	 SHORT $LN6@InsertBefo

; 1057 : 	{
; 1058 : 		ASSERT(AfxIsValidAddress(pOldNode->pPrev, sizeof(CNode)));
; 1059 : 		pOldNode->pPrev->pNext = pNewNode;

  00068	89 01		 mov	 DWORD PTR [ecx], eax

; 1065 : 	}
; 1066 : 	pOldNode->pPrev = pNewNode;

  0006a	89 47 04	 mov	 DWORD PTR [edi+4], eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\IWDblList.cpp

; 127  : 	return m_plDblList->InsertBefore( position, newElement);

  0006d	5f		 pop	 edi
  0006e	5e		 pop	 esi

; 128  : }

  0006f	5d		 pop	 ebp
  00070	c2 0c 00	 ret	 12			; 0000000cH
$LN6@InsertBefo:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 1064 : 		m_pNodeHead = pNewNode;

  00073	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 1065 : 	}
; 1066 : 	pOldNode->pPrev = pNewNode;

  00076	89 47 04	 mov	 DWORD PTR [edi+4], eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\IWDblList.cpp

; 127  : 	return m_plDblList->InsertBefore( position, newElement);

  00079	5f		 pop	 edi
  0007a	5e		 pop	 esi

; 128  : }

  0007b	5d		 pop	 ebp
  0007c	c2 0c 00	 ret	 12			; 0000000cH
?InsertBefore@CIWDblList@@MAEPAU__POSITION@@PAU2@N@Z ENDP ; CIWDblList::InsertBefore
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\IWDblList.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\IWDblList.cpp
;	COMDAT ?RemoveAt@CIWDblList@@MAEXPAU__POSITION@@@Z
_TEXT	SEGMENT
_position$ = 8						; size = 4
?RemoveAt@CIWDblList@@MAEXPAU__POSITION@@@Z PROC	; CIWDblList::RemoveAt, COMDAT
; _this$ = ecx

; 119  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 120  : 	if( m_plDblList) m_plDblList->RemoveAt( position);

  00004	8b 71 0c	 mov	 esi, DWORD PTR [ecx+12]
  00007	85 f6		 test	 esi, esi
  00009	74 5f		 je	 SHORT $LN11@RemoveAt
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 1107 : 	if (pOldNode == m_pNodeHead)

  0000b	8b 4d 08	 mov	 ecx, DWORD PTR _position$[ebp]
  0000e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00010	3b 4e 04	 cmp	 ecx, DWORD PTR [esi+4]
  00013	75 05		 jne	 SHORT $LN5@RemoveAt

; 1108 : 	{
; 1109 : 		m_pNodeHead = pOldNode->pNext;

  00015	89 56 04	 mov	 DWORD PTR [esi+4], edx

; 1110 : 	}

  00018	eb 05		 jmp	 SHORT $LN6@RemoveAt
$LN5@RemoveAt:

; 1111 : 	else
; 1112 : 	{
; 1113 : 		ASSERT(AfxIsValidAddress(pOldNode->pPrev, sizeof(CNode)));
; 1114 : 		pOldNode->pPrev->pNext = pOldNode->pNext;

  0001a	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0001d	89 10		 mov	 DWORD PTR [eax], edx
$LN6@RemoveAt:

; 1115 : 	}
; 1116 : 	if (pOldNode == m_pNodeTail)

  0001f	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00022	3b 4e 08	 cmp	 ecx, DWORD PTR [esi+8]
  00025	75 05		 jne	 SHORT $LN7@RemoveAt

; 1117 : 	{
; 1118 : 		m_pNodeTail = pOldNode->pPrev;

  00027	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 1119 : 	}

  0002a	eb 05		 jmp	 SHORT $LN8@RemoveAt
$LN7@RemoveAt:

; 1120 : 	else
; 1121 : 	{
; 1122 : 		ASSERT(AfxIsValidAddress(pOldNode->pNext, sizeof(CNode)));
; 1123 : 		pOldNode->pNext->pPrev = pOldNode->pPrev;

  0002c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0002e	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN8@RemoveAt:

; 938  : 	pNode->pNext = m_pNodeFree;

  00031	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00034	89 01		 mov	 DWORD PTR [ecx], eax

; 939  : 	m_pNodeFree = pNode;
; 940  : 	m_nCount--;

  00036	83 46 0c ff	 add	 DWORD PTR [esi+12], -1
  0003a	89 4e 10	 mov	 DWORD PTR [esi+16], ecx

; 941  : 	ASSERT(m_nCount >= 0);  // make sure we don't underflow
; 942  : 
; 943  : 	// if no more elements, cleanup completely
; 944  : 	if (m_nCount == 0)

  0003d	75 2b		 jne	 SHORT $LN11@RemoveAt

; 872  : 	m_pBlocks->FreeDataChain();

  0003f	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00042	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  00049	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00050	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00057	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0005e	e8 00 00 00 00	 call	 ?FreeDataChain@CPlex@@QAEXXZ ; CPlex::FreeDataChain

; 873  : 	m_pBlocks = NULL;

  00063	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
$LN11@RemoveAt:
  0006a	5e		 pop	 esi
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\IWDblList.cpp

; 121  : }

  0006b	5d		 pop	 ebp
  0006c	c2 04 00	 ret	 4
?RemoveAt@CIWDblList@@MAEXPAU__POSITION@@@Z ENDP	; CIWDblList::RemoveAt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\IWDblList.cpp
;	COMDAT ?SetAt@CIWDblList@@MAEXPAU__POSITION@@N@Z
_TEXT	SEGMENT
_position$ = 8						; size = 4
_newElement$ = 12					; size = 8
?SetAt@CIWDblList@@MAEXPAU__POSITION@@N@Z PROC		; CIWDblList::SetAt, COMDAT
; _this$ = ecx

; 115  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 116  : 	if( m_plDblList) m_plDblList->SetAt( position, newElement);

  00003	83 79 0c 00	 cmp	 DWORD PTR [ecx+12], 0
  00007	74 0d		 je	 SHORT $LN2@SetAt
  00009	8b 45 08	 mov	 eax, DWORD PTR _position$[ebp]
  0000c	f2 0f 10 45 0c	 movsd	 xmm0, QWORD PTR _newElement$[ebp]
  00011	f2 0f 11 40 08	 movsd	 QWORD PTR [eax+8], xmm0
$LN2@SetAt:

; 117  : }

  00016	5d		 pop	 ebp
  00017	c2 0c 00	 ret	 12			; 0000000cH
?SetAt@CIWDblList@@MAEXPAU__POSITION@@N@Z ENDP		; CIWDblList::SetAt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\IWDblList.cpp
;	COMDAT ?GetAt@CIWDblList@@MBEHPAU__POSITION@@AAN@Z
_TEXT	SEGMENT
_position$ = 8						; size = 4
_p_dData$ = 12						; size = 4
?GetAt@CIWDblList@@MBEHPAU__POSITION@@AAN@Z PROC	; CIWDblList::GetAt, COMDAT
; _this$ = ecx

; 109  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 110  : 	if( !m_plDblList) return FALSE;

  00003	83 79 0c 00	 cmp	 DWORD PTR [ecx+12], 0
  00007	75 06		 jne	 SHORT $LN2@GetAt
  00009	33 c0		 xor	 eax, eax

; 113  : }

  0000b	5d		 pop	 ebp
  0000c	c2 08 00	 ret	 8
$LN2@GetAt:

; 111  : 	p_dData = m_plDblList->GetAt( position);

  0000f	8b 45 08	 mov	 eax, DWORD PTR _position$[ebp]
  00012	f2 0f 10 40 08	 movsd	 xmm0, QWORD PTR [eax+8]
  00017	8b 45 0c	 mov	 eax, DWORD PTR _p_dData$[ebp]
  0001a	f2 0f 11 00	 movsd	 QWORD PTR [eax], xmm0

; 112  : 	return TRUE;

  0001e	b8 01 00 00 00	 mov	 eax, 1

; 113  : }

  00023	5d		 pop	 ebp
  00024	c2 08 00	 ret	 8
?GetAt@CIWDblList@@MBEHPAU__POSITION@@AAN@Z ENDP	; CIWDblList::GetAt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\IWDblList.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\IWDblList.cpp
;	COMDAT ?GetPrev@CIWDblList@@MBEHAAPAU__POSITION@@AAN@Z
_TEXT	SEGMENT
_rPosition$ = 8						; size = 4
_p_dData$ = 12						; size = 4
?GetPrev@CIWDblList@@MBEHAAPAU__POSITION@@AAN@Z PROC	; CIWDblList::GetPrev, COMDAT
; _this$ = ecx

; 101  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 102  : 	if( !m_plDblList) return FALSE;

  00003	83 79 0c 00	 cmp	 DWORD PTR [ecx+12], 0
  00007	75 06		 jne	 SHORT $LN2@GetPrev
  00009	33 c0		 xor	 eax, eax

; 105  : }

  0000b	5d		 pop	 ebp
  0000c	c2 08 00	 ret	 8
$LN2@GetPrev:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 823  : 	{ CNode* pNode = (CNode*) rPosition;

  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _rPosition$[ebp]
  00012	8b 11		 mov	 edx, DWORD PTR [ecx]

; 824  : 		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 825  : 		rPosition = (POSITION) pNode->pPrev;

  00014	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00017	89 01		 mov	 DWORD PTR [ecx], eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\IWDblList.cpp

; 103  : 	p_dData = m_plDblList->GetPrev( rPosition);

  00019	8b 45 0c	 mov	 eax, DWORD PTR _p_dData$[ebp]
  0001c	f2 0f 10 42 08	 movsd	 xmm0, QWORD PTR [edx+8]
  00021	f2 0f 11 00	 movsd	 QWORD PTR [eax], xmm0

; 104  : 	return TRUE;

  00025	b8 01 00 00 00	 mov	 eax, 1

; 105  : }

  0002a	5d		 pop	 ebp
  0002b	c2 08 00	 ret	 8
?GetPrev@CIWDblList@@MBEHAAPAU__POSITION@@AAN@Z ENDP	; CIWDblList::GetPrev
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\IWDblList.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\IWDblList.cpp
;	COMDAT ?GetNext@CIWDblList@@MBEHAAPAU__POSITION@@AAN@Z
_TEXT	SEGMENT
_rPosition$ = 8						; size = 4
_p_dData$ = 12						; size = 4
?GetNext@CIWDblList@@MBEHAAPAU__POSITION@@AAN@Z PROC	; CIWDblList::GetNext, COMDAT
; _this$ = ecx

; 95   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 96   : 	if( !m_plDblList) return FALSE;

  00003	83 79 0c 00	 cmp	 DWORD PTR [ecx+12], 0
  00007	75 06		 jne	 SHORT $LN2@GetNext
  00009	33 c0		 xor	 eax, eax

; 99   : }

  0000b	5d		 pop	 ebp
  0000c	c2 08 00	 ret	 8
$LN2@GetNext:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 811  : 	{ CNode* pNode = (CNode*) rPosition;

  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _rPosition$[ebp]
  00012	8b 11		 mov	 edx, DWORD PTR [ecx]

; 812  : 		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 813  : 		rPosition = (POSITION) pNode->pNext;

  00014	8b 02		 mov	 eax, DWORD PTR [edx]
  00016	89 01		 mov	 DWORD PTR [ecx], eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\IWDblList.cpp

; 97   : 	p_dData = m_plDblList->GetNext( rPosition);

  00018	8b 45 0c	 mov	 eax, DWORD PTR _p_dData$[ebp]
  0001b	f2 0f 10 42 08	 movsd	 xmm0, QWORD PTR [edx+8]
  00020	f2 0f 11 00	 movsd	 QWORD PTR [eax], xmm0

; 98   : 	return TRUE;

  00024	b8 01 00 00 00	 mov	 eax, 1

; 99   : }

  00029	5d		 pop	 ebp
  0002a	c2 08 00	 ret	 8
?GetNext@CIWDblList@@MBEHAAPAU__POSITION@@AAN@Z ENDP	; CIWDblList::GetNext
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\IWDblList.cpp
;	COMDAT ?GetTailPosition@CIWDblList@@MBEPAU__POSITION@@XZ
_TEXT	SEGMENT
?GetTailPosition@CIWDblList@@MBEPAU__POSITION@@XZ PROC	; CIWDblList::GetTailPosition, COMDAT
; _this$ = ecx

; 91   : 	if( !m_plDblList) return NULL;

  00000	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00003	85 c0		 test	 eax, eax
  00005	75 01		 jne	 SHORT $LN2@GetTailPos

; 93   : }

  00007	c3		 ret	 0
$LN2@GetTailPos:

; 92   : 	return m_plDblList->GetTailPosition();

  00008	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 93   : }

  0000b	c3		 ret	 0
?GetTailPosition@CIWDblList@@MBEPAU__POSITION@@XZ ENDP	; CIWDblList::GetTailPosition
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\IWDblList.cpp
;	COMDAT ?GetHeadPosition@CIWDblList@@MBEPAU__POSITION@@XZ
_TEXT	SEGMENT
?GetHeadPosition@CIWDblList@@MBEPAU__POSITION@@XZ PROC	; CIWDblList::GetHeadPosition, COMDAT
; _this$ = ecx

; 86   : 	if( !m_plDblList) return NULL;

  00000	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00003	85 c0		 test	 eax, eax
  00005	75 01		 jne	 SHORT $LN2@GetHeadPos

; 88   : }

  00007	c3		 ret	 0
$LN2@GetHeadPos:

; 87   : 	return m_plDblList->GetHeadPosition();

  00008	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 88   : }

  0000b	c3		 ret	 0
?GetHeadPosition@CIWDblList@@MBEPAU__POSITION@@XZ ENDP	; CIWDblList::GetHeadPosition
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\IWDblList.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\IWDblList.cpp
;	COMDAT ?RemoveAll@CIWDblList@@MAEXXZ
_TEXT	SEGMENT
?RemoveAll@CIWDblList@@MAEXXZ PROC			; CIWDblList::RemoveAll, COMDAT
; _this$ = ecx

; 79   : {

  00000	56		 push	 esi

; 80   : 	if( m_plDblList) m_plDblList->RemoveAll();

  00001	8b 71 0c	 mov	 esi, DWORD PTR [ecx+12]
  00004	85 f6		 test	 esi, esi
  00006	74 2b		 je	 SHORT $LN2@RemoveAll
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 872  : 	m_pBlocks->FreeDataChain();

  00008	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  0000b	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  00012	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00019	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00020	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00027	e8 00 00 00 00	 call	 ?FreeDataChain@CPlex@@QAEXXZ ; CPlex::FreeDataChain

; 873  : 	m_pBlocks = NULL;

  0002c	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
$LN2@RemoveAll:
  00033	5e		 pop	 esi
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\IWDblList.cpp

; 81   : }

  00034	c3		 ret	 0
?RemoveAll@CIWDblList@@MAEXXZ ENDP			; CIWDblList::RemoveAll
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\IWDblList.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\IWDblList.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\IWDblList.cpp
;	COMDAT ?AddTail@CIWDblList@@MAEPAU__POSITION@@N@Z
_TEXT	SEGMENT
_newElement$ = 8					; size = 8
?AddTail@CIWDblList@@MAEPAU__POSITION@@N@Z PROC		; CIWDblList::AddTail, COMDAT
; _this$ = ecx

; 72   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 73   : 	if( !m_plDblList) return NULL;

  00004	8b 71 0c	 mov	 esi, DWORD PTR [ecx+12]
  00007	85 f6		 test	 esi, esi
  00009	75 07		 jne	 SHORT $LN2@AddTail
  0000b	33 c0		 xor	 eax, eax
  0000d	5e		 pop	 esi

; 75   : }

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
$LN2@AddTail:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 968  : 	CNode* pNewNode = NewNode(m_pNodeTail, NULL);

  00012	6a 00		 push	 0
  00014	ff 76 08	 push	 DWORD PTR [esi+8]
  00017	8b ce		 mov	 ecx, esi
  00019	e8 00 00 00 00	 call	 ?NewNode@?$CList@NN@@IAEPAUCNode@1@PAU21@0@Z ; CList<double,double>::NewNode

; 969  : 	pNewNode->data = newElement;

  0001e	f2 0f 10 45 08	 movsd	 xmm0, QWORD PTR _newElement$[ebp]
  00023	f2 0f 11 40 08	 movsd	 QWORD PTR [eax+8], xmm0

; 970  : 	if (m_pNodeTail != NULL)

  00028	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0002b	85 c9		 test	 ecx, ecx
  0002d	74 0a		 je	 SHORT $LN5@AddTail

; 971  : 		m_pNodeTail->pNext = pNewNode;

  0002f	89 01		 mov	 DWORD PTR [ecx], eax

; 974  : 	m_pNodeTail = pNewNode;

  00031	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00034	5e		 pop	 esi
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\IWDblList.cpp

; 75   : }

  00035	5d		 pop	 ebp
  00036	c2 08 00	 ret	 8
$LN5@AddTail:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 973  : 		m_pNodeHead = pNewNode;

  00039	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 974  : 	m_pNodeTail = pNewNode;

  0003c	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0003f	5e		 pop	 esi
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\IWDblList.cpp

; 75   : }

  00040	5d		 pop	 ebp
  00041	c2 08 00	 ret	 8
?AddTail@CIWDblList@@MAEPAU__POSITION@@N@Z ENDP		; CIWDblList::AddTail
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\IWDblList.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\IWDblList.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\IWDblList.cpp
;	COMDAT ?AddHead@CIWDblList@@MAEPAU__POSITION@@N@Z
_TEXT	SEGMENT
_newElement$ = 8					; size = 8
?AddHead@CIWDblList@@MAEPAU__POSITION@@N@Z PROC		; CIWDblList::AddHead, COMDAT
; _this$ = ecx

; 67   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 68   : 	if( !m_plDblList) return NULL;

  00004	8b 71 0c	 mov	 esi, DWORD PTR [ecx+12]
  00007	85 f6		 test	 esi, esi
  00009	75 07		 jne	 SHORT $LN2@AddHead
  0000b	33 c0		 xor	 eax, eax
  0000d	5e		 pop	 esi

; 70   : }

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
$LN2@AddHead:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 953  : 	CNode* pNewNode = NewNode(NULL, m_pNodeHead);

  00012	ff 76 04	 push	 DWORD PTR [esi+4]
  00015	8b ce		 mov	 ecx, esi
  00017	6a 00		 push	 0
  00019	e8 00 00 00 00	 call	 ?NewNode@?$CList@NN@@IAEPAUCNode@1@PAU21@0@Z ; CList<double,double>::NewNode

; 954  : 	pNewNode->data = newElement;

  0001e	f2 0f 10 45 08	 movsd	 xmm0, QWORD PTR _newElement$[ebp]
  00023	f2 0f 11 40 08	 movsd	 QWORD PTR [eax+8], xmm0

; 955  : 	if (m_pNodeHead != NULL)

  00028	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0002b	85 c9		 test	 ecx, ecx
  0002d	74 0b		 je	 SHORT $LN5@AddHead

; 956  : 		m_pNodeHead->pPrev = pNewNode;

  0002f	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 959  : 	m_pNodeHead = pNewNode;

  00032	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00035	5e		 pop	 esi
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\IWDblList.cpp

; 70   : }

  00036	5d		 pop	 ebp
  00037	c2 08 00	 ret	 8
$LN5@AddHead:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 958  : 		m_pNodeTail = pNewNode;

  0003a	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 959  : 	m_pNodeHead = pNewNode;

  0003d	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00040	5e		 pop	 esi
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\IWDblList.cpp

; 70   : }

  00041	5d		 pop	 ebp
  00042	c2 08 00	 ret	 8
?AddHead@CIWDblList@@MAEPAU__POSITION@@N@Z ENDP		; CIWDblList::AddHead
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\IWDblList.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\IWDblList.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\IWDblList.cpp
;	COMDAT ?RemoveTail@CIWDblList@@MAEHAAN@Z
_TEXT	SEGMENT
_returnValue$1$ = -8					; size = 8
_p_dData$ = 8						; size = 4
?RemoveTail@CIWDblList@@MAEHAAN@Z PROC			; CIWDblList::RemoveTail, COMDAT
; _this$ = ecx

; 59   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi

; 60   : 	if( !m_plDblList) return FALSE;

  00007	8b 71 0c	 mov	 esi, DWORD PTR [ecx+12]
  0000a	85 f6		 test	 esi, esi
  0000c	75 09		 jne	 SHORT $LN2@RemoveTail
  0000e	33 c0		 xor	 eax, eax
  00010	5e		 pop	 esi

; 63   : }

  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c2 04 00	 ret	 4
$LN2@RemoveTail:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 1028 : 	ENSURE(m_pNodeTail != NULL);  // don't call on empty list !!!

  00017	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0001a	85 c9		 test	 ecx, ecx
  0001c	74 74		 je	 SHORT $LN28@RemoveTail

; 1029 : 	ASSERT(AfxIsValidAddress(m_pNodeTail, sizeof(CNode)));
; 1030 : 
; 1031 : 	CNode* pOldNode = m_pNodeTail;
; 1032 : 	TYPE returnValue = pOldNode->data;

  0001e	f2 0f 10 41 08	 movsd	 xmm0, QWORD PTR [ecx+8]

; 1033 : 
; 1034 : 	m_pNodeTail = pOldNode->pPrev;

  00023	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00026	f2 0f 11 45 f8	 movsd	 QWORD PTR _returnValue$1$[ebp], xmm0
  0002b	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 1035 : 	if (m_pNodeTail != NULL)

  0002e	85 c0		 test	 eax, eax
  00030	74 08		 je	 SHORT $LN9@RemoveTail

; 1036 : 		m_pNodeTail->pNext = NULL;

  00032	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00038	eb 07		 jmp	 SHORT $LN10@RemoveTail
$LN9@RemoveTail:

; 1037 : 	else
; 1038 : 		m_pNodeHead = NULL;

  0003a	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
$LN10@RemoveTail:

; 938  : 	pNode->pNext = m_pNodeFree;

  00041	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00044	89 01		 mov	 DWORD PTR [ecx], eax

; 939  : 	m_pNodeFree = pNode;
; 940  : 	m_nCount--;

  00046	83 46 0c ff	 add	 DWORD PTR [esi+12], -1
  0004a	89 4e 10	 mov	 DWORD PTR [esi+16], ecx

; 941  : 	ASSERT(m_nCount >= 0);  // make sure we don't underflow
; 942  : 
; 943  : 	// if no more elements, cleanup completely
; 944  : 	if (m_nCount == 0)

  0004d	75 30		 jne	 SHORT $LN13@RemoveTail

; 872  : 	m_pBlocks->FreeDataChain();

  0004f	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00052	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  00059	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00060	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00067	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0006e	e8 00 00 00 00	 call	 ?FreeDataChain@CPlex@@QAEXXZ ; CPlex::FreeDataChain
  00073	f2 0f 10 45 f8	 movsd	 xmm0, QWORD PTR _returnValue$1$[ebp]

; 873  : 	m_pBlocks = NULL;

  00078	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
$LN13@RemoveTail:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\IWDblList.cpp

; 61   : 	p_dData = m_plDblList->RemoveTail();

  0007f	8b 45 08	 mov	 eax, DWORD PTR _p_dData$[ebp]
  00082	5e		 pop	 esi
  00083	f2 0f 11 00	 movsd	 QWORD PTR [eax], xmm0

; 62   : 	return TRUE;

  00087	b8 01 00 00 00	 mov	 eax, 1

; 63   : }

  0008c	8b e5		 mov	 esp, ebp
  0008e	5d		 pop	 ebp
  0008f	c2 04 00	 ret	 4
$LN28@RemoveTail:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 1028 : 	ENSURE(m_pNodeTail != NULL);  // don't call on empty list !!!

  00092	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN26@RemoveTail:
  00097	cc		 int	 3
?RemoveTail@CIWDblList@@MAEHAAN@Z ENDP			; CIWDblList::RemoveTail
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\IWDblList.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\IWDblList.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\IWDblList.cpp
;	COMDAT ?RemoveHead@CIWDblList@@MAEHAAN@Z
_TEXT	SEGMENT
_returnValue$1$ = -8					; size = 8
_p_dData$ = 8						; size = 4
?RemoveHead@CIWDblList@@MAEHAAN@Z PROC			; CIWDblList::RemoveHead, COMDAT
; _this$ = ecx

; 53   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi

; 54   : 	if( !m_plDblList) return FALSE;

  00007	8b 71 0c	 mov	 esi, DWORD PTR [ecx+12]
  0000a	85 f6		 test	 esi, esi
  0000c	75 09		 jne	 SHORT $LN2@RemoveHead
  0000e	33 c0		 xor	 eax, eax
  00010	5e		 pop	 esi

; 57   : }

  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c2 04 00	 ret	 4
$LN2@RemoveHead:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 1009 : 	ENSURE(m_pNodeHead != NULL);  // don't call on empty list !!!

  00017	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0001a	85 c9		 test	 ecx, ecx
  0001c	74 74		 je	 SHORT $LN28@RemoveHead

; 1010 : 	ASSERT(AfxIsValidAddress(m_pNodeHead, sizeof(CNode)));
; 1011 : 
; 1012 : 	CNode* pOldNode = m_pNodeHead;
; 1013 : 	TYPE returnValue = pOldNode->data;

  0001e	f2 0f 10 41 08	 movsd	 xmm0, QWORD PTR [ecx+8]

; 1014 : 
; 1015 : 	m_pNodeHead = pOldNode->pNext;

  00023	8b 01		 mov	 eax, DWORD PTR [ecx]
  00025	f2 0f 11 45 f8	 movsd	 QWORD PTR _returnValue$1$[ebp], xmm0
  0002a	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 1016 : 	if (m_pNodeHead != NULL)

  0002d	85 c0		 test	 eax, eax
  0002f	74 09		 je	 SHORT $LN9@RemoveHead

; 1017 : 		m_pNodeHead->pPrev = NULL;

  00031	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00038	eb 07		 jmp	 SHORT $LN10@RemoveHead
$LN9@RemoveHead:

; 1018 : 	else
; 1019 : 		m_pNodeTail = NULL;

  0003a	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN10@RemoveHead:

; 938  : 	pNode->pNext = m_pNodeFree;

  00041	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00044	89 01		 mov	 DWORD PTR [ecx], eax

; 939  : 	m_pNodeFree = pNode;
; 940  : 	m_nCount--;

  00046	83 46 0c ff	 add	 DWORD PTR [esi+12], -1
  0004a	89 4e 10	 mov	 DWORD PTR [esi+16], ecx

; 941  : 	ASSERT(m_nCount >= 0);  // make sure we don't underflow
; 942  : 
; 943  : 	// if no more elements, cleanup completely
; 944  : 	if (m_nCount == 0)

  0004d	75 30		 jne	 SHORT $LN13@RemoveHead

; 872  : 	m_pBlocks->FreeDataChain();

  0004f	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00052	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  00059	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00060	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00067	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0006e	e8 00 00 00 00	 call	 ?FreeDataChain@CPlex@@QAEXXZ ; CPlex::FreeDataChain
  00073	f2 0f 10 45 f8	 movsd	 xmm0, QWORD PTR _returnValue$1$[ebp]

; 873  : 	m_pBlocks = NULL;

  00078	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
$LN13@RemoveHead:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\IWDblList.cpp

; 55   : 	p_dData = m_plDblList->RemoveHead();

  0007f	8b 45 08	 mov	 eax, DWORD PTR _p_dData$[ebp]
  00082	5e		 pop	 esi
  00083	f2 0f 11 00	 movsd	 QWORD PTR [eax], xmm0

; 56   : 	return TRUE;

  00087	b8 01 00 00 00	 mov	 eax, 1

; 57   : }

  0008c	8b e5		 mov	 esp, ebp
  0008e	5d		 pop	 ebp
  0008f	c2 04 00	 ret	 4
$LN28@RemoveHead:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 1009 : 	ENSURE(m_pNodeHead != NULL);  // don't call on empty list !!!

  00092	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN26@RemoveHead:
  00097	cc		 int	 3
?RemoveHead@CIWDblList@@MAEHAAN@Z ENDP			; CIWDblList::RemoveHead
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\IWDblList.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\IWDblList.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\IWDblList.cpp
;	COMDAT ?GetTail@CIWDblList@@MBEHAAN@Z
_TEXT	SEGMENT
_p_dData$ = 8						; size = 4
?GetTail@CIWDblList@@MBEHAAN@Z PROC			; CIWDblList::GetTail, COMDAT
; _this$ = ecx

; 44   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 45   : 	if( !m_plDblList) return FALSE;

  00003	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00006	85 c0		 test	 eax, eax
  00008	75 04		 jne	 SHORT $LN2@GetTail

; 48   : }

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
$LN2@GetTail:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 797  : 	{ ENSURE(m_pNodeTail != NULL);

  0000e	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00011	85 c0		 test	 eax, eax
  00013	74 15		 je	 SHORT $LN13@GetTail
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\IWDblList.cpp

; 46   : 	p_dData = m_plDblList->GetTail();

  00015	f2 0f 10 40 08	 movsd	 xmm0, QWORD PTR [eax+8]
  0001a	8b 45 08	 mov	 eax, DWORD PTR _p_dData$[ebp]
  0001d	f2 0f 11 00	 movsd	 QWORD PTR [eax], xmm0

; 47   : 	return TRUE;

  00021	b8 01 00 00 00	 mov	 eax, 1

; 48   : }

  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
$LN13@GetTail:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 797  : 	{ ENSURE(m_pNodeTail != NULL);

  0002a	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN11@GetTail:
  0002f	cc		 int	 3
?GetTail@CIWDblList@@MBEHAAN@Z ENDP			; CIWDblList::GetTail
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\IWDblList.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\IWDblList.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\IWDblList.cpp
;	COMDAT ?GetHead@CIWDblList@@MBEHAAN@Z
_TEXT	SEGMENT
_p_dData$ = 8						; size = 4
?GetHead@CIWDblList@@MBEHAAN@Z PROC			; CIWDblList::GetHead, COMDAT
; _this$ = ecx

; 38   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 39   : 	if( !m_plDblList) return FALSE;

  00003	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00006	85 c0		 test	 eax, eax
  00008	75 04		 jne	 SHORT $LN2@GetHead

; 42   : }

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
$LN2@GetHead:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 789  : 	{ ENSURE(m_pNodeHead != NULL);

  0000e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00011	85 c0		 test	 eax, eax
  00013	74 15		 je	 SHORT $LN13@GetHead
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\IWDblList.cpp

; 40   : 	p_dData = m_plDblList->GetHead();

  00015	f2 0f 10 40 08	 movsd	 xmm0, QWORD PTR [eax+8]
  0001a	8b 45 08	 mov	 eax, DWORD PTR _p_dData$[ebp]
  0001d	f2 0f 11 00	 movsd	 QWORD PTR [eax], xmm0

; 41   : 	return TRUE;

  00021	b8 01 00 00 00	 mov	 eax, 1

; 42   : }

  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
$LN13@GetHead:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 789  : 	{ ENSURE(m_pNodeHead != NULL);

  0002a	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN11@GetHead:
  0002f	cc		 int	 3
?GetHead@CIWDblList@@MBEHAAN@Z ENDP			; CIWDblList::GetHead
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\IWDblList.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\IWDblList.cpp
;	COMDAT ?IsEmpty@CIWDblList@@MBEHXZ
_TEXT	SEGMENT
?IsEmpty@CIWDblList@@MBEHXZ PROC			; CIWDblList::IsEmpty, COMDAT
; _this$ = ecx

; 32   : 	if( !m_plDblList) return TRUE;

  00000	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  00003	85 c9		 test	 ecx, ecx
  00005	75 06		 jne	 SHORT $LN2@IsEmpty
  00007	b8 01 00 00 00	 mov	 eax, 1

; 34   : }

  0000c	c3		 ret	 0
$LN2@IsEmpty:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 786  : 	{ return m_nCount == 0; }

  0000d	33 c0		 xor	 eax, eax
  0000f	39 41 0c	 cmp	 DWORD PTR [ecx+12], eax
  00012	0f 94 c0	 sete	 al
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\IWDblList.cpp

; 34   : }

  00015	c3		 ret	 0
?IsEmpty@CIWDblList@@MBEHXZ ENDP			; CIWDblList::IsEmpty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\IWDblList.cpp
;	COMDAT ?GetCount@CIWDblList@@MBEHXZ
_TEXT	SEGMENT
?GetCount@CIWDblList@@MBEHXZ PROC			; CIWDblList::GetCount, COMDAT
; _this$ = ecx

; 27   : 	if( !m_plDblList) return 0;

  00000	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00003	85 c0		 test	 eax, eax
  00005	75 01		 jne	 SHORT $LN2@GetCount

; 29   : }

  00007	c3		 ret	 0
$LN2@GetCount:

; 28   : 	return m_plDblList->GetCount();

  00008	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]

; 29   : }

  0000b	c3		 ret	 0
?GetCount@CIWDblList@@MBEHXZ ENDP			; CIWDblList::GetCount
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
;	COMDAT ??_GCIWrapperManager@CIWDblList@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCIWrapperManager@CIWDblList@@UAEPAXI@Z PROC		; CIWDblList::CIWrapperManager::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CIWrapperManager@CIWDblList@@UAE@XZ ; CIWDblList::CIWrapperManager::~CIWrapperManager
  0000b	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  0000e	a8 01		 test	 al, 1
  00010	74 1f		 je	 SHORT $LN9@scalar
  00012	a8 04		 test	 al, 4
  00014	75 10		 jne	 SHORT $LN3@scalar

; 112  : 	{ ::operator delete(p); }

  00016	56		 push	 esi
  00017	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001c	83 c4 04	 add	 esp, 4
  0001f	8b c6		 mov	 eax, esi
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
$LN3@scalar:
  00026	6a 1c		 push	 28			; 0000001cH
  00028	56		 push	 esi
  00029	e8 00 00 00 00	 call	 ?__global_delete@@YAXPAXI@Z ; __global_delete
  0002e	83 c4 08	 add	 esp, 8
$LN9@scalar:
  00031	8b c6		 mov	 eax, esi
  00033	5e		 pop	 esi
  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
??_GCIWrapperManager@CIWDblList@@UAEPAXI@Z ENDP		; CIWDblList::CIWrapperManager::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\IWDblList.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\IWDblList.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\IWDblList.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\IWDblList.h
;	COMDAT ??1CIWrapperManager@CIWDblList@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1CIWrapperManager@CIWDblList@@UAE@XZ PROC		; CIWDblList::CIWrapperManager::~CIWrapperManager, COMDAT
; _this$ = ecx

; 22   : 	_IWRAPPER_IUNKNOWN_MANAGER( IDblList, CIWDblList, CDblList, m_plDblList);

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CIWrapperManager@CIWDblList@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl

; 337  : 	{ return m_nCount == 0; }

  00025	83 7e 0c 00	 cmp	 DWORD PTR [esi+12], 0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\IWDblList.h

; 22   : 	_IWRAPPER_IUNKNOWN_MANAGER( IDblList, CIWDblList, CDblList, m_plDblList);

  00029	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CIWrapperManager@CIWDblList@@6B@
  0002f	74 1f		 je	 SHORT $LN3@CIWrapperM
$LL2@CIWrapperM:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 1890 : 		{ return (TYPE)BASE_CLASS::RemoveHead(); }

  00031	8b ce		 mov	 ecx, esi
  00033	e8 00 00 00 00	 call	 ?RemoveHead@CPtrList@@QAEPAXXZ ; CPtrList::RemoveHead
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\IWDblList.h

; 22   : 	_IWRAPPER_IUNKNOWN_MANAGER( IDblList, CIWDblList, CDblList, m_plDblList);

  00038	85 c0		 test	 eax, eax
  0003a	74 0e		 je	 SHORT $LN7@CIWrapperM
  0003c	8d 48 f8	 lea	 ecx, DWORD PTR [eax-8]
  0003f	85 c9		 test	 ecx, ecx
  00041	74 07		 je	 SHORT $LN7@CIWrapperM
  00043	8b 01		 mov	 eax, DWORD PTR [ecx]
  00045	6a 01		 push	 1
  00047	ff 50 04	 call	 DWORD PTR [eax+4]
$LN7@CIWrapperM:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxcoll.inl

; 337  : 	{ return m_nCount == 0; }

  0004a	83 7e 0c 00	 cmp	 DWORD PTR [esi+12], 0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\IWDblList.h

; 22   : 	_IWRAPPER_IUNKNOWN_MANAGER( IDblList, CIWDblList, CDblList, m_plDblList);

  0004e	75 e1		 jne	 SHORT $LL2@CIWrapperM
$LN3@CIWrapperM:
  00050	8b ce		 mov	 ecx, esi
  00052	e8 00 00 00 00	 call	 ??1CPtrList@@UAE@XZ	; CPtrList::~CPtrList
  00057	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00061	59		 pop	 ecx
  00062	5e		 pop	 esi
  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c3		 ret	 0
  00067	cc		 int	 3
  00068	cc		 int	 3
  00069	cc		 int	 3
  0006a	cc		 int	 3
  0006b	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1CIWrapperManager@CIWDblList@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CIWrapperManager@CIWDblList@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CIWrapperManager@CIWDblList@@UAE@XZ ENDP		; CIWDblList::CIWrapperManager::~CIWrapperManager
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
;	COMDAT ??_G?$CTypedPtrList@VCPtrList@@PAUIDblList@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CTypedPtrList@VCPtrList@@PAUIDblList@@@@UAEPAXI@Z PROC ; CTypedPtrList<CPtrList,IDblList *>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CPtrList@@UAE@XZ	; CPtrList::~CPtrList
  0000b	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  0000e	a8 01		 test	 al, 1
  00010	74 1f		 je	 SHORT $LN15@scalar
  00012	a8 04		 test	 al, 4
  00014	75 10		 jne	 SHORT $LN3@scalar

; 112  : 	{ ::operator delete(p); }

  00016	56		 push	 esi
  00017	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001c	83 c4 04	 add	 esp, 4
  0001f	8b c6		 mov	 eax, esi
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
$LN3@scalar:
  00026	6a 1c		 push	 28			; 0000001cH
  00028	56		 push	 esi
  00029	e8 00 00 00 00	 call	 ?__global_delete@@YAXPAXI@Z ; __global_delete
  0002e	83 c4 08	 add	 esp, 8
$LN15@scalar:
  00031	8b c6		 mov	 eax, esi
  00033	5e		 pop	 esi
  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
??_G?$CTypedPtrList@VCPtrList@@PAUIDblList@@@@UAEPAXI@Z ENDP ; CTypedPtrList<CPtrList,IDblList *>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
;	COMDAT ??_G?$_CTypedPtrList@VCPtrList@@PAUIDblList@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$_CTypedPtrList@VCPtrList@@PAUIDblList@@@@UAEPAXI@Z PROC ; _CTypedPtrList<CPtrList,IDblList *>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CPtrList@@UAE@XZ	; CPtrList::~CPtrList
  0000b	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  0000e	a8 01		 test	 al, 1
  00010	74 1f		 je	 SHORT $LN12@scalar
  00012	a8 04		 test	 al, 4
  00014	75 10		 jne	 SHORT $LN3@scalar

; 112  : 	{ ::operator delete(p); }

  00016	56		 push	 esi
  00017	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001c	83 c4 04	 add	 esp, 4
  0001f	8b c6		 mov	 eax, esi
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
$LN3@scalar:
  00026	6a 1c		 push	 28			; 0000001cH
  00028	56		 push	 esi
  00029	e8 00 00 00 00	 call	 ?__global_delete@@YAXPAXI@Z ; __global_delete
  0002e	83 c4 08	 add	 esp, 8
$LN12@scalar:
  00031	8b c6		 mov	 eax, esi
  00033	5e		 pop	 esi
  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
??_G?$_CTypedPtrList@VCPtrList@@PAUIDblList@@@@UAEPAXI@Z ENDP ; _CTypedPtrList<CPtrList,IDblList *>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
;	COMDAT ?Dump@CObject@@UBEXAAVCDumpContext@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?Dump@CObject@@UBEXAAVCDumpContext@@@Z PROC		; CObject::Dump, COMDAT
; _this$ = ecx

; 122  : 	{ /* no dumping in release builds */ }

  00000	c2 04 00	 ret	 4
?Dump@CObject@@UBEXAAVCDumpContext@@@Z ENDP		; CObject::Dump
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
;	COMDAT ?AssertValid@CObject@@UBEXXZ
_TEXT	SEGMENT
?AssertValid@CObject@@UBEXXZ PROC			; CObject::AssertValid, COMDAT
; _this$ = ecx

; 120  : 	{ /* no asserts in release builds */ }

  00000	c2 00 00	 ret	 0
?AssertValid@CObject@@UBEXXZ ENDP			; CObject::AssertValid
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afx.inl
;	COMDAT ?Serialize@CObject@@UAEXAAVCArchive@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?Serialize@CObject@@UAEXAAVCArchive@@@Z PROC		; CObject::Serialize, COMDAT
; _this$ = ecx

; 106  : 	{ /* CObject does not serialize anything by default */ }

  00000	c2 04 00	 ret	 4
?Serialize@CObject@@UAEXAAVCArchive@@@Z ENDP		; CObject::Serialize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\IWDblList.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	c2 00 00	 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\AddInManager\ChartCommonAddIn\IWDblList.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

  00000	c2 00 00	 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
