; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30145.0 

	TITLE	D:\git\src\IBK\IBK_DRFN\#DRfn-CS\_Obj\ChartFormulate\Signal.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0N@FMCKNONO@SignalPacket@			; `string'
;	COMDAT ??_C@_0N@FMCKNONO@SignalPacket@
CONST	SEGMENT
??_C@_0N@FMCKNONO@SignalPacket@ DB 'SignalPacket', 00H	; `string'
CONST	ENDS
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@ABV10@0@Z ; ATL::operator+
PUBLIC	??0CSignal@@QAE@XZ				; CSignal::CSignal
PUBLIC	??1CSignal@@UAE@XZ				; CSignal::~CSignal
PUBLIC	?GetSignalDataPacket@CSignal@@QBE_NABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAVCPacketList@@AAPAVCPacket@@@Z ; CSignal::GetSignalDataPacket
PUBLIC	?GetSignalDatas@CSignal@@QAEXABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAVCPacketList@@AAPAV?$CList@NN@@@Z ; CSignal::GetSignalDatas
PUBLIC	?GetSignalTypesbyUsingGraphDatas@CSignal@@QAEXABVCPoint@@PAV?$CList@NN@@1PAVCPacket@@@Z ; CSignal::GetSignalTypesbyUsingGraphDatas
PUBLIC	?MakeRealPacket@CSignal@@AAEXABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAV?$CList@NN@@AAV4@@Z ; CSignal::MakeRealPacket
PUBLIC	?GetSignalType@CSignal@@AAE?AW4SignalTYPE@CGraphBaseData@@NNNN@Z ; CSignal::GetSignalType
PUBLIC	?GetSignalType@CSignal@@AAE?AW4SignalTYPE@CGraphBaseData@@NNN@Z ; CSignal::GetSignalType
PUBLIC	?GetSignalType3@CSignal@@AAE?AW4SignalTYPE@CGraphBaseData@@NNNN@Z ; CSignal::GetSignalType3
PUBLIC	?GetCurDataFromList@CSignal@@AAENAAPAU__POSITION@@PAV?$CList@NN@@@Z ; CSignal::GetCurDataFromList
PUBLIC	?GetFirstNonZeroValueIndex@CSignal@@AAEHPAV?$CList@NN@@@Z ; CSignal::GetFirstNonZeroValueIndex
PUBLIC	?GetSignalTypesbyUsingGraphDataandTwoBaseLine@CSignal@@AAEXABVCPoint@@PAV?$CList@NN@@1PAVCPacket@@@Z ; CSignal::GetSignalTypesbyUsingGraphDataandTwoBaseLine
PUBLIC	?GetSignalTypesbyUsingGraphDataandOneBaseLine@CSignal@@AAEXABVCPoint@@PAV?$CList@NN@@1PAVCPacket@@@Z ; CSignal::GetSignalTypesbyUsingGraphDataandOneBaseLine
PUBLIC	?GetSignalTypesbyUsingGraphDataandMinMaxBaseLine@CSignal@@AAEXABVCPoint@@PAV?$CList@NN@@1PAVCPacket@@@Z ; CSignal::GetSignalTypesbyUsingGraphDataandMinMaxBaseLine
PUBLIC	?GetSignalDatabyUsingGraphDataandTwoBaseLine@CSignal@@AAEXABVCPoint@@NNPAV?$CList@NN@@PAVCPacket@@@Z ; CSignal::GetSignalDatabyUsingGraphDataandTwoBaseLine
PUBLIC	?GetSignalDatabyUsingGraphDataandOneBaseLine@CSignal@@AAEXABVCPoint@@NPAV?$CList@NN@@PAVCPacket@@@Z ; CSignal::GetSignalDatabyUsingGraphDataandOneBaseLine
PUBLIC	?GetPacketDataList@CSignal@@AAEXABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@0PAVCPacketList@@AAV?$CList@NN@@@Z ; CSignal::GetPacketDataList
PUBLIC	?GetPoint@CSignal@@AAE?AVCPoint@@PAVCPacketList@@PAVCPacket@@@Z ; CSignal::GetPoint
PUBLIC	?SetData@CSignal@@AAEXABVCPoint@@HNPAVCPacket@@@Z ; CSignal::SetData
PUBLIC	??_GCSignal@@UAEPAXI@Z				; CSignal::`scalar deleting destructor'
PUBLIC	?AddTail@?$CList@NN@@QAEPAU__POSITION@@N@Z	; CList<double,double>::AddTail
PUBLIC	?FindIndex@?$CList@NN@@QBEPAU__POSITION@@H@Z	; CList<double,double>::FindIndex
PUBLIC	?NewNode@?$CList@NN@@IAEPAUCNode@1@PAU21@0@Z	; CList<double,double>::NewNode
PUBLIC	??_7CSignal@@6B@				; CSignal::`vftable'
PUBLIC	??_R4CSignal@@6B@				; CSignal::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCSignal@@@8				; CSignal `RTTI Type Descriptor'
PUBLIC	??_R3CSignal@@8					; CSignal::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CSignal@@8					; CSignal::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CSignal@@8			; CSignal::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@0000000000000000
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	?AfxThrowInvalidArgException@@YGXXZ:PROC	; AfxThrowInvalidArgException
EXTRN	__imp_?Concatenate@?$CSimpleStringT@D$00@ATL@@KAXAAV12@PBDH1H@Z:PROC
EXTRN	__imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PAUIAtlStringMgr@1@@Z:PROC
EXTRN	__imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z:PROC
EXTRN	__imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z:PROC
EXTRN	__imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ:PROC
EXTRN	__imp_?GetManager@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEPAUIAtlStringMgr@2@XZ:PROC
EXTRN	?Create@CPlex@@SGPAU1@AAPAU1@II@Z:PROC		; CPlex::Create
EXTRN	??_ECSignal@@UAEPAXI@Z:PROC			; CSignal::`vector deleting destructor'
EXTRN	__imp_?GetnumericDataList@CPacket@@QAEPAV?$CList@NN@@XZ:PROC
EXTRN	__imp_?AppendData@CPacket@@QAEXNH@Z:PROC
EXTRN	__imp_?UpdateData@CPacket@@QAEXNH_N@Z:PROC
EXTRN	__imp_?GetMaxCount@CPacketList@@QAEHXZ:PROC
EXTRN	__imp_?GetnumericDataList@CPacketList@@QAEPAV?$CList@NN@@PAVCPacket@@@Z:PROC
EXTRN	__imp_?GetBaseData@CPacketList@@QAEPAVCPacket@@V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@_N@Z:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?g_iMetaTable@@3VIMetaTable@@A:BYTE		; g_iMetaTable
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
?SIGNAL_PACKET@@3V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@B DD 01H DUP (?) ; SIGNAL_PACKET
_BSS	ENDS
CRT$XCU	SEGMENT
?SIGNAL_PACKET$initializer$@@3P6AXXZA DD FLAT:??__ESIGNAL_PACKET@@YAXXZ ; SIGNAL_PACKET$initializer$
CRT$XCU	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@CSignal@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CSignal@@8 DD FLAT:??_R0?AVCSignal@@@8	; CSignal::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CSignal@@8
rdata$r	ENDS
;	COMDAT ??_R2CSignal@@8
rdata$r	SEGMENT
??_R2CSignal@@8 DD FLAT:??_R1A@?0A@EA@CSignal@@8	; CSignal::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CSignal@@8
rdata$r	SEGMENT
??_R3CSignal@@8 DD 00H					; CSignal::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CSignal@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCSignal@@@8
data$rs	SEGMENT
??_R0?AVCSignal@@@8 DD FLAT:??_7type_info@@6B@		; CSignal `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCSignal@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CSignal@@6B@
rdata$r	SEGMENT
??_R4CSignal@@6B@ DD 00H				; CSignal::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCSignal@@@8
	DD	FLAT:??_R3CSignal@@8
rdata$r	ENDS
;	COMDAT ??_7CSignal@@6B@
CONST	SEGMENT
??_7CSignal@@6B@ DD FLAT:??_R4CSignal@@6B@		; CSignal::`vftable'
	DD	FLAT:??_ECSignal@@UAEPAXI@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?GetSignalDatas@CSignal@@QAEXABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAVCPacketList@@AAPAV?$CList@NN@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetSignalDatas@CSignal@@QAEXABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAVCPacketList@@AAPAV?$CList@NN@@@Z$0
__ehfuncinfo$?GetSignalDatas@CSignal@@QAEXABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAVCPacketList@@AAPAV?$CList@NN@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetSignalDatas@CSignal@@QAEXABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAVCPacketList@@AAPAV?$CList@NN@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@ABV10@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@ABV10@0@Z$0
__ehfuncinfo$??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@ABV10@0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@ABV10@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ?NewNode@?$CList@NN@@IAEPAUCNode@1@PAU21@0@Z
_TEXT	SEGMENT
_pPrev$ = 8						; size = 4
_pNext$ = 12						; size = 4
?NewNode@?$CList@NN@@IAEPAUCNode@1@PAU21@0@Z PROC	; CList<double,double>::NewNode, COMDAT
; _this$ = ecx

; 901  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 902  : 	if (m_pNodeFree == NULL)

  00006	83 7e 10 00	 cmp	 DWORD PTR [esi+16], 0
  0000a	75 34		 jne	 SHORT $LN7@NewNode

; 903  : 	{
; 904  : 		// add another block
; 905  : 		CPlex* pNewBlock = CPlex::Create(m_pBlocks, m_nBlockSize,

  0000c	6a 10		 push	 16			; 00000010H
  0000e	ff 76 18	 push	 DWORD PTR [esi+24]
  00011	8d 46 14	 lea	 eax, DWORD PTR [esi+20]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ?Create@CPlex@@SGPAU1@AAPAU1@II@Z ; CPlex::Create

; 906  : 				 sizeof(CNode));
; 907  : 
; 908  : 		// chain them into free list
; 909  : 		CNode* pNode = (CNode*) pNewBlock->data();
; 910  : 		// free in reverse order to make it easier to debug
; 911  : 		pNode += m_nBlockSize - 1;

  0001a	8b 56 18	 mov	 edx, DWORD PTR [esi+24]
  0001d	83 c0 08	 add	 eax, 8
  00020	8b ca		 mov	 ecx, edx
  00022	c1 e1 04	 shl	 ecx, 4
  00025	83 c1 f0	 add	 ecx, -16		; fffffff0H
  00028	03 c1		 add	 eax, ecx

; 912  : 		for (INT_PTR i = m_nBlockSize-1; i >= 0; i--, pNode--)

  0002a	83 c2 ff	 add	 edx, -1
  0002d	78 11		 js	 SHORT $LN7@NewNode
  0002f	90		 npad	 1
$LL4@NewNode:

; 913  : 		{
; 914  : 			pNode->pNext = m_pNodeFree;

  00030	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00033	89 08		 mov	 DWORD PTR [eax], ecx

; 915  : 			m_pNodeFree = pNode;

  00035	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00038	83 e8 10	 sub	 eax, 16			; 00000010H
  0003b	83 ea 01	 sub	 edx, 1
  0003e	79 f0		 jns	 SHORT $LL4@NewNode
$LN7@NewNode:

; 916  : 		}
; 917  : 	}
; 918  : 	ENSURE(m_pNodeFree != NULL);  // we must have something

  00040	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00043	85 c0		 test	 eax, eax
  00045	74 18		 je	 SHORT $LN17@NewNode

; 919  : 
; 920  : 	CList::CNode* pNode = m_pNodeFree;
; 921  : 	m_pNodeFree = m_pNodeFree->pNext;

  00047	8b 08		 mov	 ecx, DWORD PTR [eax]
  00049	89 4e 10	 mov	 DWORD PTR [esi+16], ecx

; 922  : 	pNode->pPrev = pPrev;

  0004c	8b 4d 08	 mov	 ecx, DWORD PTR _pPrev$[ebp]
  0004f	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 923  : 	pNode->pNext = pNext;

  00052	8b 4d 0c	 mov	 ecx, DWORD PTR _pNext$[ebp]
  00055	89 08		 mov	 DWORD PTR [eax], ecx

; 924  : 	m_nCount++;

  00057	ff 46 0c	 inc	 DWORD PTR [esi+12]

; 925  : 	ASSERT(m_nCount > 0);  // make sure we don't overflow
; 926  : 
; 927  : #pragma push_macro("new")
; 928  : #undef new
; 929  : 	::new( (void*)( &pNode->data ) ) TYPE;
; 930  : #pragma pop_macro("new")
; 931  : 	return pNode;

  0005a	5e		 pop	 esi

; 932  : }

  0005b	5d		 pop	 ebp
  0005c	c2 08 00	 ret	 8
$LN17@NewNode:

; 916  : 		}
; 917  : 	}
; 918  : 	ENSURE(m_pNodeFree != NULL);  // we must have something

  0005f	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN15@NewNode:
  00064	cc		 int	 3
?NewNode@?$CList@NN@@IAEPAUCNode@1@PAU21@0@Z ENDP	; CList<double,double>::NewNode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ?FindIndex@?$CList@NN@@QBEPAU__POSITION@@H@Z
_TEXT	SEGMENT
_nIndex$ = 8						; size = 4
?FindIndex@?$CList@NN@@QBEPAU__POSITION@@H@Z PROC	; CList<double,double>::FindIndex, COMDAT
; _this$ = ecx

; 1130 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1131 : 	ASSERT_VALID(this);
; 1132 : 
; 1133 : 	if (nIndex >= m_nCount || nIndex < 0)

  00003	8b 55 08	 mov	 edx, DWORD PTR _nIndex$[ebp]
  00006	3b 51 0c	 cmp	 edx, DWORD PTR [ecx+12]
  00009	7d 14		 jge	 SHORT $LN5@FindIndex
  0000b	85 d2		 test	 edx, edx
  0000d	78 10		 js	 SHORT $LN5@FindIndex

; 1135 : 
; 1136 : 	CNode* pNode = m_pNodeHead;

  0000f	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 1137 : 	while (nIndex--)

  00012	74 0d		 je	 SHORT $LN1@FindIndex
$LL2@FindIndex:

; 1138 : 	{
; 1139 : 		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 1140 : 		pNode = pNode->pNext;

  00014	8b 00		 mov	 eax, DWORD PTR [eax]
  00016	83 ea 01	 sub	 edx, 1
  00019	75 f9		 jne	 SHORT $LL2@FindIndex

; 1141 : 	}
; 1142 : 	return (POSITION) pNode;
; 1143 : }

  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
$LN5@FindIndex:

; 1134 : 		return NULL;  // went too far

  0001f	33 c0		 xor	 eax, eax
$LN1@FindIndex:

; 1141 : 	}
; 1142 : 	return (POSITION) pNode;
; 1143 : }

  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
?FindIndex@?$CList@NN@@QBEPAU__POSITION@@H@Z ENDP	; CList<double,double>::FindIndex
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
;	COMDAT ?AddTail@?$CList@NN@@QAEPAU__POSITION@@N@Z
_TEXT	SEGMENT
_newElement$ = 8					; size = 8
?AddTail@?$CList@NN@@QAEPAU__POSITION@@N@Z PROC		; CList<double,double>::AddTail, COMDAT
; _this$ = ecx

; 965  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	57		 push	 edi

; 902  : 	if (m_pNodeFree == NULL)

  00007	83 7e 10 00	 cmp	 DWORD PTR [esi+16], 0

; 966  : 	ASSERT_VALID(this);
; 967  : 
; 968  : 	CNode* pNewNode = NewNode(m_pNodeTail, NULL);

  0000b	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]

; 902  : 	if (m_pNodeFree == NULL)

  0000e	75 33		 jne	 SHORT $LN11@AddTail

; 903  : 	{
; 904  : 		// add another block
; 905  : 		CPlex* pNewBlock = CPlex::Create(m_pBlocks, m_nBlockSize,

  00010	6a 10		 push	 16			; 00000010H
  00012	ff 76 18	 push	 DWORD PTR [esi+24]
  00015	8d 46 14	 lea	 eax, DWORD PTR [esi+20]
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ?Create@CPlex@@SGPAU1@AAPAU1@II@Z ; CPlex::Create

; 906  : 				 sizeof(CNode));
; 907  : 
; 908  : 		// chain them into free list
; 909  : 		CNode* pNode = (CNode*) pNewBlock->data();
; 910  : 		// free in reverse order to make it easier to debug
; 911  : 		pNode += m_nBlockSize - 1;

  0001e	8b 56 18	 mov	 edx, DWORD PTR [esi+24]
  00021	83 c0 08	 add	 eax, 8
  00024	8b ca		 mov	 ecx, edx
  00026	c1 e1 04	 shl	 ecx, 4
  00029	83 c1 f0	 add	 ecx, -16		; fffffff0H
  0002c	03 c8		 add	 ecx, eax

; 912  : 		for (INT_PTR i = m_nBlockSize-1; i >= 0; i--, pNode--)

  0002e	83 c2 ff	 add	 edx, -1
  00031	78 10		 js	 SHORT $LN11@AddTail
$LL8@AddTail:

; 913  : 		{
; 914  : 			pNode->pNext = m_pNodeFree;

  00033	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00036	89 01		 mov	 DWORD PTR [ecx], eax

; 915  : 			m_pNodeFree = pNode;

  00038	89 4e 10	 mov	 DWORD PTR [esi+16], ecx
  0003b	83 e9 10	 sub	 ecx, 16			; 00000010H
  0003e	83 ea 01	 sub	 edx, 1
  00041	79 f0		 jns	 SHORT $LL8@AddTail
$LN11@AddTail:

; 916  : 		}
; 917  : 	}
; 918  : 	ENSURE(m_pNodeFree != NULL);  // we must have something

  00043	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00046	85 c9		 test	 ecx, ecx
  00048	74 3d		 je	 SHORT $LN22@AddTail

; 919  : 
; 920  : 	CList::CNode* pNode = m_pNodeFree;
; 921  : 	m_pNodeFree = m_pNodeFree->pNext;

  0004a	8b 01		 mov	 eax, DWORD PTR [ecx]

; 969  : 	pNewNode->data = newElement;

  0004c	f2 0f 10 45 08	 movsd	 xmm0, QWORD PTR _newElement$[ebp]

; 921  : 	m_pNodeFree = m_pNodeFree->pNext;

  00051	89 46 10	 mov	 DWORD PTR [esi+16], eax

; 922  : 	pNode->pPrev = pPrev;

  00054	89 79 04	 mov	 DWORD PTR [ecx+4], edi

; 923  : 	pNode->pNext = pNext;

  00057	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 924  : 	m_nCount++;

  0005d	ff 46 0c	 inc	 DWORD PTR [esi+12]

; 969  : 	pNewNode->data = newElement;

  00060	f2 0f 11 41 08	 movsd	 QWORD PTR [ecx+8], xmm0

; 970  : 	if (m_pNodeTail != NULL)

  00065	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00068	85 c0		 test	 eax, eax
  0006a	74 0d		 je	 SHORT $LN2@AddTail

; 971  : 		m_pNodeTail->pNext = pNewNode;

  0006c	89 08		 mov	 DWORD PTR [eax], ecx

; 972  : 	else
; 973  : 		m_pNodeHead = pNewNode;
; 974  : 	m_pNodeTail = pNewNode;
; 975  : 	return (POSITION) pNewNode;

  0006e	8b c1		 mov	 eax, ecx
  00070	5f		 pop	 edi
  00071	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00074	5e		 pop	 esi

; 976  : }

  00075	5d		 pop	 ebp
  00076	c2 08 00	 ret	 8
$LN2@AddTail:

; 972  : 	else
; 973  : 		m_pNodeHead = pNewNode;
; 974  : 	m_pNodeTail = pNewNode;
; 975  : 	return (POSITION) pNewNode;

  00079	5f		 pop	 edi
  0007a	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  0007d	8b c1		 mov	 eax, ecx
  0007f	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00082	5e		 pop	 esi

; 976  : }

  00083	5d		 pop	 ebp
  00084	c2 08 00	 ret	 8
$LN22@AddTail:

; 918  : 	ENSURE(m_pNodeFree != NULL);  // we must have something

  00087	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN20@AddTail:
  0008c	cc		 int	 3
?AddTail@?$CList@NN@@QAEPAU__POSITION@@N@Z ENDP		; CList<double,double>::AddTail
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__FSIGNAL_PACKET@@YAXXZ
text$yd	SEGMENT
??__FSIGNAL_PACKET@@YAXXZ PROC				; `dynamic atexit destructor for 'SIGNAL_PACKET'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?SIGNAL_PACKET@@3V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@B
  00005	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
??__FSIGNAL_PACKET@@YAXXZ ENDP				; `dynamic atexit destructor for 'SIGNAL_PACKET''
text$yd	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartFormulate\ChartFormlateBaseData.h
;	COMDAT ??__ESIGNAL_PACKET@@YAXXZ
text$di	SEGMENT
??__ESIGNAL_PACKET@@YAXXZ PROC				; `dynamic initializer for 'SIGNAL_PACKET'', COMDAT

; 13   : static const CString SIGNAL_PACKET = "SignalPacket";

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0N@FMCKNONO@SignalPacket@
  00005	b9 00 00 00 00	 mov	 ecx, OFFSET ?SIGNAL_PACKET@@3V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@B
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  00010	68 00 00 00 00	 push	 OFFSET ??__FSIGNAL_PACKET@@YAXXZ ; `dynamic atexit destructor for 'SIGNAL_PACKET''
  00015	e8 00 00 00 00	 call	 _atexit
  0001a	59		 pop	 ecx
  0001b	c3		 ret	 0
??__ESIGNAL_PACKET@@YAXXZ ENDP				; `dynamic initializer for 'SIGNAL_PACKET''
text$di	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GCSignal@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCSignal@@UAEPAXI@Z PROC				; CSignal::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CSignal@@6B@
  00010	74 0b		 je	 SHORT $LN4@scalar
  00012	6a 04		 push	 4
  00014	56		 push	 esi
  00015	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001a	83 c4 08	 add	 esp, 8
$LN4@scalar:
  0001d	8b c6		 mov	 eax, esi
  0001f	5e		 pop	 esi
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??_GCSignal@@UAEPAXI@Z ENDP				; CSignal::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartFormulate\Signal.cpp
;	COMDAT ?SetData@CSignal@@AAEXABVCPoint@@HNPAVCPacket@@@Z
_TEXT	SEGMENT
_point$ = 8						; size = 4
_nUpdateIndex$ = 12					; size = 4
_dData$ = 16						; size = 8
_pPacket$ = 24						; size = 4
?SetData@CSignal@@AAEXABVCPoint@@HNPAVCPacket@@@Z PROC	; CSignal::SetData, COMDAT
; _this$ = ecx

; 146  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 147  : 	if(point.x == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR _point$[ebp]
  00006	f2 0f 10 45 10	 movsd	 xmm0, QWORD PTR _dData$[ebp]
  0000b	8b 4d 18	 mov	 ecx, DWORD PTR _pPacket$[ebp]
  0000e	83 38 00	 cmp	 DWORD PTR [eax], 0
  00011	75 14		 jne	 SHORT $LN2@SetData

; 148  : 		pPacket->AppendData(dData);

  00013	6a ff		 push	 -1
  00015	83 ec 08	 sub	 esp, 8
  00018	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0001d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?AppendData@CPacket@@QAEXNH@Z

; 151  : }

  00023	5d		 pop	 ebp
  00024	c2 14 00	 ret	 20			; 00000014H
$LN2@SetData:

; 149  : 	else
; 150  : 		pPacket->UpdateData(dData, nUpdateIndex, false);

  00027	6a 00		 push	 0
  00029	ff 75 0c	 push	 DWORD PTR _nUpdateIndex$[ebp]
  0002c	83 ec 08	 sub	 esp, 8
  0002f	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00034	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?UpdateData@CPacket@@QAEXNH_N@Z

; 151  : }

  0003a	5d		 pop	 ebp
  0003b	c2 14 00	 ret	 20			; 00000014H
?SetData@CSignal@@AAEXABVCPoint@@HNPAVCPacket@@@Z ENDP	; CSignal::SetData
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartFormulate\Signal.cpp
;	COMDAT ?GetPoint@CSignal@@AAE?AVCPoint@@PAVCPacketList@@PAVCPacket@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_pPacketList$ = 12					; size = 4
_pSignalPacket$ = 16					; size = 4
?GetPoint@CSignal@@AAE?AVCPoint@@PAVCPacketList@@PAVCPacket@@@Z PROC ; CSignal::GetPoint, COMDAT
; _this$ = ecx

; 128  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 129  : 	CPoint point(-1, -1);
; 130  : 	if(pPacketList == NULL || pSignalPacket == NULL)

  00005	8b 7d 0c	 mov	 edi, DWORD PTR _pPacketList$[ebp]
  00008	85 ff		 test	 edi, edi
  0000a	74 57		 je	 SHORT $LN3@GetPoint
  0000c	8b 75 10	 mov	 esi, DWORD PTR _pSignalPacket$[ebp]
  0000f	85 f6		 test	 esi, esi
  00011	74 50		 je	 SHORT $LN3@GetPoint

; 132  : 
; 133  : 	CPacket* pPacket = pPacketList->GetBaseData( _MTEXT( C0_CLOSE));//"종가"

  00013	a1 54 00 00 00	 mov	 eax, DWORD PTR ?g_iMetaTable@@3VIMetaTable@@A+84
  00018	6a 01		 push	 1
  0001a	51		 push	 ecx
  0001b	8b cc		 mov	 ecx, esp
  0001d	ff 70 14	 push	 DWORD PTR [eax+20]
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  00026	8b cf		 mov	 ecx, edi
  00028	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetBaseData@CPacketList@@QAEPAVCPacket@@V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@_N@Z

; 134  : 	if(pPacket == NULL)

  0002e	85 c0		 test	 eax, eax
  00030	74 31		 je	 SHORT $LN3@GetPoint

; 135  : 		return point;
; 136  : 	if(pSignalPacket->GetCount() == 0)

  00032	8b 06		 mov	 eax, DWORD PTR [esi]
  00034	8b ce		 mov	 ecx, esi
  00036	ff 50 14	 call	 DWORD PTR [eax+20]
  00039	85 c0		 test	 eax, eax
  0003b	75 04		 jne	 SHORT $LN5@GetPoint

; 137  : 		point.x = 0;

  0003d	33 f6		 xor	 esi, esi
  0003f	eb 0a		 jmp	 SHORT $LN6@GetPoint
$LN5@GetPoint:

; 138  : 	else
; 139  : 		point.x = pSignalPacket->GetCount() - 1;

  00041	8b 06		 mov	 eax, DWORD PTR [esi]
  00043	8b ce		 mov	 ecx, esi
  00045	ff 50 14	 call	 DWORD PTR [eax+20]
  00048	8d 70 ff	 lea	 esi, DWORD PTR [eax-1]
$LN6@GetPoint:

; 140  : 	point.y = pPacketList->GetMaxCount();

  0004b	8b cf		 mov	 ecx, edi
  0004d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetMaxCount@CPacketList@@QAEHXZ
  00053	8b c8		 mov	 ecx, eax

; 141  : 	
; 142  : 	return point;

  00055	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00058	89 30		 mov	 DWORD PTR [eax], esi
  0005a	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 143  : }

  0005d	5f		 pop	 edi
  0005e	5e		 pop	 esi
  0005f	5d		 pop	 ebp
  00060	c2 0c 00	 ret	 12			; 0000000cH
$LN3@GetPoint:

; 131  : 		return point;

  00063	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 143  : }

  00066	5f		 pop	 edi
  00067	5e		 pop	 esi
  00068	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  0006e	c7 40 04 ff ff
	ff ff		 mov	 DWORD PTR [eax+4], -1
  00075	5d		 pop	 ebp
  00076	c2 0c 00	 ret	 12			; 0000000cH
?GetPoint@CSignal@@AAE?AVCPoint@@PAVCPacketList@@PAVCPacket@@@Z ENDP ; CSignal::GetPoint
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartFormulate\Signal.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartFormulate\Signal.cpp
;	COMDAT ?GetPacketDataList@CSignal@@AAEXABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@0PAVCPacketList@@AAV?$CList@NN@@@Z
_TEXT	SEGMENT
_strGraphName$ = 8					; size = 4
_strSubGraphName$ = 12					; size = 4
_pPacketList$ = 16					; size = 4
_dRealDataList$ = 20					; size = 4
?GetPacketDataList@CSignal@@AAEXABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@0PAVCPacketList@@AAV?$CList@NN@@@Z PROC ; CSignal::GetPacketDataList, COMDAT
; _this$ = ecx

; 115  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 116  : 	if(pPacketList == NULL) return;

  00004	8b 75 10	 mov	 esi, DWORD PTR _pPacketList$[ebp]
  00007	57		 push	 edi
  00008	85 f6		 test	 esi, esi
  0000a	74 60		 je	 SHORT $LN9@GetPacketD

; 117  : 
; 118  : 	CPacket* pPacket = NULL;
; 119  : 	pPacket = pPacketList->GetBaseData(strSubGraphName);

  0000c	6a 01		 push	 1
  0000e	51		 push	 ecx
  0000f	8b cc		 mov	 ecx, esp
  00011	ff 75 0c	 push	 DWORD PTR _strSubGraphName$[ebp]
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z
  0001a	8b ce		 mov	 ecx, esi
  0001c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetBaseData@CPacketList@@QAEPAVCPacket@@V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@_N@Z
  00022	8b f8		 mov	 edi, eax

; 120  : 
; 121  : 	if(pPacket == NULL)	return;

  00024	85 ff		 test	 edi, edi
  00026	74 44		 je	 SHORT $LN9@GetPacketD

; 122  : 
; 123  : 	if(pPacketList->GetnumericDataList(pPacket)->GetCount() <= 0) return;

  00028	57		 push	 edi
  00029	8b ce		 mov	 ecx, esi
  0002b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetnumericDataList@CPacketList@@QAEPAV?$CList@NN@@PAVCPacket@@@Z
  00031	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  00035	7e 35		 jle	 SHORT $LN9@GetPacketD

; 124  : 	MakeRealPacket(strGraphName, pPacketList->GetnumericDataList(pPacket), dRealDataList);

  00037	57		 push	 edi
  00038	8b ce		 mov	 ecx, esi
  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetnumericDataList@CPacketList@@QAEPAV?$CList@NN@@PAVCPacket@@@Z

; 414  : 	if(pDataList == NULL)

  00040	85 c0		 test	 eax, eax
  00042	74 28		 je	 SHORT $LN9@GetPacketD

; 415  : 		return;
; 416  : 
; 417  : 	for(POSITION pos = pDataList->GetHeadPosition(); pos ; ) {

  00044	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  00047	85 f6		 test	 esi, esi
  00049	74 21		 je	 SHORT $LN9@GetPacketD
  0004b	8b 7d 14	 mov	 edi, DWORD PTR _dRealDataList$[ebp]
  0004e	66 90		 npad	 2
$LL8@GetPacketD:

; 419  : 		dRealDataList.AddTail(data);

  00050	f2 0f 10 46 08	 movsd	 xmm0, QWORD PTR [esi+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 811  : 	{ CNode* pNode = (CNode*) rPosition;

  00055	8d 06		 lea	 eax, DWORD PTR [esi]

; 812  : 		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 813  : 		rPosition = (POSITION) pNode->pNext;

  00057	8b 36		 mov	 esi, DWORD PTR [esi]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartFormulate\Signal.cpp

; 419  : 		dRealDataList.AddTail(data);

  00059	83 ec 08	 sub	 esp, 8
  0005c	8b cf		 mov	 ecx, edi
  0005e	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00063	e8 00 00 00 00	 call	 ?AddTail@?$CList@NN@@QAEPAU__POSITION@@N@Z ; CList<double,double>::AddTail
  00068	85 f6		 test	 esi, esi
  0006a	75 e4		 jne	 SHORT $LL8@GetPacketD
$LN9@GetPacketD:

; 125  : }

  0006c	5f		 pop	 edi
  0006d	5e		 pop	 esi
  0006e	5d		 pop	 ebp
  0006f	c2 10 00	 ret	 16			; 00000010H
?GetPacketDataList@CSignal@@AAEXABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@0PAVCPacketList@@AAV?$CList@NN@@@Z ENDP ; CSignal::GetPacketDataList
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartFormulate\Signal.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartFormulate\Signal.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartFormulate\Signal.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartFormulate\Signal.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartFormulate\Signal.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartFormulate\Signal.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartFormulate\Signal.cpp
;	COMDAT ?GetSignalDatabyUsingGraphDataandOneBaseLine@CSignal@@AAEXABVCPoint@@NPAV?$CList@NN@@PAVCPacket@@@Z
_TEXT	SEGMENT
tv500 = -4						; size = 4
_point$ = 8						; size = 4
_nBaseline$ = 12					; size = 8
_nCnt$1$ = 20						; size = 4
_pGraphData$ = 20					; size = 4
_pSignalPacket$ = 24					; size = 4
?GetSignalDatabyUsingGraphDataandOneBaseLine@CSignal@@AAEXABVCPoint@@NPAV?$CList@NN@@PAVCPacket@@@Z PROC ; CSignal::GetSignalDatabyUsingGraphDataandOneBaseLine, COMDAT
; _this$ = ecx

; 225  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 226  : 	if(pGraphData == NULL) return;

  00005	8b 75 14	 mov	 esi, DWORD PTR _pGraphData$[ebp]
  00008	85 f6		 test	 esi, esi
  0000a	0f 84 6f 01 00
	00		 je	 $LN11@GetSignalD

; 358  : 	const int nCnt = pGraphData1->GetCount();

  00010	53		 push	 ebx
  00011	8b 5e 0c	 mov	 ebx, DWORD PTR [esi+12]

; 359  : 	POSITION pos = pGraphData1->GetHeadPosition();
; 360  : 	if(pos == NULL)

  00014	33 c9		 xor	 ecx, ecx
  00016	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
  00019	8b d6		 mov	 edx, esi
  0001b	89 5d 14	 mov	 DWORD PTR _nCnt$1$[ebp], ebx
  0001e	85 d2		 test	 edx, edx
  00020	74 29		 je	 SHORT $LN15@GetSignalD

; 361  : 		return 0;
; 362  : 	for(int start = 0; start < nCnt; start++)

  00022	85 db		 test	 ebx, ebx
  00024	7e 22		 jle	 SHORT $LN17@GetSignalD
  00026	0f 57 c9	 xorps	 xmm1, xmm1
  00029	0f 1f 80 00 00
	00 00		 npad	 7
$LL18@GetSignalD:

; 364  : 		if(pGraphData1->GetNext(pos) != 0)

  00030	f2 0f 10 42 08	 movsd	 xmm0, QWORD PTR [edx+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 811  : 	{ CNode* pNode = (CNode*) rPosition;

  00035	8d 02		 lea	 eax, DWORD PTR [edx]

; 813  : 		rPosition = (POSITION) pNode->pNext;

  00037	8b 12		 mov	 edx, DWORD PTR [edx]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartFormulate\Signal.cpp

; 364  : 		if(pGraphData1->GetNext(pos) != 0)

  00039	66 0f 2e c1	 ucomisd xmm0, xmm1
  0003d	9f		 lahf
  0003e	f6 c4 44	 test	 ah, 68			; 00000044H
  00041	7a 08		 jp	 SHORT $LN15@GetSignalD

; 361  : 		return 0;
; 362  : 	for(int start = 0; start < nCnt; start++)

  00043	41		 inc	 ecx
  00044	3b cb		 cmp	 ecx, ebx
  00046	7c e8		 jl	 SHORT $LL18@GetSignalD
$LN17@GetSignalD:

; 365  : 			return start;
; 366  : 	return pGraphData1->GetCount()-1;

  00048	8d 4b ff	 lea	 ecx, DWORD PTR [ebx-1]
$LN15@GetSignalD:

; 227  : 	int nFirstNonZeroValue = GetFirstNonZeroValueIndex(pGraphData);
; 228  : 	const int nCnt = pGraphData->GetCount();
; 229  : 
; 230  : 	POSITION prepos = NULL, pos = NULL;
; 231  : 	if(point.x == 0)

  0004b	8b 45 08	 mov	 eax, DWORD PTR _point$[ebp]
  0004e	57		 push	 edi
  0004f	33 ff		 xor	 edi, edi
  00051	8b 18		 mov	 ebx, DWORD PTR [eax]
  00053	85 db		 test	 ebx, ebx
  00055	75 0d		 jne	 SHORT $LN6@GetSignalD

; 232  : 	{
; 233  : 		pos = pGraphData->GetHeadPosition();
; 234  : 		if(pos == NULL)

  00057	85 f6		 test	 esi, esi
  00059	0f 84 1e 01 00
	00		 je	 $LN83@GetSignalD

; 235  : 			return ;
; 236  : 
; 237  : 	}

  0005f	8b 55 14	 mov	 edx, DWORD PTR _nCnt$1$[ebp]
  00062	eb 4f		 jmp	 SHORT $LN10@GetSignalD
$LN6@GetSignalD:

; 238  : 	else
; 239  : 	{
; 240  : 		if(pGraphData->GetCount() < 2)

  00064	8b 55 14	 mov	 edx, DWORD PTR _nCnt$1$[ebp]
  00067	83 fa 02	 cmp	 edx, 2
  0006a	0f 8c 0d 01 00
	00		 jl	 $LN83@GetSignalD

; 241  : 			return ;
; 242  : 		prepos = pGraphData->FindIndex(point.x - 1);

  00070	8d 43 ff	 lea	 eax, DWORD PTR [ebx-1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 1133 : 	if (nIndex >= m_nCount || nIndex < 0)

  00073	3b c2		 cmp	 eax, edx
  00075	7d 12		 jge	 SHORT $LN29@GetSignalD
  00077	85 c0		 test	 eax, eax
  00079	78 0e		 js	 SHORT $LN29@GetSignalD

; 1135 : 
; 1136 : 	CNode* pNode = m_pNodeHead;

  0007b	8b fe		 mov	 edi, esi

; 1137 : 	while (nIndex--)

  0007d	74 0c		 je	 SHORT $LN25@GetSignalD
  0007f	90		 npad	 1
$LL26@GetSignalD:

; 1138 : 	{
; 1139 : 		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 1140 : 		pNode = pNode->pNext;

  00080	8b 3f		 mov	 edi, DWORD PTR [edi]
  00082	83 e8 01	 sub	 eax, 1
  00085	75 f9		 jne	 SHORT $LL26@GetSignalD

; 1141 : 	}
; 1142 : 	return (POSITION) pNode;

  00087	eb 02		 jmp	 SHORT $LN25@GetSignalD
$LN29@GetSignalD:

; 1134 : 		return NULL;  // went too far

  00089	33 ff		 xor	 edi, edi
$LN25@GetSignalD:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartFormulate\Signal.cpp

; 243  : 		pos = pGraphData->FindIndex(point.x);

  0008b	8b c3		 mov	 eax, ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 1133 : 	if (nIndex >= m_nCount || nIndex < 0)

  0008d	3b c2		 cmp	 eax, edx
  0008f	7d 0d		 jge	 SHORT $LN35@GetSignalD
  00091	85 db		 test	 ebx, ebx
  00093	78 09		 js	 SHORT $LN35@GetSignalD
$LL32@GetSignalD:

; 1138 : 	{
; 1139 : 		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 1140 : 		pNode = pNode->pNext;

  00095	8b 36		 mov	 esi, DWORD PTR [esi]
  00097	83 e8 01	 sub	 eax, 1
  0009a	75 f9		 jne	 SHORT $LL32@GetSignalD

; 1141 : 	}
; 1142 : 	return (POSITION) pNode;

  0009c	eb 02		 jmp	 SHORT $LN31@GetSignalD
$LN35@GetSignalD:

; 1134 : 		return NULL;  // went too far

  0009e	33 f6		 xor	 esi, esi
$LN31@GetSignalD:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartFormulate\Signal.cpp

; 245  : 		if(prepos == NULL || pos == NULL)

  000a0	85 ff		 test	 edi, edi
  000a2	0f 84 d5 00 00
	00		 je	 $LN83@GetSignalD
  000a8	85 f6		 test	 esi, esi
  000aa	0f 84 cd 00 00
	00		 je	 $LN83@GetSignalD
  000b0	8b 45 08	 mov	 eax, DWORD PTR _point$[ebp]
$LN10@GetSignalD:

; 250  : 	for(int i = point.x; i < nCnt; i++){

  000b3	3b da		 cmp	 ebx, edx
  000b5	0f 8d c2 00 00
	00		 jge	 $LN83@GetSignalD
  000bb	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR __imp_?AppendData@CPacket@@QAEXNH@Z
  000c1	41		 inc	 ecx
  000c2	89 4d fc	 mov	 DWORD PTR tv500[ebp], ecx
  000c5	8b 4d 18	 mov	 ecx, DWORD PTR _pSignalPacket$[ebp]
$LL4@GetSignalD:

; 251  : 		if(i >= (nFirstNonZeroValue+1)) {

  000c8	0f 57 c0	 xorps	 xmm0, xmm0
  000cb	3b 5d fc	 cmp	 ebx, DWORD PTR tv500[ebp]
  000ce	7c 6f		 jl	 SHORT $LN12@GetSignalD

; 406  : 	if(pGraphData == NULL || pos == NULL)

  000d0	85 f6		 test	 esi, esi
  000d2	74 0b		 je	 SHORT $LN39@GetSignalD
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 811  : 	{ CNode* pNode = (CNode*) rPosition;

  000d4	8b c6		 mov	 eax, esi

; 813  : 		rPosition = (POSITION) pNode->pNext;

  000d6	8b 36		 mov	 esi, DWORD PTR [esi]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartFormulate\Signal.cpp

; 409  : 	return pGraphData->GetNext(pos);

  000d8	f2 0f 10 48 08	 movsd	 xmm1, QWORD PTR [eax+8]
  000dd	eb 03		 jmp	 SHORT $LN37@GetSignalD
$LN39@GetSignalD:
  000df	0f 57 c9	 xorps	 xmm1, xmm1
$LN37@GetSignalD:

; 406  : 	if(pGraphData == NULL || pos == NULL)

  000e2	85 ff		 test	 edi, edi
  000e4	74 09		 je	 SHORT $LN45@GetSignalD
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 811  : 	{ CNode* pNode = (CNode*) rPosition;

  000e6	8b c7		 mov	 eax, edi

; 813  : 		rPosition = (POSITION) pNode->pNext;

  000e8	8b 3f		 mov	 edi, DWORD PTR [edi]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartFormulate\Signal.cpp

; 409  : 	return pGraphData->GetNext(pos);

  000ea	f2 0f 10 40 08	 movsd	 xmm0, QWORD PTR [eax+8]
$LN45@GetSignalD:

; 384  : 	if(oldData <= baseline && nowData > baseline)

  000ef	f2 0f 10 55 0c	 movsd	 xmm2, QWORD PTR _nBaseline$[ebp]
  000f4	66 0f 2f d0	 comisd	 xmm2, xmm0
  000f8	72 18		 jb	 SHORT $LN50@GetSignalD
  000fa	66 0f 2f ca	 comisd	 xmm1, xmm2
  000fe	76 12		 jbe	 SHORT $LN50@GetSignalD

; 385  : 		return CGraphBaseData::BUY; // 매수

  00100	b8 01 00 00 00	 mov	 eax, 1
  00105	66 0f 6e c0	 movd	 xmm0, eax

; 147  : 	if(point.x == 0)

  00109	8b 45 08	 mov	 eax, DWORD PTR _point$[ebp]

; 252  : 			double nCurrentData = GetCurDataFromList(pos, pGraphData);
; 253  : 			double nOldData = GetCurDataFromList(prepos, pGraphData);
; 254  : 			SetData(point, i, GetSignalType(nBaseline, nOldData, nCurrentData), pSignalPacket);

  0010c	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0

; 148  : 		pPacket->AppendData(dData);

  00110	eb 31		 jmp	 SHORT $LN84@GetSignalD
$LN50@GetSignalD:

; 386  : 	if(oldData >= baseline && nowData < baseline)

  00112	66 0f 2f c2	 comisd	 xmm0, xmm2
  00116	72 18		 jb	 SHORT $LN51@GetSignalD
  00118	66 0f 2f d1	 comisd	 xmm2, xmm1
  0011c	76 12		 jbe	 SHORT $LN51@GetSignalD

; 387  : 		return CGraphBaseData::SELL; // 매도

  0011e	b8 02 00 00 00	 mov	 eax, 2
  00123	66 0f 6e c0	 movd	 xmm0, eax

; 147  : 	if(point.x == 0)

  00127	8b 45 08	 mov	 eax, DWORD PTR _point$[ebp]

; 252  : 			double nCurrentData = GetCurDataFromList(pos, pGraphData);
; 253  : 			double nOldData = GetCurDataFromList(prepos, pGraphData);
; 254  : 			SetData(point, i, GetSignalType(nBaseline, nOldData, nCurrentData), pSignalPacket);

  0012a	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0

; 148  : 		pPacket->AppendData(dData);

  0012e	eb 13		 jmp	 SHORT $LN84@GetSignalD
$LN51@GetSignalD:

; 389  : 	return CGraphBaseData::NONE;

  00130	33 c0		 xor	 eax, eax
  00132	66 0f 6e c0	 movd	 xmm0, eax

; 147  : 	if(point.x == 0)

  00136	8b 45 08	 mov	 eax, DWORD PTR _point$[ebp]

; 252  : 			double nCurrentData = GetCurDataFromList(pos, pGraphData);
; 253  : 			double nOldData = GetCurDataFromList(prepos, pGraphData);
; 254  : 			SetData(point, i, GetSignalType(nBaseline, nOldData, nCurrentData), pSignalPacket);

  00139	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0

; 148  : 		pPacket->AppendData(dData);

  0013d	eb 04		 jmp	 SHORT $LN84@GetSignalD
$LN12@GetSignalD:

; 255  : 		}
; 256  : 		else
; 257  : 		{
; 258  : 			prepos = pos; 

  0013f	8b fe		 mov	 edi, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 813  : 		rPosition = (POSITION) pNode->pNext;

  00141	8b 36		 mov	 esi, DWORD PTR [esi]
$LN84@GetSignalD:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartFormulate\Signal.cpp

; 250  : 	for(int i = point.x; i < nCnt; i++){

  00143	83 38 00	 cmp	 DWORD PTR [eax], 0
  00146	75 0e		 jne	 SHORT $LN54@GetSignalD
  00148	6a ff		 push	 -1
  0014a	83 ec 08	 sub	 esp, 8
  0014d	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00152	ff d2		 call	 edx
  00154	eb 11		 jmp	 SHORT $LN2@GetSignalD
$LN54@GetSignalD:
  00156	6a 00		 push	 0
  00158	53		 push	 ebx
  00159	83 ec 08	 sub	 esp, 8
  0015c	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00161	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?UpdateData@CPacket@@QAEXNH_N@Z
$LN2@GetSignalD:
  00167	8b 4d 18	 mov	 ecx, DWORD PTR _pSignalPacket$[ebp]
  0016a	43		 inc	 ebx
  0016b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR __imp_?AppendData@CPacket@@QAEXNH@Z
  00171	8b 45 08	 mov	 eax, DWORD PTR _point$[ebp]
  00174	3b 5d 14	 cmp	 ebx, DWORD PTR _nCnt$1$[ebp]
  00177	0f 8c 4b ff ff
	ff		 jl	 $LL4@GetSignalD
$LN83@GetSignalD:
  0017d	5f		 pop	 edi
  0017e	5b		 pop	 ebx
$LN11@GetSignalD:
  0017f	5e		 pop	 esi

; 259  : 			pGraphData->GetNext(pos);
; 260  : 			SetData(point, i, 0.0, pSignalPacket);
; 261  : 		}
; 262  : 	}
; 263  : }

  00180	8b e5		 mov	 esp, ebp
  00182	5d		 pop	 ebp
  00183	c2 14 00	 ret	 20			; 00000014H
?GetSignalDatabyUsingGraphDataandOneBaseLine@CSignal@@AAEXABVCPoint@@NPAV?$CList@NN@@PAVCPacket@@@Z ENDP ; CSignal::GetSignalDatabyUsingGraphDataandOneBaseLine
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartFormulate\Signal.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartFormulate\Signal.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartFormulate\Signal.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartFormulate\Signal.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartFormulate\Signal.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartFormulate\Signal.cpp
;	COMDAT ?GetSignalDatabyUsingGraphDataandTwoBaseLine@CSignal@@AAEXABVCPoint@@NNPAV?$CList@NN@@PAVCPacket@@@Z
_TEXT	SEGMENT
tv510 = -4						; size = 4
_point$ = 8						; size = 4
_nUpBaseline$ = 12					; size = 8
_nDownBaseline$ = 20					; size = 8
_nCnt$1$ = 28						; size = 4
_pGraphData$ = 28					; size = 4
_pSignalPacket$ = 32					; size = 4
?GetSignalDatabyUsingGraphDataandTwoBaseLine@CSignal@@AAEXABVCPoint@@NNPAV?$CList@NN@@PAVCPacket@@@Z PROC ; CSignal::GetSignalDatabyUsingGraphDataandTwoBaseLine, COMDAT
; _this$ = ecx

; 312  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 313  : 	if(pGraphData == NULL) return;

  00005	8b 75 1c	 mov	 esi, DWORD PTR _pGraphData$[ebp]
  00008	85 f6		 test	 esi, esi
  0000a	0f 84 7d 01 00
	00		 je	 $LN11@GetSignalD

; 358  : 	const int nCnt = pGraphData1->GetCount();

  00010	53		 push	 ebx
  00011	8b 5e 0c	 mov	 ebx, DWORD PTR [esi+12]

; 359  : 	POSITION pos = pGraphData1->GetHeadPosition();
; 360  : 	if(pos == NULL)

  00014	33 c9		 xor	 ecx, ecx
  00016	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
  00019	8b d6		 mov	 edx, esi
  0001b	89 5d 1c	 mov	 DWORD PTR _nCnt$1$[ebp], ebx
  0001e	85 d2		 test	 edx, edx
  00020	74 29		 je	 SHORT $LN15@GetSignalD

; 361  : 		return 0;
; 362  : 	for(int start = 0; start < nCnt; start++)

  00022	85 db		 test	 ebx, ebx
  00024	7e 22		 jle	 SHORT $LN17@GetSignalD
  00026	0f 57 c9	 xorps	 xmm1, xmm1
  00029	0f 1f 80 00 00
	00 00		 npad	 7
$LL18@GetSignalD:

; 364  : 		if(pGraphData1->GetNext(pos) != 0)

  00030	f2 0f 10 42 08	 movsd	 xmm0, QWORD PTR [edx+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 811  : 	{ CNode* pNode = (CNode*) rPosition;

  00035	8d 02		 lea	 eax, DWORD PTR [edx]

; 813  : 		rPosition = (POSITION) pNode->pNext;

  00037	8b 12		 mov	 edx, DWORD PTR [edx]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartFormulate\Signal.cpp

; 364  : 		if(pGraphData1->GetNext(pos) != 0)

  00039	66 0f 2e c1	 ucomisd xmm0, xmm1
  0003d	9f		 lahf
  0003e	f6 c4 44	 test	 ah, 68			; 00000044H
  00041	7a 08		 jp	 SHORT $LN15@GetSignalD

; 361  : 		return 0;
; 362  : 	for(int start = 0; start < nCnt; start++)

  00043	41		 inc	 ecx
  00044	3b cb		 cmp	 ecx, ebx
  00046	7c e8		 jl	 SHORT $LL18@GetSignalD
$LN17@GetSignalD:

; 365  : 			return start;
; 366  : 	return pGraphData1->GetCount()-1;

  00048	8d 4b ff	 lea	 ecx, DWORD PTR [ebx-1]
$LN15@GetSignalD:

; 314  : 	// 처음으로 "0"아닌 값은 무조건 none이다!
; 315  : 	int nFirstNonZeroValue = GetFirstNonZeroValueIndex(pGraphData);
; 316  : 	const int nCnt = pGraphData->GetCount();
; 317  : 	
; 318  : 	POSITION prepos = NULL, pos = NULL;
; 319  : 	if(point.x == 0)

  0004b	8b 45 08	 mov	 eax, DWORD PTR _point$[ebp]
  0004e	33 db		 xor	 ebx, ebx
  00050	57		 push	 edi
  00051	8b 38		 mov	 edi, DWORD PTR [eax]
  00053	85 ff		 test	 edi, edi
  00055	75 0a		 jne	 SHORT $LN6@GetSignalD

; 320  : 	{
; 321  : 		pos = pGraphData->GetHeadPosition();
; 322  : 		if(pos == NULL)

  00057	85 f6		 test	 esi, esi
  00059	0f 84 2c 01 00
	00		 je	 $LN85@GetSignalD

; 323  : 			return ;
; 324  : 
; 325  : 	}

  0005f	eb 5a		 jmp	 SHORT $LN10@GetSignalD
$LN6@GetSignalD:

; 326  : 	else
; 327  : 	{
; 328  : 		if(pGraphData->GetCount() < 2)

  00061	8b 55 1c	 mov	 edx, DWORD PTR _nCnt$1$[ebp]
  00064	83 fa 02	 cmp	 edx, 2
  00067	0f 8c 1e 01 00
	00		 jl	 $LN85@GetSignalD

; 329  : 			return ;
; 330  : 		prepos = pGraphData->FindIndex(point.x);

  0006d	8b c7		 mov	 eax, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 1133 : 	if (nIndex >= m_nCount || nIndex < 0)

  0006f	3b c2		 cmp	 eax, edx
  00071	0f 8d 14 01 00
	00		 jge	 $LN85@GetSignalD
  00077	85 ff		 test	 edi, edi
  00079	78 12		 js	 SHORT $LN29@GetSignalD

; 1134 : 		return NULL;  // went too far
; 1135 : 
; 1136 : 	CNode* pNode = m_pNodeHead;

  0007b	8b d6		 mov	 edx, esi
  0007d	0f 1f 00	 npad	 3
$LL26@GetSignalD:

; 1137 : 	while (nIndex--)
; 1138 : 	{
; 1139 : 		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 1140 : 		pNode = pNode->pNext;

  00080	8b 12		 mov	 edx, DWORD PTR [edx]
  00082	83 e8 01	 sub	 eax, 1
  00085	75 f9		 jne	 SHORT $LL26@GetSignalD

; 1141 : 	}
; 1142 : 	return (POSITION) pNode;

  00087	8b da		 mov	 ebx, edx
  00089	8b c7		 mov	 eax, edi
  0008b	eb 14		 jmp	 SHORT $LL83@GetSignalD
$LN29@GetSignalD:

; 1133 : 	if (nIndex >= m_nCount || nIndex < 0)

  0008d	3b c2		 cmp	 eax, edx
  0008f	0f 8d f6 00 00
	00		 jge	 $LN85@GetSignalD
  00095	33 d2		 xor	 edx, edx
  00097	33 db		 xor	 ebx, ebx
  00099	85 c0		 test	 eax, eax
  0009b	0f 88 ea 00 00
	00		 js	 $LN85@GetSignalD
$LL83@GetSignalD:

; 1137 : 	while (nIndex--)
; 1138 : 	{
; 1139 : 		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 1140 : 		pNode = pNode->pNext;

  000a1	8b 36		 mov	 esi, DWORD PTR [esi]
  000a3	83 e8 01	 sub	 eax, 1
  000a6	75 f9		 jne	 SHORT $LL83@GetSignalD
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartFormulate\Signal.cpp

; 333  : 		if(prepos == NULL || pos == NULL)

  000a8	85 d2		 test	 edx, edx
  000aa	0f 84 db 00 00
	00		 je	 $LN85@GetSignalD
  000b0	85 f6		 test	 esi, esi
  000b2	0f 84 d3 00 00
	00		 je	 $LN85@GetSignalD
  000b8	8b 45 08	 mov	 eax, DWORD PTR _point$[ebp]
$LN10@GetSignalD:

; 338  : 	for(int i = point.x; i < nCnt; i++){

  000bb	3b 7d 1c	 cmp	 edi, DWORD PTR _nCnt$1$[ebp]
  000be	0f 8d c7 00 00
	00		 jge	 $LN85@GetSignalD
  000c4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR __imp_?AppendData@CPacket@@QAEXNH@Z
  000ca	41		 inc	 ecx
  000cb	89 4d fc	 mov	 DWORD PTR tv510[ebp], ecx
  000ce	8b 4d 20	 mov	 ecx, DWORD PTR _pSignalPacket$[ebp]
$LL4@GetSignalD:

; 339  : 		if(i >= (nFirstNonZeroValue+1)) {

  000d1	0f 57 c0	 xorps	 xmm0, xmm0
  000d4	3b 7d fc	 cmp	 edi, DWORD PTR tv510[ebp]
  000d7	7c 74		 jl	 SHORT $LN12@GetSignalD

; 406  : 	if(pGraphData == NULL || pos == NULL)

  000d9	85 db		 test	 ebx, ebx
  000db	74 0b		 je	 SHORT $LN39@GetSignalD
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 811  : 	{ CNode* pNode = (CNode*) rPosition;

  000dd	8b c3		 mov	 eax, ebx

; 813  : 		rPosition = (POSITION) pNode->pNext;

  000df	8b 1b		 mov	 ebx, DWORD PTR [ebx]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartFormulate\Signal.cpp

; 409  : 	return pGraphData->GetNext(pos);

  000e1	f2 0f 10 48 08	 movsd	 xmm1, QWORD PTR [eax+8]
  000e6	eb 03		 jmp	 SHORT $LN37@GetSignalD
$LN39@GetSignalD:
  000e8	0f 57 c9	 xorps	 xmm1, xmm1
$LN37@GetSignalD:

; 406  : 	if(pGraphData == NULL || pos == NULL)

  000eb	85 f6		 test	 esi, esi
  000ed	74 09		 je	 SHORT $LN45@GetSignalD
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 811  : 	{ CNode* pNode = (CNode*) rPosition;

  000ef	8b c6		 mov	 eax, esi

; 813  : 		rPosition = (POSITION) pNode->pNext;

  000f1	8b 36		 mov	 esi, DWORD PTR [esi]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartFormulate\Signal.cpp

; 409  : 	return pGraphData->GetNext(pos);

  000f3	f2 0f 10 40 08	 movsd	 xmm0, QWORD PTR [eax+8]
$LN45@GetSignalD:

; 395  : 	if(oldData <= downBaseline && nowData > downBaseline) 

  000f8	f2 0f 10 55 14	 movsd	 xmm2, QWORD PTR _nDownBaseline$[ebp]
  000fd	66 0f 2f d1	 comisd	 xmm2, xmm1
  00101	72 18		 jb	 SHORT $LN50@GetSignalD
  00103	66 0f 2f c2	 comisd	 xmm0, xmm2
  00107	76 12		 jbe	 SHORT $LN50@GetSignalD

; 396  : 		return CGraphBaseData::BUY; // 매수

  00109	b8 01 00 00 00	 mov	 eax, 1
  0010e	66 0f 6e c0	 movd	 xmm0, eax

; 147  : 	if(point.x == 0)

  00112	8b 45 08	 mov	 eax, DWORD PTR _point$[ebp]

; 340  : 			double nOldData = GetCurDataFromList(prepos, pGraphData);
; 341  : 			double nCurrentData = GetCurDataFromList(pos, pGraphData);
; 342  : 			SetData(point, i, GetSignalType(nUpBaseline, nDownBaseline, nOldData, nCurrentData), pSignalPacket);

  00115	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0

; 148  : 		pPacket->AppendData(dData);

  00119	eb 36		 jmp	 SHORT $LN87@GetSignalD
$LN50@GetSignalD:

; 398  : 	if(oldData >= upBaseline && nowData < upBaseline) 

  0011b	f2 0f 10 55 0c	 movsd	 xmm2, QWORD PTR _nUpBaseline$[ebp]
  00120	66 0f 2f ca	 comisd	 xmm1, xmm2
  00124	72 18		 jb	 SHORT $LN51@GetSignalD
  00126	66 0f 2f d0	 comisd	 xmm2, xmm0
  0012a	76 12		 jbe	 SHORT $LN51@GetSignalD

; 399  : 		return CGraphBaseData::SELL; // 매도

  0012c	b8 02 00 00 00	 mov	 eax, 2
  00131	66 0f 6e c0	 movd	 xmm0, eax

; 147  : 	if(point.x == 0)

  00135	8b 45 08	 mov	 eax, DWORD PTR _point$[ebp]

; 340  : 			double nOldData = GetCurDataFromList(prepos, pGraphData);
; 341  : 			double nCurrentData = GetCurDataFromList(pos, pGraphData);
; 342  : 			SetData(point, i, GetSignalType(nUpBaseline, nDownBaseline, nOldData, nCurrentData), pSignalPacket);

  00138	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0

; 148  : 		pPacket->AppendData(dData);

  0013c	eb 13		 jmp	 SHORT $LN87@GetSignalD
$LN51@GetSignalD:

; 401  : 	return CGraphBaseData::NONE;

  0013e	33 c0		 xor	 eax, eax
  00140	66 0f 6e c0	 movd	 xmm0, eax

; 147  : 	if(point.x == 0)

  00144	8b 45 08	 mov	 eax, DWORD PTR _point$[ebp]

; 340  : 			double nOldData = GetCurDataFromList(prepos, pGraphData);
; 341  : 			double nCurrentData = GetCurDataFromList(pos, pGraphData);
; 342  : 			SetData(point, i, GetSignalType(nUpBaseline, nDownBaseline, nOldData, nCurrentData), pSignalPacket);

  00147	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0

; 148  : 		pPacket->AppendData(dData);

  0014b	eb 04		 jmp	 SHORT $LN87@GetSignalD
$LN12@GetSignalD:

; 343  : 		}
; 344  : 		else
; 345  : 		{
; 346  : 			prepos = pos;

  0014d	8b de		 mov	 ebx, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 813  : 		rPosition = (POSITION) pNode->pNext;

  0014f	8b 36		 mov	 esi, DWORD PTR [esi]
$LN87@GetSignalD:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartFormulate\Signal.cpp

; 338  : 	for(int i = point.x; i < nCnt; i++){

  00151	83 38 00	 cmp	 DWORD PTR [eax], 0
  00154	75 0e		 jne	 SHORT $LN54@GetSignalD
  00156	6a ff		 push	 -1
  00158	83 ec 08	 sub	 esp, 8
  0015b	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00160	ff d2		 call	 edx
  00162	eb 11		 jmp	 SHORT $LN2@GetSignalD
$LN54@GetSignalD:
  00164	6a 00		 push	 0
  00166	57		 push	 edi
  00167	83 ec 08	 sub	 esp, 8
  0016a	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0016f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?UpdateData@CPacket@@QAEXNH_N@Z
$LN2@GetSignalD:
  00175	8b 4d 20	 mov	 ecx, DWORD PTR _pSignalPacket$[ebp]
  00178	47		 inc	 edi
  00179	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR __imp_?AppendData@CPacket@@QAEXNH@Z
  0017f	8b 45 08	 mov	 eax, DWORD PTR _point$[ebp]
  00182	3b 7d 1c	 cmp	 edi, DWORD PTR _nCnt$1$[ebp]
  00185	0f 8c 46 ff ff
	ff		 jl	 $LL4@GetSignalD
$LN85@GetSignalD:
  0018b	5f		 pop	 edi
  0018c	5b		 pop	 ebx
$LN11@GetSignalD:
  0018d	5e		 pop	 esi

; 347  : 			pGraphData->GetNext(pos);
; 348  : 			SetData(point, i, 0.0, pSignalPacket);
; 349  : 		}
; 350  : 	}
; 351  : }

  0018e	8b e5		 mov	 esp, ebp
  00190	5d		 pop	 ebp
  00191	c2 1c 00	 ret	 28			; 0000001cH
?GetSignalDatabyUsingGraphDataandTwoBaseLine@CSignal@@AAEXABVCPoint@@NNPAV?$CList@NN@@PAVCPacket@@@Z ENDP ; CSignal::GetSignalDatabyUsingGraphDataandTwoBaseLine
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartFormulate\Signal.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartFormulate\Signal.cpp
;	COMDAT ?GetSignalTypesbyUsingGraphDataandMinMaxBaseLine@CSignal@@AAEXABVCPoint@@PAV?$CList@NN@@1PAVCPacket@@@Z
_TEXT	SEGMENT
_nDownBaseline$ = -8					; size = 8
_nUpBaseline$ = -8					; size = 8
_point$ = 8						; size = 4
_pBaseLineList$ = 12					; size = 4
_pGraphData$ = 16					; size = 4
_pSignalPacket$ = 20					; size = 4
?GetSignalTypesbyUsingGraphDataandMinMaxBaseLine@CSignal@@AAEXABVCPoint@@PAV?$CList@NN@@1PAVCPacket@@@Z PROC ; CSignal::GetSignalTypesbyUsingGraphDataandMinMaxBaseLine, COMDAT
; _this$ = ecx

; 288  : void CSignal::GetSignalTypesbyUsingGraphDataandMinMaxBaseLine(const CPoint& point, CDoublePacketData *pBaseLineList, CDoublePacketData *pGraphData, CPacket* pSignalPacket){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	57		 push	 edi
  00007	8b f9		 mov	 edi, ecx

; 289  : 	if(pBaseLineList == NULL || pGraphData == NULL) return;

  00009	8b 4d 0c	 mov	 ecx, DWORD PTR _pBaseLineList$[ebp]
  0000c	85 c9		 test	 ecx, ecx
  0000e	74 67		 je	 SHORT $LN5@GetSignalT
  00010	83 7d 10 00	 cmp	 DWORD PTR _pGraphData$[ebp], 0
  00014	74 61		 je	 SHORT $LN5@GetSignalT

; 290  : 	double nUpBaseline, nDownBaseline;
; 291  : 
; 292  : 	int order = 0;
; 293  : 	POSITION pos = pBaseLineList->GetHeadPosition();

  00016	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00019	33 d2		 xor	 edx, edx

; 294  : 	while(pos) {

  0001b	f2 0f 10 55 f8	 movsd	 xmm2, QWORD PTR _nUpBaseline$[ebp]
  00020	f2 0f 10 4d f8	 movsd	 xmm1, QWORD PTR _nDownBaseline$[ebp]
  00025	85 c9		 test	 ecx, ecx
  00027	74 30		 je	 SHORT $LN3@GetSignalT
  00029	0f 1f 80 00 00
	00 00		 npad	 7
$LL2@GetSignalT:

; 295  : 		double temp = pBaseLineList->GetNext(pos);

  00030	f2 0f 10 41 08	 movsd	 xmm0, QWORD PTR [ecx+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 811  : 	{ CNode* pNode = (CNode*) rPosition;

  00035	8d 01		 lea	 eax, DWORD PTR [ecx]

; 812  : 		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 813  : 		rPosition = (POSITION) pNode->pNext;

  00037	8b 09		 mov	 ecx, DWORD PTR [ecx]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartFormulate\Signal.cpp

; 297  : 		if(order == 0)

  00039	85 d2		 test	 edx, edx
  0003b	75 05		 jne	 SHORT $LN6@GetSignalT

; 298  : 			nUpBaseline = nDownBaseline = temp;

  0003d	0f 28 c8	 movaps	 xmm1, xmm0
  00040	eb 0f		 jmp	 SHORT $LN19@GetSignalT
$LN6@GetSignalT:

; 299  : 		else {
; 300  : 			if(nDownBaseline > temp)

  00042	66 0f 2f c8	 comisd	 xmm1, xmm0
  00046	76 05		 jbe	 SHORT $LN8@GetSignalT

; 301  : 				nDownBaseline = temp;

  00048	0f 28 c8	 movaps	 xmm1, xmm0
  0004b	eb 07		 jmp	 SHORT $LN10@GetSignalT
$LN8@GetSignalT:

; 302  : 			else if(nUpBaseline < temp)

  0004d	f2 0f 5f c2	 maxsd	 xmm0, xmm2
$LN19@GetSignalT:

; 303  : 				nUpBaseline = temp;
; 304  : 		}
; 305  : 		order++;

  00051	0f 28 d0	 movaps	 xmm2, xmm0
$LN10@GetSignalT:
  00054	42		 inc	 edx
  00055	85 c9		 test	 ecx, ecx
  00057	75 d7		 jne	 SHORT $LL2@GetSignalT
$LN3@GetSignalT:

; 306  : 	}
; 307  : 
; 308  : 	GetSignalDatabyUsingGraphDataandTwoBaseLine(point, nUpBaseline, nDownBaseline, pGraphData, pSignalPacket);

  00059	ff 75 14	 push	 DWORD PTR _pSignalPacket$[ebp]
  0005c	8b cf		 mov	 ecx, edi
  0005e	ff 75 10	 push	 DWORD PTR _pGraphData$[ebp]
  00061	83 ec 10	 sub	 esp, 16			; 00000010H
  00064	f2 0f 11 4c 24
	08		 movsd	 QWORD PTR [esp+8], xmm1
  0006a	f2 0f 11 14 24	 movsd	 QWORD PTR [esp], xmm2
  0006f	ff 75 08	 push	 DWORD PTR _point$[ebp]
  00072	e8 00 00 00 00	 call	 ?GetSignalDatabyUsingGraphDataandTwoBaseLine@CSignal@@AAEXABVCPoint@@NNPAV?$CList@NN@@PAVCPacket@@@Z ; CSignal::GetSignalDatabyUsingGraphDataandTwoBaseLine
$LN5@GetSignalT:
  00077	5f		 pop	 edi

; 309  : }

  00078	8b e5		 mov	 esp, ebp
  0007a	5d		 pop	 ebp
  0007b	c2 10 00	 ret	 16			; 00000010H
?GetSignalTypesbyUsingGraphDataandMinMaxBaseLine@CSignal@@AAEXABVCPoint@@PAV?$CList@NN@@1PAVCPacket@@@Z ENDP ; CSignal::GetSignalTypesbyUsingGraphDataandMinMaxBaseLine
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartFormulate\Signal.cpp
;	COMDAT ?GetSignalTypesbyUsingGraphDataandOneBaseLine@CSignal@@AAEXABVCPoint@@PAV?$CList@NN@@1PAVCPacket@@@Z
_TEXT	SEGMENT
_point$ = 8						; size = 4
_pBaseLineList$ = 12					; size = 4
_pGraphData$ = 16					; size = 4
_pSignalPacket$ = 20					; size = 4
?GetSignalTypesbyUsingGraphDataandOneBaseLine@CSignal@@AAEXABVCPoint@@PAV?$CList@NN@@1PAVCPacket@@@Z PROC ; CSignal::GetSignalTypesbyUsingGraphDataandOneBaseLine, COMDAT
; _this$ = ecx

; 213  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 214  : 	if(pBaseLineList == NULL || pGraphData == NULL) return;

  00003	8b 45 0c	 mov	 eax, DWORD PTR _pBaseLineList$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 27		 je	 SHORT $LN3@GetSignalT
  0000a	8b 55 10	 mov	 edx, DWORD PTR _pGraphData$[ebp]
  0000d	85 d2		 test	 edx, edx
  0000f	74 20		 je	 SHORT $LN3@GetSignalT

; 215  : 	// 처음으로 "0"아닌 값은 무조건 none이다!
; 216  : 	POSITION pos = pBaseLineList->GetHeadPosition();

  00011	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 217  : 	if(pos == NULL)

  00014	85 c0		 test	 eax, eax
  00016	74 19		 je	 SHORT $LN3@GetSignalT

; 218  : 		return;
; 219  : 	
; 220  : 	double nBaseline = pBaseLineList->GetAt(pos);
; 221  : 	GetSignalDatabyUsingGraphDataandOneBaseLine(point, nBaseline, pGraphData, pSignalPacket);

  00018	ff 75 14	 push	 DWORD PTR _pSignalPacket$[ebp]
  0001b	f2 0f 10 40 08	 movsd	 xmm0, QWORD PTR [eax+8]
  00020	52		 push	 edx
  00021	83 ec 08	 sub	 esp, 8
  00024	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00029	ff 75 08	 push	 DWORD PTR _point$[ebp]
  0002c	e8 00 00 00 00	 call	 ?GetSignalDatabyUsingGraphDataandOneBaseLine@CSignal@@AAEXABVCPoint@@NPAV?$CList@NN@@PAVCPacket@@@Z ; CSignal::GetSignalDatabyUsingGraphDataandOneBaseLine
$LN3@GetSignalT:

; 222  : }

  00031	5d		 pop	 ebp
  00032	c2 10 00	 ret	 16			; 00000010H
?GetSignalTypesbyUsingGraphDataandOneBaseLine@CSignal@@AAEXABVCPoint@@PAV?$CList@NN@@1PAVCPacket@@@Z ENDP ; CSignal::GetSignalTypesbyUsingGraphDataandOneBaseLine
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartFormulate\Signal.cpp
;	COMDAT ?GetSignalTypesbyUsingGraphDataandTwoBaseLine@CSignal@@AAEXABVCPoint@@PAV?$CList@NN@@1PAVCPacket@@@Z
_TEXT	SEGMENT
_point$ = 8						; size = 4
_pBaseLineList$ = 12					; size = 4
_pGraphData$ = 16					; size = 4
_pSignalPacket$ = 20					; size = 4
?GetSignalTypesbyUsingGraphDataandTwoBaseLine@CSignal@@AAEXABVCPoint@@PAV?$CList@NN@@1PAVCPacket@@@Z PROC ; CSignal::GetSignalTypesbyUsingGraphDataandTwoBaseLine, COMDAT
; _this$ = ecx

; 266  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 267  : 	if(pBaseLineList == NULL || pGraphData == NULL) return;

  00003	8b 45 0c	 mov	 eax, DWORD PTR _pBaseLineList$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 45		 je	 SHORT $LN3@GetSignalT
  0000a	8b 55 10	 mov	 edx, DWORD PTR _pGraphData$[ebp]
  0000d	85 d2		 test	 edx, edx
  0000f	74 3e		 je	 SHORT $LN3@GetSignalT

; 268  : 	
; 269  : 	POSITION pos = pBaseLineList->GetHeadPosition();

  00011	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 270  : 	if(pos == NULL)

  00014	85 c0		 test	 eax, eax
  00016	74 37		 je	 SHORT $LN3@GetSignalT

; 271  : 		return;
; 272  : 	double nUpBaseline, nDownBaseline;
; 273  : 	double first = pBaseLineList->GetNext(pos);

  00018	f2 0f 10 48 08	 movsd	 xmm1, QWORD PTR [eax+8]

; 274  : 	double second = pBaseLineList->GetNext(pos);

  0001d	8b 00		 mov	 eax, DWORD PTR [eax]
  0001f	f2 0f 10 40 08	 movsd	 xmm0, QWORD PTR [eax+8]

; 275  : 
; 276  : 	if(first > second) {

  00024	66 0f 2f c8	 comisd	 xmm1, xmm0
  00028	76 05		 jbe	 SHORT $LN5@GetSignalT

; 277  : 		nUpBaseline = first;

  0002a	0f 28 d1	 movaps	 xmm2, xmm1

; 278  : 		nDownBaseline = second;
; 279  : 	}

  0002d	eb 06		 jmp	 SHORT $LN6@GetSignalT
$LN5@GetSignalT:

; 280  : 	else {
; 281  : 		nUpBaseline = second;

  0002f	0f 28 d0	 movaps	 xmm2, xmm0

; 282  : 		nDownBaseline = first;

  00032	0f 28 c1	 movaps	 xmm0, xmm1
$LN6@GetSignalT:

; 283  : 	}
; 284  : 
; 285  : 	GetSignalDatabyUsingGraphDataandTwoBaseLine(point, nUpBaseline, nDownBaseline, pGraphData, pSignalPacket);

  00035	ff 75 14	 push	 DWORD PTR _pSignalPacket$[ebp]
  00038	52		 push	 edx
  00039	83 ec 10	 sub	 esp, 16			; 00000010H
  0003c	f2 0f 11 44 24
	08		 movsd	 QWORD PTR [esp+8], xmm0
  00042	f2 0f 11 14 24	 movsd	 QWORD PTR [esp], xmm2
  00047	ff 75 08	 push	 DWORD PTR _point$[ebp]
  0004a	e8 00 00 00 00	 call	 ?GetSignalDatabyUsingGraphDataandTwoBaseLine@CSignal@@AAEXABVCPoint@@NNPAV?$CList@NN@@PAVCPacket@@@Z ; CSignal::GetSignalDatabyUsingGraphDataandTwoBaseLine
$LN3@GetSignalT:

; 286  : }

  0004f	5d		 pop	 ebp
  00050	c2 10 00	 ret	 16			; 00000010H
?GetSignalTypesbyUsingGraphDataandTwoBaseLine@CSignal@@AAEXABVCPoint@@PAV?$CList@NN@@1PAVCPacket@@@Z ENDP ; CSignal::GetSignalTypesbyUsingGraphDataandTwoBaseLine
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartFormulate\Signal.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartFormulate\Signal.cpp
;	COMDAT ?GetFirstNonZeroValueIndex@CSignal@@AAEHPAV?$CList@NN@@@Z
_TEXT	SEGMENT
_pGraphData1$ = 8					; size = 4
?GetFirstNonZeroValueIndex@CSignal@@AAEHPAV?$CList@NN@@@Z PROC ; CSignal::GetFirstNonZeroValueIndex, COMDAT
; _this$ = ecx

; 355  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 356  : 	if( !pGraphData1) return 0;

  00003	8b 55 08	 mov	 edx, DWORD PTR _pGraphData1$[ebp]
  00006	56		 push	 esi
  00007	85 d2		 test	 edx, edx
  00009	74 3c		 je	 SHORT $LN16@GetFirstNo

; 357  : 
; 358  : 	const int nCnt = pGraphData1->GetCount();

  0000b	8b 72 0c	 mov	 esi, DWORD PTR [edx+12]

; 359  : 	POSITION pos = pGraphData1->GetHeadPosition();

  0000e	8b 52 04	 mov	 edx, DWORD PTR [edx+4]

; 360  : 	if(pos == NULL)

  00011	85 d2		 test	 edx, edx
  00013	74 32		 je	 SHORT $LN16@GetFirstNo

; 362  : 	for(int start = 0; start < nCnt; start++)

  00015	33 c9		 xor	 ecx, ecx
  00017	85 f6		 test	 esi, esi
  00019	7e 1d		 jle	 SHORT $LN3@GetFirstNo
  0001b	0f 57 c9	 xorps	 xmm1, xmm1
  0001e	66 90		 npad	 2
$LL4@GetFirstNo:

; 364  : 		if(pGraphData1->GetNext(pos) != 0)

  00020	f2 0f 10 42 08	 movsd	 xmm0, QWORD PTR [edx+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 811  : 	{ CNode* pNode = (CNode*) rPosition;

  00025	8d 02		 lea	 eax, DWORD PTR [edx]

; 812  : 		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 813  : 		rPosition = (POSITION) pNode->pNext;

  00027	8b 12		 mov	 edx, DWORD PTR [edx]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartFormulate\Signal.cpp

; 364  : 		if(pGraphData1->GetNext(pos) != 0)

  00029	66 0f 2e c1	 ucomisd xmm0, xmm1
  0002d	9f		 lahf
  0002e	f6 c4 44	 test	 ah, 68			; 00000044H
  00031	7a 0d		 jp	 SHORT $LN12@GetFirstNo

; 362  : 	for(int start = 0; start < nCnt; start++)

  00033	41		 inc	 ecx
  00034	3b ce		 cmp	 ecx, esi
  00036	7c e8		 jl	 SHORT $LL4@GetFirstNo
$LN3@GetFirstNo:

; 366  : 	return pGraphData1->GetCount()-1;

  00038	8d 46 ff	 lea	 eax, DWORD PTR [esi-1]
  0003b	5e		 pop	 esi

; 367  : 
; 368  : }

  0003c	5d		 pop	 ebp
  0003d	c2 04 00	 ret	 4
$LN12@GetFirstNo:

; 365  : 			return start;

  00040	8b c1		 mov	 eax, ecx
  00042	5e		 pop	 esi

; 367  : 
; 368  : }

  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
$LN16@GetFirstNo:

; 361  : 		return 0;

  00047	33 c0		 xor	 eax, eax
  00049	5e		 pop	 esi

; 367  : 
; 368  : }

  0004a	5d		 pop	 ebp
  0004b	c2 04 00	 ret	 4
?GetFirstNonZeroValueIndex@CSignal@@AAEHPAV?$CList@NN@@@Z ENDP ; CSignal::GetFirstNonZeroValueIndex
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartFormulate\Signal.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartFormulate\Signal.cpp
;	COMDAT ?GetCurDataFromList@CSignal@@AAENAAPAU__POSITION@@PAV?$CList@NN@@@Z
_TEXT	SEGMENT
_pos$ = 8						; size = 4
_pGraphData$ = 12					; size = 4
?GetCurDataFromList@CSignal@@AAENAAPAU__POSITION@@PAV?$CList@NN@@@Z PROC ; CSignal::GetCurDataFromList, COMDAT
; _this$ = ecx

; 405  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 406  : 	if(pGraphData == NULL || pos == NULL)

  00003	83 7d 0c 00	 cmp	 DWORD PTR _pGraphData$[ebp], 0
  00007	74 14		 je	 SHORT $LN3@GetCurData
  00009	8b 55 08	 mov	 edx, DWORD PTR _pos$[ebp]
  0000c	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0000e	85 c9		 test	 ecx, ecx
  00010	74 0b		 je	 SHORT $LN3@GetCurData
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 813  : 		rPosition = (POSITION) pNode->pNext;

  00012	8b 01		 mov	 eax, DWORD PTR [ecx]
  00014	89 02		 mov	 DWORD PTR [edx], eax
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartFormulate\Signal.cpp

; 409  : 	return pGraphData->GetNext(pos);

  00016	dd 41 08	 fld	 QWORD PTR [ecx+8]

; 410  : }

  00019	5d		 pop	 ebp
  0001a	c2 08 00	 ret	 8
$LN3@GetCurData:

; 407  : 		return 0;

  0001d	d9 ee		 fldz

; 410  : }

  0001f	5d		 pop	 ebp
  00020	c2 08 00	 ret	 8
?GetCurDataFromList@CSignal@@AAENAAPAU__POSITION@@PAV?$CList@NN@@@Z ENDP ; CSignal::GetCurDataFromList
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartFormulate\Signal.cpp
;	COMDAT ?GetSignalType3@CSignal@@AAE?AW4SignalTYPE@CGraphBaseData@@NNNN@Z
_TEXT	SEGMENT
_oldBaseData$ = 8					; size = 8
_nowBaseData$ = 16					; size = 8
_oldData$ = 24						; size = 8
_nowData$ = 32						; size = 8
?GetSignalType3@CSignal@@AAE?AW4SignalTYPE@CGraphBaseData@@NNNN@Z PROC ; CSignal::GetSignalType3, COMDAT
; _this$ = ecx

; 371  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 372  : 	// 비교할 값 = xxxData (graphData1), 비교할 기준값 = xxxBaseData (graphData2)
; 373  : 	if(oldData <= oldBaseData && nowData > nowBaseData)

  00003	f2 0f 10 55 08	 movsd	 xmm2, QWORD PTR _oldBaseData$[ebp]
  00008	f2 0f 10 5d 18	 movsd	 xmm3, QWORD PTR _oldData$[ebp]
  0000d	66 0f 2f d3	 comisd	 xmm2, xmm3
  00011	f2 0f 10 45 20	 movsd	 xmm0, QWORD PTR _nowData$[ebp]
  00016	f2 0f 10 4d 10	 movsd	 xmm1, QWORD PTR _nowBaseData$[ebp]
  0001b	72 0f		 jb	 SHORT $LN2@GetSignalT
  0001d	66 0f 2f c1	 comisd	 xmm0, xmm1
  00021	76 09		 jbe	 SHORT $LN2@GetSignalT

; 374  : 		return CGraphBaseData::BUY; // 매수

  00023	b8 01 00 00 00	 mov	 eax, 1

; 379  : 
; 380  : }

  00028	5d		 pop	 ebp
  00029	c2 20 00	 ret	 32			; 00000020H
$LN2@GetSignalT:

; 375  : 	if(oldData >= oldBaseData && nowData < nowBaseData)

  0002c	66 0f 2f da	 comisd	 xmm3, xmm2
  00030	72 0f		 jb	 SHORT $LN3@GetSignalT
  00032	66 0f 2f c8	 comisd	 xmm1, xmm0
  00036	76 09		 jbe	 SHORT $LN3@GetSignalT

; 376  : 		return CGraphBaseData::SELL;// 매도

  00038	b8 02 00 00 00	 mov	 eax, 2

; 379  : 
; 380  : }

  0003d	5d		 pop	 ebp
  0003e	c2 20 00	 ret	 32			; 00000020H
$LN3@GetSignalT:

; 377  : 
; 378  : 	return CGraphBaseData::NONE;

  00041	33 c0		 xor	 eax, eax

; 379  : 
; 380  : }

  00043	5d		 pop	 ebp
  00044	c2 20 00	 ret	 32			; 00000020H
?GetSignalType3@CSignal@@AAE?AW4SignalTYPE@CGraphBaseData@@NNNN@Z ENDP ; CSignal::GetSignalType3
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartFormulate\Signal.cpp
;	COMDAT ?GetSignalType@CSignal@@AAE?AW4SignalTYPE@CGraphBaseData@@NNN@Z
_TEXT	SEGMENT
_baseline$ = 8						; size = 8
_oldData$ = 16						; size = 8
_nowData$ = 24						; size = 8
?GetSignalType@CSignal@@AAE?AW4SignalTYPE@CGraphBaseData@@NNN@Z PROC ; CSignal::GetSignalType, COMDAT
; _this$ = ecx

; 383  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 384  : 	if(oldData <= baseline && nowData > baseline)

  00003	f2 0f 10 45 08	 movsd	 xmm0, QWORD PTR _baseline$[ebp]
  00008	f2 0f 10 55 10	 movsd	 xmm2, QWORD PTR _oldData$[ebp]
  0000d	66 0f 2f c2	 comisd	 xmm0, xmm2
  00011	f2 0f 10 4d 18	 movsd	 xmm1, QWORD PTR _nowData$[ebp]
  00016	72 0f		 jb	 SHORT $LN2@GetSignalT
  00018	66 0f 2f c8	 comisd	 xmm1, xmm0
  0001c	76 09		 jbe	 SHORT $LN2@GetSignalT

; 385  : 		return CGraphBaseData::BUY; // 매수

  0001e	b8 01 00 00 00	 mov	 eax, 1

; 390  : }

  00023	5d		 pop	 ebp
  00024	c2 18 00	 ret	 24			; 00000018H
$LN2@GetSignalT:

; 386  : 	if(oldData >= baseline && nowData < baseline)

  00027	66 0f 2f d0	 comisd	 xmm2, xmm0
  0002b	72 0f		 jb	 SHORT $LN3@GetSignalT
  0002d	66 0f 2f c1	 comisd	 xmm0, xmm1
  00031	76 09		 jbe	 SHORT $LN3@GetSignalT

; 387  : 		return CGraphBaseData::SELL; // 매도

  00033	b8 02 00 00 00	 mov	 eax, 2

; 390  : }

  00038	5d		 pop	 ebp
  00039	c2 18 00	 ret	 24			; 00000018H
$LN3@GetSignalT:

; 388  : 
; 389  : 	return CGraphBaseData::NONE;

  0003c	33 c0		 xor	 eax, eax

; 390  : }

  0003e	5d		 pop	 ebp
  0003f	c2 18 00	 ret	 24			; 00000018H
?GetSignalType@CSignal@@AAE?AW4SignalTYPE@CGraphBaseData@@NNN@Z ENDP ; CSignal::GetSignalType
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartFormulate\Signal.cpp
;	COMDAT ?GetSignalType@CSignal@@AAE?AW4SignalTYPE@CGraphBaseData@@NNNN@Z
_TEXT	SEGMENT
_upBaseline$ = 8					; size = 8
_downBaseline$ = 16					; size = 8
_oldData$ = 24						; size = 8
_nowData$ = 32						; size = 8
?GetSignalType@CSignal@@AAE?AW4SignalTYPE@CGraphBaseData@@NNNN@Z PROC ; CSignal::GetSignalType, COMDAT
; _this$ = ecx

; 393  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 394  : 	// 하향 기준선 = downBaseline, 상향 기준선 = upBaseline
; 395  : 	if(oldData <= downBaseline && nowData > downBaseline) 

  00003	f2 0f 10 45 10	 movsd	 xmm0, QWORD PTR _downBaseline$[ebp]
  00008	f2 0f 10 55 18	 movsd	 xmm2, QWORD PTR _oldData$[ebp]
  0000d	66 0f 2f c2	 comisd	 xmm0, xmm2
  00011	f2 0f 10 4d 20	 movsd	 xmm1, QWORD PTR _nowData$[ebp]
  00016	72 0f		 jb	 SHORT $LN2@GetSignalT
  00018	66 0f 2f c8	 comisd	 xmm1, xmm0
  0001c	76 09		 jbe	 SHORT $LN2@GetSignalT

; 396  : 		return CGraphBaseData::BUY; // 매수

  0001e	b8 01 00 00 00	 mov	 eax, 1

; 402  : }

  00023	5d		 pop	 ebp
  00024	c2 20 00	 ret	 32			; 00000020H
$LN2@GetSignalT:

; 397  : 
; 398  : 	if(oldData >= upBaseline && nowData < upBaseline) 

  00027	f2 0f 10 45 08	 movsd	 xmm0, QWORD PTR _upBaseline$[ebp]
  0002c	66 0f 2f d0	 comisd	 xmm2, xmm0
  00030	72 0f		 jb	 SHORT $LN3@GetSignalT
  00032	66 0f 2f c1	 comisd	 xmm0, xmm1
  00036	76 09		 jbe	 SHORT $LN3@GetSignalT

; 399  : 		return CGraphBaseData::SELL; // 매도

  00038	b8 02 00 00 00	 mov	 eax, 2

; 402  : }

  0003d	5d		 pop	 ebp
  0003e	c2 20 00	 ret	 32			; 00000020H
$LN3@GetSignalT:

; 400  : 
; 401  : 	return CGraphBaseData::NONE;

  00041	33 c0		 xor	 eax, eax

; 402  : }

  00043	5d		 pop	 ebp
  00044	c2 20 00	 ret	 32			; 00000020H
?GetSignalType@CSignal@@AAE?AW4SignalTYPE@CGraphBaseData@@NNNN@Z ENDP ; CSignal::GetSignalType
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartFormulate\Signal.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartFormulate\Signal.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartFormulate\Signal.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartFormulate\Signal.cpp
;	COMDAT ?MakeRealPacket@CSignal@@AAEXABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAV?$CList@NN@@AAV4@@Z
_TEXT	SEGMENT
_data$1$ = -8						; size = 8
_strGraphName$ = 8					; size = 4
$T1 = 12						; size = 4
_pDataList$ = 12					; size = 4
_dRealDataList$ = 16					; size = 4
?MakeRealPacket@CSignal@@AAEXABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAV?$CList@NN@@AAV4@@Z PROC ; CSignal::MakeRealPacket, COMDAT
; _this$ = ecx

; 413  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx

; 414  : 	if(pDataList == NULL)

  00007	8b 5d 0c	 mov	 ebx, DWORD PTR _pDataList$[ebp]
  0000a	85 db		 test	 ebx, ebx
  0000c	0f 84 b7 00 00
	00		 je	 $LN37@MakeRealPa

; 417  : 	for(POSITION pos = pDataList->GetHeadPosition(); pos ; ) {

  00012	8b 5b 04	 mov	 ebx, DWORD PTR [ebx+4]
  00015	85 db		 test	 ebx, ebx
  00017	0f 84 ac 00 00
	00		 je	 $LN37@MakeRealPa
  0001d	56		 push	 esi
  0001e	8b 75 10	 mov	 esi, DWORD PTR _dRealDataList$[ebp]
  00021	57		 push	 edi
  00022	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00025	89 4d 0c	 mov	 DWORD PTR $T1[ebp], ecx
  00028	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL2@MakeRealPa:

; 418  : 		double data = pDataList->GetNext(pos);

  00030	f2 0f 10 43 08	 movsd	 xmm0, QWORD PTR [ebx+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 811  : 	{ CNode* pNode = (CNode*) rPosition;

  00035	8d 03		 lea	 eax, DWORD PTR [ebx]

; 902  : 	if (m_pNodeFree == NULL)

  00037	8b 56 10	 mov	 edx, DWORD PTR [esi+16]

; 813  : 		rPosition = (POSITION) pNode->pNext;

  0003a	8b 1b		 mov	 ebx, DWORD PTR [ebx]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartFormulate\Signal.cpp

; 418  : 		double data = pDataList->GetNext(pos);

  0003c	f2 0f 11 45 f8	 movsd	 QWORD PTR _data$1$[ebp], xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 902  : 	if (m_pNodeFree == NULL)

  00041	85 d2		 test	 edx, edx
  00043	75 4e		 jne	 SHORT $LN35@MakeRealPa

; 903  : 	{
; 904  : 		// add another block
; 905  : 		CPlex* pNewBlock = CPlex::Create(m_pBlocks, m_nBlockSize,

  00045	6a 10		 push	 16			; 00000010H
  00047	ff 76 18	 push	 DWORD PTR [esi+24]
  0004a	8d 46 14	 lea	 eax, DWORD PTR [esi+20]
  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 ?Create@CPlex@@SGPAU1@AAPAU1@II@Z ; CPlex::Create

; 906  : 				 sizeof(CNode));
; 907  : 
; 908  : 		// chain them into free list
; 909  : 		CNode* pNode = (CNode*) pNewBlock->data();
; 910  : 		// free in reverse order to make it easier to debug
; 911  : 		pNode += m_nBlockSize - 1;

  00053	8b 56 18	 mov	 edx, DWORD PTR [esi+24]
  00056	83 c0 08	 add	 eax, 8
  00059	8b ca		 mov	 ecx, edx
  0005b	c1 e1 04	 shl	 ecx, 4
  0005e	83 c1 f0	 add	 ecx, -16		; fffffff0H

; 912  : 		for (INT_PTR i = m_nBlockSize-1; i >= 0; i--, pNode--)

  00061	8d 7a ff	 lea	 edi, DWORD PTR [edx-1]
  00064	03 c8		 add	 ecx, eax
  00066	85 ff		 test	 edi, edi
  00068	78 1a		 js	 SHORT $LN36@MakeRealPa
  0006a	66 0f 1f 44 00
	00		 npad	 6
$LL16@MakeRealPa:

; 913  : 		{
; 914  : 			pNode->pNext = m_pNodeFree;

  00070	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00073	8b d1		 mov	 edx, ecx
  00075	89 01		 mov	 DWORD PTR [ecx], eax

; 915  : 			m_pNodeFree = pNode;

  00077	89 4e 10	 mov	 DWORD PTR [esi+16], ecx
  0007a	83 e9 10	 sub	 ecx, 16			; 00000010H
  0007d	83 ef 01	 sub	 edi, 1
  00080	79 ee		 jns	 SHORT $LL16@MakeRealPa
  00082	eb 03		 jmp	 SHORT $LN19@MakeRealPa
$LN36@MakeRealPa:
  00084	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
$LN19@MakeRealPa:

; 918  : 	ENSURE(m_pNodeFree != NULL);  // we must have something

  00087	85 d2		 test	 edx, edx
  00089	74 45		 je	 SHORT $LN27@MakeRealPa
  0008b	f2 0f 10 45 f8	 movsd	 xmm0, QWORD PTR _data$1$[ebp]
  00090	8b 4d 0c	 mov	 ecx, DWORD PTR $T1[ebp]
$LN35@MakeRealPa:

; 919  : 
; 920  : 	CList::CNode* pNode = m_pNodeFree;
; 921  : 	m_pNodeFree = m_pNodeFree->pNext;

  00093	8b 02		 mov	 eax, DWORD PTR [edx]
  00095	89 46 10	 mov	 DWORD PTR [esi+16], eax

; 922  : 	pNode->pPrev = pPrev;

  00098	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 923  : 	pNode->pNext = pNext;

  0009b	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 924  : 	m_nCount++;

  000a1	ff 46 0c	 inc	 DWORD PTR [esi+12]

; 969  : 	pNewNode->data = newElement;

  000a4	f2 0f 11 42 08	 movsd	 QWORD PTR [edx+8], xmm0

; 970  : 	if (m_pNodeTail != NULL)

  000a9	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000ac	85 c0		 test	 eax, eax
  000ae	74 04		 je	 SHORT $LN10@MakeRealPa

; 971  : 		m_pNodeTail->pNext = pNewNode;

  000b0	89 10		 mov	 DWORD PTR [eax], edx
  000b2	eb 03		 jmp	 SHORT $LN11@MakeRealPa
$LN10@MakeRealPa:

; 972  : 	else
; 973  : 		m_pNodeHead = pNewNode;

  000b4	89 56 04	 mov	 DWORD PTR [esi+4], edx
$LN11@MakeRealPa:

; 974  : 	m_pNodeTail = pNewNode;

  000b7	89 56 08	 mov	 DWORD PTR [esi+8], edx
  000ba	8b ca		 mov	 ecx, edx
  000bc	89 4d 0c	 mov	 DWORD PTR $T1[ebp], ecx
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartFormulate\Signal.cpp

; 417  : 	for(POSITION pos = pDataList->GetHeadPosition(); pos ; ) {

  000bf	85 db		 test	 ebx, ebx
  000c1	0f 85 69 ff ff
	ff		 jne	 $LL2@MakeRealPa
  000c7	5f		 pop	 edi
  000c8	5e		 pop	 esi
$LN37@MakeRealPa:
  000c9	5b		 pop	 ebx

; 437  : }

  000ca	8b e5		 mov	 esp, ebp
  000cc	5d		 pop	 ebp
  000cd	c2 0c 00	 ret	 12			; 0000000cH
$LN27@MakeRealPa:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 918  : 	ENSURE(m_pNodeFree != NULL);  // we must have something

  000d0	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN40@MakeRealPa:
  000d5	cc		 int	 3
?MakeRealPacket@CSignal@@AAEXABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAV?$CList@NN@@AAV4@@Z ENDP ; CSignal::MakeRealPacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartFormulate\Signal.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartFormulate\Signal.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartFormulate\Signal.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartFormulate\Signal.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartFormulate\Signal.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartFormulate\Signal.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartFormulate\Signal.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartFormulate\Signal.cpp
;	COMDAT ?GetSignalTypesbyUsingGraphDatas@CSignal@@QAEXABVCPoint@@PAV?$CList@NN@@1PAVCPacket@@@Z
_TEXT	SEGMENT
_nCnt$1$ = -16						; size = 4
_i$1$ = -12						; size = 4
_prepos1$1$ = -8					; size = 4
_prepos2$1$ = -4					; size = 4
_point$ = 8						; size = 4
_pGraphData2$ = 12					; size = 4
tv463 = 16						; size = 4
_pGraphData1$ = 16					; size = 4
_pSignalPacket$ = 20					; size = 4
?GetSignalTypesbyUsingGraphDatas@CSignal@@QAEXABVCPoint@@PAV?$CList@NN@@1PAVCPacket@@@Z PROC ; CSignal::GetSignalTypesbyUsingGraphDatas, COMDAT
; _this$ = ecx

; 156  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 157  : 	if(pGraphData1 == NULL || pGraphData2 == NULL) return;

  00006	83 7d 10 00	 cmp	 DWORD PTR _pGraphData1$[ebp], 0
  0000a	0f 84 12 02 00
	00		 je	 $LN14@GetSignalT
  00010	8b 45 0c	 mov	 eax, DWORD PTR _pGraphData2$[ebp]
  00013	85 c0		 test	 eax, eax
  00015	0f 84 07 02 00
	00		 je	 $LN14@GetSignalT

; 358  : 	const int nCnt = pGraphData1->GetCount();

  0001b	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  0001e	53		 push	 ebx

; 359  : 	POSITION pos = pGraphData1->GetHeadPosition();

  0001f	8b 58 04	 mov	 ebx, DWORD PTR [eax+4]
  00022	8b cb		 mov	 ecx, ebx
  00024	57		 push	 edi

; 360  : 	if(pos == NULL)

  00025	33 ff		 xor	 edi, edi
  00027	85 c9		 test	 ecx, ecx
  00029	74 22		 je	 SHORT $LN18@GetSignalT

; 361  : 		return 0;
; 362  : 	for(int start = 0; start < nCnt; start++)

  0002b	85 d2		 test	 edx, edx
  0002d	7e 1b		 jle	 SHORT $LN20@GetSignalT
  0002f	0f 57 c9	 xorps	 xmm1, xmm1
$LL21@GetSignalT:

; 364  : 		if(pGraphData1->GetNext(pos) != 0)

  00032	f2 0f 10 41 08	 movsd	 xmm0, QWORD PTR [ecx+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 811  : 	{ CNode* pNode = (CNode*) rPosition;

  00037	8d 01		 lea	 eax, DWORD PTR [ecx]

; 813  : 		rPosition = (POSITION) pNode->pNext;

  00039	8b 09		 mov	 ecx, DWORD PTR [ecx]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartFormulate\Signal.cpp

; 364  : 		if(pGraphData1->GetNext(pos) != 0)

  0003b	66 0f 2e c1	 ucomisd xmm0, xmm1
  0003f	9f		 lahf
  00040	f6 c4 44	 test	 ah, 68			; 00000044H
  00043	7a 08		 jp	 SHORT $LN18@GetSignalT

; 361  : 		return 0;
; 362  : 	for(int start = 0; start < nCnt; start++)

  00045	47		 inc	 edi
  00046	3b fa		 cmp	 edi, edx
  00048	7c e8		 jl	 SHORT $LL21@GetSignalT
$LN20@GetSignalT:

; 365  : 			return start;
; 366  : 	return pGraphData1->GetCount()-1;

  0004a	8d 7a ff	 lea	 edi, DWORD PTR [edx-1]
$LN18@GetSignalT:

; 158  : 	// 비교할 값 = graphData1, 비교할 기준값 = graphData2
; 159  : 	// --> ex) Macd Signal : 
; 160  : 	//         매수 -> Macd가 Signal 상향돌파, 매도 -> Macd가 Signal 하향돌파
; 161  : 	//         graphData1 --> Macd,   graphData2 --> Signal
; 162  : 
; 163  : 	// 처음으로 "0"아닌 값은 무조건 none이다!
; 164  : 	int nFirstNonZeroValue = GetFirstNonZeroValueIndex(pGraphData2);
; 165  : 	const int nCnt = pGraphData1->GetCount();

  0004d	8b 45 10	 mov	 eax, DWORD PTR _pGraphData1$[ebp]

; 166  : 
; 167  : 	POSITION prepos1 = NULL, prepos2 = NULL;

  00050	33 c9		 xor	 ecx, ecx
  00052	89 4d f8	 mov	 DWORD PTR _prepos1$1$[ebp], ecx
  00055	89 4d fc	 mov	 DWORD PTR _prepos2$1$[ebp], ecx

; 168  : 	POSITION pos1 = NULL;
; 169  : 	POSITION pos2 = NULL;
; 170  : 
; 171  : 	if(point.x == 0)

  00058	8b 4d 08	 mov	 ecx, DWORD PTR _point$[ebp]
  0005b	56		 push	 esi
  0005c	8b 70 0c	 mov	 esi, DWORD PTR [eax+12]
  0005f	89 75 f0	 mov	 DWORD PTR _nCnt$1$[ebp], esi
  00062	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00064	89 4d f4	 mov	 DWORD PTR _i$1$[ebp], ecx
  00067	85 c9		 test	 ecx, ecx
  00069	75 50		 jne	 SHORT $LN7@GetSignalT

; 172  : 	{
; 173  : 		pos1 = pGraphData1->GetHeadPosition();

  0006b	8b 70 04	 mov	 esi, DWORD PTR [eax+4]

; 174  : 		pos2 = pGraphData2->GetHeadPosition();
; 175  : 		if(pos1 == NULL || pos2 == NULL)

  0006e	85 f6		 test	 esi, esi
  00070	0f 84 a9 01 00
	00		 je	 $LN80@GetSignalT
  00076	85 db		 test	 ebx, ebx
  00078	0f 84 a1 01 00
	00		 je	 $LN80@GetSignalT
  0007e	33 d2		 xor	 edx, edx
$LN13@GetSignalT:

; 189  : 			return ;
; 190  : 
; 191  : 	}
; 192  : 	for(int i = point.x; i < nCnt; i++){

  00080	3b 4d f0	 cmp	 ecx, DWORD PTR _nCnt$1$[ebp]
  00083	0f 8d 96 01 00
	00		 jge	 $LN80@GetSignalT
  00089	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  0008c	8b 7d 08	 mov	 edi, DWORD PTR _point$[ebp]
  0008f	89 45 10	 mov	 DWORD PTR tv463[ebp], eax
  00092	8b 45 14	 mov	 eax, DWORD PTR _pSignalPacket$[ebp]
  00095	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL4@GetSignalT:

; 193  : 		if(i >= (nFirstNonZeroValue+1)) {

  000a0	0f 57 c0	 xorps	 xmm0, xmm0
  000a3	3b 4d 10	 cmp	 ecx, DWORD PTR tv463[ebp]
  000a6	0f 8c 27 01 00
	00		 jl	 $LN15@GetSignalT

; 406  : 	if(pGraphData == NULL || pos == NULL)

  000ac	85 f6		 test	 esi, esi
  000ae	74 7d		 je	 SHORT $LN30@GetSignalT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 811  : 	{ CNode* pNode = (CNode*) rPosition;

  000b0	8b c6		 mov	 eax, esi

; 813  : 		rPosition = (POSITION) pNode->pNext;

  000b2	8b 36		 mov	 esi, DWORD PTR [esi]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartFormulate\Signal.cpp

; 409  : 	return pGraphData->GetNext(pos);

  000b4	f2 0f 10 58 08	 movsd	 xmm3, QWORD PTR [eax+8]
  000b9	eb 75		 jmp	 SHORT $LN28@GetSignalT
$LN7@GetSignalT:

; 176  : 			return ;
; 177  : 
; 178  : 	}
; 179  : 	else
; 180  : 	{
; 181  : 		if(pGraphData1->GetCount() < 2 || pGraphData2->GetCount() < 2)

  000bb	83 fe 02	 cmp	 esi, 2
  000be	0f 8c 5b 01 00
	00		 jl	 $LN80@GetSignalT
  000c4	83 fa 02	 cmp	 edx, 2
  000c7	0f 8c 52 01 00
	00		 jl	 $LN80@GetSignalT

; 182  : 			return ;
; 183  : 		prepos1 = pGraphData1->FindIndex(point.x - 1);

  000cd	8d 71 ff	 lea	 esi, DWORD PTR [ecx-1]
  000d0	8b c8		 mov	 ecx, eax
  000d2	56		 push	 esi
  000d3	e8 00 00 00 00	 call	 ?FindIndex@?$CList@NN@@QBEPAU__POSITION@@H@Z ; CList<double,double>::FindIndex

; 184  : 		prepos2 = pGraphData2->FindIndex(point.x - 1);

  000d8	8b 4d 0c	 mov	 ecx, DWORD PTR _pGraphData2$[ebp]
  000db	56		 push	 esi
  000dc	89 45 f8	 mov	 DWORD PTR _prepos1$1$[ebp], eax
  000df	e8 00 00 00 00	 call	 ?FindIndex@?$CList@NN@@QBEPAU__POSITION@@H@Z ; CList<double,double>::FindIndex

; 185  : 		pos1 = pGraphData1->FindIndex(point.x);

  000e4	8b 5d f4	 mov	 ebx, DWORD PTR _i$1$[ebp]
  000e7	8b 4d 10	 mov	 ecx, DWORD PTR _pGraphData1$[ebp]
  000ea	53		 push	 ebx
  000eb	89 45 fc	 mov	 DWORD PTR _prepos2$1$[ebp], eax
  000ee	e8 00 00 00 00	 call	 ?FindIndex@?$CList@NN@@QBEPAU__POSITION@@H@Z ; CList<double,double>::FindIndex

; 186  : 		pos2 = pGraphData2->FindIndex(point.x);

  000f3	8b 4d 0c	 mov	 ecx, DWORD PTR _pGraphData2$[ebp]
  000f6	8b f0		 mov	 esi, eax
  000f8	53		 push	 ebx
  000f9	e8 00 00 00 00	 call	 ?FindIndex@?$CList@NN@@QBEPAU__POSITION@@H@Z ; CList<double,double>::FindIndex

; 187  : 
; 188  : 		if(prepos1 == NULL || prepos2 == NULL || pos1 == NULL || pos2 == NULL)

  000fe	8b 55 f8	 mov	 edx, DWORD PTR _prepos1$1$[ebp]
  00101	8b d8		 mov	 ebx, eax
  00103	85 d2		 test	 edx, edx
  00105	0f 84 14 01 00
	00		 je	 $LN80@GetSignalT
  0010b	83 7d fc 00	 cmp	 DWORD PTR _prepos2$1$[ebp], 0
  0010f	0f 84 0a 01 00
	00		 je	 $LN80@GetSignalT
  00115	85 f6		 test	 esi, esi
  00117	0f 84 02 01 00
	00		 je	 $LN80@GetSignalT
  0011d	85 db		 test	 ebx, ebx
  0011f	0f 84 fa 00 00
	00		 je	 $LN80@GetSignalT

; 174  : 		pos2 = pGraphData2->GetHeadPosition();
; 175  : 		if(pos1 == NULL || pos2 == NULL)

  00125	8b 4d f4	 mov	 ecx, DWORD PTR _i$1$[ebp]
  00128	e9 53 ff ff ff	 jmp	 $LN13@GetSignalT
$LN30@GetSignalT:
  0012d	0f 57 db	 xorps	 xmm3, xmm3
$LN28@GetSignalT:

; 406  : 	if(pGraphData == NULL || pos == NULL)

  00130	85 db		 test	 ebx, ebx
  00132	74 0b		 je	 SHORT $LN36@GetSignalT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 811  : 	{ CNode* pNode = (CNode*) rPosition;

  00134	8b c3		 mov	 eax, ebx

; 813  : 		rPosition = (POSITION) pNode->pNext;

  00136	8b 1b		 mov	 ebx, DWORD PTR [ebx]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartFormulate\Signal.cpp

; 409  : 	return pGraphData->GetNext(pos);

  00138	f2 0f 10 50 08	 movsd	 xmm2, QWORD PTR [eax+8]
  0013d	eb 03		 jmp	 SHORT $LN34@GetSignalT
$LN36@GetSignalT:
  0013f	0f 57 d2	 xorps	 xmm2, xmm2
$LN34@GetSignalT:

; 406  : 	if(pGraphData == NULL || pos == NULL)

  00142	85 d2		 test	 edx, edx
  00144	74 0e		 je	 SHORT $LN42@GetSignalT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 811  : 	{ CNode* pNode = (CNode*) rPosition;

  00146	8b c2		 mov	 eax, edx

; 813  : 		rPosition = (POSITION) pNode->pNext;

  00148	8b 12		 mov	 edx, DWORD PTR [edx]
  0014a	89 55 f8	 mov	 DWORD PTR _prepos1$1$[ebp], edx
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartFormulate\Signal.cpp

; 409  : 	return pGraphData->GetNext(pos);

  0014d	f2 0f 10 48 08	 movsd	 xmm1, QWORD PTR [eax+8]
  00152	eb 03		 jmp	 SHORT $LN40@GetSignalT
$LN42@GetSignalT:
  00154	0f 57 c9	 xorps	 xmm1, xmm1
$LN40@GetSignalT:

; 406  : 	if(pGraphData == NULL || pos == NULL)

  00157	8b 7d fc	 mov	 edi, DWORD PTR _prepos2$1$[ebp]
  0015a	85 ff		 test	 edi, edi
  0015c	74 0c		 je	 SHORT $LN48@GetSignalT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 811  : 	{ CNode* pNode = (CNode*) rPosition;

  0015e	8b c7		 mov	 eax, edi

; 813  : 		rPosition = (POSITION) pNode->pNext;

  00160	8b 3f		 mov	 edi, DWORD PTR [edi]
  00162	89 7d fc	 mov	 DWORD PTR _prepos2$1$[ebp], edi
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartFormulate\Signal.cpp

; 409  : 	return pGraphData->GetNext(pos);

  00165	f2 0f 10 40 08	 movsd	 xmm0, QWORD PTR [eax+8]
$LN48@GetSignalT:

; 373  : 	if(oldData <= oldBaseData && nowData > nowBaseData)

  0016a	66 0f 2f c1	 comisd	 xmm0, xmm1
  0016e	72 0d		 jb	 SHORT $LN53@GetSignalT
  00170	66 0f 2f da	 comisd	 xmm3, xmm2
  00174	76 07		 jbe	 SHORT $LN53@GetSignalT

; 374  : 		return CGraphBaseData::BUY; // 매수

  00176	b8 01 00 00 00	 mov	 eax, 1
  0017b	eb 15		 jmp	 SHORT $LN52@GetSignalT
$LN53@GetSignalT:

; 375  : 	if(oldData >= oldBaseData && nowData < nowBaseData)

  0017d	66 0f 2f c8	 comisd	 xmm1, xmm0
  00181	72 0d		 jb	 SHORT $LN54@GetSignalT
  00183	66 0f 2f d3	 comisd	 xmm2, xmm3
  00187	76 07		 jbe	 SHORT $LN54@GetSignalT

; 376  : 		return CGraphBaseData::SELL;// 매도

  00189	b8 02 00 00 00	 mov	 eax, 2
  0018e	eb 02		 jmp	 SHORT $LN52@GetSignalT
$LN54@GetSignalT:

; 377  : 
; 378  : 	return CGraphBaseData::NONE;

  00190	33 c0		 xor	 eax, eax
$LN52@GetSignalT:
  00192	66 0f 6e c0	 movd	 xmm0, eax

; 147  : 	if(point.x == 0)

  00196	8b 45 08	 mov	 eax, DWORD PTR _point$[ebp]

; 194  : 		// 이전, 현재기준이 될값(graphData2), 이전, 현재비교할 값(graphData1)
; 195  : 			double nCurrentData = GetCurDataFromList( pos1, pGraphData1 );
; 196  : 			double nCurrentBaseData = GetCurDataFromList(pos2, pGraphData2);
; 197  : 			double nOldData = GetCurDataFromList(prepos1, pGraphData1);
; 198  : 			double nOldBaseData = GetCurDataFromList(prepos2, pGraphData2);
; 199  : 			SetData(point, i, GetSignalType3(nOldBaseData, nCurrentBaseData, nOldData, nCurrentData), pSignalPacket);

  00199	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0

; 147  : 	if(point.x == 0)

  0019d	83 38 00	 cmp	 DWORD PTR [eax], 0
  001a0	75 18		 jne	 SHORT $LN57@GetSignalT

; 148  : 		pPacket->AppendData(dData);

  001a2	8b 4d 14	 mov	 ecx, DWORD PTR _pSignalPacket$[ebp]
  001a5	6a ff		 push	 -1
  001a7	83 ec 08	 sub	 esp, 8
  001aa	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  001af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?AppendData@CPacket@@QAEXNH@Z
  001b5	8b 7d 08	 mov	 edi, DWORD PTR _point$[ebp]
  001b8	eb 4f		 jmp	 SHORT $LN2@GetSignalT
$LN57@GetSignalT:

; 149  : 	else
; 150  : 		pPacket->UpdateData(dData, nUpdateIndex, false);

  001ba	6a 00		 push	 0
  001bc	51		 push	 ecx
  001bd	8b 4d 14	 mov	 ecx, DWORD PTR _pSignalPacket$[ebp]
  001c0	83 ec 08	 sub	 esp, 8
  001c3	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  001c8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?UpdateData@CPacket@@QAEXNH_N@Z

; 200  : 		}

  001ce	8b 7d 08	 mov	 edi, DWORD PTR _point$[ebp]
  001d1	eb 36		 jmp	 SHORT $LN2@GetSignalT
$LN15@GetSignalT:

; 147  : 	if(point.x == 0)

  001d3	83 3f 00	 cmp	 DWORD PTR [edi], 0

; 203  : 			prepos1 = pos1; prepos2 = pos2;

  001d6	89 75 f8	 mov	 DWORD PTR _prepos1$1$[ebp], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 813  : 		rPosition = (POSITION) pNode->pNext;

  001d9	8b 36		 mov	 esi, DWORD PTR [esi]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartFormulate\Signal.cpp

; 203  : 			prepos1 = pos1; prepos2 = pos2;

  001db	89 5d fc	 mov	 DWORD PTR _prepos2$1$[ebp], ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\afxtempl.h

; 813  : 		rPosition = (POSITION) pNode->pNext;

  001de	8b 1b		 mov	 ebx, DWORD PTR [ebx]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartFormulate\Signal.cpp

; 147  : 	if(point.x == 0)

  001e0	75 14		 jne	 SHORT $LN65@GetSignalT

; 148  : 		pPacket->AppendData(dData);

  001e2	6a ff		 push	 -1
  001e4	83 ec 08	 sub	 esp, 8
  001e7	8b c8		 mov	 ecx, eax
  001e9	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  001ee	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?AppendData@CPacket@@QAEXNH@Z
  001f4	eb 13		 jmp	 SHORT $LN2@GetSignalT
$LN65@GetSignalT:

; 149  : 	else
; 150  : 		pPacket->UpdateData(dData, nUpdateIndex, false);

  001f6	6a 00		 push	 0
  001f8	51		 push	 ecx
  001f9	83 ec 08	 sub	 esp, 8
  001fc	8b c8		 mov	 ecx, eax
  001fe	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00203	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?UpdateData@CPacket@@QAEXNH_N@Z
$LN2@GetSignalT:

; 189  : 			return ;
; 190  : 
; 191  : 	}
; 192  : 	for(int i = point.x; i < nCnt; i++){

  00209	8b 4d f4	 mov	 ecx, DWORD PTR _i$1$[ebp]
  0020c	8b 55 f8	 mov	 edx, DWORD PTR _prepos1$1$[ebp]
  0020f	41		 inc	 ecx
  00210	8b 45 14	 mov	 eax, DWORD PTR _pSignalPacket$[ebp]
  00213	89 4d f4	 mov	 DWORD PTR _i$1$[ebp], ecx
  00216	3b 4d f0	 cmp	 ecx, DWORD PTR _nCnt$1$[ebp]
  00219	0f 8c 81 fe ff
	ff		 jl	 $LL4@GetSignalT
$LN80@GetSignalT:
  0021f	5e		 pop	 esi
  00220	5f		 pop	 edi
  00221	5b		 pop	 ebx
$LN14@GetSignalT:

; 204  : 			pGraphData1->GetNext(pos1);
; 205  : 			pGraphData2->GetNext(pos2);
; 206  : 			SetData(point, i, 0.0, pSignalPacket);
; 207  : 		}
; 208  : 	}
; 209  : 
; 210  : }

  00222	8b e5		 mov	 esp, ebp
  00224	5d		 pop	 ebp
  00225	c2 10 00	 ret	 16			; 00000010H
?GetSignalTypesbyUsingGraphDatas@CSignal@@QAEXABVCPoint@@PAV?$CList@NN@@1PAVCPacket@@@Z ENDP ; CSignal::GetSignalTypesbyUsingGraphDatas
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartFormulate\Signal.cpp
;	COMDAT ?GetSignalDatas@CSignal@@QAEXABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAVCPacketList@@AAPAV?$CList@NN@@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_strPacketName$ = 8					; size = 4
_strFuncName$ = 8					; size = 4
_pPacketList$ = 12					; size = 4
_pSignalData$ = 16					; size = 4
?GetSignalDatas@CSignal@@QAEXABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAVCPacketList@@AAPAV?$CList@NN@@@Z PROC ; CSignal::GetSignalDatas, COMDAT
; _this$ = ecx

; 50   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?GetSignalDatas@CSignal@@QAEXABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAVCPacketList@@AAPAV?$CList@NN@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 51   : 	CString strPacketName = strFuncName + SIGNAL_PACKET;

  00023	68 00 00 00 00	 push	 OFFSET ?SIGNAL_PACKET@@3V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@B
  00028	ff 75 08	 push	 DWORD PTR _strFuncName$[ebp]
  0002b	8d 45 08	 lea	 eax, DWORD PTR _strPacketName$[ebp]
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 ??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@ABV10@0@Z ; ATL::operator+
  00034	83 c4 0c	 add	 esp, 12			; 0000000cH

; 52   : 	CPacket* pPacket = pPacketList->GetBaseData(strPacketName);

  00037	6a 01		 push	 1
  00039	51		 push	 ecx
  0003a	8d 45 08	 lea	 eax, DWORD PTR _strPacketName$[ebp]
  0003d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00044	8b cc		 mov	 ecx, esp
  00046	50		 push	 eax
  00047	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z
  0004d	8b 4d 0c	 mov	 ecx, DWORD PTR _pPacketList$[ebp]
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetBaseData@CPacketList@@QAEPAVCPacket@@V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@_N@Z

; 53   : 	if(pPacket == NULL)

  00056	85 c0		 test	 eax, eax
  00058	74 0d		 je	 SHORT $LN6@GetSignalD

; 54   : 		return ;
; 55   : 
; 56   : 	pSignalData = pPacket->GetnumericDataList();

  0005a	8b c8		 mov	 ecx, eax
  0005c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetnumericDataList@CPacket@@QAEPAV?$CList@NN@@XZ
  00062	8b 4d 10	 mov	 ecx, DWORD PTR _pSignalData$[ebp]
  00065	89 01		 mov	 DWORD PTR [ecx], eax
$LN6@GetSignalD:

; 57   : }

  00067	8d 4d 08	 lea	 ecx, DWORD PTR _strPacketName$[ebp]
  0006a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00070	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00073	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007a	59		 pop	 ecx
  0007b	8b e5		 mov	 esp, ebp
  0007d	5d		 pop	 ebp
  0007e	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetSignalDatas@CSignal@@QAEXABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAVCPacketList@@AAPAV?$CList@NN@@@Z$0:
  00000	8d 4d 08	 lea	 ecx, DWORD PTR _strPacketName$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
  0000d	cc		 int	 3
__ehhandler$?GetSignalDatas@CSignal@@QAEXABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAVCPacketList@@AAPAV?$CList@NN@@@Z:
  0000e	90		 npad	 1
  0000f	90		 npad	 1
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?GetSignalDatas@CSignal@@QAEXABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAVCPacketList@@AAPAV?$CList@NN@@@Z
  00026	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?GetSignalDatas@CSignal@@QAEXABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAVCPacketList@@AAPAV?$CList@NN@@@Z ENDP ; CSignal::GetSignalDatas
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartFormulate\Signal.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartFormulate\Signal.cpp
;	COMDAT ?GetSignalDataPacket@CSignal@@QBE_NABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAVCPacketList@@AAPAVCPacket@@@Z
_TEXT	SEGMENT
_strGraphName$ = 8					; size = 4
_pPacketList$ = 12					; size = 4
_pSignalPacket$ = 16					; size = 4
?GetSignalDataPacket@CSignal@@QBE_NABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAVCPacketList@@AAPAVCPacket@@@Z PROC ; CSignal::GetSignalDataPacket, COMDAT
; _this$ = ecx

; 38   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 40   : 	if(pPacketList == NULL || strGraphName.IsEmpty())

  00003	83 7d 0c 00	 cmp	 DWORD PTR _pPacketList$[ebp], 0
  00007	56		 push	 esi
  00008	8b 75 10	 mov	 esi, DWORD PTR _pSignalPacket$[ebp]
  0000b	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00011	74 34		 je	 SHORT $LN3@GetSignalD
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h

; 519  : 		return( GetData()->nDataLength );

  00013	8b 4d 08	 mov	 ecx, DWORD PTR _strGraphName$[ebp]
  00016	8b 01		 mov	 eax, DWORD PTR [ecx]

; 533  : 		return( GetLength() == 0 );

  00018	83 78 f4 00	 cmp	 DWORD PTR [eax-12], 0
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartFormulate\Signal.cpp

; 40   : 	if(pPacketList == NULL || strGraphName.IsEmpty())

  0001c	74 29		 je	 SHORT $LN3@GetSignalD

; 42   : 
; 43   : 	pSignalPacket = pPacketList->GetBaseData(strGraphName + SIGNAL_PACKET);

  0001e	6a 01		 push	 1
  00020	51		 push	 ecx
  00021	8b c4		 mov	 eax, esp
  00023	68 00 00 00 00	 push	 OFFSET ?SIGNAL_PACKET@@3V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@B
  00028	51		 push	 ecx
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 ??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@ABV10@0@Z ; ATL::operator+
  0002f	8b 4d 0c	 mov	 ecx, DWORD PTR _pPacketList$[ebp]
  00032	83 c4 0c	 add	 esp, 12			; 0000000cH
  00035	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetBaseData@CPacketList@@QAEPAVCPacket@@V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@_N@Z

; 44   : 	return (pSignalPacket != NULL);

  0003b	85 c0		 test	 eax, eax
  0003d	89 06		 mov	 DWORD PTR [esi], eax
  0003f	0f 95 c0	 setne	 al

; 45   : }

  00042	5e		 pop	 esi
  00043	5d		 pop	 ebp
  00044	c2 0c 00	 ret	 12			; 0000000cH
$LN3@GetSignalD:

; 41   : 		return false;

  00047	32 c0		 xor	 al, al

; 45   : }

  00049	5e		 pop	 esi
  0004a	5d		 pop	 ebp
  0004b	c2 0c 00	 ret	 12			; 0000000cH
?GetSignalDataPacket@CSignal@@QBE_NABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAVCPacketList@@AAPAVCPacket@@@Z ENDP ; CSignal::GetSignalDataPacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartFormulate\Signal.cpp
;	COMDAT ??1CSignal@@UAE@XZ
_TEXT	SEGMENT
??1CSignal@@UAE@XZ PROC					; CSignal::~CSignal, COMDAT
; _this$ = ecx

; 31   : {

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CSignal@@6B@

; 32   : 
; 33   : }

  00006	c3		 ret	 0
??1CSignal@@UAE@XZ ENDP					; CSignal::~CSignal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartFormulate\Signal.cpp
;	COMDAT ??0CSignal@@QAE@XZ
_TEXT	SEGMENT
??0CSignal@@QAE@XZ PROC					; CSignal::CSignal, COMDAT
; _this$ = ecx

; 26   : {

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CSignal@@6B@

; 27   : 
; 28   : }

  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0CSignal@@QAE@XZ ENDP					; CSignal::CSignal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h
;	COMDAT ??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@ABV10@0@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_str1$ = 12						; size = 4
_str2$ = 16						; size = 4
??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@ABV10@0@Z PROC ; ATL::operator+, COMDAT

; 2389 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@ABV10@0@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 2390 : 		CStringT strResult( str1.GetManager() );

  00025	8b 75 0c	 mov	 esi, DWORD PTR _str1$[ebp]
  00028	8b ce		 mov	 ecx, esi
  0002a	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0
  00031	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetManager@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEPAUIAtlStringMgr@2@XZ
  00037	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  0003a	8b cf		 mov	 ecx, edi
  0003c	50		 push	 eax
  0003d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PAUIAtlStringMgr@1@@Z
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h

; 519  : 		return( GetData()->nDataLength );

  00043	8b 45 10	 mov	 eax, DWORD PTR _str2$[ebp]
  00046	8b 16		 mov	 edx, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h

; 2394 : 		return( strResult );

  00048	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0004f	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR $T2[ebp], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h

; 519  : 		return( GetData()->nDataLength );

  00056	8b 08		 mov	 ecx, DWORD PTR [eax]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\cstringt.h

; 2392 : 		CThisSimpleString::Concatenate( strResult, str1, str1.GetLength(), str2, str2.GetLength() );

  00058	ff 71 f4	 push	 DWORD PTR [ecx-12]
  0005b	51		 push	 ecx
  0005c	ff 72 f4	 push	 DWORD PTR [edx-12]
  0005f	52		 push	 edx
  00060	57		 push	 edi
  00061	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Concatenate@?$CSimpleStringT@D$00@ATL@@KAXAAV12@PBDH1H@Z
  00067	83 c4 14	 add	 esp, 20			; 00000014H

; 2394 : 		return( strResult );

  0006a	8b c7		 mov	 eax, edi

; 2395 : 	}

  0006c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00076	59		 pop	 ecx
  00077	5f		 pop	 edi
  00078	5e		 pop	 esi
  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@ABV10@0@Z$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0d 00 00
	00		 je	 $LN4@operator
  0000c	83 65 f0 fe	 and	 DWORD PTR $T2[ebp], -2	; fffffffeH
  00010	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00013	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$LN4@operator:
  00019	c3		 ret	 0
  0001a	cc		 int	 3
  0001b	cc		 int	 3
  0001c	cc		 int	 3
  0001d	cc		 int	 3
  0001e	cc		 int	 3
__ehhandler$??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@ABV10@0@Z:
  0001f	90		 npad	 1
  00020	90		 npad	 1
  00021	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00025	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00028	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0002b	33 c8		 xor	 ecx, eax
  0002d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00032	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@ABV10@0@Z
  00037	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@ABV10@0@Z ENDP ; ATL::operator+
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartFormulate\Signal.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	c2 00 00	 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcChartEx\ChartOCX\ChartFormulate\Signal.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

  00000	c2 00 00	 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
