; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30148.0 

	TITLE	D:\git\src\IBK\IBK_DRFN\#DRfn-CS\_Obj\PcTrMng\_SystemUtilManager.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0P@BKKCOCLK@RMSG_INTERFACE@		; `string'
PUBLIC	??_C@_0BB@GOOPDKI@RMSG_GETPCTRDATA@		; `string'
PUBLIC	??_C@_0BB@JPACFCL@RMSG_SETPCTRDATA@		; `string'
PUBLIC	??_C@_0BB@EPGJDGDK@RMSG_CONCERNHWND@		; `string'
PUBLIC	??_C@_0BA@JHANHJCN@RMSG_INTREQUEST@		; `string'
PUBLIC	??_C@_0BF@MNPNIDPI@RMSG_GWANSIMREGISTER@	; `string'
;	COMDAT ??_C@_0BF@MNPNIDPI@RMSG_GWANSIMREGISTER@
CONST	SEGMENT
??_C@_0BF@MNPNIDPI@RMSG_GWANSIMREGISTER@ DB 'RMSG_GWANSIMREGISTER', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JHANHJCN@RMSG_INTREQUEST@
CONST	SEGMENT
??_C@_0BA@JHANHJCN@RMSG_INTREQUEST@ DB 'RMSG_INTREQUEST', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@EPGJDGDK@RMSG_CONCERNHWND@
CONST	SEGMENT
??_C@_0BB@EPGJDGDK@RMSG_CONCERNHWND@ DB 'RMSG_CONCERNHWND', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@JPACFCL@RMSG_SETPCTRDATA@
CONST	SEGMENT
??_C@_0BB@JPACFCL@RMSG_SETPCTRDATA@ DB 'RMSG_SETPCTRDATA', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GOOPDKI@RMSG_GETPCTRDATA@
CONST	SEGMENT
??_C@_0BB@GOOPDKI@RMSG_GETPCTRDATA@ DB 'RMSG_GETPCTRDATA', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@BKKCOCLK@RMSG_INTERFACE@
CONST	SEGMENT
??_C@_0P@BKKCOCLK@RMSG_INTERFACE@ DB 'RMSG_INTERFACE', 00H ; `string'
CONST	ENDS
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	?CheckExeRun@CSystemUtilManager@@AAEHABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z ; CSystemUtilManager::CheckExeRun
PUBLIC	?IsRegistered@CSystemUtilManager@@UAGHPBDAAU_GUID@@@Z ; CSystemUtilManager::IsRegistered
PUBLIC	?DLLRegister@CSystemUtilManager@@UAGHPBD@Z	; CSystemUtilManager::DLLRegister
PUBLIC	?IsRegisteredEx@CSystemUtilManager@@UAGHPBDAAU_GUID@@00@Z ; CSystemUtilManager::IsRegisteredEx
PUBLIC	?StringCLSIDFromProgID@CProgIDInfo@@SAJPBDAAV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ; CProgIDInfo::StringCLSIDFromProgID
PUBLIC	?ComServerFromProgID@CProgIDInfo@@SAJPBDAAV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ; CProgIDInfo::ComServerFromProgID
PUBLIC	??_C@_06JHNIBAJK@CLSID?2@			; `string'
PUBLIC	??_C@_0BA@CCGIMEPP@?2InprocServer32@		; `string'
PUBLIC	??_C@_0P@IKCDKIKH@?2LocalServer32@		; `string'
PUBLIC	??_C@_0BH@OANCKEIH@?2System32?2regsvr32?4exe@	; `string'
PUBLIC	??_C@_08LMJFGFMJ@?5?1s?5?$CC?$CFs?$CC@		; `string'
EXTRN	_strrchr:PROC
EXTRN	__imp__SetCurrentDirectoryA@4:PROC
EXTRN	__imp__GetCurrentDirectoryA@8:PROC
EXTRN	__imp__GetLongPathNameA@12:PROC
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__imp__GetLastError@0:PROC
EXTRN	__imp__WaitForSingleObject@8:PROC
EXTRN	__imp__GetExitCodeProcess@8:PROC
EXTRN	__imp__CreateProcessA@40:PROC
EXTRN	__imp__GetWindowsDirectoryA@8:PROC
EXTRN	__imp__LocalFree@4:PROC
EXTRN	__imp__FormatMessageA@28:PROC
EXTRN	__imp__RegisterWindowMessageA@4:PROC
EXTRN	__imp__MultiByteToWideChar@24:PROC
EXTRN	__imp__WideCharToMultiByte@32:PROC
EXTRN	__imp__RegCloseKey@4:PROC
EXTRN	__imp__RegOpenKeyExA@20:PROC
EXTRN	__imp__RegQueryValueExA@24:PROC
EXTRN	__imp__StringFromCLSID@8:PROC
EXTRN	__imp__CLSIDFromProgID@8:PROC
EXTRN	__imp__CoTaskMemFree@4:PROC
EXTRN	__imp_?GetBuffer@?$CSimpleStringT@D$00@ATL@@QAEPADH@Z:PROC
EXTRN	__imp_?GetBufferSetLength@?$CSimpleStringT@D$00@ATL@@QAEPADH@Z:PROC
EXTRN	__imp_?ReleaseBuffer@?$CSimpleStringT@D$00@ATL@@QAEXH@Z:PROC
EXTRN	__imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ:PROC
EXTRN	__imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z:PROC
EXTRN	__imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ:PROC
EXTRN	__imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z:PROC
EXTRN	__imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z:PROC
EXTRN	__imp_??Y?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z:PROC
EXTRN	__imp_?CompareNoCase@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEHPBD@Z:PROC
EXTRN	__imp_?ReverseFind@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEHD@Z:PROC
EXTRN	__imp_?Left@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBE?AV12@H@Z:PROC
EXTRN	__imp_?Format@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAAXPBDZZ:PROC
EXTRN	??0CFileFind@@QAE@XZ:PROC			; CFileFind::CFileFind
EXTRN	??1CFileFind@@UAE@XZ:PROC			; CFileFind::~CFileFind
EXTRN	?FindFile@CFileFind@@UAEHPBDK@Z:PROC		; CFileFind::FindFile
EXTRN	?AfxGetClassIDFromString@@YGJPBDPAU_GUID@@@Z:PROC ; AfxGetClassIDFromString
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__alloca_probe_16:PROC
EXTRN	_memset:PROC
EXTRN	___security_cookie:DWORD
_BSS	SEGMENT
?RMSG_INTERFACE@@3IB DD 01H DUP (?)			; RMSG_INTERFACE
?RMSG_GETPCTRDATA@@3IB DD 01H DUP (?)			; RMSG_GETPCTRDATA
?RMSG_SETPCTRDATA@@3IB DD 01H DUP (?)			; RMSG_SETPCTRDATA
?RMSG_CONCERNHWND@@3IB DD 01H DUP (?)			; RMSG_CONCERNHWND
?RMSG_INTREQUEST@@3IB DD 01H DUP (?)			; RMSG_INTREQUEST
?RMSG_GWANSIMREGISTER@@3IB DD 01H DUP (?)		; RMSG_GWANSIMREGISTER
_BSS	ENDS
CRT$XCU	SEGMENT
?RMSG_INTERFACE$initializer$@@3P6AXXZA DD FLAT:??__ERMSG_INTERFACE@@YAXXZ ; RMSG_INTERFACE$initializer$
CRT$XCU	ENDS
;	COMDAT ??_C@_08LMJFGFMJ@?5?1s?5?$CC?$CFs?$CC@
CONST	SEGMENT
??_C@_08LMJFGFMJ@?5?1s?5?$CC?$CFs?$CC@ DB ' /s "%s"', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@OANCKEIH@?2System32?2regsvr32?4exe@
CONST	SEGMENT
??_C@_0BH@OANCKEIH@?2System32?2regsvr32?4exe@ DB '\System32\regsvr32.exe', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@IKCDKIKH@?2LocalServer32@
CONST	SEGMENT
??_C@_0P@IKCDKIKH@?2LocalServer32@ DB '\LocalServer32', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@CCGIMEPP@?2InprocServer32@
CONST	SEGMENT
??_C@_0BA@CCGIMEPP@?2InprocServer32@ DB '\InprocServer32', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06JHNIBAJK@CLSID?2@
CONST	SEGMENT
??_C@_06JHNIBAJK@CLSID?2@ DB 'CLSID\', 00H		; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?ComServerFromProgID@CProgIDInfo@@SAJPBDAAV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ComServerFromProgID@CProgIDInfo@@SAJPBDAAV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ComServerFromProgID@CProgIDInfo@@SAJPBDAAV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?ComServerFromProgID@CProgIDInfo@@SAJPBDAAV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z$2
__ehfuncinfo$?ComServerFromProgID@CProgIDInfo@@SAJPBDAAV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?ComServerFromProgID@CProgIDInfo@@SAJPBDAAV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?ComServerFromStringCLSID@CProgIDInfo@@SAJPBDAAV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ComServerFromStringCLSID@CProgIDInfo@@SAJPBDAAV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ComServerFromStringCLSID@CProgIDInfo@@SAJPBDAAV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z$1
__ehfuncinfo$?ComServerFromStringCLSID@CProgIDInfo@@SAJPBDAAV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?ComServerFromStringCLSID@CProgIDInfo@@SAJPBDAAV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
CRT$XCU	SEGMENT
?RMSG_GETPCTRDATA$initializer$@@3P6AXXZA DD FLAT:??__ERMSG_GETPCTRDATA@@YAXXZ ; RMSG_GETPCTRDATA$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?RMSG_SETPCTRDATA$initializer$@@3P6AXXZA DD FLAT:??__ERMSG_SETPCTRDATA@@YAXXZ ; RMSG_SETPCTRDATA$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?RMSG_CONCERNHWND$initializer$@@3P6AXXZA DD FLAT:??__ERMSG_CONCERNHWND@@YAXXZ ; RMSG_CONCERNHWND$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?RMSG_INTREQUEST$initializer$@@3P6AXXZA DD FLAT:??__ERMSG_INTREQUEST@@YAXXZ ; RMSG_INTREQUEST$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?RMSG_GWANSIMREGISTER$initializer$@@3P6AXXZA DD FLAT:??__ERMSG_GWANSIMREGISTER@@YAXXZ ; RMSG_GWANSIMREGISTER$initializer$
CRT$XCU	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\inc\ProgIDInfo.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\inc\ProgIDInfo.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\string.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\inc\ProgIDInfo.h
;	COMDAT ?ComServerFromProgID@CProgIDInfo@@SAJPBDAAV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
_TEXT	SEGMENT
_dwDataType$2 = -36					; size = 4
_dwReceivedSize$3 = -32					; size = 4
_strClsID$ = -28					; size = 4
_hKey$4 = -24						; size = 4
_strShortServerPath$5 = -20				; size = 4
_strSubKey$6 = -16					; size = 4
__$EHRec$ = -12						; size = 12
_p_szProgID$ = 8					; size = 4
_p_strComServer$ = 12					; size = 4
?ComServerFromProgID@CProgIDInfo@@SAJPBDAAV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z PROC ; CProgIDInfo::ComServerFromProgID, COMDAT

; 188  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?ComServerFromProgID@CProgIDInfo@@SAJPBDAAV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 18	 sub	 esp, 24			; 00000018H
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	50		 push	 eax
  0001e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 189  : 		// 1. 먼저 String CLSID를 구한다.
; 190  : 		CString strClsID;

  00027	8d 4d e4	 lea	 ecx, DWORD PTR _strClsID$[ebp]
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 191  : 		long lResult = StringCLSIDFromProgID( p_szProgID, strClsID);

  00030	8d 45 e4	 lea	 eax, DWORD PTR _strClsID$[ebp]
  00033	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003a	50		 push	 eax
  0003b	ff 75 08	 push	 DWORD PTR _p_szProgID$[ebp]
  0003e	e8 00 00 00 00	 call	 ?StringCLSIDFromProgID@CProgIDInfo@@SAJPBDAAV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ; CProgIDInfo::StringCLSIDFromProgID
  00043	83 c4 08	 add	 esp, 8

; 192  : 		if( lResult < 0) return lResult * 10 - 1;

  00046	85 c0		 test	 eax, eax
  00048	79 0f		 jns	 SHORT $LN2@ComServerF
  0004a	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  0004d	8d 34 45 ff ff
	ff ff		 lea	 esi, DWORD PTR [eax*2-1]
  00054	e9 8f 01 00 00	 jmp	 $LN7@ComServerF
$LN2@ComServerF:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h

; 377  : 		return( m_pszData );

  00059	8b 75 e4	 mov	 esi, DWORD PTR _strClsID$[ebp]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\inc\ProgIDInfo.h

; 141  : 		CString strSubKey;

  0005c	8d 4d f0	 lea	 ecx, DWORD PTR _strSubKey$6[ebp]
  0005f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 142  : 		char *szSubKey = strSubKey.GetBufferSetLength( 6 + 38 + 15);

  00065	6a 3b		 push	 59			; 0000003bH
  00067	8d 4d f0	 lea	 ecx, DWORD PTR _strSubKey$6[ebp]
  0006a	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0006e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetBufferSetLength@?$CSimpleStringT@D$00@ATL@@QAEPADH@Z

; 143  : 		strcpy( szSubKey, "CLSID\\");

  00074	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ??_C@_06JHNIBAJK@CLSID?2@
  0007a	8b f8		 mov	 edi, eax
  0007c	89 0f		 mov	 DWORD PTR [edi], ecx
  0007e	66 8b 0d 04 00
	00 00		 mov	 cx, WORD PTR ??_C@_06JHNIBAJK@CLSID?2@+4
  00085	66 89 4f 04	 mov	 WORD PTR [edi+4], cx
  00089	8a 0d 06 00 00
	00		 mov	 cl, BYTE PTR ??_C@_06JHNIBAJK@CLSID?2@+6
  0008f	88 4f 06	 mov	 BYTE PTR [edi+6], cl

; 144  : 		strcpy( szSubKey + 6, p_szClsID);

  00092	8b cf		 mov	 ecx, edi
  00094	2b ce		 sub	 ecx, esi
$LL17@ComServerF:
  00096	8a 06		 mov	 al, BYTE PTR [esi]
  00098	8d 76 01	 lea	 esi, DWORD PTR [esi+1]
  0009b	88 44 31 05	 mov	 BYTE PTR [ecx+esi+5], al
  0009f	84 c0		 test	 al, al
  000a1	75 f3		 jne	 SHORT $LL17@ComServerF

; 145  : 		strcpy( szSubKey + 6 + 38, "\\InprocServer32");

  000a3	0f 10 05 00 00
	00 00		 movups	 xmm0, XMMWORD PTR ??_C@_0BA@CCGIMEPP@?2InprocServer32@

; 146  : 		// 1. Key를 Open한다.
; 147  : 		HKEY hKey;
; 148  : 		if( RegOpenKeyEx( HKEY_CLASSES_ROOT, szSubKey, 0, KEY_QUERY_VALUE, &hKey) != ERROR_SUCCESS)

  000aa	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__RegOpenKeyExA@20
  000b0	8d 45 e8	 lea	 eax, DWORD PTR _hKey$4[ebp]
  000b3	50		 push	 eax
  000b4	6a 01		 push	 1
  000b6	6a 00		 push	 0
  000b8	57		 push	 edi
  000b9	68 00 00 00 80	 push	 -2147483648		; 80000000H
  000be	0f 11 47 2c	 movups	 XMMWORD PTR [edi+44], xmm0
  000c2	ff d6		 call	 esi
  000c4	85 c0		 test	 eax, eax
  000c6	74 4e		 je	 SHORT $LN12@ComServerF

; 149  : 		{
; 150  : 			// 1.1 InprocServer32가 아니라면 LocalServer32로 확인한다.
; 151  : 			strcpy( szSubKey + 6 + 38, "\\LocalServer32");

  000c8	f3 0f 7e 05 00
	00 00 00	 movq	 xmm0, QWORD PTR ??_C@_0P@IKCDKIKH@?2LocalServer32@
  000d0	66 0f d6 47 2c	 movq	 QWORD PTR [edi+44], xmm0
  000d5	a1 08 00 00 00	 mov	 eax, DWORD PTR ??_C@_0P@IKCDKIKH@?2LocalServer32@+8
  000da	89 47 34	 mov	 DWORD PTR [edi+52], eax
  000dd	66 a1 0c 00 00
	00		 mov	 ax, WORD PTR ??_C@_0P@IKCDKIKH@?2LocalServer32@+12
  000e3	66 89 47 38	 mov	 WORD PTR [edi+56], ax
  000e7	a0 0e 00 00 00	 mov	 al, BYTE PTR ??_C@_0P@IKCDKIKH@?2LocalServer32@+14
  000ec	88 47 3a	 mov	 BYTE PTR [edi+58], al

; 152  : 			if( RegOpenKeyEx( HKEY_CLASSES_ROOT, szSubKey, 0, KEY_QUERY_VALUE, &hKey) != ERROR_SUCCESS)

  000ef	8d 45 e8	 lea	 eax, DWORD PTR _hKey$4[ebp]
  000f2	50		 push	 eax
  000f3	6a 01		 push	 1
  000f5	6a 00		 push	 0
  000f7	57		 push	 edi
  000f8	68 00 00 00 80	 push	 -2147483648		; 80000000H
  000fd	ff d6		 call	 esi
  000ff	85 c0		 test	 eax, eax
  00101	74 13		 je	 SHORT $LN12@ComServerF

; 153  : 				return -1;

  00103	8d 4d f0	 lea	 ecx, DWORD PTR _strSubKey$6[ebp]
  00106	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0010c	be f4 ff ff ff	 mov	 esi, -12		; fffffff4H
  00111	e9 d2 00 00 00	 jmp	 $LN7@ComServerF
$LN12@ComServerF:

; 154  : 		}
; 155  : 		// 2. ComServer의 경로를 정보를 구한다.(Default Value이다.)
; 156  : 		DWORD dwDataType, dwReceivedSize = _MAX_PATH;
; 157  : 		CString strShortServerPath;

  00116	8d 4d ec	 lea	 ecx, DWORD PTR _strShortServerPath$5[ebp]
  00119	c7 45 e0 04 01
	00 00		 mov	 DWORD PTR _dwReceivedSize$3[ebp], 260 ; 00000104H
  00120	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 158  : 		char *szShortServerPath = strShortServerPath.GetBufferSetLength( dwReceivedSize);

  00126	ff 75 e0	 push	 DWORD PTR _dwReceivedSize$3[ebp]
  00129	8d 4d ec	 lea	 ecx, DWORD PTR _strShortServerPath$5[ebp]
  0012c	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00130	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetBufferSetLength@?$CSimpleStringT@D$00@ATL@@QAEPADH@Z
  00136	8b f0		 mov	 esi, eax

; 159  : 		RegQueryValueEx( hKey, NULL, 0, &dwDataType, ( unsigned char *)szShortServerPath, &dwReceivedSize);

  00138	8d 45 e0	 lea	 eax, DWORD PTR _dwReceivedSize$3[ebp]
  0013b	50		 push	 eax
  0013c	56		 push	 esi
  0013d	8d 45 dc	 lea	 eax, DWORD PTR _dwDataType$2[ebp]
  00140	50		 push	 eax
  00141	6a 00		 push	 0
  00143	6a 00		 push	 0
  00145	ff 75 e8	 push	 DWORD PTR _hKey$4[ebp]
  00148	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegQueryValueExA@24

; 160  : 		// 3. Key를 닫는다.
; 161  : 		RegCloseKey( hKey);

  0014e	ff 75 e8	 push	 DWORD PTR _hKey$4[ebp]
  00151	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4

; 162  : 		// 4. 구해진 Com Server Path를 확인한다.
; 163  : 		if( !*szShortServerPath) return -2;

  00157	80 3e 00	 cmp	 BYTE PTR [esi], 0
  0015a	75 19		 jne	 SHORT $LN13@ComServerF
  0015c	8d 4d ec	 lea	 ecx, DWORD PTR _strShortServerPath$5[ebp]
  0015f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00165	8d 4d f0	 lea	 ecx, DWORD PTR _strSubKey$6[ebp]
  00168	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0016e	be ea ff ff ff	 mov	 esi, -22		; ffffffeaH
  00173	eb 73		 jmp	 SHORT $LN7@ComServerF
$LN13@ComServerF:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\string.h

; 514  :         return const_cast<char*>(strrchr(static_cast<char const*>(_String), _Ch));

  00175	6a 2e		 push	 46			; 0000002eH
  00177	56		 push	 esi
  00178	e8 00 00 00 00	 call	 _strrchr
  0017d	83 c4 08	 add	 esp, 8
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\inc\ProgIDInfo.h

; 166  : 		if( !szExtension) return -3;

  00180	85 c0		 test	 eax, eax
  00182	75 19		 jne	 SHORT $LN14@ComServerF
  00184	8d 4d ec	 lea	 ecx, DWORD PTR _strShortServerPath$5[ebp]
  00187	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0018d	8d 4d f0	 lea	 ecx, DWORD PTR _strSubKey$6[ebp]
  00190	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00196	be e0 ff ff ff	 mov	 esi, -32		; ffffffe0H
  0019b	eb 4b		 jmp	 SHORT $LN7@ComServerF
$LN14@ComServerF:

; 167  : 		szExtension[ 4] = '\0';
; 168  : 		// 6. Long File Path를 구한다.
; 169  : 		char *szLongServerPath = p_strComServer.GetBuffer( _MAX_PATH);

  0019d	8b 4d 0c	 mov	 ecx, DWORD PTR _p_strComServer$[ebp]
  001a0	68 04 01 00 00	 push	 260			; 00000104H
  001a5	c6 40 04 00	 mov	 BYTE PTR [eax+4], 0
  001a9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetBuffer@?$CSimpleStringT@D$00@ATL@@QAEPADH@Z

; 170  : 		DWORD dwLongPath = GetLongPathName( szShortServerPath, szLongServerPath, _MAX_PATH);

  001af	68 04 01 00 00	 push	 260			; 00000104H
  001b4	50		 push	 eax
  001b5	56		 push	 esi
  001b6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLongPathNameA@12

; 171  : 		p_strComServer.ReleaseBuffer();

  001bc	8b 4d 0c	 mov	 ecx, DWORD PTR _p_strComServer$[ebp]
  001bf	8b f0		 mov	 esi, eax
  001c1	6a ff		 push	 -1
  001c3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?ReleaseBuffer@?$CSimpleStringT@D$00@ATL@@QAEXH@Z

; 172  : 		if( !dwLongPath) return -4;

  001c9	8d 4d ec	 lea	 ecx, DWORD PTR _strShortServerPath$5[ebp]
  001cc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  001d2	8d 4d f0	 lea	 ecx, DWORD PTR _strSubKey$6[ebp]
  001d5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  001db	85 f6		 test	 esi, esi
  001dd	75 07		 jne	 SHORT $LN15@ComServerF
  001df	be d6 ff ff ff	 mov	 esi, -42		; ffffffd6H
  001e4	eb 02		 jmp	 SHORT $LN7@ComServerF
$LN15@ComServerF:

; 193  : 		// 2. String CLSID로 Com Server를 구한다.
; 194  : 		lResult = ComServerFromStringCLSID( strClsID, p_strComServer);
; 195  : 		if( lResult < 0) return lResult * 10 - 2;
; 196  : 		return 0;

  001e6	33 f6		 xor	 esi, esi
$LN7@ComServerF:
  001e8	8d 4d e4	 lea	 ecx, DWORD PTR _strClsID$[ebp]
  001eb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  001f1	8b c6		 mov	 eax, esi

; 197  : 	}

  001f3	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001f6	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001fd	59		 pop	 ecx
  001fe	5f		 pop	 edi
  001ff	5e		 pop	 esi
  00200	8b e5		 mov	 esp, ebp
  00202	5d		 pop	 ebp
  00203	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ComServerFromProgID@CProgIDInfo@@SAJPBDAAV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z$0:
  00000	8d 4d e4	 lea	 ecx, DWORD PTR _strClsID$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?ComServerFromProgID@CProgIDInfo@@SAJPBDAAV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z$1:
  00009	8d 4d f0	 lea	 ecx, DWORD PTR _strSubKey$6[ebp]
  0000c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?ComServerFromProgID@CProgIDInfo@@SAJPBDAAV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z$2:
  00012	8d 4d ec	 lea	 ecx, DWORD PTR _strShortServerPath$5[ebp]
  00015	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0001b	cc		 int	 3
  0001c	cc		 int	 3
  0001d	cc		 int	 3
  0001e	cc		 int	 3
  0001f	cc		 int	 3
__ehhandler$?ComServerFromProgID@CProgIDInfo@@SAJPBDAAV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z:
  00020	90		 npad	 1
  00021	90		 npad	 1
  00022	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00026	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00029	8b 4a dc	 mov	 ecx, DWORD PTR [edx-36]
  0002c	33 c8		 xor	 ecx, eax
  0002e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00033	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?ComServerFromProgID@CProgIDInfo@@SAJPBDAAV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
  00038	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?ComServerFromProgID@CProgIDInfo@@SAJPBDAAV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ENDP ; CProgIDInfo::ComServerFromProgID
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\inc\ProgIDInfo.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlconv.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\inc\ProgIDInfo.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlconv.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\inc\ProgIDInfo.h
;	COMDAT ?StringCLSIDFromProgID@CProgIDInfo@@SAJPBDAAV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
_TEXT	SEGMENT
_p_strClsID$GSCopy$1$ = -44				; size = 4
_oleClsID$1 = -40					; size = 4
_p_clsID$ = -36						; size = 16
_clsID$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_p_szProgID$ = 8					; size = 4
_p_strClsID$ = 12					; size = 4
?StringCLSIDFromProgID@CProgIDInfo@@SAJPBDAAV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z PROC ; CProgIDInfo::StringCLSIDFromProgID, COMDAT

; 100  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 0c	 mov	 eax, DWORD PTR _p_strClsID$[ebp]
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	8b 75 08	 mov	 esi, DWORD PTR _p_szProgID$[ebp]
  00018	89 45 d4	 mov	 DWORD PTR _p_strClsID$GSCopy$1$[ebp], eax
  0001b	57		 push	 edi

; 38   : 		LPCOLESTR szOleProgID = T2COLE( p_szProgID);

  0001c	85 f6		 test	 esi, esi
  0001e	74 42		 je	 SHORT $LN18@StringCLSI
  00020	8b ce		 mov	 ecx, esi
  00022	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL35@StringCLSI:
  00025	8a 01		 mov	 al, BYTE PTR [ecx]
  00027	41		 inc	 ecx
  00028	84 c0		 test	 al, al
  0002a	75 f9		 jne	 SHORT $LL35@StringCLSI
  0002c	2b ca		 sub	 ecx, edx
  0002e	8d 59 01	 lea	 ebx, DWORD PTR [ecx+1]
  00031	81 fb ff ff ff
	3f		 cmp	 ebx, 1073741823		; 3fffffffH
  00037	7f 29		 jg	 SHORT $LN18@StringCLSI
  00039	8d 04 1b	 lea	 eax, DWORD PTR [ebx+ebx]
  0003c	e8 00 00 00 00	 call	 __alloca_probe_16
  00041	8b fc		 mov	 edi, esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlconv.h

; 566  : 	if (lpw == NULL || lpa == NULL)

  00043	85 ff		 test	 edi, edi
  00045	74 1b		 je	 SHORT $LN18@StringCLSI

; 567  : 		return NULL;
; 568  : 	// verify that no illegal character present
; 569  : 	// since lpw was allocated based on the size of lpa
; 570  : 	// don't worry about the number of chars
; 571  : 	*lpw = '\0';
; 572  : 	int ret = MultiByteToWideChar(acp, 0, lpa, -1, lpw, nChars);

  00047	53		 push	 ebx
  00048	57		 push	 edi
  00049	6a ff		 push	 -1
  0004b	33 c0		 xor	 eax, eax
  0004d	56		 push	 esi
  0004e	50		 push	 eax
  0004f	6a 03		 push	 3
  00051	66 89 07	 mov	 WORD PTR [edi], ax
  00054	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MultiByteToWideChar@24

; 573  : 	if(ret == 0)

  0005a	f7 d8		 neg	 eax
  0005c	1b c0		 sbb	 eax, eax
  0005e	23 c7		 and	 eax, edi

; 574  : 	{
; 575  : 		ATLASSERT(FALSE);
; 576  : 		return NULL;
; 577  : 	}
; 578  : 	return lpw;

  00060	eb 02		 jmp	 SHORT $LN15@StringCLSI
$LN18@StringCLSI:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\inc\ProgIDInfo.h

; 39   : 		HRESULT hResult = ::CLSIDFromProgID( szOleProgID, p_pClsID);

  00062	33 c0		 xor	 eax, eax
$LN15@StringCLSI:
  00064	8d 4d ec	 lea	 ecx, DWORD PTR _clsID$[ebp]
  00067	51		 push	 ecx
  00068	50		 push	 eax
  00069	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CLSIDFromProgID@8
  0006f	8b c8		 mov	 ecx, eax

; 40   : 		if( hResult == S_OK) return 0;

  00071	85 c9		 test	 ecx, ecx
  00073	74 48		 je	 SHORT $LN2@StringCLSI

; 41   : 		else if( hResult == CO_E_CLASSSTRING) return -1;

  00075	81 f9 f3 01 04
	80		 cmp	 ecx, -2147221005	; 800401f3H
  0007b	75 19		 jne	 SHORT $LN8@StringCLSI
  0007d	b8 f5 ff ff ff	 mov	 eax, -11		; fffffff5H

; 109  : 	}

  00082	8d 65 c8	 lea	 esp, DWORD PTR [ebp-56]
  00085	5f		 pop	 edi
  00086	5e		 pop	 esi
  00087	5b		 pop	 ebx
  00088	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0008b	33 cd		 xor	 ecx, ebp
  0008d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00092	8b e5		 mov	 esp, ebp
  00094	5d		 pop	 ebp
  00095	c3		 ret	 0
$LN8@StringCLSI:

; 42   : 		else if( hResult == REGDB_E_WRITEREGDB) return -2;

  00096	81 f9 51 01 04
	80		 cmp	 ecx, -2147221167	; 80040151H
  0009c	b8 e1 ff ff ff	 mov	 eax, -31		; ffffffe1H
  000a1	ba eb ff ff ff	 mov	 edx, -21		; ffffffebH
  000a6	0f 44 c2	 cmove	 eax, edx

; 109  : 	}

  000a9	8d 65 c8	 lea	 esp, DWORD PTR [ebp-56]
  000ac	5f		 pop	 edi
  000ad	5e		 pop	 esi
  000ae	5b		 pop	 ebx
  000af	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b2	33 cd		 xor	 ecx, ebp
  000b4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b9	8b e5		 mov	 esp, ebp
  000bb	5d		 pop	 ebp
  000bc	c3		 ret	 0
$LN2@StringCLSI:

; 101  : 		// 1. 먼저 CLSID를 구한다.
; 102  : 		CLSID clsID;
; 103  : 		LONG lResult = CLSIDFromProgID( p_szProgID, &clsID);
; 104  : 		if( lResult < 0) return lResult * 10 - 1;
; 105  : 		// 2. String CLSID를 구한다.
; 106  : 		lResult = StringFromCLSID( clsID, p_strClsID);

  000bd	0f 10 45 ec	 movups	 xmm0, XMMWORD PTR _clsID$[ebp]

; 71   : 		HRESULT hResult = ::StringFromCLSID( p_clsID, &oleClsID);

  000c1	8d 45 d8	 lea	 eax, DWORD PTR _oleClsID$1[ebp]
  000c4	50		 push	 eax
  000c5	8d 45 dc	 lea	 eax, DWORD PTR _p_clsID$[ebp]
  000c8	50		 push	 eax

; 101  : 		// 1. 먼저 CLSID를 구한다.
; 102  : 		CLSID clsID;
; 103  : 		LONG lResult = CLSIDFromProgID( p_szProgID, &clsID);
; 104  : 		if( lResult < 0) return lResult * 10 - 1;
; 105  : 		// 2. String CLSID를 구한다.
; 106  : 		lResult = StringFromCLSID( clsID, p_strClsID);

  000c9	0f 11 45 dc	 movups	 XMMWORD PTR _p_clsID$[ebp], xmm0

; 71   : 		HRESULT hResult = ::StringFromCLSID( p_clsID, &oleClsID);

  000cd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__StringFromCLSID@8

; 72   : 		if( hResult != S_OK) return -1;

  000d3	85 c0		 test	 eax, eax
  000d5	75 7e		 jne	 SHORT $LN34@StringCLSI

; 74   : 		p_strClsID = OLE2T( oleClsID);

  000d7	8b 7d d8	 mov	 edi, DWORD PTR _oleClsID$1[ebp]
  000da	85 ff		 test	 edi, edi
  000dc	74 4c		 je	 SHORT $LN30@StringCLSI
  000de	8b cf		 mov	 ecx, edi
  000e0	8d 51 02	 lea	 edx, DWORD PTR [ecx+2]
$LL36@StringCLSI:
  000e3	66 8b 01	 mov	 ax, WORD PTR [ecx]
  000e6	83 c1 02	 add	 ecx, 2
  000e9	66 85 c0	 test	 ax, ax
  000ec	75 f5		 jne	 SHORT $LL36@StringCLSI
  000ee	2b ca		 sub	 ecx, edx
  000f0	d1 f9		 sar	 ecx, 1
  000f2	8d 59 01	 lea	 ebx, DWORD PTR [ecx+1]
  000f5	81 fb ff ff ff
	3f		 cmp	 ebx, 1073741823		; 3fffffffH
  000fb	7f 2d		 jg	 SHORT $LN30@StringCLSI
  000fd	03 db		 add	 ebx, ebx
  000ff	8b c3		 mov	 eax, ebx
  00101	e8 00 00 00 00	 call	 __alloca_probe_16
  00106	8b f4		 mov	 esi, esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlconv.h

; 591  : 	if (lpa == NULL || lpw == NULL)

  00108	85 f6		 test	 esi, esi
  0010a	74 1e		 je	 SHORT $LN30@StringCLSI

; 592  : 		return NULL;
; 593  : 	// verify that no illegal character present
; 594  : 	// since lpa was allocated based on the size of lpw
; 595  : 	// don't worry about the number of chars
; 596  : 	*lpa = '\0';
; 597  : 	int ret = WideCharToMultiByte(acp, 0, lpw, -1, lpa, nChars, NULL, NULL);

  0010c	6a 00		 push	 0
  0010e	6a 00		 push	 0
  00110	53		 push	 ebx
  00111	56		 push	 esi
  00112	6a ff		 push	 -1
  00114	57		 push	 edi
  00115	6a 00		 push	 0
  00117	6a 03		 push	 3
  00119	c6 06 00	 mov	 BYTE PTR [esi], 0
  0011c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32

; 598  : 	if(ret == 0)

  00122	f7 d8		 neg	 eax
  00124	1b c0		 sbb	 eax, eax
  00126	23 c6		 and	 eax, esi

; 599  : 	{
; 600  : 		ATLASSERT(FALSE);
; 601  : 		return NULL;
; 602  : 	}
; 603  : 	return lpa;

  00128	eb 02		 jmp	 SHORT $LN27@StringCLSI
$LN30@StringCLSI:
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\inc\ProgIDInfo.h

; 74   : 		p_strClsID = OLE2T( oleClsID);

  0012a	33 c0		 xor	 eax, eax
$LN27@StringCLSI:
  0012c	8b 4d d4	 mov	 ecx, DWORD PTR _p_strClsID$GSCopy$1$[ebp]
  0012f	50		 push	 eax
  00130	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z

; 75   : 		CoTaskMemFree( oleClsID);

  00136	ff 75 d8	 push	 DWORD PTR _oleClsID$1[ebp]
  00139	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CoTaskMemFree@4

; 108  : 		return 0;

  0013f	33 c0		 xor	 eax, eax

; 109  : 	}

  00141	8d 65 c8	 lea	 esp, DWORD PTR [ebp-56]
  00144	5f		 pop	 edi
  00145	5e		 pop	 esi
  00146	5b		 pop	 ebx
  00147	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0014a	33 cd		 xor	 ecx, ebp
  0014c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00151	8b e5		 mov	 esp, ebp
  00153	5d		 pop	 ebp
  00154	c3		 ret	 0
$LN34@StringCLSI:

; 107  : 		if( lResult < 0) return lResult * 10 - 2;

  00155	b8 f4 ff ff ff	 mov	 eax, -12		; fffffff4H

; 109  : 	}

  0015a	8d 65 c8	 lea	 esp, DWORD PTR [ebp-56]
  0015d	5f		 pop	 edi
  0015e	5e		 pop	 esi
  0015f	5b		 pop	 ebx
  00160	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00163	33 cd		 xor	 ecx, ebp
  00165	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0016a	8b e5		 mov	 esp, ebp
  0016c	5d		 pop	 ebp
  0016d	c3		 ret	 0
?StringCLSIDFromProgID@CProgIDInfo@@SAJPBDAAV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ENDP ; CProgIDInfo::StringCLSIDFromProgID
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\DrCommon\PcTrMng\_SystemUtilManager.cpp
;	COMDAT ?IsRegisteredEx@CSystemUtilManager@@UAGHPBDAAU_GUID@@00@Z
_TEXT	SEGMENT
_filefind$1 = -28					; size = 28
_szRegPath$ = 8						; size = 4
_this$ = 8						; size = 4
$T2 = 12						; size = 4
_szProgID$ = 12						; size = 4
_strOcxFile$ = 16					; size = 4
_clsid$ = 16						; size = 4
_szOcxName$ = 20					; size = 4
_szFullPath$ = 24					; size = 4
?IsRegisteredEx@CSystemUtilManager@@UAGHPBDAAU_GUID@@00@Z PROC ; CSystemUtilManager::IsRegisteredEx, COMDAT

; 170  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 171  : 	if(!IsRegistered(szProgID, clsid)) return FALSE;

  00003	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00006	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00009	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000b	56		 push	 esi
  0000c	ff 75 10	 push	 DWORD PTR _clsid$[ebp]
  0000f	8b 75 0c	 mov	 esi, DWORD PTR _szProgID$[ebp]
  00012	56		 push	 esi
  00013	50		 push	 eax
  00014	ff 11		 call	 DWORD PTR [ecx]
  00016	85 c0		 test	 eax, eax
  00018	75 07		 jne	 SHORT $LN2@IsRegister
  0001a	5e		 pop	 esi

; 201  : }

  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 14 00	 ret	 20			; 00000014H
$LN2@IsRegister:

; 172  : 	
; 173  : 	// 등록은 되어있는데, 파일이 없으면 FALSE를 리턴한다.
; 174  : 	CString strOcxFile;

  00021	8d 4d 10	 lea	 ecx, DWORD PTR _strOcxFile$[ebp]
  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 175  : 	CProgIDInfo::ComServerFromProgID( szProgID, strOcxFile);

  0002a	8d 45 10	 lea	 eax, DWORD PTR _strOcxFile$[ebp]
  0002d	50		 push	 eax
  0002e	56		 push	 esi
  0002f	e8 00 00 00 00	 call	 ?ComServerFromProgID@CProgIDInfo@@SAJPBDAAV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ; CProgIDInfo::ComServerFromProgID
  00034	83 c4 08	 add	 esp, 8

; 176  : 	
; 177  : 	CString szRegPath;

  00037	8d 4d 08	 lea	 ecx, DWORD PTR _szRegPath$[ebp]
  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 178  : 	szRegPath = strOcxFile.Left( strOcxFile.ReverseFind( '\\') + 1);

  00040	6a 5c		 push	 92			; 0000005cH
  00042	8d 4d 10	 lea	 ecx, DWORD PTR _strOcxFile$[ebp]
  00045	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?ReverseFind@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEHD@Z
  0004b	40		 inc	 eax
  0004c	8d 4d 10	 lea	 ecx, DWORD PTR _strOcxFile$[ebp]
  0004f	50		 push	 eax
  00050	8d 45 0c	 lea	 eax, DWORD PTR $T2[ebp]
  00053	50		 push	 eax
  00054	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Left@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBE?AV12@H@Z
  0005a	50		 push	 eax
  0005b	8d 4d 08	 lea	 ecx, DWORD PTR _szRegPath$[ebp]
  0005e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
  00064	8d 4d 0c	 lea	 ecx, DWORD PTR $T2[ebp]
  00067	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 179  : 	szRegPath += szOcxName;

  0006d	ff 75 14	 push	 DWORD PTR _szOcxName$[ebp]
  00070	8d 4d 08	 lea	 ecx, DWORD PTR _szRegPath$[ebp]
  00073	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z

; 180  : 	
; 181  : 	if(szFullPath !=NULL)

  00079	8b 45 18	 mov	 eax, DWORD PTR _szFullPath$[ebp]
  0007c	85 c0		 test	 eax, eax
  0007e	74 12		 je	 SHORT $LN3@IsRegister

; 182  : 	{
; 183  : 		if(szRegPath.CompareNoCase(szFullPath)==0)

  00080	50		 push	 eax
  00081	8d 4d 08	 lea	 ecx, DWORD PTR _szRegPath$[ebp]
  00084	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?CompareNoCase@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEHPBD@Z
  0008a	85 c0		 test	 eax, eax
  0008c	74 04		 je	 SHORT $LN3@IsRegister

; 184  : 		{
; 185  : 			CFileFind filefind;
; 186  : 			if(!filefind.FindFile(szRegPath))
; 187  : 				return FALSE;
; 188  : 			
; 189  : 			return TRUE;
; 190  : 		}
; 191  : 	}
; 192  : 	else
; 193  : 	{
; 194  : 		CFileFind filefind;
; 195  : 		if(!filefind.FindFile(szRegPath))
; 196  : 			return FALSE;
; 197  : 		return TRUE;
; 198  : 	}
; 199  : 	
; 200  : 	return FALSE;

  0008e	33 f6		 xor	 esi, esi
  00090	eb 23		 jmp	 SHORT $LN12@IsRegister
$LN3@IsRegister:
  00092	8d 4d e4	 lea	 ecx, DWORD PTR _filefind$1[ebp]
  00095	e8 00 00 00 00	 call	 ??0CFileFind@@QAE@XZ	; CFileFind::CFileFind
  0009a	6a 00		 push	 0
  0009c	ff 75 08	 push	 DWORD PTR _szRegPath$[ebp]
  0009f	8d 4d e4	 lea	 ecx, DWORD PTR _filefind$1[ebp]
  000a2	e8 00 00 00 00	 call	 ?FindFile@CFileFind@@UAEHPBDK@Z ; CFileFind::FindFile
  000a7	f7 d8		 neg	 eax
  000a9	8d 4d e4	 lea	 ecx, DWORD PTR _filefind$1[ebp]
  000ac	1b f6		 sbb	 esi, esi
  000ae	f7 de		 neg	 esi
  000b0	e8 00 00 00 00	 call	 ??1CFileFind@@UAE@XZ	; CFileFind::~CFileFind
$LN12@IsRegister:
  000b5	8d 4d 08	 lea	 ecx, DWORD PTR _szRegPath$[ebp]
  000b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  000be	8d 4d 10	 lea	 ecx, DWORD PTR _strOcxFile$[ebp]
  000c1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  000c7	8b c6		 mov	 eax, esi
  000c9	5e		 pop	 esi

; 201  : }

  000ca	8b e5		 mov	 esp, ebp
  000cc	5d		 pop	 ebp
  000cd	c2 14 00	 ret	 20			; 00000014H
?IsRegisteredEx@CSystemUtilManager@@UAGHPBDAAU_GUID@@00@Z ENDP ; CSystemUtilManager::IsRegisteredEx
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\DrCommon\PcTrMng\_SystemUtilManager.cpp
;	COMDAT ?DLLRegister@CSystemUtilManager@@UAGHPBD@Z
_TEXT	SEGMENT
_startupInfo$1 = -628					; size = 68
_processInformation$2 = -560				; size = 16
_szErrorMsg$ = -544					; size = 4
_exitCode$3 = -540					; size = 4
_strError$4 = -540					; size = 4
_szParam$ = -536					; size = 4
$T5 = -532						; size = 4
$T6 = -532						; size = 4
_lpMsgBuf$7 = -528					; size = 4
_szPath$8 = -528					; size = 4
_aCurPath$ = -524					; size = 260
_szCommand$ = -264					; size = 260
__$ArrayPad$ = -4					; size = 4
_this$ = 8						; size = 4
_szFileName$ = 12					; size = 4
?DLLRegister@CSystemUtilManager@@UAGHPBD@Z PROC		; CSystemUtilManager::DLLRegister, COMDAT

; 108  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 74 02 00
	00		 sub	 esp, 628		; 00000274H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	8b 5d 0c	 mov	 ebx, DWORD PTR _szFileName$[ebp]

; 109  : 	int			iReturn=0;
; 110  : 	CString		szErrorMsg;

  00017	8d 8d e0 fd ff
	ff		 lea	 ecx, DWORD PTR _szErrorMsg$[ebp]
  0001d	56		 push	 esi
  0001e	57		 push	 edi
  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 111  : 	
; 112  : 	char aCurPath[MAX_PATH]={0,};

  00025	68 04 01 00 00	 push	 260			; 00000104H
  0002a	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _aCurPath$[ebp]
  00030	6a 00		 push	 0
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 _memset
  00038	83 c4 0c	 add	 esp, 12			; 0000000cH

; 113  : 	::GetCurrentDirectory(MAX_PATH, aCurPath);

  0003b	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _aCurPath$[ebp]
  00041	50		 push	 eax
  00042	68 04 01 00 00	 push	 260			; 00000104H
  00047	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentDirectoryA@8

; 114  : 	{
; 115  : 		CString szPath(szFileName);

  0004d	53		 push	 ebx
  0004e	8d 8d f0 fd ff
	ff		 lea	 ecx, DWORD PTR _szPath$8[ebp]
  00054	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z

; 116  : 		int nPos = szPath.ReverseFind('\\');

  0005a	6a 5c		 push	 92			; 0000005cH
  0005c	8d 8d f0 fd ff
	ff		 lea	 ecx, DWORD PTR _szPath$8[ebp]
  00062	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?ReverseFind@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEHD@Z

; 117  : 		if(nPos<0) nPos = szPath.ReverseFind('/');

  00068	85 c0		 test	 eax, eax
  0006a	79 10		 jns	 SHORT $LN20@DLLRegiste
  0006c	6a 2f		 push	 47			; 0000002fH
  0006e	8d 8d f0 fd ff
	ff		 lea	 ecx, DWORD PTR _szPath$8[ebp]
  00074	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?ReverseFind@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEHD@Z

; 118  : 		if(nPos>0)

  0007a	85 c0		 test	 eax, eax
$LN20@DLLRegiste:
  0007c	7e 39		 jle	 SHORT $LN3@DLLRegiste

; 119  : 		{
; 120  : 			szPath = szPath.Left(nPos);

  0007e	50		 push	 eax
  0007f	8d 85 ec fd ff
	ff		 lea	 eax, DWORD PTR $T6[ebp]
  00085	50		 push	 eax
  00086	8d 8d f0 fd ff
	ff		 lea	 ecx, DWORD PTR _szPath$8[ebp]
  0008c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Left@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBE?AV12@H@Z
  00092	50		 push	 eax
  00093	8d 8d f0 fd ff
	ff		 lea	 ecx, DWORD PTR _szPath$8[ebp]
  00099	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
  0009f	8d 8d ec fd ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  000a5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 121  : 			::SetCurrentDirectory(szPath);

  000ab	ff b5 f0 fd ff
	ff		 push	 DWORD PTR _szPath$8[ebp]
  000b1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetCurrentDirectoryA@4
$LN3@DLLRegiste:

; 122  : 		}
; 123  : 	}

  000b7	8d 8d f0 fd ff
	ff		 lea	 ecx, DWORD PTR _szPath$8[ebp]
  000bd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 124  : 
; 125  : 	char szCommand[MAX_PATH];
; 126  : 	::GetWindowsDirectory(szCommand, MAX_PATH);

  000c3	68 04 01 00 00	 push	 260			; 00000104H
  000c8	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szCommand$[ebp]
  000ce	50		 push	 eax
  000cf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowsDirectoryA@8

; 127  : 	strcat(szCommand, "\\System32\\regsvr32.exe");

  000d5	8d bd f8 fe ff
	ff		 lea	 edi, DWORD PTR _szCommand$[ebp]
  000db	4f		 dec	 edi
  000dc	0f 1f 40 00	 npad	 4
$LL17@DLLRegiste:
  000e0	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  000e3	47		 inc	 edi
  000e4	84 c0		 test	 al, al
  000e6	75 f8		 jne	 SHORT $LL17@DLLRegiste
  000e8	b9 05 00 00 00	 mov	 ecx, 5
  000ed	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_0BH@OANCKEIH@?2System32?2regsvr32?4exe@
  000f2	f3 a5		 rep movsd

; 128  : 
; 129  : 	CString szParam;

  000f4	8d 8d e8 fd ff
	ff		 lea	 ecx, DWORD PTR _szParam$[ebp]
  000fa	66 a5		 movsw
  000fc	a4		 movsb
  000fd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 130  : 	szParam.Format(" /s \"%s\"", szFileName);

  00103	53		 push	 ebx
  00104	8d 85 e8 fd ff
	ff		 lea	 eax, DWORD PTR _szParam$[ebp]
  0010a	68 00 00 00 00	 push	 OFFSET ??_C@_08LMJFGFMJ@?5?1s?5?$CC?$CFs?$CC@
  0010f	50		 push	 eax
  00110	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Format@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAAXPBDZZ

; 131  : 	strcat(szCommand, szParam);	

  00116	8b 95 e8 fd ff
	ff		 mov	 edx, DWORD PTR _szParam$[ebp]
  0011c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0011f	8b f2		 mov	 esi, edx
$LL18@DLLRegiste:
  00121	8a 02		 mov	 al, BYTE PTR [edx]
  00123	42		 inc	 edx
  00124	84 c0		 test	 al, al
  00126	75 f9		 jne	 SHORT $LL18@DLLRegiste
  00128	8d bd f8 fe ff
	ff		 lea	 edi, DWORD PTR _szCommand$[ebp]
  0012e	2b d6		 sub	 edx, esi
  00130	4f		 dec	 edi
$LL19@DLLRegiste:
  00131	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  00134	47		 inc	 edi
  00135	84 c0		 test	 al, al
  00137	75 f8		 jne	 SHORT $LL19@DLLRegiste
  00139	8b ca		 mov	 ecx, edx

; 132  : 
; 133  : 	CheckExeRun( szCommand, FALSE );

  0013b	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szCommand$[ebp]
  00141	c1 e9 02	 shr	 ecx, 2
  00144	f3 a5		 rep movsd
  00146	8b ca		 mov	 ecx, edx
  00148	83 e1 03	 and	 ecx, 3
  0014b	f3 a4		 rep movsb
  0014d	50		 push	 eax
  0014e	8d 8d ec fd ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  00154	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z

; 206  : 	STARTUPINFO startupInfo                = {0};

  0015a	6a 44		 push	 68			; 00000044H
  0015c	8d 85 8c fd ff
	ff		 lea	 eax, DWORD PTR _startupInfo$1[ebp]
  00162	0f 57 c0	 xorps	 xmm0, xmm0
  00165	6a 00		 push	 0
  00167	50		 push	 eax
  00168	0f 11 85 d0 fd
	ff ff		 movups	 XMMWORD PTR _processInformation$2[ebp], xmm0
  0016f	e8 00 00 00 00	 call	 _memset
  00174	83 c4 0c	 add	 esp, 12			; 0000000cH

; 207  : 	startupInfo.cb                         = sizeof(startupInfo);

  00177	c7 85 8c fd ff
	ff 44 00 00 00	 mov	 DWORD PTR _startupInfo$1[ebp], 68 ; 00000044H

; 208  : 	if( _bShow == FALSE) startupInfo.wShowWindow = SW_HIDE;

  00181	33 c0		 xor	 eax, eax
  00183	66 89 85 bc fd
	ff ff		 mov	 WORD PTR _startupInfo$1[ebp+48], ax

; 209  : 	
; 210  : 	// Create the process
; 211  : 	BOOL result = CreateProcess( NULL, (LPTSTR)(LPCTSTR)szCmdLine, 

  0018a	8d 85 d0 fd ff
	ff		 lea	 eax, DWORD PTR _processInformation$2[ebp]
  00190	50		 push	 eax
  00191	8d 85 8c fd ff
	ff		 lea	 eax, DWORD PTR _startupInfo$1[ebp]
  00197	50		 push	 eax
  00198	6a 00		 push	 0
  0019a	6a 00		 push	 0
  0019c	68 20 00 00 08	 push	 134217760		; 08000020H
  001a1	6a 00		 push	 0
  001a3	6a 00		 push	 0
  001a5	6a 00		 push	 0
  001a7	ff b5 ec fd ff
	ff		 push	 DWORD PTR $T5[ebp]
  001ad	6a 00		 push	 0
  001af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateProcessA@40

; 212  : 		NULL, NULL, FALSE, 
; 213  : 		NORMAL_PRIORITY_CLASS | CREATE_NO_WINDOW, 
; 214  : 		NULL, NULL, &startupInfo, &processInformation);
; 215  : 	
; 216  : 	if (!result)

  001b5	85 c0		 test	 eax, eax
  001b7	75 50		 jne	 SHORT $LN11@DLLRegiste

; 217  : 	{
; 218  : 		// CreateProcess() failed
; 219  : 		// Get the error from the system
; 220  : 		LPVOID lpMsgBuf;
; 221  : 		DWORD dw = GetLastError();

  001b9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0

; 222  : 		FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, 

  001bf	6a 00		 push	 0
  001c1	6a 00		 push	 0
  001c3	8d 8d f0 fd ff
	ff		 lea	 ecx, DWORD PTR _lpMsgBuf$7[ebp]
  001c9	51		 push	 ecx
  001ca	68 00 04 00 00	 push	 1024			; 00000400H
  001cf	50		 push	 eax
  001d0	6a 00		 push	 0
  001d2	68 00 13 00 00	 push	 4864			; 00001300H
  001d7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FormatMessageA@28

; 223  : 			NULL, dw, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR) &lpMsgBuf, 0, NULL);
; 224  : 		
; 225  : 		// Display the error
; 226  : 		CString strError = (LPTSTR) lpMsgBuf;

  001dd	ff b5 f0 fd ff
	ff		 push	 DWORD PTR _lpMsgBuf$7[ebp]
  001e3	8d 8d e4 fd ff
	ff		 lea	 ecx, DWORD PTR _strError$4[ebp]
  001e9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z

; 227  : 		TRACE(_T("::executeCommandLine() failed at CreateProcess()\nCommand=%s\nMessage=%s\n\n"), szCmdLine, strError);
; 228  : 		
; 229  : 		// Free resources created by the system
; 230  : 		LocalFree(lpMsgBuf);

  001ef	ff b5 f0 fd ff
	ff		 push	 DWORD PTR _lpMsgBuf$7[ebp]
  001f5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LocalFree@4

; 231  : 		
; 232  : 		// We failed.
; 233  : 		return FALSE;

  001fb	8d 8d e4 fd ff
	ff		 lea	 ecx, DWORD PTR _strError$4[ebp]
  00201	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00207	eb 37		 jmp	 SHORT $LN13@DLLRegiste
$LN11@DLLRegiste:

; 234  : 	}
; 235  : 	else
; 236  : 	{
; 237  : 		DWORD  exitCode;
; 238  : 		
; 239  : 		// Successfully created the process.  Wait for it to finish.
; 240  : 		WaitForSingleObject( processInformation.hProcess, INFINITE );

  00209	6a ff		 push	 -1
  0020b	ff b5 d0 fd ff
	ff		 push	 DWORD PTR _processInformation$2[ebp]
  00211	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8

; 241  : 		
; 242  : 		// Get the exit code.
; 243  : 		result = GetExitCodeProcess(processInformation.hProcess, &exitCode);

  00217	8d 85 e4 fd ff
	ff		 lea	 eax, DWORD PTR _exitCode$3[ebp]
  0021d	50		 push	 eax
  0021e	ff b5 d0 fd ff
	ff		 push	 DWORD PTR _processInformation$2[ebp]
  00224	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetExitCodeProcess@8

; 244  : 		
; 245  : 		// Close the handles.
; 246  : 		CloseHandle( processInformation.hProcess );

  0022a	ff b5 d0 fd ff
	ff		 push	 DWORD PTR _processInformation$2[ebp]
  00230	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__CloseHandle@4
  00236	ff d6		 call	 esi

; 247  : 		CloseHandle( processInformation.hThread );

  00238	ff b5 d4 fd ff
	ff		 push	 DWORD PTR _processInformation$2[ebp+4]
  0023e	ff d6		 call	 esi
$LN13@DLLRegiste:

; 132  : 
; 133  : 	CheckExeRun( szCommand, FALSE );

  00240	8d 8d ec fd ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  00246	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 134  : 
; 135  : // 	SHELLEXECUTEINFO shExlf = { 0 };
; 136  : // 	shExlf.cbSize = sizeof(SHELLEXECUTEINFO);
; 137  : // 	shExlf.fMask = 0;
; 138  : // 	shExlf.lpVerb = _T("open");
; 139  : // 	shExlf.lpFile = (LPSTR)(LPCTSTR)szCommand;
; 140  : // 	shExlf.nShow = SW_HIDE;
; 141  : // 	shExlf.lpParameters = (LPSTR)(LPCTSTR)szParam;
; 142  : // 	
; 143  : // 	ShellExecuteEx(&shExlf);
; 144  : // 	::SetCurrentDirectory(aCurPath);
; 145  : 	
; 146  : 	return iReturn;

  0024c	8d 8d e8 fd ff
	ff		 lea	 ecx, DWORD PTR _szParam$[ebp]
  00252	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00258	8d 8d e0 fd ff
	ff		 lea	 ecx, DWORD PTR _szErrorMsg$[ebp]
  0025e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 147  : }

  00264	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00267	33 c0		 xor	 eax, eax
  00269	5f		 pop	 edi
  0026a	5e		 pop	 esi
  0026b	33 cd		 xor	 ecx, ebp
  0026d	5b		 pop	 ebx
  0026e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00273	8b e5		 mov	 esp, ebp
  00275	5d		 pop	 ebp
  00276	c2 08 00	 ret	 8
?DLLRegister@CSystemUtilManager@@UAGHPBD@Z ENDP		; CSystemUtilManager::DLLRegister
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\DrCommon\PcTrMng\_SystemUtilManager.cpp
;	COMDAT ?IsRegistered@CSystemUtilManager@@UAGHPBDAAU_GUID@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_szProgID$ = 12						; size = 4
_clsid$ = 16						; size = 4
?IsRegistered@CSystemUtilManager@@UAGHPBDAAU_GUID@@@Z PROC ; CSystemUtilManager::IsRegistered, COMDAT

; 19   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 20   : 	HRESULT hr = AfxGetClassIDFromString(szProgID, &clsid);

  00003	ff 75 10	 push	 DWORD PTR _clsid$[ebp]
  00006	ff 75 0c	 push	 DWORD PTR _szProgID$[ebp]
  00009	e8 00 00 00 00	 call	 ?AfxGetClassIDFromString@@YGJPBDPAU_GUID@@@Z ; AfxGetClassIDFromString

; 21   : 	if (FAILED(hr))		return FALSE;

  0000e	33 c9		 xor	 ecx, ecx
  00010	85 c0		 test	 eax, eax
  00012	0f 99 c1	 setns	 cl
  00015	8b c1		 mov	 eax, ecx

; 22   : 	return TRUE;
; 23   : }

  00017	5d		 pop	 ebp
  00018	c2 0c 00	 ret	 12			; 0000000cH
?IsRegistered@CSystemUtilManager@@UAGHPBDAAU_GUID@@@Z ENDP ; CSystemUtilManager::IsRegistered
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\DrCommon\PcTrMng\_SystemUtilManager.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\DrCommon\PcTrMng\_SystemUtilManager.cpp
;	COMDAT ?CheckExeRun@CSystemUtilManager@@AAEHABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z
_TEXT	SEGMENT
_startupInfo$ = -88					; size = 68
_processInformation$ = -20				; size = 16
_strError$1 = -4					; size = 4
_exitCode$2 = 8						; size = 4
_lpMsgBuf$3 = 8						; size = 4
_szCmdLine$ = 8						; size = 4
__bShow$ = 12						; size = 4
?CheckExeRun@CSystemUtilManager@@AAEHABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z PROC ; CSystemUtilManager::CheckExeRun, COMDAT
; _this$ = ecx

; 204  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\atlmfc\include\atlsimpstr.h

; 377  : 		return( m_pszData );

  00006	8b 45 08	 mov	 eax, DWORD PTR _szCmdLine$[ebp]
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\DrCommon\PcTrMng\_SystemUtilManager.cpp

; 211  : 	BOOL result = CreateProcess( NULL, (LPTSTR)(LPCTSTR)szCmdLine, 

  00009	8d 4d ec	 lea	 ecx, DWORD PTR _processInformation$[ebp]
  0000c	51		 push	 ecx
  0000d	8d 4d a8	 lea	 ecx, DWORD PTR _startupInfo$[ebp]
  00010	c7 45 a8 44 00
	00 00		 mov	 DWORD PTR _startupInfo$[ebp], 68 ; 00000044H
  00017	51		 push	 ecx
  00018	6a 00		 push	 0
  0001a	6a 00		 push	 0
  0001c	68 20 00 00 08	 push	 134217760		; 08000020H
  00021	6a 00		 push	 0
  00023	0f 57 c0	 xorps	 xmm0, xmm0
  00026	6a 00		 push	 0
  00028	6a 00		 push	 0
  0002a	ff 30		 push	 DWORD PTR [eax]
  0002c	0f 11 45 ec	 movups	 XMMWORD PTR _processInformation$[ebp], xmm0
  00030	6a 00		 push	 0
  00032	66 0f 13 45 ac	 movlpd	 QWORD PTR _startupInfo$[ebp+4], xmm0
  00037	66 0f 13 45 b4	 movlpd	 QWORD PTR _startupInfo$[ebp+12], xmm0
  0003c	66 0f 13 45 bc	 movlpd	 QWORD PTR _startupInfo$[ebp+20], xmm0
  00041	66 0f 13 45 c4	 movlpd	 QWORD PTR _startupInfo$[ebp+28], xmm0
  00046	66 0f 13 45 cc	 movlpd	 QWORD PTR _startupInfo$[ebp+36], xmm0
  0004b	66 0f 13 45 d4	 movlpd	 QWORD PTR _startupInfo$[ebp+44], xmm0
  00050	66 0f 13 45 dc	 movlpd	 QWORD PTR _startupInfo$[ebp+52], xmm0
  00055	66 0f 13 45 e4	 movlpd	 QWORD PTR _startupInfo$[ebp+60], xmm0
  0005a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateProcessA@40

; 212  : 		NULL, NULL, FALSE, 
; 213  : 		NORMAL_PRIORITY_CLASS | CREATE_NO_WINDOW, 
; 214  : 		NULL, NULL, &startupInfo, &processInformation);
; 215  : 	
; 216  : 	if (!result)

  00060	85 c0		 test	 eax, eax
  00062	75 47		 jne	 SHORT $LN3@CheckExeRu

; 217  : 	{
; 218  : 		// CreateProcess() failed
; 219  : 		// Get the error from the system
; 220  : 		LPVOID lpMsgBuf;
; 221  : 		DWORD dw = GetLastError();

  00064	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0

; 222  : 		FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, 

  0006a	6a 00		 push	 0
  0006c	6a 00		 push	 0
  0006e	8d 4d 08	 lea	 ecx, DWORD PTR _lpMsgBuf$3[ebp]
  00071	51		 push	 ecx
  00072	68 00 04 00 00	 push	 1024			; 00000400H
  00077	50		 push	 eax
  00078	6a 00		 push	 0
  0007a	68 00 13 00 00	 push	 4864			; 00001300H
  0007f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FormatMessageA@28

; 223  : 			NULL, dw, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR) &lpMsgBuf, 0, NULL);
; 224  : 		
; 225  : 		// Display the error
; 226  : 		CString strError = (LPTSTR) lpMsgBuf;

  00085	ff 75 08	 push	 DWORD PTR _lpMsgBuf$3[ebp]
  00088	8d 4d fc	 lea	 ecx, DWORD PTR _strError$1[ebp]
  0008b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z

; 227  : 		TRACE(_T("::executeCommandLine() failed at CreateProcess()\nCommand=%s\nMessage=%s\n\n"), szCmdLine, strError);
; 228  : 		
; 229  : 		// Free resources created by the system
; 230  : 		LocalFree(lpMsgBuf);

  00091	ff 75 08	 push	 DWORD PTR _lpMsgBuf$3[ebp]
  00094	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LocalFree@4

; 231  : 		
; 232  : 		// We failed.
; 233  : 		return FALSE;

  0009a	8d 4d fc	 lea	 ecx, DWORD PTR _strError$1[ebp]
  0009d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  000a3	33 c0		 xor	 eax, eax

; 250  : 		{
; 251  : 			// Could not get exit code.
; 252  : 			TRACE(_T("Executed command but couldn't get exit code.\nCommand=%s\n"), szCmdLine);
; 253  : 			return FALSE;
; 254  : 		}
; 255  : 		// We succeeded.
; 256  : 		return TRUE;
; 257  : 	}
; 258  : }

  000a5	8b e5		 mov	 esp, ebp
  000a7	5d		 pop	 ebp
  000a8	c2 08 00	 ret	 8
$LN3@CheckExeRu:
  000ab	57		 push	 edi

; 234  : 	}
; 235  : 	else
; 236  : 	{
; 237  : 		DWORD  exitCode;
; 238  : 		
; 239  : 		// Successfully created the process.  Wait for it to finish.
; 240  : 		WaitForSingleObject( processInformation.hProcess, INFINITE );

  000ac	6a ff		 push	 -1
  000ae	ff 75 ec	 push	 DWORD PTR _processInformation$[ebp]
  000b1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8

; 241  : 		
; 242  : 		// Get the exit code.
; 243  : 		result = GetExitCodeProcess(processInformation.hProcess, &exitCode);

  000b7	8d 45 08	 lea	 eax, DWORD PTR _exitCode$2[ebp]
  000ba	50		 push	 eax
  000bb	ff 75 ec	 push	 DWORD PTR _processInformation$[ebp]
  000be	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetExitCodeProcess@8

; 244  : 		
; 245  : 		// Close the handles.
; 246  : 		CloseHandle( processInformation.hProcess );

  000c4	ff 75 ec	 push	 DWORD PTR _processInformation$[ebp]
  000c7	8b f8		 mov	 edi, eax
  000c9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 247  : 		CloseHandle( processInformation.hThread );

  000cf	ff 75 f0	 push	 DWORD PTR _processInformation$[ebp+4]
  000d2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 248  : 		
; 249  : 		if (!result)

  000d8	33 c0		 xor	 eax, eax
  000da	85 ff		 test	 edi, edi
  000dc	5f		 pop	 edi
  000dd	0f 95 c0	 setne	 al

; 250  : 		{
; 251  : 			// Could not get exit code.
; 252  : 			TRACE(_T("Executed command but couldn't get exit code.\nCommand=%s\n"), szCmdLine);
; 253  : 			return FALSE;
; 254  : 		}
; 255  : 		// We succeeded.
; 256  : 		return TRUE;
; 257  : 	}
; 258  : }

  000e0	8b e5		 mov	 esp, ebp
  000e2	5d		 pop	 ebp
  000e3	c2 08 00	 ret	 8
?CheckExeRun@CSystemUtilManager@@AAEHABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z ENDP ; CSystemUtilManager::CheckExeRun
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\inc\IAUGwanMng.h
;	COMDAT ??__ERMSG_GWANSIMREGISTER@@YAXXZ
text$di	SEGMENT
??__ERMSG_GWANSIMREGISTER@@YAXXZ PROC			; `dynamic initializer for 'RMSG_GWANSIMREGISTER'', COMDAT

; 173  : const UINT RMSG_GWANSIMREGISTER		=   ::RegisterWindowMessage("RMSG_GWANSIMREGISTER");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@MNPNIDPI@RMSG_GWANSIMREGISTER@
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegisterWindowMessageA@4
  0000b	a3 00 00 00 00	 mov	 DWORD PTR ?RMSG_GWANSIMREGISTER@@3IB, eax
  00010	c3		 ret	 0
??__ERMSG_GWANSIMREGISTER@@YAXXZ ENDP			; `dynamic initializer for 'RMSG_GWANSIMREGISTER''
text$di	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\inc\Define_Gwansim.h
;	COMDAT ??__ERMSG_INTREQUEST@@YAXXZ
text$di	SEGMENT
??__ERMSG_INTREQUEST@@YAXXZ PROC			; `dynamic initializer for 'RMSG_INTREQUEST'', COMDAT

; 10   : const UINT RMSG_INTREQUEST = ::RegisterWindowMessage(_T("RMSG_INTREQUEST") );

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JHANHJCN@RMSG_INTREQUEST@
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegisterWindowMessageA@4
  0000b	a3 00 00 00 00	 mov	 DWORD PTR ?RMSG_INTREQUEST@@3IB, eax
  00010	c3		 ret	 0
??__ERMSG_INTREQUEST@@YAXXZ ENDP			; `dynamic initializer for 'RMSG_INTREQUEST''
text$di	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\inc\Define_Gwansim.h
;	COMDAT ??__ERMSG_CONCERNHWND@@YAXXZ
text$di	SEGMENT
??__ERMSG_CONCERNHWND@@YAXXZ PROC			; `dynamic initializer for 'RMSG_CONCERNHWND'', COMDAT

; 9    : const UINT RMSG_CONCERNHWND = ::RegisterWindowMessage(_T("RMSG_CONCERNHWND") );

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@EPGJDGDK@RMSG_CONCERNHWND@
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegisterWindowMessageA@4
  0000b	a3 00 00 00 00	 mov	 DWORD PTR ?RMSG_CONCERNHWND@@3IB, eax
  00010	c3		 ret	 0
??__ERMSG_CONCERNHWND@@YAXXZ ENDP			; `dynamic initializer for 'RMSG_CONCERNHWND''
text$di	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Inc\IBaseDefine.h
;	COMDAT ??__ERMSG_SETPCTRDATA@@YAXXZ
text$di	SEGMENT
??__ERMSG_SETPCTRDATA@@YAXXZ PROC			; `dynamic initializer for 'RMSG_SETPCTRDATA'', COMDAT

; 172  : const UINT RMSG_SETPCTRDATA = ::RegisterWindowMessage("RMSG_SETPCTRDATA");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@JPACFCL@RMSG_SETPCTRDATA@
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegisterWindowMessageA@4
  0000b	a3 00 00 00 00	 mov	 DWORD PTR ?RMSG_SETPCTRDATA@@3IB, eax
  00010	c3		 ret	 0
??__ERMSG_SETPCTRDATA@@YAXXZ ENDP			; `dynamic initializer for 'RMSG_SETPCTRDATA''
text$di	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Inc\IBaseDefine.h
;	COMDAT ??__ERMSG_GETPCTRDATA@@YAXXZ
text$di	SEGMENT
??__ERMSG_GETPCTRDATA@@YAXXZ PROC			; `dynamic initializer for 'RMSG_GETPCTRDATA'', COMDAT

; 171  : const UINT RMSG_GETPCTRDATA = ::RegisterWindowMessage("RMSG_GETPCTRDATA");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@GOOPDKI@RMSG_GETPCTRDATA@
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegisterWindowMessageA@4
  0000b	a3 00 00 00 00	 mov	 DWORD PTR ?RMSG_GETPCTRDATA@@3IB, eax
  00010	c3		 ret	 0
??__ERMSG_GETPCTRDATA@@YAXXZ ENDP			; `dynamic initializer for 'RMSG_GETPCTRDATA''
text$di	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\Inc\IBaseDefine.h
;	COMDAT ??__ERMSG_INTERFACE@@YAXXZ
text$di	SEGMENT
??__ERMSG_INTERFACE@@YAXXZ PROC				; `dynamic initializer for 'RMSG_INTERFACE'', COMDAT

; 170  : const UINT RMSG_INTERFACE = ::RegisterWindowMessage("RMSG_INTERFACE");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0P@BKKCOCLK@RMSG_INTERFACE@
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegisterWindowMessageA@4
  0000b	a3 00 00 00 00	 mov	 DWORD PTR ?RMSG_INTERFACE@@3IB, eax
  00010	c3		 ret	 0
??__ERMSG_INTERFACE@@YAXXZ ENDP				; `dynamic initializer for 'RMSG_INTERFACE''
text$di	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\DrCommon\PcTrMng\_SystemUtilManager.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	c2 00 00	 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\git\src\IBK\IBK_DRFN\ProjSrc\SrcDrfn\DrCommon\PcTrMng\_SystemUtilManager.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

  00000	c2 00 00	 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
